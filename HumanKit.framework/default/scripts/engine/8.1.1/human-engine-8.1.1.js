/*
 * SceneJS V4.2.2
 *
 * A WebGL-based 3D scene graph from xeoLabs
 * http://scenejs.org/
 *
 * Built on 2016-08-02
 *
 * MIT License
 * Copyright 2016, Lindsay Kay
 * http://xeolabs.com/
 *
 */

/*
 * SceneJS Latest
 *
 * A WebGL-based 3D scene graph from xeoLabs
 * http://scenejs.org/
 *
 * MIT License
 * Copyright 2015, Lindsay Kay
 * http://xeolabs.com/
 *
 */

;// Only define RequireJS if not already present
if (undefined === require) {;/*
 RequireJS 2.1.6 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/requirejs for details
 */
var requirejs,require,define;
(function(ba){function J(b){return"[object Function]"===N.call(b)}function K(b){return"[object Array]"===N.call(b)}function z(b,c){if(b){var d;for(d=0;d<b.length&&(!b[d]||!c(b[d],d,b));d+=1);}}function O(b,c){if(b){var d;for(d=b.length-1;-1<d&&(!b[d]||!c(b[d],d,b));d-=1);}}function t(b,c){return ha.call(b,c)}function m(b,c){return t(b,c)&&b[c]}function H(b,c){for(var d in b)if(t(b,d)&&c(b[d],d))break}function S(b,c,d,m){c&&H(c,function(c,l){if(d||!t(b,l))m&&"string"!==typeof c?(b[l]||(b[l]={}),S(b[l],
    c,d,m)):b[l]=c});return b}function v(b,c){return function(){return c.apply(b,arguments)}}function ca(b){throw b;}function da(b){if(!b)return b;var c=ba;z(b.split("."),function(b){c=c[b]});return c}function B(b,c,d,m){c=Error(c+"\nhttp://requirejs.org/docs/errors.html#"+b);c.requireType=b;c.requireModules=m;d&&(c.originalError=d);return c}function ia(b){function c(a,f,C){var e,n,b,c,d,T,k,g=f&&f.split("/");e=g;var l=j.map,h=l&&l["*"];if(a&&"."===a.charAt(0))if(f){e=m(j.pkgs,f)?g=[f]:g.slice(0,g.length-
    1);f=a=e.concat(a.split("/"));for(e=0;f[e];e+=1)if(n=f[e],"."===n)f.splice(e,1),e-=1;else if(".."===n)if(1===e&&(".."===f[2]||".."===f[0]))break;else 0<e&&(f.splice(e-1,2),e-=2);e=m(j.pkgs,f=a[0]);a=a.join("/");e&&a===f+"/"+e.main&&(a=f)}else 0===a.indexOf("./")&&(a=a.substring(2));if(C&&l&&(g||h)){f=a.split("/");for(e=f.length;0<e;e-=1){b=f.slice(0,e).join("/");if(g)for(n=g.length;0<n;n-=1)if(C=m(l,g.slice(0,n).join("/")))if(C=m(C,b)){c=C;d=e;break}if(c)break;!T&&(h&&m(h,b))&&(T=m(h,b),k=e)}!c&&
    T&&(c=T,d=k);c&&(f.splice(0,d,c),a=f.join("/"))}return a}function d(a){A&&z(document.getElementsByTagName("script"),function(f){if(f.getAttribute("data-requiremodule")===a&&f.getAttribute("data-requirecontext")===k.contextName)return f.parentNode.removeChild(f),!0})}function p(a){var f=m(j.paths,a);if(f&&K(f)&&1<f.length)return d(a),f.shift(),k.require.undef(a),k.require([a]),!0}function g(a){var f,b=a?a.indexOf("!"):-1;-1<b&&(f=a.substring(0,b),a=a.substring(b+1,a.length));return[f,a]}function l(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          f,b,e){var n,D,i=null,d=f?f.name:null,l=a,h=!0,j="";a||(h=!1,a="_@r"+(N+=1));a=g(a);i=a[0];a=a[1];i&&(i=c(i,d,e),D=m(r,i));a&&(i?j=D&&D.normalize?D.normalize(a,function(a){return c(a,d,e)}):c(a,d,e):(j=c(a,d,e),a=g(j),i=a[0],j=a[1],b=!0,n=k.nameToUrl(j)));b=i&&!D&&!b?"_unnormalized"+(O+=1):"";return{prefix:i,name:j,parentMap:f,unnormalized:!!b,url:n,originalName:l,isDefine:h,id:(i?i+"!"+j:j)+b}}function s(a){var f=a.id,b=m(q,f);b||(b=q[f]=new k.Module(a));return b}function u(a,f,b){var e=a.id,n=m(q,
    e);if(t(r,e)&&(!n||n.defineEmitComplete))"defined"===f&&b(r[e]);else if(n=s(a),n.error&&"error"===f)b(n.error);else n.on(f,b)}function w(a,f){var b=a.requireModules,e=!1;if(f)f(a);else if(z(b,function(f){if(f=m(q,f))f.error=a,f.events.error&&(e=!0,f.emit("error",a))}),!e)h.onError(a)}function x(){U.length&&(ja.apply(I,[I.length-1,0].concat(U)),U=[])}function y(a){delete q[a];delete W[a]}function G(a,f,b){var e=a.map.id;a.error?a.emit("error",a.error):(f[e]=!0,z(a.depMaps,function(e,c){var d=e.id,
    g=m(q,d);g&&(!a.depMatched[c]&&!b[d])&&(m(f,d)?(a.defineDep(c,r[d]),a.check()):G(g,f,b))}),b[e]=!0)}function E(){var a,f,b,e,n=(b=1E3*j.waitSeconds)&&k.startTime+b<(new Date).getTime(),c=[],i=[],g=!1,l=!0;if(!X){X=!0;H(W,function(b){a=b.map;f=a.id;if(b.enabled&&(a.isDefine||i.push(b),!b.error))if(!b.inited&&n)p(f)?g=e=!0:(c.push(f),d(f));else if(!b.inited&&(b.fetched&&a.isDefine)&&(g=!0,!a.prefix))return l=!1});if(n&&c.length)return b=B("timeout","Load timeout for modules: "+c,null,c),b.contextName=
    k.contextName,w(b);l&&z(i,function(a){G(a,{},{})});if((!n||e)&&g)if((A||ea)&&!Y)Y=setTimeout(function(){Y=0;E()},50);X=!1}}function F(a){t(r,a[0])||s(l(a[0],null,!0)).init(a[1],a[2])}function L(a){var a=a.currentTarget||a.srcElement,b=k.onScriptLoad;a.detachEvent&&!Z?a.detachEvent("onreadystatechange",b):a.removeEventListener("load",b,!1);b=k.onScriptError;(!a.detachEvent||Z)&&a.removeEventListener("error",b,!1);return{node:a,id:a&&a.getAttribute("data-requiremodule")}}function M(){var a;for(x();I.length;){a=
    I.shift();if(null===a[0])return w(B("mismatch","Mismatched anonymous define() module: "+a[a.length-1]));F(a)}}var X,$,k,P,Y,j={waitSeconds:7,baseUrl:"./",paths:{},pkgs:{},shim:{},config:{}},q={},W={},aa={},I=[],r={},V={},N=1,O=1;P={require:function(a){return a.require?a.require:a.require=k.makeRequire(a.map)},exports:function(a){a.usingExports=!0;if(a.map.isDefine)return a.exports?a.exports:a.exports=r[a.map.id]={}},module:function(a){return a.module?a.module:a.module={id:a.map.id,uri:a.map.url,config:function(){var b=
    m(j.pkgs,a.map.id);return(b?m(j.config,a.map.id+"/"+b.main):m(j.config,a.map.id))||{}},exports:r[a.map.id]}}};$=function(a){this.events=m(aa,a.id)||{};this.map=a;this.shim=m(j.shim,a.id);this.depExports=[];this.depMaps=[];this.depMatched=[];this.pluginMaps={};this.depCount=0};$.prototype={init:function(a,b,c,e){e=e||{};if(!this.inited){this.factory=b;if(c)this.on("error",c);else this.events.error&&(c=v(this,function(a){this.emit("error",a)}));this.depMaps=a&&a.slice(0);this.errback=c;this.inited=
    !0;this.ignore=e.ignore;e.enabled||this.enabled?this.enable():this.check()}},defineDep:function(a,b){this.depMatched[a]||(this.depMatched[a]=!0,this.depCount-=1,this.depExports[a]=b)},fetch:function(){if(!this.fetched){this.fetched=!0;k.startTime=(new Date).getTime();var a=this.map;if(this.shim)k.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],v(this,function(){return a.prefix?this.callPlugin():this.load()}));else return a.prefix?this.callPlugin():this.load()}},load:function(){var a=
    this.map.url;V[a]||(V[a]=!0,k.load(this.map.id,a))},check:function(){if(this.enabled&&!this.enabling){var a,b,c=this.map.id;b=this.depExports;var e=this.exports,n=this.factory;if(this.inited)if(this.error)this.emit("error",this.error);else{if(!this.defining){this.defining=!0;if(1>this.depCount&&!this.defined){if(J(n)){if(this.events.error&&this.map.isDefine||h.onError!==ca)try{e=k.execCb(c,n,b,e)}catch(d){a=d}else e=k.execCb(c,n,b,e);this.map.isDefine&&((b=this.module)&&void 0!==b.exports&&b.exports!==
    this.exports?e=b.exports:void 0===e&&this.usingExports&&(e=this.exports));if(a)return a.requireMap=this.map,a.requireModules=this.map.isDefine?[this.map.id]:null,a.requireType=this.map.isDefine?"define":"require",w(this.error=a)}else e=n;this.exports=e;if(this.map.isDefine&&!this.ignore&&(r[c]=e,h.onResourceLoad))h.onResourceLoad(k,this.map,this.depMaps);y(c);this.defined=!0}this.defining=!1;this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit("defined",this.exports),this.defineEmitComplete=
    !0)}}else this.fetch()}},callPlugin:function(){var a=this.map,b=a.id,d=l(a.prefix);this.depMaps.push(d);u(d,"defined",v(this,function(e){var n,d;d=this.map.name;var g=this.map.parentMap?this.map.parentMap.name:null,C=k.makeRequire(a.parentMap,{enableBuildCallback:!0});if(this.map.unnormalized){if(e.normalize&&(d=e.normalize(d,function(a){return c(a,g,!0)})||""),e=l(a.prefix+"!"+d,this.map.parentMap),u(e,"defined",v(this,function(a){this.init([],function(){return a},null,{enabled:!0,ignore:!0})})),
    d=m(q,e.id)){this.depMaps.push(e);if(this.events.error)d.on("error",v(this,function(a){this.emit("error",a)}));d.enable()}}else n=v(this,function(a){this.init([],function(){return a},null,{enabled:!0})}),n.error=v(this,function(a){this.inited=!0;this.error=a;a.requireModules=[b];H(q,function(a){0===a.map.id.indexOf(b+"_unnormalized")&&y(a.map.id)});w(a)}),n.fromText=v(this,function(e,c){var d=a.name,g=l(d),i=Q;c&&(e=c);i&&(Q=!1);s(g);t(j.config,b)&&(j.config[d]=j.config[b]);try{h.exec(e)}catch(D){return w(B("fromtexteval",
    "fromText eval for "+b+" failed: "+D,D,[b]))}i&&(Q=!0);this.depMaps.push(g);k.completeLoad(d);C([d],n)}),e.load(a.name,C,n,j)}));k.enable(d,this);this.pluginMaps[d.id]=d},enable:function(){W[this.map.id]=this;this.enabling=this.enabled=!0;z(this.depMaps,v(this,function(a,b){var c,e;if("string"===typeof a){a=l(a,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap);this.depMaps[b]=a;if(c=m(P,a.id)){this.depExports[b]=c(this);return}this.depCount+=1;u(a,"defined",v(this,function(a){this.defineDep(b,
    a);this.check()}));this.errback&&u(a,"error",v(this,this.errback))}c=a.id;e=q[c];!t(P,c)&&(e&&!e.enabled)&&k.enable(a,this)}));H(this.pluginMaps,v(this,function(a){var b=m(q,a.id);b&&!b.enabled&&k.enable(a,this)}));this.enabling=!1;this.check()},on:function(a,b){var c=this.events[a];c||(c=this.events[a]=[]);c.push(b)},emit:function(a,b){z(this.events[a],function(a){a(b)});"error"===a&&delete this.events[a]}};k={config:j,contextName:b,registry:q,defined:r,urlFetched:V,defQueue:I,Module:$,makeModuleMap:l,
    nextTick:h.nextTick,onError:w,configure:function(a){a.baseUrl&&"/"!==a.baseUrl.charAt(a.baseUrl.length-1)&&(a.baseUrl+="/");var b=j.pkgs,c=j.shim,e={paths:!0,config:!0,map:!0};H(a,function(a,b){e[b]?"map"===b?(j.map||(j.map={}),S(j[b],a,!0,!0)):S(j[b],a,!0):j[b]=a});a.shim&&(H(a.shim,function(a,b){K(a)&&(a={deps:a});if((a.exports||a.init)&&!a.exportsFn)a.exportsFn=k.makeShimExports(a);c[b]=a}),j.shim=c);a.packages&&(z(a.packages,function(a){a="string"===typeof a?{name:a}:a;b[a.name]={name:a.name,
        location:a.location||a.name,main:(a.main||"main").replace(ka,"").replace(fa,"")}}),j.pkgs=b);H(q,function(a,b){!a.inited&&!a.map.unnormalized&&(a.map=l(b))});if(a.deps||a.callback)k.require(a.deps||[],a.callback)},makeShimExports:function(a){return function(){var b;a.init&&(b=a.init.apply(ba,arguments));return b||a.exports&&da(a.exports)}},makeRequire:function(a,f){function d(e,c,g){var i,j;f.enableBuildCallback&&(c&&J(c))&&(c.__requireJsBuild=!0);if("string"===typeof e){if(J(c))return w(B("requireargs",
        "Invalid require call"),g);if(a&&t(P,e))return P[e](q[a.id]);if(h.get)return h.get(k,e,a,d);i=l(e,a,!1,!0);i=i.id;return!t(r,i)?w(B("notloaded",'Module name "'+i+'" has not been loaded yet for context: '+b+(a?"":". Use require([])"))):r[i]}M();k.nextTick(function(){M();j=s(l(null,a));j.skipMap=f.skipMap;j.init(e,c,g,{enabled:!0});E()});return d}f=f||{};S(d,{isBrowser:A,toUrl:function(b){var d,f=b.lastIndexOf("."),g=b.split("/")[0];if(-1!==f&&(!("."===g||".."===g)||1<f))d=b.substring(f,b.length),b=
        b.substring(0,f);return k.nameToUrl(c(b,a&&a.id,!0),d,!0)},defined:function(b){return t(r,l(b,a,!1,!0).id)},specified:function(b){b=l(b,a,!1,!0).id;return t(r,b)||t(q,b)}});a||(d.undef=function(b){x();var c=l(b,a,!0),d=m(q,b);delete r[b];delete V[c.url];delete aa[b];d&&(d.events.defined&&(aa[b]=d.events),y(b))});return d},enable:function(a){m(q,a.id)&&s(a).enable()},completeLoad:function(a){var b,c,e=m(j.shim,a)||{},d=e.exports;for(x();I.length;){c=I.shift();if(null===c[0]){c[0]=a;if(b)break;b=!0}else c[0]===
        a&&(b=!0);F(c)}c=m(q,a);if(!b&&!t(r,a)&&c&&!c.inited){if(j.enforceDefine&&(!d||!da(d)))return p(a)?void 0:w(B("nodefine","No define call for "+a,null,[a]));F([a,e.deps||[],e.exportsFn])}E()},nameToUrl:function(a,b,c){var d,g,l,i,k,p;if(h.jsExtRegExp.test(a))i=a+(b||"");else{d=j.paths;g=j.pkgs;i=a.split("/");for(k=i.length;0<k;k-=1)if(p=i.slice(0,k).join("/"),l=m(g,p),p=m(d,p)){K(p)&&(p=p[0]);i.splice(0,k,p);break}else if(l){a=a===l.name?l.location+"/"+l.main:l.location;i.splice(0,k,a);break}i=i.join("/");
        i+=b||(/\?/.test(i)||c?"":".js");i=("/"===i.charAt(0)||i.match(/^[\w\+\.\-]+:/)?"":j.baseUrl)+i}return j.urlArgs?i+((-1===i.indexOf("?")?"?":"&")+j.urlArgs):i},load:function(a,b){h.load(k,a,b)},execCb:function(a,b,c,d){return b.apply(d,c)},onScriptLoad:function(a){if("load"===a.type||la.test((a.currentTarget||a.srcElement).readyState))R=null,a=L(a),k.completeLoad(a.id)},onScriptError:function(a){var b=L(a);if(!p(b.id))return w(B("scripterror","Script error for: "+b.id,a,[b.id]))}};k.require=k.makeRequire();
    return k}var h,x,y,E,L,F,R,M,s,ga,ma=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,na=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,fa=/\.js$/,ka=/^\.\//;x=Object.prototype;var N=x.toString,ha=x.hasOwnProperty,ja=Array.prototype.splice,A=!!("undefined"!==typeof window&&navigator&&window.document),ea=!A&&"undefined"!==typeof importScripts,la=A&&"PLAYSTATION 3"===navigator.platform?/^complete$/:/^(complete|loaded)$/,Z="undefined"!==typeof opera&&"[object Opera]"===opera.toString(),G={},u={},U=[],Q=
    !1;if("undefined"===typeof define){if("undefined"!==typeof requirejs){if(J(requirejs))return;u=requirejs;requirejs=void 0}"undefined"!==typeof require&&!J(require)&&(u=require,require=void 0);h=requirejs=function(b,c,d,p){var g,l="_";!K(b)&&"string"!==typeof b&&(g=b,K(c)?(b=c,c=d,d=p):b=[]);g&&g.context&&(l=g.context);(p=m(G,l))||(p=G[l]=h.s.newContext(l));g&&p.configure(g);return p.require(b,c,d)};h.config=function(b){return h(b)};h.nextTick="undefined"!==typeof setTimeout?function(b){setTimeout(b,
    4)}:function(b){b()};require||(require=h);h.version="2.1.6";h.jsExtRegExp=/^\/|:|\?|\.js$/;h.isBrowser=A;x=h.s={contexts:G,newContext:ia};h({});z(["toUrl","undef","defined","specified"],function(b){h[b]=function(){var c=G._;return c.require[b].apply(c,arguments)}});if(A&&(y=x.head=document.getElementsByTagName("head")[0],E=document.getElementsByTagName("base")[0]))y=x.head=E.parentNode;h.onError=ca;h.load=function(b,c,d){var h=b&&b.config||{},g;if(A)return g=h.xhtml?document.createElementNS("http://www.w3.org/1999/xhtml",
    "html:script"):document.createElement("script"),g.type=h.scriptType||"text/javascript",g.charset="utf-8",g.async=!0,g.setAttribute("data-requirecontext",b.contextName),g.setAttribute("data-requiremodule",c),g.attachEvent&&!(g.attachEvent.toString&&0>g.attachEvent.toString().indexOf("[native code"))&&!Z?(Q=!0,g.attachEvent("onreadystatechange",b.onScriptLoad)):(g.addEventListener("load",b.onScriptLoad,!1),g.addEventListener("error",b.onScriptError,!1)),g.src=d,M=g,E?y.insertBefore(g,E):y.appendChild(g),
    M=null,g;if(ea)try{importScripts(d),b.completeLoad(c)}catch(l){b.onError(B("importscripts","importScripts failed for "+c+" at "+d,l,[c]))}};A&&O(document.getElementsByTagName("script"),function(b){y||(y=b.parentNode);if(L=b.getAttribute("data-main"))return s=L,u.baseUrl||(F=s.split("/"),s=F.pop(),ga=F.length?F.join("/")+"/":"./",u.baseUrl=ga),s=s.replace(fa,""),h.jsExtRegExp.test(s)&&(s=L),u.deps=u.deps?u.deps.concat(s):[s],!0});define=function(b,c,d){var h,g;"string"!==typeof b&&(d=c,c=b,b=null);
    K(c)||(d=c,c=null);!c&&J(d)&&(c=[],d.length&&(d.toString().replace(ma,"").replace(na,function(b,d){c.push(d)}),c=(1===d.length?["require"]:["require","exports","module"]).concat(c)));if(Q){if(!(h=M))R&&"interactive"===R.readyState||O(document.getElementsByTagName("script"),function(b){if("interactive"===b.readyState)return R=b}),h=R;h&&(b||(b=h.getAttribute("data-requiremodule")),g=G[h.getAttribute("data-requirecontext")])}(g?g.defQueue:U).push([b,c,d])};define.amd={jQuery:!0};h.exec=function(b){return eval(b)};
    h(u)}})(this);;};
WebGLDebugUtils = function() {

/**
 * Wrapped logging function.
 * @param {string} msg Message to log.
 */
var log = function(msg) {
  if (window.console && window.console.log) {
    window.console.log(msg);
  }
};

/**
 * Which arguements are enums.
 * @type {!Object.<number, string>}
 */
var glValidEnumContexts = {

  // Generic setters and getters

  'enable': { 0:true },
  'disable': { 0:true },
  'getParameter': { 0:true },

  // Rendering

  'drawArrays': { 0:true },
  'drawElements': { 0:true, 2:true },

  // Shaders

  'createShader': { 0:true },
  'getShaderParameter': { 1:true },
  'getProgramParameter': { 1:true },

  // Vertex attributes

  'getVertexAttrib': { 1:true },
  'vertexAttribPointer': { 2:true },

  // Textures

  'bindTexture': { 0:true },
  'activeTexture': { 0:true },
  'getTexParameter': { 0:true, 1:true },
  'texParameterf': { 0:true, 1:true },
  'texParameteri': { 0:true, 1:true, 2:true },
  'texImage2D': { 0:true, 2:true, 6:true, 7:true },
  'texSubImage2D': { 0:true, 6:true, 7:true },
  'copyTexImage2D': { 0:true, 2:true },
  'copyTexSubImage2D': { 0:true },
  'generateMipmap': { 0:true },

  // Buffer objects

  'bindBuffer': { 0:true },
  'bufferData': { 0:true, 2:true },
  'bufferSubData': { 0:true },
  'getBufferParameter': { 0:true, 1:true },

  // Renderbuffers and framebuffers

  'pixelStorei': { 0:true, 1:true },
  'readPixels': { 4:true, 5:true },
  'bindRenderbuffer': { 0:true },
  'bindFramebuffer': { 0:true },
  'checkFramebufferStatus': { 0:true },
  'framebufferRenderbuffer': { 0:true, 1:true, 2:true },
  'framebufferTexture2D': { 0:true, 1:true, 2:true },
  'getFramebufferAttachmentParameter': { 0:true, 1:true, 2:true },
  'getRenderbufferParameter': { 0:true, 1:true },
  'renderbufferStorage': { 0:true, 1:true },

  // Frame buffer operations (clear, blend, depth test, stencil)

  'clear': { 0:true },
  'depthFunc': { 0:true },
  'blendFunc': { 0:true, 1:true },
  'blendFuncSeparate': { 0:true, 1:true, 2:true, 3:true },
  'blendEquation': { 0:true },
  'blendEquationSeparate': { 0:true, 1:true },
  'stencilFunc': { 0:true },
  'stencilFuncSeparate': { 0:true, 1:true },
  'stencilMaskSeparate': { 0:true },
  'stencilOp': { 0:true, 1:true, 2:true },
  'stencilOpSeparate': { 0:true, 1:true, 2:true, 3:true },

  // Culling

  'cullFace': { 0:true },
  'frontFace': { 0:true },
};

/**
 * Map of numbers to names.
 * @type {Object}
 */
var glEnums = null;

/**
 * Initializes this module. Safe to call more than once.
 * @param {!WebGLRenderingContext} ctx A WebGL context. If
 *    you have more than one context it doesn't matter which one
 *    you pass in, it is only used to pull out constants.
 */
function init(ctx) {
  if (glEnums == null) {
    glEnums = { };
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'number') {
        glEnums[ctx[propertyName]] = propertyName;
      }
    }
  }
}

/**
 * Checks the utils have been initialized.
 */
function checkInit() {
  if (glEnums == null) {
    throw 'WebGLDebugUtils.init(ctx) not called';
  }
}

/**
 * Returns true or false if value matches any WebGL enum
 * @param {*} value Value to check if it might be an enum.
 * @return {boolean} True if value matches one of the WebGL defined enums
 */
function mightBeEnum(value) {
  checkInit();
  return (glEnums[value] !== undefined);
}

/**
 * Gets an string version of an WebGL enum.
 *
 * Example:
 *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
 *
 * @param {number} value Value to return an enum for
 * @return {string} The string version of the enum.
 */
function glEnumToString(value) {
  checkInit();
  var name = glEnums[value];
  return (name !== undefined) ? name :
      ("*UNKNOWN WebGL ENUM (0x" + value.toString(16) + ")");
}

/**
 * Returns the string version of a WebGL argument.
 * Attempts to convert enum arguments to strings.
 * @param {string} functionName the name of the WebGL function.
 * @param {number} argumentIndx the index of the argument.
 * @param {*} value The value of the argument.
 * @return {string} The value as a string.
 */
function glFunctionArgToString(functionName, argumentIndex, value) {
  var funcInfo = glValidEnumContexts[functionName];
  if (funcInfo !== undefined) {
    if (funcInfo[argumentIndex]) {
      return glEnumToString(value);
    }
  }
  if (value === null) {
    return "null";
  } else if (value === undefined) {
    return "undefined";
  } else {
    return value.toString();
  }
}

/**
 * Converts the arguments of a WebGL function to a string.
 * Attempts to convert enum arguments to strings.
 *
 * @param {string} functionName the name of the WebGL function.
 * @param {number} args The arguments.
 * @return {string} The arguments as a string.
 */
function glFunctionArgsToString(functionName, args) {
  // apparently we can't do args.join(",");
  var argStr = "";
  for (var ii = 0; ii < args.length; ++ii) {
    argStr += ((ii == 0) ? '' : ', ') +
        glFunctionArgToString(functionName, ii, args[ii]);
  }
  return argStr;
};


function makePropertyWrapper(wrapper, original, propertyName) {
  //log("wrap prop: " + propertyName);
  wrapper.__defineGetter__(propertyName, function() {
    return original[propertyName];
  });
  // TODO(gmane): this needs to handle properties that take more than
  // one value?
  wrapper.__defineSetter__(propertyName, function(value) {
    //log("set: " + propertyName);
    original[propertyName] = value;
  });
}

// Makes a function that calls a function on another object.
function makeFunctionWrapper(original, functionName) {
  //log("wrap fn: " + functionName);
  var f = original[functionName];
  return function() {
    //log("call: " + functionName);
    var result = f.apply(original, arguments);
    return result;
  };
}

/**
 * Given a WebGL context returns a wrapped context that calls
 * gl.getError after every command and calls a function if the
 * result is not gl.NO_ERROR.
 *
 * @param {!WebGLRenderingContext} ctx The webgl context to
 *        wrap.
 * @param {!function(err, funcName, args): void} opt_onErrorFunc
 *        The function to call when gl.getError returns an
 *        error. If not specified the default function calls
 *        console.log with a message.
 * @param {!function(funcName, args): void} opt_onFunc The
 *        function to call when each webgl function is called.
 *        You can use this to log all calls for example.
 */
function makeDebugContext(ctx, opt_onErrorFunc, opt_onFunc) {
  init(ctx);
  opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
        // apparently we can't do args.join(",");
        var argStr = "";
        for (var ii = 0; ii < args.length; ++ii) {
          argStr += ((ii == 0) ? '' : ', ') +
              glFunctionArgToString(functionName, ii, args[ii]);
        }
        log("WebGL error "+ glEnumToString(err) + " in "+ functionName +
            "(" + argStr + ")");
      };

  // Holds booleans for each GL error so after we get the error ourselves
  // we can still return it to the client app.
  var glErrorShadow = { };

  // Makes a function that calls a WebGL function and then calls getError.
  function makeErrorWrapper(ctx, functionName) {
    return function() {
      if (opt_onFunc) {
        opt_onFunc(functionName, arguments);
      }
      var result = ctx[functionName].apply(ctx, arguments);
      var err = ctx.getError();
      if (err != 0) {
        glErrorShadow[err] = true;
        opt_onErrorFunc(err, functionName, arguments);
      }
      return result;
    };
  }

  // Make a an object that has a copy of every property of the WebGL context
  // but wraps all functions.
  var wrapper = {};
  for (var propertyName in ctx) {
    if (typeof ctx[propertyName] == 'function') {
       wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);
     } else {
       makePropertyWrapper(wrapper, ctx, propertyName);
     }
  }

  // Override the getError function with one that returns our saved results.
  wrapper.getError = function() {
    for (var err in glErrorShadow) {
      if (glErrorShadow.hasOwnProperty(err)) {
        if (glErrorShadow[err]) {
          glErrorShadow[err] = false;
          return err;
        }
      }
    }
    return ctx.NO_ERROR;
  };

  return wrapper;
}

function resetToInitialState(ctx) {
  var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
  var tmp = ctx.createBuffer();
  ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
  for (var ii = 0; ii < numAttribs; ++ii) {
    ctx.disableVertexAttribArray(ii);
    ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
    ctx.vertexAttrib1f(ii, 0);
  }
  ctx.deleteBuffer(tmp);

  var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
  for (var ii = 0; ii < numTextureUnits; ++ii) {
    ctx.activeTexture(ctx.TEXTURE0 + ii);
    ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
    ctx.bindTexture(ctx.TEXTURE_2D, null);
  }

  ctx.activeTexture(ctx.TEXTURE0);
  ctx.useProgram(null);
  ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
  ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
  ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
  ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
  ctx.disable(ctx.BLEND);
  ctx.disable(ctx.CULL_FACE);
  ctx.disable(ctx.DEPTH_TEST);
  ctx.disable(ctx.DITHER);
  ctx.disable(ctx.SCISSOR_TEST);
  ctx.blendColor(0, 0, 0, 0);
  ctx.blendEquation(ctx.FUNC_ADD);
  ctx.blendFunc(ctx.ONE, ctx.ZERO);
  ctx.clearColor(0, 0, 0, 0);
  ctx.clearDepth(1);
  ctx.clearStencil(-1);
  ctx.colorMask(true, true, true, true);
  ctx.cullFace(ctx.BACK);
  ctx.depthFunc(ctx.LESS);
  ctx.depthMask(true);
  ctx.depthRange(0, 1);
  ctx.frontFace(ctx.CCW);
  ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
  ctx.lineWidth(1);
  ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
  ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
  ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
  // TODO: Delete this IF.
  if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
    ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
  }
  ctx.polygonOffset(0, 0);
  ctx.sampleCoverage(1, false);
  ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);
  ctx.stencilMask(0xFFFFFFFF);
  ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
  ctx.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
  ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);

  // TODO: This should NOT be needed but Firefox fails with 'hint'
  while(ctx.getError());
}

function makeLostContextSimulatingCanvas(canvas) {
  var unwrappedContext_;
  var wrappedContext_;
  var onLost_ = [];
  var onRestored_ = [];
  var wrappedContext_ = {};
  var contextId_ = 1;
  var contextLost_ = false;
  var resourceId_ = 0;
  var resourceDb_ = [];
  var numCallsToLoseContext_ = 0;
  var numCalls_ = 0;
  var canRestore_ = false;
  var restoreTimeout_ = 0;

  // Holds booleans for each GL error so can simulate errors.
  var glErrorShadow_ = { };

  canvas.getContext = function(f) {
    return function() {
      var ctx = f.apply(canvas, arguments);
      // Did we get a context and is it a WebGL context?
      if (ctx instanceof WebGLRenderingContext) {
        if (ctx != unwrappedContext_) {
          if (unwrappedContext_) {
            throw "got different context"
          }
          unwrappedContext_ = ctx;
          wrappedContext_ = makeLostContextSimulatingContext(unwrappedContext_);
        }
        return wrappedContext_;
      }
      return ctx;
    }
  }(canvas.getContext);

  function wrapEvent(listener) {
    if (typeof(listener) == "function") {
      return listener;
    } else {
      return function(info) {
        listener.handleEvent(info);
      }
    }
  }

  var addOnContextLostListener = function(listener) {
    onLost_.push(wrapEvent(listener));
  };

  var addOnContextRestoredListener = function(listener) {
    onRestored_.push(wrapEvent(listener));
  };


  function wrapAddEventListener(canvas) {
    var f = canvas.addEventListener;
    canvas.addEventListener = function(type, listener, bubble) {
      switch (type) {
        case 'webglcontextlost':
          addOnContextLostListener(listener);
          break;
        case 'webglcontextrestored':
          addOnContextRestoredListener(listener);
          break;
        default:
          f.apply(canvas, arguments);
      }
    };
  }

  wrapAddEventListener(canvas);

  canvas.loseContext = function() {
    if (!contextLost_) {
      contextLost_ = true;
      numCallsToLoseContext_ = 0;
      ++contextId_;
      while (unwrappedContext_.getError());
      clearErrors();
      glErrorShadow_[unwrappedContext_.CONTEXT_LOST_WEBGL] = true;
      var event = makeWebGLContextEvent("context lost");
      var callbacks = onLost_.slice();
      setTimeout(function() {
          //log("numCallbacks:" + callbacks.length);
          for (var ii = 0; ii < callbacks.length; ++ii) {
            //log("calling callback:" + ii);
            callbacks[ii](event);
          }
          if (restoreTimeout_ >= 0) {
            setTimeout(function() {
                canvas.restoreContext();
              }, restoreTimeout_);
          }
        }, 0);
    }
  };

  canvas.restoreContext = function() {
    if (contextLost_) {
      if (onRestored_.length) {
        setTimeout(function() {
            if (!canRestore_) {
              throw "can not restore. webglcontestlost listener did not call event.preventDefault";
            }
            freeResources();
            resetToInitialState(unwrappedContext_);
            contextLost_ = false;
            numCalls_ = 0;
            canRestore_ = false;
            var callbacks = onRestored_.slice();
            var event = makeWebGLContextEvent("context restored");
            for (var ii = 0; ii < callbacks.length; ++ii) {
              callbacks[ii](event);
            }
          }, 0);
      }
    }
  };

  canvas.loseContextInNCalls = function(numCalls) {
    if (contextLost_) {
      throw "You can not ask a lost contet to be lost";
    }
    numCallsToLoseContext_ = numCalls_ + numCalls;
  };

  canvas.getNumCalls = function() {
    return numCalls_;
  };

  canvas.setRestoreTimeout = function(timeout) {
    restoreTimeout_ = timeout;
  };

  function isWebGLObject(obj) {
    //return false;
    return (obj instanceof WebGLBuffer ||
            obj instanceof WebGLFramebuffer ||
            obj instanceof WebGLProgram ||
            obj instanceof WebGLRenderbuffer ||
            obj instanceof WebGLShader ||
            obj instanceof WebGLTexture);
  }

  function checkResources(args) {
    for (var ii = 0; ii < args.length; ++ii) {
      var arg = args[ii];
      if (isWebGLObject(arg)) {
        return arg.__webglDebugContextLostId__ == contextId_;
      }
    }
    return true;
  }

  function clearErrors() {
    var k = Object.keys(glErrorShadow_);
    for (var ii = 0; ii < k.length; ++ii) {
      delete glErrorShadow_[k];
    }
  }

  function loseContextIfTime() {
    ++numCalls_;
    if (!contextLost_) {
      if (numCallsToLoseContext_ == numCalls_) {
        canvas.loseContext();
      }
    }
  }

  // Makes a function that simulates WebGL when out of context.
  function makeLostContextFunctionWrapper(ctx, functionName) {
    var f = ctx[functionName];
    return function() {
      // log("calling:" + functionName);
      // Only call the functions if the context is not lost.
      loseContextIfTime();
      if (!contextLost_) {
        //if (!checkResources(arguments)) {
        //  glErrorShadow_[wrappedContext_.INVALID_OPERATION] = true;
        //  return;
        //}

        var result = f.apply(ctx, arguments);
        return result;
      }
    };
  }

  function freeResources() {
    for (var ii = 0; ii < resourceDb_.length; ++ii) {
      var resource = resourceDb_[ii];
      if (resource instanceof WebGLBuffer) {
        unwrappedContext_.deleteBuffer(resource);
      } else if (resource instanceof WebGLFramebuffer) {
        unwrappedContext_.deleteFramebuffer(resource);
      } else if (resource instanceof WebGLProgram) {
        unwrappedContext_.deleteProgram(resource);
      } else if (resource instanceof WebGLRenderbuffer) {
        unwrappedContext_.deleteRenderbuffer(resource);
      } else if (resource instanceof WebGLShader) {
        unwrappedContext_.deleteShader(resource);
      } else if (resource instanceof WebGLTexture) {
        unwrappedContext_.deleteTexture(resource);
      }
    }
  }

  function makeWebGLContextEvent(statusMessage) {
    return {
      statusMessage: statusMessage,
      preventDefault: function() {
          canRestore_ = true;
        }
    };
  }

  return canvas;

  function makeLostContextSimulatingContext(ctx) {
    // copy all functions and properties to wrapper
    for (var propertyName in ctx) {
      if (typeof ctx[propertyName] == 'function') {
         wrappedContext_[propertyName] = makeLostContextFunctionWrapper(
             ctx, propertyName);
       } else {
         makePropertyWrapper(wrappedContext_, ctx, propertyName);
       }
    }

    // Wrap a few functions specially.
    wrappedContext_.getError = function() {
      loseContextIfTime();
      if (!contextLost_) {
        var err;
        while (err = unwrappedContext_.getError()) {
          glErrorShadow_[err] = true;
        }
      }
      for (var err in glErrorShadow_) {
        if (glErrorShadow_[err]) {
          delete glErrorShadow_[err];
          return err;
        }
      }
      return wrappedContext_.NO_ERROR;
    };

    var creationFunctions = [
      "createBuffer",
      "createFramebuffer",
      "createProgram",
      "createRenderbuffer",
      "createShader",
      "createTexture"
    ];
    for (var ii = 0; ii < creationFunctions.length; ++ii) {
      var functionName = creationFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          var obj = f.apply(ctx, arguments);
          obj.__webglDebugContextLostId__ = contextId_;
          resourceDb_.push(obj);
          return obj;
        };
      }(ctx[functionName]);
    }

    var functionsThatShouldReturnNull = [
      "getActiveAttrib",
      "getActiveUniform",
      "getBufferParameter",
      "getContextAttributes",
      "getAttachedShaders",
      "getFramebufferAttachmentParameter",
      "getParameter",
      "getProgramParameter",
      "getProgramInfoLog",
      "getRenderbufferParameter",
      "getShaderParameter",
      "getShaderInfoLog",
      "getShaderSource",
      "getTexParameter",
      "getUniform",
      "getUniformLocation",
      "getVertexAttrib"
    ];
    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
      var functionName = functionsThatShouldReturnNull[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return null;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    var isFunctions = [
      "isBuffer",
      "isEnabled",
      "isFramebuffer",
      "isProgram",
      "isRenderbuffer",
      "isShader",
      "isTexture"
    ];
    for (var ii = 0; ii < isFunctions.length; ++ii) {
      var functionName = isFunctions[ii];
      wrappedContext_[functionName] = function(f) {
        return function() {
          loseContextIfTime();
          if (contextLost_) {
            return false;
          }
          return f.apply(ctx, arguments);
        }
      }(wrappedContext_[functionName]);
    }

    wrappedContext_.checkFramebufferStatus = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return wrappedContext_.FRAMEBUFFER_UNSUPPORTED;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.checkFramebufferStatus);

    wrappedContext_.getAttribLocation = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return -1;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getAttribLocation);

    wrappedContext_.getVertexAttribOffset = function(f) {
      return function() {
        loseContextIfTime();
        if (contextLost_) {
          return 0;
        }
        return f.apply(ctx, arguments);
      };
    }(wrappedContext_.getVertexAttribOffset);

    wrappedContext_.isContextLost = function() {
      return contextLost_;
    };

    return wrappedContext_;
  }
}

return {
    /**
     * Initializes this module. Safe to call more than once.
     * @param {!WebGLRenderingContext} ctx A WebGL context. If
    }
   *    you have more than one context it doesn't matter which one
   *    you pass in, it is only used to pull out constants.
   */
  'init': init,

  /**
   * Returns true or false if value matches any WebGL enum
   * @param {*} value Value to check if it might be an enum.
   * @return {boolean} True if value matches one of the WebGL defined enums
   */
  'mightBeEnum': mightBeEnum,

  /**
   * Gets an string version of an WebGL enum.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());
   *
   * @param {number} value Value to return an enum for
   * @return {string} The string version of the enum.
   */
  'glEnumToString': glEnumToString,

  /**
   * Converts the argument of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * Example:
   *   WebGLDebugUtil.init(ctx);
   *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);
   *
   * would return 'TEXTURE_2D'
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} argumentIndx the index of the argument.
   * @param {*} value The value of the argument.
   * @return {string} The value as a string.
   */
  'glFunctionArgToString': glFunctionArgToString,

  /**
   * Converts the arguments of a WebGL function to a string.
   * Attempts to convert enum arguments to strings.
   *
   * @param {string} functionName the name of the WebGL function.
   * @param {number} args The arguments.
   * @return {string} The arguments as a string.
   */
  'glFunctionArgsToString': glFunctionArgsToString,

  /**
   * Given a WebGL context returns a wrapped context that calls
   * gl.getError after every command and calls a function if the
   * result is not NO_ERROR.
   *
   * You can supply your own function if you want. For example, if you'd like
   * an exception thrown on any GL error you could do this
   *
   *    function throwOnGLError(err, funcName, args) {
   *      throw WebGLDebugUtils.glEnumToString(err) +
   *            " was caused by call to " + funcName;
   *    };
   *
   *    ctx = WebGLDebugUtils.makeDebugContext(
   *        canvas.getContext("webgl"), throwOnGLError);
   *
   * @param {!WebGLRenderingContext} ctx The webgl context to wrap.
   * @param {!function(err, funcName, args): void} opt_onErrorFunc The function
   *     to call when gl.getError returns an error. If not specified the default
   *     function calls console.log with a message.
   * @param {!function(funcName, args): void} opt_onFunc The
   *     function to call when each webgl function is called. You
   *     can use this to log all calls for example.
   */
  'makeDebugContext': makeDebugContext,

  /**
   * Given a canvas element returns a wrapped canvas element that will
   * simulate lost context. The canvas returned adds the following functions.
   *
   * loseContext:
   *   simulates a lost context event.
   *
   * restoreContext:
   *   simulates the context being restored.
   *
   * lostContextInNCalls:
   *   loses the context after N gl calls.
   *
   * getNumCalls:
   *   tells you how many gl calls there have been so far.
   *
   * setRestoreTimeout:
   *   sets the number of milliseconds until the context is restored
   *   after it has been lost. Defaults to 0. Pass -1 to prevent
   *   automatic restoring.
   *
   * @param {!Canvas} canvas The canvas element to wrap.
   */
  'makeLostContextSimulatingCanvas': makeLostContextSimulatingCanvas,

  /**
   * Resets a context to the initial state.
   * @param {!WebGLRenderingContext} ctx The webgl context to
   *     reset.
   */
  'resetToInitialState': resetToInitialState
};

}();
;/**
 * @class Generic map of IDs to items - can generate own IDs or accept given IDs. IDs should be strings in order to not
 * clash with internally generated IDs, which are numbers.
 * @private
 */
var SceneJS_Map = function(items, _baseId) {

    /**
     * @property Items in this map
     */
    this.items = items || [];


    var baseId = _baseId || 0;
    var lastUniqueId = baseId + 1;

    /**
     * Adds an item to the map and returns the ID of the item in the map. If an ID is given, the item is
     * mapped to that ID. Otherwise, the map automatically generates the ID and maps to that.
     *
     * id = myMap.addItem("foo") // ID internally generated
     *
     * id = myMap.addItem("foo", "bar") // ID is "foo"
     *
     */
    this.addItem = function() {

        var item;

        if (arguments.length == 2) {

            var id = arguments[0];

            item = arguments[1];

            if (this.items[id]) { // Won't happen if given ID is string
                throw SceneJS_error.fatalError(SceneJS.errors.ID_CLASH, "ID clash: '" + id + "'");
            }

            this.items[id] = item;

            return id;

        } else {

            while (true) {

                item = arguments[0];
                var findId = lastUniqueId++;

                if (!this.items[findId]) {
                    this.items[findId] = item;
                    return findId;
                }
            }
        }
    };

    /**
     * Removes the item of the given ID from the map
     */
    this.removeItem = function(id) {
        delete this.items[id];
    };
};;/**
 * The SceneJS object.
 */
var SceneJS = new (function () {

    /**
     * This SceneJS version
     */
    this.VERSION = '3.2';

    this._baseStateId = 0;

    // Pub/sub support
    this._handleMap = new SceneJS_Map(); // Subscription handle pool
    this._topicSubs = {}; // A [handle -> callback] map for each topic name
    this._handleTopics = {}; // Maps handles to topic names
    this._topicPubs = {}; // Maps topics to publications

    /**
     * @property {SceneJS_Engine} Engines currently in existance
     */
    this._engines = {};

    this._engineIds = new SceneJS_Map();

    this.WEBGL_INFO = (function() {
        var info = {
            WEBGL: false
        };

        var canvas = document.createElement("canvas");

        if (!canvas) {
            return info;
        }

        var gl = canvas.getContext("webgl", { stencil:true, antialias: true }) || canvas.getContext("experimental-webgl", { antialias: true });

        info.WEBGL = !!gl;

        if (!info.WEBGL) {
            return info;
        }

        info.ANTIALIAS = gl.getContextAttributes().antialias;

        if (gl.getShaderPrecisionFormat) {
            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                info.FS_MAX_FLOAT_PRECISION = "highp";
            } else if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                info.FS_MAX_FLOAT_PRECISION = "mediump";
            } else {
                info.FS_MAX_FLOAT_PRECISION = "lowp";
            }
        } else {
            info.FS_MAX_FLOAT_PRECISION = "mediump";
        }

        info.DEPTH_BUFFER_BITS = gl.getParameter(gl.DEPTH_BITS);
        info.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        info.MAX_CUBE_MAP_SIZE = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        info.MAX_RENDERBUFFER_SIZE = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
        info.MAX_TEXTURE_UNITS =  gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        info.MAX_VERTEX_ATTRIBS = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        info.MAX_VERTEX_UNIFORM_VECTORS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        info.MAX_FRAGMENT_UNIFORM_VECTORS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        info.MAX_VARYING_VECTORS = gl.getParameter(gl.MAX_VARYING_VECTORS);

        info.SUPPORTED_EXTENSIONS = {};

        gl.getSupportedExtensions().forEach(function(ext) {
            info.SUPPORTED_EXTENSIONS[ext] = true;
        });

        return info;
    })();

    /**
     * Publishes to a topic.
     *
     * Immediately notifies existing subscriptions to that topic, retains the publication to give to
     * any subsequent notifications on that topic as they are made.
     *
     * @param {String} topic Publication topic
     * @param {Object} pub The publication
     * @param {Boolean} [forget] When true, the publication will be sent to subscribers then forgotten, so that any
     * subsequent subscribers will not receive it
     * @private
     */
    this.publish = function (topic, pub, forget) {
        if (!forget) {
            this._topicPubs[topic] = pub; // Save notification
        }
        var subsForTopic = this._topicSubs[topic];
        if (subsForTopic) { // Notify subscriptions
            for (var handle in subsForTopic) {
                if (subsForTopic.hasOwnProperty(handle)) {
                    subsForTopic[handle].call(this, pub);
                }
            }
        }
    };

    /**
     * Removes a topic publication
     *
     * Immediately notifies existing subscriptions to that topic, sending them each a null publication.
     *
     * @param topic Publication topic
     * @private
     */
    this.unpublish = function (topic) {
        var subsForTopic = this._topicSubs[topic];
        if (subsForTopic) { // Notify subscriptions
            for (var handle in subsForTopic) {
                if (subsForTopic.hasOwnProperty(handle)) {
                    subsForTopic[handle].call(this, null);
                }
            }
        }
        delete this._topicPubs[topic];
    };


    /**
     * Listen for data changes at a particular location
     *
     * <p>Your callback will be triggered for
     * the initial data and again whenever the data changes. Use {@link #off} to stop receiving updates.</p>
     *
     * <p>The callback is be called with SceneJS as scope.</p>
     *
     * @param {String} location Publication location
     * @param {Function(data)} callback Called when fresh data is available at the location
     * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
     */
    this.on = function (topic, callback) {
        var subsForTopic = this._topicSubs[topic];
        if (!subsForTopic) {
            subsForTopic = {};
            this._topicSubs[topic] = subsForTopic;
        }
        var handle = this._handleMap.addItem(); // Create unique handle
        subsForTopic[handle] = callback;
        this._handleTopics[handle] = topic;
        var pub = this._topicPubs[topic];
        if (pub) { // A publication exists, notify callback immediately
            callback.call(this, pub);
        }
        return handle;
    };

    /**
     * Unsubscribes from a publication that was previously made with {@link #on}.
     * @param handle Publication handle
     */
    this.off = function (handle) {
        var topic = this._handleTopics[handle];
        if (topic) {
            delete this._handleTopics[handle];
            var topicSubs = this._topicSubs[topic];
            if (topicSubs) {
                delete topicSubs[handle];
            }
            this._handleMap.removeItem(handle); // Release handle
            if (topic == "rendered") {
                this._engine.branchDirty(this);
            }
        }
    };

    /**
     * Listens for exactly one data update at the specified location, and then stops listening.
     * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
     * @param {String} location Data location to listen to
     * @param {Function(data)} callback Called when fresh data is available at the location
     */
    this.once = function (topic, callback) {
        var self = this;
        var sub = this.on(topic,
            function (pub) {
                self.off(sub);
                callback(pub);
            });
    };

    /**
     * Creates a new scene from the given JSON description and begins rendering it
     *
     * @param {String} json JSON scene description
     * @param {*} options Optional options
     * @param {Boolean} options.simulateWebGLContextLost Set true to enable simulation of lost WebGL context (has performance impact)
     * @returns {SceneJS.Scene} New scene
     */
    this.createScene = function (json, options) {

       json = json || {};

        if (json.id) {
            if (this._engines[json.id]) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "Scene already exists with this ID: '" + json.id + "'");
            }
            this._engineIds.addItem(json.id, {});
        } else {
            json.id = this._engineIds.addItem({});
        }

        var engine = new SceneJS_Engine(json, options);

        this._engines[json.id] = engine;

        SceneJS_events.fireEvent(SceneJS_events.SCENE_CREATED, {    // Notify modules that need to know about new scene
            engine:engine
        });

        engine.scene.start(options);

        return engine.scene;
    };

    /**
     * Gets an existing scene
     *
     * @param {String} sceneId ID of target scene
     * @deprecated
     * @returns {SceneJS.Scene} The selected scene
     */
    this.scene = function (sceneId) {

        var engine = this._engines[sceneId];

        return engine ? engine.scene : null;
    };

    /**
     * Gets an existing scene.
     *
     * When no scene ID is given, the first scene found is returned. This is a shorthand convenience for
     * easy scripting when only one scene is defined.
     *
     * @param {String} [sceneId] ID of target scene
     * @returns {SceneJS.Scene} The selected scene
     */
    this.getScene = function (sceneId) {

        if (!sceneId) {
            for (var sceneId in this._engines) {
                if (this._engines.hasOwnProperty(sceneId)) {
                    return this._engines[sceneId].scene;
                }
            }
        }

        var engine = this._engines[sceneId];

        return engine ? engine.scene : null;
    };

    /**
     * Gets existing scenes
     *
     * @returns  Existing scenes, mapped to their IDs
     */
    this.getScenes = function () {

        var scenes = {};

        for (var sceneId in this._engines) {
            if (this._engines.hasOwnProperty(sceneId)) {
                scenes[sceneId] = this._engines[sceneId].scene;
            }
        }

        return scenes;
    };

    /**
     * Tests if the given object is an array
     * @private
     */
    this._isArray = function (testObject) {
        return testObject && !(testObject.propertyIsEnumerable('length'))
            && typeof testObject === 'object' && typeof testObject.length === 'number';
    };

    /**
     *
     */
    this._shallowClone = function (o) {
        var o2 = {};
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /**
     * Add properties of o to o2 where undefined or null on o2
     * @private
     */
    this._applyIf = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                if (o2[name] == undefined || o2[name] == null) {
                    o2[name] = o[name];
                }
            }
        }
        return o2;
    };

    /**
     * Add properties of o to o2, overwriting them on o2 if already there.
     * The optional clear flag causes properties on o2 to be cleared first
     * @private
     */
    this._apply = function (o, o2, clear) {
        var name;
        if (clear) {
            for (name in o2) {
                if (o2.hasOwnProperty(name)) {
                    delete o2[name];
                }
            }
        }
        for (name in o) {
            if (o.hasOwnProperty(name) && o[name] != undefined) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    /**
     * Tests is an object is empty
     * @param obj
     * @returns {boolean}
     * @private
     */
    this._isEmpty =function(obj) {
        // null and undefined are "empty"
        if (obj == null) return true;
        // Assume if it has a length property with a non-zero value
        // that that property is correct.
        if (obj.length > 0)    return false;
        if (obj.length === 0)  return true;
        // Otherwise, does it have any properties of its own?
        // Note that this doesn't handle
        // toString and valueOf enumeration bugs in IE < 9
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) return false;
        }
        return true;
    };

    /**
     * Tests if the given value is a number
     * @param value
     * @returns {boolean}
     * @private
     */
    this._isNumeric = function (value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
    };

    /**
    * Shim for slicing arrays regardless of the array type.
    * (Primarily because TypedArray.prototype.slice is
    * not supported on all platforms)
    */
    this._sliceArray = function(array, start, end) {
        if (array.slice) {
            return array.slice(start, end);
        }

        start = start || 0;
        end = end || array.length;

        var length = end - start;
        var newArray = new array.constructor(length);

        for (var i = 0; i < length; i++) {
            newArray[i] = array[start + i];
        }

        return newArray;
    };

    /**
     * Resets SceneJS, destroying all existing scenes
     */
    this.reset = function () {

        var temp = [];

        for (var id in this._engines) { // Collect engines to destroy
            if (this._engines.hasOwnProperty(id)) {

                temp.push(this._engines[id]);

                delete this._engines[id];

                this._engineIds.removeItem(id);
            }
        }

        while (temp.length > 0) { // Destroy the engines
            temp.pop().destroy();
        }

        SceneJS_events.fireEvent(SceneJS_events.RESET);
    };

})();
;// Configure RequireJS to find plugins relative to plugins location
(function () {

    var pluginPath;

    SceneJS.on("configs",
        function (configs) {
            if (configs.pluginPath != pluginPath) {
                pluginPath = configs.pluginPath;
                var libPath = pluginPath + "/lib";
                require.config({
                    paths:{
                        "scenejsPluginDeps":libPath
                    }
                });
            }
        });
})();;/**
 *  @private
 */
var SceneJS_eventManager = function () {

    this._handlerIds = new SceneJS_Map();

    this.typeHandlers = {};
};

/**
 *
 */
SceneJS_eventManager.prototype.createEvent = function (type) {

    if (this.typeHandlers[type]) {
        return;
    }

    this.typeHandlers[type] = {
        handlers:{},
        numSubs:0
    };
};

/**
 * Subscribes to an event defined on this event manager
 *
 * @param {String} type Event type one of the values in SceneJS_events
 * @param {Function} callback Handler function that will accept whatever parameter object accompanies the event
 * @return {String} handle Handle to the event binding
 */
SceneJS_eventManager.prototype.onEvent = function (type, callback) {

    var handlersForType = this.typeHandlers[type] || (this.typeHandlers[type] = {
        handlers:{},
        numSubs:0
    });

    var handlerId = this._handlerIds.addItem(type);

    var handlers = handlersForType.handlers;
    handlers[handlerId] = callback;
    handlersForType.numSubs++;

    return handlerId;
};

/**
 *
 */
SceneJS_eventManager.prototype.fireEvent = function (type, params) {

    var handlersForType = this.typeHandlers[type] || (this.typeHandlers[type] = {
        handlers:{},
        numSubs:0
    });

    if (handlersForType.numSubs > 0) {

        var handlers = handlersForType.handlers;

        for (var handlerId in handlers) {
            if (handlers.hasOwnProperty(handlerId)) {
                handlers[handlerId](params);
            }
        }
    }
};

/**
 * Unsubscribes to an event previously subscribed to on this manager
 *
 * @param {String} handlerId Subscription handle
 */
SceneJS_eventManager.prototype.unEvent = function (handlerId) {

    var type = this._handlerIds.items[handlerId];
    if (!type) {
        return;
    }

    this._handlerIds.removeItem(handlerId);

    var handlers = this.typeHandlers[type];

    if (!handlers) {
        return;
    }

    delete handlers[handlerId];
    this.typeHandlers[type].numSubs--;
};
;/**
 * SceneJS plugin registry
 */
SceneJS.Plugins = new (function () {

    // Plugin map for each node type
    var nodePlugins = {};

    // Subscribers to plugins
    var pluginSubs = {};

    /**
     * Installs a plugin into SceneJS
     * @param {String} nodeType Node type name
     * @param {String} pluginType Plugin type name
     * @param [{String}] deps List of URLs of JavaScript files that the plugin depends on
     * @param {Function} plugin Plugin constructor
     */
    this.addPlugin = function () {
        var nodeType = arguments[0];
        var pluginType = arguments[1];
        var deps;
        var plugin;
        if (arguments.length == 4) {
            deps = arguments[2];
            plugin = arguments[3];
        } else {
            plugin = arguments[2];
        }
        addPlugin(nodeType, pluginType, deps, plugin);
    };

    function addPlugin(nodeType, pluginType, deps, plugin) {
        var plugins = nodePlugins[nodeType] || (nodePlugins[nodeType] = {});
        plugins[pluginType] = plugin;
        // Load dependencies, if any
        loadDeps(deps,
            0,
            function () {
                // Notify and unsubscribe subscribers
                var subId = nodeType + pluginType;
                var subs = pluginSubs[subId] || (pluginSubs[subId] = []);
                while (subs.length > 0) {
                    subs.pop()(plugin);
                }
                delete pluginSubs[subId];
            });
    }

    // Loads list of dependencies, synchronously and in order
    function loadDeps(deps, i, ok) {
        if (!deps || i >= deps.length) {
            ok();
            return;
        }
        var src = deps[i];
        var pluginPath = SceneJS_configsModule.configs.pluginPath;
        if (!pluginPath) {
            throw "no pluginPath config"; // Build script error - should create this config
        }
        src = pluginPath + "/" + src;
        loadScript(src,
            function () {
                loadDeps(deps, i + 1, ok);
            });
    }

    /**
     * Tests if given plugin is installed
     */
    this.hasPlugin = function (nodeType, pluginType) {
        var plugins = nodePlugins[nodeType];
        return (plugins && !!plugins[pluginType]);
    };

    /**
     * Returns installed plugin of given type and ID
     */
    this.getPlugin = function (nodeType, pluginType, ok) {
        var plugins = nodePlugins[nodeType];
        if (plugins) {
            var plugin = plugins[pluginType];
            if (plugin) {
                ok(plugin);
                return;
            }
        }
        var subId = nodeType + pluginType;
        var subs = pluginSubs[subId] || (pluginSubs[subId] = []);
        subs.push(ok);
        if (subs.length > 1) { // Not first sub
            return;
        }
        var self = this;
        var pluginPath = SceneJS_configsModule.configs.pluginPath;
        if (!pluginPath) {
            throw "no pluginPath config"; // Build script error - should create this config
        }
        var pluginFilePath = pluginPath + "/" + nodeType + "/" + pluginType + ".js";
        loadScript(pluginFilePath);
    };

    function loadScript(src, ok) {
        var script = document.createElement("script");
        script.type = "text/javascript";
        if (script.readyState) {  //IE
            script.onreadystatechange = function () {
                if (script.readyState == "loaded" ||
                    script.readyState == "complete") {
                    script.onreadystatechange = null;
                    if (ok) {
                        ok();
                    }
                }
            };
        } else {  //Others
            script.onload = function () {
                if (ok) {
                    ok();
                }
            };
        }
        script.src = src;
        document.getElementsByTagName("head")[0].appendChild(script);
    }

})();;/**
 *  @private
 */
var SceneJS_events = new (function () {

    this.ERROR = 0;
    this.RESET = 1;                         // SceneJS framework reset
    this.NODE_CREATED = 2;                 // Scene has just been created
    this.SCENE_CREATED = 3;                 // Scene has just been created
    this.SCENE_COMPILING = 4;               // Scene about to be compiled and drawn
    this.SCENE_DESTROYED = 5;               // Scene just been destroyed
    this.OBJECT_COMPILING = 6;
    this.WEBGL_CONTEXT_LOST = 7;
    this.WEBGL_CONTEXT_RESTORED = 8;
    this.RENDER = 9;

    /* Priority queue for each type of event
     */
    var events = [];

    /**
     * Registers a handler for the given event and returns a subscription handle
     *
     * The handler can be registered with an optional priority number which specifies the order it is
     * called among the other handler already registered for the event.
     *
     * So, with n being the number of commands registered for the given event:
     *
     * (priority <= 0)      - command will be the first called
     * (priority >= n)      - command will be the last called
     * (0 < priority < n)   - command will be called at the order given by the priority
     * @private
     * @param type Event type - one of the values in SceneJS_events
     * @param command - Handler function that will accept whatever parameter object accompanies the event
     * @param priority - Optional priority number (see above)
     * @return {String} - Subscription handle
     */
    this.addListener = function (type, command, priority) {

        var list = events[type];

        if (!list) {
            list = [];
            events[type] = list;
        }

        var handler = {
            command:command,
            priority:(priority == undefined) ? list.length : priority
        };

        var index = -1;

        for (var i = 0, len = list.length; i < len; i++) {
            if (!list[i]) {
                index = i;
                break;
            }
        }

        if (index < 0) {
            list.push(handler);
            index = list.length - 1;
        }

//
//        for (var i = 0; i < list.length; i++) {
//            if (list[i].priority > handler.priority) {
//                list.splice(i, 0, handler);
//                return i;
//            }
//        }


        var handle = type + "." + index;

        return handle;
    };

    /**
     * Removes a listener
     * @param handle Subscription handle
     */
    this.removeListener = function (handle) {

        var lastIdx = handle.lastIndexOf(".");

        var type = parseInt(handle.substr(0, lastIdx));
        var index = parseInt(handle.substr(lastIdx + 1));

        var list = events[type];

        if (!list) {
            return;
        }

        delete list[index];
    };

    /**
     * @private
     */
    this.fireEvent = function (type, params) {

        var list = events[type];

        if (list) {
            params = params || {};
            for (var i = 0; i < list.length; i++) {
                if (list[i]) {
                    list[i].command(params);
                }
            }
        }
    };

})();


/**
 * Subscribe to SceneJS events
 * @deprecated
 */
SceneJS.bind = function (name, func) {
    switch (name) {

        case "error" :

            return SceneJS_events.addListener(SceneJS_events.ERROR, func);
            break;

        case "reset" :

            return SceneJS_events.addListener(
                SceneJS_events.RESET,
                function () {
                    func();
                });
            break;

        case "webglcontextlost" :

            return SceneJS_events.addListener(
                SceneJS_events.WEBGL_CONTEXT_LOST,
                function (params) {
                    func(params);
                });
            break;

        case "webglcontextrestored" :

            return SceneJS_events.addListener(
                SceneJS_events.WEBGL_CONTEXT_RESTORED,
                function (params) {
                    func(params);
                });
            break;

        default:
            throw SceneJS_error.fatalError("SceneJS.bind - this event type not supported: '" + name + "'");
    }
};

/* Subscribe to SceneJS events
 * @deprecated
 */
SceneJS.onEvent = SceneJS.bind;

/* Unsubscribe from event
 */
SceneJS.unEvent = function (handle) {
    return SceneJS_events.removeListener(handle);
};

SceneJS.subscribe = SceneJS.addListener = SceneJS.onEvent = SceneJS.bind;

SceneJS.unsubscribe = SceneJS.unEvent;


SceneJS.on = SceneJS.onEvent;
SceneJS.off = SceneJS.unEvent;



;/**
 *
 */
var SceneJS_Canvas = function (id, canvasId, contextAttr, options) {

    /**
     * ID of this canvas
     */
    this.canvasId;

    if (!canvasId) {
        // Automatic default canvas
        canvasId = "canvas-" + id;
        var body = document.getElementsByTagName("body")[0];
        var div = document.createElement('div');
        var style = div.style;
        style.height = "100%";
        style.width = "100%";
        style.padding = "0";
        style.margin = "0";
        style.left = "0";
        style.top = "0";
        style.position = "absolute";
        // style["z-index"] = "10000";
        div.innerHTML += '<canvas id="' + canvasId + '" style="width: 100%; height: 100%; margin: 0; padding: 0;"></canvas>';
        body.appendChild(div);
    }

    // Bind to canvas
    var canvas = document.getElementById(canvasId);
    if (!canvas) {
        throw SceneJS_error.fatalError(SceneJS.errors.CANVAS_NOT_FOUND,
            "SceneJS.Scene attribute 'canvasId' does not match any elements in the page");
    }
    this.canvasId = canvasId;

    /**
     * WebGL context options
     */
    this.options = options || {};

    this.canvas = (this.options.simulateWebGLContextLost)
        ? WebGLDebugUtils.makeLostContextSimulatingCanvas(canvas)
        : canvas;

    this.resolutionScaling = this.options.resolutionScaling || 1;

    // If the canvas uses css styles to specify the sizes make sure the basic
    // width and height attributes match or the WebGL context will use 300 x 150

    this.canvas.width = this.canvas.clientWidth * this.resolutionScaling;
    this.canvas.height = this.canvas.clientHeight * this.resolutionScaling;

    /**
     * Attributes given when initialising the WebGL context
     */
    this.contextAttr = contextAttr || {};
    this.contextAttr.alpha = true;
    
    this.contextAttr["stencil"] = true;

    /**
     * The WebGL context
     */
    this.gl = null;

    this.initWebGL();
};

/**
 * Names of recognised WebGL contexts
 */
SceneJS_Canvas.prototype._WEBGL_CONTEXT_NAMES = [
    "webgl",
    "experimental-webgl",
    "webkit-3d",
    "moz-webgl",
    "moz-glweb20"
];

/**
 * Initialise the WebGL context

 */
SceneJS_Canvas.prototype.initWebGL = function () {

    for (var i = 0; !this.gl && i < this._WEBGL_CONTEXT_NAMES.length; i++) {
        try {
            this.gl = this.canvas.getContext(this._WEBGL_CONTEXT_NAMES[i], this.contextAttr);
        } catch (e) { // Try with next context name
        }
    }

    if (!this.gl) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.WEBGL_NOT_SUPPORTED,
            'Failed to get a WebGL context');
    }
};


/**
 * Simulate a lost WebGL context.
 * Only works if the simulateWebGLContextLost was given as an option to the canvas' constructor.
 */
SceneJS_Canvas.prototype.loseWebGLContext = function () {
    if (this.options.simulateWebGLContextLost) {
        this.canvas.loseContext();
    }
};

/**
 * Set canvas size multiplier for supersample anti-aliasing
 */
SceneJS_Canvas.prototype.setResolutionScaling = function (resolutionScaling) {
    this.resolutionScaling = resolutionScaling;
    this.canvas.width = this.canvas.clientWidth * resolutionScaling;
    this.canvas.height = this.canvas.clientHeight * resolutionScaling;
};


;/**
 * @class A container for a scene graph and its display
 *
 *
 * @private
 */
var SceneJS_Engine = function (json, options) {
    options = options || {};

    json.type = "scene"; // The type property supplied by user on the root JSON node is ignored - would always be 'scene'

    /**
     * ID of this engine, also the ID of this engine's {@link SceneJS.Scene}
     * @type String
     */
    this.id = json.id;


    /**
     * Number of times the scene is drawn each time it's rendered.
     * <p>This is useful for when we need to do things like render for left and right eyes.
     * @type {*|number}
     */
    this._numPasses = json.numPasses || 1;

    /**
     * Canvas and GL context for this engine
     */
    this.canvas = new SceneJS_Canvas(this.id, json.canvasId, json.contextAttr, options);

    /**
     * Manages firing of and subscription to events
     */
    this.events = new SceneJS_eventManager();

    /**
     * State core factory - creates, stores, shares and destroys cores
     */
    this._coreFactory = new SceneJS_CoreFactory();

    /**
     * Manages creation, recycle and destruction of {@link SceneJS.Node} instances for this engine's scene graph
     */
    this._nodeFactory = new SceneJS_NodeFactory();

    /**
     * Tracks statistics within this engine, such as numbers of
     * scenes, textures, geometries etc.
     *
     * @property stats
     * @type {*}
     * @final
     */
    this.stats = {
        build: {
            version: SceneJS.VERSION
        },
        client: {
            browser: (navigator && navigator.userAgent) ? navigator.userAgent : "n/a"
        },
        components: {
        },
        memory: {
            // Note that these counts will include any positions, colors,
            // normals and indices that SceneJS internally creates on-demand
            // to support color-index triangle picking.
            meshes: 0,
            positions: 0,
            colors: 0,
            normals: 0,
            uvs: 0,
            indices: 0,
            textures: 0,
            programs: 0
        },
        frame: {
            frameCount: 0,
            fps: 0,
            useProgram: 0,
            setUniform: 0,
            setUniformCacheHits: 0,
            bindTexture: 0,
            bindArray: 0,
            drawElements: 0,
            drawArrays: 0,
            drawChunks: 0
        }
    };

    /**
     * The engine's scene renderer
     * @type SceneJS_Display
     */
    this.display = new SceneJS_Display(this.stats, {
        canvas: this.canvas,
        transparent: json.transparent,
        dof: json.dof,
        depthSort: options.depthSort
    });

    /**
     * Flags the entirety of the scene graph as needing to be (re)compiled into the display
     */
    this.sceneDirty = false;

    /**
     * Flag set when at least one branch of the scene graph needs recompilation
     */
    this._sceneBranchesDirty = false;

    /**
     * Flag to prevent engine from re-compiling the scene graph
     */
    this._compilationPaused = false;

    /**
     * List of nodes scheduled for destruction by #destroyNode
     * Destructions are done in a batch at the end of each render so as not to disrupt the render.
     */
    this._nodesToDestroy = [];

    /**
     * Number of nodes in destruction list
     */
    this._numNodesToDestroy = 0;

    /**
     * Frame rate. 0 means as fast as the browser will render.
     */
    this.fps = json.fps || 0;

    /**
     * Flag which is set while this engine is running - set after call to #start, unset after #stop or #pause
     */
    this.running = false;

    /**
     * Flag which is set while this engine is paused - set after call to #pause, unset after #stop or #start
     */
    this.paused = false;

    /**
     * Flag set once this engine has been destroyed
     */
    this.destroyed = false;

    /**
     * The current scene graph status
     */
    this.sceneStatus = {
        nodes: {}, // Status for each node
        numTasks: 0  // Number of loads currently in progress
    };

    var self = this;


    // Create scene root first, then create its subnodes
    // This way nodes can access the scene in their constructors
    var nodes = json.nodes;
    json.nodes = null;
    this.scene = this.createNode(json); // Create scene root

    if (nodes) {
        json.nodes = nodes;
        this.scene.addNodes(nodes); // then create sub-nodes
    }

    SceneJS_events.addListener(SceneJS_events.RENDER, function (event) {
        self.scene.publish("render", event);
    });

    this.canvas.canvas.addEventListener(// WebGL context lost
        "webglcontextlost",
        function (event) {
            event.preventDefault();
            self.stop();
            SceneJS_events.fireEvent(SceneJS_events.WEBGL_CONTEXT_LOST, {scene: self.scene});
        },
        false);

    this.canvas.canvas.addEventListener(// WebGL context recovered
        "webglcontextrestored",
        function (event) {
            self.canvas.initWebGL();
            self._coreFactory.webglRestored();  // Reallocate WebGL resources for node state cores
            self.display.webglRestored(); // Reallocate shaders and re-cache shader var locations for display state chunks
            SceneJS_events.fireEvent(SceneJS_events.WEBGL_CONTEXT_RESTORED, {scene: self.scene});
            self.start();
        },
        false);
};

/**
 * Sets the number of times the scene is drawn on each render.
 * <p>This is useful for when we need to do things like render for left and right eyes.
 * @param {Number} numPasses The number of times the scene is drawn on each frame.
 * @see #getTagMask
 * @see SceneJS.Tag
 */
SceneJS_Engine.prototype.setNumPasses = function (numPasses) {
    this._numPasses = numPasses;
};

/**
 * Simulate a lost WebGL context.
 * Only works if the simulateWebGLContextLost was given as an option to the engine's constructor.
 */
SceneJS_Engine.prototype.loseWebGLContext = function () {
    this.canvas.loseWebGLContext();
};

/**
 * Gets/loads the given node type
 *
 * @param {String} type Node type name
 * @param {Function(Function)} ok Callback fired when type loaded, returns the type constructor
 */
SceneJS_Engine.prototype.getNodeType = function (type, ok) {
    SceneJS_NodeFactory.getNodeType(type, ok);
};

/**
 * Returns true if the given node type is currently loaded (ie. load not required)
 * @param type
 */
SceneJS_Engine.prototype.hasNodeType = function (type) {
    return !!SceneJS_NodeFactory.nodeTypes[type];
};

/**
 * Recursively parse the given JSON scene graph representation and return a scene (sub)graph.
 *
 * @param {Object} json JSON definition of a scene graph or subgraph
 * @param {Function} ok Callback fired when node created, with the node as argument
 */
SceneJS_Engine.prototype.createNode = function (json, ok) {

    // Do buffered node destroys - don't want olds nodes
    // hanging around whose IDs may clash with the new node
    this._doDestroyNodes();

    json.type = json.type || "node"; // Nodes are SceneJS.Node type by default
    var core = this._coreFactory.getCore(json.type, json.coreId); // Create or share a core
    var self = this;

    return this._nodeFactory.getNode(
        this,
        json,
        core,
        function (node) {

            // Create child nodes
            if (!node._fromPlugin && json.nodes) {
                var numNodes = 0;
                for (var i = 0, len = json.nodes.length; i < len; i++) {
                    self.createNode(
                        json.nodes[i],
                        function (childNode) {
                            node.addNode(childNode);
                            if (++numNodes == len) {
                                if (ok) {
                                    ok(node);
                                }
                                self.scene.publish("nodes/" + node.id, node);
                            }
                        });
                }
            } else {
                if (ok) {
                    ok(node);
                    self.scene.publish("nodes/" + node.id, node);
                }
            }
        });
};

/**
 * Performs pending node destructions. When destroyed, each node and its core is released back to the
 * node and core pools for reuse, respectively.
 */
SceneJS_Engine.prototype._doDestroyNodes = function () {
    var node;
    while (this._numNodesToDestroy > 0) {
        --this._numNodesToDestroy;
        node = this._nodesToDestroy[this._numNodesToDestroy];
        this._nodesToDestroy[this._numNodesToDestroy] = null; // Don't retain the node
        node._doDestroy();
        this._coreFactory.putCore(node._core);    // Release state core for reuse
        this._nodeFactory.putNode(node);         // Release node for reuse
    }
};

/**
 * Finds the node with the given ID in this engine's scene graph
 * @return {SceneJS.Node} The node if found, else null
 */
SceneJS_Engine.prototype.findNode = function (nodeId) {
    return this._nodeFactory.nodes.items[nodeId];
};

/** Finds nodes in this engine's scene graph that have nodes IDs matching the given regular expression
 * @param {String} nodeIdRegex Regular expression to match on node IDs
 * @return {[SceneJS.Node]} Array of nodes whose IDs match the given regex
 */
SceneJS_Engine.prototype.findNodes = function (nodeIdRegex) {

    var regex = new RegExp(nodeIdRegex);
    var nodes = [];
    var nodeMap = this._nodeFactory.nodes.items;

    for (var nodeId in nodeMap) {
        if (nodeMap.hasOwnProperty(nodeId)) {

            if (regex.test(nodeId)) {
                nodes.push(nodeMap[nodeId]);
            }
        }
    }

    return nodes;
};

/**
 * Tests whether a core of the given ID exists for the given node type
 * @param {String} type Node type
 * @param {String} coreId
 * @returns Boolean
 */
SceneJS_Engine.prototype.hasCore = function (type, coreId) {
    return this._coreFactory.hasCore(type, coreId);
};

/**
 * Schedules the given subtree of this engine's {@link SceneJS.Scene} for recompilation
 *
 * @param {SceneJS.Node} node Root node of the subtree to recompile
 */
SceneJS_Engine.prototype.branchDirty = function (node) {

    if (this.sceneDirty) {
        return; // Whole scene will recompile anyway
    }

    /* Dealing with some weirdness with the embedded window and iframe / window fascism.
     */
    if (node == window) {
        return;
    }

    node.branchDirty = true;
    node.dirty = true;

    for (var n = node.parent; n && !(n.dirty || n.branchDirty); n = n.parent) { // Flag path down to this node
        n.dirty = true;
    }

    this._sceneBranchesDirty = true;
};

/**
 * Renders a single frame. Does any pending scene compilations or draw graph updates first.
 * Ordinarily the frame is rendered only if compilations or draw graph updates were performed,
 * but may be forced to render the frame regardless.
 *
 * @param {*} params Rendering parameters
 * @param {Boolean} params.clear True to clear the display first (default)
 */
SceneJS_Engine.prototype.renderFrame = function (params) {

    var rendered = false;

    if (this._needCompile() || (params && params.force)) {

//        // Render display graph
//        this.display.render(params);

        var time = Date.now();

        var force = params && params.force;

        // Render the scene once for each pass
        for (var i = 0; i < this._numPasses; i++) {

            // Notify that render is upcoming
            this.scene.publish("rendering", {
                pass: i
            });

            // Compile scene graph to display graph, if necessary
            this.compile();

            // Render display graph
            // Clear buffers only on first frame
            this.display.render({
                clear: i == 0,
                force: force,
                opaqueOnly: params && params.opaqueOnly
            });

            // Notify that render completed
            this.scene.publish("rendered", {
                sceneId: this.id,
                time: time,
                pass: i
            });

            rendered = true;
        }
    }

    return rendered;
};

/**
 * Starts the render loop on this engine.
 */
SceneJS_Engine.prototype.start = function () {

    if (!this.running) { // Do nothing if already started

        this.running = true;
        this.paused = false;
        this.sceneDirty = true;

        var self = this;
        var fnName = "__scenejs_sceneLoop" + this.id;
        var sleeping = false;
        var time = Date.now();
        var prevTime = time;
        var startTime = time;
        var scene = this.scene;
        var rendered = false;
        var canvas = this.canvas.canvas;
        var width;
        var height;
        var lastWidth = null;
        var lastHeight = null;
        var frameTime;
        var lastFrameTime = 0;
        var elapsedFrameTime;
        var newFPS;
        var fpsSamples = [];
        var numFPSSamples = 30;
        var totalFPS = 0;

        // Notify started
        this.events.fireEvent("started", {
            sceneId: self.id,
            startTime: startTime
        });

        var renderingEvent = {
            pass: 0
        };
        var renderOptions = {
            clear: true
        };
        var renderedEvent = {
            sceneId: self.id,
            time: time,
            pass: 0
        };
        var sleepEvent = {
            sceneId: self.id,
            startTime: time,
            prevTime: time,
            time: time
        };
        var canvasSizeEvent = {
            width: 0,
            height: 0,
            aspect: 1
        };
        var tickEvent = {
            sceneId: self.id,
            startTime: time,
            prevTime: time,
            time: time
        };

        function draw() {
            rendered = false;

            frameTime = Date.now();

            // Moving average of FPS

            if (lastFrameTime > 0) {
                elapsedFrameTime = frameTime - lastFrameTime;
                newFPS = 1000 / elapsedFrameTime;
                totalFPS += newFPS;
                fpsSamples.push(newFPS);
                if (fpsSamples.length >= numFPSSamples) {
                    totalFPS -= fpsSamples.shift();
                }
                self.stats.frame.fps = Math.round(totalFPS / fpsSamples.length);
            }

            // Render the scene once for each pass
            for (var i = 0; i < self._numPasses; i++) {

                if (self._needCompile() || rendered) {

                    sleeping = false;

                    // Notify we're about to do a render
                    renderingEvent.pass = i;
                    scene.publish("rendering", renderingEvent);

                    // Compile scene graph to display graph, if necessary
                    self.compile();

                    // Render display graph
                    // Clear buffers only on first frame
                    renderOptions.clear = i == 0;
                    self.display.render(renderOptions);

                    // Notify that we've just done a render
                    renderedEvent.sceneId = self.id;
                    renderedEvent.time = time;
                    renderedEvent.pass = i;
                    scene.publish("rendered", renderedEvent);

                    rendered = true;
                }
            }

            lastFrameTime = frameTime;

            self.stats.frame.frameCount++;

            // If any of the passes did not render anything, then put the render loop to sleep again
            if (!rendered) {
                if (!sleeping) {
                    sleepEvent.sceneId = self.id;
                    sleepEvent.startTime = startTime;
                    sleepEvent.prevTime = time;
                    sleepEvent.time = time;
                    scene.publish("sleep", sleepEvent);
                }
                sleeping = true;
            }
        }

        // Animation frame callback
        window[fnName] = function () {

            var resolutionScaling = self.canvas.resolutionScaling || 1;

            width = canvas.width = canvas.clientWidth * resolutionScaling;
            height = canvas.height = canvas.clientHeight * resolutionScaling;

            if (width != lastWidth || height != lastHeight) {
                canvasSizeEvent.width = width;
                canvasSizeEvent.height = height;
                canvasSizeEvent.aspect = width / height;
                scene.publish("canvasSize", canvasSizeEvent);
                self.display.imageDirty = true;
                lastWidth = width;
                lastHeight = height;
            }

            if (self.running && !self.paused) {

                time = Date.now();

                tickEvent.sceneId = self.id;
                tickEvent.startTime = startTime;
                tickEvent.prevTime = time;
                tickEvent.time = time;
                scene.publish("tick", tickEvent);

                prevTime = time;

                if (!self.running) { // "tick" handler have destroyed scene
                    return;
                }

                if (self.fps > 0) {
                    requestAnimationFrame(draw);
                } else {
                    draw();  // Already at an animation frame.
                }
            }

            if (self.running) {
                if (self.fps > 0) {
                    setTimeout(window[fnName], 1000 / self.fps);
                } else {
                    requestAnimationFrame(window[fnName]);
                }
            }
        };

        setTimeout(window[fnName], 0);
    }
};

/**
 * Performs a pick on this engine and returns a hit record containing at least the name of the picked
 * scene object (as configured by SceneJS.Name nodes) and the canvas pick coordinates. Ordinarily, picking
 * is the simple GPU color-name mapped method, but this method can instead perform a ray-intersect pick
 * when the 'rayPick' flag is set on the options parameter for this method. For that mode, this method will
 * also find the intersection point on the picked object's near surface with a ray cast from the eye that passes
 * through the mouse position on the projection plane.
 *
 * @param {Number} canvasX X-axis canvas pick coordinate
 * @param {Number} canvasY Y-axis canvas pick coordinate
 * @param options Pick options
 * @param options.rayPick Performs additional ray-intersect pick when true
 * @param options.regionPick Performs additional region-intersect pick when true
 * @returns The pick record
 */
SceneJS_Engine.prototype.pick = function (canvasX, canvasY, options) {

    // Do any pending scene compilations
    if (this._needCompile()) {
        this.compile();
    }

    var hit = this.display.pick({
        canvasX: canvasX,
        canvasY: canvasY,
        pickTriangle: options ? options.rayPick : false,
        pickRegion: options ? options.regionPick : false
    });

    return hit;
};

/**
 * Reads colors of pixels from the last rendered frame.
 */
SceneJS_Engine.prototype.readPixels = function (entries, size, opaqueOnly) {

    // Do any pending scene compilations
    if (this._needCompile()) {
        this.compile();
    }

    return this.display.readPixels(entries, size, opaqueOnly);
};

/**
 * Returns true if view needs refreshing from scene
 * @returns {Boolean}
 * @private
 */
SceneJS_Engine.prototype._needCompile = function () {
    return (this.display.imageDirty // Frame buffer needs redraw
    || this.display.drawListDirty // Draw list needs rebuild
    || this.display.stateSortDirty // Draw list needs to redetermine state order
    || this.display.stateOrderDirty // Draw list needs state sort
    || this.display.objectListDirty // Draw list needs to be rebuilt
    || this._sceneBranchesDirty // One or more branches in scene graph need (re)compilation
    || this.sceneDirty); // Whole scene needs recompilation
};

/**
 * Prevent engine from compiling the scene graph
 */
SceneJS_Engine.prototype.pauseCompilation = function () {
    this._compilationPaused = true;
};

/**
 * Resume compilation of scene graph
 */
SceneJS_Engine.prototype.resumeCompilation = function () {
    this._compilationPaused = false;
};

/**
 * Performs any pending scene compilations or display rebuilds
 */
SceneJS_Engine.prototype.compile = function () {
    if (this._compilationPaused) {
        return;
    }

    if (this._sceneBranchesDirty || this.sceneDirty) { // Need scene graph compilation
        this._sceneBranchesDirty = false;
        SceneJS_events.fireEvent(SceneJS_events.SCENE_COMPILING, {  // Notify compilation support start
            engine: this                                            // Compilation support modules get ready
        });
        this.pubSubProxy = new SceneJS_PubSubProxy(this.scene, null);
        var ctx = {
            pubSubProxy: this.pubSubProxy
        };
        this.scene._compileNodes(ctx); // Begin depth-first compilation descent into scene sub-nodes
        this.sceneDirty = false;
    }
    this._doDestroyNodes(); // Garbage collect destroyed nodes - node destructions set imageDirty true
};

/**
 * Enable or disable depth sorting
 */
SceneJS_Engine.prototype.setDepthSort = function (enabled) {
    this.display.setDepthSort(enabled);
};

/**
 * Pauses/unpauses the render loop
 * @param {Boolean} doPause Pauses or unpauses the render loop
 */
SceneJS_Engine.prototype.pause = function (doPause) {
    this.paused = doPause;
};

/**
 * Stops the render loop
 */
SceneJS_Engine.prototype.stop = function () {
    if (this.running) {
        this.running = false;
        this.paused = false;
        window["__scenejs_sceneLoop" + this.id] = null;
        //   this.events.fireEvent("stopped", { sceneId: this.id });
    }
};

/**
 * Destroys a node within this engine's {@link SceneJS.Scene}
 *
 * @param {SceneJS.Node} node Node to destroy
 */
SceneJS_Engine.prototype.destroyNode = function (node) {

    /* The node is actually scheduled for lazy destruction within the next invocation of #_tryCompile
     */
    this._nodesToDestroy[this._numNodesToDestroy++] = node;

    /* Stop tracking node's status
     */
    var nodeStatus = this.sceneStatus.nodes[node.id];

    if (nodeStatus) {
        this.sceneStatus.numTasks -= nodeStatus.numTasks;
        delete this.sceneStatus.nodes[node.id];
    }
};

/**
 * Destroys this engine
 */
SceneJS_Engine.prototype.destroy = function () {
    this.destroyed = true;
    // this.events.fireEvent("destroyed", { sceneId: this.id });
};

/*---------------------------------------------------------------------------------------------------------------------
 * JavaScript augmentations to support render loop
 *--------------------------------------------------------------------------------------------------------------------*/

if (!self.Int32Array) {
    self.Int32Array = Array;
    self.Float32Array = Array;
}

// Ripped off from THREE.js - https://github.com/mrdoob/three.js/blob/master/src/Three.js
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

(function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'RequestCancelAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                    callback(currTime + timeToCall);
                },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
}());
;/**
 * Backend module that provides single point through which exceptions may be raised
 *
 * @class SceneJS_error
 * @private
 */
var SceneJS_error = new (function() {

    var activeSceneId;

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING, // Set default logging for scene root
            function(params) {
                activeSceneId = params.engine.id;
            });

    SceneJS_events.addListener(
            SceneJS_events.RESET,
            function() {
                activeSceneId = null;
            },
            100000);  // Really low priority - must be reset last

    this.fatalError = function(code, message) {
        if (typeof code == "string") {
            message = code;
            code = SceneJS.errors.ERROR;
        }
        var error = {
            errorName: SceneJS.errors._getErrorName(code) || "ERROR",
            code: code,
            exception: message,
            fatal: true
        };
        if (activeSceneId) {
            error.sceneId = activeSceneId;
        }
        SceneJS_events.fireEvent(SceneJS_events.ERROR, error);
        return message;
    };

    this.error = function(code, message) {
        var error = {
            errorName: SceneJS.errors._getErrorName(code) || "ERROR",
            code: code,
            exception: message,
            fatal: false
        };
        if (activeSceneId) {
            error.sceneId = activeSceneId;
        }
        SceneJS_events.fireEvent(SceneJS_events.ERROR, error);
    };
})();

(function() {
    SceneJS.errors = {};

    var n = 0;
    SceneJS.errors.ERROR = n++;
    SceneJS.errors.INVALID_FRAMEBUFFER = n++;
    SceneJS.errors.WEBGL_NOT_SUPPORTED = n++;
    SceneJS.errors.WEBGL_CONTEXT_LOST = n++;
    SceneJS.errors.NODE_CONFIG_EXPECTED = n++;
    SceneJS.errors.ILLEGAL_NODE_CONFIG = n++;
    SceneJS.errors.SHADER_COMPILATION_FAILURE = n++;
    SceneJS.errors.SHADER_LINK_FAILURE = n++;
    SceneJS.errors.CANVAS_NOT_FOUND = n++;
    SceneJS.errors.OUT_OF_VRAM = n++;
    SceneJS.errors.WEBGL_UNSUPPORTED_NODE_CONFIG = n++;
    SceneJS.errors.NODE_NOT_FOUND = n++;
    SceneJS.errors.NODE_ILLEGAL_STATE = n++;
    SceneJS.errors.ID_CLASH = n++;
    SceneJS.errors.PLUGIN_INVALID = n++;
})();

SceneJS.errors._getErrorName = function(code) {
    for (var key in SceneJS.errors) {
        if (SceneJS.errors.hasOwnProperty(key) && SceneJS.errors[key] == code) {
            return key;
        }
    }
    return null;
};

;/**
 * Backend that manages configurations.
 *
 * @class SceneJS_configsModule
 * @private
 */
var SceneJS_configsModule = new (function () {

    this.configs = {};
    var subs = {};

    /**
     * Set a config
     * @param path
     * @param data
     */
    this.setConfigs = function (path, data) {
        // Update configs
        if (!path) {
            this.configs = data;
        } else {
            var parts = path.split(".");
            var cfg = this.configs;
            var subCfg;
            var name;
            for (var i = 0; i < parts.length - 1; i++) {
                name = parts[i];
                subCfg = cfg[name];
                if (!subCfg) {
                    subCfg = cfg[name] = {};
                }
                cfg = subCfg;
            }
            cfg[parts.length - 1] = data;
        }
        // Notify subscribers
        var list = subs[path || "_all"];
        if (list) {
            for (var i = 0, len = list.length; i < len; i++) {
                list[i](cfg);
            }
        }

        SceneJS.publish("configs", this.configs);
    };

    /**
     * Get a config
     * @param path
     * @return {*}
     */
    this.getConfigs = function (path) {
        if (!path) {
            return this.configs;
        } else {
            var cfg = this.configs;
            var parts = path.split(".");
            for (var i = 0; cfg && i < parts.length; i++) {
                cfg = cfg[parts[i]];
            }
            return (cfg != undefined) ? cfg : {};
        }
    };

    /**
     * Subscribe to updates to a config
     * @param path
     * @param ok
     */
    this.on = function (path, ok) {
        path = path || "_all";
        (subs[path] || (subs[path] = [])).push(ok);
        ok(this.getConfigs(path));
    };

})();

/** Sets configurations.
 */
SceneJS.configure = SceneJS.setConfigs = SceneJS.setDebugConfigs = function () {
    if (arguments.length == 1) {
        SceneJS_configsModule.setConfigs(null, arguments[0]);
    } else if (arguments.length == 2) {
        SceneJS_configsModule.setConfigs(arguments[0], arguments[1]);
    } else {
        throw SceneJS_error.fatalError("Illegal arguments given to SceneJS.setDebugs - should be either ({String}:name, {Object}:cfg) or ({Object}:cfg)");
    }
};

/** Gets configurations
 */
SceneJS.getConfigs = SceneJS.getDebugConfigs = function (path) {
    return SceneJS_configsModule.getConfigs(path);
};

;/**
 * @class Manages logging
 *  @private
 */
SceneJS.log = new (function() {

    var activeSceneId;
    var funcs = null;
    var queues = {};
    var indent = 0;
    var indentStr = "";

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING, // Set default logging for scene root
            function(params) {
                activeSceneId = params.engine.id;
            });

    SceneJS_events.addListener(
            SceneJS_events.RESET,
            function() {
                queues = {};
                funcs = null;
                activeSceneId = null;
            },
            100000);  // Really low priority - must be reset last

    this._setIndent = function(_indent) {
        indent = _indent;
        var indentArray = [];
        for (var i = 0; i < indent; i++) {
            indentArray.push("----");
        }
        indentStr = indentArray.join("");
    };

    this.error = function(msg) {
        this._log("error", msg);
    };

    this.warn = function(msg) {
        this._log("warn", msg);
    };

    this.info = function(msg) {
        this._log("info", msg);
    };

    this.debug = function(msg) {
        this._log("debug", msg);
    };

    this.setFuncs = function(l) {
        if (l) {
            funcs = l;
            for (var channel in queues) {
                this._flush(channel);
            }
        }
    };

    this._flush = function(channel) {
        var queue = queues[channel];
        if (queue) {
            var func = funcs ? funcs[channel] : null;
            if (func) {
                for (var i = 0; i < queue.length; i++) {
                    func(queue[i]);
                }
                queues[channel] = [];
            }
        }
    };

    this._log = function(channel, message) {
        if (SceneJS._isArray(message)) {
            for (var i = 0; i < message.length; i++) {
                this.__log(channel, message[i]);
            }
        } else {
            this.__log(channel, message);
        }
    };

    this.__log = function(channel, message) {
        message = indentStr + message;

        if (funcs && funcs[channel]) {
            funcs[channel](message);

        } else if (console && console[channel]) {
            console[channel](message);
        }
    };

    this.getFuncs = function() {
        return funcs;
    };

})();;(function () {

    /*
     * Optimizations made based on glMatrix by Brandon Jones
     */

    /*
     * Copyright (c) 2010 Brandon Jones
     *
     * This software is provided 'as-is', without any express or implied
     * warranty. In no event will the authors be held liable for any damages
     * arising from the use of this software.
     *
     * Permission is granted to anyone to use this software for any purpose,
     * including commercial applications, and to alter it and redistribute it
     * freely, subject to the following restrictions:
     *
     *    1. The origin of this software must not be misrepresented; you must not
     *    claim that you wrote the original software. If you use this software
     *    in a product, an acknowledgment in the product documentation would be
     *    appreciated but is not required.
     *
     *    2. Altered source versions must be plainly marked as such, and must not
     *    be misrepresented as being the original software.
     *
     *    3. This notice may not be removed or altered from any source
     *    distribution.
     */


    // Some temporary vars to help avoid garbage collection

    var tempMat1 = new Float32Array(16);
    var tempMat2 = new Float32Array(16);
    var tempVec3 = new Float32Array(3);
    var tempVec3b = new Float32Array(3);
    var tempVec3c = new Float32Array(3);
    var tempVec3d = new Float32Array(3);
    var tempVec3e = new Float32Array(3);
    var tempVec3f = new Float32Array(3);
    var tempVec3g = new Float32Array(3);
    var tempVec3h = new Float32Array(3);
    var tempVec4 = new Float32Array(4);

    /**
     * Returns a new, uninitialized two-element vector.
     * @method vec2
     * @static
     * @returns {Float32Array}
     */
    window.SceneJS_math_vec2 = function () {
        return new Float32Array(2);
    };

    /**
     * Returns a new, uninitialized three-element vector.
     * @method vec3
     * @static
     * @returns {Float32Array}
     */
    window.SceneJS_math_vec3 = function () {
        return new Float32Array(3);
    };

    /**
     * Returns a new, uninitialized four-element vector.
     * @method vec4
     * @static
     * @returns {Float32Array}
     */
    window.SceneJS_math_vec4 = function () {
        return new Float32Array(4);
    };

    /**
     * Returns a new, uninitialized 3x3 matrix.
     * @method mat3
     * @static
     * @returns {Float32Array}
     */
    window.SceneJS_math_mat3 = function () {
        return new Float32Array(9);
    };

    /**
     * Returns a new, uninitialized 4x4 matrix.
     * @method mat4
     * @static
     * @returns {Float32Array}
     */
    window.SceneJS_math_mat4 = function () {
        return new Float32Array(16);
    };

    /**
     * @param u vec3
     * @param v vec3
     * @param dest vec3 - optional destination
     * @return {vec3} dest if specified, u otherwise
     * @private
     */
    window.SceneJS_math_divVec3 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        dest[0] = u[0] / v[0];
        dest[1] = u[1] / v[1];
        dest[2] = u[2] / v[2];

        return dest;
    };

    /**
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_negateVector4 = function (v, dest) {
        if (!dest) {
            dest = v;
        }
        dest[0] = -v[0];
        dest[1] = -v[1];
        dest[2] = -v[2];
        dest[3] = -v[3];

        return dest;
    };

    /**
     * @param u vec4
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, u otherwise
     * @private
     */
    window.SceneJS_math_addVec4 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        dest[0] = u[0] + v[0];
        dest[1] = u[1] + v[1];
        dest[2] = u[2] + v[2];
        dest[3] = u[3] + v[3];

        return dest;
    };


    /**
     * @param v vec4
     * @param s scalar
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_addVec4s = function (v, s, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = v[0] + s;
        dest[1] = v[1] + s;
        dest[2] = v[2] + s;
        dest[3] = v[3] + s;

        return dest;
    };

    /**
     * @param u vec3
     * @param v vec3
     * @param dest vec3 - optional destination
     * @return {vec3} dest if specified, u otherwise
     * @private
     */
    window.SceneJS_math_addVec3 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        dest[0] = u[0] + v[0];
        dest[1] = u[1] + v[1];
        dest[2] = u[2] + v[2];

        return dest;
    };

    /**
     * @param v vec3
     * @param s scalar
     * @param dest vec3 - optional destination
     * @return {vec3} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_addVec3s = function (v, s, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = v[0] + s;
        dest[1] = v[1] + s;
        dest[2] = v[2] + s;

        return dest;
    };

    /** @private */
    window.SceneJS_math_addScalarVec4 = function (s, v, dest) {
        return SceneJS_math_addVec4s(v, s, dest);
    };

    /**
     * @param u vec4
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, u otherwise
     * @private
     */
    window.SceneJS_math_subVec4 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        dest[0] = u[0] - v[0];
        dest[1] = u[1] - v[1];
        dest[2] = u[2] - v[2];
        dest[3] = u[3] - v[3];

        return dest;
    };

    /**
     * @param u vec3
     * @param v vec3
     * @param dest vec3 - optional destination
     * @return {vec3} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_subVec3 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        dest[0] = u[0] - v[0];
        dest[1] = u[1] - v[1];
        dest[2] = u[2] - v[2];

        return dest;
    };

    window.SceneJS_math_lerpVec3 = function (t, t1, t2, p1, p2, dest) {
        dest = dest || SceneJS_math_vec3();
        var f2 = (t - t1) / (t2 - t1);
        var f1 = 1.0 - f2;
        dest[0] = p1[0] * f1 + p2[0] * f2;
        dest[1] = p1[1] * f1 + p2[1] * f2;
        dest[2] = p1[2] * f1 + p2[2] * f2;
        return dest;
    };

    /**
     * @param u vec2
     * @param v vec2
     * @param dest vec2 - optional destination
     * @return {vec2} dest if specified, u otherwise
     * @private
     */
    window.SceneJS_math_subVec2 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        dest[0] = u[0] - v[0];
        dest[1] = u[1] - v[1];

        return dest;
    };

    /**
     * @param u vec2
     * @param v vec2
     * @param dest vec2 - optional destination
     * @return {vec2} dest if specified, u otherwise
     * @private
     */
    window.SceneJS_math_addVec2 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        dest[0] = u[0] + v[0];
        dest[1] = u[1] + v[1];

        return dest;
    };

    /**
     * @param v vec4
     * @param s scalar
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_subVec4Scalar = function (v, s, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = v[0] - s;
        dest[1] = v[1] - s;
        dest[2] = v[2] - s;
        dest[3] = v[3] - s;

        return dest;
    };

    /**
     * @param v vec4
     * @param s scalar
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_subScalarVec4 = function (v, s, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = s - v[0];
        dest[1] = s - v[1];
        dest[2] = s - v[2];
        dest[3] = s - v[3];

        return dest;
    };

    /**
     * @param u vec4
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, u otherwise
     * @private
     */
    window.SceneJS_math_mulVec4 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        dest[0] = u[0] * v[0];
        dest[1] = u[1] * v[1];
        dest[2] = u[2] * v[2];
        dest[3] = u[3] * v[3];

        return dest;
    };

    /**
     * @param v vec4
     * @param s scalar
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_mulVec4Scalar = function (v, s, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = v[0] * s;
        dest[1] = v[1] * s;
        dest[2] = v[2] * s;
        dest[3] = v[3] * s;

        return dest;
    };


    /**
     * @param v vec3
     * @param s scalar
     * @param dest vec3 - optional destination
     * @return {vec3} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_mulVec3Scalar = function (v, s, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = v[0] * s;
        dest[1] = v[1] * s;
        dest[2] = v[2] * s;

        return dest;
    };

    /**
     * @param v vec2
     * @param s scalar
     * @param dest vec2 - optional destination
     * @return {vec2} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_mulVec2Scalar = function (v, s, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = v[0] * s;
        dest[1] = v[1] * s;

        return dest;
    };


    /**
     * @param u vec4
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, u otherwise
     * @private
     */
    window.SceneJS_math_divVec4 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        dest[0] = u[0] / v[0];
        dest[1] = u[1] / v[1];
        dest[2] = u[2] / v[2];
        dest[3] = u[3] / v[3];

        return dest;
    };

    /**
     * @param v vec3
     * @param s scalar
     * @param dest vec3 - optional destination
     * @return {vec3} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_divScalarVec3 = function (s, v, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = s / v[0];
        dest[1] = s / v[1];
        dest[2] = s / v[2];

        return dest;
    };

    /**
     * @param v vec3
     * @param s scalar
     * @param dest vec3 - optional destination
     * @return {vec3} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_divVec3s = function (v, s, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = v[0] / s;
        dest[1] = v[1] / s;
        dest[2] = v[2] / s;

        return dest;
    };

    /**
     * @param v vec4
     * @param s scalar
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_divVec4s = function (v, s, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = v[0] / s;
        dest[1] = v[1] / s;
        dest[2] = v[2] / s;
        dest[3] = v[3] / s;

        return dest;
    };


    /**
     * @param s scalar
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_divScalarVec4 = function (s, v, dest) {
        if (!dest) {
            dest = v;
        }

        dest[0] = s / v[0];
        dest[1] = s / v[1];
        dest[2] = s / v[2];
        dest[3] = s / v[3];

        return dest;
    };


    /** @private */
    window.SceneJS_math_dotVector4 = function (u, v) {
        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);
    };

    /** @private */
    window.SceneJS_math_cross3Vec4 = function (u, v) {
        var u0 = u[0], u1 = u[1], u2 = u[2];
        var v0 = v[0], v1 = v[1], v2 = v[2];
        return [
            u1 * v2 - u2 * v1,
            u2 * v0 - u0 * v2,
            u0 * v1 - u1 * v0,
            0.0];
    };

    /**
     * @param u vec3
     * @param v vec3
     * @param dest vec3 - optional destination
     * @return {vec3} dest if specified, u otherwise
     * @private
     */
    window.SceneJS_math_cross3Vec3 = function (u, v, dest) {
        if (!dest) {
            dest = u;
        }

        var x = u[0], y = u[1], z = u[2];
        var x2 = v[0], y2 = v[1], z2 = v[2];

        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;

        return dest;
    };

    /**
     * Returns the dot product of two three-element vectors.
     * @method dotVec4
     * @static
     * @param {Array(Number)} u First vector
     * @param {Array(Number)} v Second vector
     * @return The dot product
     */
    window.SceneJS_math_dotVec3 = function (u, v) {
        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);
    };

    /** @private */
    window.SceneJS_math_sqLenVec4 = function (v) {
        return SceneJS_math_dotVector4(v, v);
    };

    /** @private */
    window.SceneJS_math_lenVec4 = function (v) {
        return Math.sqrt(SceneJS_math_sqLenVec4(v));
    };

    /** @private */
    window.SceneJS_math_dotVector3 = function (u, v) {
        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);
    };

    /** @private */
    window.SceneJS_math_dotVector2 = function (u, v) {
        return (u[0] * v[0] + u[1] * v[1]);
    };

    /** @private */
    window.SceneJS_math_sqLenVec3 = function (v) {
        return SceneJS_math_dotVector3(v, v);
    };

    /** @private */
    window.SceneJS_math_sqLenVec2 = function (v) {
        return SceneJS_math_dotVector2(v, v);
    };

    /** @private */
    window.SceneJS_math_lenVec3 = function (v) {
        return Math.sqrt(SceneJS_math_sqLenVec3(v));
    };

    /** @private */
    window.SceneJS_math_lenVec2 = function (v) {
        return Math.sqrt(SceneJS_math_sqLenVec2(v));
    };

    /**
     * @param v vec3
     * @param dest vec3 - optional destination
     * @return {vec3} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_rcpVec3 = function (v, dest) {
        return SceneJS_math_divScalarVec3(1.0, v, dest);
    };

    /**
     * @param v vec4
     * @param dest vec4 - optional destination
     * @return {vec4} dest if specified, v otherwise
     * @private
     */
    window.SceneJS_math_normalizeVec4 = function (v, dest) {
        var f = 1.0 / SceneJS_math_lenVec4(v);
        return SceneJS_math_mulVec4Scalar(v, f, dest);
    };

    /** @private */
    window.SceneJS_math_normalizeVec3 = function (v, dest) {
        var f = 1.0 / SceneJS_math_lenVec3(v);
        return SceneJS_math_mulVec3Scalar(v, f, dest);
    };

    // @private
    window.SceneJS_math_normalizeVec2 = function (v, dest) {
        var f = 1.0 / SceneJS_math_lenVec2(v);
        return SceneJS_math_mulVec2Scalar(v, f, dest);
    };

    /** @private */
    window.SceneJS_math_getCellMat4 = function (m, row, col) {
        return m[row + col * 4];
    };

    /** @private */
    window.SceneJS_math_setCellMat4 = function (m, row, col, s) {
        m[row + col * 4] = s;
    };

    /** @private */
    window.SceneJS_math_getRowMat4 = function (m, r) {
        return [m[r], m[r + 4], m[r + 8], m[r + 12]];
    };

    /** @private */
    window.SceneJS_math_setRowMat4 = function (m, r, v) {
        m[r] = v[0];
        m[r + 4] = v[1];
        m[r + 8] = v[2];
        m[r + 12] = v[3];
    };

    /** @private */
    window.SceneJS_math_setRowMat4c = function (m, r, x, y, z, w) {
        SceneJS_math_setRowMat4(m, r, [x, y, z, w]);
    };

    /** @private */
    window.SceneJS_math_setRowMat4s = function (m, r, s) {
        SceneJS_math_setRowMat4c(m, r, s, s, s, s);
    };

    /** @private */
    window.SceneJS_math_getColMat4 = function (m, c) {
        var i = c * 4;
        return [m[i], m[i + 1], m[i + 2], m[i + 3]];
    };

    /** @private */
    window.SceneJS_math_setColMat4v = function (m, c, v) {
        var i = c * 4;
        m[i] = v[0];
        m[i + 1] = v[1];
        m[i + 2] = v[2];
        m[i + 3] = v[3];
    };

    /** @private */
    window.SceneJS_math_setColMat4c = function (m, c, x, y, z, w) {
        SceneJS_math_setColMat4v(m, c, [x, y, z, w]);
    };

    /** @private */
    window.SceneJS_math_setColMat4Scalar = function (m, c, s) {
        SceneJS_math_setColMat4c(m, c, s, s, s, s);
    };

    /** @private */
    window.SceneJS_math_mat4To3 = function (m) {
        return [
            m[0], m[1], m[2],
            m[4], m[5], m[6],
            m[8], m[9], m[10]
        ];
    };

    /** @private */
    window.SceneJS_math_m4s = function (s) {
        return [
            s, s, s, s,
            s, s, s, s,
            s, s, s, s,
            s, s, s, s
        ];
    };

    /** @private */
    window.SceneJS_math_setMat4ToZeroes = function () {
        return SceneJS_math_m4s(0.0);
    };

    /** @private */
    window.SceneJS_math_setMat4ToOnes = function () {
        return SceneJS_math_m4s(1.0);
    };

    /** @private */
    window.SceneJS_math_diagonalMat4v = function (v) {
        return [
            v[0], 0.0, 0.0, 0.0,
            0.0, v[1], 0.0, 0.0,
            0.0, 0.0, v[2], 0.0,
            0.0, 0.0, 0.0, v[3]
        ];
    };

    /** @private */
    window.SceneJS_math_diagonalMat4c = function (x, y, z, w) {
        return SceneJS_math_diagonalMat4v([x, y, z, w]);
    };

    /** @private */
    window.SceneJS_math_diagonalMat4s = function (s) {
        return SceneJS_math_diagonalMat4c(s, s, s, s);
    };

    /** @private */
    window.SceneJS_math_identityMat4 = function () {
        return SceneJS_math_diagonalMat4v([1.0, 1.0, 1.0, 1.0]);
    };

    /** @private */
    window.SceneJS_math_isIdentityMat4 = function (m) {
        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||
            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||
            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||
            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {
            return false;
        }

        return true;
    };

    /**
     * @param m mat4
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, m otherwise
     * @private
     */
    window.SceneJS_math_negateMat4 = function (m, dest) {
        if (!dest) {
            dest = m;
        }

        dest[0] = -m[0];
        dest[1] = -m[1];
        dest[2] = -m[2];
        dest[3] = -m[3];
        dest[4] = -m[4];
        dest[5] = -m[5];
        dest[6] = -m[6];
        dest[7] = -m[7];
        dest[8] = -m[8];
        dest[9] = -m[9];
        dest[10] = -m[10];
        dest[11] = -m[11];
        dest[12] = -m[12];
        dest[13] = -m[13];
        dest[14] = -m[14];
        dest[15] = -m[15];

        return dest;
    };

    /**
     * @param a mat4
     * @param b mat4
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, a otherwise
     * @private
     */
    window.SceneJS_math_addMat4 = function (a, b, dest) {
        if (!dest) {
            dest = a;
        }

        dest[0] = a[0] + b[0];
        dest[1] = a[1] + b[1];
        dest[2] = a[2] + b[2];
        dest[3] = a[3] + b[3];
        dest[4] = a[4] + b[4];
        dest[5] = a[5] + b[5];
        dest[6] = a[6] + b[6];
        dest[7] = a[7] + b[7];
        dest[8] = a[8] + b[8];
        dest[9] = a[9] + b[9];
        dest[10] = a[10] + b[10];
        dest[11] = a[11] + b[11];
        dest[12] = a[12] + b[12];
        dest[13] = a[13] + b[13];
        dest[14] = a[14] + b[14];
        dest[15] = a[15] + b[15];

        return dest;
    };

    /**
     * @param m mat4
     * @param s scalar
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, m otherwise
     * @private
     */
    window.SceneJS_math_addMat4Scalar = function (m, s, dest) {
        if (!dest) {
            dest = m;
        }

        dest[0] = m[0] + s;
        dest[1] = m[1] + s;
        dest[2] = m[2] + s;
        dest[3] = m[3] + s;
        dest[4] = m[4] + s;
        dest[5] = m[5] + s;
        dest[6] = m[6] + s;
        dest[7] = m[7] + s;
        dest[8] = m[8] + s;
        dest[9] = m[9] + s;
        dest[10] = m[10] + s;
        dest[11] = m[11] + s;
        dest[12] = m[12] + s;
        dest[13] = m[13] + s;
        dest[14] = m[14] + s;
        dest[15] = m[15] + s;

        return dest;
    };

    /** @private */
    window.SceneJS_math_addScalarMat4 = function (s, m, dest) {
        return SceneJS_math_addMat4Scalar(m, s, dest);
    };

    /**
     * @param a mat4
     * @param b mat4
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, a otherwise
     * @private
     */
    window.SceneJS_math_subMat4 = function (a, b, dest) {
        if (!dest) {
            dest = a;
        }

        dest[0] = a[0] - b[0];
        dest[1] = a[1] - b[1];
        dest[2] = a[2] - b[2];
        dest[3] = a[3] - b[3];
        dest[4] = a[4] - b[4];
        dest[5] = a[5] - b[5];
        dest[6] = a[6] - b[6];
        dest[7] = a[7] - b[7];
        dest[8] = a[8] - b[8];
        dest[9] = a[9] - b[9];
        dest[10] = a[10] - b[10];
        dest[11] = a[11] - b[11];
        dest[12] = a[12] - b[12];
        dest[13] = a[13] - b[13];
        dest[14] = a[14] - b[14];
        dest[15] = a[15] - b[15];

        return dest;
    };

    /**
     * @param m mat4
     * @param s scalar
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, m otherwise
     * @private
     */
    window.SceneJS_math_subMat4Scalar = function (m, s, dest) {
        if (!dest) {
            dest = m;
        }

        dest[0] = m[0] - s;
        dest[1] = m[1] - s;
        dest[2] = m[2] - s;
        dest[3] = m[3] - s;
        dest[4] = m[4] - s;
        dest[5] = m[5] - s;
        dest[6] = m[6] - s;
        dest[7] = m[7] - s;
        dest[8] = m[8] - s;
        dest[9] = m[9] - s;
        dest[10] = m[10] - s;
        dest[11] = m[11] - s;
        dest[12] = m[12] - s;
        dest[13] = m[13] - s;
        dest[14] = m[14] - s;
        dest[15] = m[15] - s;

        return dest;
    };

    /**
     * @param s scalar
     * @param m mat4
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, m otherwise
     * @private
     */
    window.SceneJS_math_subScalarMat4 = function (s, m, dest) {
        if (!dest) {
            dest = m;
        }

        dest[0] = s - m[0];
        dest[1] = s - m[1];
        dest[2] = s - m[2];
        dest[3] = s - m[3];
        dest[4] = s - m[4];
        dest[5] = s - m[5];
        dest[6] = s - m[6];
        dest[7] = s - m[7];
        dest[8] = s - m[8];
        dest[9] = s - m[9];
        dest[10] = s - m[10];
        dest[11] = s - m[11];
        dest[12] = s - m[12];
        dest[13] = s - m[13];
        dest[14] = s - m[14];
        dest[15] = s - m[15];

        return dest;
    };

    /**
     * @param a mat4
     * @param b mat4
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, a otherwise
     * @private
     */
    window.SceneJS_math_mulMat4 = function (a, b, dest) {
        if (!dest) {
            dest = a;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        var b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
        var b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
        var b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
        var b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];

        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

        return dest;
    };

    /**
     * @param m mat4
     * @param s scalar
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, m otherwise
     * @private
     */
    window.SceneJS_math_mulMat4s = function (m, s, dest) {
        if (!dest) {
            dest = m;
        }

        dest[0] = m[0] * s;
        dest[1] = m[1] * s;
        dest[2] = m[2] * s;
        dest[3] = m[3] * s;
        dest[4] = m[4] * s;
        dest[5] = m[5] * s;
        dest[6] = m[6] * s;
        dest[7] = m[7] * s;
        dest[8] = m[8] * s;
        dest[9] = m[9] * s;
        dest[10] = m[10] * s;
        dest[11] = m[11] * s;
        dest[12] = m[12] * s;
        dest[13] = m[13] * s;
        dest[14] = m[14] * s;
        dest[15] = m[15] * s;

        return dest;
    };

    /**
     * @param m mat4
     * @param v vec4
     * @return {vec4}
     * @private
     */
    window.SceneJS_math_mulMat4v4 = function (m, v) {
        var v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];

        return [
            m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3,
            m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3,
            m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3,
            m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3
        ];
    };

    /**
     * @param mat mat4
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, mat otherwise
     * @private
     */
    window.SceneJS_math_transposeMat4 = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        var m4 = mat[4], m14 = mat[14], m8 = mat[8];
        var m13 = mat[13], m12 = mat[12], m9 = mat[9];
        if (!dest || mat == dest) {
            var a01 = mat[1], a02 = mat[2], a03 = mat[3];
            var a12 = mat[6], a13 = mat[7];
            var a23 = mat[11];

            mat[1] = m4;
            mat[2] = m8;
            mat[3] = m12;
            mat[4] = a01;
            mat[6] = m9;
            mat[7] = m13;
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = m14;
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = m4;
        dest[2] = m8;
        dest[3] = m12;
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = m9;
        dest[7] = m13;
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = m14;
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };

    /** @private */
    window.SceneJS_math_determinantMat4 = function (mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;
    };

    /**
     * @param mat mat4
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, mat otherwise
     * @private
     */
    window.SceneJS_math_inverseMat4 = function (mat, dest) {
        if (!dest) {
            dest = mat;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        var b00 = a00 * a11 - a01 * a10;
        var b01 = a00 * a12 - a02 * a10;
        var b02 = a00 * a13 - a03 * a10;
        var b03 = a01 * a12 - a02 * a11;
        var b04 = a01 * a13 - a03 * a11;
        var b05 = a02 * a13 - a03 * a12;
        var b06 = a20 * a31 - a21 * a30;
        var b07 = a20 * a32 - a22 * a30;
        var b08 = a20 * a33 - a23 * a30;
        var b09 = a21 * a32 - a22 * a31;
        var b10 = a21 * a33 - a23 * a31;
        var b11 = a22 * a33 - a23 * a32;

        // Calculate the determinant (inlined to avoid double-caching)
        var invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    };

    /** @private */
    window.SceneJS_math_traceMat4 = function (m) {
        return (m[0] + m[5] + m[10] + m[15]);
    };

    /** @private */
    window.SceneJS_math_translationMat4v = function (v) {
        var m = SceneJS_math_identityMat4();
        m[12] = v[0];
        m[13] = v[1];
        m[14] = v[2];
        return m;
    };

    /** @private */
    window.SceneJS_math_translationMat4c = function (x, y, z) {
        return SceneJS_math_translationMat4v([x, y, z]);
    };

    /** @private */
    window.SceneJS_math_translationMat4s = function (s) {
        return SceneJS_math_translationMat4c(s, s, s);
    };

    /** @private */
    window.SceneJS_math_rotationMat4v = function (anglerad, axis) {
        var ax = SceneJS_math_normalizeVec4([axis[0], axis[1], axis[2], 0.0]);
        var s = Math.sin(anglerad);
        var c = Math.cos(anglerad);
        var q = 1.0 - c;

        var x = ax[0];
        var y = ax[1];
        var z = ax[2];

        var xy, yz, zx, xs, ys, zs;

        //xx = x * x; used once
        //yy = y * y; used once
        //zz = z * z; used once
        xy = x * y;
        yz = y * z;
        zx = z * x;
        xs = x * s;
        ys = y * s;
        zs = z * s;

        var m = SceneJS_math_mat4();

        m[0] = (q * x * x) + c;
        m[1] = (q * xy) + zs;
        m[2] = (q * zx) - ys;
        m[3] = 0.0;

        m[4] = (q * xy) - zs;
        m[5] = (q * y * y) + c;
        m[6] = (q * yz) + xs;
        m[7] = 0.0;

        m[8] = (q * zx) + ys;
        m[9] = (q * yz) - xs;
        m[10] = (q * z * z) + c;
        m[11] = 0.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 0.0;
        m[15] = 1.0;

        return m;
    };

    /** @private */
    window.SceneJS_math_rotationMat4c = function (anglerad, x, y, z) {
        return SceneJS_math_rotationMat4v(anglerad, [x, y, z]);
    };

    /** @private */
    window.SceneJS_math_scalingMat4v = function (v) {
        var m = SceneJS_math_identityMat4();
        m[0] = v[0];
        m[5] = v[1];
        m[10] = v[2];
        return m;
    };

    /** @private */
    window.SceneJS_math_scalingMat4c = function (x, y, z) {
        return SceneJS_math_scalingMat4v([x, y, z]);
    };

    /** @private */
    window.SceneJS_math_scalingMat4s = function (s) {
        return SceneJS_math_scalingMat4c(s, s, s);
    };

    /**
     * Default lookat properties - eye at 0,0,1, looking at 0,0,0, up vector pointing up Y-axis
     */
    window.SceneJS_math_LOOKAT_OBJ = {
        eye: {x: 0, y: 0, z: 10.0},
        look: {x: 0, y: 0, z: 0.0},
        up: {x: 0, y: 1, z: 0.0}
    };

    /**
     * Default lookat properties in array form - eye at 0,0,1, looking at 0,0,0, up vector pointing up Y-axis
     */
    window.SceneJS_math_LOOKAT_ARRAYS = {
        eye: [0, 0, 10.0],
        look: [0, 0, 0.0],
        up: [0, 1, 0.0]
    };

    /**
     * Default orthographic projection properties
     */
    window.SceneJS_math_ORTHO_OBJ = {
        left: -1.0,
        right: 1.0,
        bottom: -1.0,
        near: 0.1,
        top: 1.0,
        far: 5000.0
    };

    /**
     * @param pos vec3 position of the viewer
     * @param target vec3 point the viewer is looking at
     * @param up vec3 pointing "up"
     * @param dest mat4 Optional, mat4 frustum matrix will be written into
     *
     * @return {mat4} dest if specified, a new mat4 otherwise
     */
    window.SceneJS_math_lookAtMat4v = function (pos, target, up, dest) {
        if (!dest) {
            dest = SceneJS_math_mat4();
        }

        var posx = pos[0],
            posy = pos[1],
            posz = pos[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            targetx = target[0],
            targety = target[1],
            targetz = target[2];

        if (posx == targetx && posy == targety && posz == targetz) {
            return SceneJS_math_identityMat4();
        }

        var z0, z1, z2, x0, x1, x2, y0, y1, y2, len;

        //vec3.direction(eye, center, z);
        z0 = posx - targetx;
        z1 = posy - targety;
        z2 = posz - targetz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);
        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);
        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);
        dest[15] = 1;

        return dest;
    };

    /** @private */
    window.SceneJS_math_lookAtMat4c = function (posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {
        return SceneJS_math_lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz]);
    };

    /** @private */
    window.SceneJS_math_orthoMat4c = function (left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = SceneJS_math_mat4();
        }
        var rl = (right - left);
        var tb = (top - bottom);
        var fn = (far - near);

        dest[0] = 2.0 / rl;
        dest[1] = 0.0;
        dest[2] = 0.0;
        dest[3] = 0.0;

        dest[4] = 0.0;
        dest[5] = 2.0 / tb;
        dest[6] = 0.0;
        dest[7] = 0.0;

        dest[8] = 0.0;
        dest[9] = 0.0;
        dest[10] = -2.0 / fn;
        dest[11] = 0.0;

        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1.0;

        return dest;
    };

    /** @private */
    window.SceneJS_math_frustumMat4v = function (fmin, fmax) {
        var fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];
        var fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];
        var vsum = SceneJS_math_mat4();
        SceneJS_math_addVec4(fmax4, fmin4, vsum);
        var vdif = SceneJS_math_mat4();
        SceneJS_math_subVec4(fmax4, fmin4, vdif);
        var t = 2.0 * fmin4[2];

        var m = SceneJS_math_mat4();
        var vdif0 = vdif[0], vdif1 = vdif[1], vdif2 = vdif[2];

        m[0] = t / vdif0;
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;

        m[4] = 0.0;
        m[5] = t / vdif1;
        m[6] = 0.0;
        m[7] = 0.0;

        m[8] = vsum[0] / vdif0;
        m[9] = vsum[1] / vdif1;
        m[10] = -vsum[2] / vdif2;
        m[11] = -1.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = -t * fmax4[2] / vdif2;
        m[15] = 0.0;

        return m;
    };

    /** @private */
    window.SceneJS_math_frustumMatrix4 = function (left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = SceneJS_math_mat4();
        }
        var rl = (right - left);
        var tb = (top - bottom);
        var fn = (far - near);
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    };


    /** @private */
    window.SceneJS_math_perspectiveMatrix4 = function (fovyrad, aspectratio, znear, zfar) {
        var pmin = [];
        var pmax = [];

        pmin[2] = znear;
        pmax[2] = zfar;

        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);
        pmin[1] = -pmax[1];

        pmax[0] = pmax[1] * aspectratio;
        pmin[0] = -pmax[0];

        return SceneJS_math_frustumMat4v(pmin, pmax);
    };

    /** @private */
    window.SceneJS_math_transformPoint3 = function (m, p) {
        var p0 = p[0], p1 = p[1], p2 = p[2];
        return [
            (m[0] * p0) + (m[4] * p1) + (m[8] * p2) + m[12],
            (m[1] * p0) + (m[5] * p1) + (m[9] * p2) + m[13],
            (m[2] * p0) + (m[6] * p1) + (m[10] * p2) + m[14],
            (m[3] * p0) + (m[7] * p1) + (m[11] * p2) + m[15]
        ];
    };


    /** @private */
    window.SceneJS_math_transformPoints3 = function (m, points) {
        var result = new Array(points.length);
        var len = points.length;
        var p0, p1, p2;
        var pi;

        // cache values
        var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3];
        var m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7];
        var m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];
        var m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15];

        for (var i = 0; i < len; ++i) {
            // cache values
            pi = points[i];
            p0 = pi[0];
            p1 = pi[1];
            p2 = pi[2];

            result[i] = [
                (m0 * p0) + (m4 * p1) + (m8 * p2) + m12,
                (m1 * p0) + (m5 * p1) + (m9 * p2) + m13,
                (m2 * p0) + (m6 * p1) + (m10 * p2) + m14,
                (m3 * p0) + (m7 * p1) + (m11 * p2) + m15
            ];
        }

        return result;
    };

    /** @private */
    window.SceneJS_math_transformVector3 = function (m, v, dest) {
        var v0 = v[0], v1 = v[1], v2 = v[2];
        dest = dest || SceneJS_math_vec3();
        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);
        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);
        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);
        return dest;
    };

    window.SceneJS_math_transformVector4 = function (m, v, dest) {
        var v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];
        dest = dest || SceneJS_math_vec4();
        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;
        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;
        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;
        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;
        return dest;
    };

    /** @private */
    window.SceneJS_math_projectVec4 = function (v) {
        var f = 1.0 / v[3];
        return [v[0] * f, v[1] * f, v[2] * f, 1.0];
    };


    /** @private */
    window.SceneJS_math_Plane3 = function (normal, offset, normalize) {
        this.normal = [0.0, 0.0, 1.0];

        this.offset = 0.0;
        if (normal && offset) {
            var normal0 = normal[0], normal1 = normal[1], normal2 = normal[2];
            this.offset = offset;

            if (normalize) {
                var s = Math.sqrt(
                    normal0 * normal0 +
                    normal1 * normal1 +
                    normal2 * normal2
                );
                if (s > 0.0) {
                    s = 1.0 / s;
                    this.normal[0] = normal0 * s;
                    this.normal[1] = normal1 * s;
                    this.normal[2] = normal2 * s;
                    this.offset *= s;
                }
            }
        }
    };

    /** @private */
    window.SceneJS_math_MAX_DOUBLE = Number.POSITIVE_INFINITY;
    /** @private */
    window.SceneJS_math_MIN_DOUBLE = Number.NEGATIVE_INFINITY;

    /** @private
     *
     */
    window.SceneJS_math_Box3 = function (min, max) {
        this.min = min || [SceneJS_math_MAX_DOUBLE, SceneJS_math_MAX_DOUBLE, SceneJS_math_MAX_DOUBLE];
        this.max = max || [SceneJS_math_MIN_DOUBLE, SceneJS_math_MIN_DOUBLE, SceneJS_math_MIN_DOUBLE];

        /** @private */
        this.init = function (min, max) {
            this.min[0] = min[0];
            this.min[1] = min[1];
            this.min[2] = min[2];
            this.max[0] = max[0];
            this.max[1] = max[1];
            this.max[2] = max[2];
            return this;
        };

        /** @private */
        this.fromPoints = function (points) {
            var pointsLength = points.length;

            for (var i = 0; i < pointsLength; ++i) {
                var points_i3 = points[i][3];
                var pDiv0 = points[i][0] / points_i3;
                var pDiv1 = points[i][1] / points_i3;
                var pDiv2 = points[i][2] / points_i3;

                if (pDiv0 < this.min[0]) {
                    this.min[0] = pDiv0;
                }
                if (pDiv1 < this.min[1]) {
                    this.min[1] = pDiv1;
                }
                if (pDiv2 < this.min[2]) {
                    this.min[2] = pDiv2;
                }

                if (pDiv0 > this.max[0]) {
                    this.max[0] = pDiv0;
                }
                if (pDiv1 > this.max[1]) {
                    this.max[1] = pDiv1;
                }
                if (pDiv2 > this.max[2]) {
                    this.max[2] = pDiv2;
                }
            }
            return this;
        };

        /** @private */
        this.isEmpty = function () {
            return (
                (this.min[0] >= this.max[0]) &&
                (this.min[1] >= this.max[1]) &&
                (this.min[2] >= this.max[2])
            );
        };

        /** @private */
        this.getCenter = function () {
            return [
                (this.max[0] + this.min[0]) / 2.0,
                (this.max[1] + this.min[1]) / 2.0,
                (this.max[2] + this.min[2]) / 2.0
            ];
        };

        /** @private */
        this.getSize = function () {
            return [
                (this.max[0] - this.min[0]),
                (this.max[1] - this.min[1]),
                (this.max[2] - this.min[2])
            ];
        };

        /** @private */
        this.getFacesAreas = function () {
            var s = this.size;
            return [
                (s[1] * s[2]),
                (s[0] * s[2]),
                (s[0] * s[1])
            ];
        };

        /** @private */
        this.getSurfaceArea = function () {
            var a = this.getFacesAreas();
            return ((a[0] + a[1] + a[2]) * 2.0);
        };

        /** @private */
        this.getVolume = function () {
            var s = this.size;
            return (s[0] * s[1] * s[2]);
        };

        /** @private */
        this.getOffset = function (half_delta) {
            this.min[0] -= half_delta;
            this.min[1] -= half_delta;
            this.min[2] -= half_delta;
            this.max[0] += half_delta;
            this.max[1] += half_delta;
            this.max[2] += half_delta;
            return this;
        };
    };

    /** @private
     *
     * @param min
     * @param max
     */
    window.SceneJS_math_AxisBox3 = function (min, max) {
        var min0 = min[0], min1 = min[1], min2 = min[2];
        var max0 = max[0], max1 = max[1], max2 = max[2];

        this.verts = [
            [min0, min1, min2],
            [max0, min1, min2],
            [max0, max1, min2],
            [min0, max1, min2],

            [min0, min1, max2],
            [max0, min1, max2],
            [max0, max1, max2],
            [min0, max1, max2]
        ];

        /** @private */
        this.toBox3 = function () {
            var box = new SceneJS_math_Box3();
            for (var i = 0; i < 8; ++i) {
                var v = this.verts[i];
                for (var j = 0; j < 3; ++j) {
                    if (v[j] < box.min[j]) {
                        box.min[j] = v[j];
                    }
                    if (v[j] > box.max[j]) {
                        box.max[j] = v[j];
                    }
                }
            }
        };
    };

    /** @private
     *
     * @param center
     * @param radius
     */
    window.SceneJS_math_Sphere3 = function (center, radius) {
        this.center = [center[0], center[1], center[2]];
        this.radius = radius;

        /** @private */
        this.isEmpty = function () {
            return (this.radius === 0.0);
        };

        /** @private */
        this.surfaceArea = function () {
            return (4.0 * Math.PI * this.radius * this.radius);
        };

        /** @private */
        this.getVolume = function () {
            var thisRadius = this.radius;
            return ((4.0 / 3.0) * Math.PI * thisRadius * thisRadius * thisRadius);
        };
    };

    /** Creates billboard matrix from given view matrix
     * @private
     */
    window.SceneJS_math_billboardMat = function (viewMatrix) {
        var rotVec = [
            SceneJS_math_getColMat4(viewMatrix, 0),
            SceneJS_math_getColMat4(viewMatrix, 1),
            SceneJS_math_getColMat4(viewMatrix, 2)
        ];

        var scaleVec = [
            SceneJS_math_lenVec4(rotVec[0]),
            SceneJS_math_lenVec4(rotVec[1]),
            SceneJS_math_lenVec4(rotVec[2])
        ];

        var scaleVecRcp = SceneJS_math_mat4();
        SceneJS_math_rcpVec3(scaleVec, scaleVecRcp);
        var sMat = SceneJS_math_scalingMat4v(scaleVec);
        //var sMatInv = SceneJS_math_scalingMat4v(scaleVecRcp);

        SceneJS_math_mulVec4Scalar(rotVec[0], scaleVecRcp[0]);
        SceneJS_math_mulVec4Scalar(rotVec[1], scaleVecRcp[1]);
        SceneJS_math_mulVec4Scalar(rotVec[2], scaleVecRcp[2]);

        var rotMatInverse = SceneJS_math_identityMat4();

        SceneJS_math_setRowMat4(rotMatInverse, 0, rotVec[0]);
        SceneJS_math_setRowMat4(rotMatInverse, 1, rotVec[1]);
        SceneJS_math_setRowMat4(rotMatInverse, 2, rotVec[2]);

        //return rotMatInverse;
        //return SceneJS_math_mulMat4(sMatInv, SceneJS_math_mulMat4(rotMatInverse, sMat));
        return SceneJS_math_mulMat4(rotMatInverse, sMat);
        // return SceneJS_math_mulMat4(sMat, SceneJS_math_mulMat4(rotMatInverse, sMat));
        //return SceneJS_math_mulMat4(sMatInv, SceneJS_math_mulMat4(rotMatInverse, sMat));
    };

    /** @private */
    window.SceneJS_math_FrustumPlane = function (nx, ny, nz, offset) {
        var s = 1.0 / Math.sqrt(nx * nx + ny * ny + nz * nz);
        this.normal = [nx * s, ny * s, nz * s];
        this.offset = offset * s;
        this.testVertex = [
            (this.normal[0] >= 0.0) ? (1) : (0),
            (this.normal[1] >= 0.0) ? (1) : (0),
            (this.normal[2] >= 0.0) ? (1) : (0)];
    };

    /** @private */
    window.SceneJS_math_OUTSIDE_FRUSTUM = 3;
    /** @private */
    window.SceneJS_math_INTERSECT_FRUSTUM = 4;
    /** @private */
    window.SceneJS_math_INSIDE_FRUSTUM = 5;

    /** @private */
    window.SceneJS_math_Frustum = function (viewMatrix, projectionMatrix, viewport) {
        var m = SceneJS_math_mat4();
        SceneJS_math_mulMat4(projectionMatrix, viewMatrix, m);

        // cache m indexes
        var m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3];
        var m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7];
        var m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];
        var m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15];

        //var q = [ m[3], m[7], m[11] ]; just reuse m indexes instead of making new var
        var planes = [
            new SceneJS_math_FrustumPlane(m3 - m0, m7 - m4, m11 - m8, m15 - m12),
            new SceneJS_math_FrustumPlane(m3 + m0, m7 + m4, m11 + m8, m15 + m12),
            new SceneJS_math_FrustumPlane(m3 - m1, m7 - m5, m11 - m9, m15 - m13),
            new SceneJS_math_FrustumPlane(m3 + m1, m7 + m5, m11 + m9, m15 + m13),
            new SceneJS_math_FrustumPlane(m3 - m2, m7 - m6, m11 - m10, m15 - m14),
            new SceneJS_math_FrustumPlane(m3 + m2, m7 + m6, m11 + m10, m15 + m14)
        ];

        /* Resources for LOD
         */
        var rotVec = [
            SceneJS_math_getColMat4(viewMatrix, 0),
            SceneJS_math_getColMat4(viewMatrix, 1),
            SceneJS_math_getColMat4(viewMatrix, 2)
        ];

        var scaleVec = [
            SceneJS_math_lenVec4(rotVec[0]),
            SceneJS_math_lenVec4(rotVec[1]),
            SceneJS_math_lenVec4(rotVec[2])
        ];

        var scaleVecRcp = SceneJS_math_rcpVec3(scaleVec);
        var sMat = SceneJS_math_scalingMat4v(scaleVec);
        var sMatInv = SceneJS_math_scalingMat4v(scaleVecRcp);

        SceneJS_math_mulVec4Scalar(rotVec[0], scaleVecRcp[0]);
        SceneJS_math_mulVec4Scalar(rotVec[1], scaleVecRcp[1]);
        SceneJS_math_mulVec4Scalar(rotVec[2], scaleVecRcp[2]);

        var rotMatInverse = SceneJS_math_identityMat4();

        SceneJS_math_setRowMat4(rotMatInverse, 0, rotVec[0]);
        SceneJS_math_setRowMat4(rotMatInverse, 1, rotVec[1]);
        SceneJS_math_setRowMat4(rotMatInverse, 2, rotVec[2]);

        if (!this.matrix) {
            this.matrix = SceneJS_math_mat4();
        }
        SceneJS_math_mulMat4(projectionMatrix, viewMatrix, this.matrix);
        if (!this.billboardMatrix) {
            this.billboardMatrix = SceneJS_math_mat4();
        }
        SceneJS_math_mulMat4(sMatInv, SceneJS_math_mulMat4(rotMatInverse, sMat), this.billboardMatrix);
        this.viewport = viewport.slice(0, 4);

        /** @private */
        this.textAxisBoxIntersection = function (box) {
            var ret = SceneJS_math_INSIDE_FRUSTUM;
            var bminmax = [box.min, box.max];
            var plane = null;

            for (var i = 0; i < 6; ++i) {
                plane = planes[i];
                if (((plane.normal[0] * bminmax[plane.testVertex[0]][0]) +
                    (plane.normal[1] * bminmax[plane.testVertex[1]][1]) +
                    (plane.normal[2] * bminmax[plane.testVertex[2]][2]) +
                    (plane.offset)) < 0.0) {
                    return SceneJS_math_OUTSIDE_FRUSTUM;
                }
                if (((plane.normal[0] * bminmax[1 - plane.testVertex[0]][0]) +
                    (plane.normal[1] * bminmax[1 - plane.testVertex[1]][1]) +
                    (plane.normal[2] * bminmax[1 - plane.testVertex[2]][2]) +
                    (plane.offset)) < 0.0) {
                    ret = SceneJS_math_INTERSECT_FRUSTUM;
                }
            }
            return ret;
        };

        /** @private */
        this.getProjectedSize = function (box) {
            var diagVec = SceneJS_math_mat4();
            SceneJS_math_subVec3(box.max, box.min, diagVec);

            var diagSize = SceneJS_math_lenVec3(diagVec);

            var size = Math.abs(diagSize);

            var p0 = [
                (box.min[0] + box.max[0]) * 0.5,
                (box.min[1] + box.max[1]) * 0.5,
                (box.min[2] + box.max[2]) * 0.5,
                0.0];

            var halfSize = size * 0.5;
            var p1 = [-halfSize, 0.0, 0.0, 1.0];
            var p2 = [halfSize, 0.0, 0.0, 1.0];

            p1 = SceneJS_math_mulMat4v4(this.billboardMatrix, p1);
            p1 = SceneJS_math_addVec4(p1, p0);
            p1 = SceneJS_math_projectVec4(SceneJS_math_mulMat4v4(this.matrix, p1));

            p2 = SceneJS_math_mulMat4v4(this.billboardMatrix, p2);
            p2 = SceneJS_math_addVec4(p2, p0);
            p2 = SceneJS_math_projectVec4(SceneJS_math_mulMat4v4(this.matrix, p2));

            return viewport[2] * Math.abs(p2[0] - p1[0]);
        };


        this.getProjectedState = function (modelCoords) {
            var viewCoords = SceneJS_math_transformPoints3(this.matrix, modelCoords);

            //var canvasBox = {
            //    min: [10000000, 10000000 ],
            //    max: [-10000000, -10000000]
            //};
            // separate variables instead of indexing an array
            var canvasBoxMin0 = 10000000, canvasBoxMin1 = 10000000;
            var canvasBoxMax0 = -10000000, canvasBoxMax1 = -10000000;

            var v, x, y;

            var arrLen = viewCoords.length;
            for (var i = 0; i < arrLen; ++i) {
                v = SceneJS_math_projectVec4(viewCoords[i]);
                x = v[0];
                y = v[1];

                if (x < -0.5) {
                    x = -0.5;
                }

                if (y < -0.5) {
                    y = -0.5;
                }

                if (x > 0.5) {
                    x = 0.5;
                }

                if (y > 0.5) {
                    y = 0.5;
                }


                if (x < canvasBoxMin0) {
                    canvasBoxMin0 = x;
                }
                if (y < canvasBoxMin1) {
                    canvasBoxMin1 = y;
                }

                if (x > canvasBoxMax0) {
                    canvasBoxMax0 = x;
                }
                if (y > canvasBoxMax1) {
                    canvasBoxMax1 = y;
                }
            }

            canvasBoxMin0 += 0.5;
            canvasBoxMin1 += 0.5;
            canvasBoxMax0 += 0.5;
            canvasBoxMax1 += 0.5;

            // cache viewport indexes
            var viewport2 = viewport[2], viewport3 = viewport[3];

            canvasBoxMin0 = (canvasBoxMin0 * (viewport2 + 15));
            canvasBoxMin1 = (canvasBoxMin1 * (viewport3 + 15));
            canvasBoxMax0 = (canvasBoxMax0 * (viewport2 + 15));
            canvasBoxMax1 = (canvasBoxMax1 * (viewport3 + 15));

            var diagCanvasBoxVec = SceneJS_math_mat4();
            SceneJS_math_subVec2([canvasBoxMax0, canvasBoxMax1],
                [canvasBoxMin0, canvasBoxMin1],
                diagCanvasBoxVec);
            var diagCanvasBoxSize = SceneJS_math_lenVec2(diagCanvasBoxVec);

            if (canvasBoxMin0 < 0) {
                canvasBoxMin0 = 0;
            }
            if (canvasBoxMax0 > viewport2) {
                canvasBoxMax0 = viewport2;
            }

            if (canvasBoxMin1 < 0) {
                canvasBoxMin1 = 0;
            }
            if (canvasBoxMax1 > viewport3) {
                canvasBoxMax1 = viewport3;
            }
            return {
                canvasBox: {
                    min: [canvasBoxMin0, canvasBoxMin1],
                    max: [canvasBoxMax0, canvasBoxMax1]
                },
                canvasSize: diagCanvasBoxSize
            };
        };
    };

    window.SceneJS_math_identityQuaternion = function () {
        return [0.0, 0.0, 0.0, 1.0];
    };

    window.SceneJS_math_angleAxisQuaternion = function (x, y, z, degrees) {
        var angleRad = (degrees / 180.0) * Math.PI;
        var halfAngle = angleRad / 2.0;
        var fsin = Math.sin(halfAngle);
        return [
            fsin * x,
            fsin * y,
            fsin * z,
            Math.cos(halfAngle)
        ];
    };

    window.SceneJS_math_mulQuaternions = function (p, q) {
        var p0 = p[0], p1 = p[1], p2 = p[2], p3 = p[3];
        var q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
        return [
            p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1,
            p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2,
            p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0,
            p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2
        ];
    };

    window.SceneJS_math_newMat4FromQuaternion = function (q) {
        var q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
        var tx = 2.0 * q0;
        var ty = 2.0 * q1;
        var tz = 2.0 * q2;
        var twx = tx * q3;
        var twy = ty * q3;
        var twz = tz * q3;
        var txx = tx * q0;
        var txy = ty * q0;
        var txz = tz * q0;
        var tyy = ty * q1;
        var tyz = tz * q1;
        var tzz = tz * q2;
        var m = SceneJS_math_identityMat4();
        SceneJS_math_setCellMat4(m, 0, 0, 1.0 - (tyy + tzz));
        SceneJS_math_setCellMat4(m, 0, 1, txy - twz);
        SceneJS_math_setCellMat4(m, 0, 2, txz + twy);
        SceneJS_math_setCellMat4(m, 1, 0, txy + twz);
        SceneJS_math_setCellMat4(m, 1, 1, 1.0 - (txx + tzz));
        SceneJS_math_setCellMat4(m, 1, 2, tyz - twx);
        SceneJS_math_setCellMat4(m, 2, 0, txz - twy);
        SceneJS_math_setCellMat4(m, 2, 1, tyz + twx);
        SceneJS_math_setCellMat4(m, 2, 2, 1.0 - (txx + tyy));
        return m;
    };

    window.SceneJS_math_slerp = function (t, q1, q2) {
        //var result = SceneJS_math_identityQuaternion();
        var q13 = q1[3] * 0.0174532925;
        var q23 = q2[3] * 0.0174532925;
        var cosHalfAngle = q13 * q23 + q1[0] * q2[0] + q1[1] * q2[1] + q1[2] * q2[2];
        if (Math.abs(cosHalfAngle) >= 1) {
            return [q1[0], q1[1], q1[2], q1[3]];
        } else {
            var halfAngle = Math.acos(cosHalfAngle);
            var sinHalfAngle = Math.sqrt(1 - cosHalfAngle * cosHalfAngle);
            if (Math.abs(sinHalfAngle) < 0.001) {
                return [
                    q1[0] * 0.5 + q2[0] * 0.5,
                    q1[1] * 0.5 + q2[1] * 0.5,
                    q1[2] * 0.5 + q2[2] * 0.5,
                    q1[3] * 0.5 + q2[3] * 0.5
                ];
            } else {
                var a = Math.sin((1 - t) * halfAngle) / sinHalfAngle;
                var b = Math.sin(t * halfAngle) / sinHalfAngle;
                return [
                    q1[0] * a + q2[0] * b,
                    q1[1] * a + q2[1] * b,
                    q1[2] * a + q2[2] * b,
                    (q13 * a + q23 * b) * 57.295779579
                ];
            }
        }
    };

    window.SceneJS_math_normalizeQuaternion = function (q) {
        var len = SceneJS_math_lenVec4([q[0], q[1], q[2], q[3]]);
        return [q[0] / len, q[1] / len, q[2] / len, q[3] / len];
    };

    window.SceneJS_math_conjugateQuaternion = function (q) {
        return [-q[0], -q[1], -q[2], q[3]];
    };

    window.SceneJS_math_angleAxisFromQuaternion = function (q) {
        q = SceneJS_math_normalizeQuaternion(q);
        var q3 = q[3];
        var angle = 2 * Math.acos(q3);
        var s = Math.sqrt(1 - q3 * q3);
        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
            return {
                x: q[0],
                y: q[1],
                z: q[2],
                angle: angle * 57.295779579
            };
        } else {
            return {
                x: q[0] / s,
                y: q[1] / s,
                z: q[2] / s,
                angle: angle * 57.295779579
            };
        }
    };

    /**
     * Builds vertex and index arrays needed by color-indexed triangle picking.
     *
     * @method getPickPrimitives
     * @static
     * @param {Array of Number} positions One-dimensional flattened array of positions.
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @returns {*} Object containing the arrays, created by this method or reused from 'pickTris' parameter.
     */
    window.SceneJS_math_getPickPrimitives = function (positions, indices) {

        var numIndices = indices.length;

        var pickPositions = new Float32Array(numIndices * 3);
        var pickColors = new Float32Array(numIndices * 4);

        var primIndex = 0;

        // Positions array index
        var vi;

        // Picking positions array index
        var pvi;

        // Picking color array index
        var pci;

        // Triangle indices

        var i;
        var r;
        var g;
        var b;
        var a;

        for (var location = 0; location < numIndices; location += 3) {

            pvi = location * 3;
            pci = location * 4;

            // Primitive-indexed triangle pick color

            a = (primIndex >> 24 & 0xFF) / 255.0;
            b = (primIndex >> 16 & 0xFF) / 255.0;
            g = (primIndex >> 8 & 0xFF) / 255.0;
            r = (primIndex & 0xFF) / 255.0;

            // A

            i = indices[location];
            vi = i * 3;

            pickPositions[pvi]     = positions[vi];
            pickPositions[pvi + 1] = positions[vi + 1];
            pickPositions[pvi + 2] = positions[vi + 2];

            pickColors[pci]     = r;
            pickColors[pci + 1] = g;
            pickColors[pci + 2] = b;
            pickColors[pci + 3] = a;


            // B

            i = indices[location + 1];
            vi = i * 3;

            pickPositions[pvi + 3] = positions[vi];
            pickPositions[pvi + 4] = positions[vi + 1];
            pickPositions[pvi + 5] = positions[vi + 2];

            pickColors[pci + 4] = r;
            pickColors[pci + 5] = g;
            pickColors[pci + 6] = b;
            pickColors[pci + 7] = a;


            // C

            i = indices[location + 2];
            vi = i * 3;

            pickPositions[pvi + 6] = positions[vi];
            pickPositions[pvi + 7] = positions[vi + 1];
            pickPositions[pvi + 8] = positions[vi + 2];

            pickColors[pci + 8]  = r;
            pickColors[pci + 9]  = g;
            pickColors[pci + 10] = b;
            pickColors[pci + 11] = a;

            primIndex++;
        }

        return {
            positions: pickPositions,
            colors: pickColors
        };
    };

    /**
     * Builds vertex array needed by color-indexed triangle picking (for morph target positions).
     *
     * @method getPickPositions
     * @static
     * @param {Array of Number} positions One-dimensional flattened array of positions.
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @returns {Array of Number} The pick positions.
     */
    window.SceneJS_math_getPickPositions = function (positions, indices) {

        var numIndices = indices.length;

        var pickPositions = new Float32Array(numIndices * 3);
        var pvi, vi;
        var i;

        for (var location = 0; location < numIndices; location++) {

            // Picking position array index
            pvi = location * 3;

            i = indices[location];

            // Drawing position index
            vi = i * 3;

            pickPositions[pvi]     = positions[vi];
            pickPositions[pvi + 1] = positions[vi + 1];
            pickPositions[pvi + 2] = positions[vi + 2];

        }

        return pickPositions;
    };

    /**
     * Builds color arrays needed by color-indexed triangle picking.
     *
     * @method getPickPrimitives
     * @static
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @returns {Array of Number} The pick colors
     */
    window.SceneJS_math_getPickColors = function (indices) {

        var numIndices = indices.length;

        var pickColors = new Float32Array(numIndices * 4);

        var primIndex = 0;
        var pci;

        // Triangle indices

        var r;
        var g;
        var b;
        var a;

        for (var location = 0; location < numIndices; location += 3) {

            // Picking color array index;
            pci = location * 4;

            // Primitive-indexed triangle pick color

            a = (primIndex >> 24 & 0xFF) / 255.0;
            b = (primIndex >> 16 & 0xFF) / 255.0;
            g = (primIndex >> 8 & 0xFF) / 255.0;
            r = (primIndex & 0xFF) / 255.0;

            // A

            pickColors[pci]     = r;
            pickColors[pci + 1] = g;
            pickColors[pci + 2] = b;
            pickColors[pci + 3] = a;

            // B

            pickColors[pci + 4] = r;
            pickColors[pci + 5] = g;
            pickColors[pci + 6] = b;
            pickColors[pci + 7] = a;

            // C

            pickColors[pci + 8]  = r;
            pickColors[pci + 9]  = g;
            pickColors[pci + 10] = b;
            pickColors[pci + 11] = a;

            primIndex++;
        }

        return pickColors;
    };


    /**
     * Finds the intersection of a 3D ray with a 3D triangle.
     *
     * @method rayTriangleIntersect
     * @static
     * @param {Array of Number} origin Ray origin.
     * @param {Array of Number} dir Ray direction.
     * @param {Array of Number} a First triangle vertex.
     * @param {Array of Number} b Second triangle vertex.
     * @param {Array of Number} c Third triangle vertex.
     * @param {Array of Number} [isect] Intersection point.
     * @returns {Array of Number} The intersection point, or null if no intersection found.
     */
    window.SceneJS_math_rayTriangleIntersect = function (origin, dir, a, b, c, isect) {

        isect = isect || SceneJS_math_vec3();

        var EPSILON = 0.000001;

        var edge1 = SceneJS_math_subVec3(b, a, tempVec3);
        var edge2 = SceneJS_math_subVec3(c, a, tempVec3b);

        var pvec = SceneJS_math_cross3Vec3(dir, edge2, tempVec3c);
        var det = SceneJS_math_dotVec3(edge1, pvec);
        if (det < EPSILON) {
            return null;
        }

        var tvec = SceneJS_math_subVec3(origin, a, tempVec3d);
        var u = SceneJS_math_dotVec3(tvec, pvec);
        if (u < 0 || u > det) {
            return null;
        }

        var qvec = SceneJS_math_cross3Vec3(tvec, edge1, tempVec3e);
        var v = SceneJS_math_dotVec3(dir, qvec);
        if (v < 0 || u + v > det) {
            return null;
        }

        var t = SceneJS_math_dotVec3(edge2, qvec) / det;
        isect[0] = origin[0] + t * dir[0];
        isect[1] = origin[1] + t * dir[1];
        isect[2] = origin[2] + t * dir[2];

        return isect;
    };

    /**
     * Finds the intersection of a 3D ray with a plane defined by 3 points.
     *
     * @method rayPlaneIntersect
     * @static
     * @param {Array of Number} origin Ray origin.
     * @param {Array of Number} dir Ray direction.
     * @param {Array of Number} a First point on plane.
     * @param {Array of Number} b Second point on plane.
     * @param {Array of Number} c Third point on plane.
     * @param {Array of Number} [isect] Intersection point.
     * @returns {Array of Number} The intersection point.
     */
    window.SceneJS_math_rayPlaneIntersect = function (origin, dir, a, b, c, isect) {

        isect = isect || SceneJS_math_vec3();
        dir = SceneJS_math_normalizeVec3(dir, tempVec3);

        var edge1 = SceneJS_math_subVec3(b, a, tempVec3b);
        var edge2 = SceneJS_math_subVec3(c, a, tempVec3c);

        var n = SceneJS_math_cross3Vec3(edge1, edge2, tempVec3d);
        SceneJS_math_normalizeVec3(n, n);

        var d = -SceneJS_math_dotVec3(a, n);

        var t = -(SceneJS_math_dotVec3(origin, n) + d) / SceneJS_math_dotVec3(dir, n);
        isect[0] = origin[0] + t * dir[0];
        isect[1] = origin[1] + t * dir[1];
        isect[2] = origin[2] + t * dir[2];

        return isect;
    };


    /**
     * Gets barycentric coordinates from cartesian coordinates within a triangle.
     *
     * @method cartesianToBaryCentric
     * @static
     * @param {Array of Number} cartesian Cartesian coordinates.
     * @param {Array of Number} a First triangle vertex.
     * @param {Array of Number} b Second triangle vertex.
     * @param {Array of Number} c Third triangle vertex.
     * @param {Array of Number} [bary] The barycentric coordinates.
     * @returns {Array of Number} The barycentric coordinates, or null if the triangle was invalid.
     * @returns {*}
     */
    window.SceneJS_math_cartesianToBarycentric = function (cartesian, a, b, c, bary) {

        var f1 = SceneJS_math_subVec3(a, cartesian, tempVec3);
        var f2 = SceneJS_math_subVec3(b, cartesian, tempVec3b);
        var f3 = SceneJS_math_subVec3(c, cartesian, tempVec3c);

        var t1 = SceneJS_math_subVec3(a, b, tempVec3d);
        var t2 = SceneJS_math_subVec3(a, c, tempVec3e);

        var a0 = SceneJS_math_lenVec3(SceneJS_math_cross3Vec3(t1, t2, tempVec3f));

        bary[0] = SceneJS_math_lenVec3(SceneJS_math_cross3Vec3(f2, f3, tempVec3f)) / a0;
        bary[1] = SceneJS_math_lenVec3(SceneJS_math_cross3Vec3(f3, f1, tempVec3f)) / a0;
        bary[2] = SceneJS_math_lenVec3(SceneJS_math_cross3Vec3(f1, f2, tempVec3f)) / a0;

        return bary;
    };

    window.SceneJS_math_cartesianToBarycentric2 = function (cartesian, a, b, c, dest) {

        var v0 = SceneJS_math_subVec3(c, a, tempVec3);
        var v1 = SceneJS_math_subVec3(b, a, tempVec3b);
        var v2 = SceneJS_math_subVec3(cartesian, a, tempVec3c);

        var dot00 = SceneJS_math_dotVector3(v0, v0);
        var dot01 = SceneJS_math_dotVector3(v0, v1);
        var dot02 = SceneJS_math_dotVector3(v0, v2);
        var dot11 = SceneJS_math_dotVector3(v1, v1);
        var dot12 = SceneJS_math_dotVector3(v1, v2);

        var denom = ( dot00 * dot11 - dot01 * dot01 );

        // Colinear or singular triangle

        if (denom === 0) {

            // Arbitrary location outside of triangle

            return null;
        }

        var invDenom = 1 / denom;

        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

        dest[0] = 1 - u - v;
        dest[1] = v;
        dest[2] = u;

        return dest;
    };

    /**
     * Returns true if the given barycentric coordinates are within their triangle.
     *
     * @method barycentricInsideTriangle
     * @static
     * @param {Array of Number} bary Barycentric coordinates.
     * @returns {Boolean} True if the barycentric coordinates are inside their triangle.
     * @returns {*}
     */
    window.SceneJS_math_barycentricInsideTriangle = function (bary) {

        var v = bary[1];
        var u = bary[2];

        return (u >= 0) && (v >= 0) && (u + v < 1);
    };

    /**
     * Gets cartesian coordinates from barycentric coordinates within a triangle.
     *
     * @method barycentricToCartesian
     * @static
     * @param {Array of Number} bary The barycentric coordinate.
     * @param {Array of Number} a First triangle vertex.
     * @param {Array of Number} b Second triangle vertex.
     * @param {Array of Number} c Third triangle vertex.
     * @param {Array of Number} [cartesian] Cartesian coordinates.
     * @returns {Array of Number} The cartesian coordinates, or null if the triangle was invalid.
     * @returns {*}
     */
    window.SceneJS_math_barycentricToCartesian = function (bary, a, b, c, cartesian) {

        cartesian = cartesian || SceneJS_math_vec3();

        var u = bary[0];
        var v = bary[1];
        var w = bary[2];

        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;
        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;
        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;

        return cartesian;
    };


    /**
     * Builds vertex tangent vectors from positions, UVs and indices
     *
     * @method buildTangents
     * @static
     * @param {Array of Number} positions One-dimensional flattened array of positions.
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @param {Array of Number} uv One-dimensional flattened array of UV coordinates.
     * @returns {Array of Number} One-dimensional flattened array of tangents.
     */
    window.SceneJS_math_buildTangents = function (positions, indices, uv) {

        var tangents = new Float32Array(positions.length);

        // The vertex arrays needs to be calculated
        // before the calculation of the tangents

        for (var location = 0; location < indices.length; location += 3) {

            // Recontructing each vertex and UV coordinate into the respective vectors

            var index = indices[location];

            var v0 = positions.subarray(index * 3, index * 3 + 3);
            var uv0 = uv.subarray(index * 2, index * 2 + 2);

            index = indices[location + 1];

            var v1 = positions.subarray(index * 3, index * 3 + 3);
            var uv1 = uv.subarray(index * 2, index * 2 + 2);

            index = indices[location + 2];

            var v2 = positions.subarray(index * 3, index * 3 + 3);
            var uv2 = uv.subarray(index * 2, index * 2 + 2);

            var deltaPos1 = SceneJS_math_subVec3(v1, v0, tempVec3);
            var deltaPos2 = SceneJS_math_subVec3(v2, v0, tempVec3b);

            var deltaUV1 = SceneJS_math_subVec2(uv1, uv0, tempVec3c);
            var deltaUV2 = SceneJS_math_subVec2(uv2, uv0, tempVec3d);

            var r = 1 / ((deltaUV1[0] * deltaUV2[1]) - (deltaUV1[1] * deltaUV2[0]));

            var tangent = SceneJS_math_mulVec3Scalar(
                SceneJS_math_subVec3(
                    SceneJS_math_mulVec3Scalar(deltaPos1, deltaUV2[1], tempVec3e),
                    SceneJS_math_mulVec3Scalar(deltaPos2, deltaUV1[1], tempVec3f),
                    tempVec3g
                ),
                r,
                tempVec3f
            );

            // Average the value of the vectors outs
            for (var v = 0; v < 3; v++) {
                var addTo = indices[location + v] * 3;

                tangents[addTo]     += tangent[0];
                tangents[addTo + 1] += tangent[1];
                tangents[addTo + 2] += tangent[2];
            }
        }

        return tangents;
    }

})();
;/**
 * Backend that tracks statistics on loading states of nodes during scene traversal.
 *
 * This supports the "loading-status" events that we can listen for on scene nodes.
 *
 * When a node with that listener is pre-visited, it will call getStatus on this module to
 * save a copy of the status. Then when it is post-visited, it will call diffStatus on this
 * module to find the status for its sub-nodes, which it then reports through the "loading-status" event.
 *
 * @private
 */
var SceneJS_sceneStatusModule = new (function () {

    // Public activity summary
    this.sceneStatus = {};

    // IDs of all tasks
    var taskIds = new SceneJS_Map();
    var tasks = {};

    var sceneStates = {};

    var self = this;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_DESTROYED,
        function (params) {
            var sceneId = params.engine.id;
            delete self.sceneStatus[sceneId];
            delete sceneStates[sceneId];
        });

    /** Notifies that a node has begun loading some data
     */
    this.taskStarted = function (node, description) {

        var popups = SceneJS_configsModule.configs.statusPopups !== false;

        var scene = node.getScene();
        var sceneId = scene.getId();
        var nodeId = node.getId();
        var canvas = scene.getCanvas();

        var taskId = taskIds.addItem();

        // Update public info
        var status = this.sceneStatus[sceneId];
        if (!status) {
            status = this.sceneStatus[sceneId] = {
                numTasks: 0
            };
        }
        status.numTasks++;

        // Track node
        var sceneState = sceneStates[sceneId];
        if (!sceneState) {
            sceneState = sceneStates[sceneId] = {
                sceneId: sceneId,
                nodeStates: {},
                scene: scene,
                popupContainer: popups ? createPopupContainer(canvas) : null,
                descCounts: {}
            };
        }
        var descCount = sceneState.descCounts[description];
        if (descCount == undefined) {
            descCount = sceneState.descCounts[description] = 0;
        }
        sceneState.descCounts[description]++;
        var nodeState = sceneState.nodeStates[nodeId];
        if (!nodeState) {
            nodeState = sceneState.nodeStates[nodeId] = {
                nodeId: nodeId,
                numTasks: 0,
                tasks: {}
            };
        }
        description = description + " " + sceneState.descCounts[description] + "...";
        nodeState.numTasks++;
        var task = {
            sceneState: sceneState,
            nodeState: nodeState,
            description: description,
            element: popups ? createPopup(sceneState.popupContainer, description) : null
        };
        nodeState.tasks[taskId] = task;
        tasks[taskId] = task;
        return taskId;
    };

    function createPopupContainer(canvas) {
        var body = document.getElementsByTagName("body")[0];
        var div = document.createElement('div');
        var style = div.style;
        style.position = "absolute";
        style.width = "200px";
        style.right = "10px";
        style.top = "0";
        style.padding = "10px";
        style["z-index"] = "10000";
        body.appendChild(div);
        return div;
    }

    function createPopup(popupContainer, description) {
        var div = document.createElement('div');
        var style = div.style;
        style["font-family"] = "Helvetica";
        style["font-size"] = "14px";
        style.padding = "5px";
        style.margin = "4px";
        style["padding-left"] = "12px";
        style["border"] = "1px solid #000055";
        style.color = "black";
        style.background = "#AAAAAA";
        style.opacity = "0.8";
        style["border-radius"] = "3px";
        style["-moz-border-radius"] = "3px";
        style["box-shadow"] = "3px 3px 3px #444444";
        div.innerHTML = description;
        popupContainer.appendChild(div);
        return div;
    }

    /** Notifies that a load has finished loading some data
     */
    this.taskFinished = function (taskId) {
        if (taskId == -1 || taskId == null) {
            return null;
        }
        var task = tasks[taskId];
        if (!task) {
            return null;
        }
        var sceneState = task.sceneState;
        this.sceneStatus[sceneState.sceneId].numTasks--;
        if (task.element) {
            dismissPopup(task.element);
        }
        var nodeState = task.nodeState;
        if (--nodeState.numTasks < 0) {
            nodeState.numTasks = 0;
        }
        delete nodeState.tasks[taskId];
        if (nodeState.numTasks == 0) {
            delete sceneState.nodeStates[nodeState.nodeId];
        }
        return null;
    };

    function dismissPopup(element) {
        element.style.background = "#AAFFAA";
        var opacity = 0.8;
        var interval = setInterval(function () {
            if (opacity <= 0) {
                element.parentNode.removeChild(element);
                clearInterval(interval);
            } else {
                element.style.opacity = opacity;
                opacity -= 0.1;
            }
        }, 100);
    }

    /** Notifies that a task has failed
     */
    this.taskFailed = function (taskId) {
        if (taskId == -1 || taskId == null) {
            return null;
        }
        var task = tasks[taskId];
        if (!task) {
            return null;
        }
        var popups = !!SceneJS_configsModule.configs.statusPopups;
        var sceneState = task.sceneState;
        this.sceneStatus[sceneState.sceneId].numTasks--;
        if (popups) {
            failPopup(task.element);
        }
        var nodeState = task.nodeState;
        nodeState.numTasks--;
        delete nodeState.tasks[taskId];
        if (nodeState.numTasks == 0) {
            delete task.sceneState.nodeStates[nodeState.nodeId];
        }
        return null;
    };

    function failPopup(element) {
        element.style.background = "#FFAAAA";
    }
})();;SceneJS._webgl = {};
;/** Buffer for vertices and indices
 *
 * @private
 * @param gl  WebGL gl
 * @param type     Eg. ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER
 * @param values   WebGL array wrapper
 * @param numItems Count of items in array wrapper
 * @param itemSize Size of each item
 * @param usage    Eg. STATIC_DRAW
 */

SceneJS._webgl.ArrayBuffer = function (gl, type, values, numItems, itemSize, usage) {

    /**
     * True when this buffer is allocated and ready to go
     * @type {boolean}
     */
    this.allocated = false;

    var itemType = values.constructor == Uint8Array   ? gl.UNSIGNED_BYTE :
                   values.constructor == Uint16Array  ? gl.UNSIGNED_SHORT :
                   values.constructor == Uint32Array  ? gl.UNSIGNED_INT :
                                                        gl.FLOAT;

    this.gl = gl;
    this.type = type;
    this.itemType = itemType;
    this.numItems = numItems;
    this.itemSize = itemSize;
    this.usage = usage;
    this._allocate(values, numItems);
};

/**
 * Allocates this buffer
 *
 * @param values
 * @param numItems
 * @private
 */
SceneJS._webgl.ArrayBuffer.prototype._allocate = function (values, numItems) {
    this.allocated = false;
    this.handle = this.gl.createBuffer();
    if (!this.handle) {
        throw SceneJS_error.fatalError(SceneJS.errors.OUT_OF_VRAM, "Failed to allocate WebGL ArrayBuffer");
    }
    if (this.handle) {
        this.gl.bindBuffer(this.type, this.handle);
        this.gl.bufferData(this.type, values, this.usage);
        this.gl.bindBuffer(this.type, null);
        this.numItems = numItems;
        this.length = values.length;
        this.allocated = true;
    }
};

/**
 * Updates values within this buffer, reallocating if needed
 *
 * @param data
 * @param offset
 */
SceneJS._webgl.ArrayBuffer.prototype.setData = function (data, offset) {
    if (!this.allocated) {
        return;
    }
    if (data.length > this.length) {
        // Needs reallocation
        this.destroy();
        this._allocate(data, data.length);
    } else {
        // No reallocation needed
        if (offset || offset === 0) {
            this.gl.bufferSubData(this.type, offset, data);
        } else {
            this.gl.bufferData(this.type, data);
        }
    }
};

/**
 * Unbinds this buffer on WebGL
 */
SceneJS._webgl.ArrayBuffer.prototype.unbind = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.bindBuffer(this.type, null);
};

/**
 * Destroys this buffer
 */
SceneJS._webgl.ArrayBuffer.prototype.destroy = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.deleteBuffer(this.handle);
    this.handle = null;
    this.allocated = false;
};


SceneJS._webgl.ArrayBuffer.prototype.bind = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.bindBuffer(this.type, this.handle);
};


;
/** An attribute within a shader
 */
SceneJS._webgl.Attribute = function (gl, program, name, type, size, location) {

    this.gl = gl;
    this.location = location;

    this.bindFloatArrayBuffer = function (buffer) {
        if (buffer) {
            buffer.bind();
            gl.enableVertexAttribArray(location);
            gl.vertexAttribPointer(location, buffer.itemSize, gl.FLOAT, false, 0, 0);   // Vertices are not homogeneous - no w-element
        }
    };
};

SceneJS._webgl.Attribute.prototype.bindInterleavedFloatArrayBuffer = function (components, stride, byteOffset) {
    this.gl.enableVertexAttribArray(this.location);
    this.gl.vertexAttribPointer(this.location, components, this.gl.FLOAT, false, stride, byteOffset);   // Vertices are not homogeneous - no w-element
};
;
/** Maps SceneJS node parameter names to WebGL enum names
 * @private
 */
SceneJS._webgl.enumMap = {
    funcAdd: "FUNC_ADD",
    funcSubtract: "FUNC_SUBTRACT",
    funcReverseSubtract: "FUNC_REVERSE_SUBTRACT",
    zero: "ZERO",
    one: "ONE",
    srcColor: "SRC_COLOR",
    oneMinusSrcColor: "ONE_MINUS_SRC_COLOR",
    dstColor: "DST_COLOR",
    oneMinusDstColor: "ONE_MINUS_DST_COLOR",
    srcAlpha: "SRC_ALPHA",
    oneMinusSrcAlpha: "ONE_MINUS_SRC_ALPHA",
    dstAlpha: "DST_ALPHA",
    oneMinusDstAlpha: "ONE_MINUS_DST_ALPHA",
    contantColor: "CONSTANT_COLOR",
    oneMinusConstantColor: "ONE_MINUS_CONSTANT_COLOR",
    constantAlpha: "CONSTANT_ALPHA",
    oneMinusConstantAlpha: "ONE_MINUS_CONSTANT_ALPHA",
    srcAlphaSaturate: "SRC_ALPHA_SATURATE",
    front: "FRONT",
    back: "BACK",
    frontAndBack: "FRONT_AND_BACK",
    never: "NEVER",
    less: "LESS",
    equal: "EQUAL",
    lequal: "LEQUAL",
    greater: "GREATER",
    notequal: "NOTEQUAL",
    gequal: "GEQUAL",
    always: "ALWAYS",
    cw: "CW",
    ccw: "CCW",
    linear: "LINEAR",
    nearest: "NEAREST",
    linearMipMapNearest: "LINEAR_MIPMAP_NEAREST",
    nearestMipMapNearest: "NEAREST_MIPMAP_NEAREST",
    nearestMipMapLinear: "NEAREST_MIPMAP_LINEAR",
    linearMipMapLinear: "LINEAR_MIPMAP_LINEAR",
    repeat: "REPEAT",
    clampToEdge: "CLAMP_TO_EDGE",
    mirroredRepeat: "MIRRORED_REPEAT",
    alpha: "ALPHA",
    rgb: "RGB",
    rgba: "RGBA",
    luminance: "LUMINANCE",
    luminanceAlpha: "LUMINANCE_ALPHA",
    textureBinding2D: "TEXTURE_BINDING_2D",
    textureBindingCubeMap: "TEXTURE_BINDING_CUBE_MAP",
    compareRToTexture: "COMPARE_R_TO_TEXTURE", // Hardware Shadowing Z-depth,
    unsignedByte: "UNSIGNED_BYTE"
};

;SceneJS._webgl.RenderBuffer = function (cfg) {

    /**
     * True as soon as this buffer is allocated and ready to go
     */
    this.allocated = false;

    /**
     * The canvas, to synch buffer size with when its dimensions change
     */
    this.canvas = cfg.canvas;

    /**
     * WebGL context
     */
    this.gl = cfg.canvas.gl;

    /**
     * Buffer resources, set up in #_touch
     */
    this.buf = null;

    /**
     * True while this buffer is bound
     * @type {boolean}
     */
    this.bound = false;
};

/**
 * Called after WebGL context is restored.
 */
SceneJS._webgl.RenderBuffer.prototype.webglRestored = function (_gl) {
    this.gl = _gl;
    this.buf = null;
    this.allocated = false;
    this.bound = false;
};

/**
 * Binds this buffer
 */
SceneJS._webgl.RenderBuffer.prototype.bind = function () {
    this._touch();
    if (this.bound) {
        return;
    }
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buf.framebuf);
    this.bound = true;
};

SceneJS._webgl.RenderBuffer.prototype._touch = function () {
    var width = this.canvas.canvas.width;
    var height = this.canvas.canvas.height;
    if (this.buf) { // Currently have a buffer
        if (this.buf.width == width && this.buf.height == height) { // Canvas size unchanged, buffer still good
            return;
        } else { // Buffer needs reallocation for new canvas size
            this.gl.deleteTexture(this.buf.texture);
            this.gl.deleteFramebuffer(this.buf.framebuf);
            this.gl.deleteRenderbuffer(this.buf.renderbuf);
        }
    }

    this.buf = {
        framebuf: this.gl.createFramebuffer(),
        renderbuf: this.gl.createRenderbuffer(),
        texture: this.gl.createTexture(),
        width: width,
        height: height
    };

    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buf.framebuf);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.buf.texture);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);

    this._setTexture(width, height);

    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.buf.renderbuf);
    this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);
    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.buf.texture, 0);
    this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.buf.renderbuf);
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);

    // Verify framebuffer is OK
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buf.framebuf);

    if (!this.gl.isFramebuffer(this.buf.framebuf)) {
        throw SceneJS_error.fatalError(SceneJS.errors.INVALID_FRAMEBUFFER, "Invalid framebuffer");
    }

    var status = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);

    switch (status) {

        case this.gl.FRAMEBUFFER_COMPLETE:
            break;

        case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");

        case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");

        case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");

        case this.gl.FRAMEBUFFER_UNSUPPORTED:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");

        default:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: " + status);
    }

    this.bound = false;
};

SceneJS._webgl.RenderBuffer.prototype._setTexture = function (width, height) {
    try {
        // Do it the way the spec requires
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
    } catch (exception) {
        // Workaround for what appears to be a Minefield bug.
        var textureStorage = new WebGLUnsignedByteArray(width * height * 3);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, textureStorage);
    }
};

/**
 * Clears this renderbuffer
 */
SceneJS._webgl.RenderBuffer.prototype.clear = function () {
    if (!this.bound) {
        throw "Render buffer not bound";
    }
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    this.gl.disable(this.gl.BLEND);
};

/**
 * Reads buffer pixel at given coordinates
 */
SceneJS._webgl.RenderBuffer.prototype.read = function (pickX, pickY) {
    var x = pickX;
    var y = this.canvas.canvas.height - pickY;
    var pix = new Uint8Array(4);
    this.gl.readPixels(x, y, 1, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pix);
    return pix;
};

/**
 * Unbinds this renderbuffer
 */
SceneJS._webgl.RenderBuffer.prototype.unbind = function () {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.bound = false;
};

/** Returns the texture
 */
SceneJS._webgl.RenderBuffer.prototype.getTexture = function () {
    var self = this;
    return {
        bind: function (unit) {
            if (self.buf && self.buf.texture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, self.buf.texture);
                return true;
            }
            return false;
        },
        unbind: function (unit) {
            if (self.buf && self.buf.texture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, null);
            }
        }
    };
};

/** Destroys this buffer
 */
SceneJS._webgl.RenderBuffer.prototype.destroy = function () {
    if (this.buf) {
        this.gl.deleteTexture(this.buf.texture);
        this.gl.deleteFramebuffer(this.buf.framebuf);
        this.gl.deleteRenderbuffer(this.buf.renderbuf);
        this.buf = null;
        this.bound = false;
    }
};
;/**
 * @class Wrapper for a WebGL program
 *
 * @param hash SceneJS-managed ID for program
 * @param {*} stats Collects scene statistics
 * @param gl WebGL gl
 * @param vertexSources Source codes for vertex shaders
 * @param fragmentSources Source codes for fragment shaders
 * @param logging Program and shaders will write to logging's debug channel as they compile and link
 */
SceneJS._webgl.Program = function (stats, gl, vertexSources, fragmentSources) {

    this.stats = stats;

    /**
     * True as soon as this program is allocated and ready to go
     * @type {boolean}
     */
    this.allocated = false;

    this.gl = gl;

    this._uniforms = {};
    this._samplers = {};
    this._attributes = {};

    this.materialSettings = {
        specularColor: [0, 0, 0],
        specular: 0,
        shine: 0,
        emit: 0,
        alpha: 0
    };

    // Create shaders from sources

    this._shaders = [];

    var a, i, u, u_name, location, shader;

    for (i = 0; i < vertexSources.length; i++) {
        this._shaders.push(new SceneJS._webgl.Shader(gl, gl.VERTEX_SHADER, vertexSources[i]));
    }

    for (i = 0; i < fragmentSources.length; i++) {
        this._shaders.push(new SceneJS._webgl.Shader(gl, gl.FRAGMENT_SHADER, fragmentSources[i]));
    }

    // Create program, attach shaders, link and validate program

    this.handle = gl.createProgram();

    if (this.handle) {

        for (i = 0; i < this._shaders.length; i++) {
            shader = this._shaders[i];
            if (shader.valid) {
                gl.attachShader(this.handle, shader.handle);
            }
        }

        gl.linkProgram(this.handle);

        // Discover uniforms and samplers

        var numUniforms = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);
        var valueIndex = 0;
        for (i = 0; i < numUniforms; ++i) {
            u = gl.getActiveUniform(this.handle, i);
            if (u) {
                u_name = u.name;
                if (u_name[u_name.length - 1] == "\u0000") {
                    u_name = u_name.substr(0, u_name.length - 1);
                }
                location = gl.getUniformLocation(this.handle, u_name);
                if ((u.type == gl.SAMPLER_2D) || (u.type == gl.SAMPLER_CUBE) || (u.type == 35682)) {
                    this._samplers[u_name] = new SceneJS._webgl.Sampler(gl, this.handle, u_name, u.type, u.size, location);
                } else {
                    this._uniforms[u_name] = new SceneJS._webgl.Uniform(stats.frame, gl, this.handle, u_name, u.type, u.size, location, valueIndex);
                    ++valueIndex;
                }
            }
        }

        // Discover attributes

        var numAttribs = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);
        for (i = 0; i < numAttribs; i++) {
            a = gl.getActiveAttrib(this.handle, i);
            if (a) {
                location = gl.getAttribLocation(this.handle, a.name);
                this._attributes[a.name] = new SceneJS._webgl.Attribute(gl, this.handle, a.name, a.type, a.size, location);
            }
        }

        // Program allocated
        this.allocated = true;

    } // if (this.handle)
};


SceneJS._webgl.Program.prototype.bind = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.useProgram(this.handle);
};

SceneJS._webgl.Program.prototype.getUniformLocation = function (name) {
    if (!this.allocated) {
        return;
    }
    var u = this._uniforms[name];
    if (u) {
        return u.getLocation();
    }
};

SceneJS._webgl.Program.prototype.getUniform = function (name) {
    if (!this.allocated) {
        return;
    }
    var u = this._uniforms[name];
    if (u) {
        return u;
    }
};

SceneJS._webgl.Program.prototype.getAttribute = function (name) {
    if (!this.allocated) {
        return;
    }
    var attr = this._attributes[name];
    if (attr) {
        return attr;
    }
};

SceneJS._webgl.Program.prototype.bindFloatArrayBuffer = function (name, buffer) {
    if (!this.allocated) {
        return;
    }
    var attr = this._attributes[name];
    if (attr) {
        attr.bindFloatArrayBuffer(buffer);
    }
};

SceneJS._webgl.Program.prototype.bindTexture = function (name, texture, unit) {
    if (!this.allocated) {
        return false;
    }
    var sampler = this._samplers[name];
    if (sampler) {
        return sampler.bindTexture(texture, unit);
    } else {
        return false;
    }
};

SceneJS._webgl.Program.prototype.destroy = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.deleteProgram(this.handle);
    for (var s in this._shaders) {
        this.gl.deleteShader(this._shaders[s].handle);
    }
    this.handle = null;
    this._attributes = null;
    this._uniforms = null;
    this._samplers = null;
    this.allocated = false;
};


SceneJS._webgl.Program.prototype.setUniform = function (name, value) {
    if (!this.allocated) {
        return;
    }
    var u = this._uniforms[name];
    if (u) {
        u.setValue(value);
    }
};
;SceneJS._webgl.Sampler = function (gl, program, name, type, size, location) {

    this.bindTexture = function (texture, unit) {
        if (texture.bind(unit)) {
            gl.uniform1i(location, unit);
            return true;
        }
        return false;
    };
};
;/**
 * A vertex/fragment shader in a program
 *
 * @private
 * @param gl WebGL gl
 * @param gl.VERTEX_SHADER | gl.FRAGMENT_SHADER
 * @param source Source code for shader
 * @param logging Shader will write logging's debug channel as it compiles
 */
SceneJS._webgl.Shader = function (gl, type, source) {

    /**
     * True as soon as this shader is allocated and ready to go
     * @type {boolean}
     */
    this.allocated = false;

    this.handle = gl.createShader(type);

    if (!this.handle) {
        throw SceneJS_error.fatalError(SceneJS.errors.OUT_OF_VRAM, "Failed to create WebGL shader");
    }

    gl.shaderSource(this.handle, source);
    gl.compileShader(this.handle);

    this.valid = (gl.getShaderParameter(this.handle, gl.COMPILE_STATUS) != 0);

    if (!this.valid) {

        if (!gl.isContextLost()) { // Handled explicitely elsewhere, so wont rehandle here

            SceneJS.log.error("Shader program failed to compile: " + gl.getShaderInfoLog(this.handle));
            SceneJS.log.error("Shader source:");
            var lines = source.split('\n');
            for (var j = 0; j < lines.length; j++) {
                SceneJS.log.error((j + 1) + ": " + lines[j]);
            }

            throw SceneJS_error.fatalError(
                SceneJS.errors.SHADER_COMPILATION_FAILURE, "Shader program failed to compile");
        }
    }

    this.allocated = true;
};
;
SceneJS._webgl.Texture2D = function (gl, cfg) {

    try {
        this._init(gl, cfg);
    } catch (e) {
        throw SceneJS_error.fatalError(SceneJS.errors.OUT_OF_VRAM, "Failed to create texture: " + e.message || e);
    }

};

SceneJS._webgl.Texture2D.prototype._init = function (gl, cfg) {
    /**
     * True as soon as this texture is allocated and ready to go
     * @type {boolean}
     */
    this.allocated = false;

    this.target = cfg.target || gl.TEXTURE_2D;
    this.minFilter = cfg.minFilter;
    this.magFilter = cfg.magFilter;
    this.wrapS = cfg.wrapS;
    this.wrapT = cfg.wrapT;
    this.update = cfg.update;  // For dynamically-sourcing textures (ie movies etc)
    this.texture = cfg.texture;
    this.format = gl.RGBA;
    this.isDepth = false;
    this.depthMode = 0;
    this.depthCompareMode = 0;
    this.depthCompareFunc = 0;

    gl.bindTexture(this.target, this.texture);

    if (cfg.minFilter) {
        gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, cfg.minFilter);
    }

    if (cfg.magFilter) {
        gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, cfg.magFilter);
    }

    if (cfg.wrapS) {
        gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, cfg.wrapS);
    }

    if (cfg.wrapT) {
        gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, cfg.wrapT);
    }

    if (cfg.minFilter == gl.NEAREST_MIPMAP_NEAREST ||
        cfg.minFilter == gl.LINEAR_MIPMAP_NEAREST ||
        cfg.minFilter == gl.NEAREST_MIPMAP_LINEAR ||
        cfg.minFilter == gl.LINEAR_MIPMAP_LINEAR) {
        gl.generateMipmap(this.target);
    }

    gl.bindTexture(this.target, null);

    this.allocated = true;

    this.bind = function (unit) {
        if (!this.allocated) {
            return;
        }
        if (this.texture) {
            gl.activeTexture(gl["TEXTURE" + unit]);
            gl.bindTexture(this.target, this.texture);
            if (this.update) {
                this.update(gl);
            }
            return true;
        }
        return false;
    };

    this.unbind = function (unit) {
        if (!this.allocated) {
            return;
        }
        if (this.texture) {
            gl.activeTexture(gl["TEXTURE" + unit]);
            gl.bindTexture(this.target, null);
        }
    };

    this.destroy = function () {
        if (!this.allocated) {
            return;
        }
        if (this.texture) {
            gl.deleteTexture(this.texture);
            this.texture = null;
        }
    };
}

SceneJS._webgl.clampImageSize = function (image, numPixels) {
    var n = image.width * image.height;
    if (n > numPixels) {
        var ratio = numPixels / n;

        var width = image.width * ratio;
        var height = image.height * ratio;

        var canvas = document.createElement("canvas");

        canvas.width = SceneJS._webgl.nextHighestPowerOfTwo(width);
        canvas.height = SceneJS._webgl.nextHighestPowerOfTwo(height);

        var ctx = canvas.getContext("2d");

        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);

        image = canvas;
    }
    return image;
};

SceneJS._webgl.ensureImageSizePowerOfTwo = function (image) {
    if (!SceneJS._webgl.isPowerOfTwo(image.width) || !SceneJS._webgl.isPowerOfTwo(image.height)) {
        var canvas = document.createElement("canvas");
        canvas.width = SceneJS._webgl.nextHighestPowerOfTwo(image.width);
        canvas.height = SceneJS._webgl.nextHighestPowerOfTwo(image.height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image,
            0, 0, image.width, image.height,
            0, 0, canvas.width, canvas.height);
        image = canvas;
    }
    return image;
};

SceneJS._webgl.isPowerOfTwo = function (x) {
    return (x & (x - 1)) == 0;
};

SceneJS._webgl.nextHighestPowerOfTwo = function (x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
};
;SceneJS._webgl.Uniform = function (renderStats, gl, program, name, type, size, location, index, logging) {

    var func = null;

    var value = null;

    if (type === gl.BOOL) {

        func = function (v) {
            if (value === v) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value = v;
            gl.uniform1i(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.BOOL_VEC2) {
        value = new Array(2);

        func = function (v) {
            if (value[0] === v[0] && value[1] === v[1]) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value[0] = v[0];
            value[1] = v[1];
            gl.uniform2iv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.BOOL_VEC3) {
        value = new Array(3);

        func = function (v) {
            if (value[0] === v[0] && value[1] === v[1] && value[2] === v[2]) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value[0] = v[0];
            value[1] = v[1];
            value[2] = v[2];
            gl.uniform3iv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.BOOL_VEC4) {
        value = new Array(4);

        func = function (v) {
            if (value[0] === v[0] && value[1] === v[1] && value[2] === v[2] && value[3] === v[3]) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value[0] = v[0];
            value[1] = v[1];
            value[2] = v[2];
            value[3] = v[3];
            gl.uniform4iv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.INT) {

        func = function (v) {
            if (value === v) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value = v;
            gl.uniform1iv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.INT_VEC2) {
        value = new Uint32Array(2);

        func = function (v) {
            if (value[0] === v[0] && value[1] === v[1]) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value.set(v);
            gl.uniform2iv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.INT_VEC3) {
        value = new Uint32Array(3);

        func = function (v) {
            if (value[0] === v[0] && value[1] === v[1] && value[2] === v[2]) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value.set(v);
            gl.uniform3iv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.INT_VEC4) {
        value = new Uint32Array(4);

        func = function (v) {
            if (value[0] === v[0] && value[1] === v[1] && value[2] === v[2] && value[3] === v[3]) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value.set(v);
            gl.uniform4iv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.FLOAT) {

        func = function (v) {
            if (value === v) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value = v;
            gl.uniform1f(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.FLOAT_VEC2) {
        value = new Float32Array(2);

        func = function (v) {
            if (value[0] === v[0] && value[1] === v[1]) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value.set(v);
            gl.uniform2fv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.FLOAT_VEC3) {
        value = new Float32Array(3);

        func = function (v) {
            if (value[0] === v[0] && value[1] === v[1] && value[2] === v[2]) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value.set(v);
            gl.uniform3fv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.FLOAT_VEC4) {
        value = new Float32Array(4);

        func = function (v) {
            if (value[0] === v[0] && value[1] === v[1] && value[2] === v[2] && value[3] === v[3]) {
                renderStats.setUniformCacheHits++;
                return;
            }
            value.set(v);
            gl.uniform4fv(location, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.FLOAT_MAT2) {

        func = function (v) {
            gl.uniformMatrix2fv(location, gl.FALSE, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.FLOAT_MAT3) {

        func = function (v) {
            gl.uniformMatrix3fv(location, gl.FALSE, v);
            renderStats.setUniform++;
        };

    } else if (type === gl.FLOAT_MAT4) {

        func = function (v) {

            // Caching this matrix is actually slower than not caching

            gl.uniformMatrix4fv(location, gl.FALSE, v);
            renderStats.setUniform++;
        };

    } else {
        throw "Unsupported shader uniform type: " + type;
    }

    this.setValue = func;

    this.getLocation = function () {
        return location;
    };

    // This is just an integer key for caching the uniform's value, more efficient than caching by name.
    this.index = index;
};










;/**
 * Manages scene node event listeners
 * @private
 */
var SceneJS_nodeEventsModule = new (function () {

    var idStack = [];
    var listenerStack = [];
    var stackLen = 0;
    var dirty;

    var defaultCore = {
        type:"listeners",
        stateId:SceneJS._baseStateId++,
        empty:true,
        listeners:[]
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function () {
            stackLen = 0;
            dirty = true;
        });

    SceneJS_events.addListener(
        SceneJS_events.OBJECT_COMPILING,
        function (params) {
            if (dirty) {
                if (stackLen > 0) {
                    var core = {
                        type:"listeners",
                        stateId:idStack[stackLen - 1],
                        listeners:listenerStack.slice(0, stackLen)
                    };
                    params.display.renderListeners = core;
                } else {
                    params.display.renderListeners = defaultCore;
                }
                dirty = false;
            }
        });


    this.preVisitNode = function (node) {

        var renderedSubs = node._topicSubs["rendered"]; // DEPRECATED in V3.2
        var worldPosSubs = node._topicSubs["worldPos"];
        var viewPosSubs = node._topicSubs["viewPos"];
        var cameraPosSubs = node._topicSubs["cameraPos"];
        var projPosSubs = node._topicSubs["projPos"];
        var canvasPosSubs = node._topicSubs["canvasPos"];

        if (renderedSubs || worldPosSubs || viewPosSubs || cameraPosSubs || projPosSubs || canvasPosSubs) {
            idStack[stackLen] = node.id;

            listenerStack[stackLen] = function (event) {

                // Don't retain - callback must get positions for
                // required coordinate via methods on the event object.
                // That's dirty, therefore deprecated.
                if (renderedSubs) {
                    node.publish("rendered", event, true); // DEPRECATED in V3.2
                }

                // Publish retained positions for coordinate systems where subscribed
                if (worldPosSubs) {
                    node.publish("worldPos", event.getWorldPos());
                }
                if (viewPosSubs) {
                    node.publish("viewPos", event.getViewPos());
                }
                if (cameraPosSubs) {
                    node.publish("cameraPos", event.getCameraPos());
                }
                if (projPosSubs) {
                    node.publish("projPos", event.getProjPos());
                }
                if (canvasPosSubs) {
                    node.publish("canvasPos", event.getCanvasPos());
                }
            };

            stackLen++;
            dirty = true;
        }
    };

    this.postVisitNode = function (node) {
        if (node.id == idStack[stackLen - 1]) {
            stackLen--;
            dirty = true;
        }
    };

})();

;/**
 * @class Holds state for one or more {@link SceneJS.Node}s.
 *
 * <p>Each {@link SceneJS.Node} has a state core to hold its state, and the core may be shared by other
 * {@link SceneJS.Nodes}s of the same type.</p>
 *
 * <p>The state held by core is rendered by a {@link SceneJS_Chunk}  
 *
 * @private
 */
var SceneJS_Core = function(type) {

    /**
     * The state core type, which will be the same value as the type property on the {@link SceneJS.Node}s that use the core
     * @type String
     * @see SceneJS.Node#type
     */
    this.type = type;

    /**
     * The state core ID, unique within the scene. This ID may be either a string assigned by the application layer via
     * scene node configs, or a number that is automatically generated by the {@link SceneJS_CoreFactory} managing
     * this core instance.
     * @type String|Number
     */
    this.coreId = null;

    /**
     * Uniquely identifies this state core within a {@link SceneJS_Display}.
     *
     * This ID is used by a {@link SceneJS_Display} to reduce redundant state changes when rendering a sequence of cores, 
     * where as a {@link SceneJS_Display} renders a frame it avoids applying consecutive cores that have the
     * same value for this ID.
     *
     * @type Number
     */
    this.stateId = null;

    /**
     * Count of {@link SceneJS.Node} instances this core holds state for
     */
    this.useCount = 0;
};;/**
 * @class Manages creation, recycle and destruction of {@link SceneJS_Core} instances
 * @private
 */
var SceneJS_CoreFactory = function () {

    this._stateMap = new SceneJS_Map(null, SceneJS._baseStateId);  // For creating unique state IDs for cores

    this._cores = {}; // Map of cores for each type
};

/**
 * State core classes provided by this factory
 * @type {SceneJS.Core}
 */
SceneJS_CoreFactory.coreTypes = {};    // Supported core classes, installed by #createCoreType

/**
 * Creates a core class for instantiation by this factory
 * @param {String} type Name of type, eg. "camera"
 * @param {Node} [superType] Class of super type - SceneJS.Node by default
 * @returns The new node class
 */
SceneJS_CoreFactory.createCoreType = function (type, superType) {
    //
    //    var supa = SceneJS_CoreFactory.coreTypes[superType];
    //
    //    if (!supa) {
    //        supa = SceneJS.Core; // Super class is Core by default
    //    }
    //
    //    var nodeType = function() { // Create the class
    //        supa.apply(this, arguments);
    //        this.type = type;
    //    };
    //
    //    nodeType.prototype = new supa();            // Inherit from base class
    //    nodeType.prototype.constructor = nodeType;
    //
    //    SceneJS_CoreFactory.nodeTypes[type] = nodeType;
    //
    //    return nodeType;
};

SceneJS_CoreFactory.addCoreBuilder = function (type, factory) {

};

/* HACK - allows different types of node to have same type of core, eg. "rotate" and "translate" nodes can both have an "xform" core    
 */
SceneJS_CoreFactory.coreAliases = {
    "rotate":"xform",
    "translate":"xform",
    "scale":"xform",
    "matrix":"xform",
    "xform":"xform"
};

/**
 * Gets a core of the given type from this factory. Reuses any existing existing core of the same type and ID.
 *
 * The caller (a scene node) will then augment the core with type-specific attributes and methods.
 *
 * @param {String} type Type name of core, e.g. "material", "texture"
 * @param {String} coreId ID for the core, unique among all cores of the given type within this factory
 * @returns {Core} The core
 */
SceneJS_CoreFactory.prototype.getCore = function (type, coreId) {

    /* HACK - allows different types of node to have same type of core, eg. "rotate" and "translate" nodes can both have an "xform" core    
     */
    var alias = SceneJS_CoreFactory.coreAliases[type];
    if (alias) {
        type = alias;
    }

    var cores = this._cores[type];

    if (!cores) {
        cores = this._cores[type] = {};
    }

    var core;

    if (coreId) { // Attempt to reuse a core

        core = cores[coreId];

        if (core) {
            core.useCount++;
            return core;
        }
    }

    core = new SceneJS_Core(type);
    core.useCount = 1;  // One user so far

    core.stateId = this._stateMap.addItem(core);
    core.coreId = (coreId != undefined && coreId != null) ? coreId : core.stateId; // Use state ID as core ID by default

    cores[core.coreId] = core;

    return core;
};


/**
 * Tests if a core of the given type and ID currently exists within this factory.
 *
 * @param {String} type Type name of core, e.g. "material", "texture"
 * @param {String} coreId ID for the core, unique among all cores of the given type within this factory
 * @returns {Boolean} True if the core exists
 */
SceneJS_CoreFactory.prototype.hasCore = function (type, coreId) {
    // HACK - allows different types of node to have same type of core, eg. "rotate" and "translate" nodes can both have an "xform" core
    var alias = SceneJS_CoreFactory.coreAliases[type];
    if (alias) {
        type = alias;
    }
    var cores = this._cores[type];
    return cores && cores[coreId];
};

/**
 * Releases a state core back to this factory, destroying it if the core's use count is then zero.
 * @param {Core} core Core to release
 */
SceneJS_CoreFactory.prototype.putCore = function (core) {

    if (core.useCount == 0) {
        return; // In case of excess puts
    }

    if (--core.useCount <= 0) {                    // Release shared core if use count now zero

        var cores = this._cores[core.type];

        delete cores[core.coreId];

        this._stateMap.removeItem(core.stateId);  // Release state ID for reuse
    }
};

/**
 * Reallocates WebGL resources for cores within this factory
 */
SceneJS_CoreFactory.prototype.webglRestored = function () {

    var cores;
    var core;

    for (var type in this._cores) {
        if (this._cores.hasOwnProperty(type)) {

            cores = this._cores[type];

            if (cores) {

                for (var coreId in cores) {
                    if (cores.hasOwnProperty(coreId)) {

                        core = cores[coreId];

                        if (core && core.webglRestored) { // Method augmented on core by user
                            core.webglRestored();
                        }
                    }
                }
            }
        }
    }
};
;/**
 * @class The basic scene graph node type
 */
SceneJS.Node = function () {
};

/**
 * @class Basic scene graph node
 */
SceneJS.Node.prototype.constructor = SceneJS.Node;

/**
 * Called by SceneJS_Engine after it has instantiated the node
 *
 * @param {SceneJS_Engine} engine The engine which will manage this node
 * @param {SceneJS_Core} core The core which will hold state for this node, may be shared with other nodes of the same type
 * @param cfg Configuration for this node
 * @param {String} cfg.id ID for the node, unique among all nodes in the scene
 * @param {String} cfg.type type Type of this node (eg. "material", "texture" etc)
 * @param {Object} cfg.data Optional arbitrary JSON object to attach to node
 * @param {String} nodeId Optional ID for node
 */
SceneJS.Node.prototype._construct = function (engine, core, cfg, nodeId) {

    /**
     * Engine that manages this node
     * @type SceneJS_Engine
     */
    this._engine = engine;

    /**
     * The core which holds state for this node, may be shared with other nodes of the same type
     * @type SceneJS_Core
     */
    this._core = core;

    /**
     * The core ID
     * @type {String|Number}
     */
    this.coreId = core.coreId;

    /**
     * ID of this node, unique within its scene. The ID is a string if it was defined by the application
     * via the node's JSON configuration, otherwise it is a number if it was left to SceneJS to automatically create.
     * @type String|Number
     */
    this.id = cfg.id || cfg.nodeId || nodeId;

    /**
     * Type of this node (eg. "material", "texture" etc)
     * @type String
     */
    this.type = cfg.type || "node";

    /**
     * Optional arbitrary JSON object attached to this node
     * @type JSON
     */
    this.data = cfg.data;

    /**
     * Parent node
     * @type SceneJS.Node
     */
    this.parent = null;

    /**
     * Child nodes
     * @type SceneJS.Node[]
     */
    this.nodes = [];

    // Pub/sub support
    this._handleMap = new SceneJS_Map(); // Subscription handle pool
    this._topicSubs = {}; // A [handle -> callback] map for each topic name
    this._handleTopics = {}; // Maps handles to topic names
    this._topicPubs = {}; // Maps topics to publications

    /**
     *
     */
    this._listeners = {};

    /**
     *
     */
    this._numListeners = 0; // Useful for quick check whether node observes any events

    /**
     *
     */
    this.dirty = false;

    /**
     *
     */
    this.branchDirty = false;

    if (this._init) {
        this._init(cfg);
    }
};

/**
 * Notifies that an asynchronous task has started on this node
 * @param {String} [description] Description - will be "Task" by default
 * @return {String} Unique ID for the task, which may be given to {@link #taskFinished} or {@link #taskFailed}
 */
SceneJS.Node.prototype.taskStarted = function (description) {
    return SceneJS_sceneStatusModule.taskStarted(this, description || "Task");
};

/**
 * Notifies that a task, whose initiation was previously notified with {@link #taskStarted},
 * has now completed successfully.
 * @param {String} taskId Unique ID for the task, which was got with {@link #taskStarted}
 * @return null
 */
SceneJS.Node.prototype.taskFinished = function (taskId) {
    return SceneJS_sceneStatusModule.taskFinished(taskId);
};

/**
 * Notifies that a task, whose initiation was previously notified with {@link #taskStarted},
 * has failed.
 * @param {String} taskId Unique ID for the task, which was got with {@link #taskStarted}
 * @return null
 */
SceneJS.Node.prototype.taskFailed = function (taskId) {
    return SceneJS_sceneStatusModule.taskFailed(taskId);
};

/**
 * Logs a message in the context of this node
 * @param {String} [channel] Logging channel - "error", "warn" or "info" (default)
 * @param {String} msg Message to log
 */
SceneJS.Node.prototype.log = function () {
    var channel;
    var msg;
    if (arguments.length == 1) {
        channel = "info";
        msg = arguments[0];
    } else if (arguments.length == 2) {
        channel = arguments[0];
        msg = arguments[1];
    }
    switch (channel) {
        case "warn":
            msg = "WARN;  [SceneJS.Node type=" + this.type + ", id=" + this.id + "] : " + msg;
            break;
        case "error":
            msg = "ERROR; [SceneJS.Node type=" + this.type + ", id=" + this.id + "] : " + msg;
            break;
        default:
            msg = "INFO;  [SceneJS.Node type=" + this.type + ", id=" + this.id + "] : " + msg;
            break;
    }

    if (console[channel]) {
        console[channel](msg);
    } else {
        console.log(msg);
    }
};

/**
 * Publishes to a topic on this node.
 *
 * Immediately notifies existing subscriptions to that topic, and unless the "forget' parameter is
 * true, retains the publication to give to any subsequent notifications on that topic as they are made.
 *
 * @param {String} topic Publication topic
 * @param {Object} pub The publication
 * @param {Boolean} [forget] When true, the publication will be sent to subscribers then forgotten, so that any
 * subsequent subscribers will not receive it
 */
SceneJS.Node.prototype.publish = function (topic, pub, forget) {
    if (!forget) {
        this._topicPubs[topic] = pub; // Save notification
    }
    if (this._topicSubs[topic]) { // Notify subscriptions
        var subsForTopic = this._topicSubs[topic];
        for (var handle in subsForTopic) {
            if (subsForTopic.hasOwnProperty(handle)) {
                subsForTopic[handle].call(this, pub);
            }
        }
    }
};

/**
 * Removes a topic publication
 *
 * Immediately notifies existing subscriptions to that topic, sending them each a null publication.
 *
 * @param topic Publication topic
 * @private
 */
SceneJS.Node.prototype.unpublish = function (topic) {
    var subsForTopic = this._topicSubs[topic];
    if (subsForTopic) { // Notify subscriptions
        for (var handle in subsForTopic) {
            if (subsForTopic.hasOwnProperty(handle)) {
                subsForTopic[handle].call(this, null);
            }
        }
    }
    delete this._topicPubs[topic];
};


/**
 * Listen for data changes at a particular location on this node
 *
 * <p>Your callback will be triggered for
 * the initial data and again whenever the data changes. Use {@link #off} to stop receiving updates.</p>
 *
 * <p>The callback is be called with this node as scope.</p>
 *
 * @param {String} location Publication location
 * @param {Function(data)} callback Called when fresh data is available at the location
 * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
 */
SceneJS.Node.prototype.on = function (topic, callback) {
    var subsForTopic = this._topicSubs[topic];
    if (!subsForTopic) {
        subsForTopic = {};
        this._topicSubs[topic] = subsForTopic;
    }
    var handle = this._handleMap.addItem(); // Create unique handle
    subsForTopic[handle] = callback;
    this._handleTopics[handle] = topic;
    var pub = this._topicPubs[topic];
    if (pub) { // A publication exists, notify callback immediately
        callback.call(this, pub);
    }
    //else {
    if (topic == "rendered") {
        this._engine.branchDirty(this);
    }
//    if (topic == "tick") {
//        this._engine.scene.on("tick",callback);
//    }
    // }
    return handle;
};

/**
 * Unsubscribes from a publication on this node that was previously made with {@link #on}.
 * @param handle Publication handle
 */
SceneJS.Node.prototype.off = function (handle) {
    var topic = this._handleTopics[handle];
    if (topic) {
        delete this._handleTopics[handle];
        var topicSubs = this._topicSubs[topic];
        if (topicSubs) {
            delete topicSubs[handle];
        }
        this._handleMap.removeItem(handle); // Release handle
        if (topic == "rendered") {
            this._engine.branchDirty(this);
        }
    }
//    else {
//        this._engine.scene.off(handle);
//    }
};

/**
 * Listens for exactly one data update at the specified location on this node, and then stops listening.
 * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
 * @param {String} location Data location to listen to
 * @param {Function(data)} callback Called when fresh data is available at the location
 */
SceneJS.Node.prototype.once = function (topic, callback) {
    var self = this;
    var sub = this.on(topic,
        function (pub) {
            self.off(sub);
            callback(pub);
        });
};

/**
 * Returns this node's {@link SceneJS.Scene}
 */
SceneJS.Node.prototype.getScene = function () {
    return this._engine.scene;
};

/**
 * Returns the ID of this node's core
 */
SceneJS.Node.prototype.getCoreId = function () {
    return this._core.coreId;
};

/**
 * Get the node's ID
 *
 */
SceneJS.Node.prototype.getID = function () {
    return this.id;
};

/**
 * Alias for getID
 *  @function
 */
SceneJS.Node.prototype.getId = function () {
    return this.id;
};

/**
 * Alias for getID
 *  @function
 */
SceneJS.Node.prototype.getNodeId = function () {
    return this.id;
};


/**
 * Returns the node's type. For the Node base class, it is "node", overridden in sub-classes.
 */
SceneJS.Node.prototype.getType = function () {
    return this.type;
};

/**
 * Returns the data object attached to this node.
 */
SceneJS.Node.prototype.getData = function () {
    return this.data;
};

/**
 * Sets a data object on this node.
 */
SceneJS.Node.prototype.setData = function (data) {
    this.data = data;
    return this;
};

/**
 * Returns the number of child nodes
 */
SceneJS.Node.prototype.getNumNodes = function () {
    return this.nodes.length;
};

/** Returns child nodes
 * @returns {Array} Child nodes
 */
SceneJS.Node.prototype.getNodes = function () {
    return this.nodes.slice(0);
};

/** Returns child node at given index. Returns null if no node at that index.
 * @param {Number} index The child index
 * @returns {Node} Child node, or null if not found
 */
SceneJS.Node.prototype.getNodeAt = function (index) {
    if (index < 0 || index >= this.nodes.length) {
        return null;
    }
    return this.nodes[index];
};

/** Returns first child node. Returns null if no child nodes.
 * @returns {Node} First child node, or null if not found
 */
SceneJS.Node.prototype.getFirstNode = function () {
    if (this.nodes.length == 0) {
        return null;
    }
    return this.nodes[0];
};

/** Returns last child node. Returns null if no child nodes.
 * @returns {Node} Last child node, or null if not found
 */
SceneJS.Node.prototype.getLastNode = function () {
    if (this.nodes.length == 0) {
        return null;
    }
    return this.nodes[this.nodes.length - 1];
};

/** Returns child node with the given ID.
 * Returns null if no such child node found.
 */
SceneJS.Node.prototype.getNode = function (id) {
    for (var i = 0; i < this.nodes.length; i++) {
        if (this.nodes[i].id == id) {
            return this.nodes[i];
        }
    }
    return null;
};

/** Disconnects the child node at the given index from its parent node
 * @param {int} index Child node index
 * @returns {Node} The disconnected child node if located, else null
 */
SceneJS.Node.prototype.disconnectNodeAt = function (index) {
    var r = this.nodes.splice(index, 1);
    if (r.length > 0) {
        r[0]._disconnectFromScene();
        r[0].parent = null;
        this._engine.branchDirty(this);
        return r[0];
    } else {
        return null;
    }
};

/** Disconnects the child node from its parent, given as a node object
 * @param {String | Node} id The target child node, or its ID
 * @returns {Node} The removed child node if located
 */
SceneJS.Node.prototype.disconnect = function () {
    if (this.parent) {
        for (var i = 0; i < this.parent.nodes.length; i++) {
            if (this.parent.nodes[i] === this) {
                var node = this.parent.disconnectNodeAt(i);
                this._disconnectFromScene();
                this.parent = null;
                return node;
            }
        }
        this._disconnectFromScene();
        this.parent = null;
    }
    return null;
};

/**
 * Connection callback that can be overridden in
 * specific node types
 */
SceneJS.Node.prototype._connectToScene = function () {
    if (this._connect) {
        this._connect();
    }
    for (var i = 0, len = this.nodes.length; i < len; i++) {
        this.nodes[i]._connectToScene();
    }
};

/**
 * Disconnection callback that can be overridden in
 * specific node types
 */
SceneJS.Node.prototype._disconnectFromScene = function () {
    if (this._disconnect) {
        this._disconnect();
    }
    for (var i = 0, len = this.nodes.length; i < len; i++) {
        this.nodes[i]._disconnectFromScene();
    }
};

/** Removes the child node at the given index
 * @param {int} index Child node index
 */
SceneJS.Node.prototype.removeNodeAt = function (index) {
    var child = this.disconnectNodeAt(index);
    if (child) {
        child.destroy();
    }
};

/** Removes the child node, given as either a node object or an ID string.
 * @param {String | Node} id The target child node, or its ID
 * @returns {Node} The removed child node if located
 */
SceneJS.Node.prototype.removeNode = function (node) {

    if (!node) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "Node#removeNode - node argument undefined");
    }

    if (!node._compile) {
        if (typeof node == "string") {
            var gotNode = this._engine.findNode(node);
            if (!gotNode) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.NODE_NOT_FOUND,
                    "Node#removeNode - node not found anywhere: '" + node + "'");
            }
            node = gotNode;
        }
    }

    if (node._compile) { //  instance of node
        for (var i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i] === node) {
                var removedNode = this.removeNodeAt(i);
                return removedNode;
            }
        }
    }

    throw SceneJS_error.fatalError(
        SceneJS.errors.NODE_NOT_FOUND,
        "Node#removeNode - child node not found: " + (node._compile ? ": " + node.id : node));
};

/** Disconnects all child nodes from their parent node and returns them in an array.
 */
SceneJS.Node.prototype.disconnectNodes = function () {
    var len = this.nodes.length;
    for (var i = 0; i < len; i++) {  // Unlink nodes from this
        this.nodes[i]._disconnectFromScene();
        this.nodes[i].parent = null;
    }
    var nodes = this.nodes;
    this.nodes = [];
    this._engine.branchDirty(this);
    return nodes;
};

/** Removes all child nodes and returns them in an array.
 */
SceneJS.Node.prototype.removeNodes = function () {
    var nodes = this.disconnectNodes();
    for (var i = 0; i < nodes.length; i++) {
        nodes[i].destroy();
    }
};

/** Destroys this node and moves children up to parent, inserting them where this node resided.
 */
SceneJS.Node.prototype.splice = function () {

    var i, len;

    if (this.parent == null) {
        return null;
    }
    var parent = this.parent;
    var nodes = this.disconnectNodes();
    for (i = 0, len = nodes.length; i < len; i++) {  // Link this node's nodes to new parent
        nodes[i].parent = this.parent;
        nodes[i]._connectToScene();
    }
    for (i = 0, len = parent.nodes.length; i < len; i++) { // Replace node on parent's nodes with this node's nodes
        if (parent.nodes[i] === this) {

            parent.nodes.splice.apply(parent.nodes, [i, 1].concat(nodes));

            this.nodes = [];
            this._disconnectFromScene();
            this.parent = null;

            this.destroy();

            this._engine.branchDirty(parent);

            return parent;
        }
    }
};

/** Appends multiple child nodes
 */
SceneJS.Node.prototype.addNodes = function (nodes, ok) {

    if (!nodes) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "Node#addNodes - nodes argument is undefined");
    }

    var node;
    var result = [];
    var numNodes = nodes.length;

    for (var i = nodes.length - 1; i >= 0; i--) {
        var nodeAttr = nodes[i];
        if (nodeAttr.type == "node" || this._engine.hasNodeType(nodeAttr.type)) {

            // Add loaded node type synchronously

            node = this.addNode(nodeAttr);
            result[i] = node;
            if (--numNodes == 0) {
                if (ok) {
                    ok(nodes);
                }
                return nodes;
            }
        } else {

            // Load node type and instantiate it asynchronously

            var self = this;
            (function () {
                var nodei = i;
                self.addNode(nodeAttr,
                    function (node) {
                        result[nodei] = node;
                        if (--numNodes == 0) {
                            if (ok) {
                                ok(nodes);
                            }
                        }
                    });
            })();
        }
    }
    return null;
};

/** Appends a child node
 */
SceneJS.Node.prototype.addNode = function (node, ok) {

    node = node || {};

    // Graft node object
    if (node._compile) {
        if (node.parent != null) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Node#addNode - node argument is still attached to another parent");
        }
        this.nodes.push(node);
        node.parent = this;
        node._connectToScene();
        this._engine.branchDirty(node);
        if (ok) {
            ok(node);
        }
        return node;
    }

    // Graft node object by ID reference
    if (typeof node == "string") {
        var gotNode = this._engine.findNode(node);
        if (!gotNode) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Node#addNode - node not found: '" + node + "'");
        }
        node = gotNode;
        if (node.parent != null) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Node#addNode - node argument is still attached to another parent");
        }
        this.nodes.push(node);
        node.parent = this;
        node._connectToScene();
        this._engine.branchDirty(node);
        if (ok) {
            ok(node);
        }
        return node;
    }

    // Create node

    node.type = node.type || "node";

    if (node.type == "node" || this._engine.hasNodeType(node.type)) {

        // Root node's type is already loaded, so we are able
        // to create the root synchronously. When the caller
        // is creating a core node type, then by this contract
        // it can rely on the return value

        node = this._engine.createNode(node);
        this.nodes.push(node);
        node.parent = this;
        node._connectToScene();
        this._engine.branchDirty(node);
        if (ok) {
            ok(node);
        }
        return node;

    } else {

        // Otherwise the root node's type needs to be loaded,
        // so we need to create it asynchronously. By this contract,
        // the Caller would not rely on synchronous creation of
        // non-core types.
        var self = this;
        this._engine.createNode(node,
            function (node) {
                self.nodes.push(node);
                node.parent = self;
                node._connectToScene();
                self._engine.branchDirty(node);
                if (ok) {
                    ok(node);
                }
            });
        return null;
    }
};

/** Inserts a subgraph into child nodes
 * @param {Node} node Child node
 * @param {int} i Index for new child node
 * @return {Node} The child node
 */
SceneJS.Node.prototype.insertNode = function (node, i) {

    if (!node) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.Node#insertNode - node argument is undefined");
    }

    if (!node._compile) { // JSON node definition
        node = this._engine.createNode(node); // Create node
    }

    if (!node._compile) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.Node#insertNode - node argument is not a SceneJS.Node");
    }

    if (node.parent != null) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.Node#insertNode - node argument is still attached to another parent");
    }

    if (i === undefined || i === null) {
        node.addNodes(this.disconnectNodes());
        this.addNode(node);

    } else if (i < 0) {

        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.Node#insertNode - node index out of range: -1");

    } else if (i >= this.nodes.length) {
        this.nodes.push(node);
    } else {
        this.nodes.splice(i, 0, node);
    }

    node.parent = this;
    node._connectToScene();
    return node;
};

/** Calls the given function on each node in the subgraph rooted by this node, including this node.
 * The callback takes each node as it's sole argument and traversal stops as soon as the function returns
 * true and returns the node.
 * @param {function(Node)} func The function
 */
SceneJS.Node.prototype.mapNodes = function (func) {
    if (func(this)) {
        return this;
    }
    var result;
    for (var i = 0; i < this.nodes.length; i++) {
        result = this.nodes[i].mapNodes(func);
        if (result) {
            return result;
        }
    }
    return null;
};

/**
 * Registers a listener for a given event on this node. If the event type
 * is not supported by this node type, then the listener will never be called.
 * <p><b>Example:</b>
 * <pre><code>
 * var node = new Node();
 *
 * node.addListener(
 *
 *              // eventName
 *              "some-event",
 *
 *              // handler
 *              function(node,      // Node we are listening to
 *                       params) {  // Whatever params accompany the event type
 *
 *                     // ...
 *              }
 * );
 *
 *
 * </code></pre>
 *
 * @param {String} eventName One of the event types supported by this node
 * @param {Function} fn - Handler function that be called as specified
 * @param options - Optional options for the handler as specified
 * @return {Node} this
 */
SceneJS.Node.prototype.addListener = function (eventName, fn, options) {
    var list = this._listeners[eventName];
    if (!list) {
        list = [];
        this._listeners[eventName] = list;
    }
    list.push({
        eventName:eventName,
        fn:fn,
        options:options || {}
    });
    this._numListeners++;
    return this;
};

/**
 * Fires an event at this node, immediately calling listeners registered for the event
 */
SceneJS.Node.prototype._fireEvent = function (eventName, params, options) {
    var list = this._listeners[eventName];
    if (list) {
        if (!params) {
            params = {};
        }
        var event = {
            name:eventName,
            params:params,
            options:options || {}
        };
        var listener;
        for (var i = 0, len = list.length; i < len; i++) {
            listener = list[i];
            if (listener.options.scope) {
                listener.fn.call(listener.options.scope, event);
            } else {
                listener.fn.call(this, event);
            }
        }
    }
};

/**
 * Removes a handler that is registered for the given event on this node.
 * Does nothing if no such handler registered.
 */
SceneJS.Node.prototype.removeListener = function (eventName, fn) {
    var list = this._listeners[eventName];
    if (!list) {
        return null;
    }
    for (var i = 0; i < list.length; i++) {
        if (list[i].fn == fn) {
            list.splice(i, 1);
            return fn;
        }
    }
    this._numListeners--;
    return null;
};

/**
 * Returns true if this node has any listeners for the given event
 */
SceneJS.Node.prototype.hasListener = function (eventName) {
    return this._listeners[eventName];
};

/**
 * Returns true if this node has any listeners at all.
 */
SceneJS.Node.prototype.hasListeners = function () {
    return (this._numListeners > 0);
};

/** Removes all listeners registered on this node.
 */
SceneJS.Node.prototype.removeListeners = function () {
    this._listeners = {};
    this._numListeners = 0;
    return this;
};

/**
 * Returns the parent node
 * @return {SceneJS.Node}
 */
SceneJS.Node.prototype.getParent = function (type) {
    return this.parent;
};

/**
 * Finds the first node of given type on path to root.
 * @param {String} type Parent type to find on path to root
 * @return {SceneJS.Node}
 */
SceneJS.Node.prototype.getParentOfType = function (type) {
    var parent = this.parent;
    while (parent && parent.type != type) {
        parent = parent.parent;
    }
    return parent;
};

/**
 * Iterates over parent nodes on the path from the selected node to the root, executing a function
 * for each.
 * If the function returns true at any node, then traversal stops and a selector is
 * returned for that node.
 * @param {Function(node, index)} fn Function to execute on each instance node
 * @return {Object} Selector for selected node, if any
 */
SceneJS.Node.prototype.eachParent = function (fn) {

    if (!fn) {
        throw "SceneJS.Node.eachParent param 'fn' is null or undefined";
    }

    var count = 0;
    var node = this;

    while (node.parent) {
        if (fn.call(node.parent, count++) === true) {
            return node.parent;
        }
        node = node.parent;
    }

    return null;
};

/** Returns true if a child node matching given ID or index exists on this node
 * @param {Number|String} node Child node index or ID
 */
SceneJS.Node.prototype.hasNode = function (node) {

    if (node === null || node === undefined) {
        throw "SceneJS.Node.hasNode param 'node' is null or undefined";
    }

    var type = typeof node;
    var nodeGot;

    if (type == "number") {
        nodeGot = this.getNodeAt(node);

    } else if (type == "string") {
        nodeGot = this.getNode(node);

    } else {
        throw "SceneJS.Node.hasNode param 'node' should be either an index number or an ID string";
    }

    return (nodeGot != undefined && nodeGot != null);
};

/** Selects a child node matching given ID or index
 * @param {Number|String} node Child node index or ID
 */
SceneJS.Node.prototype.node = function (node) {

    if (node === null || node === undefined) {
        throw "SceneJS.Node.node param 'node' is null or undefined";
    }

    var type = typeof node;
    var nodeGot;

    if (type == "number") {
        nodeGot = this.getNodeAt(node);

    } else if (type == "string") {
        nodeGot = this.getNode(node);

    } else {
        throw "SceneJS.Node.node param 'node' should be either an index number or an ID string";
    }

    if (!nodeGot) {
        throw "SceneJS.Node.node - node not found: '" + node + "'";
    }

    return nodeGot;
};

/**
 * Iterates over sub-nodes of the selected node, executing a function
 * for each. With the optional options object we can configure is depth-first or breadth-first order.
 * If neither, then only the child nodes are iterated.
 * If the function returns true at any node, then traversal stops and a selector is
 * returned for that node.
 * @param {Function(index, node)} fn Function to execute on each child node
 * @return {Object} Selector for selected node, if any
 */
SceneJS.Node.prototype.eachNode = function (fn, options) {

    if (!fn) {
        throw "SceneJS.Node.eachNode param 'fn' is null or undefined";
    }

    if (typeof fn != "function") {
        throw "SceneJS.Node.eachNode param 'fn' should be a function";
    }

    var stoppedNode;
    options = options || {};
    var count = 0;

    if (options.andSelf) {
        if (fn.call(this, count++) === true) {
            return this;
        }
    }

    if (!options.depthFirst && !options.breadthFirst) {
        stoppedNode = this._iterateEachNode(fn, this, count);

    } else if (options.depthFirst) {
        stoppedNode = this._iterateEachNodeDepthFirst(fn, this, count, false); // Not below root yet

    } else {
        // TODO: breadth-first
    }

    if (stoppedNode) {
        return stoppedNode;
    }

    return undefined; // IDE happy now
};

SceneJS.Node.prototype.numNodes = function () {
    return this.nodes.length;
};

SceneJS.Node.prototype._iterateEachNode = function (fn, node, count) {

    var len = node.nodes.length;
    var child;

    for (var i = 0; i < len; i++) {
        child = node.nodes[i];

        if (fn.call(child, count++) === true) {
            return child;
        }
    }

    return null;
};

SceneJS.Node.prototype._iterateEachNodeDepthFirst = function (fn, node, count, belowRoot) {

    if (belowRoot) {

        /* Visit this node - if we are below root, because entry point visits the root
         */
        if (fn.call(node, count++) === true) {
            return node;
        }
    }

    belowRoot = true;

    /* Iterate nodes
     */
    var len = node.nodes.length;
    var child;
    for (var i = 0; i < len; i++) {
        child = this._iterateEachNodeDepthFirst(fn, node.nodes[i], count, belowRoot);
        if (child) {
            return child;
        }
    }

    return null;
};

/** Returns either all child or all sub-nodes of the given type, depending on whether search is recursive or not.
 */
SceneJS.Node.prototype.findNodesByType = function (type, recursive) {
    return this._findNodesByType(type, [], recursive);
};

SceneJS.Node.prototype._findNodesByType = function (type, list, recursive) {
    var i;
    for (i = 0; i < this.nodes.length; i++) {
        var node = this.nodes[i];
        if (node.type == type) {
            list.push(node);
        }
    }
    if (recursive) {
        for (i = 0; i < this.nodes.length; i++) {
            this.nodes[i]._findNodesByType(type, list, recursive);
        }
    }
    return list;
};

/** Finds the first node on path up to root whose type equals that given
 */
SceneJS.Node.prototype.findParentByType = function (type) {
    var parent = this.parent;
    while (parent && parent.type != type) {
        parent = parent.parent;
    }
    return parent;
};

/** Binds a listener to an event on the selected node
 *
 * @param {String} name Event name
 * @param {Function} handler Event handler
 */
SceneJS.Node.prototype.bind = function (name, handler) {

    if (!name) {
        throw "SceneJS.Node.bind param 'name' null or undefined";
    }

    if (typeof name != "string") {
        throw "SceneJS.Node.bind param 'name' should be a string";
    }

    if (!handler) {
        throw "SceneJS.Node.bind param 'handler' null or undefined";
    }

    if (typeof handler != "function") {
        throw "SceneJS.Node.bind param 'handler' should be a function";
    }

    this.addListener(name, handler, { scope:this });

    this._engine.branchDirty(this);

    return handler;
};

/**
 * Returns an object containing the attributes that were given when creating the node. Obviously, the map will have
 * the current values, plus any attributes that were later added through set/add methods on the node
 *
 */
SceneJS.Node.prototype.getJSON = function () {
    return this;
};


SceneJS.Node.prototype._compile = function (ctx) {
    if (this.preCompile) {
        this.preCompile();
    }
    this._compileNodes(ctx);
    if (this.postCompile) {
        this.postCompile();
    }
};

SceneJS.Node.prototype._compileNodes = function (ctx) {

    var renderSubs = this._topicSubs["rendered"];

    if (renderSubs) {
        SceneJS_nodeEventsModule.preVisitNode(this);
    }

//    var tickSubs = this._topicSubs["tick"];
//
//    if (tickSubs) {
//        ctx.pubSubProxy.on("tick", function(event) {
//            this.publish("tick", event);
//        });
//    }

    var child;

    for (var i = 0, len = this.nodes.length; i < len; i++) {

        child = this.nodes[i];

        child.branchDirty = child.branchDirty || this.branchDirty; // Compile subnodes if scene branch dirty

        if (child.dirty || child.branchDirty || this._engine.sceneDirty) {  // Compile nodes that are flagged dirty
            child._compile(ctx);
            child.dirty = false;
            child.branchDirty = false;
        }
    }

    if (renderSubs) {
        SceneJS_nodeEventsModule.postVisitNode(this);
    }
};



/**
 * Destroys this node. It is marked for destruction; when the next scene traversal begins (or the current one ends)
 * it will be destroyed and removed from it's parent.
 */
SceneJS.Node.prototype.destroy = function () {

    if (!this.destroyed) {

        if (this.parent) {

            // Remove from parent's child node list

            var parentNodes = this.parent.nodes;
            var len = parentNodes.length;
            for (var i = 0; i < len; i++) {
                if (parentNodes[i].id === this.id) {
                    parentNodes.splice(i, 1);
                    break;
                }
            }
        }

        // Remove publication
        this._engine.scene.unpublish("nodes/" + this.id);

        /* Recusrsively destroy child nodes without
         * bothering to remove them from their parents
         */
        this._destroyTree();

        /* Need object list recompilation on display
         */
        this._engine.display.objectListDirty = true;
    }

    return this;
};

SceneJS.Node.prototype._destroyTree = function () {

    this.destroyed = true;

    this._engine.destroyNode(this); // Release node object

    var childNode;
    for (var i = 0, len = this.nodes.length; i < len; i++) {
        childNode = this.nodes[i];
        this._engine.scene.unpublish("nodes/" + childNode.id);
        childNode._destroyTree();
    }
};

/**
 * Performs the actual destruction of this node, calling the node's optional template destroy method
 */
SceneJS.Node.prototype._doDestroy = function () {

    if (this._destroy) {  // Call destruction handler for each node subclass
        this._destroy();
    }

    return this;
};
;SceneJS_PubSubProxy = function (scene, proxy) {
    this.scene = scene;
    this.proxy = proxy;

};



;/**
 * @class Manages creation, recycle and destruction of {@link SceneJS.Node} instances
 * @private
 */
var SceneJS_NodeFactory = function () {

    /** Nodes created by this factory
     * @type {SceneJS_Map}
     */
    this.nodes = new SceneJS_Map({});
};

/**
 * Scene graph node classes provided by the SceneJS_NodeFactory class
 *
 * @type {[SceneJS.Node]}
 */
SceneJS_NodeFactory.nodeTypes = {};

/**
 * Subscribers waiting for node types
 * @type {Object}
 * @private
 */
SceneJS_NodeFactory._subs = {};

/**
 * Creates a node class for instantiation by this factory
 *
 * @param {String} typeName Name of type, eg. "rotate"
 * @param {String} coreTypeName Optional name of core type for the node, eg. "xform" - defaults to type name of node
 * @param {Function} [augment] Augments the basic node type with our custom node methods
 * @returns The new node class
 */
SceneJS_NodeFactory.createNodeType = function (typeName, coreTypeName, augment) {
    if (SceneJS_NodeFactory.nodeTypes[typeName]) {
        throw "Node type already defined: " + typeName;
    }
    var nodeType = function () { // Create the class
        SceneJS.Node.apply(this, arguments);
        this.type = typeName;
    };
    nodeType.prototype = new SceneJS.Node();            // Inherit from base class
    nodeType.prototype.constructor = nodeType;
    SceneJS_NodeFactory.nodeTypes[typeName] = nodeType;

    var type = SceneJS_NodeFactory.nodeTypes[typeName]; // Type has installed itself
    if (!type) {
        throw "Node type plugin did not install itself correctly";
    }
    // Augment the basic node type
    if (augment) {
        augment(nodeType);
    }
    // Notify subscribers waiting for the type
    var subs = SceneJS_NodeFactory._subs[typeName];
    if (subs) {
        while (subs.length > 0) {
            subs.pop()(type);
        }
        delete subs[typeName];
    }
    return nodeType;
};

/**
 *
 */
SceneJS_NodeFactory.prototype.getNode = function (engine, json, core, ok) {
    json.type = json.type || "node"; // Nodes are SceneJS.Node type by default
    var nodeType;
    if (json.type == "node") {
        nodeType = SceneJS.Node;
    } else {
        nodeType = SceneJS_NodeFactory.nodeTypes[json.type];
    }
    if (nodeType) {
        return this._createNode(nodeType, engine, json, core, ok);
    } else {
        var self = this;
        this._getType(
            engine,
            json.type,
            function (nodeType) {
                self._createNode(nodeType, engine, json, core, ok);
            });
    }
};

SceneJS_NodeFactory.prototype._createNode = function (nodeType, engine, json, core, ok) {
    var node = new nodeType();
    var id = json.id || json.nodeId; // 'id' and 'nodeId' are aliases
    if (id) {
        this.nodes.addItem(id, node);
    } else {
        id = this.nodes.addItem(node);
    }
    node._construct(engine, core, json, id); // Instantiate node
    if (ok) {
        ok(node);
    }
    return node;
};

/**
 * Returns installed type of given type and ID
 */
SceneJS_NodeFactory.prototype._getType = function (engine, typeName, ok) {
    var type = SceneJS_NodeFactory.nodeTypes[typeName];
    if (type) {
        ok(type);
        return;
    }
    var subs = SceneJS_NodeFactory._subs[typeName] || (SceneJS_NodeFactory._subs[typeName] = []);
    subs.push(ok);
    if (subs.length > 1) { // Not first sub
        return;
    }
    var taskId = SceneJS_sceneStatusModule.taskStarted(engine.scene, "Loading plugin");
    subs.push(function () {
        SceneJS_sceneStatusModule.taskFinished(taskId);
    });
    var self = this;
    var typePath = SceneJS_configsModule.configs.pluginPath;
    if (!typePath) {
        throw "no typePath config"; // Build script error - should create this config
    }
    this._loadScript(typePath + "/node/" + typeName + ".js",
        function () {
            SceneJS_sceneStatusModule.taskFailed(taskId);
        });
};

SceneJS_NodeFactory.prototype._loadScript = function (url, error) {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src = url;
    script.onerror = error;
    document.getElementsByTagName("head")[0].appendChild(script);
};

/**
 * Releases a node back to this factory
 */
SceneJS_NodeFactory.prototype.putNode = function (node) {
    this.nodes.removeItem(node.id);
};
;/**
 * @class Scene graph node which defines a billboard transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
new (function () {

    // The default state core singleton for {@link SceneJS.Billboard} nodes
    var defaultCore = {
        type: "billboard",
        stateId: SceneJS._baseStateId++,
        empty: true,
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.billboard = defaultCore;
            stackLen = 0;
        });

    var coreStack = [];
    var stackLen = 0;

    /**
     * @class Scene graph node which defines a billboard transform for nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Billboard = SceneJS_NodeFactory.createNodeType("billboard");

    SceneJS.Billboard.prototype._init = function (params) {
        if (this._core.useCount == 1) { // This node is the resource definer
            this._core.spherical = (params.spherical !== false);
        }
        this._core.hash = "bb;";
    };

    /** Sets whether this billboard is spherical (default), where it "rotates" about the X and Y-axis,
     * if required, to face the viewpoint, or cylindrical, where it only rotates about the Y-axis.
      * @param spherical
     */
    SceneJS.Billboard.prototype.setSpherical = function (spherical) {
        this._core.spherical = spherical;
        this._engine.branchDirty(this);
        this._engine.display.imageDirty = true;
    };

    SceneJS.Billboard.prototype.getSpherical = function () {
        return this._core.spherical;
    };

    SceneJS.Billboard.prototype._compile = function (ctx) {
        coreStack[stackLen++] = this._core;
        this._engine.display.billboard = this._core;
        this._compileNodes(ctx);
        this._engine.display.billboard = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
    };

    SceneJS.Billboard.prototype._destroy = function () {
        if (this._core) {
            this._engine._coreFactory.putCore(this._core);
        }
    };

})();;(function () {

    var defaultMatrix = SceneJS_math_perspectiveMatrix4(
        45, // fovy
        1, // aspect
        0.1, // near
        10000); // far

    var defaultMat = new Float32Array(defaultMatrix);

    // The default state core singleton for {@link SceneJS.Camera} nodes
    var defaultCore = {
        type: "camera",
        stateId: SceneJS._baseStateId++,
        matrix: defaultMatrix,
        mat: defaultMat,
        optics: {
            type: "perspective",
            fovy: 45.0,
            aspect: 1.0,
            near: 0.1,
            far: 10000.0
        },
        checkAspect: function (core, aspect) {
            if (core.optics.aspect != aspect) {
                core.optics.aspect = aspect;
                rebuildCore(this);
            }
        }
    };

    var coreStack = [];
    var stackLen = 0;

    // Set default core on the display at the start of each new scene compilation
    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.projTransform = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines the projection transform to apply to the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Camera = SceneJS_NodeFactory.createNodeType("camera");

    SceneJS.Camera.prototype._init = function (params) {
        if (this._core.useCount == 1) {

            params.optics = params.optics || {};
            var canvas = this.getScene().getCanvas();
            params.optics.aspect = canvas.width / canvas.height;
            this.setOptics(params.optics); // Can be undefined

            if (params.pan) {
                this.setPan(params.pan);
            }

            var self = this;

            this._canvasSizeSub = this.getScene().on("canvasSize",
                function (c) {
                    self._core.optics.aspect = c.aspect;
                    rebuildCore(self._core);
                    self._engine.display.imageDirty = true;
                });
        }
    };

    /**
     * Returns the default camera projection matrix
     * @return {Float32Array}
     */
    SceneJS.Camera.getDefaultMatrix = function () {
        return defaultMat;
    };

    SceneJS.Camera.prototype.setOptics = function (optics) {
        var core = this._core;
        if (!optics) {
            core.optics = {
                type: "perspective",
                fovy: 60.0,
                aspect: 1.0,
                near: 0.1,
                far: 10000.0
            };
        } else {
            var type = optics.type;
            if (!type) {
                if (core.optics) {
                    type = core.optics.type;
                }
            }
            type = type || "perspective";
            if (type == "ortho") {
                core.optics = SceneJS._applyIf(SceneJS_math_ORTHO_OBJ, {
                    type: type,
                    left: optics.left,
                    bottom: optics.bottom,
                    near: optics.near,
                    right: optics.right,
                    top: optics.top,
                    far: optics.far
                });
            } else if (type == "frustum") {
                core.optics = {
                    type: type,
                    left: optics.left || -1.0,
                    bottom: optics.bottom || -1.0,
                    near: optics.near || 0.1,
                    right: optics.right || 1.00,
                    top: optics.top || 1.0,
                    far: optics.far || 10000.0
                };
            } else if (type == "perspective") {
                core.optics = {
                    type: type,
                    fovy: optics.fovy || 60.0,
                    aspect: optics.aspect == undefined ? 1.0 : optics.aspect,
                    near: optics.near || 0.1,
                    far: optics.far || 10000.0
                };
            } else if (!optics.type) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "SceneJS.Camera configuration invalid: optics type not specified - " +
                    "supported types are 'perspective', 'frustum' and 'ortho'");
            } else {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "SceneJS.Camera configuration invalid: optics type not supported - " +
                    "supported types are 'perspective', 'frustum' and 'ortho'");
            }
        }
        this._core.optics.pan = optics.pan;
        rebuildCore(this._core);
        this.publish("matrix", this._core.matrix);
        this._engine.display.imageDirty = true;
    };

    SceneJS.Camera.prototype.setPan = function (pan) {
        this._core.pan = pan;
        rebuildCore(this._core);
        this.publish("matrix", this._core.matrix);
        this._engine.display.imageDirty = true;
    };

    function rebuildCore(core) {
        var optics = core.optics;
        if (optics.type == "ortho") {
            core.matrix = SceneJS_math_orthoMat4c(
                optics.left,
                optics.right,
                optics.bottom,
                optics.top,
                optics.near,
                optics.far);

        } else if (optics.type == "frustum") {
            core.matrix = SceneJS_math_frustumMatrix4(
                optics.left,
                optics.right,
                optics.bottom,
                optics.top,
                optics.near,
                optics.far);

        } else if (optics.type == "perspective") {
            core.matrix = SceneJS_math_perspectiveMatrix4(
                optics.fovy * Math.PI / 180.0,
                optics.aspect,
                optics.near,
                optics.far);
        }

        if (core.pan) {
            // Post-multiply a screen-space pan
            var pan = core.pan;
            var panMatrix = SceneJS_math_translationMat4v([pan.x || 0, pan.y || 0, pan.z || 0]);
            core.matrix = SceneJS_math_mulMat4(panMatrix, core.matrix, []);
        }

        if (!core.mat) {
            core.mat = new Float32Array(core.matrix);
        } else {
            core.mat.set(core.matrix);
        }
    }

    SceneJS.Camera.prototype.getOptics = function () {
        var optics = {};
        for (var key in this._core.optics) {
            if (this._core.optics.hasOwnProperty(key)) {
                optics[key] = this._core.optics[key];
            }
        }
        return optics;
    };

    SceneJS.Camera.prototype.getMatrix = function () {
        return SceneJS._sliceArray(this._core.matrix, 0);
    };

    /**
     * Compiles this camera node, setting this node's state core on the display, compiling sub-nodes,
     * then restoring the previous camera state core back onto the display on exit.
     */
    SceneJS.Camera.prototype._compile = function (ctx) {
        this._engine.display.projTransform = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.projTransform = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Camera.prototype._destroy = function () {
        this.getScene().off(this._canvasSizeSub);
    };
})();;(function() {

    /**
     * The default state core singleton for {@link SceneJS.Clips} nodes
     */
    var defaultCore = {
        type: "clips",
        stateId: SceneJS._baseStateId++,
        empty: true,        
        hash: "",
        clips : []
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING,
            function(params) {
                params.engine.display.clips = defaultCore;
                stackLen = 0;
            });

    /**
     * @class Scene graph node which defines one or more arbitrarily-aligned clip planes to clip the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Clips = SceneJS_NodeFactory.createNodeType("clips");

    SceneJS.Clips.prototype._init = function(params) {

        if (this._core.useCount == 1) { // This node defines the resource

            var clips = params.clips;

            if (!clips) {
                throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "clips node attribute missing : 'clips'");
            }

            this._core.clips = this._core.clips || [];

            for (var i = 0, len = clips.length; i < len; i++) {
                this._setClip(i, clips[i]);
            }
        }
    };

    SceneJS.Clips.prototype.setClips = function(clips) {
        var indexNum;
        for (var index in clips) {
            if (clips.hasOwnProperty(index)) {
                if (index != undefined || index != null) {
                    indexNum = parseInt(index);
                    if (indexNum < 0 || indexNum >= this._core.clips.length) {
                        throw SceneJS_error.fatalError(
                                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                                "Invalid argument to set 'clips': index out of range (" + this._core.clips.length + " clips defined)");
                    }
                    this._setClip(indexNum, clips[index] || {});
                }
            }
        }
        this._engine.display.imageDirty = true;
    };

    SceneJS.Clips.prototype._setClip = function(index, cfg) {

        var clip = this._core.clips[index] || (this._core.clips[index] = {});

        clip.normalAndDist = [cfg.x || 0,  cfg.y || 0, cfg.z || 0, cfg.dist || 0];

        var mode = cfg.mode || clip.mode || "disabled";

        if (mode != "inside" && mode != "outside" && mode != "disabled") {
            throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "clips node invalid value for property 'mode': should be 'inside' or 'outside' or 'disabled'");
        }
        clip.mode = mode;

        this._core.hash = null;
    };

    SceneJS.Clips.prototype._compile = function(ctx) {

        if (!this._core.hash) {
            this._core.hash = this._core.clips.length;
        }

        this._engine.display.clips = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.clips = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };


})();;(function () {

    // The default state core singleton for {@link SceneJS.Enable} nodes
    var defaultCore = {
        stateId:SceneJS._baseStateId++,
        type:"enable",
        enabled:true
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.enable = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which enables or disables rendering for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Enable = SceneJS_NodeFactory.createNodeType("enable");

    SceneJS.Enable.prototype._init = function (params) {
        if (this._core.useCount == 1) {   // This node is first to reference the state core, so sets it up
            this._core.enabled = true;
            if (params.enabled != undefined) {
                this.setEnabled(params.enabled);
            }
        }
    };

    SceneJS.Enable.prototype.setEnabled = function (enabled) {
        if (enabled !== this._core.enabled) {
            this._core.enabled = enabled;
            this._engine.display.drawListDirty = true;
            this.publish("enabled", enabled);
        }
        return this;
    };

    SceneJS.Enable.prototype.getEnabled = function () {
        return this._core.enabled;
    };

    SceneJS.Enable.prototype._compile = function (ctx) {
        this._engine.display.enable = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.enable = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();;(function () {

    /**
     * The default state core singleton for {@link SceneJS.Flags} nodes
     */
    var defaultCore = {

        stateId: SceneJS._baseStateId++,
        type: "flags",

        picking: true,              // Picking enabled
        clipping: true,             // User-defined clipping enabled
        enabled: true,              // Node not culled from traversal
        transparent: false,         // Node transparent - works in conjunction with matarial alpha properties
        backfaces: true,            // Show backfaces
        frontface: "ccw",           // Default vertex winding for front face
        reflective: true,           // Reflects reflection node cubemap, if it exists, by default.
        solid: false,               // When true, renders backfaces without texture or shading, for a cheap solid cross-section effect
        solidColor: [1.0, 1.0, 1.0],// Solid cap color
        skybox: false,              // Treat as a skybox
        hash: "refl;;;"
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.flags = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which sets rendering mode flags for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Flags = SceneJS_NodeFactory.createNodeType("flags");

    SceneJS.Flags.prototype._init = function (params) {

        if (this._core.useCount == 1) {         // This node is first to reference the state core, so sets it up

            this._core.picking = true;           // Picking enabled
            this._core.clipping = true;          // User-defined clipping enabled
            this._core.enabled = true;           // Node not culled from traversal
            this._core.transparent = false;      // Node transparent - works in conjunction with matarial alpha properties
            this._core.backfaces = true;         // Show backfaces
            this._core.frontface = "ccw";        // Default vertex winding for front face
            this._core.reflective = true;        // Reflects reflection node cubemap, if it exists, by default.
            this._core.solid = false;            // Renders backfaces without texture or shading, for a cheap solid cross-section effect
            this._core.solidColor = [1.0, 1.0, 1.0 ]; // Solid cap color
            this._core.skybox = false;              // Treat as a skybox
            if (params.flags) {                  // 'flags' property is actually optional in the node definition
                this.setFlags(params.flags);
            }
        }
    };

    SceneJS.Flags.prototype.setFlags = function (flags) {

        var core = this._core;

        if (flags.picking != undefined) {
            core.picking = !!flags.picking;
            this._engine.display.drawListDirty = true;
        }

        if (flags.clipping != undefined) {
            core.clipping = !!flags.clipping;
            this._engine.display.imageDirty = true;
        }

        if (flags.enabled != undefined) {
            core.enabled = !!flags.enabled;
            this._engine.display.drawListDirty = true;
        }

        if (flags.transparent != undefined) {
            core.transparent = !!flags.transparent;
            this._engine.display.stateSortDirty = true;
        }

        if (flags.backfaces != undefined) {
            core.backfaces = !!flags.backfaces;
            this._engine.display.imageDirty = true;
        }

        if (flags.frontface != undefined) {
            core.frontface = flags.frontface;
            this._engine.display.imageDirty = true;
        }

        if (flags.reflective != undefined) {
            core.reflective = flags.reflective;
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (flags.solid != undefined) {
            core.solid = flags.solid;
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (flags.solidColor != undefined) {
            var defaultSolidColor = defaultCore.solidColor;
            var color = flags.solidColor;
            core.solidColor = color ? [
                color.r != undefined && color.r != null ? color.r : defaultSolidColor[0],
                color.g != undefined && color.g != null ? color.g : defaultSolidColor[1],
                color.b != undefined && color.b != null ? color.b : defaultSolidColor[2]
            ] : defaultCore.solidColor;
            this._engine.display.imageDirty = true;
        }

        if (flags.skybox != undefined) {
            core.skybox = flags.skybox;
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        core.hash = getHash(core);

        return this;
    };

    SceneJS.Flags.prototype.getFlags = function () {
        var core = this._core;
        return {
            picking: core.picking,
            clipping: core.clipping,
            enabled: core.enabled,
            transparent: core.transparent,
            backfaces: core.backfaces,
            frontface: core.frontface,
            reflective: core.reflective,
            solid: core.solid,
            solidColor: core.solidColor
        };
    };

    SceneJS.Flags.prototype.setPicking = function (picking) {
        picking = !!picking;
        if (this._core.picking != picking) {
            this._core.picking = picking;
            this._engine.display.drawListDirty = true;
        }
        return this;
    };

    SceneJS.Flags.prototype.getPicking = function () {
        return this._core.picking;
    };

    SceneJS.Flags.prototype.setClipping = function (clipping) {
        clipping = !!clipping;
        if (this._core.clipping != clipping) {
            this._core.clipping = clipping;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Flags.prototype.getClipping = function () {
        return this._core.clipping;
    };

    SceneJS.Flags.prototype.setEnabled = function (enabled) {
        enabled = !!enabled;
        if (this._core.enabled != enabled) {
            this._core.enabled = enabled;
            this._engine.display.drawListDirty = true;
        }
        return this;
    };

    SceneJS.Flags.prototype.getEnabled = function () {
        return this._core.enabled;
    };

    SceneJS.Flags.prototype.setTransparent = function (transparent) {
        transparent = !!transparent;
        if (this._core.transparent != transparent) {
            this._core.transparent = transparent;
            this._engine.display.stateOrderDirty = true;
        }
        return this;
    };

    SceneJS.Flags.prototype.getTransparent = function () {
        return this._core.transparent;
    };

    SceneJS.Flags.prototype.setBackfaces = function (backfaces) {
        backfaces = !!backfaces;
        if (this._core.backfaces != backfaces) {
            this._core.backfaces = backfaces;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Flags.prototype.getBackfaces = function () {
        return this._core.backfaces;
    };

    SceneJS.Flags.prototype.setFrontface = function (frontface) {
        if (this._core.frontface != frontface) {
            this._core.frontface = frontface;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Flags.prototype.getFrontface = function () {
        return this._core.frontface;
    };

    SceneJS.Flags.prototype.setReflective = function (reflective) {
        reflective = !!reflective;
        if (this._core.reflective != reflective) {
            this._core.reflective = reflective;
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Flags.prototype.getReflective = function () {
        return this._core.reflective;
    };

    SceneJS.Flags.prototype.setSolid = function (solid) {
        solid = !!solid;
        if (this._core.solid != solid) {
            this._core.solid = solid;
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Flags.prototype.getSolid = function () {
        return this._core.solid;
    };

    SceneJS.Flags.prototype.setSolidColor = function (color) {
        var defaultSolidColor = defaultCore.solidColor;
        this._core.solidColor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultSolidColor[0],
            color.g != undefined && color.g != null ? color.g : defaultSolidColor[1],
            color.b != undefined && color.b != null ? color.b : defaultSolidColor[2]
        ] : defaultCore.solidColor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Flags.prototype.getSolidColor = function () {
        return {
            r: this._core.solidColor[0],
            g: this._core.solidColor[1],
            b: this._core.solidColor[2]
        };
    };

    SceneJS.Flags.prototype.setSkybox = function (skybox) {
        skybox = !!skybox;
        if (this._core.skybox != skybox) {
            this._core.skybox = skybox;
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Flags.prototype.getSkybox = function () {
        return this._core.skybox;
    };

    SceneJS.Flags.prototype._compile = function (ctx) {
        this._engine.display.flags = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.flags = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    function getHash(core) {
        return (core.reflective ? "refl" : "") + ";" +
                (core.solid ? "s" : "") + ";" +
                (core.skybox ? "sky" : "") + ";";
    }

})();
;new (function () {

    var defaultCore = {
        type: "renderTarget",
        stateId: SceneJS._baseStateId++,
        targets: null
    };

    // Map of  nodes to cores, for reallocation on WebGL context restore
    var nodeCoreMap = {};

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.renderTarget = defaultCore;
            stackLen = 0;
        });

    // Reallocate VBOs when context restored after loss
    SceneJS_events.addListener(
        SceneJS_events.WEBGL_CONTEXT_RESTORED,
        function () {
            for (var nodeId in nodeCoreMap) {
                if (nodeCoreMap.hasOwnProperty(nodeId)) {
                    nodeCoreMap[nodeId]._core.renderBuf.webglRestored();
                }
            }
        });

    SceneJS.ColorTarget = SceneJS_NodeFactory.createNodeType("colorTarget");

    SceneJS.ColorTarget.prototype._init = function (params) {
        nodeCoreMap[this._core.coreId] = this;
        this._core.bufType = "color";
        this._core.renderBuf = new SceneJS._webgl.RenderBuffer({ canvas: this._engine.canvas });
    };

    SceneJS.ColorTarget.prototype._compile = function (ctx) {
        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("renderTarget");
        }
        var parentCore = this._engine.display.renderTarget;
        if (!this._core.empty) {
            this.__core.targets = (parentCore && parentCore.targets) ? parentCore.targets.concat([this._core]) : [this._core];
        }
        coreStack[stackLen++] = this.__core;
        this._engine.display.renderTarget = this.__core;
        this._compileNodes(ctx);
        this._engine.display.renderTarget = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };


    SceneJS.ColorTarget.prototype._destroy = function () {
        if (this._core) {
            if (this._core.renderBuf) {
                this._core.renderBuf.destroy();
            }
            delete nodeCoreMap[this._core.coreId];
        }
    };
})();;new (function () {

    var defaultCore = {
        type: "renderTarget",
        stateId: SceneJS._baseStateId++,
        targets: null
    };

    // Map of  nodes to cores, for reallocation on WebGL context restore
    var nodeCoreMap = {};

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.renderTarget = defaultCore;
            stackLen = 0;
        });

    // Reallocate VBOs when context restored after loss
    SceneJS_events.addListener(
        SceneJS_events.WEBGL_CONTEXT_RESTORED,
        function () {
            for (var nodeId in nodeCoreMap) {
                if (nodeCoreMap.hasOwnProperty(nodeId)) {
                    nodeCoreMap[nodeId]._buildNodeCore();
                }
            }
        });

    SceneJS.DepthTarget = SceneJS_NodeFactory.createNodeType("depthTarget");

    SceneJS.DepthTarget.prototype._init = function (params) {
        nodeCoreMap[this._core.coreId] = this;
        this._core.bufType = "depth";
        this._core.renderBuf = new SceneJS._webgl.RenderBuffer({ canvas: this._engine.canvas });
    };

    SceneJS.DepthTarget.prototype._compile = function (ctx) {
        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("renderTarget");
        }
        var parentCore = this._engine.display.renderTarget;
        if (!this._core.empty) {
            this.__core.targets = (parentCore && parentCore.targets) ? parentCore.targets.concat([this._core]) : [this._core];
        }
        coreStack[stackLen++] = this.__core;
        this._engine.display.renderTarget = this.__core;
        this._compileNodes(ctx);
        this._engine.display.renderTarget = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };


    SceneJS.DepthTarget.prototype._destroy = function () {
        if (this._core) {
            if (this._core.renderBuf) {
                this._core.renderBuf.destroy();
            }
            delete nodeCoreMap[this._core.coreId];
        }
    };
})();;new (function () {

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function () {
            stackLen = 0;
        });

    /**
     * @class Scene graph node that defines geometry.
     * @extends SceneJS.Node
     * When this node is at a leaf, it defines a scene object which inherits the state set up by all the nodes above it
     * on the path up to the root. These nodes can be nested, so that child geometries inherit arrays
     * defined by parent geometries.
     */
    SceneJS.Geometry = SceneJS_NodeFactory.createNodeType("geometry");

    SceneJS.Geometry.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node defines the core

            this._initNodeCore(params, {
                origin: params.origin,
                scale: params.scale,
                autoNormals: params.normals == "auto"
            });

            this._buildNodeCore(this._engine.canvas.gl, this._core);

            var self = this;

            this._core.webglRestored = function () {

                // Ensure that we recreate these in subsequent calls to
                // core.getTangents and core.getPickPositions
                self._core.tangentBufs = null;
                self._core.pickPositionsBuf = null;

                self._buildNodeCore(self._engine.canvas.gl, self._core);
            };

            this._engine.stats.memory.meshes++;
        }
    };

    /**
     * Convert JSON arrays into typed arrays,
     * apply optional baked Model-space transforms to positions
     */
    SceneJS.Geometry.prototype._initNodeCore = function (data, options) {

        var self = this;

        options = options || {};

        var primitive = data.primitive || "triangles";
        var core = this._core;
        var IndexArrayType = SceneJS.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"] ? Uint32Array : Uint16Array;

        core.primitive = this._getPrimitiveType(primitive);
        core.primitiveName = primitive;
        core.pointSize = data.pointSize || 1;

        // Generate normals
        if (data.normals) {
            if (primitive == "triangles") {
                if (data.normals === "auto" || data.normals === true) {
                    if (data.positions && data.indices) {
                        this._buildNormals(data); // Auto normal generation - build normals array
                    }
                }
            }
        }

        // Create typed arrays, apply any baked transforms
        core.arrays = {};

        if (data.positions) {
            if (data.positions.constructor != Float32Array) {
                data.positions = new Float32Array(data.positions);
            }

            if (options.scale || options.origin) {
                this._applyOptions(data.positions, options)
            }

            core.arrays.positions = data.positions;
            this._engine.stats.memory.positions += data.positions.length / 3;
        }

        if (data.normals) {
            if (data.normals.constructor != Float32Array) {
                data.normals = new Float32Array(data.normals);
            }

            core.arrays.normals = data.normals;
            this._engine.stats.memory.normals += data.normals.length / 3;
        }

        if (data.uvs) {
            var uvs = data.uvs;
            var uv;
            for (var i = 0, len = uvs.length; i < len; i++) {
                uv = uvs[i];
                if (uv.constructor != Float32Array) {
                    uvs[i] = new Float32Array(uvs[i]);
                }
                this._engine.stats.memory.uvs += uv.length / 2;
            }
            core.arrays.uvs = uvs;
        }

        // ---------------- Backward-compatibility -------------------

        if (data.uv) {
            if (data.uv.constructor != Float32Array) {
                data.uv = new Float32Array(data.uv);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[0] = data.uv;
            this._engine.stats.memory.uvs += data.uv.length / 2;
        }

        if (data.uv1) {
            if (data.uv1.constructor != Float32Array) {
                data.uv1 = new Float32Array(data.uv1);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[1] = data.uv1;
            this._engine.stats.memory.uvs += data.uv1.length / 2;
        }

        if (data.uv2) {
            if (data.uv2.constructor != Float32Array) {
                data.uv2 = new Float32Array(data.uv2);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[2] = data.uv2;
            this._engine.stats.memory.uvs += data.uv2.length / 2;
        }

        if (data.uv3) {
            if (data.uv3.constructor != Float32Array) {
                data.uv3 = new Float32Array(data.uv3);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[3] = data.uv3;
            this._engine.stats.memory.uvs += data.uv3.length / 2;
        }

        // ----------------------------------------------------------

        if (core.arrays.normals && core.arrays.uvs) {
            core.arrays.tangents = [];
        }

        if (data.colors) {
            if (data.colors.constructor != Float32Array) {
                data.colors = new Float32Array(data.colors);
            }

            core.arrays.colors = data.colors;
            this._engine.stats.memory.colors += data.colors.length / 4;
        }

        if (data.indices) {
            if (data.indices.constructor != Uint8Array &&
                data.indices.constructor != Uint16Array &&
                data.indices.constructor != Uint32Array)
            {
                data.indices = new IndexArrayType(data.indices);
            }

            core.arrays.indices = data.indices;
            this._engine.stats.memory.indices += data.indices.length;
        }

        // Lazy-build tangents, only when needed as rendering
        core.getTangents = function (uvLayerIdx) {

            // We're only allowed one normal map per drawable, but we'll
            // cache tangents for each UV layer. In practice the cache would
            // only contain one array of tangents, for the UV layer that
            // happens to be used for normal mapping.

            if (!core.tangentBufs) {
                core.tangentBufs = [];
            }
            if (core.tangentBufs[uvLayerIdx]) {
                return core.tangentBufs[uvLayerIdx];
            }
            var arrays = core.arrays;
            var tangents = core.arrays.tangents[uvLayerIdx];
            if (!tangents) {
                // Retaining tangents data after WebGL context recovery
                if (arrays.positions && arrays.indices && arrays.uvs && arrays.uvs[uvLayerIdx]) {
                    var gl = self._engine.canvas.gl;
                    tangents = new Float32Array(SceneJS_math_buildTangents(arrays.positions, arrays.indices, arrays.uvs[uvLayerIdx])); // Build tangents array;
                    core.arrays.tangents[uvLayerIdx] = tangents;
                }
            }
            if (tangents) {
                return core.tangentBufs[uvLayerIdx] = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, tangents, tangents.length, 3, gl.STATIC_DRAW);
            } else {
                return null;
            }
        };

        // Buffers for primitive-pick rendering

        core.getPickPositions = function () {
            if (core.pickPositionsBuf) {
                return core.pickPositionsBuf;
            }

            createPickArrays();

            return core.pickPositionsBuf;
        };

        core.getPickColors = function () {
            if (core.pickColorsBuf) {
                return core.pickColorsBuf;
            }

            createPickArrays();

            return core.pickColorsBuf;
        };

        function createPickArrays() {
            var gl = self._engine.canvas.gl;

            var pickArrays, pickPositions, pickColors;

            if (core.arrays.positions) {
                pickArrays = SceneJS_math_getPickPrimitives(core.arrays.positions, core.arrays.indices);
                pickPositions = pickArrays.positions;
                pickColors = pickArrays.colors;
                core.pickPositionsBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickPositions, pickPositions.length, 3, gl.STATIC_DRAW);
            } else {
                pickColors = SceneJS_math_getPickColors(core.arrays.indices);
            }

            core.pickColorsBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickColors, pickColors.length, 4, gl.STATIC_DRAW);
        }
    };


    /**
     * Returns WebGL constant for primitive name
     */
    SceneJS.Geometry.prototype._getPrimitiveType = function (primitive) {

        var gl = this._engine.canvas.gl;

        switch (primitive) {

            case "points":
                return gl.POINTS;

            case "lines":
                return gl.LINES;

            case "line-loop":
                return gl.LINE_LOOP;

            case "line-strip":
                return gl.LINE_STRIP;

            case "triangles":
                return gl.TRIANGLES;

            case "triangle-strip":
                return gl.TRIANGLE_STRIP;

            case "triangle-fan":
                return gl.TRIANGLE_FAN;

            default:
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "geometry primitive unsupported: '" +
                    primitive +
                    "' - supported types are: 'points', 'lines', 'line-loop', " +
                    "'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'");
        }
    };

    /**
     * Apply baked Model-space transformations to give position array
     */
    SceneJS.Geometry.prototype._applyOptions = function (positions, options) {

        if (options.scale) {

            var scaleX = options.scale.x != undefined ? options.scale.x : 1.0;
            var scaleY = options.scale.y != undefined ? options.scale.y : 1.0;
            var scaleZ = options.scale.z != undefined ? options.scale.z : 1.0;

            for (var i = 0, len = positions.length; i < len; i += 3) {
                positions[i] *= scaleX;
                positions[i + 1] *= scaleY;
                positions[i + 2] *= scaleZ;
            }
        }

        if (options.origin) {

            var originX = options.origin.x != undefined ? options.origin.x : 0.0;
            var originY = options.origin.y != undefined ? options.origin.y : 0.0;
            var originZ = options.origin.z != undefined ? options.origin.z : 0.0;

            for (var i = 0, len = positions.length; i < len; i += 3) {
                positions[i] -= originX;
                positions[i + 1] -= originY;
                positions[i + 2] -= originZ;
            }
        }

        return positions;
    };

    /**
     * Destroy vertex buffers associated with given core
     */
    var destroyBuffers = function (core) {
        if (core.vertexBuf) {
            core.vertexBuf.destroy();
            core.vertexBuf = null;
        }

        if (core.normalBuf) {
            core.normalBuf.destroy();
            core.normalBuf = null;
        }

        if (core.uvBufs) {
            var uvBufs = core.uvBufs;
            var uvBuf;
            for (var i = 0, len = uvBufs.length; i < len; i++) {
                uvBuf = uvBufs[i];
                if (uvBuf) {
                    uvBuf.destroy();
                }
            }
            core.uvBufs = null;
        }

        if (core.colorBuf) {
            core.colorBuf.destroy();
            core.colorBuf = null;
        }

        if (core.tangentBufs) {
            var tangentBufs = core.tangentBufs;
            var tangentBuf;
            for (var j = 0, lenj = tangentBufs.length; j < lenj; j++) {
                tangentBuf = tangentBufs[j];
                if (tangentBuf) {
                    tangentBuf.destroy();
                }
            }
            core.tangentBufs = null;
        }

        if (core.indexBuf) {
            core.indexBuf.destroy();
            core.indexBuf = null;
        }

        if (core.interleavedBuf) {
            core.interleavedBuf.destroy();
            core.interleavedBuf = null;
        }
    };

    /**
     * Allocates WebGL buffers for geometry arrays
     *
     * In addition to initially allocating those, this is called to reallocate them after
     * WebGL context is regained after being lost.
     */
    SceneJS.Geometry.prototype._buildNodeCore = function (gl, core) {

        try { // TODO: Modify usage flags in accordance with how often geometry is evicted
            buildCore(gl, core);
        } catch (e) { // Allocation failure - delete whatever buffers got allocated
            destroyBuffers(core);
            throw SceneJS_error.fatalError(
                SceneJS.errors.ERROR,
                "Failed to allocate geometry: " + e);
        }
    };

    SceneJS.Geometry.prototype._updateArray = function (array, items, offset) {

        var arrayLen = array.length;
        var itemsLen = items.length;

        if (itemsLen + offset > arrayLen) {
            itemsLen -= (itemsLen + offset) - arrayLen;
        }

        for (var i = offset, j = 0; j < itemsLen; i++, j++) {
            array[i] = items[j];
        }

    };

    /** Builds normal vectors from positions and indices
     * @private
     */
    SceneJS.Geometry.prototype._buildNormals = function (data) {

        var positions = data.positions;
        var indices = data.indices;
        var nvecs = new Array(positions.length / 3);
        var j0;
        var j1;
        var j2;
        var v1;
        var v2;
        var v3;

        for (var i = 0, len = indices.length - 3; i < len; i += 3) {
            j0 = indices[i + 0];
            j1 = indices[i + 1];
            j2 = indices[i + 2];

            v1 = [positions[j0 * 3 + 0], positions[j0 * 3 + 1], positions[j0 * 3 + 2]];
            v2 = [positions[j1 * 3 + 0], positions[j1 * 3 + 1], positions[j1 * 3 + 2]];
            v3 = [positions[j2 * 3 + 0], positions[j2 * 3 + 1], positions[j2 * 3 + 2]];

            v2 = SceneJS_math_subVec4(v2, v1, [0, 0, 0, 0]);
            v3 = SceneJS_math_subVec4(v3, v1, [0, 0, 0, 0]);

            var n = SceneJS_math_normalizeVec4(SceneJS_math_cross3Vec4(v2, v3, [0, 0, 0, 0]), [0, 0, 0, 0]);

            if (!nvecs[j0]) nvecs[j0] = [];
            if (!nvecs[j1]) nvecs[j1] = [];
            if (!nvecs[j2]) nvecs[j2] = [];

            nvecs[j0].push(n);
            nvecs[j1].push(n);
            nvecs[j2].push(n);
        }

        var normals = new Float32Array(positions.length);

        // now go through and average out everything
        for (var i = 0, len = nvecs.length; i < len; i++) {
            var nvec = nvecs[i];
            if (!nvec) {
                continue;
            }
            var count = nvec.length;
            var x = 0;
            var y = 0;
            var z = 0;
            for (var j = 0; j < count; j++) {
                x += nvec[j][0];
                y += nvec[j][1];
                z += nvec[j][2];
            }
            normals[i * 3 + 0] = (x / count);
            normals[i * 3 + 1] = (y / count);
            normals[i * 3 + 2] = (z / count);
        }

        data.normals = normals;
        this._engine.stats.memory.normals += normals.length / 3;
    };

    SceneJS.Geometry.prototype.setSource = function (sourceConfigs) {
        this._sourceConfigs = sourceConfigs;
        var source = this._source;
        if (source && source.configure) {
            source.configure(sourceConfigs);
        }
    };

    SceneJS.Geometry.prototype.getSource = function () {
        return this._sourceConfigs || {};
    };

    SceneJS.Geometry.prototype.setPositions = function (data) {
        if (data.positions && this._core.vertexBuf) {
            this._boundary = null;
            var core = this._core;
            core.vertexBuf.bind();
            core.vertexBuf.setData(new Float32Array(data.positions), data.positionsOffset || 0);
            core.arrays.positions.set(data.positions, data.positionsOffset || 0);
            this._engine.display.imageDirty = true;
            if (core.interleavedBuf) {
                core.interleavedBuf.dirty = true;
            }
        }
    };

    SceneJS.Geometry.prototype.getPositions = function () {
        return this._core.arrays ? this._core.arrays.positions : null;
    };

    SceneJS.Geometry.prototype.setNormals = function (data) {
        if (data.normals && this._core.normalBuf) {
            var core = this._core;
            core.normalBuf.bind();
            core.normalBuf.setData(new Float32Array(data.normals), data.normalsOffset || 0);
            core.arrays.normals.set(data.normals, data.normalsOffset || 0);
            this._engine.display.imageDirty = true;
            if (core.interleavedBuf) {
                core.interleavedBuf.dirty = true;
            }
        }
    };

    SceneJS.Geometry.prototype.getNormals = function () {
        return this._core.arrays ? this._core.arrays.normals : null;
    };

    SceneJS.Geometry.prototype.setColors = function (data) {
        if (data.colors && this._core.colorBuf) {
            var core = this._core;
            core.colorBuf.bind();
            core.colorBuf.setData(new Float32Array(data.colors), data.colorsOffset || 0);
            core.arrays.colors.set(data.colors, data.colorsOffset || 0);
            this._engine.display.imageDirty = true;
            if (core.interleavedBuf) {
                core.interleavedBuf.dirty = true;
            }
        }
    };

    SceneJS.Geometry.prototype.getColors = function () {
        return this._core.arrays ? this._core.arrays.colors : null;
    };

    SceneJS.Geometry.prototype.setIndices = function (data) {
        if (data.indices && this._core.indexBuf) {
            this._boundary = null;
            var core = this._core;
            core.indexBuf.bind();

            // Make sure indices remain of the same type.
            if (data.indices.constructor != core.arrays.indices.constructor) {
                data.indices = new core.arrays.indices.constructor(data.indices);
            }

            core.indexBuf.setData(data.indices, data.indicesOffset || 0);
            core.arrays.indices.set(data.indices, data.indicesOffset || 0);
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getIndices = function () {
        return this._core.arrays ? this._core.arrays.indices : null;
    };

    SceneJS.Geometry.prototype.getUV = function () {
        return this._core.arrays ? this._core.arrays.uvs[0] : null;
    };

    SceneJS.Geometry.prototype.getUV2 = function () {
        return this._core.arrays ? this._core.arrays.uvs[1] : null;
    };

    SceneJS.Geometry.prototype.getUV2 = function () {
        return this._core.arrays ? this._core.arrays.uvs[2] : null;
    };

    SceneJS.Geometry.prototype.getUv3 = function () {
        return this._core.arrays ? this._core.arrays.uvs[3] : null;
    };

    SceneJS.Geometry.prototype.getPrimitive = function () {
        return this.primitive;
    };

    SceneJS.Geometry.prototype.getPointSize = function () {
        return this._core.pointSize;
    };

    SceneJS.Geometry.prototype.setPointSize = function (size) {
        if (size && this._core.pointSize !== size) {
            this._core.pointSize = size;
            this._engine.display.imageDirty = true;
        }
    };

    /** Returns the Model-space boundary of this geometry
     *
     * @returns {*}
     */
    SceneJS.Geometry.prototype.getBoundary = function () {
        if (this._boundary) {
            return this._boundary;
        }

        var arrays = this._core.arrays;

        if (!arrays) {
            return null;
        }

        var positions = arrays.positions;

        if (!positions) {
            return null;
        }

        this._boundary = {
            xmin: SceneJS_math_MAX_DOUBLE,
            ymin: SceneJS_math_MAX_DOUBLE,
            zmin: SceneJS_math_MAX_DOUBLE,
            xmax: SceneJS_math_MIN_DOUBLE,
            ymax: SceneJS_math_MIN_DOUBLE,
            zmax: SceneJS_math_MIN_DOUBLE
        };

        var x, y, z;

        for (var i = 0, len = positions.length - 2; i < len; i += 3) {

            x = positions[i];
            y = positions[i + 1];
            z = positions[i + 2];

            if (x < this._boundary.xmin) {
                this._boundary.xmin = x;
            }
            if (y < this._boundary.ymin) {
                this._boundary.ymin = y;
            }
            if (z < this._boundary.zmin) {
                this._boundary.zmin = z;
            }
            if (x > this._boundary.xmax) {
                this._boundary.xmax = x;
            }
            if (y > this._boundary.ymax) {
                this._boundary.ymax = y;
            }
            if (z > this._boundary.zmax) {
                this._boundary.zmax = z;
            }
        }

        return this._boundary;
    };

    SceneJS.Geometry.prototype._compile = function (ctx) {

        if (this._core._loading) { // TODO: Breaks with asynch loaded cores - this node needs to recompile when target core is loaded
            this._compileNodes(ctx);
            return;
        }

        var core = this._core;

        if (!core.vertexBuf) {

            /* SceneJS.Geometry has no vertex buffer - it must be therefore be indexing a vertex/uv buffers defined
             * by a higher Geometry, as part of a composite geometry:
             *
             * It must therefore inherit the vertex buffer, along with UV coord buffers.
             *
             * We'll leave it to the render state graph traversal to ensure that the
             * vertex and UV buffers are not needlessly rebound for this geometry.
             */
            core = this._inheritVBOs(core);
        }

        if (core.indexBuf || core.primitiveName === "points") { // Can only render when we have indices or are drawing points

            var parts = [                           // Safe to build geometry hash here - geometry is immutable
                core.normalBuf ? "t" : "f",
                core.arrays && core.arrays.tangents ? "t" : "f",
                core.colorBuf ? "t" : "f",
                core.primitive
            ];

            // Hash parts for UVs

            parts.push(";uvs");
            var uvBufs = core.uvBufs;
            if (uvBufs) {
                for (var i = 0, len = uvBufs.length; i < len; i++) {
                    parts.push(uvBufs[i] ? "t" : "f");
                }
            }

            core.hash = parts.join("");

            core.stateId = this._core.stateId;
            core.type = "geometry";

            this._engine.display.geometry = coreStack[stackLen++] = core;

            SceneJS_events.fireEvent(SceneJS_events.OBJECT_COMPILING, { // Pull in state updates from scenes nodes
                display: this._engine.display
            });

            this._engine.display.buildObject(this.id); // Use node ID since we may inherit from many cores

        } else {
            coreStack[stackLen++] = this._core;
        }

        this._compileNodes(ctx);

        stackLen--;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Geometry.prototype._inheritVBOs = function (core) {

        var core2 = {
            arrays: core.arrays,
            primitive: core.primitive,
            primitiveName: core.primitiveName,
            boundary: core.boundary,
            normalBuf: core.normalBuf,
            uvBufs: core.uvBufs,
            colorBuf: core.colorBuf,
            interleavedBuf: core.interleavedBuf,
            indexBuf: core.indexBuf,
            interleavedStride: core.interleavedStride,
            interleavedPositionOffset: core.interleavedPositionOffset,
            interleavedNormalOffset: core.interleavedNormalOffset,
            interleavedUVOffsets: core.interleavedUVOffsets,
            interleavedColorOffset: core.interleavedColorOffset,
            getPickIndices: core.getPickIndices,
            getPickPositions: core.getPickPositions,
            getPickColors: core.getPickColors
        };

        for (var i = stackLen - 1; i >= 0; i--) {
            if (coreStack[i].vertexBuf) {
                core2.vertexBuf = coreStack[i].vertexBuf;
                core2.boundary = coreStack[i].boundary;
                core2.normalBuf = coreStack[i].normalBuf;
                core2.uvBufs = coreStack[i].uvBufs;           // Vertex and UVs are a package
                core2.colorBuf = coreStack[i].colorBuf;
                core2.interleavedBuf = coreStack[i].interleavedBuf;
                core2.interleavedStride = coreStack[i].interleavedStride;
                core2.interleavedPositionOffset = coreStack[i].interleavedPositionOffset;
                core2.interleavedNormalOffset = coreStack[i].interleavedNormalOffset;
                core2.interleavedUVOffsets = coreStack[i].interleavedUVOffsets;
                core2.interleavedColorOffset = coreStack[i].interleavedColorOffset;
                return core2;
            }
        }

        return core2;
    };

    SceneJS.Geometry.prototype._destroy = function () {

        this._engine.display.removeObject(this.id);

        /* Destroy core if no other references
         */
        if (this._core.useCount == 1) {

            this._destroyNodeCore();

            if (this._source && this._source.destroy) {
                this._source.destroy();
            }

            this._engine.stats.memory.meshes--;
        }
    };

    SceneJS.Geometry.prototype._destroyNodeCore = function () {

        if (document.getElementById(this._engine.canvas.canvasId)) { // Context won't exist if canvas has disappeared
            destroyBuffers(this._core);
        }

        var arrays = this._core.arrays;

        if (arrays.positions) {
            this._engine.stats.memory.positions -= arrays.positions.length / 3;
        }
        if (arrays.normals) {
            this._engine.stats.memory.normals -= arrays.normals.length / 3;
        }
        if (arrays.colors) {
            this._engine.stats.memory.colors -= arrays.colors.length / 3;
        }
        if (arrays.uvs && arrays.uvs.length > 0) {
            this._engine.stats.memory.uvs -= arrays.uvs.length * (arrays.uvs[0].length / 2);
        }
        if (arrays.indices) {
            this._engine.stats.memory.indices -= arrays.indices.length;
        }
    };

    function buildCore(gl, core) {
        var usage = gl.STATIC_DRAW;
        var arrays = core.arrays;
        var canInterleave = (SceneJS.getConfigs("enableInterleaving") !== false);
        var dataLength = 0;
        var interleavedValues = 0;
        var interleavedArrays = [];
        var interleavedArrayStrides = [];

        var prepareInterleaveBuffer = function (array, strideInElements) {
            if (dataLength == 0) {
                dataLength = array.length / strideInElements;
            } else if (array.length / strideInElements != dataLength) {
                canInterleave = false;
            }
            interleavedArrays.push(array);
            interleavedArrayStrides.push(strideInElements);
            interleavedValues += strideInElements;
            return (interleavedValues - strideInElements) * 4;
        };

        if (arrays.positions) {
            if (canInterleave) {
                core.interleavedPositionOffset = prepareInterleaveBuffer(arrays.positions, 3);
            }
            core.vertexBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.positions, arrays.positions.length, 3, usage);
        }

        if (arrays.normals) {
            if (canInterleave) {
                core.interleavedNormalOffset = prepareInterleaveBuffer(arrays.normals, 3);
            }
            core.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.normals, arrays.normals.length, 3, usage);
        }

        if (arrays.uvs) {

            var uvs = arrays.uvs;
            var offsets;
            var i;
            var len;
            var uv;

            if (canInterleave) {
                core.interleavedUVOffsets = [];
                offsets = core.interleavedUVOffsets;
                for (i = 0, len = uvs.length; i < len; i++) {
                    offsets.push(prepareInterleaveBuffer(arrays.uvs[i], 2));
                }
            }

            core.uvBufs = [];

            for (i = 0, len = uvs.length; i < len; i++) {
                uv = arrays.uvs[i];
                if (uv.length > 0) {
                    core.uvBufs.push(new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, uv, uv.length, 2, usage));
                }
            }
        }

        if (arrays.colors) {
            if (canInterleave) {
                core.interleavedColorOffset = prepareInterleaveBuffer(arrays.colors, 4);
            }
            core.colorBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.colors, arrays.colors.length, 4, usage);
        }

        if (arrays.indices) {
            core.indexBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, arrays.indices, arrays.indices.length, 1, usage);
        }

        if (interleavedValues > 0 && canInterleave) {
            // We'll place the vertex attribute data interleaved in this array.
            // This will enable us to use less bindBuffer calls and make the data
            // efficient to address on the GPU.
            var interleaved = [];

            var arrayCount = interleavedArrays.length;
            for (var i = 0; i < dataLength; ++i) {
                for (var j = 0; j < arrayCount; ++j) {
                    var stride = interleavedArrayStrides[j];
                    for (var k = 0; k < stride; ++k) {
                        interleaved.push(interleavedArrays[j][i * stride + k]);
                    }
                }
            }
            core.interleavedStride = interleavedValues * 4; // in bytes
            core.interleavedBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(interleaved), interleaved.length, interleavedValues, usage);
            core.interleavedBuf.dirty = false;
        }
    }

})();
;(function() {

    /**
     * The default state core singleton for {@link SceneJS.Stage} nodes
     */
    var defaultCore = {
        type: "stage",
        stateId: SceneJS._baseStateId++,
        priority: 0,
        pickable: true,
        enabled: true
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING,
            function(params) {
                params.engine.display.stage = defaultCore;
                stackLen = 0;
            });

    /**
     * @class Scene graph node which assigns the {@link SceneJS.Geometry}s within its subgraph to a prioritised render bin
     * @extends SceneJS.Node
     */
    SceneJS.Stage = SceneJS_NodeFactory.createNodeType("stage");

    SceneJS.Stage.prototype._init = function(params) {
        if (this._core.useCount == 1) { // This node defines the resource
            this._core.priority = params.priority || 0;
            this._core.enabled = params.enabled !== false;
            this._core.pickable = !!params.pickable;
        }
    };

    SceneJS.Stage.prototype.setPriority = function(priority) {
        priority = priority || 0;
        if (this._core.priority != priority) {
            this._core.priority = priority;
            this._engine.display.stateOrderDirty = true;
        }
    };

    SceneJS.Stage.prototype.getPriority = function() {
        return this._core.priority;
    };

    SceneJS.Stage.prototype.setEnabled = function(enabled) {
        enabled = !!enabled;
        if (this._core.enabled != enabled) {
            this._core.enabled = enabled;
            this._engine.display.drawListDirty = true;
        }
    };

    SceneJS.Stage.prototype.getEnabled = function() {
        return this._core.enabled;
    };

    SceneJS.Stage.prototype.getEnabled = function() {
        return this._core.enabled;
    };

    SceneJS.Stage.prototype._compile = function(ctx) {
        this._engine.display.stage = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.stage = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();

;(function () {

    /**
     * The default state core singleton for {@link SceneJS.Layer} nodes
     */
    var defaultCore = {
        type: "layer",
        stateId: SceneJS._baseStateId++,
        priority: 0,
        enabled: true
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.layer = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which assigns the {@link SceneJS.Geometry}s within its subgraph to a prioritised render bin
     * @extends SceneJS.Node
     */
    SceneJS.Layer = SceneJS_NodeFactory.createNodeType("layer");

    SceneJS.Layer.prototype._init = function (params) {
        if (this._core.useCount == 1) { // This node defines the resource
            this._core.priority = params.priority || 0;
            this._core.enabled = params.enabled !== false;
        }
    };

    SceneJS.Layer.prototype.setPriority = function (priority) {
        priority = priority || 0;
        if (this._core.priority != priority) {
            this._core.priority = priority;
            this._engine.display.stateOrderDirty = true;
        }
    };

    SceneJS.Layer.prototype.getPriority = function () {
        return this._core.priority;
    };

    SceneJS.Layer.prototype.setEnabled = function (enabled) {
        enabled = !!enabled;
        if (this._core.enabled != enabled) {
            this._core.enabled = enabled;
            this._engine.display.drawListDirty = true;
        }
    };

    SceneJS.Layer.prototype.getEnabled = function () {
        return this._core.enabled;
    };

    SceneJS.Layer.prototype.getEnabled = function () {
        return this._core.enabled;
    };

    SceneJS.Layer.prototype.setClearDepth = function (clearDepth) {
        clearDepth = clearDepth || 0;
        if (this._core.clearDepth != clearDepth) {
            this._core.clearDepth = clearDepth;
            this._engine.display.drawListDirty = true;
        }
    };

    SceneJS.Layer.prototype.getClearDepth = function () {
        return this._core.clearDepth;
    };

    SceneJS.Layer.prototype._compile = function(ctx) {
        this._engine.display.layer = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.layer = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();

;/**
 * @class Scene graph node which assigns nodes in its subgraph to a library
 * @extends SceneJS.Node
 */
SceneJS.Library = SceneJS_NodeFactory.createNodeType("library");
SceneJS.Library.prototype._compile = function(ctx) { // Bypass child nodes
};

;(function () {

    /**
     * The default state core singleton for {@link SceneJS.Lights} nodes
     */
    var defaultCore = {
        type: "lights",
        stateId: SceneJS._baseStateId++,
        hash: null,
        empty: false,
        lights: [
            {
                mode: "ambient",
                color: [0.7, 0.7, 0.8 ],
                diffuse: true,
                specular: false
            },
            {
                mode: "dir",
                color: [1.0, 1.0, 1.0 ],
                diffuse: true,
                specular: true,
                dir: [-0.5, -0.5, -1.0 ],
                space: "view"
            },
            {
                mode: "dir",
                color: [1.0, 1.0, 1.0 ],
                diffuse: false,
                specular: true,
                dir: [1.0, -0.9, -0.7 ],
                space: "view"
            }
        ]
    };

    makeHash(defaultCore);

    function makeHash(core) {
        if (core.lights && core.lights.length > 0) {
            var lights = core.lights;
            var parts = [];
            var light;
            for (var i = 0, len = lights.length; i < len; i++) {
                light = lights[i];
                parts.push(light.mode);
                if (light.specular) {
                    parts.push("s");
                }
                if (light.diffuse) {
                    parts.push("d");
                }
                parts.push((light.space == "world") ? "w" : "v");
            }
            core.hash = parts.join("");

        } else {
            core.hash = "";
        }
    }

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.lights = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines light sources to illuminate the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Lights = SceneJS_NodeFactory.createNodeType("lights");

    SceneJS.Lights.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node defines the resource

            var lights = params.lights;

            if (!lights) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.NODE_CONFIG_EXPECTED,
                    "lights node attribute missing : 'lights'");
            }

            this._core.lights = this._core.lights || [];

            for (var i = 0, len = lights.length; i < len; i++) {
                this._initLight(i, lights[i]);
            }
        }
    };

    SceneJS.Lights.prototype._initLight = function (index, cfg) {

        var light = {};
        this._core.lights[index] = light;

        var mode = cfg.mode || "dir";
        if (mode != "dir" && mode != "point" && mode != "ambient" && mode != "spot") {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Light mode not supported - should be 'dir' or 'point' or 'spot' or 'ambient'");
        }

        var pos = cfg.pos;
        var dir = cfg.dir;

        var color = cfg.color;
        light.color = [
                color.r != undefined ? color.r : 1.0,
                color.g != undefined ? color.g : 1.0,
                color.b != undefined ? color.b : 1.0
        ];

        // Ambient lights hardwired to contribute to diffuse lighting
        light.mode = mode;
        light.diffuse = (mode == "ambient") ? true : ((cfg.diffuse != undefined) ? cfg.diffuse : true);
        light.specular = (mode == "ambient") ? false : ((cfg.specular != undefined) ? cfg.specular : true);
        light.pos = cfg.pos ? [pos.x || 0, pos.y || 0, pos.z || 0 ] : [0, 0, 0];
        light.dir = cfg.dir ? [dir.x || 0, dir.y || 0, dir.z || 0] : [0, 0, 1];
        light.innerCone = cfg.innerCone != undefined ? cfg.innerCone : 0.25;
        light.outerCone = cfg.outerCone != undefined ? cfg.outerCone : 0;
        light.attenuation = [
                cfg.constantAttenuation != undefined ? cfg.constantAttenuation : 0.0,
                cfg.linearAttenuation || 0.0,
                cfg.quadraticAttenuation || 0.0
        ];

        var space = cfg.space;

        if (!space) {

            space = "world";

        } else if (space != "view" && space != "world") {

            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "lights node invalid value for property 'space': '" + space + "' - should be 'view' or 'world'");
        }

        light.space = space;

        this._core.hash = null;
    };


    SceneJS.Lights.prototype.setLights = function (lights) {
        var indexNum;
        for (var index in lights) {
            if (lights.hasOwnProperty(index)) {
                if (index != undefined || index != null) {
                    indexNum = parseInt(index);
                    if (indexNum < 0 || indexNum >= this._core.lights.length) {
                        throw SceneJS_error.fatalError(
                            SceneJS.errors.ILLEGAL_NODE_CONFIG,
                                "Invalid argument to set 'lights': index out of range (" + this._core.lights.length + " lights defined)");
                    }
                    this._setLight(indexNum, lights[index] || {});
                }
            }
        }
        this._engine.branchDirty(this); // Schedule recompilation of this subgraph
    };

    SceneJS.Lights.prototype._setLight = function (index, cfg) {

        var light = this._core.lights[index];

        // Impact of light update
        var imageDirty = false; // Redraw display list?
        var branchDirty = false; // Recompile scene branch?

        if (cfg.mode && cfg.mode != light.mode) {
            var mode = cfg.mode;
            if (mode != "dir" && mode != "point" && mode != "ambient") {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "Light mode not supported - should be 'dir' or 'point' or 'ambient'");
            }
            light.mode = mode;
            light.diffuse = (mode == "ambient") ? true : ((cfg.diffuse != undefined) ? cfg.diffuse : true);
            light.specular = (mode == "ambient") ? false : ((cfg.specular != undefined) ? cfg.specular : true);
            branchDirty = true;
        }

        if (cfg.color) {
            var color = cfg.color;
            light.color = [
                    color.r != undefined ? color.r : 1.0,
                    color.g != undefined ? color.g : 1.0,
                    color.b != undefined ? color.b : 1.0
            ];
            imageDirty = true;
        }

        var pos = cfg.pos;
        if (pos) {
            light.pos = [ pos.x || 0, pos.y || 0, pos.z || 0 ];
            imageDirty = true;
        }

        var dir = cfg.dir;
        if (dir) {
            light.dir = [dir.x || 0, dir.y || 0, dir.z || 0];
            imageDirty = true;
        }

        if (cfg.innerCone != undefined && cfg.innerCone != light.innerCone) {
            light.innerCone = cfg.innerCone;
            imageDirty = true;
        }

        if (cfg.outerCone != undefined && cfg.outerCone != light.outerCone) {
            light.outerCone = cfg.outerCone;
            imageDirty = true;
        }

        if (cfg.constantAttenuation != undefined) {
            light.attenuation[0] = cfg.constantAttenuation;
            imageDirty = true;
        }
        if (cfg.linearAttenuation != undefined) {
            light.attenuation[1] = cfg.linearAttenuation;
            imageDirty = true;
        }
        if (cfg.quadraticAttenuation != undefined) {
            light.attenuation[2] = cfg.quadraticAttenuation;
            imageDirty = true;
        }

        if (cfg.space && cfg.space != light.space) {
            var space = cfg.space;
            if (space != "view" && space != "world") {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                        "lights node invalid value for property 'space': '" + space + "' - should be 'view' or 'world'");
            }
            light.space = space;
            this._core.hash = null;
            branchDirty = true;
        }

        if (cfg.specular != undefined && cfg.specular != light.specular) {
            light.specular = cfg.specular;
            branchDirty = true;
        }
        if (cfg.diffuse != undefined && cfg.diffuse != light.diffuse) {
            light.diffuse = cfg.diffuse;
            branchDirty = true;
        }

        if (branchDirty) {
            this._engine.branchDirty(this); // Schedule recompilation of this subgraph
        } else if (imageDirty) {
            this._engine.display.imageDirty = true;
        }

        this._core.hash = null;
    };

    SceneJS.Lights.prototype._compile = function (ctx) {

        if (!this._core.hash) {
            makeHash(this._core);
        }

        this._engine.display.lights = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.lights = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();
;(function () {

    var defaultMatrix = SceneJS_math_lookAtMat4c(0, 0, 10, 0, 0, 0, 0, 1, 0);
    var defaultMat = new Float32Array(defaultMatrix);
    var normalMat = SceneJS_math_transposeMat4(SceneJS_math_inverseMat4(defaultMat, SceneJS_math_mat4()));
    var defaultNormalMat = new Float32Array(normalMat);

    /**
     * The default state core singleton for {@link SceneJS.Lookat} nodes
     */
    var defaultCore = {
        type:"lookAt",
        stateId:SceneJS._baseStateId++,
        matrix:defaultMatrix,
        mat:defaultMat,
        normalMatrix:normalMat,
        normalMat:defaultNormalMat,
        lookAt:SceneJS_math_LOOKAT_ARRAYS
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.viewTransform = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines the viewing transform for the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Lookat = SceneJS_NodeFactory.createNodeType("lookAt");

    SceneJS.Lookat.prototype._init = function (params) {

        this._mat = null;

        this._xf = {
            type:"lookat"
        };

        if (this._core.useCount == 1) { // This node is the resource definer

            this._core.eyeX = 0;
            this._core.eyeY = 0;
            this._core.eyeZ = 10.0;

            this._core.lookX = 0;
            this._core.lookY = 0;
            this._core.lookZ = 0;

            this._core.upX = 0;
            this._core.upY = 1;
            this._core.upZ = 0;

            if (!params.eye && !params.look && !params.up) {
                this.setEye({x:0, y:0, z:10.0 });
                this.setLook({x:0, y:0, z:0 });
                this.setUp({x:0, y:1.0, z:0 });
            } else {
                this.setEye(params.eye);
                this.setLook(params.look);
                this.setUp(params.up);
            }

            var core = this._core;

            var self = this;

            this._core.rebuild = function () {

                core.matrix = SceneJS_math_lookAtMat4c(
                    core.eyeX, core.eyeY, core.eyeZ,
                    core.lookX, core.lookY, core.lookZ,
                    core.upX, core.upY, core.upZ);

                core.lookAt = {
                    eye:[core.eyeX, core.eyeY, core.eyeZ ],
                    look:[core.lookX, core.lookY, core.lookZ ],
                    up:[core.upX, core.upY, core.upZ ]
                };

                if (!core.mat) { // Lazy-create arrays
                    core.mat = new Float32Array(core.matrix);
                    core.normalMat = new Float32Array(
                        SceneJS_math_transposeMat4(SceneJS_math_inverseMat4(core.matrix, SceneJS_math_mat4())));

                } else { // Insert into arrays
                    core.mat.set(core.matrix);
                    core.normalMat.set(SceneJS_math_transposeMat4(SceneJS_math_inverseMat4(core.matrix, SceneJS_math_mat4())));
                }

                self.publish("matrix", core.matrix);

                core.dirty = false;
            };

            this._core.dirty = true;

            // Rebuild on every scene tick
            // https://github.com/xeolabs/scenejs/issues/277
            this._tick = this.getScene().on("tick", function () {
                if (self._core.dirty) {
                    self._core.rebuild();
                }
            });
        }
    };

    /**
     * Returns the default view transformation matrix
     * @return {Float32Array}
     */
    SceneJS.Lookat.getDefaultMatrix = function () {
        return defaultMat;
    };

    SceneJS.Lookat.prototype.setEye = function (eye) {

        eye = eye || {};

        if (eye.x != undefined && eye.x != null) {
            this._core.eyeX = eye.x;
        }

        if (eye.y != undefined && eye.y != null) {
            this._core.eyeY = eye.y;
        }

        if (eye.z != undefined && eye.z != null) {
            this._core.eyeZ = eye.z;
        }

        this._core.dirty = true;
        this._engine.display.imageDirty = true;

        return this;
    };

    SceneJS.Lookat.prototype.incEye = function (eye) {
        eye = eye || {};
        this._core.eyeX += (eye.x != undefined && eye.x != null) ? eye.x : 0;
        this._core.eyeY += (eye.y != undefined && eye.y != null) ? eye.y : 0;
        this._core.eyeZ += (eye.z != undefined && eye.z != null) ? eye.z : 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setEyeX = function (x) {
        this._core.eyeX = x || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setEyeY = function (y) {
        this._core.eyeY = y || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setEyeZ = function (z) {
        this._core.eyeZ = z || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incEyeX = function (x) {
        this._core.eyeX += x;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incEyeY = function (y) {
        this._core.eyeY += y;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incEyeZ = function (z) {
        this._core.eyeZ += z;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.getEye = function () {
        return {
            x:this._core.eyeX,
            y:this._core.eyeY,
            z:this._core.eyeZ
        };
    };

    SceneJS.Lookat.prototype.setLook = function (look) {
        look = look || {};

        if (look.x != undefined && look.x != null) {
            this._core.lookX = look.x;
        }

        if (look.y != undefined && look.y != null) {
            this._core.lookY = look.y;
        }

        if (look.z != undefined && look.z != null) {
            this._core.lookZ = look.z;
        }

        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incLook = function (look) {
        look = look || {};
        this._core.lookX += (look.x != undefined && look.x != null) ? look.x : 0;
        this._core.lookY += (look.y != undefined && look.y != null) ? look.y : 0;
        this._core.lookZ += (look.z != undefined && look.z != null) ? look.z : 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setLookX = function (x) {
        this._core.lookX = x || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setLookY = function (y) {
        this._core.lookY = y || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setLookZ = function (z) {
        this._core.lookZ = z || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incLookX = function (x) {
        this._core.lookX += x;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incLookY = function (y) {
        this._core.lookY += y;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incLookZ = function (z) {
        this._core.lookZ += z;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.getLook = function () {
        return {
            x:this._core.lookX,
            y:this._core.lookY,
            z:this._core.lookZ
        };
    };

    SceneJS.Lookat.prototype.setUp = function (up) {
        up = up || {};

        if (up.x != undefined && up.x != null) {
            this._core.upX = up.x;
        }

        if (up.y != undefined && up.y != null) {
            this._core.upY = up.y;
        }

        if (up.z != undefined && up.z != null) {
            this._core.upZ = up.z;
        }

        this._core.dirty = true;
        this._engine.display.imageDirty = true;

        return this;
    };

    SceneJS.Lookat.prototype.incUp = function (up) {
        up = up || {};
        this._core.upX += (up.x != undefined && up.x != null) ? up.x : 0;
        this._core.upY += (up.y != undefined && up.y != null) ? up.y : 0;
        this._core.upZ += (up.z != undefined && up.z != null) ? up.z : 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setUpX = function (x) {
        this._core.upX = x || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setUpY = function (y) {
        this._core.upY = y || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setUpZ = function (z) {
        this._core.upZ = z || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incUpX = function (x) {
        this._core.upX += x;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incUpY = function (y) {
        this._core.upY += y;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incUpZ = function (z) {
        this._core.upZ += z;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.getUp = function () {
        return {
            x:this._core.upX,
            y:this._core.upY,
            z:this._core.upZ
        };
    };

    /**
     * Returns a copy of the matrix as a 1D array of 16 elements
     * @returns {Number[16]}
     */
    SceneJS.Lookat.prototype.getMatrix = function () {

        if (this._core.dirty) {
            this._core.rebuild();
        }

        return  SceneJS._sliceArray(this._core.matrix, 0);
    };

    SceneJS.Lookat.prototype.getAttributes = function () {
        return {
            look:{
                x:this._core.lookX,
                y:this._core.lookY,
                z:this._core.lookZ
            },
            eye:{
                x:this._core.eyeX,
                y:this._core.eyeY,
                z:this._core.eyeZ
            },
            up:{
                x:this._core.upX,
                y:this._core.upY,
                z:this._core.upZ
            }
        };
    };

    SceneJS.Lookat.prototype._compile = function (ctx) {
        this._engine.display.viewTransform = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.viewTransform = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Lookat.prototype._destroy = function () {
        // Stop publishing matrix on each tick
        this.getScene().off(this._tick);
    };

})();;/*

 TODO: material system from virtualworldframework:

 "color":
 "ambient":
 "specColor":
 "shininess":
 "reflect":
 "specular":
 "emit":
 "alpha":
 "binaryAlpha":
 */
new (function () {

    /**
     * The default state core singleton for {@link SceneJS.Material} nodes
     */
    var defaultCore = {
        type:"material",
        stateId:SceneJS._baseStateId++,
        baseColor:[ 1.0, 1.0, 1.0 ],
        specularColor:[ 1.0, 1.0, 1.0 ],
        emitColor:[ 1.0, 1.0, 1.0 ],
        specular:1.0,
        shine:70.0,
        alpha:1.0,
        emit:0.0
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.material = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines surface material properties for the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Material = SceneJS_NodeFactory.createNodeType("material");

    SceneJS.Material.prototype._init = function (params) {
        if (this._core.useCount == 1) {
            this.setBaseColor(params.color || params.baseColor);
            this.setSpecularColor(params.specularColor);
            this.setEmitColor(params.emitColor);
            this.setSpecular(params.specular);
            this.setShine(params.shine);
            this.setEmit(params.emit);
            this.setAlpha(params.alpha);
        }
    };

    /**
     * @deprecated
     * @param color
     * @return {*}
     */
    SceneJS.Material.prototype.setBaseColor = function (color) {
        var defaultBaseColor = defaultCore.baseColor;
        this._core.baseColor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultBaseColor[0],
            color.g != undefined && color.g != null ? color.g : defaultBaseColor[1],
            color.b != undefined && color.b != null ? color.b : defaultBaseColor[2]
        ] : defaultCore.baseColor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.setColor = SceneJS.Material.prototype.setBaseColor;

    /**
     * @deprecated
     * @return {Object}
     */
    SceneJS.Material.prototype.getBaseColor = function () {
        return {
            r:this._core.baseColor[0],
            g:this._core.baseColor[1],
            b:this._core.baseColor[2]
        };
    };

    SceneJS.Material.prototype.getColor = SceneJS.Material.prototype.getBaseColor;

    SceneJS.Material.prototype.setSpecularColor = function (color) {
        var defaultSpecularColor = defaultCore.specularColor;
        this._core.specularColor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultSpecularColor[0],
            color.g != undefined && color.g != null ? color.g : defaultSpecularColor[1],
            color.b != undefined && color.b != null ? color.b : defaultSpecularColor[2]
        ] : defaultCore.specularColor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getSpecularColor = function () {
        return {
            r:this._core.specularColor[0],
            g:this._core.specularColor[1],
            b:this._core.specularColor[2]
        };
    };

    SceneJS.Material.prototype.setEmitColor = function (color) {
        var defaultEmitColor = defaultCore.emitColor;
        this._core.emitColor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultEmitColor[0],
            color.g != undefined && color.g != null ? color.g : defaultEmitColor[1],
            color.b != undefined && color.b != null ? color.b : defaultEmitColor[2]
        ] : defaultCore.emitColor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getEmitColor = function () {
        return {
            r:this._core.emitColor[0],
            g:this._core.emitColor[1],
            b:this._core.emitColor[2]
        };
    };

    SceneJS.Material.prototype.setSpecular = function (specular) {
        this._core.specular = (specular != undefined && specular != null) ? specular : defaultCore.specular;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getSpecular = function () {
        return this._core.specular;
    };

    SceneJS.Material.prototype.setShine = function (shine) {
        this._core.shine = (shine != undefined && shine != null) ? shine : defaultCore.shine;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getShine = function () {
        return this._core.shine;
    };

    SceneJS.Material.prototype.setEmit = function (emit) {
        this._core.emit = (emit != undefined && emit != null) ? emit : defaultCore.emit;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getEmit = function () {
        return this._core.emit;
    };

    SceneJS.Material.prototype.setAlpha = function (alpha) {
        this._core.alpha = (alpha != undefined && alpha != null) ? alpha : defaultCore.alpha;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getAlpha = function () {
        return this._core.alpha;
    };

    SceneJS.Material.prototype._compile = function (ctx) {
        this._engine.display.material = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.material = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();;new (function () {

    /**
     * The default state core singleton for {@link SceneJS.MorphGeometry} nodes
     */
    var defaultCore = {
        type: "morphGeometry",
        stateId: SceneJS._baseStateId++,
        hash: "",
        //         empty: true,
        morph: null
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.morphGeometry = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines morphing behaviour for the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.MorphGeometry = SceneJS_NodeFactory.createNodeType("morphGeometry");

    SceneJS.MorphGeometry.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node defines the resource

            this._pickPositionsDirty = true;

            this._buildNodeCore(params);

            this._core.webglRestored = function () {
                //self._buildNodeCore(self._engine.canvas.gl, self._core);
            };

            var self = this;

            // For the morph target at the given index,
            // returns a positions VBO for triangle-picking,
            // lazy-generated from the given indices if not yet existing.

            this._core.getPickPositions = function (index, indices) {
                if (self._pickPositionsDirty) {
                    self._buildPickPositions(indices);
                }
                return self._core.targets[index].pickPositionsBuf;
            };

            // For the morph target at the given index,
            // returns tangents for normal mapping
            // lazy-generated from the given indices if not yet existing.

            this._core.getTangents = function (index, indices, uv) {
                var core = self._core;
                var target = core.targets[index];
                if (target.tangentBuf) {
                    return target.tangentBuf;
                }
                var positions = target.positions;
                uv = target.uv || uv;
                if (positions && indices && uv) {
                    var gl = self._engine.canvas.gl;
                    var tangents = new Float32Array(SceneJS_math_buildTangents(positions, indices, uv));
                    target.tangents = tangents;
                    var usage = gl.STATIC_DRAW;
                    target.tangentBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, tangents, tangents.length, 3, usage);
                    return target.tangentBuf;
                }
            };

            this.setFactor(params.factor);
        }

        this._core.factor = params.factor || 0;
        this._core.clamp = !!params.clamp;
    };

    SceneJS.MorphGeometry.prototype._buildNodeCore = function (data) {

        try {
            buildCore(this, data);
        } catch (e) {

            /* Allocation failure - deallocate target VBOs
             */
            for (var i = 0, len = core.targets.length; i < len; i++) {

                target = core.targets[i];

                if (target.vertexBuf) {
                    target.vertexBuf.destroy();
                }
                if (target.normalBuf) {
                    target.normalBuf.destroy();
                }
                if (target.uvBuf) {
                    target.uvBuf.destroy();
                }
                if (target.uvBuf2) {
                    target.uvBuf2.destroy();
                }
            }

            throw SceneJS_error.fatalError(
                SceneJS.errors.ERROR,
                "Failed to allocate VBO(s) for morphGeometry: " + e);
        }

    };

    SceneJS.MorphGeometry.prototype._buildPickPositions = function (indices) {

        var core = this._core;
        var target = null;
        var pickPositions;
        var gl = this._engine.canvas.gl;
        var usage = gl.STATIC_DRAW;

        // On each morph target, build a positions array for
        // color-indexed triangle-picking.

        for (var i = 0, len = core.targets.length; i < len; i++) {

            target = core.targets[i];

            if (target.positions) {

                if (target.pickPositionsBuf) {
                    target.pickPositionsBuf.destroy();
                    target.pickPositionsBuf = null;
                }

                pickPositions = SceneJS_math_getPickPositions(target.positions, indices);

                target.pickPositionsBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickPositions, pickPositions.length, 3, usage);
            }
        }

        this._pickPositionsDirty = false;
    };

    SceneJS.MorphGeometry.prototype.setFactor = function (factor) {
        factor = factor || 0.0;

        var core = this._core;

        var keys = core.keys;
        var key1 = core.key1;
        var key2 = core.key2;

        var oldFactor = core.factor;

        if (factor < keys[0]) {
            key1 = 0;
            key2 = 1;

        } else if (factor > keys[keys.length - 1]) {
            key1 = keys.length - 2;
            key2 = key1 + 1;

        } else {
            while (keys[key1] > factor) {
                key1--;
                key2--;
            }
            while (keys[key2] < factor) {
                key1++;
                key2++;
            }
        }

        var frameUpdate = key1 != core.key1;

        /* Normalise factor to range [0.0..1.0] for the target frame
         */
        core.factor = (factor - keys[key1]) / (keys[key2] - keys[key1]);

        this._factor = factor;

        var morphUpdate = frameUpdate || oldFactor != core.factor;

        core.key1 = key1;
        core.key2 = key2;

        if (morphUpdate) {
            var currentFrame = this.getCurrentFrame();
            this.publish("update", currentFrame);
            if (frameUpdate) {
                this.publish("frameUpdate", currentFrame);
            }
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.MorphGeometry.prototype.getFactor = function () {
        return this._factor;
    };

    SceneJS.MorphGeometry.prototype.getKeys = function () {
        return this._core.keys;
    };

    SceneJS.MorphGeometry.prototype.getTargets = function () {
        return this._core.targets;
    };

    SceneJS.MorphGeometry.prototype.getCurrentFrame = function () {
        var core = this._core;
        var key1 = core.key1;
        var key2 = core.key2;
        return {
            key1: key1,
            key2: key2,
            factor: core.factor,
            target1: core.targets[key1],
            target2: core.targets[key2]
        }
    };

    SceneJS.MorphGeometry.prototype._compile = function (ctx) {

        if (!this._core.hash) {
            this._makeHash();
        }

        this._engine.display.morphGeometry = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.morphGeometry = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.MorphGeometry.prototype._makeHash = function () {
        var core = this._core;
        if (core.targets.length > 0) {
            var target0 = core.targets[0];  // All targets have same arrays
            var t = "t";
            var f = "f";
            core.hash = ([
                target0.vertexBuf ? t : f,
                target0.normalBuf ? t : f,
                target0.uvBuf ? t : f,
                target0.uvBuf2 ? t : f
            ]).join("");
        } else {
            core.hash = "";
        }
    };

    SceneJS.MorphGeometry.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Destroy core if no other references
            if (document.getElementById(this._engine.canvas.canvasId)) { // Context won't exist if canvas has disappeared
                var core = this._core;
                var target;
                for (var i = 0, len = core.targets.length; i < len; i++) {
                    target = core.targets[i];
                    if (target.vertexBuf) {
                        target.vertexBuf.destroy();
                    }
                    if (target.pickPositionsBuf) {
                        target.pickPositionsBuf.destroy();
                    }
                    if (target.normalBuf) {
                        target.normalBuf.destroy();
                    }
                    if (target.uvBuf) {
                        target.uvBuf.destroy();
                    }
                    if (target.uvBuf2) {
                        target.uvBuf2.destroy();
                    }
                }
            }
        }
    };

    function buildCore(node, data) {
        var targetsData = data.targets || [];
        if (targetsData.length < 2) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "morphGeometry node should have at least two targets");
        }

        var keysData = data.keys || [];
        if (keysData.length != targetsData.length) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "morphGeometry node mismatch in number of keys and targets");
        }

        var core = node._core;
        var gl = node._engine.canvas.gl;
        var usage = gl.STATIC_DRAW; //var usage = (!arrays.fixed) ? gl.STREAM_DRAW : gl.STATIC_DRAW;

        core.keys = keysData;
        core.targets = [];
        core.key1 = 0;
        core.key2 = 1;

        /* First target's arrays are defaults for where not given on previous and subsequent targets.
         * When target does have array, subsequent targets without array inherit it.
         */

        var positions;
        var normals;
        var uv;
        var uv2;

        var targetData;

        for (var i = 0, len = targetsData.length; i < len; i++) {
            targetData = targetsData[i];
            if (!positions && targetData.positions) {
                positions = targetData.positions;
            }
            if (!normals && targetData.normals) {
                normals = targetData.normals;
            }
            if (!uv && targetData.uv) {
                uv = targetData.uv;
            }
            if (!uv2 && targetData.uv2) {
                uv2 = targetData.uv2;
            }
        }

        var target;
        var arry;

        for (var i = 0, len = targetsData.length; i < len; i++) {
            targetData = targetsData[i];
            target = {};

            arry = targetData.positions || positions;
            if (arry) {
                target.positions = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                target.vertexBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.positions, arry.length, 3, usage);
                positions = arry;
            }

            arry = targetData.normals || normals;
            if (arry) {
                target.normals = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                target.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.normals, arry.length, 3, usage);
                normals = arry;
            }

            arry = targetData.uv || uv;
            if (arry) {
                target.uv = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                target.uvBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.uv, arry.length, 2, usage);
                uv = arry;
            }

            arry = targetData.uv2 || uv2;
            if (arry) {
                target.uv2 = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                target.uvBuf2 = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.uv2, arry.length, 2, usage);
                uv2 = arry;
            }

            core.targets.push(target);  // We'll iterate this to destroy targets when we recover from error
        }

        node._pickPositionsDirty = true;
    }

})();
;(function () {

    /**
     * The default state core singleton for {@link SceneJS.Name} nodes
     */
    var defaultCore = {
        type:"name",
        stateId:SceneJS._baseStateId++,
        name:null
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.name = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which assigns a pick name to the {@link SceneJS.Geometry} nodes in its subgraph.
     * @extends SceneJS.Node
     */
    SceneJS.Name = SceneJS_NodeFactory.createNodeType("name");

    SceneJS.Name.prototype._init = function (params) {
        this.setName(params.name);
        this._core.nodeId = this.id;
    };

    SceneJS.Name.prototype.setName = function (name) {
        this._core.name = name || "unnamed";
        this._engine.branchDirty(this); // Need to recompile name path
    };

    SceneJS.Name.prototype.getName = function () {
        return this._core.name;
    };

    SceneJS.Name.prototype._compile = function (ctx) {

        this._engine.display.name = coreStack[stackLen++] = this._core;

        // (Re)build name path
        var path = [];
        var name;
        for (var i = 0; i < stackLen; i++) {
            name = coreStack[i].name;
            if (name) {
                path.push(name);
            }
        }
        this._core.path = path.join(".");

        this._compileNodes(ctx);
        this._engine.display.name = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };
})();;new (function () {

    /**
     * The default state core singleton for {@link SceneJS.Renderer} nodes
     */
    var defaultCore = {
        type: "renderer",
        stateId: SceneJS._baseStateId++,
        props: null
    };

    var canvas;         // Currently active canvas
    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {

            canvas = params.engine.canvas;

//                // TODO: Below is a HACK
//
//                defaultCore.props = createProps({  // Dont set props - just define for restoring to on props pop
//                    clear: {
//                        depth : true,
//                        color : true
//                    },
//                    // clearColor: {r: 0, g : 0, b : 0 },
//                    clearDepth: 1.0,
//                    enableDepthTest:true,
//                    enableCullFace: false,
//                    frontFace: "ccw",
//                    cullFace: "back",
//                    depthFunc: "less",
//                    depthRange: {
//                        zNear: 0,
//                        zFar: 1
//                    },
//                    enableScissorTest: false,
//                    viewport:{
//                        x : 1,
//                        y : 1,
//                        width: canvas.canvas.width,
//                        height: canvas.canvas.height
//                    },
//                    enableClip: undefined,
//                    enableBlend: false,
//                    blendFunc: {
//                        sfactor: "srcAlpha",
//                        dfactor: "one"
//                    }
//                });

            stackLen = 0;

            params.engine.display.renderer = coreStack[stackLen++] = defaultCore;
        });

    function createProps(props) {

        var restore;
        if (stackLen > 0) {  // can't restore when no previous props set
            restore = {};
            for (var name in props) {
                if (props.hasOwnProperty(name)) {
                    if (!(props[name] == undefined)) {
                        restore[name] = getSuperProperty(name);
                    }
                }
            }
        }

        processProps(props.props);

        return {

            props: props,

            setProps: function (gl) {
                setProperties(gl, props);
            },

            restoreProps: function (gl) {
                if (restore) {
                    restoreProperties(gl, restore);
                }
            }
        };
    }

    var getSuperProperty = function (name) {
        var props;
        var prop;
        for (var i = stackLen - 1; i >= 0; i--) {
            props = coreStack[i].props;
            if (props) {
                prop = props[name];
                if (prop != undefined && prop != null) {
                    return props[name];
                }
            }
        }
        return null; // Cause default to be set
    };

    function processProps(props) {
        var prop;
        for (var name in props) {
            if (props.hasOwnProperty(name)) {
                prop = props[name];
                if (prop != undefined && prop != null) {
                    if (glModeSetters[name]) {
                        props[name] = glModeSetters[name](null, prop);
                    } else if (glStateSetters[name]) {
                        props[name] = glStateSetters[name](null, prop);
                    }
                }
            }
        }
    }

    var setProperties = function (gl, props) {

        for (var key in props) {        // Set order-insensitive properties (modes)
            if (props.hasOwnProperty(key)) {
                var setter = glModeSetters[key];
                if (setter) {
                    setter(gl, props[key]);
                }
            }
        }

        if (props.viewport) {           // Set order-sensitive properties (states)
            glStateSetters.viewport(gl, props.viewport);
        }

        if (props.scissor) {
            glStateSetters.clear(gl, props.scissor);
        }

        if (props.clear) {
            glStateSetters.clear(gl, props.clear);
        }
    };

    /**
     * Restores previous renderer properties, except for clear - that's the reason we
     * have a seperate set and restore semantic - we don't want to keep clearing the buffer.
     */
    var restoreProperties = function (gl, props) {

        var value;

        for (var key in props) {            // Set order-insensitive properties (modes)
            if (props.hasOwnProperty(key)) {
                value = props[key];
                if (value != undefined && value != null) {
                    var setter = glModeSetters[key];
                    if (setter) {
                        setter(gl, value);
                    }
                }
            }
        }

        if (props.viewport) {               //  Set order-sensitive properties (states)
            glStateSetters.viewport(gl, props.viewport);
        }

        if (props.scissor) {
            glStateSetters.clear(gl, props.scissor);
        }
    };


    /**
     * Maps renderer node properties to WebGL gl enums
     * @private
     */
    var glEnum = function (gl, name) {
        if (!name) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Null SceneJS.State node config: \"" + name + "\"");
        }
        var result = SceneJS._webgl.enumMap[name];
        if (!result) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Unrecognised SceneJS.State node config value: \"" + name + "\"");
        }
        var value = gl[result];
        if (!value) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "This browser's WebGL does not support renderer node config value: \"" + name + "\"");
        }
        return value;
    };


    /**
     * Order-insensitive functions that set WebGL modes ie. not actually causing an
     * immediate change.
     *
     * These map to renderer properties and are called in whatever order their
     * property is found on the renderer config.
     *
     * Each of these wrap a state-setter function on the WebGL gl. Each function
     * also uses the glEnum map to convert its renderer node property argument to the
     * WebGL enum constant required by its wrapped function.
     *
     * When called with undefined/null gl, will condition and return the value given
     * ie. set it to default if value is undefined. When called with a gl, will
     * set the value on the gl using the wrapped function.
     *
     * @private
     */
    var glModeSetters = {

        enableBlend: function (gl, flag) {
            if (!gl) {
                if (flag == null || flag == undefined) {
                    flag = false;
                }
                return flag;
            }
            if (flag) {
                gl.enable(gl.BLEND);
            } else {
                gl.disable(gl.BLEND);
            }
        },

        blendColor: function (gl, color) {
            if (!gl) {
                color = color || {};
                return {
                    r: color.r || 0,
                    g: color.g || 0,
                    b: color.b || 0,
                    a: (color.a == undefined || color.a == null) ? 1 : color.a
                };
            }
            gl.blendColor(color.r, color.g, color.b, color.a);
        },

        blendEquation: function (gl, eqn) {
            if (!gl) {
                return eqn || "funcAdd";
            }
            gl.blendEquation(gl, glEnum(gl, eqn));
        },

        /** Sets the RGB blend equation and the alpha blend equation separately
         */
        blendEquationSeparate: function (gl, eqn) {
            if (!gl) {
                eqn = eqn || {};
                return {
                    rgb: eqn.rgb || "funcAdd",
                    alpha: eqn.alpha || "funcAdd"
                };
            }
            gl.blendEquation(glEnum(gl, eqn.rgb), glEnum(gl, eqn.alpha));
        },

        blendFunc: function (gl, funcs) {
            if (!gl) {
                funcs = funcs || {};
                return  {
                    sfactor: funcs.sfactor || "srcAlpha",
                    dfactor: funcs.dfactor || "oneMinusSrcAlpha"
                };
            }
            gl.blendFunc(glEnum(gl, funcs.sfactor || "srcAlpha"), glEnum(gl, funcs.dfactor || "oneMinusSrcAlpha"));
        },

        blendFuncSeparate: function (gl, func) {
            if (!gl) {
                func = func || {};
                return {
                    srcRGB: func.srcRGB || "zero",
                    dstRGB: func.dstRGB || "zero",
                    srcAlpha: func.srcAlpha || "zero",
                    dstAlpha: func.dstAlpha || "zero"
                };
            }
            gl.blendFuncSeparate(
                glEnum(gl, func.srcRGB || "zero"),
                glEnum(gl, func.dstRGB || "zero"),
                glEnum(gl, func.srcAlpha || "zero"),
                glEnum(gl, func.dstAlpha || "zero"));
        },

        clearColor: function (gl, color) {
            if (!gl) {
                color = color || {};
                return {
                    r: color.r || 0,
                    g: color.g || 0,
                    b: color.b || 0,
                    a: (color.a == undefined || color.a == null) ? 1 : color.a
                };
            }
            gl.clearColor(color.r, color.g, color.b, color.a);
        },

        clearDepth: function (gl, depth) {
            if (!gl) {
                return (depth == null || depth == undefined) ? 1 : depth;
            }
            gl.clearDepth(depth);
        },

        clearStencil: function (gl, clearValue) {
            if (!gl) {
                return  clearValue || 0;
            }
            gl.clearStencil(clearValue);
        },

        colorMask: function (gl, color) {
            if (!gl) {
                color = color || {};
                return {
                    r: color.r || 0,
                    g: color.g || 0,
                    b: color.b || 0,
                    a: (color.a == undefined || color.a == null) ? 1 : color.a
                };

            }
            gl.colorMask(color.r, color.g, color.b, color.a);
        },

        enableCullFace: function (gl, flag) {
            if (!gl) {
                return flag;
            }
            if (flag) {
                gl.enable(gl.CULL_FACE);
            } else {
                gl.disable(gl.CULL_FACE);
            }
        },

        cullFace: function (gl, mode) {
            if (!gl) {
                return mode || "back";
            }
            gl.cullFace(glEnum(gl, mode));
        },

        enableDepthTest: function (gl, flag) {
            if (!gl) {
                if (flag == null || flag == undefined) {
                    flag = true;
                }
                return flag;
            }
            if (flag) {
                gl.enable(gl.DEPTH_TEST);
            } else {
                gl.disable(gl.DEPTH_TEST);
            }
        },

        depthFunc: function (gl, func) {
            if (!gl) {
                return func || "less";
            }
            gl.depthFunc(glEnum(gl, func));
        },

        enableDepthMask: function (gl, flag) {
            if (!gl) {
                if (flag == null || flag == undefined) {
                    flag = true;
                }
                return flag;
            }
            gl.depthMask(flag);
        },

        depthRange: function (gl, range) {
            if (!gl) {
                range = range || {};
                return {
                    zNear: (range.zNear == undefined || range.zNear == null) ? 0 : range.zNear,
                    zFar: (range.zFar == undefined || range.zFar == null) ? 1 : range.zFar
                };
            }
            gl.depthRange(range.zNear, range.zFar);
        },

        frontFace: function (gl, mode) {
            if (!gl) {
                return mode || "ccw";
            }
            gl.frontFace(glEnum(gl, mode));
        },

        lineWidth: function (gl, width) {
            if (!gl) {
                return width || 1;
            }
            gl.lineWidth(width);
        },

        enableScissorTest: function (gl, flag) {
            if (!gl) {
                return flag;
            }
            if (flag) {
                gl.enable(gl.SCISSOR_TEST);
            } else {
                flag = false;
                gl.disable(gl.SCISSOR_TEST);
            }
        }
    };

    /**
     * Order-sensitive functions that immediately effect WebGL state change.
     *
     * These map to renderer properties and are called in a particular order since they
     * affect one another.
     *
     * Each of these wrap a state-setter function on the WebGL gl. Each function
     * also uses the glEnum map to convert its renderer node property argument to the
     * WebGL enum constant required by its wrapped function.
     *
     * @private
     */
    var glStateSetters = {

        /** Set viewport on the given gl
         */
        viewport: function (gl, v) {
            if (!gl) {
                v = v || {};
                return {
                    x: v.x || 1,
                    y: v.y || 1,
                    width: v.width || canvas.canvas.width,
                    height: v.height || canvas.canvas.height
                };
            }
            gl.viewport(v.x, v.y, v.width, v.height);
        },

        /** Sets scissor region on the given gl
         */
        scissor: function (gl, s) {
            if (!gl) {
                s = s || {};
                return {
                    x: s.x || 0,
                    y: s.y || 0,
                    width: s.width || 1.0,
                    height: s.height || 1.0
                };
            }
            gl.scissor(s.x, s.y, s.width, s.height);
        },

        /** Clears buffers on the given gl as specified in mask
         */
        clear: function (gl, mask) {
            if (!gl) {
                mask = mask || {};
                return mask;
            }
            var m;
            if (mask.color) {
                m = gl.COLOR_BUFFER_BIT;
            }
            if (mask.depth) {
                m = m | gl.DEPTH_BUFFER_BIT;
            }
            if (mask.stencil) {
                m = m | gl.STENCIL_BUFFER_BIT;
            }
            if (m) {
               //     gl.clear(m);
            }
        }
    };

    SceneJS.Renderer = SceneJS_NodeFactory.createNodeType("renderer");

    SceneJS.Renderer.prototype._init = function (params) {
        if (this._core.useCount == 1) { // This node defines the resource
            for (var key in params) {
                if (params.hasOwnProperty(key)) {
                    this._core[key] = params[key];
                }
            }
            this._core.dirty = true;
        }
    };

    SceneJS.Renderer.prototype.setViewport = function (viewport) {
        this._core.viewport = viewport ? {
            x: viewport.x || 1,
            y: viewport.y || 1,
            width: viewport.width || 1000,
            height: viewport.height || 1000
        } : undefined;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Renderer.prototype.getViewport = function () {
        return this._core.viewport ? {
            x: this._core.viewport.x,
            y: this._core.viewport.y,
            width: this._core.viewport.width,
            height: this._core.viewport.height
        } : undefined;
    };

    SceneJS.Renderer.prototype.setScissor = function (scissor) {
        this._core.scissor = scissor ? {
            x: scissor.x || 1,
            y: scissor.y || 1,
            width: scissor.width || 1000,
            height: scissor.height || 1000
        } : undefined;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Renderer.prototype.getScissor = function () {
        return this._core.scissor ? {
            x: this._core.scissor.x,
            y: this._core.scissor.y,
            width: this._core.scissor.width,
            height: this._core.scissor.height
        } : undefined;
    };

    SceneJS.Renderer.prototype.setClear = function (clear) {
        this._core.clear = clear ? {
            r: clear.r || 0,
            g: clear.g || 0,
            b: clear.b || 0
        } : undefined;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Renderer.prototype.getClear = function () {
        return this._core.clear ? {
            r: this._core.clear.r,
            g: this._core.clear.g,
            b: this._core.clear.b
        } : null;
    };

    SceneJS.Renderer.prototype.setEnableBlend = function (enableBlend) {
        this._core.enableBlend = enableBlend;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Renderer.prototype.getEnableBlend = function () {
        return this._core.enableBlend;
    };

    SceneJS.Renderer.prototype.setBlendColor = function (color) {
        this._core.blendColor = color ? {
            r: color.r || 0,
            g: color.g || 0,
            b: color.b || 0,
            a: (color.a == undefined || color.a == null) ? 1 : color.a
        } : undefined;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Renderer.prototype.getBlendColor = function () {
        return this._core.blendColor ? {
            r: this._core.blendColor.r,
            g: this._core.blendColor.g,
            b: this._core.blendColor.b,
            a: this._core.blendColor.a
        } : undefined;
    };

    SceneJS.Renderer.prototype.setBlendEquation = function (eqn) {
        this._core.blendEquation = eqn;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Renderer.prototype.getBlendEquation = function () {
        return this._core.blendEquation;
    };

    SceneJS.Renderer.prototype.setBlendEquationSeparate = function (eqn) {
        this._core.blendEquationSeparate = eqn ? {
            rgb: eqn.rgb || "funcAdd",
            alpha: eqn.alpha || "funcAdd"
        } : undefined;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Renderer.prototype.getBlendEquationSeparate = function () {
        return this._core.blendEquationSeparate ? {
            rgb: this._core.rgb,
            alpha: this._core.alpha
        } : undefined;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Renderer.prototype.setBlendFunc = function (funcs) {
        this._core.blendFunc = funcs ? {
            sfactor: funcs.sfactor || "srcAlpha",
            dfactor: funcs.dfactor || "one"
        } : undefined;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Renderer.prototype.getBlendFunc = function () {
        return this._core.blendFunc ? {
            sfactor: this._core.sfactor,
            dfactor: this._core.dfactor
        } : undefined;
    };

    SceneJS.Renderer.prototype.setBlendFuncSeparate = function (eqn) {
        this._core.blendFuncSeparate = eqn ? {
            srcRGB: eqn.srcRGB || "zero",
            dstRGB: eqn.dstRGB || "zero",
            srcAlpha: eqn.srcAlpha || "zero",
            dstAlpha: eqn.dstAlpha || "zero"
        } : undefined;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getBlendFuncSeparate = function () {
        return this._core.blendFuncSeparate ? {
            srcRGB: this._core.blendFuncSeparate.srcRGB,
            dstRGB: this._core.blendFuncSeparate.dstRGB,
            srcAlpha: this._core.blendFuncSeparate.srcAlpha,
            dstAlpha: this._core.blendFuncSeparate.dstAlpha
        } : undefined;
    };

    SceneJS.Renderer.prototype.setEnableCullFace = function (enableCullFace) {
        this._core.enableCullFace = enableCullFace;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getEnableCullFace = function () {
        return this._core.enableCullFace;
    };


    SceneJS.Renderer.prototype.setCullFace = function (cullFace) {
        this._core.cullFace = cullFace;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getCullFace = function () {
        return this._core.cullFace;
    };

    SceneJS.Renderer.prototype.setEnableDepthTest = function (enableDepthTest) {
        this._core.enableDepthTest = enableDepthTest;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getEnableDepthTest = function () {
        return this._core.enableDepthTest;
    };

    SceneJS.Renderer.prototype.setDepthFunc = function (depthFunc) {
        this._core.depthFunc = depthFunc;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getDepthFunc = function () {
        return this._core.depthFunc;
    };

    SceneJS.Renderer.prototype.setEnableDepthMask = function (enableDepthMask) {
        this._core.enableDepthMask = enableDepthMask;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getEnableDepthMask = function () {
        return this._core.enableDepthMask;
    };

    SceneJS.Renderer.prototype.setClearDepth = function (clearDepth) {
        this._core.clearDepth = clearDepth;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getClearDepth = function () {
        return this._core.clearDepth;
    };

    SceneJS.Renderer.prototype.setDepthRange = function (range) {
        this._core.depthRange = range ? {
            zNear: (range.zNear == undefined || range.zNear == null) ? 0 : range.zNear,
            zFar: (range.zFar == undefined || range.zFar == null) ? 1 : range.zFar
        } : undefined;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getDepthRange = function () {
        return this._core.depthRange ? {
            zNear: this._core.depthRange.zNear,
            zFar: this._core.depthRange.zFar
        } : undefined;
    };

    SceneJS.Renderer.prototype.setFrontFace = function (frontFace) {
        this._core.frontFace = frontFace;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getFrontFace = function () {
        return this._core.frontFace;
    };

    SceneJS.Renderer.prototype.setLineWidth = function (lineWidth) {
        this._core.lineWidth = lineWidth;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getLineWidth = function () {
        return this._core.lineWidth;
    };

    SceneJS.Renderer.prototype.setEnableScissorTest = function (enableScissorTest) {
        this._core.enableScissorTest = enableScissorTest;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getEnableScissorTest = function () {
        return this._core.enableScissorTest;
    };

    SceneJS.Renderer.prototype.setClearStencil = function (clearStencil) {
        this._core.clearStencil = clearStencil;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getClearStencil = function () {
        return this._core.clearStencil;
    };

    SceneJS.Renderer.prototype.setColorMask = function (color) {
        this._core.colorMask = color ? {
            r: color.r || 0,
            g: color.g || 0,
            b: color.b || 0,
            a: (color.a == undefined || color.a == null) ? 1 : color.a
        } : undefined;
        this._core.dirty = true;
    };

    SceneJS.Renderer.prototype.getColorMask = function () {
        return this._core.colorMask ? {
            r: this._core.colorMask.r,
            g: this._core.colorMask.g,
            b: this._core.colorMask.b,
            a: this._core.colorMask.a
        } : undefined;
    };

    SceneJS.Renderer.prototype._compile = function (ctx) {
        if (this._core.dirty) {
            this._core.props = createProps(this._core);
            this._core.dirty = false;
        }
        this._engine.display.renderer = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.renderer = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };
})();;(function () {

    var lookup = {
        less:"LESS",
        equal:"EQUAL",
        lequal:"LEQUAL",
        greater:"GREATER",
        notequal:"NOTEQUAL",
        gequal:"GEQUAL"
    };

    // The default state core singleton for {@link SceneJS.DepthBuf} nodes
    var defaultCore = {
        type:"depthBuffer",
        stateId:SceneJS._baseStateId++,
        enabled:true,
        clearDepth:1,
        depthFunc:null, // Lazy init depthFunc when we can get a context
        _depthFuncName:"less"
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            if (defaultCore.depthFunc === null) { // Lazy-init depthFunc now we can get a context
                defaultCore.depthFunc = params.engine.canvas.gl.LESS;
            }
            params.engine.display.depthBuffer = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures the depth buffer for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.DepthBuf = SceneJS_NodeFactory.createNodeType("depthBuffer");

    SceneJS.DepthBuf.prototype._init = function (params) {

        if (params.enabled != undefined) {
            this.setEnabled(params.enabled);
        } else if (this._core.useCount == 1) { // This node defines the core
            this.setEnabled(true);
        }

        if (params.clearDepth != undefined) {
            this.setClearDepth(params.clearDepth);
        } else if (this._core.useCount == 1) {
            this.setClearDepth(1);
        }

        if (params.depthFunc != undefined) {
            this.setDepthFunc(params.depthFunc);
        } else if (this._core.useCount == 1) {
            this.setDepthFunc("less");
        }

        if (params.clear != undefined) {
            this.setClear(params.clear);
        } else if (this._core.useCount == 1) {
            this.setClear(true);
        }
    };

    /**
     * Enable or disable the depth buffer
     *
     * @param enabled Specifies whether depth buffer is enabled or not
     * @return {*}
     */
    SceneJS.DepthBuf.prototype.setEnabled = function (enabled) {
        if (this._core.enabled != enabled) {
            this._core.enabled = enabled;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Get whether or not the depth buffer is enabled
     *
     * @return Boolean
     */
    SceneJS.DepthBuf.prototype.getEnabled = function () {
        return this._core.enabled;
    };

    /**
     * Sets whether or not to clear the depth buffer before each render
     *
     * @param clear
     * @return {*}
     */
    SceneJS.DepthBuf.prototype.setClear = function (clear) {
        if (this._core.clear != clear) {
            this._core.clear = clear;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Get whether or not the depth buffer is cleared before each render
     *
     * @return Boolean
     */
    SceneJS.DepthBuf.prototype.getClear = function () {
        return this._core.clear;
    };
    
    /**
     * Specify the clear value for the depth buffer.
     * Initial value is 1, and the given value will be clamped to [0..1].
     * @param clearDepth
     * @return {*}
     */
    SceneJS.DepthBuf.prototype.setClearDepth = function (clearDepth) {
        if (this._core.clearDepth != clearDepth) {
            this._core.clearDepth = clearDepth;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Get the clear value for the depth buffer
     *
     * @return Number
     */
    SceneJS.DepthBuf.prototype.getClearDepth = function () {
        return this._core.clearDepth;
    };

    /**
     * Sets the depth comparison function.
     * Supported values are 'less', 'equal', 'lequal', 'greater', 'notequal' and 'gequal'
     * @param {String} depthFunc The depth comparison function
     * @return {*}
     */
    SceneJS.DepthBuf.prototype.setDepthFunc = function (depthFunc) {
        if (this._core._depthFuncName != depthFunc) {
            var enumName = lookup[depthFunc];
            if (enumName == undefined) {
                throw "unsupported value for 'clearFunc' attribute on depthBuffer node: '" + depthFunc
                    + "' - supported values are 'less', 'equal', 'lequal', 'greater', 'notequal' and 'gequal'";
            }
            this._core.depthFunc = this._engine.canvas.gl[enumName];
            this._core._depthFuncName = depthFunc;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Returns the depth comparison function
     * @return {*}
     */
    SceneJS.DepthBuf.prototype.getDepthFunc = function () {
        return this._core._depthFuncName;
    };

    SceneJS.DepthBuf.prototype._compile = function (ctx) {
        this._engine.display.depthBuffer = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.depthBuffer = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();;(function () {

    var lookup = {
        // stencilFunc.func
        never: "NEVER", 
        less: "LESS",
        equal: "EQUAL",
        lequal: "LEQUAL",
        greater: "GREATER",
        notequal: "NOTEQUAL",
        gequal: "GEQUAL",
        always: "ALWAYS",

        // stencilOp
        keep: "KEEP",
        zero: "ZERO",
        replace: "REPLACE",
        incr: "INCR",
        incr_wrap: "INCR_WRAP",
        decr: "DECR",
        decr_wrap: "DECR_WRAP",
        invert: "INVERT",

        // face
        front: "FRONT",
        back: "BACK",
        front_and_back: "FRONT_AND_BACK"
    };

    // The default state core singleton for {@link SceneJS.StencilBuf} nodes
    var defaultCore = {
        type: "stencilBuffer",
        stateId: SceneJS._baseStateId++,
        enabled: false,
        clearStencil: 0,
        
        // Lazy init stencilFunc when we can get a context

        stencilFuncFuncFront: null,
        stencilFuncRefFront: 0,
        stencilFuncMaskFront: 0xff,

        stencilFuncFuncBack: null,
        stencilFuncRefBack: 0,
        stencilFuncMaskBack: 0xff,

        stencilOpSfailFront: null,
        stencilOpDpfailFront: null,
        stencilOpDppassFront: null,

        stencilOpSfailBack: null,
        stencilOpDpfailBack: null,
        stencilOpDppassBack: null,

        _stencilFuncFuncStateFront: "always",
        _stencilFuncRefStateFront: 0,
        _stencilFuncMaskStateFront: 0xff,

        _stencilFuncFuncStateBack: "always",
        _stencilFuncRefStateBack: 0,
        _stencilFuncMaskStateBack: 0xff,

        _stencilOpSfailStateFront: "keep",
        _stencilOpDpfailStateFront: "keep",
        _stencilOpDppassStateFront: "keep",

        _stencilOpSfailStateBack: "keep",
        _stencilOpDpfailStateBack: "keep",
        _stencilOpDppassStateBack: "keep"
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            // Lazy-init stencilFunc now we can get a context
            if (defaultCore.stencilFuncFuncFront === null) { 
                defaultCore.stencilFuncFuncFront = params.engine.canvas.gl.ALWAYS;
            }

            if (defaultCore.stencilFuncFuncBack === null) {
                defaultCore.stencilFuncFuncBack = params.engine.canvas.gl.ALWAYS;
            }

            if (defaultCore.stencilOpSfailFront === null) {
                defaultCore.stencilOpSfailFront = params.engine.canvas.gl.KEEP;
                defaultCore.stencilOpDpfailFront = params.engine.canvas.gl.KEEP;
                defaultCore.stencilOpDppassFront = params.engine.canvas.gl.KEEP;
            }

            if (defaultCore.stencilOpSfailBack === null) {
                defaultCore.stencilOpSfailBack = params.engine.canvas.gl.KEEP;
                defaultCore.stencilOpDpfailBack = params.engine.canvas.gl.KEEP;
                defaultCore.stencilOpDppassBack = params.engine.canvas.gl.KEEP;
            }

            params.engine.display.stencilBuffer = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures the stencil buffer for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.StencilBuf = SceneJS_NodeFactory.createNodeType("stencilBuffer");

    SceneJS.StencilBuf.prototype._init = function (params) {

        if (params.enabled != undefined) {
            this.setEnabled(params.enabled);
        } else if (this._core.useCount == 1) { // This node defines the core
            this.setEnabled(true);
        }

        if (params.clearStencil != undefined) {
            this.setClearStencil(params.clearStencil);
        } else if (this._core.useCount == 1) {
            this.setClearStencil(0);
        }

        if (params.stencilFunc != undefined) {
            this.setStencilFunc(params.stencilFunc);
        } else if (this._core.useCount == 1) {
            this.setStencilFunc({
                face: "front_back",
                func: "always", 
                ref: 1, 
                mask: 0xff
            });
        }

        if (params.stencilOp != undefined) {
            this.setStencilOp(params.stencilOp);
        } else if (this._core.useCount == 1) {
            this.setStencilOp({
                face: "front_back",
                sfail: "keep", 
                dpfail: "keep", 
                dppass: "keep"
            });
        }

        if (params.clear != undefined) {
            this.setClear(params.clear);
        }
    };

    /**
     * Enable or disable the stencil buffer
     *
     * @param enabled Specifies whether stencil buffer is enabled or not
     * @return {*}
     */
    SceneJS.StencilBuf.prototype.setEnabled = function (enabled) {
        if (this._core.enabled != enabled) {
            this._core.enabled = enabled;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Get whether or not the stencil buffer is enabled
     *
     * @return Boolean
     */
    SceneJS.StencilBuf.prototype.getEnabled = function () {
        return this._core.enabled;
    };

    /**
     * Sets whether or not to clear the stencil buffer before each render
     *
     * @param clear
     * @return {*}
     */
    SceneJS.StencilBuf.prototype.setClear = function (clear) {
        if (this._core.clear != clear) {
            this._core.clear = clear;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Get whether or not the stencil buffer is cleared before each render
     *
     * @return Boolean
     */
    SceneJS.StencilBuf.prototype.getClear = function () {
        return this._core.clear;
    };
    
    /**
     * Specify the clear value for the stencil buffer.
     * Initial value is 1, and the given value will be clamped to [0..1].
     * @param clearStencil
     * @return {*}
     */
    SceneJS.StencilBuf.prototype.setClearStencil = function (clearStencil) {
        if (this._core.clearStencil != clearStencil) {
            this._core.clearStencil = clearStencil;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Get the clear value for the stencil buffer
     *
     * @return Number
     */
    SceneJS.StencilBuf.prototype.getClearStencil = function () {
        return this._core.clearStencil;
    };

    /**
     * Sets the stencil comparison function
     * 
     * @param {String} params - The stencil comparison function
     * @return {*}
     */
    SceneJS.StencilBuf.prototype.setStencilFunc = function (params) {

        var faceFront = false;
        var faceBack = false;

        var funcFront = params.func || 'always';
        var refFront = params.ref !== undefined ? params.ref : 1;
        var maskFront = params.mask !== undefined ? params.mask : 0xff;

        var funcBack = funcFront;
        var refBack = refFront;
        var maskBack = maskFront;

        var face = params.face || 'front_and_back';

        if (params.front || params.back) {

            if (params.front) {
                faceFront = true;

                funcFront = params.front.func || 'always';
                refFront = params.front.ref !== undefined ? params.front.ref : 1;
                maskFront = params.front.mask !== undefined ? params.front.mask : 0xff;
            }

            if (params.back) {
                faceBack = true;

                funcBack = params.back.func || 'always';
                refBack = params.back.ref !== undefined ? params.back.ref : 1;
                maskBack = params.back.mask !== undefined ? params.back.mask : 0xff;
            }

        } else {

            faceFront = face === 'front' || face === 'front_and_back';
            faceBack = face === 'back' || face === 'front_and_back';

        }

        if (refFront !== refBack || maskFront !== maskBack) {
            throw "WebGL only allow same value for stencil ref and mask of front and back faces";
        }

        if (faceFront) {
            // Front
            if (this._core._stencilFuncFuncStateFront != funcFront || 
                this._core._stencilFuncRefStateFront != refFront ||
                this._core._stencilFuncMaskStateFront != maskFront 
                ) {

                var funcEnumName = lookup[funcFront];
                if (funcEnumName == undefined) {
                    throw "unsupported value for 'stencilFunc' attribute on stencilBuffer node: '" + stencilFunc.func
                        + "' - supported values are 'keep', 'always', 'less', 'equal', 'lequal', 'greater', 'notequal' and 'gequal'";
                }

                this._core.stencilFuncFuncFront = this._engine.canvas.gl[funcEnumName];
                this._core.stencilFuncRefFront = refFront;
                this._core.stencilFuncMaskFront = maskFront;

                this._core._stencilFuncFuncStateFront = funcFront;
                this._core._stencilFuncRefStateFront = refFront;
                this._core._stencilFuncMaskStateFront = maskFront;

                this._engine.display.imageDirty = true;
            }
        } 

        if (faceBack) {
            // Back
            if (this._core._stencilFuncFuncStateBack != funcBack || 
                this._core._stencilFuncRefStateBack != refBack ||
                this._core._stencilFuncMaskStateBack != maskBack 
                ) {

                var funcEnumName = lookup[funcBack];
                if (funcEnumName == undefined) {
                    throw "unsupported value for 'stencilFunc' attribute on stencilBuffer node: '" + stencilFunc.func
                        + "' - supported values are 'keep', 'always', 'less', 'equal', 'lequal', 'greater', 'notequal' and 'gequal'";
                }

                this._core.stencilFuncFuncBack = this._engine.canvas.gl[funcEnumName];
                this._core.stencilFuncRefBack = refBack;
                this._core.stencilFuncMaskBack = maskBack;

                this._core._stencilFuncFuncStateBack = funcBack;
                this._core._stencilFuncRefStateBack = refBack;
                this._core._stencilFuncMaskStateBack = maskBack;

                this._engine.display.imageDirty = true;
            }
        } 

        return this;
    };

    /**
     * Sets the stencil comparison function.
     * Supported values are 'keep', 'zero', 'replace', 'incr', 'incr_wrap', 'decr', 'decr_wrap', 'invert'
     * @param {Object} params - stencilOp parameters
     * @param {String} params.
     * @return {*}
     */
    SceneJS.StencilBuf.prototype.setStencilOp = function (params) {

        var faceFront = false;
        var faceBack = false;

        var sfailFront = params.sfail || 'keep';
        var dpfailFront = params.dpfail || 'keep';
        var dppassFront = params.dppass || 'keep';

        var sfailBack = sfailFront;
        var dpfailBack = dpfailFront;
        var dppassBack = dppassFront;

        var face = params.face || 'front_and_back';

        if (params.front || params.back) {

            if (params.front) {
                faceFront = true;

                sfailFront = params.front.sfail || 'keep';
                dpfailFront = params.front.dpfail || 'keep';
                dppassFront = params.front.dppass || 'keep';
            }

            if (params.back) {
                faceBack = true;

                sfailBack = params.back.sfail || 'keep';
                dpfailBack = params.back.dpfail || 'keep';
                dppassBack = params.back.dppass || 'keep';
            }

        } else {

            faceFront = face === 'front' || face === 'front_and_back';
            faceBack = face === 'back' || face === 'front_and_back';

        }

        if (faceFront) {
            // Front
            if (this._core._stencilOpSfailStateFront != sfailFront || 
                this._core._stencilOpDpfailStateFront != dpfailFront ||
                this._core._stencilOpDppassStateFront != dppassFront 
                ) {

                var sfail = lookup[sfailFront];
                var dpfail = lookup[dpfailFront];
                var dppass = lookup[dppassFront];
                if (sfail == undefined || dpfail == undefined || dppass == undefined) {
                    throw "unsupported value for 'StencilOp' attribute on stencilBuffer node - supported values are 'keep', 'zero', 'replace', 'incr', 'incr_wrap', 'decr', 'decr_wrap', 'invert'";
                }

                this._core.stencilOpSfailFront = this._engine.canvas.gl[sfail];
                this._core.stencilOpDpfailFront = this._engine.canvas.gl[dpfail];
                this._core.stencilOpDppassFront = this._engine.canvas.gl[dppass];

                this._core._stencilOpSfailStateFront = sfailFront;
                this._core._stencilOpSfailStateFront = dpfailFront;
                this._core._stencilOpSfailStateFront = dppassFront;

                this._engine.display.imageDirty = true;
            }
        } 
        
        if (faceBack) {
            // Back
            if (this._core._stencilOpSfailStateBack != sfailBack || 
                this._core._stencilOpDpfailStateBack != dpfailBack ||
                this._core._stencilOpDppassStateBack != dppassBack 
                ) {

                var sfail = lookup[sfailBack];
                var dpfail = lookup[dpfailBack];
                var dppass = lookup[dppassBack];
                if (sfail == undefined || dpfail == undefined || dppass == undefined) {
                    throw "unsupported value for 'StencilOp' attribute on stencilBuffer node - supported values are 'keep', 'zero', 'replace', 'incr', 'incr_wrap', 'decr', 'decr_wrap', 'invert'";
                }

                this._core.stencilOpSfailBack = this._engine.canvas.gl[sfail];
                this._core.stencilOpDpfailBack = this._engine.canvas.gl[dpfail];
                this._core.stencilOpDppassBack = this._engine.canvas.gl[dppass];

                this._core._stencilOpSfailStateBack = sfailBack;
                this._core._stencilOpSfailStateBack = dpfailBack;
                this._core._stencilOpSfailStateBack = dppassBack;

                this._engine.display.imageDirty = true;
            }
        }

        return this;
    };

    SceneJS.StencilBuf.prototype.getStencilFuncFront = function () {
        return {
            func: this._core._stencilFuncFuncStateFront,
            ref: this._core._stencilFuncRefStateFront,
            mask: this._core._stencilFuncMaskStateFront
        };
    };

    SceneJS.StencilBuf.prototype.getStencilFuncBack = function () {
        return {
            func: this._core._stencilFuncFuncStateBack,
            ref: this._core._stencilFuncRefStateBack,
            mask: this._core._stencilFuncMaskStateBack
        };
    };

    SceneJS.StencilBuf.prototype.getStencilOpFront = function () {
        return {
            sfail: this._core._stencilOpSfailStateFront, 
            dpfail: this._core._stencilOpDpfailStateFront,
            dppass: this._core._stencilOpDppassStateFront
        };
    };

    SceneJS.StencilBuf.prototype.getStencilOpBack = function () {
        return {
            sfail: this._core._stencilOpSfailStateBack, 
            dpfail: this._core._stencilOpDpfailStateBack,
            dppass: this._core._stencilOpDppassStateBack
        };
    };

    SceneJS.StencilBuf.prototype._compile = function (ctx) {
        this._engine.display.stencilBuffer = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.stencilBuffer = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();;(function () {

    // The default state core singleton for {@link SceneJS.ColorBuffer} nodes
    var defaultCore = {
        type: "colorBuffer",
        stateId: SceneJS._baseStateId++,
        blendEnabled: false,
        colorMask: { r: true, g: true, b: true, a: true }
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.colorBuffer = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures the color buffer for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.ColorBuffer = SceneJS_NodeFactory.createNodeType("colorBuffer");

    SceneJS.ColorBuffer.prototype._init = function (params) {
        if (params.blendEnabled != undefined) {
            this.setBlendEnabled(params.blendEnabled);
        } else if (this._core.useCount == 1) { // This node defines the core
            this.setBlendEnabled(false);
        }
        this.setColorMask(params);
    };

    /**
     * Enable or disable blending
     *
     * @param blendEnabled Specifies whether depth buffer is blendEnabled or not
     */
    SceneJS.ColorBuffer.prototype.setBlendEnabled = function (blendEnabled) {
        if (this._core.blendEnabled != blendEnabled) {
            this._core.blendEnabled = blendEnabled;
            this._engine.display.imageDirty = true;
        }
        this._engine.display.imageDirty = true;
    };

    /**
     * Get whether or not blending is enabled
     * @return Boolean
     */
    SceneJS.ColorBuffer.prototype.getBlendEnabled = function () {
        return this._core.blendEnabled;
    };

    /**
     * Enable and disable writing of buffer's color components.
     * Components default to true where not given.
     * @param mask The mask
     */
    SceneJS.ColorBuffer.prototype.setColorMask = function (mask) {
        this._core.colorMask =  {
            r: mask.r != undefined && mask.r != null ? mask.r : true,
            g: mask.g != undefined && mask.g != null ? mask.g : true,
            b: mask.b != undefined && mask.b != null ? mask.b : true,
            a: mask.a != undefined && mask.a != null ? mask.a : true
        };
        this._engine.display.imageDirty = true;
    };

    /**
     * Gets the color mask
     * @return {{}}
     */
    SceneJS.ColorBuffer.prototype.getColorMask = function () {
        return this._core.colorMask;
    };

    SceneJS.ColorBuffer.prototype._compile = function (ctx) {
        this._engine.display.colorBuffer = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.colorBuffer = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
        this._engine.display.imageDirty = true;
    };

})();;(function () {

    // The default state core singleton for {@link SceneJS.View} nodes
    var defaultCore = {
        type:"view",
        stateId:SceneJS._baseStateId++,
        scissorTestEnabled:false
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.view = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures view parameters such as depth range, scissor test and viewport
     * @extends SceneJS.Node
     * void depthRange(floatzNear, floatzFar)
     zNear: Clamped to the range 0 to 1 Must be <= zFar
     zFar: Clamped to the range 0 to 1.
     void scissor(int x, int y, long width, long height)
     void viewport(int x, int y, long width, long height)
     */
    SceneJS.View = SceneJS_NodeFactory.createNodeType("view");

    SceneJS.View.prototype._init = function (params) {

        if (params.scissorTestEnabled != undefined) {
            this.setScissorTestEnabled(params.scissorTestEnabled);
        } else if (this._core.useCount == 1) { // This node defines the core
            this.setScissorTestEnabled(false);
        }
    };

    /**
     * Enable or disables scissor test.
     *
     * When enabled, the scissor test will discards fragments that are outside the scissor box.
     *
     * Scissor test is initially disabled.
     *
     * @param scissorTestEnabled Specifies whether scissor test is enabled or not
     * @return {*}
     */
    SceneJS.View.prototype.setScissorTestEnabled = function (scissorTestEnabled) {
        if (this._core.scissorTestEnabled != scissorTestEnabled) {
            this._core.scissorTestEnabled = scissorTestEnabled;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Get whether or not scissor test is enabled.
     * Initial value will be false.
     *
     * @return Boolean
     */
    SceneJS.View.prototype.getScissorTestEnabled = function () {
        return this._core.scissorTestEnabled;
    };

    SceneJS.View.prototype._compile = function (ctx) {
        this._engine.display.view = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.view = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();;/**
 * @class The root node of a scenegraph
 * @extends SceneJS.Node
 *
 */

SceneJS.Scene = SceneJS_NodeFactory.createNodeType("scene");

SceneJS.Scene.prototype._init = function (params) {

    if (params.tagMask) {
        this.setTagMask(params.tagMask);
    }

    this._tagSelector = null;

    /**
     * Set false when canvas is to be transparent.
     * @type {boolean}
     */
    this.transparent = (params.transparent === true);

    /**
     * Tracks statistics within this engine, such as numbers of
     * scenes, textures, geometries etc.
     *
     * @property stats
     * @type {*}
     * @final
     */
    this.stats = this._engine.stats;
};


/**
 * Simulate a lost WebGL context for testing purposes.
 * Only works if the simulateWebGLLost was given as an option to {@link SceneJS.createScene}.
 */
SceneJS.Scene.prototype.loseWebGLContext = function () {
    this._engine.loseWebGLContext();
};


/**
 * Returns the HTML canvas for this scene
 * @return {HTMLCanvas} The canvas
 */
SceneJS.Scene.prototype.getCanvas = function () {
    return this._engine.canvas.canvas;
};

/**
 * Returns the WebGL context for this scene
 */
SceneJS.Scene.prototype.getGL = function () {
    return this._engine.canvas.gl;
};

/** Returns the Z-buffer depth in bits of the webgl context that this scene is to bound to.
 */
SceneJS.Scene.prototype.getZBufferDepth = function () {
    var gl = this._engine.canvas.gl;
    return gl.getParameter(gl.DEPTH_BITS);
};

/**
 * Set canvas size multiplier for supersample anti-aliasing
 */
SceneJS.Scene.prototype.setResolutionScaling = function (resolutionScaling) {
    return this._engine.canvas.setResolutionScaling(resolutionScaling);
};

/**
 * Sets a regular expression to select which of the scene subgraphs that are rooted by {@link SceneJS.Tag} nodes are included in scene renders
 * @param {String} [tagMask] Regular expression string to match on the tag attributes of {@link SceneJS.Tag} nodes. Nothing is selected when this is omitted.
 * @see #getTagMask
 * @see SceneJS.Tag
 */
SceneJS.Scene.prototype.setTagMask = function (tagMask) {
    tagMask = tagMask || "XXXXXXXXXXXXXXXXXXXXXXXXXX"; // HACK to select nothing by default
    if (!this._tagSelector) {
        this._tagSelector = {};
    }
    this._tagSelector.mask = tagMask;
    this._tagSelector.regex = tagMask ? new RegExp(tagMask) : null;
    this._engine.display.selectTags(this._tagSelector);
};

/**
 * Gets the regular expression which will select which of the scene subgraphs that are rooted by {@link SceneJS.Tag} nodes are included in scene renders
 * @see #setTagMask
 * @see SceneJS.Tag
 * @returns {String} Regular expression string that will be matched on the tag attributes of {@link SceneJS.Tag} nodes
 */
SceneJS.Scene.prototype.getTagMask = function () {
    return this._tagSelector ? this._tagSelector.mask : null;
};

/**
 * Sets the number of times this scene is drawn on each render.
 * <p>This is useful for when we need to do things like render for left and right eyes.
 * @param {Number} numPasses The number of times the scene is drawn on each frame.
 * @see #getTagMask
 * @see SceneJS.Tag
 */
SceneJS.Scene.prototype.setNumPasses = function (numPasses) {
    this._engine.setNumPasses(numPasses);
};

/**
 * Render a single frame if new frame pending, or force a new frame
 * Returns true if frame rendered
 */
SceneJS.Scene.prototype.renderFrame = function (params) {
    return this._engine.renderFrame(params);
};

/**
 * Prevent re-compilation of scene graph.
 */
SceneJS.Scene.prototype.pauseCompilation = function () {
    return this._engine.pauseCompilation();
};

/**
 * Resume re-compilation of scene graph.
 */
SceneJS.Scene.prototype.resumeCompilation = function () {
    return this._engine.resumeCompilation();
};

/**
 * Force compilation of the scene graph.
 */
SceneJS.Scene.prototype.compile = function () {
    return this._engine.compile();
};

/**
 * Signals that a new frame will be needed
 * @param params
 */
SceneJS.Scene.prototype.needFrame = function () {
    this._engine.display.imageDirty = true;
};

/**
 * Starts the render loop for this scene
 */
SceneJS.Scene.prototype.start = function (params) {
    this._engine.start(params);
};

/**
 * Set refresh rate for the scene
 */
SceneJS.Scene.prototype.setFPS = function (fps) {
    this._engine.fps = fps;
};

/**
 * Pauses/unpauses current render loop that was started with {@link #start}. After this, {@link #isRunning} will return false.
 * @param {Boolean} doPause Indicates whether to pause or unpause the render loop
 */
SceneJS.Scene.prototype.pause = function (doPause) {
    this._engine.pause(doPause);
};

/**
 * Returns true if the scene's render loop is currently running.
 * @returns {Boolean} True when scene render loop is running
 */
SceneJS.Scene.prototype.isRunning = function () {
    return this._engine.running;
};

/**
 * Picks whatever geometry will be rendered at the given canvas coordinates.
 */
SceneJS.Scene.prototype.pick = function (canvasX, canvasY, options) {
    var result = this._engine.pick(canvasX, canvasY, options);
    this.renderFrame({force: true }); // HACK: canvas blanks after picking
    if (result) {
        this.publish("pick", result);
        return result;
    } else {
        this.publish("nopick");
    }
};


/**
 * Reads colors of pixels from the last rendered frame.
 *
 * <p>Call this method like this:</p>
 *
 * <pre>
 *
 * // Ignore transparent pixels (default is false)
 * var opaqueOnly = true;
 *
 * #readPixels([
 *      { x: 100, y: 22,  r: 0, g: 0, b: 0 },
 *      { x: 120, y: 82,  r: 0, g: 0, b: 0 },
 *      { x: 12,  y: 345, r: 0, g: 0, b: 0 }
 * ], 3, opaqueOnly);
 * </pre>
 *
 * Then the r,g,b components of the entries will be set to the colors at those pixels.
 */
SceneJS.Scene.prototype.readPixels = function (entries, size, opaqueOnly) {
    return this._engine.readPixels(entries, size, opaqueOnly);
};

/**
 * Scene node's destroy handler, called by {@link SceneJS_node#destroy}
 * @private
 */
SceneJS.Scene.prototype._destroy = function () {
    if (!this.destroyed) {
        delete SceneJS._engines[this.id];  // HACK: circular dependency
        SceneJS._engineIds.removeItem(this.id); // HACK: circular dependency
        this.destroyed = true;
    }
};

/**
 * Returns true if scene active, ie. not destroyed. A destroyed scene becomes active again
 * when you render it.
 */
SceneJS.Scene.prototype.isActive = function () {
    return !this._engine.destroyed;
};

/**
 * Stops current render loop that was started with {@link #start}. After this, {@link #isRunning} will return false.
 */
SceneJS.Scene.prototype.stop = function () {
    this._engine.stop();
};

/** Determines if node exists in this scene
 * @deprecated
 */
SceneJS.Scene.prototype.containsNode = function (nodeId) {
    return !!this._engine.findNode(nodeId);
};

/**
 * Finds nodes in this scene that have nodes IDs matching the given regular expression
 *
 * @param {String} nodeIdRegex Regular expression to match on node IDs
 * @return {[SceneJS.Node]} Array of nodes whose IDs match the given regex
 */
SceneJS.Scene.prototype.findNodes = function (nodeIdRegex) {
    return this._engine.findNodes(nodeIdRegex);
};

/**
 * Finds the node with the given ID in this scene
 * @deprecated
 * @param {String} nodeId Node ID
 * @param {Function} callback Callback through which we'll get the node asynchronously if it's being instantiated on-demand from a node type plugin
 * @return {SceneJS.Node} The node if found, else null
 */
SceneJS.Scene.prototype.findNode = function (nodeId, callback) {
    return this.getNode(nodeId, callback);
};

/**
 * @function Finds the node with the given ID in this scene
 * @param {String} nodeId Node ID
 * @param {Function} callback Callback through which we'll get the node asynchronously if it's being instantiated on-demand from a node type plugin
 * @return {SceneJS.Node} The node if found, else null
 */
SceneJS.Scene.prototype.getNode = function (nodeId, callback) {
    var node = this._engine.findNode(nodeId);
    if (node) {
        if (callback) {
            callback(node);
        }
        return node;
    } else {
        if (!callback) {
            return null;
        }
        // Subscribe to instantiation of node from plugin
        this.once("nodes/" + nodeId, callback);
    }
};

/**
 * Tests whether a node core of the given ID exists for the given node type
 * @param {String} type Node type
 * @param {String} coreId
 * @returns Boolean
 */
SceneJS.Scene.prototype.hasCore = function (type, coreId) {
    return this._engine.hasCore(type, coreId);
};

/**
 * Enable or disable depth sorting
 */
SceneJS.Scene.prototype.setDepthSort = function (enabled) {
    this._engine.setDepthSort(enabled);
};

/**
 * Returns the current status of this scene.
 *
 * When the scene has been destroyed, the returned status will be a map like this:
 *
 * {
 *      destroyed: true
 * }
 *
 * Otherwise, the status will be:
 *
 * {
 *      numTasks: Total number of asset loads (eg. texture, geometry stream etc.) currently in progress for this scene
 * }
 *
 */
SceneJS.Scene.prototype.getStatus = function () {
    var sceneStatus = SceneJS_sceneStatusModule.sceneStatus[this.id];
    if (!sceneStatus) {
        return {
            destroyed: true
        };
    }
    return SceneJS._shallowClone(sceneStatus);
};
;new (function() {

    /**
     * The default state core singleton for {@link SceneJS.Shader} nodes
     */
    var defaultCore = {
        type: "shader",
        stateId: SceneJS._baseStateId++,
        hash: "",
        empty: true,
        shader : {}
    };

    var idStack = [];
    var shaderVertexCodeStack = [];
    var shaderVertexHooksStack = [];
    var shaderFragmentCodeStack = [];
    var shaderFragmentHooksStack = [];
    var shaderParamsStack = [];

    var stackLen = 0;

    var dirty = true;

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING,
            function(params) {

                params.engine.display.shader = defaultCore;

                stackLen = 0;

                dirty = true;
            });

    SceneJS_events.addListener(
            SceneJS_events.OBJECT_COMPILING,
            function(params) {
                if (dirty) {

                    if (stackLen > 0) {

                        var core = {
                            type: "shader",
                            stateId: idStack[stackLen - 1],
                            hash: idStack.slice(0, stackLen).join("."),

                            shaders: {
                                fragment: {
                                    code: shaderFragmentCodeStack.slice(0, stackLen).join(""),
                                    hooks: combineMapStack(shaderFragmentHooksStack)
                                },
                                vertex: {
                                    code: shaderVertexCodeStack.slice(0, stackLen).join(""),
                                    hooks: combineMapStack(shaderVertexHooksStack)
                                }
                            },

                            paramsStack: shaderParamsStack.slice(0, stackLen)
                        };

                        params.display.shader = core;

                    } else {

                        params.display.shader = defaultCore;
                    }

                    dirty = false;
                }
            });

    function combineMapStack(maps) {
        var map1;
        var map2 = {};
        var name;
        for (var i = 0; i < stackLen; i++) {
            map1 = maps[i];
            for (name in map1) {
                if (map1.hasOwnProperty(name)) {
                    map2[name] = map1[name];
                }
            }
        }
        return map2;
    }

    function pushHooks(hooks, hookStacks) {
        var stack;
        for (var key in hooks) {
            if (hooks.hasOwnProperty(key)) {
                stack = hookStacks[key];
                if (!stack) {
                    stack = hookStacks[key] = [];
                }
                stack.push(hooks[key]);
            }
        }
    }

    SceneJS.Shader = SceneJS_NodeFactory.createNodeType("shader");

    SceneJS.Shader.prototype._init = function(params) {
        if (this._core.useCount == 1) { // This node is the resource definer
            this._setShaders(params.shaders);
            this.setParams(params.params);
        }
    };

    SceneJS.Shader.prototype._setShaders = function(shaders) {
        shaders = shaders || [];
        this._core.shaders = {};
        var shader;

        for (var i = 0, len = shaders.length; i < len; i++) {
            shader = shaders[i];

            if (!shader.stage) {
                throw SceneJS_error.fatalError(
                        SceneJS.errors.ILLEGAL_NODE_CONFIG,
                        "shader 'stage' attribute expected");
            }

            var code;
            if (shader.code) {
                if (SceneJS._isArray(shader.code)) {
                    code = shader.code.join("");
                } else {
                    code = shader.code;
                }
            }

            this._core.shaders[shader.stage] = {
                code: code,
                hooks: shader.hooks
            };
        }
    };

    SceneJS.Shader.prototype.setParams = function(params) {
        params = params || {};
        var coreParams = this._core.params;
        if (!coreParams) {
            coreParams = this._core.params = {};
        }
        for (var name in params) {
            if (params.hasOwnProperty(name)) {
                coreParams[name] = params[name];
            }
        }
        this._engine.display.imageDirty = true;
    };

    SceneJS.Shader.prototype.getParams = function() {
        var coreParams = this._core.params;
        if (!coreParams) {
            return {};
        }
        var params = {};
        for (var name in coreParams) {
            if (coreParams.hasOwnProperty(name)) {
                params[name] = coreParams[name];
            }
        }
        return params;
    };

    SceneJS.Shader.prototype._compile = function(ctx) {

        idStack[stackLen] = this._core.coreId; // Draw list node tied to core, not node

        var shaders = this._core.shaders;

        var fragment = shaders.fragment || {};
        var vertex = shaders.vertex || {};

        shaderFragmentCodeStack[stackLen] = fragment.code || "";
        shaderFragmentHooksStack[stackLen] = fragment.hooks || {};

        shaderVertexCodeStack[stackLen] = vertex.code || "";
        shaderVertexHooksStack[stackLen] = vertex.hooks || {};

        shaderParamsStack[stackLen] = this._core.params || {};

        stackLen++;
        dirty = true;

        this._compileNodes(ctx);

        stackLen--;
        dirty = true;
    };

})();;new (function() {

    /**
     * The default state core singleton for {@link SceneJS.ShaderParams} nodes
     */
    var defaultCore = {
        type: "shaderParams",
        stateId: SceneJS._baseStateId++,
        empty: true
    };

    var idStack = [];
    var shaderParamsStack = [];
    var stackLen = 0;
    var dirty;

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING,
            function(params) {

                params.engine.display.shaderParams = defaultCore;

                stackLen = 0;
                dirty = true;
            });

    SceneJS_events.addListener(
            SceneJS_events.OBJECT_COMPILING,
            function(params) {
                if (dirty) {

                    if (stackLen > 0) {
                        var core = {
                            type: "shaderParams",
                            stateId: idStack[stackLen - 1],
                            paramsStack: shaderParamsStack.slice(0, stackLen)
                        };
                        params.display.shaderParams = core;

                    } else {
                        params.display.shaderParams = defaultCore;
                    }

                    dirty = false;
                }
            });

    SceneJS.ShaderParams = SceneJS_NodeFactory.createNodeType("shaderParams");

    SceneJS.ShaderParams.prototype._init = function(params) {
        if (this._core.useCount == 1) { // This node is the resource definer
            this.setParams(params.params);
        }
    };

    SceneJS.ShaderParams.prototype.setParams = function(params) {
        params = params || {};
        var core = this._core;
        if (!core.params) {
            core.params = {};
        }
        for (var name in params) {
            if (params.hasOwnProperty(name)) {
                core.params[name] = params[name];
            }
        }
        this._engine.display.imageDirty = true;
    };

    SceneJS.ShaderParams.prototype.getParams = function() {
        var coreParams = this._core.params;
        if (!coreParams) {
            return {};
        }
        var params = {};
        for (var name in coreParams) {
            if (coreParams.hasOwnProperty(name)) {
                params[name] = coreParams[name];
            }
        }
        return params;
    };

    SceneJS.ShaderParams.prototype._compile = function(ctx) {

        idStack[stackLen] = this._core.coreId; // Tie draw list state to core, not to scene node
        shaderParamsStack[stackLen] = this._core.params;
        stackLen++;
        dirty = true;

        this._compileNodes(ctx);

        stackLen--;
        dirty = true;
    };

})();;(function () {

    // The default state core singleton for {@link SceneJS.Line} nodes
    var defaultCore = {
        type:"style",
        stateId:SceneJS._baseStateId++,
        lineWidth:1.0
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.style = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures style parameters such as line width for subnodes
     * @extends SceneJS.Node
     */
    SceneJS.Style = SceneJS_NodeFactory.createNodeType("style");

    SceneJS.Style.prototype._init = function (params) {
        if (params.lineWidth != undefined) {
            this.setLineWidth(params.lineWidth);
        }
    };

    /**
     * Sets the line width
     *
     * Line width is initially 1.
     *
     * @param lineWidth The line width
     * @return {*}
     */
    SceneJS.Style.prototype.setLineWidth = function (lineWidth) {
        if (this._core.lineWidth != lineWidth) {
            this._core.lineWidth = lineWidth;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Gets the line width
     * Initial value will be 1.
     *
     * @return Boolean
     */
    SceneJS.Style.prototype.getLineWidth = function () {
        return this._core.lineWidth;
    };

    SceneJS.Style.prototype._compile = function (ctx) {
        this._engine.display.style = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.style = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();;(function() {

    /**
     * The default state core singleton for {@link SceneJS.Tag} nodes
     */
    var defaultCore = {
        type: "tag",
        stateId: SceneJS._baseStateId++,
        tag : null
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING,
            function(params) {
                params.engine.display.tag = defaultCore;
                stackLen = 0;
            });

    /**
     * @class Scene graph node which assigns a symbolic tag name to the {@link SceneJS.Geometry} nodes in its subgraph.
     * The subgraph can then be included or excluded from scene rendering using {@link SceneJS.Scene#setTagMask}.
     * @extends SceneJS.Node
     */
    SceneJS.Tag = SceneJS_NodeFactory.createNodeType("tag");

    SceneJS.Tag.prototype._init = function(params) {
        if (this._core.useCount == 1) { // This node defines the resource
            if (!params.tag) {
                throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "tag node attribute missing : 'tag'");
            }
            this.setTag(params.tag);
        }
    };

    SceneJS.Tag.prototype.setTag = function(tag) {

        var core = this._core;

        core.tag = tag;
        core.pattern = null;    // To be recomputed
        core.matched = false;   // To be rematched

        this._engine.display.drawListDirty = true;
    };

    SceneJS.Tag.prototype.getTag = function() {
        return this._core.tag;
    };

    SceneJS.Tag.prototype._compile = function(ctx) {
        this._engine.display.tag = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.tag = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };
})();;/**
 * @class Scene graph node which defines textures to apply to the objects in its subgraph
 * <p>This is the deprecated node type from SceneJS v3.2, which has been replaced by the "texture" node in ./texture.js</p>
 * @extends SceneJS.Node
 */
new (function () {

    // The default state core singleton for {@link SceneJS.Texture} nodes
    var defaultCore = {
        type: "texture",
        stateId: SceneJS._baseStateId++,
        empty: true,
        hash: ""
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.texture = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines one or more textures to apply to the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Texture = SceneJS_NodeFactory.createNodeType("_texture");

    SceneJS.Texture.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node is the resource definer

            this._core.layers = [];
            this._core.params = {};

            // By default, wait for texture to load before building subgraph
            var waitForLoad = params.waitForLoad == undefined ? true : params.waitForLoad;

            if (!params.layers) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.NODE_CONFIG_EXPECTED,
                    "texture layers missing");
            }

            if (!SceneJS._isArray(params.layers)) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.NODE_CONFIG_EXPECTED,
                    "texture layers should be an array");
            }

            var layerParams;
            var gl = this._engine.canvas.gl;

            for (var i = 0; i < params.layers.length; i++) {

                layerParams = params.layers[i];

                if (!layerParams.source && !layerParams.uri && !layerParams.src && !layerParams.colorTarget && !layerParams.video) {

                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture layer " + i + "  has no uri, src, source, colorTarget, video or canvasId specified");
                }

                if (layerParams.applyFrom) {
                    if (layerParams.applyFrom != "uv" &&
                        layerParams.applyFrom != "uv2" &&
                        layerParams.applyFrom != "normal" &&
                        layerParams.applyFrom != "geometry") {
                        throw SceneJS_error.fatalError(
                            SceneJS.errors.NODE_CONFIG_EXPECTED,
                            "texture layer " + i + "  applyFrom value is unsupported - " +
                            "should be either 'uv', 'uv2', 'normal' or 'geometry'");
                    }
                }

                if (layerParams.applyTo) {
                    if (layerParams.applyTo != "baseColor" && // Colour map (deprecated)
                        layerParams.applyTo != "color" && // Colour map
                        layerParams.applyTo != "specular" && // Specular map
                        layerParams.applyTo != "emit" && // Emission map
                        layerParams.applyTo != "alpha" && // Alpha map
                        layerParams.applyTo != "normals" && // Normal map
                        layerParams.applyTo != "shine") { // Shininess map
                        throw SceneJS_error.fatalError(
                            SceneJS.errors.NODE_CONFIG_EXPECTED,
                            "texture layer " + i + " applyTo value is unsupported - " +
                            "should be either 'color', 'baseColor', 'specular' or 'normals'");
                    }
                }

                if (layerParams.blendMode) {
                    if (layerParams.blendMode != "add" && layerParams.blendMode != "multiply" && layerParams.blendMode != "mix") {
                        throw SceneJS_error.fatalError(
                            SceneJS.errors.NODE_CONFIG_EXPECTED,
                            "texture layer " + i + " blendMode value is unsupported - " +
                            "should be either 'add', 'multiply' or 'mix'");
                    }
                }

                if (layerParams.applyTo == "color") {
                    layerParams.applyTo = "baseColor";
                }

                var layer = SceneJS._apply(layerParams, {
                    waitForLoad: waitForLoad,
                    texture: null,
                    applyFrom: layerParams.applyFrom || "uv",
                    applyTo: layerParams.applyTo || "baseColor",
                    blendMode: layerParams.blendMode || "multiply",
                    blendFactor: (layerParams.blendFactor != undefined && layerParams.blendFactor != null) ? layerParams.blendFactor : 1.0,
                    translate: {x: 0, y: 0},
                    scale: {x: 1, y: 1},
                    rotate: {z: 0.0}
                });

                this._core.layers.push(layer);

                this._setLayerTransform(layerParams, layer);

                if (layer.colorTarget) { // Create from a colorTarget node preceeding this texture in the scene graph
                    var targetNode = this._engine.findNode(layer.colorTarget);
                    if (targetNode && targetNode.type == "colorTarget") {
                        layer.texture = targetNode._core.colorTarget.getTexture(); // TODO: what happens when the colorTarget is destroyed?
                    }
                } else { // Create from texture node's layer configs
                    this._loadLayerTexture(gl, layer);
                }

                if (layer.image && layer.applyTo == "baseColor" && !this._imagePublished) {
                    this.publish("image", layer.image);
                    this._imagePublished = true;
                }

                this._engine.stats.memory.textures++;
            }

            var self = this;

            // WebGL restored handler - rebuilds the texture layers
            this._core.webglRestored = function () {

                var layers = self._core.layers;
                var gl = self._engine.canvas.gl;

                for (var i = 0, len = layers.length; i < len; i++) {
                    self._loadLayerTexture(gl, layers[i]);
                }
            };
        }
    };

    SceneJS.Texture.prototype._loadLayerTexture = function (gl, layer) {

        var self = this;

        var sourceConfigs = layer.source;

        if (sourceConfigs) {

            if (!sourceConfigs.type) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "texture layer config expected: source.type");
            }

            SceneJS.Plugins.getPlugin(
                "texture",
                sourceConfigs.type,
                function (plugin) {

                    if (!plugin.getSource) {
                        throw SceneJS_error.fatalError(
                            SceneJS.errors.PLUGIN_INVALID,
                            "texture: 'getSource' method missing on plugin for texture source type '" + sourceConfigs.type + "'.");
                    }

                    var source = plugin.getSource({gl: gl});

                    if (!source.subscribe) {
                        throw SceneJS_error.fatalError(
                            SceneJS.errors.PLUGIN_INVALID,
                            "texture: 'subscribe' method missing on plugin for texture source type '" + sourceConfigs.type + "'");
                    }

                    var taskId = SceneJS_sceneStatusModule.taskStarted(self, "Loading texture");

                    source.subscribe(// Get notification whenever source updates the texture
                        (function () {
                            var loaded = false;
                            return function (texture) {
                                if (!loaded) { // Texture first initialised - create layer
                                    loaded = true;
                                    self._setLayerTexture(gl, layer, texture);
                                    SceneJS_sceneStatusModule.taskFinished(taskId);
                                } else { // Texture updated - layer already has the handle to it, so just signal a redraw
                                    self._engine.display.imageDirty = true;
                                }
                            };
                        })());

                    if (source.configure) {
                        source.configure(sourceConfigs); // Configure the source, which may cause it to update the texture
                    }

                    layer._source = source;
                });

        } else {

            /* Load from URL
             */

            var src = layer.uri || layer.src;
            var preloadSrc = layer.preloadURI || layer.preloadSrc;
            var preloadColor = layer.preloadColor || {r: 0.57735, g: 0.57735, b: 0.57735};
            preloadColor.a = preloadColor.a === undefined ? 1 : preloadColor.a;

            preloadColor = new Uint8Array([
                Math.floor(preloadColor.r * 255),
                Math.floor(preloadColor.g * 255),
                Math.floor(preloadColor.b * 255),
                Math.floor(preloadColor.a * 255)
            ]);

            var taskId = SceneJS_sceneStatusModule.taskStarted(this, "Loading texture");

            var texture = gl.createTexture();

            var loaded = false;
            var taskFinished = false;

            gl.bindTexture(gl.TEXTURE_2D, texture);

            if (layer.image) {
                self._setTextureImage(gl, texture, layer.image);
                self._setLayerTexture(gl, layer, texture);
                SceneJS_sceneStatusModule.taskFinished(taskId);
                return;
            }

            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, preloadColor);
            self._setLayerTexture(gl, layer, texture);

            if (preloadSrc) {
                var preloadImage = new Image();

                preloadImage.onload = function () {
                    if (!loaded) {
                        self._setTextureImage(gl, texture, preloadImage);
                        self._setLayerTexture(gl, layer, texture);
                        SceneJS_sceneStatusModule.taskFinished(taskId);
                        taskFinished = true;
                    }
                };

                self._fetchImage(preloadImage, preloadSrc);
            }

            var image = new Image();

            image.onload = function () {
                self._setTextureImage(gl, texture, image);
                self._setLayerTexture(gl, layer, texture);
                if (!taskFinished) {
                    SceneJS_sceneStatusModule.taskFinished(taskId);
                }
                layer.image = image;
                loaded = true;

                self.publish("image", image);
            };

            image.onerror = function () {
                SceneJS_sceneStatusModule.taskFailed(taskId);
            };

            self._fetchImage(image, src);
        }
    };

    SceneJS.Texture.prototype._fetchImage = function (image, src) {
        if (src.indexOf("data") == 0) {  // Image data
            image.src = src;
        } else { // Image file
            image.crossOrigin = "Anonymous";
            image.src = src;
        }
    };

    SceneJS.Texture.prototype._setTextureImage = function (gl, texture, image) {
        gl.bindTexture(gl.TEXTURE_2D, texture);

        var maxTextureSize = SceneJS_configsModule.configs.maxTextureSize;
        if (maxTextureSize) {
            image = SceneJS._webgl.clampImageSize(image, maxTextureSize);
        }

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this._ensureImageSizePowerOfTwo(image));
        this._engine.display.imageDirty = true;
        return image;
    };

    SceneJS.Texture.prototype._ensureImageSizePowerOfTwo = function (image) {

        if (!this._isPowerOfTwo(image.width) || !this._isPowerOfTwo(image.height)) {

            var canvas = document.createElement("canvas");
            canvas.width = this._nextHighestPowerOfTwo(image.width);
            canvas.height = this._nextHighestPowerOfTwo(image.height);

            var ctx = canvas.getContext("2d");

            ctx.drawImage(image,
                0, 0, image.width, image.height,
                0, 0, canvas.width, canvas.height);

            image = canvas;
            image.crossOrigin = "";
        }
        return image;
    };

    SceneJS.Texture.prototype._isPowerOfTwo = function (x) {
        return (x & (x - 1)) == 0;
    };

    SceneJS.Texture.prototype._nextHighestPowerOfTwo = function (x) {
        --x;
        for (var i = 1; i < 32; i <<= 1) {
            x = x | x >> i;
        }
        return x + 1;
    };

    SceneJS.Texture.prototype._setLayerTexture = function (gl, layer, texture) {

        layer.texture = new SceneJS._webgl.Texture2D(gl, {
            texture: texture, // WebGL texture object
            minFilter: this._getGLOption("minFilter", gl, layer, gl.LINEAR_MIPMAP_NEAREST),
            magFilter: this._getGLOption("magFilter", gl, layer, gl.LINEAR),
            wrapS: this._getGLOption("wrapS", gl, layer, gl.REPEAT),
            wrapT: this._getGLOption("wrapT", gl, layer, gl.REPEAT),
            update: null
        });

        if (this.destroyed) { // Node was destroyed while loading
            layer.texture.destroy();
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.Texture.prototype._getGLOption = function (name, gl, layer, defaultVal) {
        var value = layer[name];
        if (value == undefined) {
            return defaultVal;
        }
        var glName = SceneJS._webgl.enumMap[value];
        if (glName == undefined) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Unrecognised value for texture node property '" + name + "' value: '" + value + "'");
        }
        var glValue = gl[glName];
        //                if (!glValue) {
        //                    throw new SceneJS.errors.WebGLUnsupportedNodeConfigException(
        //                            "This browser's WebGL does not support value of SceneJS.texture node property '" + name + "' value: '" + value + "'");
        //                }
        return glValue;
    };

    SceneJS.Texture.prototype._getOption = function (value, defaultVal) {
        return (value == undefined) ? defaultVal : value;
    };

    /**
     * Set some writeable properties on a layer
     */
    SceneJS.Texture.prototype.setLayer = function (cfg) {

        if (cfg.index == undefined || cfg.index == null) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Invalid texture set layer argument: index null or undefined");
        }

        if (cfg.index < 0 || cfg.index >= this._core.layers.length) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Invalid texture set layer argument: index out of range (" + this._core.layers.length + " layers defined)");
        }

        this._setLayer(parseInt(cfg.index), cfg);

        this._engine.display.imageDirty = true;
    };

    /**
     * Set some writeable properties on multiple layers
     */
    SceneJS.Texture.prototype.setLayers = function (layers) {
        var indexNum;
        for (var index in layers) {
            if (layers.hasOwnProperty(index)) {
                if (index != undefined || index != null) {
                    indexNum = parseInt(index);
                    if (indexNum < 0 || indexNum >= this._core.layers.length) {
                        throw SceneJS_error.fatalError(
                            SceneJS.errors.ILLEGAL_NODE_CONFIG,
                            "Invalid texture set layer argument: index out of range (" + this._core.layers.length + " layers defined)");
                    }
                    this._setLayer(indexNum, layers[index] || {});
                }
            }
        }
        this._engine.display.imageDirty = true;
    };

    SceneJS.Texture.prototype._setLayer = function (index, cfg) {

        cfg = cfg || {};

        var layer = this._core.layers[index];

        if (cfg.blendFactor != undefined && cfg.blendFactor != null) {
            layer.blendFactor = cfg.blendFactor;
        }

        if (cfg.source) {
            var source = layer._source;
            if (source && source.configure) {
                source.configure(cfg.source);
            }
        }

        if (cfg.translate || cfg.rotate || cfg.scale) {
            this._setLayerTransform(cfg, layer);
        }
    };

    SceneJS.Texture.prototype._setLayerTransform = function (cfg, layer) {

        var matrix;
        var t;

        if (cfg.translate) {
            var translate = cfg.translate;
            if (translate.x != undefined) {
                layer.translate.x = translate.x;
            }
            if (translate.y != undefined) {
                layer.translate.y = translate.y;
            }
            matrix = SceneJS_math_translationMat4v([translate.x || 0, translate.y || 0, 0]);
        }

        if (cfg.scale) {
            var scale = cfg.scale;
            if (scale.x != undefined) {
                layer.scale.x = scale.x;
            }
            if (scale.y != undefined) {
                layer.scale.y = scale.y;
            }
            t = SceneJS_math_scalingMat4v([scale.x || 1, scale.y || 1, 1]);
            matrix = matrix ? SceneJS_math_mulMat4(matrix, t) : t;
        }

        if (cfg.rotate) {
            var rotate = cfg.rotate;
            if (rotate.z != undefined) {
                layer.rotate.z = rotate.z || 0;
            }
            t = SceneJS_math_rotationMat4v(rotate.z * 0.0174532925, [0, 0, 1]);
            matrix = matrix ? SceneJS_math_mulMat4(matrix, t) : t;
        }

        if (matrix) {
            layer.matrix = matrix;
            if (!layer.matrixAsArray) {
                layer.matrixAsArray = new Float32Array(layer.matrix);
            } else {
                layer.matrixAsArray.set(layer.matrix);
            }

            layer.matrixAsArray = new Float32Array(layer.matrix); // TODO - reinsert into array
        }
    };

    SceneJS.Texture.prototype._compile = function (ctx) {
        if (!this._core.hash) {
            this._makeHash();
        }
        this._engine.display.texture = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.texture = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Texture.prototype._makeHash = function () {
        var core = this._core;
        var hash;
        if (core.layers && core.layers.length > 0) {
            var layers = core.layers;
            var hashParts = [];
            var texLayer;
            for (var i = 0, len = layers.length; i < len; i++) {
                texLayer = layers[i];
                hashParts.push("/");
                hashParts.push(texLayer.applyFrom);
                hashParts.push("/");
                hashParts.push(texLayer.applyTo);
                hashParts.push("/");
                hashParts.push(texLayer.blendMode);
                if (texLayer.matrix) {
                    hashParts.push("/anim");
                }
            }
            hash = hashParts.join("");
        } else {
            hash = "";
        }
        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.Texture.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last resource user
            var layers = this._core.layers;
            var layer;
            var source;
            for (var i = 0, len = layers.length; i < len; i++) {
                layer = layers[i];
                if (layer.texture) {
                    layer.texture.destroy();
                    this._engine.stats.memory.textures++;
                }
                source = layer._source;
                if (source && source.destroy) {
                    source.destroy();
                }
            }
        }
    };

})();
;/**
 * @class Scene graph node which defines textures to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
new (function () {

    // The default state core singleton for {@link SceneJS.Texture} nodes
    var defaultCore = {
        type: "texture",
        stateId: SceneJS._baseStateId++,
        empty: true,
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.texture = defaultCore;
            stackLen = 0;
        });

    var coreStack = [];
    var stackLen = 0;

    /**
     * @class Scene graph node which defines one or more textures to apply to the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.TextureMap = SceneJS_NodeFactory.createNodeType("texture");

    SceneJS.TextureMap.prototype._init = function (params) {

        var self = this;

        if (this._core.useCount == 1) { // This node is the resource definer

            var applyFrom = params.applyFrom || "uv";
            if (applyFrom.substring(0,2) !== "uv") {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyFrom value is unsupported - should be 'uv<index>'");
            }
            var uvLayerIdx = 0;
            if (applyFrom !== "uv") {
                uvLayerIdx = applyFrom.substring(2);
                if (isNaN(uvLayerIdx)) {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyFrom value invalid - should be 'uv<index>'");
                }
            }

            if (params.applyTo) {

                var applyTo = params.applyTo;

                if (applyTo != "baseColor" && // Colour map (deprecated)
                    applyTo != "color" && // Colour map
                    applyTo != "specular" && // Specular map
                    applyTo != "emit" && // Emission map
                    applyTo != "alpha" && // Alpha map
                    applyTo != "normals" && // Normal map
                    applyTo != "shine") { // Shininess map

                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyTo value is unsupported - " +
                        "should be either 'color', 'baseColor', 'specular' or 'normals'");
                }
            }

            if (params.blendMode) {
                if (params.blendMode != "add" && params.blendMode != "multiply") {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture layer blendMode value is unsupported - " +
                        "should be either 'add' or 'multiply'");
                }
            }

            if (params.applyTo == "color") {
                params.applyTo = "baseColor";
            }

            SceneJS._apply({
                    waitForLoad: params.waitForLoad == undefined ? true : params.waitForLoad,
                    texture: null,
                    minFilter: params.minFilter,
                    magFilter: params.magFilter,
                    wrapS: params.wrapS,
                    wrapT: params.wrapT,
                    uvLayerIdx: uvLayerIdx,
                    isNormalMap: params.applyTo === "normals",
                    applyFrom: applyFrom,
                    applyTo: !!params.applyTo ? params.applyTo : "baseColor",
                    blendMode: !!params.blendMode ? params.blendMode : "multiply",
                    blendFactor: (params.blendFactor != undefined && params.blendFactor != null) ? params.blendFactor : 1.0,
                    translate: params.translate ? SceneJS._apply(params.translate, { x: 0, y: 0}) : {x: 0, y: 0},
                    scale: params.scale ? SceneJS._apply(params.scale, { x: 1, y: 1}) : {x: 1, y: 1},
                    rotate: params.rotate || 0,
                    matrix: null,
                    _matrixDirty: true,
                    buildMatrix: buildMatrix
                },
                this._core);

            buildMatrix.call(this._core);


            if (params.src) { // Load from URL
                this._initTexture(params.preloadColor);
                this._core.src = params.src;
                this._loadTexture(params.src, params.preloadSrc);

            } else if (params.image) { // Create from image
                this._initTexture(params.preloadColor);
                this._core.image = params.image;
                this._setTextureImage(params.image);

            } else if (params.target) { // Render to this texture
                this.getScene().getNode(params.target,
                    function (target) {
                        self.setTarget(target);
                    });
            }

            this._core.webglRestored = function () {

                if (self._core.image) {
                    self._initTexture(params.preloadColor);
                    self._setTextureImage(self._core.image);

                } else if (self._core.src) {
                    self._initTexture(params.preloadColor);
                    self._loadTexture(self._core.src);

                } else if (self._core.target) {
//                    self.getScene().getNode(params.target,
//                        function (target) {
//                            self.setTarget(self._core.target);
//                        });
                }
            };

            this._engine.stats.memory.textures++;
        }
    };

    function buildMatrix() {
        var matrix;
        var t;
        if (this.translate.x != 0 || this.translate.y != 0) {
            matrix = SceneJS_math_translationMat4v([ this.translate.x || 0, this.translate.y || 0, 0]);
        }
        if (this.scale.x != 1 || this.scale.y != 1) {
            t = SceneJS_math_scalingMat4v([ this.scale.x || 1, this.scale.y || 1, 1]);
            matrix = matrix ? SceneJS_math_mulMat4(matrix, t) : t;
        }
        if (this.rotate != 0) {
            t = SceneJS_math_rotationMat4v(this.rotate * 0.0174532925, [0, 0, 1]);
            matrix = matrix ? SceneJS_math_mulMat4(matrix, t) : t;
        }
        if (matrix) {
            this.matrix = matrix;
            if (!this.matrixAsArray) {
                this.matrixAsArray = new Float32Array(this.matrix);
            } else {
                this.matrixAsArray.set(this.matrix);
            }
        }
        this._matrixDirty = false;
    }

    SceneJS.TextureMap.prototype._initTexture = function (preloadColor) {
        var gl = this._engine.canvas.gl;

        preloadColor = preloadColor || { r: 0.57735, g: 0.57735, b: 0.57735 };
        preloadColor.a = preloadColor.a === undefined ? 1 : preloadColor.a;

        preloadColor = new Uint8Array([
            Math.floor(preloadColor.r * 255),
            Math.floor(preloadColor.g * 255),
            Math.floor(preloadColor.b * 255),
            Math.floor(preloadColor.a * 255)
        ]);

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, preloadColor);
        this._setCoreTexture(texture);
    };

    SceneJS.TextureMap.prototype._loadTexture = function (src, preloadSrc) {
        var self = this;
        var taskId = SceneJS_sceneStatusModule.taskStarted(this, "Loading texture");
        var image = new Image();
        var loaded = false;
        var taskFinished = false;

        if (preloadSrc) {
            var preloadImage = new Image();

            preloadImage.onload = function () {
                if (!loaded) {
                    self._setTextureImage(preloadImage);
                    SceneJS_sceneStatusModule.taskFinished(taskId);
                    taskFinished = true;
                    self._engine.display.imageDirty = true;
                }
            };

            this._fetchImage(preloadImage, preloadSrc);
        }

        image.onload = function () {
            self._setTextureImage(image);
            if (!taskFinished) {
                SceneJS_sceneStatusModule.taskFinished(taskId);
            }
            loaded = true;
            self._engine.display.imageDirty = true;
        };
        image.onerror = function () {
            SceneJS_sceneStatusModule.taskFailed(taskId);
        };
        this._fetchImage(image, src);
    };

    SceneJS.TextureMap.prototype._fetchImage = function (image, src) {
        if (src.indexOf("data") == 0) {  // Image data
            image.src = src;
        } else { // Image file
            image.crossOrigin = "Anonymous";
            image.src = src;
        }
    };

    SceneJS.TextureMap.prototype._setTextureImage = function (image) {

        var gl = this._engine.canvas.gl;
        var core = this._core;
        var texture = core.texture && core.texture.texture ? core.texture.texture : gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture);

        var maxTextureSize = SceneJS_configsModule.configs.maxTextureSize;
        if (maxTextureSize) {
            image = SceneJS._webgl.clampImageSize(image, maxTextureSize);
        }

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, SceneJS._webgl.ensureImageSizePowerOfTwo(image));

        core.image = image;

        this._setCoreTexture(texture);
    };

    SceneJS.TextureMap.prototype._setCoreTexture = function (texture) {
        var gl = this._engine.canvas.gl;

        this._core.texture = new SceneJS._webgl.Texture2D(gl, {
            texture: texture, // WebGL texture object
            minFilter: this._getGLOption("minFilter", gl.LINEAR_MIPMAP_NEAREST),
            magFilter: this._getGLOption("magFilter", gl.LINEAR),
            wrapS: this._getGLOption("wrapS", gl.REPEAT),
            wrapT: this._getGLOption("wrapT", gl.REPEAT),
            update: null
        });

        if (this.destroyed) { // Node was destroyed while loading
            this._core.texture.destroy();
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype._getGLOption = function (name, defaultVal) {
        var gl = this._engine.canvas.gl;
        var value = this._core[name];
        if (value == undefined) {
            return defaultVal;
        }
        var glName = SceneJS._webgl.enumMap[value];
        if (glName == undefined) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Unrecognised value for texture node property '" + name + "' value: '" + value + "'");
        }
        return gl[glName];
    };

    SceneJS.TextureMap.prototype._getOption = function (value, defaultVal) {
        return (value == undefined) ? defaultVal : value;
    };

    SceneJS.TextureMap.prototype.setSrc = function (src) {
        this._core.image = null;
        this._core.src = src;
        this._core.target = null;
        this._loadTexture(src);
    };

    SceneJS.TextureMap.prototype.setImage = function (image) {
        this._core.image = image;
        this._core.src = null;
        this._core.target = null;
        this._setTextureImage(image);
    };

    SceneJS.TextureMap.prototype.setTarget = function (target) {
        if (target.type != "colorTarget" && target.type != "depthTarget") {
            console.log("Target node type not compatible: " + target.type);
            return;
        }
        delete this._core.src;
        this._core.target = target;
        this._core.src = null;
        this._core.image = null;
        this._core.texture = target._core.renderBuf.getTexture(); // TODO: what happens when the target is destroyed?
        this._core.texture.bufType = target._core.bufType;
        this._engine.display.imageDirty = true;
    };

    /**
     * Sets the texture's blend factor with respect to other active textures.
     * @param {number} blendFactor The blend factor, in range [0..1]
     */
    SceneJS.TextureMap.prototype.setBlendFactor = function (blendFactor) {
        this._core.blendFactor = blendFactor;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getBlendFactor = function () {
        return this._core.blendFactor;
    };

    SceneJS.TextureMap.prototype.setTranslate = function (t) {
        if (!this._core.translate) {
            this._core.translate = {x: 0, y: 0};
        }
        this._core.translate.x = t.x;
        this._core.translate.y = t.y;
        this._core._matrixDirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getTranslate = function () {
        return this._core.translate;
    };

    SceneJS.TextureMap.prototype.setScale = function (s) {
        if (!this._core.scale) {
            this._core.scale = {x: 0, y: 0};
        }
        this._core.scale.x = s.x;
        this._core.scale.y = s.y;
        this._core._matrixDirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getScale = function () {
        return this._core.scale;
    };

    SceneJS.TextureMap.prototype.setRotate = function (angle) {
        this._core.rotate = angle;
        this._core._matrixDirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getRotate = function () {
        return this._core.rotate;
    };

    SceneJS.TextureMap.prototype.getMatrix = function () {
        if (this._core._matrixDirty) {
            this._core.buildMatrix.call(this.core)()
        }
        return this.core.matrix;
    };

    SceneJS.TextureMap.prototype._compile = function (ctx) {
        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("texture");
        }
        var parentCore = this._engine.display.texture;
        if (!this._core.empty) {
            this.__core.layers = (parentCore && parentCore.layers) ? parentCore.layers.concat([this._core]) : [this._core];
        }
        this._makeHash(this.__core);
        coreStack[stackLen++] = this.__core;
        this._engine.display.texture = this.__core;
        this._compileNodes(ctx);
        this._engine.display.texture = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.TextureMap.prototype._makeHash = function (core) {
        var hash;
        if (core.layers && core.layers.length > 0) {
            var layers = core.layers;
            var hashParts = [];
            var texLayer;
            for (var i = 0, len = layers.length; i < len; i++) {
                texLayer = layers[i];
                hashParts.push("/");
                hashParts.push(texLayer.applyFrom);
                hashParts.push("/");
                hashParts.push(texLayer.applyTo);
                hashParts.push("/");
                hashParts.push(texLayer.blendMode);
                if (texLayer.matrix) {
                    hashParts.push("/anim");
                }
            }
            hash = hashParts.join("");
        } else {
            hash = "";
        }
        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.TextureMap.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last core user
            if (this._core.texture && !this._core.target) { // Don't wipe out target texture
                this._core.texture.destroy();
                this._core.texture = null;
            }
            this._engine.stats.memory.textures--;
        }
        if (this._core) {
            this._engine._coreFactory.putCore(this._core);
        }
    };

})();
;/**
 * @class Scene graph node which defines fresnels to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
new (function () {

    // The default state core singleton for {@link SceneJS.Fresnel} nodes
    var defaultCore = {
        type: "fresnel",
        stateId: SceneJS._baseStateId++,
        centerBias: 1.0,
        edgeBias: 0.0,
        power: 1.0,
        centerColor:[ 1.0, 1.0, 1.0 ],
        edgeColor:[ 0.0, 0.0, 0.0 ],
        empty: true,
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.fresnel = defaultCore;
            stackLen = 0;
        });

    var coreStack = [];
    var stackLen = 0;

    /**
     * @class Scene graph node which defines a fresnel to apply to the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Fresnel = SceneJS_NodeFactory.createNodeType("fresnel");

    SceneJS.Fresnel.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node is the resource definer

            if (params.applyTo) {
                if (params.applyTo != "color" &&
                    params.applyTo != "specular" &&
                    params.applyTo != "alpha" &&
                    params.applyTo != "reflect" &&
                    params.applyTo != "emit" &&
                    params.applyTo != "fragment") {

                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "fresnel applyTo value is unsupported - should be either 'color', 'specular', 'alpha', 'reflect', 'emit' or 'fragment'");
                }
            }

            this._core.applyTo = params.applyTo;

            this.setCenterBias(params.centerBias);
            this.setEdgeBias(params.edgeBias);
            this.setPower(params.power);
            this.setCenterColor(params.centerColor);
            this.setEdgeColor(params.edgeColor);
        }
    };

    SceneJS.Fresnel.prototype.getApplyTo = function () {
        return this._core.applyTo;
    };

    SceneJS.Fresnel.prototype.setCenterBias = function (centerBias) {
        this._core.centerBias = (centerBias !== undefined && centerBias !== null) ? centerBias : defaultCore.centerBias;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Fresnel.prototype.getCenterBias = function () {
        return this._core.centerBias;
    };

    SceneJS.Fresnel.prototype.setEdgeBias = function (edgeBias) {
        this._core.edgeBias = (edgeBias !== undefined && edgeBias !== null) ? edgeBias : defaultCore.edgeBias;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Fresnel.prototype.getEdgeBias = function () {
        return this._core.edgeBias;
    };

    SceneJS.Fresnel.prototype.setPower = function (power) {
        this._core.power = (power !== undefined && power !== null) ? power : defaultCore.power;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Fresnel.prototype.getPower = function () {
        return this._core.power;
    };

    SceneJS.Fresnel.prototype.setCenterColor = function (color) {
        var defaultCenterColor = defaultCore.centerColor;
        this._core.centerColor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultCenterColor[0],
            color.g != undefined && color.g != null ? color.g : defaultCenterColor[1],
            color.b != undefined && color.b != null ? color.b : defaultCenterColor[2]
        ] : defaultCore.centerColor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Fresnel.prototype.getCenterColor = function () {
        return {
            r:this._core.centerColor[0],
            g:this._core.centerColor[1],
            b:this._core.centerColor[2]
        };
    };

    SceneJS.Fresnel.prototype.setEdgeColor = function (color) {
        var defaultEdgeColor = defaultCore.edgeColor;
        this._core.edgeColor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultEdgeColor[0],
            color.g != undefined && color.g != null ? color.g : defaultEdgeColor[1],
            color.b != undefined && color.b != null ? color.b : defaultEdgeColor[2]
        ] : defaultCore.edgeColor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Fresnel.prototype.getEdgeColor = function () {
        return {
            r:this._core.edgeColor[0],
            g:this._core.edgeColor[1],
            b:this._core.edgeColor[2]
        };
    };
    
    SceneJS.Fresnel.prototype._compile = function (ctx) {

        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("fresnel");
        }

        var parentCore = this._engine.display.fresnel;

        if (!this._core.empty) {
            this.__core.diffuse = this._core.applyTo == "color" ? this._core : parentCore.diffuse;
            this.__core.specular = this._core.applyTo == "specular" ? this._core : parentCore.specular;
            this.__core.alpha = this._core.applyTo == "alpha" ? this._core : parentCore.alpha;
            this.__core.reflect = this._core.applyTo == "reflect" ? this._core : parentCore.reflect;
            this.__core.emit = this._core.applyTo == "emit" ? this._core : parentCore.emit;
            this.__core.fragment = this._core.applyTo == "fragment" ? this._core : parentCore.fragment;
        }

        this._makeHash(this.__core);

        coreStack[stackLen++] = this.__core;

        this._engine.display.fresnel = this.__core;
        this._compileNodes(ctx);
        this._engine.display.fresnel = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Fresnel.prototype._makeHash = function (core) {
        var hash = [];
        if (core.diffuse) {
            hash.push("d;")
        }
        if (core.specular) {
            hash.push("s;")
        }
        if (core.alpha) {
            hash.push("a;")
        }
        if (core.reflect) {
            hash.push("r;")
        }
        if (core.emit) {
            hash.push("e;")
        }
        if (core.fragment) {
            hash.push("f;")
        }
        hash = hash.join("");
        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.Fresnel.prototype._destroy = function () {
        if (this._core) {
            this._engine._coreFactory.putCore(this._core);
        }
    };

})();;(function () {

    // The default state core singleton for {@link SceneJS.ColorBuf} nodes
    var defaultCore = {
        type: "cubemap",
        stateId: SceneJS._baseStateId++,
        empty: true,
        texture: null,
        hash: ""
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.cubemap = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures the color buffer for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Reflect = SceneJS_NodeFactory.createNodeType("reflect");

    SceneJS.Reflect.prototype._init = function (params) {
        if (this._core.useCount == 1) { // This node is first to reference the state core, so sets it up
            this._core.hash = "y";

            if (params.blendMode) {
                if (params.blendMode != "add" && params.blendMode != "multiply") {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                            "reflection blendMode value is unsupported - " +
                            "should be either 'add' or 'multiply'");
                }
            }

            this._core.blendMode = params.blendMode || "multiply";
            this._core.intensity = (params.intensity != undefined && params.intensity != null) ? params.intensity : 1.0;
            this._core.applyTo = "reflect";

            var self = this;

            var gl = this._engine.canvas.gl;
            var texture = gl.createTexture();

            var faces = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
            ];

            var images = [];
            var taskId = SceneJS_sceneStatusModule.taskStarted(this, "Loading reflection texture");
            var loadFailed = false;

            for (var i = 0; i < faces.length; i++) {

                var image = new Image();

                image.onload = (function() {

                    var _image = image;

                    return function () {

                        if (loadFailed) {
                            return;
                        }

                        images.push(_image);

                        if (images.length == faces.length) {

                            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

                            for (var j = 0, lenj = images.length; j < lenj; j++) {
                                gl.texImage2D(faces[j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
                                    SceneJS._webgl.ensureImageSizePowerOfTwo(images[j]));
                            }

                            self._core.texture = new SceneJS._webgl.Texture2D(gl, {
                                texture: texture,
                                target: gl.TEXTURE_CUBE_MAP,
                                minFilter: gl.LINEAR,
                                magFilter: gl.LINEAR,
                                wrapS: gl.CLAMP_TO_EDGE,
                                wrapT: gl.CLAMP_TO_EDGE
                            });

                            SceneJS_sceneStatusModule.taskFinished(taskId);

                            self._engine.display.imageDirty = true;
                        }
                    };
                })();

                image.onerror = function () {
                    loadFailed = true;
                    SceneJS_sceneStatusModule.taskFailed(taskId);
                };

                image.src = params.src[i];
            }
        }
    };

    SceneJS.Reflect.prototype._compile = function (ctx) {
        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("cubemap");
        }
        var parentCore = this._engine.display.cubemap;
        if (!this._core.empty) {
            this.__core.layers = (parentCore && parentCore.layers) ? parentCore.layers.concat([this._core]) : [this._core];
        }
        this._makeHash(this.__core);
        coreStack[stackLen++] = this.__core;
        this._engine.display.cubemap = this.__core;
        this._compileNodes(ctx);
        this._engine.display.cubemap = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Reflect.prototype._makeHash = function (core) {
        var hash;
        if (core.layers && core.layers.length > 0) {
            var layers = core.layers;
            var hashParts = [];
            var texLayer;
            for (var i = 0, len = layers.length; i < len; i++) {
                texLayer = layers[i];
                hashParts.push("/");
                hashParts.push(texLayer.applyTo);
                hashParts.push("/");
                hashParts.push(texLayer.blendMode);
            }
            hash = hashParts.join("");
        } else {
            hash = "";
        }
        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.Reflect.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last resource user
            if (this._core.texture) {
                this._core.texture.destroy();
                this._core.texture = null;
            }
        }
        if (this._core) {
            this._engine._coreFactory.putCore(this._core);
        }
    }

})();;/**
 * @class Scene graph node which defines textures to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
new (function () {

    // The default state core singleton for {@link SceneJS.RegionMap} nodes
    var defaultCore = {
        type: "regionMap",
        stateId: SceneJS._baseStateId++,
        empty: true,
        texture: null,
        regionColor:[ -1.0, -1.0, -1.0 ],    // Highlight off by default
        highlightFactor:[ 1.5, 1.5, 0.0 ],
        hideAlpha: 0.0,
        regionData: [],
        mode: "info",
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.regionMap = defaultCore;
            stackLen = 0;
        });

    var stackLen = 0;
    var validModes = {
        info: true,
        highlight: true,
        hide: true,
        isolate: true
    };

    /**
     * @class Scene graph node which defines a color-coded region map
     * @extends SceneJS.Node
     */
    SceneJS.RegionMap = SceneJS_NodeFactory.createNodeType("regionMap");

    SceneJS.RegionMap.prototype._init = function (params) {

        var self = this;

        if (this._core.useCount == 1) { // This node is the resource definer

            SceneJS._apply({
                    regionMap: null
                },
                this._core);

            // Index of UV layer for this region map

            var applyFrom = params.applyFrom || "uv";
            if (applyFrom.substring(0,2) !== "uv") {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.NODE_CONFIG_EXPECTED,
                    "texture applyFrom value is unsupported - should be 'uv<index>'");
            }
            var uvLayerIdx = 0;
            if (applyFrom !== "uv") {
                uvLayerIdx = applyFrom.substring(2);
                if (isNaN(uvLayerIdx)) {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyFrom value invalid - should be 'uv<index>'");
                }
            }
            this._core.uvLayerIdx = uvLayerIdx;

            if (params.src) {

                // Load from URL

                this._initTexture();
                this._core.src = params.src;
                this._loadTexture(params.src);

            } else if (params.image) {

                // Create from image

                this._initTexture(params.preloadColor);
                this._core.image = params.image;
                this._setTextureImage(params.image);

            } else if (params.target) {

                // Render to this region map

                this.getScene().getNode(params.target,
                    function (target) {
                        self.setTarget(target);
                    });
            }

            this._core.webglRestored = function () {

                if (self._core.image) {
                    self._initTexture();
                    self._setTextureImage(self._core.image);

                } else if (self._core.src) {
                    self._initTexture();
                    self._loadTexture(self._core.src);

                } else if (self._core.target) {
                    // Don't need to rebind anything for targets
                }
            };

            this.setRegionColor(params.regionColor);
            this.setHighlightFactor(params.highlightFactor);
            this.setHideAlpha(params.hideAlpha);
            this.setRegionData(params.regionData);
            this.setMode(params.mode);
        }
    };

    SceneJS.RegionMap.prototype._initTexture = function () {

        var gl = this._engine.canvas.gl;

        // Keep this for a little bit for debugging
        var preloadColor = {r: 0.57735, g: 0.57735, b: 0.57735};
        preloadColor.a = preloadColor.a === undefined ? 1 : preloadColor.a;
        preloadColor = new Uint8Array([
            Math.floor(preloadColor.r * 255),
            Math.floor(preloadColor.g * 255),
            Math.floor(preloadColor.b * 255),
            Math.floor(preloadColor.a * 255)
        ]);

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, preloadColor);
        this._setCoreTexture(texture);
    };

    SceneJS.RegionMap.prototype._loadTexture = function (src) {
        var self = this;
        var taskId = SceneJS_sceneStatusModule.taskStarted(this, "Loading texture");
        var image = new Image();
        var loaded = false;
        var taskFinished = false;

        image.onload = function () {
            self._setTextureImage(image);
            if (!taskFinished) {
                SceneJS_sceneStatusModule.taskFinished(taskId);
            }
            loaded = true;
            self._engine.display.imageDirty = true;
        };
        image.onerror = function () {
            SceneJS_sceneStatusModule.taskFailed(taskId);
        };
        this._fetchImage(image, src);
    };

    SceneJS.RegionMap.prototype._fetchImage = function (image, src) {
        if (src.indexOf("data") == 0) {  // Image data
            image.src = src;
        } else { // Image file
            image.crossOrigin = "Anonymous";
            image.src = src;
        }
    };

    SceneJS.RegionMap.prototype._setTextureImage = function (image) {
        var gl = this._engine.canvas.gl;
        var texture = this._core.texture ? this._core.texture.texture : gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, SceneJS._webgl.ensureImageSizePowerOfTwo(image));
        this._core.image = image;
        this._setCoreTexture(texture);
    };

    SceneJS.RegionMap.prototype._setCoreTexture = function (texture) {
        var gl = this._engine.canvas.gl;

        this._core.texture = new SceneJS._webgl.Texture2D(gl, {
            texture: texture, // WebGL texture object
            minFilter: this._getGLOption("minFilter", gl.NEAREST_MIPMAP_NEAREST),  // Don't want any interpolation
            magFilter: this._getGLOption("magFilter", gl.NEAREST),
            wrapS: this._getGLOption("wrapS", gl.REPEAT),
            wrapT: this._getGLOption("wrapT", gl.REPEAT),
            isDepth: this._getOption(this._core.isDepth, false),
            depthMode: this._getGLOption("depthMode", gl.LUMINANCE),
            depthCompareMode: this._getGLOption("depthCompareMode", gl.COMPARE_R_TO_TEXTURE),
            depthCompareFunc: this._getGLOption("depthCompareFunc", gl.LEQUAL),
            flipY: this._getOption(this._core.flipY, true),
            width: this._getOption(this._core.width, 1),
            height: this._getOption(this._core.height, 1),
            internalFormat: this._getGLOption("internalFormat", gl.ALPHA),
            sourceFormat: this._getGLOption("sourceFormat", gl.ALPHA),
            sourceType: this._getGLOption("sourceType", gl.UNSIGNED_BYTE),
            update: null
        });

        if (this.destroyed) { // Node was destroyed while loading
            this._core.texture.destroy();
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.RegionMap.prototype._getGLOption = function (name, defaultVal) {
        var gl = this._engine.canvas.gl;
        var value = this._core[name];
        if (value == undefined) {
            return defaultVal;
        }
        var glName = SceneJS._webgl.enumMap[value];
        if (glName == undefined) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Unrecognised value for texture node property '" + name + "' value: '" + value + "'");
        }
        return gl[glName];
    };

    SceneJS.RegionMap.prototype._getOption = function (value, defaultVal) {
        return (value == undefined) ? defaultVal : value;
    };

    SceneJS.RegionMap.prototype.setSrc = function (src) {
        this._core.image = null;
        this._core.src = src;
        this._core.target = null;
        this._loadTexture(src);
    };

    SceneJS.RegionMap.prototype.setImage = function (image) {
        this._core.image = image;
        this._core.src = null;
        this._core.target = null;
        this._setTextureImage(image);
    };

    SceneJS.RegionMap.prototype.setTarget = function (target) {
        if (target.type != "colorTarget" && target.type != "depthTarget") {
            console.log("Target node type not compatible: " + target.type);
            return;
        }
        delete this._core.src;
        this._core.target = target;
        this._core.src = null;
        this._core.image = null;
        this._core.texture = target._core.renderBuf.getTexture(); // TODO: what happens when the target is destroyed?
        this._core.texture.bufType = target._core.bufType;
        this._engine.display.imageDirty = true;
    };

    SceneJS.RegionMap.prototype.setRegionColor = function (color) {
        var defaultHighlightColor = defaultCore.regionColor;
        this._core.regionColor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultHighlightColor[0],
            color.g != undefined && color.g != null ? color.g : defaultHighlightColor[1],
            color.b != undefined && color.b != null ? color.b : defaultHighlightColor[2]
        ] : defaultCore.regionColor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.RegionMap.prototype.setHighlightFactor = function (color) {
        var defaultHighlightFactor = defaultCore.highlightFactor;
        this._core.highlightFactor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultHighlightFactor[0],
            color.g != undefined && color.g != null ? color.g : defaultHighlightFactor[1],
            color.b != undefined && color.b != null ? color.b : defaultHighlightFactor[2]
        ] : defaultCore.highlightFactor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.RegionMap.prototype.setHideAlpha = function (hideAlpha) {
        this._core.hideAlpha = hideAlpha != undefined ? hideAlpha : defaultCore.hideAlpha;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.RegionMap.prototype.setMode = function (mode) {
        this._core.mode = mode && validModes[mode] ? mode : defaultCore.mode;
        this._engine.branchDirty(this);
        this._engine.display.imageDirty = true;
        this._core.hash = "reg-" + mode;
        return this;
    };

    SceneJS.RegionMap.prototype.setRegionData = function (data) {
        this._core.regionData = data ? data : defaultCore.regionData;
        return this;
    };


    SceneJS.RegionMap.prototype._compile = function (ctx) {
        var parentCore = this._engine.display.regionMap;
        this._engine.display.regionMap = this._core;
        this._compileNodes(ctx);
        this._engine.display.regionMap = parentCore;
    };

    SceneJS.RegionMap.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last core user
            if (this._core.texture && !this._core.target) { // Don't wipe out target texture
                this._core.texture.destroy();
                this._core.texture = null;
            }
        }
    };

})();;/**
 * @class Scene graph node which defines the modelling transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.XForm = SceneJS_NodeFactory.createNodeType("xform");

SceneJS.XForm.prototype._init = function (params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        SceneJS_modelXFormStack.buildCore(this._core);

        this.setElements(params.elements);

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.XForm.prototype.getModelMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, XForm, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.XForm.prototype.getWorldMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply( [], this._core.mat);
};


SceneJS.XForm.prototype.setElements = function (elements) {

    elements = elements || SceneJS_math_identityMat4();

    if (elements.length != 16) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.XForm elements should number 16");
    }

    var core = this._core;

    if (!core.matrix) {
        core.matrix = elements;

    } else {

        for (var i = 0; i < 16; i++) {
            core.matrix[i] = elements[i];
        }
    }

//    core.mat.set(core.matrix);
//    core.normalMat.set(
//        SceneJS_math_transposeMat4(
//            SceneJS_math_inverseMat4(core.matrix, SceneJS_math_mat4())));


    core.setDirty();

    this._engine.display.imageDirty = true;

    return this;
};

SceneJS.XForm.prototype._compile = function (ctx) {
    var core = this._core;
    var i, len;

    core.numCores = 0;
    for (i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.XForm.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.XForm.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;
/**
 * @class Scene graph node which defines a modelling transform matrix to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.Matrix = SceneJS_NodeFactory.createNodeType("matrix");

SceneJS.Matrix.prototype._init = function(params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        SceneJS_modelXFormStack.buildCore(this._core);

        this.setElements(params.elements);

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.Matrix.prototype.getModelMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, matrix, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.Matrix.prototype.getWorldMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply( [], this._core.mat);
};

/**
 * Sets the matrix elements
 * @type {Function}
 */
SceneJS.Matrix.prototype.setMatrix = function(elements) {

    elements = elements || SceneJS_math_identityMat4();

    if (elements.length != 16) {
        throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "SceneJS.Matrix elements should number 16");
    }

    var core = this._core;

    if (!core.matrix) {
        core.matrix = elements;

    } else {

        for (var i = 0; i < 16; i++) {
            core.matrix[i] = elements[i];
        }
    }

    core.setDirty();

    this._engine.display.imageDirty = true;

    return this;
};

/**
 * Sets the matrix elements
 * @deprecated
 * @type {Function}
 */
SceneJS.Matrix.prototype.setElements = SceneJS.Matrix.prototype.setMatrix;

SceneJS.Matrix.prototype._compile = function (ctx) {
    var core = this._core;
    core.numCores = 0;
    for (var i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.Matrix.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.Matrix.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;/**
 * @class Scene graph node which defines a rotation modelling transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.Rotate = SceneJS_NodeFactory.createNodeType("rotate");

SceneJS.Rotate.prototype._init = function(params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        SceneJS_modelXFormStack.buildCore(this._core);

        this.setMultOrder(params.multOrder);

        this.setAngle(params.angle);

        this.setXYZ({
            x: params.x,
            y: params.y,
            z: params.z
        });

        var core = this._core;

        this._core.buildMatrix = function() {
            core.matrix = SceneJS_math_rotationMat4v(core.angle * Math.PI / 180.0, [core.x, core.y, core.z]);
        };

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.Rotate.prototype.getModelMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, rotate, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.Rotate.prototype.getWorldMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply( [], this._core.mat);
};

/**
 * Sets the multiplication order of this node's transform matrix with respect to the parent modeling transform
 * in the scene graph.
 *
 * @param {String} multOrder Mulplication order - "post" and "pre"
 */
SceneJS.Rotate.prototype.setMultOrder = function(multOrder) {

    multOrder = multOrder || "post";

    if (multOrder != "post" && multOrder != "pre") {

        throw SceneJS_error.fatalError(
                SceneJS.errors.NODE_CONFIG_EXPECTED,
                "Illegal multOrder for rotate node - '" + multOrder + "' should be 'pre' or 'post'");
    }

    this._core.multOrder = multOrder;

    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.setAngle = function(angle) {
    this._core.angle = angle || 0;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getAngle = function() {
    return this._core.angle;
};

SceneJS.Rotate.prototype.setXYZ = function(xyz) {

    xyz = xyz || {};

    this._core.x = xyz.x || 0;
    this._core.y = xyz.y || 0;
    this._core.z = xyz.z || 0;

    this._core.setDirty();

    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getXYZ = function() {
    return {
        x: this._core.x,
        y: this._core.y,
        z: this._core.z
    };
};

SceneJS.Rotate.prototype.setX = function(x) {
    this._core.x = x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getX = function() {
    return this._core.x;
};

SceneJS.Rotate.prototype.setY = function(y) {
    this._core.y = y;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getY = function() {
    return this._core.y;
};

SceneJS.Rotate.prototype.setZ = function(z) {
    this._core.z = z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getZ = function() {
    return this._core.z;
};

SceneJS.Rotate.prototype.incAngle = function(angle) {
    this._core.angle += angle;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype._compile = function (ctx) {
    var core = this._core;
    core.numCores = 0;
    for (var i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.Rotate.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.Rotate.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;/**
 * @class Scene graph node which defines a translation modelling transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.Translate = SceneJS_NodeFactory.createNodeType("translate");

SceneJS.Translate.prototype._init = function(params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        SceneJS_modelXFormStack.buildCore(this._core);

        this.setMultOrder(params.multOrder);

        this.setXYZ({
            x: params.x,
            y: params.y,
            z: params.z
        });

        var core = this._core;

        this._core.buildMatrix = function() {
            core.matrix = SceneJS_math_translationMat4v([core.x, core.y, core.z], core.matrix);
        };

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.Translate.prototype.getModelMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, translate, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.Translate.prototype.getWorldMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply( [], this._core.mat);
};


/**
 * Sets the multiplication order of this node's transform matrix with respect to the parent modeling transform
 * in the scene graph.
 *
 * @param {String} multOrder Mulplication order - "post" and "pre"
 */
SceneJS.Translate.prototype.setMultOrder = function(multOrder) {

    multOrder = multOrder || "post";

    if (multOrder != "post" && multOrder != "pre") {

        throw SceneJS_error.fatalError(
                SceneJS.errors.NODE_CONFIG_EXPECTED,
                "Illegal multOrder for translate node - '" + multOrder + "' should be 'pre' or 'post'");
    }

    this._core.multOrder = multOrder;

    this._core.setDirty();

    this._engine.display.imageDirty = true;
};

SceneJS.Translate.prototype.setXYZ = function(xyz) {

    xyz = xyz || {};

    this._core.x = xyz.x || 0;
    this._core.y = xyz.y || 0;
    this._core.z = xyz.z || 0;

    this._core.setDirty();

    this._engine.display.imageDirty = true;

    return this;
};

SceneJS.Translate.prototype.getXYZ = function() {
    return {
        x: this._core.x,
        y: this._core.y,
        z: this._core.z
    };
};

SceneJS.Translate.prototype.setX = function(x) {
    this._core.x = x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.setY = function(y) {
    this._core.y = y;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.setZ = function(z) {
    this._core.z = z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.incX = function(x) {
    this._core.x += x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.incY = function(y) {
    this._core.y += y;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.incZ = function(z) {
    this._core.z += z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.getX = function() {
    return this._core.x;
};

SceneJS.Translate.prototype.getY = function() {
    return this._core.y;
};

SceneJS.Translate.prototype.getZ = function() {
    return this._core.z;
};

SceneJS.Translate.prototype._compile = function (ctx) {
    var core = this._core;
    core.numCores = 0;
    for (var i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.Translate.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.Translate.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;/**
 * @class Scene graph node which defines a rotation modelling transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.Scale = SceneJS_NodeFactory.createNodeType("scale");

SceneJS.Scale.prototype._init = function (params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        SceneJS_modelXFormStack.buildCore(this._core);

        this.setMultOrder(params.multOrder);

        this.setXYZ({
            x:params.x,
            y:params.y,
            z:params.z
        });

        var core = this._core;

        this._core.buildMatrix = function () {
            core.matrix = SceneJS_math_scalingMat4v([core.x, core.y, core.z]);
        };

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.Scale.prototype.getModelMatrix = function () {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, scale, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.Scale.prototype.getWorldMatrix = function () {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply([], this._core.mat);
};

/**
 * Sets the multiplication order of this node's transform matrix with respect to the parent modeling transform
 * in the scene graph.
 *
 * @param {String} multOrder Mulplication order - "post" and "pre"
 */
SceneJS.Scale.prototype.setMultOrder = function (multOrder) {

    multOrder = multOrder || "post";

    if (multOrder != "post" && multOrder != "pre") {

        throw SceneJS_error.fatalError(
            SceneJS.errors.NODE_CONFIG_EXPECTED,
            "Illegal multOrder for scale node - '" + multOrder + "' should be 'pre' or 'post'");
    }

    this._core.multOrder = multOrder;

    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.setXYZ = function (xyz) {

    xyz = xyz || {};

    this._core.x = xyz.x == undefined ? 1 : xyz.x;
    this._core.y = xyz.y == undefined ? 1 : xyz.y;
    this._core.z = xyz.z == undefined ? 1 : xyz.z;

    this._core.setDirty();

    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.getXYZ = function () {
    return {
        x:this._core.x,
        y:this._core.y,
        z:this._core.z
    };
};

SceneJS.Scale.prototype.setX = function (x) {
    this._core.x = x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.setY = function (y) {
    this._core.y = y;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.setZ = function (z) {
    this._core.z = z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.getX = function () {
    return this._core.x;
};

SceneJS.Scale.prototype.getY = function () {
    return this._core.y;
};

SceneJS.Scale.prototype.getZ = function () {
    return this._core.z;
};

SceneJS.Scale.prototype.incX = function (x) {
    this._core.x += x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.incY = function (y) {
    this._core.y += y;
    this._core.matrixDirty = true;
};

SceneJS.Scale.prototype.incZ = function (z) {
    this._core.z += z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype._compile = function (ctx) {
    var core = this._core;
    core.numCores = 0;
    for (var i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.Scale.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.Scale.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;/**
 * Provides a model transform stack in front of the renderer.
 * Nodes peek push and pop to the stack, while the renderer peeks at
 * the transform on the top of the stack whenever it builds a renderer node.
 *
 */
var SceneJS_modelXFormStack = new (function () {

    var defaultMatrix = SceneJS_math_identityMat4();
    var defaultMat = new Float32Array(defaultMatrix);

    var defaultNormalMatrix = SceneJS_math_transposeMat4(
        SceneJS_math_inverseMat4(
            SceneJS_math_identityMat4(),
            SceneJS_math_mat4()));
    var defaultNormalMat = new Float32Array(defaultNormalMatrix);

    var defaultCore = {
        type:"xform",
        stateId:SceneJS._baseStateId++,

        matrix:defaultMatrix,
        mat:defaultMat,

        normalMatrix:defaultNormalMatrix,
        normalMat:defaultNormalMat,

        parent:null, // Parent transform core
        cores:[], // Child transform cores
        numCores:0, // Number of child transform cores
        dirty:false, // Does this subtree need matrices rebuilt
        matrixDirty:false
    };

    var transformStack = [];
    var stackLen = 0;

    this.top = defaultCore;

    var dirty;

    var self = this;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function () {
            stackLen = 0;
            self.top = defaultCore;
            dirty = true;
        });

    SceneJS_events.addListener(
        SceneJS_events.OBJECT_COMPILING,
        function (params) {

            if (dirty) {

                if (stackLen > 0) {

                    params.display.modelTransform = transformStack[stackLen - 1];

                } else {

                    params.display.modelTransform = defaultCore;
                }

                dirty = false;
            }
        });

    /**
     * Creates a fresh transformation core
     * @param core
     */
    this.buildCore = function (core) {

        /*
         * Transform tree node properties
         */
        core.parent = null;         // Parent transform core
        core.cores = [];            // Child transform cores
        core.numCores = 0;          // Number of child transform cores
        core.matrixDirty = false;
        core.compiling = false;

        core.matrix = SceneJS_math_identityMat4();

        core.mat = new Float32Array(core.matrix);
        core.normalMat = new Float32Array(
            SceneJS_math_transposeMat4(
                SceneJS_math_inverseMat4(core.matrix, SceneJS_math_mat4())));

        core.dirty = false;         // Does this subtree need matrices rebuilt

        core.setDirty = function () {

            core.matrixDirty = true;

            if (core.dirty) {
                // return;
            }

            setDirty(core);
        };

        /**
         * Recursively flag this subtree of transforms cores as dirty,
         * ie. needing their matrices rebuilt.
         */
        function setDirty(core) {

            core.dirty = true;
            core.matrixDirty = true;

            for (var i = 0, len = core.numCores; i < len; i++) {
                setDirty(core.cores[i]);
            }
        }

        /**
         * Pre-multiply matrices at cores on path up to root into matrix at this core
         */

        var matrix = new SceneJS_math_mat4();

        core.build = function () {

            if (core.matrixDirty) {
                if (core.buildMatrix) { // Matrix might be explicit property on some transform node types
                    core.buildMatrix();
                }
                core.matrixDirty = false;
            }

            var parent = core.parent;

            if (parent) {

                matrix.set(core.matrix);

                while (parent) {

                    if (parent.matrixDirty) {

                        if (parent.buildMatrix) { // Matrix might be explicit property on some transform node types
                            parent.buildMatrix();
                        }
                        parent.mat.set(parent.matrix);
                        SceneJS_math_inverseMat4(parent.matrix, parent.normalMat);
                        SceneJS_math_transposeMat4(parent.normalMat, parent.normalMat);

                        parent.matrixDirty = false;
                    }

                    SceneJS_math_mulMat4(parent.matrix, matrix, matrix);

                    if (!parent.dirty) {
                        //   break;
                    }

                    //  parent.dirty = false;

                    parent = parent.parent;
                }

            } else {

                matrix.set(core.matrix);
            }

            //            if (!core.mat) {
            //
            //                core.mat = new Float32Array(matrix);
            //
            //                core.normalMat = new Float32Array(
            //                        SceneJS_math_transposeMat4(
            //                                SceneJS_math_inverseMat4(matrix, SceneJS_math_mat4())));
            //            } else {

            core.mat.set(matrix);

            SceneJS_math_inverseMat4(matrix, core.normalMat);
            SceneJS_math_transposeMat4(core.normalMat, core.normalMat);

            core.dirty = false;
        };
    };

    this.push = function (core) {

        transformStack[stackLen++] = core;

        core.parent = this.top;
        core.dirty = true;

        if (this.top) {
            this.top.cores[this.top.numCores++] = core;
        }

        this.top = core;

        dirty = true;
    };

    this.pop = function () {

        this.top = (--stackLen > 0) ? transformStack[stackLen - 1] : defaultCore;
        transformStack[stackLen] = null;  // Release previous top node

        dirty = true;
    };

})();
;/**
 * Container for custom node types
 */
SceneJS.Types = new (function () {

    /**
     * Installs a node type
     * @param typeName
     * @param methods
     */
    this.addType = function (typeName, methods) {
        SceneJS_NodeFactory.createNodeType(typeName, methods,
            // Augments the basic node type with our custom type's methods
            function (type) {
                var method;
                for (var methodName in methods) {
                    if (methods.hasOwnProperty(methodName)) {
                        method = methods[methodName];
                        switch (methodName) {
                            case "init": // Deprecated
                            case "construct":
                                (function () {
                                    var _method = methods[methodName];
                                    type.prototype._init = function (params) {
                                        _method.call(this, params);
                                    };

                                    // Mark node type as a plugin
                                    type.prototype._fromPlugin = true;
                                })();
                                break;
                            case "destroy": // Deprecated
                            case "destruct":
                                type.prototype._destroy = method;
                                break;
                            default:
                                type.prototype[methodName] = method;
                        }
                    }
                }
            });
    };

    /**
     * Tests if given node type is installed
     * @param typeName
     * @param methods
     */
    this.hasType = function (typeName) {
        return !!SceneJS_NodeFactory.nodeTypes[typeName];
    };
})();

;/**
 * @class Display compiled from a {@link SceneJS.Scene}, providing methods to render and pick.
 * @private
 *
 * <p>A Display is a container of {@link SceneJS_Object}s which are created (or updated) by a depth-first
 * <b>compilation traversal</b> of a {@link SceneJS.Scene}.</b>
 *
 * <h2>Rendering Pipeline</h2>
 *
 * <p>Conceptually, a Display implements a pipeline with the following stages:</p>
 *
 * <ol>
 * <li>Create or update {@link SceneJS_Object}s during scene compilation</li>
 * <li>Organise the {@link SceneJS_Object} into an <b>object list</b></li>
 * <li>Determine the GL state sort order for the object list</li>
 * <li>State sort the object list</li>
 * <li>Create a <b>draw list</b> containing {@link SceneJS_Chunk}s belonging to the {@link SceneJS_Object}s in the object list</li>
 * <li>Render the draw list to draw the image</li>
 * </ol>
 *
 * <p>An update to the scene causes the pipeline to be re-executed from one of these stages, and SceneJS is designed
 * so that the pipeline is always re-executed from the latest stage possible to avoid redoing work.</p>
 *
 * <p>For example:</p>
 *
 * <ul>
 * <li>when an object is created or updated, we need to (re)do stages 2, 3, 4, 5 and 6</li>
 * <li>when an object is made invisible, we need to redo stages 5 and 6</li>
 * <li>when an object is assigned to a different scene render layer (works like a render bin), we need to redo
 *   stages 3, 4, 5, and 6</li>
 *<li>when the colour of an object changes, or maybe when the viewpoint changes, we simplt redo stage 6</li>
 * </ul>
 *
 * <h2>Object Creation</h2>
 * <p>The object soup (stage 1) is constructed by a depth-first traversal of the scene graph, which we think of as
 * "compiling" the scene graph into the Display. As traversal visits each scene node, the node's state core is
 * set on the Display (such as {@link #flags}, {@link #layer}, {@link #renderer} etc), which we think of as the
 * cores that are active at that instant during compilation. Each of the scene's leaf nodes is always
 * a {@link SceneJS.Geometry}, and when traversal visits one of those it calls {@link #buildObject} to create an
 * object in the soup. For each of the currently active cores, the object is given a {@link SceneJS_Chunk}
 * containing the WebGL calls for rendering it.</p>
 *
 * <p>The object also gets a shader (implemented by {@link SceneJS_Program}), taylored to render those state cores.</p>
 *
 * <p>Limited re-compilation may also be done on portions of a scene that have been added or sufficiently modified. When
 * traversal visits a {@link SceneJS.Geometry} for which an object already exists in the display, {@link #buildObject}
 * may update the {@link SceneJS_Chunk}s on the object as required for any changes in the core soup since the
 * last time the object was built. If differences among the cores require it, then {@link #buildObject} may also replace
 * the object's {@link SceneJS_Program} in order to render the new core soup configuration.</p>
 *
 * <p>So in summary, to each {@link SceneJS_Object} it builds, {@link #buildObject} creates a list of
 * {@link SceneJS_Chunk}s to render the set of node state cores that are currently set on the {@link SceneJS_Display}.
 * When {@link #buildObject} is re-building an existing object, it may replace one or more {@link SceneJS_Chunk}s
 * for state cores that have changed from the last time the object was built or re-built.</p>

 * <h2>Object Destruction</h2>
 * <p>Destruction of a scene graph branch simply involves a call to {@link #removeObject} for each {@link SceneJS.Geometry}
 * in the branch.</p>
 *
 * <h2>Draw List</h2>
 * <p>The draw list is actually comprised of two lists of state chunks: a "pick" list to render a pick buffer
 * for colour-indexed GPU picking, along with a "draw" list for normal image rendering. The chunks in these lists
 * are held in the state-sorted order of their objects in #_objectList, with runs of duplicate states removed.</p>
 *
 * <p>After a scene update, we set a flag on the display to indicate the stage we will need to redo from. The pipeline is
 * then lazy-redone on the next call to #render or #pick.</p>
 */
var SceneJS_Display = function (stats, cfg) {

    // Collects runtime statistics
    this.stats = stats || {};

    // Display is bound to the lifetime of an HTML5 canvas
    this._canvas = cfg.canvas;

    // Factory which creates and recycles {@link SceneJS_Program} instances
    this._programFactory = new SceneJS_ProgramFactory(this.stats, {
        canvas: cfg.canvas
    });

    // Factory which creates and recycles {@link SceneJS.Chunk} instances
    this._chunkFactory = new SceneJS_ChunkFactory();

    /**
     * True when the background is to be transparent
     * @type {boolean}
     */
    this.transparent = cfg.transparent === true;

    /**
     * Depth sort mode. Default to only sorting transparent objects.
     */
    this.depthSort = cfg.depthSort === true;

    /**
     * Node state core for the last {@link SceneJS.Enable} visited during scene graph compilation traversal
     * @type Object
     */
    this.enable = null;

    /**
     * Node state core for the last {@link SceneJS.Flags} visited during scene graph compilation traversal
     * @type Object
     */
    this.flags = null;

    /**
     * Node state core for the last {@link SceneJS.Layer} visited during scene graph compilation traversal
     * @type Object
     */
    this.layer = null;

    /**
     * Node state core for the last {@link SceneJS.Stage} visited during scene graph compilation traversal
     * @type Object
     */
    this.stage = null;

    /**
     * Node state core for the last {@link SceneJS.Renderer} visited during scene graph compilation traversal
     * @type Object
     */
    this.renderer = null;

    /**
     * Node state core for the last {@link SceneJS.DepthBuf} visited during scene graph compilation traversal
     * @type Object
     */
    this.depthBuffer = null;

    /**
     * Node state core for the last {@link SceneJS.StencilBuf} visited during scene graph compilation traversal
     * @type Object 
     */
    this.stencilBuffer = null;

    /**
     * Node state core for the last {@link SceneJS.ColorBuf} visited during scene graph compilation traversal
     * @type Object
     */
    this.colorBuffer = null;

    /**
     * Node state core for the last {@link SceneJS.View} visited during scene graph compilation traversal
     * @type Object
     */
    this.view = null;

    /**
     * Node state core for the last {@link SceneJS.Lights} visited during scene graph compilation traversal
     * @type Object
     */
    this.lights = null;

    /**
     * Node state core for the last {@link SceneJS.Material} visited during scene graph compilation traversal
     * @type Object
     */
    this.material = null;

    /**
     * Node state core for the last {@link SceneJS.Texture} visited during scene graph compilation traversal
     * @type Object
     */
    this.texture = null;

    /**
     * Node state core for the last {@link SceneJS.Fresnel} visited during scene graph compilation traversal
     * @type Object
     */
    this.fresnel = null;

    /**
     * Node state core for the last {@link SceneJS.Reflect} visited during scene graph compilation traversal
     * @type Object
     */
    this.cubemap = null;

    /**
     * Node state core for the last {@link SceneJS.XForm} visited during scene graph compilation traversal
     * @type Object
     */
    this.modelTransform = null;

    /**
     * Node state core for the last {@link SceneJS.LookAt} visited during scene graph compilation traversal
     * @type Object
     */
    this.viewTransform = null;

    /**
     * Node state core for the last {@link SceneJS.Camera} visited during scene graph compilation traversal
     * @type Object
     */
    this.projTransform = null;

    /**
     * Node state core for the last {@link SceneJS.Billboard} visited during scene graph compilation traversal
     * @type Object
     */
    this.billboard = null;

    /**
     * Node state core for the last {@link SceneJS.RegionMap} visited during scene graph compilation traversal
     * @type Object
     */
    this.regionMap = null;

    /**
     * Node state core for the last {@link SceneJS.ColorTarget} visited during scene graph compilation traversal
     * @type Object
     */
    this.renderTarget = null;

    /**
     * Node state core for the last {@link SceneJS.Clips} visited during scene graph compilation traversal
     * @type Object
     */
    this.clips = null;

    /**
     * Node state core for the last {@link SceneJS.MorphGeometry} visited during scene graph compilation traversal
     * @type Object
     */
    this.morphGeometry = null;

    /**
     * Node state core for the last {@link SceneJS.Name} visited during scene graph compilation traversal
     * @type Object
     */
    this.name = null;

    /**
     * Node state core for the last {@link SceneJS.Tag} visited during scene graph compilation traversal
     * @type Object
     */
    this.tag = null;

    /**
     * Node state core for the last render {@link SceneJS.Node} listener encountered during scene graph compilation traversal
     * @type Object
     */
    this.renderListeners = null;

    /**
     * Node state core for the last {@link SceneJS.Shader} visited during scene graph compilation traversal
     * @type Object
     */
    this.shader = null;

    /**
     * Node state core for the last {@link SceneJS.ShaderParams} visited during scene graph compilation traversal
     * @type Object
     */
    this.shaderParams = null;

    /**
     * Node state core for the last {@link SceneJS.Style} visited during scene graph compilation traversal
     * @type Object
     */
    this.style = null;

    /**
     * Node state core for the last {@link SceneJS.Geometry} visited during scene graph compilation traversal
     * @type Object
     */
    this.geometry = null;

    /* Factory which creates and recycles {@link SceneJS_Object} instances
     */
    this._objectFactory = new SceneJS_ObjectFactory();

    /**
     * The objects in the display
     */
    this._objects = {};

    /**
     * Ambient color, which must be given to gl.clearColor before draw list iteration
     */
    this._ambientColor = [0, 0, 0, 1.0];

    /**
     * The object list, containing all elements of #_objects, kept in GL state-sorted order
     */
    this._objectList = [];
    this._objectListLen = 0;

    this._objectPickList = [null];  // Index 0 reserved for background (i.e. no pick)
    this._objectPickListLen = 1;


    /* The "draw list", comprised collectively of three lists of state chunks belong to visible objects
     * within #_objectList: a "pick" list to render a pick buffer for colour-indexed GPU picking, along with an
     * "draw" list for normal image rendering.  The chunks in these lists are held in the state-sorted order of
     * their objects in #_objectList, with runs of duplicate states removed.
     */
    this._drawList = [];                // State chunk list to render all objects
    this._drawListLen = 0;

    this._pickDrawList = [];            // State chunk list to render scene to pick buffer
    this._pickDrawListLen = 0;

    this._targetList = [];
    this._targetListLen = 0;

    this._objectDrawList = [];
    this._objectDrawListLen = 0;

    // Tracks the index of the first chunk in the transparency pass. The first run of chunks
    // in the list are for opaque objects, while the remainder are for transparent objects.
    // This supports a mode in which we only render the opaque chunks.
    this._drawListTransparentIndex = -1;

    /* The frame context holds state shared across a single render of the draw list, along with any results of
     * the render, such as pick hits
     */
    this._frameCtx = {
        pickNames: [], // Pick names of objects hit during pick render,
        regionData: [],
        canvas: this._canvas,           // The canvas
        VAO: null                       // Vertex array object extension
    };

    /* The frame context has this facade which is given to scene node "rendered" listeners
     * to allow application code to access things like transform matrices from within those listeners.
     */
    this._frameCtx.renderListenerCtx = new SceneJS.RenderContext(this._frameCtx);

    /*-------------------------------------------------------------------------------------
     * Flags which schedule what the display is to do when #render is next called.
     *------------------------------------------------------------------------------------*/

    /**
     * Flags the object list as needing to be rebuilt from existing objects on the next call to {@link #render} or {@link #pick}.
     * Setting this will cause the rendering pipeline to be executed from stage #2 (see class comment),
     * causing object list rebuild, state order determination, state sort, draw list construction and image render.
     * @type Boolean
     */
    this.objectListDirty = true;

    /**
     * Flags the object list as needing state orders to be computed on the next call to {@link #render} or {@link #pick}.
     * Setting this will cause the rendering pipeline to be executed from stage #3 (see class comment),
     * causing state order determination, state sort, draw list construction and image render.
     * @type Boolean
     */
    this.stateOrderDirty = true;

    /**
     * Flags the object list as needing to be state sorted on the next call to {@link #render} or {@link #pick}.
     * Setting this will cause the rendering pipeline to be executed from stage #4 (see class comment),
     * causing state sort, draw list construction and image render.
     * @type Boolean
     */
    this.stateSortDirty = true;

    /**
     * Flags the draw list as needing to be rebuilt from the object list on the next call to {@link #render} or {@link #pick}.
     * Setting this will cause the rendering pipeline to be executed from stage #5 (see class comment),
     * causing draw list construction and image render.
     * @type Boolean
     */
    this.drawListDirty = true;

    /**
     * Flags the image as needing to be redrawn from the draw list on the next call to {@link #render} or {@link #pick}.
     * Setting this will cause the rendering pipeline to be executed from stage #6 (see class comment),
     * causing the image render.
     * @type Boolean
     */
    this.imageDirty = true;
};

/**
 * Reallocates WebGL resources for objects within this display
 */
SceneJS_Display.prototype.webglRestored = function () {
    this._programFactory.webglRestored();// Reallocate programs
    this._chunkFactory.webglRestored(); // Recache shader var locations
    var gl = this._canvas.gl;
    if (this.pickBuf) {
        this.pickBuf.webglRestored(gl);          // Rebuild pick buffers
    }
    this.imageDirty = true;             // Need redraw
};

/**
 * Internally creates (or updates) a {@link SceneJS_Object} of the given ID from whatever node state cores are currently set
 * on this {@link SceneJS_Display}. The object is created if it does not already exist in the display, otherwise it is
 * updated with the current state cores, possibly replacing cores already referenced by the object.
 *
 * @param {String} objectId ID of object to create or update
 */
SceneJS_Display.prototype.buildObject = function (objectId) {

    var object = this._objects[objectId];

    if (!object) { // Create object
        object = this._objects[objectId] = this._objectFactory.getObject(objectId);
        this.objectListDirty = true;
    }

    object.modelTransform = this.modelTransform;
    object.viewTransform = this.viewTransform;
    object.projTransform = this.projTransform;
    object.stage = this.stage;
    object.layer = this.layer;
    object.renderTarget = this.renderTarget;
    object.texture = this.texture;
    object.cubemap = this.cubemap;
    object.geometry = this.geometry;
    object.morphGeometry = this.morphGeometry;
    object.enable = this.enable;
    object.flags = this.flags;
    object.tag = this.tag;
    object.name = this.name;

    //if (!object.hash) {

    var hash = ([                   // Build current state hash
        this.geometry.hash,
        this.shader.hash,
        this.clips.hash,
        this.morphGeometry.hash,
        this.texture.hash,
        this.fresnel.hash,
        this.cubemap.hash,
        this.lights.hash,
        this.flags.hash,
        this.regionMap.hash,
        this.billboard.hash
    ]).join(";");

    if (!object.program || hash != object.hash) {
        // Get new program for object if no program or hash mismatch
        if (object.program) {
            this._programFactory.putProgram(object.program);
        }
        object.program = this._programFactory.getProgram(hash, this);
        object.hash = hash;
    }
    //}

    // Build draw chunks for object

    this._setChunk(object, 0, "program");          // Must be first
    this._setChunk(object, 1, "xform", this.modelTransform);
    this._setChunk(object, 2, "lookAt", this.viewTransform);
    this._setChunk(object, 3, "camera", this.projTransform);
    this._setChunk(object, 4, "flags", this.flags);
    this._setChunk(object, 5, "shader", this.shader);
    this._setChunk(object, 6, "shaderParams", this.shaderParams);
    this._setChunk(object, 7, "style", this.style);
    this._setChunk(object, 8, "depthBuffer", this.depthBuffer);
    this._setChunk(object, 9, "stencilBuffer", this.stencilBuffer);
    this._setChunk(object, 10, "colorBuffer", this.colorBuffer);
    this._setChunk(object, 11, "view", this.view);
    this._setChunk(object, 12, "lights", this.lights);
    this._setChunk(object, 13, "material", this.material);
    this._setChunk(object, 14, "texture", this.texture);
    this._setChunk(object, 15, "regionMap", this.regionMap);
    this._setChunk(object, 16, "fresnel", this.fresnel);
    this._setChunk(object, 17, "cubemap", this.cubemap);
    this._setChunk(object, 18, "clips", this.clips);
    this._setChunk(object, 19, "renderer", this.renderer);
    this._setChunk(object, 20, "geometry", this.morphGeometry, this.geometry);
    this._setChunk(object, 21, "listeners", this.renderListeners);      // Must be after the above chunks
    this._setChunk(object, 22, "draw", this.geometry); // Must be last

    // At the very least, the object sort order
    // will need be recomputed

    this.stateOrderDirty = true;
};



SceneJS_Display.prototype._setChunk = function (object, order, chunkType, core, core2) {

    var chunkId;
    var chunkClass = this._chunkFactory.chunkTypes[chunkType];

    if (core) {

        // Core supplied
        if (core.empty) { // Only set default cores for state types that have them
            var oldChunk = object.chunks[order];
            if (oldChunk) {
                this._chunkFactory.putChunk(oldChunk); // Release previous chunk to pool
            }
            object.chunks[order] = null;
            return;
        }

        // Note that core.stateId can be either a number or a string, that's why we make
        // chunkId a string here.
        // TODO: Would it be better if all were numbers?
        chunkId = chunkClass.prototype.programGlobal
            ? '_' + core.stateId
            : 'p' + object.program.id + '_' + core.stateId;

        if (core2) {
            chunkId += '__' + core2.stateId;
        }

    } else {

        // No core supplied, probably a program.
        // Only one chunk of this type per program.
        chunkId = 'p' + object.program.id;
    }

    // This is needed so that chunkFactory can distinguish between draw and geometry
    // chunks with the same core.
    chunkId = order + '__' + chunkId;

    var oldChunk = object.chunks[order];

    if (oldChunk) {
        if (oldChunk.id == chunkId) { // Avoid needless chunk reattachment
            return;
        }
        this._chunkFactory.putChunk(oldChunk); // Release previous chunk to pool
    }

    object.chunks[order] = this._chunkFactory.getChunk(chunkId, chunkType, object.program, core, core2); // Attach new chunk

    // Ambient light is global across everything in display, and
    // can never be disabled, so grab it now because we want to
    // feed it to gl.clearColor before each display list render
    if (chunkType == "lights") {
        this._setAmbient(core);
    }
};

SceneJS_Display.prototype._setAmbient = function (core) {
    var lights = core.lights;
    var light;
    for (var i = 0, len = lights.length; i < len; i++) {
        light = lights[i];
        if (light.mode == "ambient") {
            this._ambientColor[0] = light.color[0];
            this._ambientColor[1] = light.color[1];
            this._ambientColor[2] = light.color[2];
        }
    }
};

/**
 * Removes an object from this display
 *
 * @param {String} objectId ID of object to remove
 */
SceneJS_Display.prototype.removeObject = function (objectId) {
    var object = this._objects[objectId];
    if (!object) {
        return;
    }
    this._programFactory.putProgram(object.program);
    object.program = null;
    object.hash = null;
    var chunk;
    for (var i = 0, len = object.chunks.length; i < len; i++) {
        chunk = object.chunks[i];
        if (chunk) {
            this._chunkFactory.putChunk(chunk);
        }
    }
    this._objectFactory.putObject(object);
    delete this._objects[objectId];
    this.objectListDirty = true;
};

/**
 * Enable or disable depth sorting
 */
SceneJS_Display.prototype.setDepthSort = function (enabled) {
    this.depthSort = enabled;
};

/**
 * Set a tag selector to selectively activate objects that have matching SceneJS.Tag nodes
 */
SceneJS_Display.prototype.selectTags = function (tagSelector) {
    this._tagSelector = tagSelector;
    this.drawListDirty = true;
};

/**
 * Render this display. What actually happens in the method depends on what flags are set.
 *
 */
SceneJS_Display.prototype.render = function (params) {

    params = params || {};

    if (this.objectListDirty) {
        this._buildObjectList();          // Build object render bin
        this.objectListDirty = false;
        this.stateOrderDirty = true;        // Now needs state ordering
    }


    if (this.stateOrderDirty || (this.imageDirty && this.depthSort)) {

        // State sort will be dirty if the state order was dirty (due to priority or
        // or transparency change) or if depth is re-calculated in _makeStateSortKeys
        this.stateSortDirty = this.stateOrderDirty;     // Now needs state sorting
        this._makeStateSortKeys();                      // Compute state sort order
        this.stateOrderDirty = false;
    }

    if (this.stateSortDirty) {
        this._stateSort();              // State sort the object render bin
        this.stateSortDirty = false;
        this.drawListDirty = true;      // Now needs new visible object bin
        //this._logObjectList();
    }

    if (this.drawListDirty) {           // Render visible list while building transparent list
        this._buildDrawList();
        this.imageDirty = true;
        //this._logDrawList();
        //this._logPickList();
    }

    if (this.imageDirty || params.force) {
        SceneJS_events.fireEvent(SceneJS_events.RENDER, {
            forced: !!params.force
        });
        this._doDrawList({ // Render, no pick
            clear: (params.clear !== false), // Clear buffers by default
            opaqueOnly: params.opaqueOnly
        });
        this.imageDirty = false;
        this.pickBufDirty = true;       // Pick buff will now need rendering on next pick
    }
};

SceneJS_Display.prototype._buildObjectList = function () {
    var lastObjectListLen = this._objectListLen;
    this._objectListLen = 0;
    for (var objectId in this._objects) {
        if (this._objects.hasOwnProperty(objectId)) {
            this._objectList[this._objectListLen++] = this._objects[objectId];
        }
    }

    // Release memory

    if (lastObjectListLen > this._objectListLen) {
        for (i = this._objectListLen; i < lastObjectListLen; i++) {
            this._objectList[i] = null;
        }
    }

};

SceneJS_Display.prototype._makeStateSortKeys = function () {
    //  console.log("--------------------------------------------------------------------------------------------------");
    // console.log("SceneJS_Display_makeSortKeys");
    var object;
    for (var i = 0, len = this._objectListLen; i < len; i++) {
        object = this._objectList[i];
        if (!object.program) {
            // Non-visual object (eg. sound)
            object.sortKey1 = -1;
        } else {
            var transparent = object.flags.transparent;
            var depth;

            if (transparent && this.depthSort) {
                depth = object.getDepth();
                this.stateSortDirty = true;
            } else {
                depth = 0;
            }

            object.sortKey1 = (object.stage.priority + 1) * 3000 +
                              (transparent ? 2 : 1) * 1000 +
                              (object.layer.priority + 1) +
                              1 / (depth + 1);
            object.sortKey2 = (object.program.id + 1) * 100000 +
                              object.texture.stateId;
        }
    }
    //  console.log("--------------------------------------------------------------------------------------------------");
};

SceneJS_Display.prototype._stateSort = function () {
    this._objectList.length = this._objectListLen;
    this._objectList.sort(this._stateSortObjects);
};

SceneJS_Display.prototype._stateSortObjects = function (a, b) {
    return  (a.sortKey1 - b.sortKey1) ||
            (a.sortKey2 - b.sortKey2);
};

SceneJS_Display.prototype._logObjectList = function () {
    console.log("--------------------------------------------------------------------------------------------------");
    console.log(this._objectListLen + " objects");
    for (var i = 0, len = this._objectListLen; i < len; i++) {
        var object = this._objectList[i];
        console.log("SceneJS_Display : object[" + i + "] sortKey = " + object.sortKey);
    }
    console.log("--------------------------------------------------------------------------------------------------");
};

SceneJS_Display.prototype._buildDrawList = function () {

    this._lastStateId = this._lastStateId || [];
    this._lastPickStateId = this._lastPickStateId || [];

    var i;

    for (i = 0; i < 25; i++) {
        this._lastStateId[i] = null;
        this._lastPickStateId[i] = null;
    }

    var lastDrawListLen = this._drawListLen;
    var lastPickDrawListLen = this._pickDrawListLen;
    var lastObjectDrawListLen = this._objectDrawListLen;
    var lastObjectPickListLen = this._objectPickListLen;

    this._drawListLen = 0;
    this._pickDrawListLen = 0;
    this._objectDrawListLen = 0;
    this._objectPickListLen = 1;

    this._drawListTransparentIndex = -1;

    // For each render target, a list of objects to render to that target
    var targetObjectLists = {};

    // A list of all the render target object lists
    var targetListList = [];

    // List of all targets
    var targetList = [];

    var object;
    var tagMask;
    var tagRegex;
    var tagCore;
    var flags;

    if (this._tagSelector) {
        tagMask = this._tagSelector.mask;
        tagRegex = this._tagSelector.regex;
    }

    for (i = 0, len = this._objectListLen; i < len; i++) {

        object = this._objectList[i];

        // Cull invisible objects
        if (object.enable.enabled === false) {
            continue;
        }

        flags = object.flags;

        // Cull invisible objects
        if (flags.enabled === false) {
            continue;
        }

        // Cull objects in disabled layers
        if (!object.layer.enabled) {
            continue;
        }

        // Cull objects with unmatched tags
        if (tagMask) {
            tagCore = object.tag;
            if (tagCore.tag) {
                if (tagCore.mask != tagMask) { // Scene tag mask was updated since last render
                    tagCore.mask = tagMask;
                    tagCore.matches = tagRegex.test(tagCore.tag);
                }
                if (!tagCore.matches) {
                    continue;
                }
            }
        }

        // Put objects with render targets into a bin for each target
        if (object.renderTarget.targets) {
            var targets = object.renderTarget.targets;
            var target;
            var coreId;
            var list;
            for (var j = 0, lenj = targets.length; j < lenj; j++) {
                target = targets[j];
                coreId = target.coreId;
                list = targetObjectLists[coreId];
                if (!list) {
                    list = [];
                    targetObjectLists[coreId] = list;
                    targetListList.push(list);
                    targetList.push(this._chunkFactory.getChunk(target.stateId, "renderTarget", object.program, target));
                }
                list.push(object);
            }
        } else {

            //
            this._objectDrawList[this._objectDrawListLen++] = object;
        }
    }

    // Append chunks for objects within render targets first

    var list;
    var target;
    var object;
    var pickable;

    for (i = 0, len = targetListList.length; i < len; i++) {

        list = targetListList[i];
        target = targetList[i];

        this._appendRenderTargetChunk(target);

        for (var j = 0, lenj = list.length; j < lenj; j++) {
            object = list[j];
            pickable = object.stage && object.stage.pickable
                && object.flags && object.flags.picking; // We'll only pick objects in pickable stages
            this._appendObjectToDrawLists(object, pickable);
        }
    }

    if (object) {

        // Unbinds any render target bound previously
        this._appendRenderTargetChunk(this._chunkFactory.getChunk(-1, "renderTarget", object.program, {}));
    }

    // Append chunks for objects not in render targets

    for (i = 0, len = this._objectDrawListLen; i < len; i++) {
        object = this._objectDrawList[i];
        pickable = (!object.stage || (object.stage && object.stage.pickable))
            && (object.flags && object.flags.picking); // We'll only pick objects in pickable stages
        this._appendObjectToDrawLists(object, pickable);
    }

    // Release memory

    if (lastDrawListLen > this._drawListLen) {
        for (i = this._drawListLen; i < lastDrawListLen; i++) {
            this._drawList[i] = null;
        }
    }

    if (lastPickDrawListLen > this._pickDrawListLen) {
        for (i = this._pickDrawListLen; i < lastPickDrawListLen; i++) {
            this._pickDrawList[i] = null;
        }
    }

    if (lastObjectDrawListLen > this._objectDrawListLen) {
        for (i = this._objectDrawListLen; i < lastObjectDrawListLen; i++) {
            this._objectDrawList[i] = null;
        }
    }

    if (lastObjectPickListLen > this._objectPickListLen) {
        for (i = this._objectPickListLen; i < lastObjectPickListLen; i++) {
            this._objectPickList[i] = null;
        }
    }

    this.drawListDirty = false;
};


SceneJS_Display.prototype._appendRenderTargetChunk = function (chunk) {
    this._drawList[this._drawListLen++] = chunk;
};

/**
 * Appends an object to the draw and pick lists.
 * @param object
 * @param pickable
 * @private
 */
SceneJS_Display.prototype._appendObjectToDrawLists = function (object, pickable) {
    var chunks = object.chunks;
    var chunk;
    for (var i = 0, len = chunks.length; i < len; i++) {
        chunk = chunks[i];
        if (chunk) {

            // As we apply the state chunk lists we track the ID of most types of chunk in order
            // to cull redundant re-applications of runs of the same chunk - except for those chunks with a
            // 'unique' flag, because we don't want to cull runs of draw chunks because they contain the GL
            // drawElements calls which render the objects.

            if (chunk.draw && (chunk.unique || this._lastStateId[i] != chunk.id)) {
                this._drawList[this._drawListLen] = chunk;
                this._lastStateId[i] = chunk.id;

                // Get index of first chunk in transparency pass

                if (chunk.core && chunk.core.transparent && this._drawListTransparentIndex < 0) {
                    this._drawListTransparentIndex = this._drawListLen;
                }
                this._drawListLen++;
            }

            if (pickable !== false && chunk.pick && (chunk.unique || this._lastPickStateId[i] != chunk.id)) {
                this._pickDrawList[this._pickDrawListLen++] = chunk;
                this._lastPickStateId[i] = chunk.id;
            }
        }
    }
    if (pickable) {
        this._objectPickList[this._objectPickListLen++] = object;
    }
};

/**
 * Logs the contents of the draw list to the console.
 * @private
 */
SceneJS_Display.prototype._logDrawList = function () {
    console.log("--------------------------------------------------------------------------------------------------");
    console.log(this._drawListLen + " draw list chunks");
    for (var i = 0, len = this._drawListLen; i < len; i++) {
        var chunk = this._drawList[i];
        console.log("[chunk " + i + "] type = " + chunk.type);
        switch (chunk.type) {
            case "draw":
                console.log("\n");
                break;
            case "renderTarget":
                console.log(" bufType = " + chunk.core.bufType);
                break;
        }
    }
    console.log("--------------------------------------------------------------------------------------------------");
};

/**
 * Logs the contents of the pick list to the console.
 * @private
 */
SceneJS_Display.prototype._logPickList = function () {
    console.log("--------------------------------------------------------------------------------------------------");
    console.log(this._pickDrawListLen + " pick list chunks");
    for (var i = 0, len = this._pickDrawListLen; i < len; i++) {
        var chunk = this._pickDrawList[i];
        console.log("[chunk " + i + "] type = " + chunk.type);
        switch (chunk.type) {
            case "draw":
                console.log("\n");
                break;
            case "renderTarget":
                console.log(" bufType = " + chunk.core.bufType);
                break;
        }
    }
    console.log("--------------------------------------------------------------------------------------------------");
};

(function () {

    // Cached vectors to avoid garbage collection

    var origin = SceneJS_math_vec3();
    var dir = SceneJS_math_vec3();

    var a = SceneJS_math_vec3();
    var b = SceneJS_math_vec3();
    var c = SceneJS_math_vec3();

    var na = SceneJS_math_vec3();
    var nb = SceneJS_math_vec3();
    var nc = SceneJS_math_vec3();

    var uva = SceneJS_math_vec3();
    var uvb = SceneJS_math_vec3();
    var uvc = SceneJS_math_vec3();

    var tempMat4 = SceneJS_math_mat4();
    var tempMat4b = SceneJS_math_mat4();

    var tempVec4 = SceneJS_math_vec4();
    var tempVec4b = SceneJS_math_vec4();

    var tempVec3 = SceneJS_math_vec3();
    var tempVec3b = SceneJS_math_vec3();
    var tempVec3c = SceneJS_math_vec3();
    var tempVec3d = SceneJS_math_vec3();

    var tempVec2 = SceneJS_math_vec2();
    var tempVec2b = SceneJS_math_vec2();
    var tempVec2c = SceneJS_math_vec2();
    var tempVec2d = SceneJS_math_vec2();


    // Given an Object and canvas coordinates, gets a ray
    // originating at the World-space eye position that passes
    // through the perspective projection plane. The ray is
    // returned via the origin and dir arguments.

    function getLocalRay(canvas, object, canvasCoords, origin, dir) {

        var modelMat = object.modelTransform.mat;
        var viewMat = object.viewTransform.mat;
        var projMat = object.projTransform.mat;

        var vmMat = SceneJS_math_mulMat4(viewMat, modelMat, tempMat4);
        var pvMat = SceneJS_math_mulMat4(projMat, vmMat, tempMat4b);
        var pvMatInverse = SceneJS_math_inverseMat4(pvMat, tempMat4b);

        //var modelMatInverse = math.inverseMat4(modelMat, tempMat4c);

        // Calculate clip space coordinates, which will be in range
        // of x=[-1..1] and y=[-1..1], with y=(+1) at top

        var canvasWidth = canvas.width;
        var canvasHeight = canvas.height;

        var clipX = (canvasCoords[0] - canvasWidth / 2) / (canvasWidth / 2);  // Calculate clip space coordinates
        var clipY = -(canvasCoords[1] - canvasHeight / 2) / (canvasHeight / 2);

        var local1 = SceneJS_math_transformVector4(pvMatInverse, [clipX, clipY, -1, 1], tempVec4);
        local1 = SceneJS_math_mulVec4Scalar(local1, 1 / local1[3]);

        var local2 = SceneJS_math_transformVector4(pvMatInverse, [clipX, clipY, 1, 1], tempVec4b);
        local2 = SceneJS_math_mulVec4Scalar(local2, 1 / local2[3]);

        origin[0] = local1[0];
        origin[1] = local1[1];
        origin[2] = local1[2];

        SceneJS_math_subVec3(local2, local1, dir);

        SceneJS_math_normalizeVec3(dir);
    }

    /**
     * Performs a pick on the display graph and returns info on the result.
     * @param {*} params
     * @returns {*}
     */
    SceneJS_Display.prototype.pick = function (params) {

        var canvas = this._canvas.canvas;
        var resolutionScaling = this._canvas.resolutionScaling;
        var canvasX = params.canvasX * resolutionScaling;
        var canvasY = params.canvasY * resolutionScaling;
        var canvasPos = [canvasX, canvasY];
        var pickBuf = this.pickBuf;
        var hit = null;
        var object;
        var i;
        var len;

        // Lazy-create pick buffer

        if (!pickBuf) {
            pickBuf = this.pickBuf = new SceneJS._webgl.RenderBuffer({
                canvas: this._canvas
            });
        }

        this.render(); // Do any pending visible render

        //------------------------------------------------------------------
        // Pick an object using color-indexed render
        //------------------------------------------------------------------

        pickBuf.bind();

        pickBuf.clear();

        this._doDrawList({
            pickObject: true,
            clear: true
        });

        this._canvas.gl.finish();

        // Read pixel color in pick buffer at given coordinates,
        // convert to an index into the pick name list

        var pix = pickBuf.read(canvasX, canvasY);

        var pickedColorIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);

        object = this._objectPickList[pickedColorIndex];

        if (object) {

            hit = {
                canvasPos: canvasPos
            };

            var name = object.name;

            if (name) {
                hit.name = name.name;
                hit.path = name.path;
                hit.nodeId = name.nodeId;
            }
        }

        if (params.pickRegion) {

            //------------------------------------------------------------------
            // Pick a region
            // Region picking is independent of having picked an object
            //------------------------------------------------------------------

            pickBuf.clear();

            this._doDrawList({
                pickRegion: true,
                object: object,
                clear: true
            });

            pix = pickBuf.read(canvasX, canvasY);

            if (pix[0] !== 0 || pix[1] !== 0 || pix[2] !== 0 || pix[3] !== 0) {

                hit = hit || {
                        canvasPos: canvasPos
                    };

                var regionColor = {r: pix[0] / 255, g: pix[1] / 255, b: pix[2] / 255, a: pix[3] / 255};
                var regionData = this._frameCtx.regionData;
                var tolerance = 0.01;
                var data = {};
                var color, delta;

                for (i = 0, len = regionData.length; i < len; i++) {
                    color = regionData[i].color;
                    if (regionColor && regionData[i].data) {
                        delta = Math.max(
                            Math.abs(regionColor.r - color.r),
                            Math.abs(regionColor.g - color.g),
                            Math.abs(regionColor.b - color.b),
                            Math.abs(regionColor.a - (color.a === undefined ? regionColor.a : color.a))
                        );

                        if (delta < tolerance) {
                            data = regionData[i].data;
                            break;
                        }
                    }
                }

                hit.color = regionColor;
                hit.regionData = data;
            }
        }

        if (params.pickTriangle && object) {

            //------------------------------------------------------------------
            // Pick a triangle on the picked object
            //------------------------------------------------------------------

            pickBuf.clear();

            this._doDrawList({
                pickTriangle: true,
                object: object,
                clear: true
            });

            pix = pickBuf.read(canvasX, canvasY);
            var primitiveIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);
            primitiveIndex *= 3; // Convert from triangle number to first vertex in indices

            hit.primitiveIndex = primitiveIndex;

            var geometry = object.geometry;

            if (geometry.primitiveName === "triangles") {

                // Triangle picked; this only happens when the
                // GameObject has a Geometry that has primitives of type "triangle"

                hit.primitive = "triangle";

                // Attempt to ray-pick the triangle; in World-space, fire a ray
                // from the eye position through the mouse position
                // on the perspective projection plane

                getLocalRay(canvas, object, canvasPos, origin, dir);

                // Get triangle indices

                var indices = geometry.arrays.indices;

                var ia = indices[primitiveIndex];
                var ib = indices[primitiveIndex + 1];
                var ic = indices[primitiveIndex + 2];

                var ia3 = ia * 3;
                var ib3 = ib * 3;
                var ic3 = ic * 3;

                var triangleVertices = SceneJS_math_vec3();

                triangleVertices[0] = ia;
                triangleVertices[1] = ib;
                triangleVertices[2] = ic;

                hit.indices = triangleVertices;

                // Get World-space triangle vertex positions

                var morphGeometry = object.morphGeometry;
                var targets = morphGeometry.targets;

                if (targets && targets.length > 0 && targets[0].positions) {

                    // Positions from morphGeometry

                    this._lerpTargets(
                        morphGeometry.keys,
                        morphGeometry.targets,
                        "positions",
                        ia, ib, ic,
                        morphGeometry.factor,
                        a, b, c);

                } else {

                    // Positions from static geometry

                    var positions = geometry.arrays.positions;

                    a[0] = positions[ia3];
                    a[1] = positions[ia3 + 1];
                    a[2] = positions[ia3 + 2];

                    b[0] = positions[ib3];
                    b[1] = positions[ib3 + 1];
                    b[2] = positions[ib3 + 2];

                    c[0] = positions[ic3];
                    c[1] = positions[ic3 + 1];
                    c[2] = positions[ic3 + 2];
                }


                // Get Local-space cartesian coordinates of the ray-triangle intersection

                var position = hit.position = SceneJS_math_rayPlaneIntersect(origin, dir, a, b, c, SceneJS_math_vec3());

                // Get interpolated World-space coordinates

                // Need to transform homogeneous coords

                tempVec4.set(position);
                tempVec4[3] = 1;

                // Get World-space cartesian coordinates of the ray-triangle intersection

                SceneJS_math_transformVector4(object.modelTransform.mat, tempVec4, tempVec4b);

                hit.worldPos = SceneJS._sliceArray(tempVec4b, 0, 3);

                // Get barycentric coordinates of the ray-triangle intersection

                var barycentric = hit.barycentric = SceneJS_math_cartesianToBarycentric2(position, a, b, c, SceneJS_math_vec3());

                // Get interpolated normal vector

                var gotNormals = false;

                if (targets && targets.length > 0 && targets[0].normals) {

                    // Normals from morphGeometry

                    this._lerpTargets(
                        morphGeometry.keys,
                        morphGeometry.targets,
                        "normals",
                        ia, ib, ic,
                        morphGeometry.factor,
                        na, nb, nc);

                    gotNormals = true;
                }

                if (!gotNormals) {

                    // Normals from static geometry

                    var normals = geometry.arrays.normals;

                    if (normals) {

                        na[0] = normals[ia3];
                        na[1] = normals[ia3 + 1];
                        na[2] = normals[ia3 + 2];

                        nb[0] = normals[ib3];
                        nb[1] = normals[ib3 + 1];
                        nb[2] = normals[ib3 + 2];

                        nc[0] = normals[ic3];
                        nc[1] = normals[ic3 + 1];
                        nc[2] = normals[ic3 + 2];

                        gotNormals = true;
                    }
                }

                if (gotNormals) {

                    // Interpolate on triangle

                    hit.normal = SceneJS_math_addVec3(SceneJS_math_addVec3(
                            SceneJS_math_mulVec3Scalar(na, barycentric[0], tempVec3),
                            SceneJS_math_mulVec3Scalar(nb, barycentric[1], tempVec3b), tempVec3c),
                        SceneJS_math_mulVec3Scalar(nc, barycentric[2], tempVec3d), SceneJS_math_vec3());
                }

                // Get interpolated UV coordinates in each UV layer

                var uvLayers = geometry.arrays.uvs;

                if (uvLayers && uvLayers.length > 0) {

                    hit.uvs = []; // TODO: Optimize for GC

                    var uvs;
                    var uv;
                    var ia2 = ia * 2;
                    var ib2 = ib * 2;
                    var ic2 = ic * 2;

                    for (i = 0, len = uvLayers.length; i < len; i++) {

                        uvs = uvLayers[i];

                        if (!uvs) {

                            uvs.push(null);

                        } else {

                            uva[0] = uvs[ia2];
                            uva[1] = uvs[ia2 + 1];

                            uvb[0] = uvs[ib2];
                            uvb[1] = uvs[ib2 + 1];

                            uvc[0] = uvs[ic2];
                            uvc[1] = uvs[ic2 + 1];

                            uv = SceneJS_math_addVec2(
                                SceneJS_math_addVec2(
                                    SceneJS_math_mulVec2Scalar(uva, barycentric[0], tempVec2),
                                    SceneJS_math_mulVec2Scalar(uvb, barycentric[1], tempVec2b), tempVec2c),
                                SceneJS_math_mulVec2Scalar(uvc, barycentric[2], tempVec2d), SceneJS_math_vec2());

                            hit.uvs.push(uv);
                        }
                    }

                    if (uvLayers.length > 0) {
                        hit.uv = hit.uvs[0]; // Backward compatibility
                    }
                }
            }
        }

        pickBuf.unbind();

        return hit;
    };

    SceneJS_Display.prototype._lerpTargets = function (times,
                                                       targets,
                                                       arrayName,
                                                       ia, ib, ic,
                                                       time,
                                                       a, b, c) {

        // Trivial case in which we can just return the
        // positions at a target matching the given time

        for (var i = 0; i < times.length; i++) {
            if (times[i] === time) {

                var array = targets[i][arrayName];

                var ia3 = ia * 3;
                var ib3 = ib * 3;
                var ic3 = ic * 3;

                a[0] = array[ia3];
                a[1] = array[ia3 + 1];
                a[2] = array[ia3 + 2];

                b[0] = array[ib3];
                b[1] = array[ib3 + 1];
                b[2] = array[ib3 + 2];

                c[0] = array[ic3];
                c[1] = array[ic3 + 1];
                c[2] = array[ic3 + 2];

                return;
            }
        }

        // Find the indexes of the targets that enclose the given time

        var i2 = 0;

        while (times[i2] < time) {
            i2++;
        }

        var i1 = i2 - 1;

        this._lerpTargetPair(
            time,
            times[i1],
            times[i2],
            targets[i1][arrayName],
            targets[i2][arrayName],
            ia, ib, ic,
            a, b, c
        );
    };

    var a1 = SceneJS_math_vec3();
    var b1 = SceneJS_math_vec3();
    var c1 = SceneJS_math_vec3();
    var a2 = SceneJS_math_vec3();
    var b2 = SceneJS_math_vec3();
    var c2 = SceneJS_math_vec3();

    SceneJS_Display.prototype._lerpTargetPair = function (time, time1, time2, target1, target2, ia, ib, ic, a, b, c) {

        var ia3 = ia * 3;
        var ib3 = ib * 3;
        var ic3 = ic * 3;

        a1[0] = target1[ia3];
        a1[1] = target1[ia3 + 1];
        a1[2] = target1[ia3 + 2];

        b1[0] = target1[ib3];
        b1[1] = target1[ib3 + 1];
        b1[2] = target1[ib3 + 2];

        c1[0] = target1[ic3];
        c1[1] = target1[ic3 + 1];
        c1[2] = target1[ic3 + 2];

        a2[0] = target2[ia3];
        a2[1] = target2[ia3 + 1];
        a2[2] = target2[ia3 + 2];

        b2[0] = target2[ib3];
        b2[1] = target2[ib3 + 1];
        b2[2] = target2[ib3 + 2];

        c2[0] = target2[ic3];
        c2[1] = target2[ic3 + 1];
        c2[2] = target2[ic3 + 2];

        SceneJS_math_lerpVec3(time, time1, time2, a1, a2, a);
        SceneJS_math_lerpVec3(time, time1, time2, b1, b2, b);
        SceneJS_math_lerpVec3(time, time1, time2, c1, c2, c);
    };

})();

/** Renders either the draw or pick list.
 *
 * @param {*} params
 * @param {Boolean} params.clear Set true to clear the color, depth and stencil buffers first
 * @param {*} params.object Object to render chunks of, for pickTriangle or pickRegion modes
 * @param {Boolean} params.pickObject Set true to render for object-picking, using per-object indexed color
 * @param {Boolean} params.pickTriangle Set true to render for triangle-picking, using per-triangle indexed color
 * @param {Boolean} params.pickRegion Set true to render for region-picking
 * @param {Boolean} params.transparent Set false to only render opaque objects
 * @private
 */
SceneJS_Display.prototype._doDrawList = function (params) {

    var gl = this._canvas.gl;

    // Reset frame context
    var frameCtx = this._frameCtx;

    frameCtx.renderTarget = null;
    frameCtx.targetIndex = 0;
    frameCtx.renderBuf = null;
    frameCtx.viewMat = null;
    frameCtx.modelMat = null;
    frameCtx.cameraMat = null;
    frameCtx.renderer = null;
    frameCtx.depthbufEnabled = null;
    frameCtx.clearDepth = null;
    frameCtx.depthFunc = gl.LESS;
    frameCtx.stencilbufEnabled = null;
    frameCtx.clearStencil = null;

    // frameCtx.stencilFuncFront = {func: gl.ALWAYS, ref: 1, mask: 0xff};
    // frameCtx.stencilFuncBack = {func: gl.ALWAYS, ref: 1, mask: 0xff};
    // frameCtx.stencilOpFront = {sfail: gl.KEEP, dpfail: gl.KEEP, dppass: gl.KEEP};
    // frameCtx.stencilOpBack = {sfail: gl.KEEP, dpfail: gl.KEEP, dppass: gl.KEEP};
    
    frameCtx.stencilFuncFuncFront = gl.ALWAYS;
    frameCtx.stencilFuncRefFront = 0;
    frameCtx.stencilFuncMaskFront = 0xff;

    frameCtx.stencilFuncFuncBack = gl.ALWAYS;
    frameCtx.stencilFuncRefBack = 0;
    frameCtx.stencilFuncMaskBack = 0xff;

    frameCtx.stencilOpSfailFront = gl.KEEP;
    frameCtx.stencilOpDpfailFront = gl.KEEP;
    frameCtx.stencilOpDppassFront = gl.KEEP;

    frameCtx.stencilOpSfailBack = gl.KEEP;
    frameCtx.stencilOpDpfailBack = gl.KEEP;
    frameCtx.stencilOpDppassBack = gl.KEEP;

    frameCtx.scissorTestEnabled = false;
    frameCtx.blendEnabled = false;
    frameCtx.backfaces = true;
    frameCtx.frontface = "ccw";
    frameCtx.picking = !!params.pickObject || !!params.pickTriangle || !!params.pickRegion;
    frameCtx.pickObject = !!params.pickObject;
    frameCtx.pickTriangle = !!params.pickTriangle;
    frameCtx.pickRegion = !!params.pickRegion;
    frameCtx.pickIndex = 1;
    frameCtx.textureUnit = 0;
    frameCtx.lineWidth = 1;
    frameCtx.transparent = false;
    frameCtx.ambientColor = this._ambientColor;
    frameCtx.aspect = this._canvas.canvas.width / this._canvas.canvas.height;
    frameCtx.texture = null;
    frameCtx.normalMapUVLayerIdx = -1;
    frameCtx.regionMapUVLayerIdx = -1;
    frameCtx.drawElements = 0;
    frameCtx.drawArrays = 0;
    frameCtx.useProgram = 0;
    frameCtx.bindTexture = 0;
    frameCtx.bindArray = 0;

    // The extensions needs to be re-queried in case the context was lost and has been recreated.
    if (SceneJS.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"]) {
        gl.getExtension("OES_element_index_uint");
    }

    var VAO = gl.getExtension("OES_vertex_array_object");
    frameCtx.VAO = (VAO) ? VAO : null;

    this.stats.frame.setUniform = 0;
    this.stats.frame.setUniformCacheHits = 0;

    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

    if (this.transparent || frameCtx.picking) {
        gl.clearColor(0, 0, 0, 0);
    } else {
        gl.clearColor(this._ambientColor[0], this._ambientColor[1], this._ambientColor[2], 1.0);
    }

    if (params.clear) {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
    }

    gl.frontFace(gl.CCW);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.BLEND);

    if (params.pickObject) {

        // Pick object
        // Render whole draw list

        for (var i = 0, len = this._pickDrawListLen; i < len; i++) {
            this._pickDrawList[i].pick(frameCtx);
        }

        gl.flush();

    } else if (params.pickRegion || params.pickTriangle) {

        // Pick region or triangle

        if (params.object) {

            // Object was picked
            // Render just the chunks of the target object

            var chunks = params.object.chunks;
            var chunk;

            for (var i = 0, len = chunks.length; i < len; i++) {
                chunk = chunks[i];
                if (chunk && chunk.pick) {
                    chunk.pick(frameCtx);
                }
            }

        } else {

            // No object was picked
            // Render whole draw list

            if (params.pickRegion) {

                for (var i = 0, len = this._pickDrawListLen; i < len; i++) {
                    this._pickDrawList[i].pick(frameCtx);
                }
            }
        }

        gl.flush();

    } else {

        // Render scene
        // Render whole draw list

        var startTime = Date.now();

        // Option to only render opaque objects
        var len = (params.opaqueOnly && this._drawListTransparentIndex >= 0 ? this._drawListTransparentIndex : this._drawListLen);

        // Render for draw
        for (var i = 0; i < len; i++) {      // Push opaque rendering chunks
            this._drawList[i].draw(frameCtx);
        }

        gl.flush();

        var endTime = Date.now();

        this.stats.frame.renderTime = (endTime - startTime) / 1000.0;
        this.stats.frame.drawElements = frameCtx.drawElements;
        this.stats.frame.drawArrays = frameCtx.drawArrays;
        this.stats.frame.useProgram = frameCtx.useProgram;
        this.stats.frame.bindTexture = frameCtx.bindTexture;
        this.stats.frame.bindArray = frameCtx.bindArray;
        this.stats.frame.drawChunks = this._drawListLen;
    }

    if (frameCtx.renderBuf) {
        frameCtx.renderBuf.unbind();
    }

    if (frameCtx.VAO) {
        frameCtx.VAO.bindVertexArrayOES(null);
        for (var i = 0; i < 10; i++) {
            gl.disableVertexAttribArray(i);
        }
    }
//
//    var numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
//    for (var ii = 0; ii < numTextureUnits; ++ii) {
//        gl.activeTexture(gl.TEXTURE0 + ii);
//        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
//        gl.bindTexture(gl.TEXTURE_2D, null);
//    }
};

SceneJS_Display.prototype.readPixels = function (entries, size, opaqueOnly) {

    if (!this._readPixelBuf) {
        this._readPixelBuf = new SceneJS._webgl.RenderBuffer({canvas: this._canvas});
    }

    this._readPixelBuf.bind();

    this._readPixelBuf.clear();

    this.render({
        force: true,
        opaqueOnly: opaqueOnly
    });

    var entry;
    var color;

    for (var i = 0; i < size; i++) {

        entry = entries[i] || (entries[i] = {});

        color = this._readPixelBuf.read(entry.x, entry.y);

        entry.r = color[0];
        entry.g = color[1];
        entry.b = color[2];
        entry.a = color[3];
    }

    this._readPixelBuf.unbind();
};

/**
 * Unpacks a color-encoded depth
 * @param {Array(Number)} depthZ Depth encoded as an RGBA color value
 * @returns {Number}
 * @private
 */
SceneJS_Display.prototype._unpackDepth = function (depthZ) {
    var vec = [depthZ[0] / 256.0, depthZ[1] / 256.0, depthZ[2] / 256.0, depthZ[3] / 256.0];
    var bitShift = [1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0];
    return SceneJS_math_dotVector4(vec, bitShift);
};


SceneJS_Display.prototype.destroy = function () {
    this._programFactory.destroy();
};
;/**
 * @class Manages creation, sharing and recycle of {@link SceneJS_ProgramSource} instances
 * @private
 */
var SceneJS_ProgramSourceFactory = new (function () {

    var cache = {}; // Source codes are shared across all scenes

    var states; // Cache rendering state
    var diffuseFresnel;
    var specularFresnel;
    var alphaFresnel;
    var reflectFresnel;
    var emitFresnel;
    var fragmentFresnel;
    var fresnel;
    var texturing;// True when rendering state contains textures
    var cubeMapping;
    var normals;// True when rendering state contains normals
    var solid;
    var skybox;  // True when object should be treated as a skybox
    var billboard;
    var tangents;
    var clipping;
    var morphing;
    var regionMapping;
    var regionInteraction;
    var depthTargeting;
    var points;

    var src = ""; // Accumulates source code as it's being built

    /**
     * Get sourcecode for a program to render the given states
     */
    this.getSource = function (hash, _states) {

        var source = cache[hash];
        if (source) {
            source.useCount++;
            return source;
        }

        states = _states;

        diffuseFresnel = states.fresnel.diffuse;
        specularFresnel = states.fresnel.specular;
        alphaFresnel = states.fresnel.alpha;
        reflectFresnel = states.fresnel.reflect;
        emitFresnel = states.fresnel.emit;
        fragmentFresnel = states.fresnel.fragment;
        fresnel = diffuseFresnel || specularFresnel || alphaFresnel || reflectFresnel || emitFresnel || fragmentFresnel;
        texturing = hasTextures(states);
        cubeMapping = hasCubemap(states);
        normals = hasNormals(states);
        solid = states.flags.solid;
        skybox = states.flags.skybox;
        billboard = !states.billboard.empty;
        tangents = hasTangents(states);
        clipping = states.clips.clips.length > 0;
        morphing = !!states.morphGeometry.targets;
        regionMapping = hasRegionMap();
        regionInteraction = regionMapping && states.regionMap.mode !== "info";
        depthTargeting = hasDepthTarget();
        points = states.geometry.primitiveName === "points";

        source = new SceneJS_ProgramSource(
            hash,

            vertexPicking(states),
            fragmentPicking(states),

            vertexRendering(states),
            fragmentRendering(states)
        );

        cache[hash] = source;

        return source;
    };

    /**
     * Releases program source code
     */
    this.putSource = function (hash) {
        var source = cache[hash];
        if (source) {
            if (--source.useCount == 0) {
                cache[source.hash] = null;
            }
        }
    };

    function vertexPicking() {

        begin();

        add("attribute vec3 SCENEJS_aVertex;");
        add("attribute vec4 SCENEJS_aColor;");
        add("uniform mat4 SCENEJS_uMMatrix;");
        add("uniform mat4 SCENEJS_uVMatrix;");
        add("uniform mat4 SCENEJS_uVNMatrix;");
        add("uniform mat4 SCENEJS_uPMatrix;");

        if (points) {
            add("uniform float SCENEJS_uPointSize;");
        }

        add("varying vec4 SCENEJS_vWorldVertex;");

        if (regionMapping) {
            add("attribute vec2 SCENEJS_aRegionMapUV;");
            add("varying vec2 SCENEJS_vRegionMapUV;");
        }

        if (morphing) {
            add("uniform float SCENEJS_uMorphFactor;");       // LERP factor for morph
            if (states.morphGeometry.targets[0].vertexBuf) {      // target2 has these arrays also
                add("attribute vec3 SCENEJS_aMorphVertex;");
            }
        }

        add("varying vec4 SCENEJS_vColor;");

        add("void main(void) {");

        add("   vec4 tmpVertex=vec4(SCENEJS_aVertex, 1.0); ");

        if (morphing) {
            if (states.morphGeometry.targets[0].vertexBuf) {
                add("  tmpVertex = vec4(mix(tmpVertex.xyz, SCENEJS_aMorphVertex, SCENEJS_uMorphFactor), 1.0); ");
            }
        }
        add("  SCENEJS_vWorldVertex = SCENEJS_uMMatrix * tmpVertex; ");

        add("mat4 vPosMatrix = SCENEJS_uVMatrix;");

        if (skybox) {
            add("vPosMatrix[3].xyz = vec3(0.0);");
        }

        add("  gl_Position =  SCENEJS_uPMatrix * (vPosMatrix * SCENEJS_vWorldVertex);");

        if (regionMapping) {
            add("SCENEJS_vRegionMapUV = SCENEJS_aRegionMapUV;");
        }

        add("SCENEJS_vColor = SCENEJS_aColor;");

        if (points) {
            add("gl_PointSize = SCENEJS_uPointSize;");
        }

        add("}");

        return end();
    }

    function fragmentPicking() {

        begin();

        add("precision " + getFSFloatPrecision(states._canvas.gl) + " float;");

        add("varying vec4 SCENEJS_vWorldVertex;");
        add("varying vec4  SCENEJS_vColor;");

        add("uniform float  SCENEJS_uPickMode;");                   // Z-pick mode when true else colour-pick
        add("uniform vec4  SCENEJS_uPickColor;");                   // Used in colour-pick mode
        add("uniform bool  SCENEJS_uClipping;");

        if (clipping) {
            for (var i = 0; i < states.clips.clips.length; i++) {
                add("uniform float SCENEJS_uClipMode" + i + ";");
                add("uniform vec4  SCENEJS_uClipNormalAndDist" + i + ";");
            }
        }

        if (regionMapping) {
            add("varying vec2 SCENEJS_vRegionMapUV;");
            add("uniform sampler2D SCENEJS_uRegionMapSampler;");
        }

        add("void main(void) {");

        if (clipping) {
            add("if (SCENEJS_uClipping) {");
            add("  float dist = 0.0;");
            for (var i = 0; i < states.clips.clips.length; i++) {
                add("  if (SCENEJS_uClipMode" + i + " != 0.0) {");
                add("      dist += clamp(dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) - SCENEJS_uClipNormalAndDist" + i + ".w, 0.0, 1000.0);");
                add("  }");
            }
            add("  if (dist > 0.0) { discard; }");
            add("}");
        }

        add("    if  (SCENEJS_uPickMode == 0.0) {");  // Pick object
        add("          gl_FragColor = SCENEJS_uPickColor;  ");

        add("    } else if (SCENEJS_uPickMode == 1.0) {"); // Pick triangle
        add("          gl_FragColor = SCENEJS_vColor;  ");

        add("    } else {"); // Pick region
        if (regionMapping) {
            add("          gl_FragColor = texture2D(SCENEJS_uRegionMapSampler, vec2(SCENEJS_vRegionMapUV.s, 1.0 - SCENEJS_vRegionMapUV.t));");
        } else {
            add("          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);");
        }
        add("    }");
        add("}");

        return end();
    }

    function hasRegionMap() {
        if (!states.regionMap.empty) {
            return hasUVs();
        }
        return false;
    }

    function hasTextures() {
        if (states.texture.layers && states.texture.layers.length > 0) {
            return hasUVs();
        }
        return false;
    }

    function hasUVs() {
        if (states.geometry.uvBufs) { // TODO only if there is at least one defined member in this array
            return true;
        }
        if (states.morphGeometry.targets && (states.morphGeometry.targets[0].uvBuf || states.morphGeometry.targets[0].uvBuf2)) {
            return true;
        }
        return false;
    }

    function hasCubemap(states) {
        return (states.flags.reflective && states.cubemap.layers && states.cubemap.layers.length > 0 && states.geometry.normalBuf);
    }

    function hasNormals(states) {
        if (states.geometry.normalBuf) {
            return true;
        }
        if (states.morphGeometry.targets && states.morphGeometry.targets[0].normalBuf) {
            return true;
        }
        return false;
    }

    function hasTangents(states) {
        if (states.texture) {
            var layers = states.texture.layers;
            if (!layers) {
                return false;
            }
            for (var i = 0, len = layers.length; i < len; i++) {
                if (layers[i].applyTo == "normals") {
                    return true;
                }
            }
        }
        return false;
    }

    function hasDepthTarget() {
        if (states.renderTarget && states.renderTarget.targets) {
            var targets = states.renderTarget.targets;
            for (var i = 0, len = targets.length; i < len; i++) {
                if (targets[i].bufType === "depth") {
                    return true;
                }
            }
        }
        return false;
    }

    function vertexRendering() {

        var customShaders = states.shader.shaders || {};

        // Do a full custom shader replacement if code supplied without hooks
        if (customShaders.vertex
            && customShaders.vertex.code
            && customShaders.vertex.code != ""
            && SceneJS._isEmpty(customShaders.vertex.hooks)) {
            return [customShaders.vertex.code];
        }

        var customVertexShader = customShaders.vertex || {};
        var vertexHooks = customVertexShader.hooks || {};

        var customFragmentShader = customShaders.fragment || {};
        var fragmentHooks = customFragmentShader.hooks || {};

        var i;
        var uvBufs;

        begin();

        add("uniform mat4 SCENEJS_uMMatrix;");             // Model matrix
        add("uniform mat4 SCENEJS_uVMatrix;");             // View matrix
        add("uniform mat4 SCENEJS_uPMatrix;");             // Projection matrix

        add("attribute vec3 SCENEJS_aVertex;");            // Model coordinates

        add("uniform vec3 SCENEJS_uWorldEye;");            // World-space eye position

        add("varying vec3 SCENEJS_vViewEyeVec;");          // View-space vector from origin to eye

        if (points) {
            add("uniform float SCENEJS_uPointSize;");
        }

        if (normals) {

            add("attribute vec3 SCENEJS_aNormal;");        // Normal vectors
            add("uniform   mat4 SCENEJS_uMNMatrix;");      // Model normal matrix
            add("uniform   mat4 SCENEJS_uVNMatrix;");      // View normal matrix

            add("varying   vec3 SCENEJS_vViewNormal;");    // Output view-space vertex normal

            if (fresnel) {
                add("varying   vec3 SCENEJS_vWorldNormal;");    // Output view-space vertex normal
            }

            if (tangents) {
                add("attribute vec4 SCENEJS_aTangent;");
                add("varying   vec3 SCENEJS_vTangent;");
            }
        }

        if (texturing) {

            uvBufs = states.geometry.uvBufs;

            if (uvBufs) {
                for (var i = 0, len = uvBufs.length; i < len; i++) {
                    if (uvBufs[i]) {
                        add("attribute vec2 SCENEJS_aUVCoord" + i + ";");
                    }
                }
            }
        }

        if (states.geometry.colorBuf) {
            add("attribute vec4 SCENEJS_aVertexColor;");
            add("varying vec4 SCENEJS_vColor;");               // Varying for fragment texturing
        }

        if (clipping || normals) {
            add("varying vec4 SCENEJS_vWorldVertex;");         // Varying for fragment clip or world pos hook
        }

        add("varying vec4 SCENEJS_vViewVertex;");              // Varying for fragment view clip hook

        if ( texturing) {                                            // Varyings for fragment texturing

            uvBufs = states.geometry.uvBufs;

            if (uvBufs) {
                for (i = 0, len = uvBufs.length; i < len; i++) {
                    if (uvBufs[i]) {
                        add("varying vec2 SCENEJS_vUVCoord" + i + ";");
                    }
                }
            }
        }

        if (regionInteraction) {
            add("attribute vec2 SCENEJS_aRegionMapUV;");
            add("varying vec2 SCENEJS_vRegionMapUV;");
        }

        if (morphing) {
            add("uniform float SCENEJS_uMorphFactor;");       // LERP factor for morph
            if (states.morphGeometry.targets[0].vertexBuf) {      // target2 has these arrays also
                add("attribute vec3 SCENEJS_aMorphVertex;");
            }
            if (normals) {
                if (states.morphGeometry.targets[0].normalBuf) {
                    add("attribute vec3 SCENEJS_aMorphNormal;");
                }
            }
            if (tangents) {
                //if (states.morphGeometry.targets[0].normalBuf) {
                    add("attribute vec3 SCENEJS_aMorphTangent;");
               // }
            }
        }

        if (customVertexShader.code) {
            add("\n" + customVertexShader.code + "\n");
        }

        if (billboard) {

            // Billboarding function which modifies the rotation
            // elements of the given matrix

            add("void billboard(inout mat4 mat) {");
            add("   mat[0][0] = 1.0;");
            add("   mat[0][1] = 0.0;");
            add("   mat[0][2] = 0.0;");
            if (states.billboard.spherical) {
                add("   mat[1][0] = 0.0;");
                add("   mat[1][1] = 1.0;");
                add("   mat[1][2] = 0.0;");
            }
            add("   mat[2][0] = 0.0;");
            add("   mat[2][1] = 0.0;");
            add("   mat[2][2] =1.0;");
            add("}");
        }

        add("void main(void) {");

        if (tangents) {
            add("vec3 modelTangent = SCENEJS_aTangent.xyz;");
        }

        add("  vec4 tmpVertex=vec4(SCENEJS_aVertex, 1.0); ");

        add("  vec4 modelVertex = tmpVertex; ");

        if (normals) {
            add("  vec4 modelNormal = vec4(SCENEJS_aNormal, 0.0); ");
        }

        // Morphing - morph targets are in same model space as the geometry
        if (morphing) {
            if (states.morphGeometry.targets[0].vertexBuf) {
                add("  vec4 vMorphVertex = vec4(SCENEJS_aMorphVertex, 1.0); ");
                add("  modelVertex = vec4(mix(modelVertex.xyz, vMorphVertex.xyz, SCENEJS_uMorphFactor), 1.0); ");
            }
            if (normals) {
                if (states.morphGeometry.targets[0].normalBuf) {
                    add("  vec4 vMorphNormal = vec4(SCENEJS_aMorphNormal, 1.0); ");
                    add("  modelNormal = vec4( mix(modelNormal.xyz, vMorphNormal.xyz, SCENEJS_uMorphFactor), 1.0); ");
                }
            }
            if (tangents) {
                add("  modelTangent = mix(modelTangent, SCENEJS_aMorphTangent, SCENEJS_uMorphFactor); ");
            }
        }

        add("mat4 modelMatrix = SCENEJS_uMMatrix;");
        add("mat4 viewMatrix = SCENEJS_uVMatrix;");

        if (normals) {
            add("mat4 modelNormalMatrix = SCENEJS_uMNMatrix;");
            add("mat4 viewNormalMatrix = SCENEJS_uVNMatrix;");
        }

        add("vec4 worldVertex;");
        add("vec4 viewVertex;");

        if (skybox) {
            add("viewMatrix[3].xyz = vec3(0.0);");
        }

        if (billboard) {

            // Since billboard effect is not preserved
            // in the product of two billboarded matrices,
            // we need to get the product of the model and
            // view matrices and billboard that

            add("   mat4 modelViewMatrix =  viewMatrix * modelMatrix;");

            add("   billboard(modelMatrix);");
            add("   billboard(viewMatrix);");
            add("   billboard(modelViewMatrix);");

            if (normals) {

                add("   mat4 modelViewNormalMatrix = viewNormalMatrix * modelNormalMatrix;");

                add("   billboard(modelNormalMatrix);");
                add("   billboard(viewNormalMatrix);");
                add("   billboard(modelViewNormalMatrix);");
            }

            if (vertexHooks.viewMatrix) {
                add("viewMatrix = " + vertexHooks.viewMatrix + "(viewMatrix);");
            }

            add("   worldVertex = modelMatrix * modelVertex;");
            add("   viewVertex = modelViewMatrix * modelVertex;");

        } else {

            if (vertexHooks.viewMatrix) {
                add("viewMatrix = " + vertexHooks.viewMatrix + "(viewMatrix);");
            }

            add("  worldVertex = modelMatrix * modelVertex;");
            add("  viewVertex  = viewMatrix * worldVertex; ");
        }

        if (vertexHooks.viewPos) {
            add("viewVertex=" + vertexHooks.viewPos + "(viewVertex);");    // Vertex hook function
        }

        if (normals) {
            add("  vec3 worldNormal = (modelNormalMatrix * modelNormal).xyz; ");
            add("  SCENEJS_vViewNormal = (viewNormalMatrix * vec4(worldNormal, 1.0)).xyz;");

            if (fresnel) {
                add("  SCENEJS_vWorldNormal = worldNormal;");
            }
        }

        if (clipping || normals || fragmentHooks.worldPos) {
            add("  SCENEJS_vWorldVertex = worldVertex;");                  // Varying for fragment world clip or hooks
        }

        add("  SCENEJS_vViewVertex = viewVertex;");                    // Varying for fragment hooks

        if (vertexHooks.projMatrix) {
            add("gl_Position = " + vertexHooks.projMatrix + "(SCENEJS_uPMatrix) * viewVertex;");
        } else {
            add("  gl_Position = SCENEJS_uPMatrix * viewVertex;");
        }

        if (tangents) {

            // Compute tangent-bitangent-normal matrix

            add("modelTangent = normalize((viewNormalMatrix * modelNormalMatrix * vec4(modelTangent, 1.0)).xyz);");
            add("vec3 bitangent = cross(SCENEJS_vViewNormal, modelTangent);");
            add("mat3 TBM = mat3(modelTangent, bitangent, SCENEJS_vViewNormal);");

            add("SCENEJS_vTangent = modelTangent;");
        }

        add("SCENEJS_vViewEyeVec = ((viewMatrix * vec4(SCENEJS_uWorldEye, 0.0)).xyz  - viewVertex.xyz);");

        if (tangents) {

            add("SCENEJS_vViewEyeVec *= TBM;");
        }

        if (texturing) {

            uvBufs = states.geometry.uvBufs;

            if (uvBufs) {
                for (i = 0, len = uvBufs.length; i < len; i++) {
                    if (uvBufs[i]) {
                        add("SCENEJS_vUVCoord" + i + " = SCENEJS_aUVCoord" + i + ";");
                    }
                }
            }
        }

        if (states.geometry.colorBuf) {
            add("SCENEJS_vColor = SCENEJS_aVertexColor;");
        }

        if (regionInteraction) {
            add("SCENEJS_vRegionMapUV = SCENEJS_aRegionMapUV;");
        }

        if (points) {
            add("gl_PointSize = SCENEJS_uPointSize;");
        }

        add("}");

        return end();
    }


    /*-----------------------------------------------------------------------------------------------------------------
     * Rendering Fragment shader
     *---------------------------------------------------------------------------------------------------------------*/

    function fragmentRendering() {

        var customShaders = states.shader.shaders || {};

        // Do a full custom shader replacement if code supplied without hooks
        if (customShaders.fragment
            && customShaders.fragment.code
            && customShaders.fragment.code != ""
            && SceneJS._isEmpty(customShaders.fragment.hooks)) {
            return [customShaders.fragment.code];
        }

        var customFragmentShader = customShaders.fragment || {};
        var fragmentHooks = customFragmentShader.hooks || {};


        var diffuseFresnel = states.fresnel.diffuse;
        var specularFresnel = states.fresnel.specular;
        var alphaFresnel = states.fresnel.alpha;
        var reflectFresnel = states.fresnel.reflect;
        var emitFresnel = states.fresnel.emit;
        var fragmentFresnel = states.fresnel.fragment;

        begin();

        add("precision " + getFSFloatPrecision(states._canvas.gl) + " float;");

        add("uniform mat4 SCENEJS_uVMatrix;");

        if (clipping || normals) {
            add("varying vec4 SCENEJS_vWorldVertex;");             // World-space vertex
        }

        //  if (fragmentHooks.viewPos) {
        add("varying vec4 SCENEJS_vViewVertex;");              // View-space vertex
        //  }

        add("uniform float SCENEJS_uZNear;");                      // Used in Z-pick mode
        add("uniform float SCENEJS_uZFar;");                       // Used in Z-pick mode

        add("uniform vec3 SCENEJS_uWorldEye;");


        /*-----------------------------------------------------------------------------------
         * Variables
         *----------------------------------------------------------------------------------*/

        if (clipping) {
            for (var i = 0; i < states.clips.clips.length; i++) {
                add("uniform float SCENEJS_uClipMode" + i + ";");
                add("uniform vec4  SCENEJS_uClipNormalAndDist" + i + ";");
            }
        }

        if (texturing) {
            var uvBufs = states.geometry.uvBufs;
            if (uvBufs) {
                for (var i = 0, len = uvBufs.length; i < len; i++) {
                    if (uvBufs[i]) {
                        add("varying vec2  SCENEJS_vUVCoord" + i + ";");
                    }
                }
            }

            if (texturing) {
                var layer;
                for (var i = 0, len = states.texture.layers.length; i < len; i++) {
                    layer = states.texture.layers[i];
                    add("uniform sampler2D SCENEJS_uSampler" + i + ";");
                    if (layer.matrix) {
                        add("uniform mat4 SCENEJS_uLayer" + i + "Matrix;");
                    }
                    add("uniform float SCENEJS_uLayer" + i + "BlendFactor;");
                }
            }
        }

        if (normals && cubeMapping) {

            var layer;
            for (var i = 0, len = states.cubemap.layers.length; i < len; i++) {
                layer = states.cubemap.layers[i];
                add("uniform samplerCube SCENEJS_uCubeMapSampler" + i + ";");
                add("uniform float SCENEJS_uCubeMapIntensity" + i + ";");
            }
        }

        if (regionInteraction) {
            add("varying vec2 SCENEJS_vRegionMapUV;");
            add("uniform sampler2D SCENEJS_uRegionMapSampler;");
            add("uniform vec3 SCENEJS_uRegionMapRegionColor;");
            add("uniform vec3 SCENEJS_uRegionMapHighlightFactor;");
            add("uniform float SCENEJS_uRegionMapHideAlpha;");
        }

        // True when lighting
        add("uniform bool  SCENEJS_uClipping;");

        if (solid) {
            add("uniform vec3  SCENEJS_uSolidColor;");
        }

        // Added in v4.0 to support depth targets
        add("uniform bool  SCENEJS_uDepthMode;");

        /* True when rendering transparency
         */
        add("uniform bool  SCENEJS_uTransparent;");

        /* Vertex color variable
         */
        if (states.geometry.colorBuf) {
            add("varying vec4 SCENEJS_vColor;");
        }

        add("uniform vec3  SCENEJS_uAmbientColor;");                         // Scene ambient colour - taken from clear colour

        add("uniform vec3  SCENEJS_uMaterialColor;");
        add("uniform vec3  SCENEJS_uMaterialSpecularColor;");
        add("uniform vec3  SCENEJS_uMaterialEmitColor;");

        add("uniform float SCENEJS_uMaterialSpecular;");
        add("uniform float SCENEJS_uMaterialShine;");
        add("uniform float SCENEJS_uMaterialAlpha;");
        add("uniform float SCENEJS_uMaterialEmit;");

        if (diffuseFresnel) {
            add("uniform float SCENEJS_uDiffuseFresnelCenterBias;");
            add("uniform float SCENEJS_uDiffuseFresnelEdgeBias;");
            add("uniform float SCENEJS_uDiffuseFresnelPower;");
            add("uniform vec3 SCENEJS_uDiffuseFresnelCenterColor;");
            add("uniform vec3 SCENEJS_uDiffuseFresnelEdgeColor;");
        }

        if (specularFresnel) {
            add("uniform float SCENEJS_uSpecularFresnelCenterBias;");
            add("uniform float SCENEJS_uSpecularFresnelEdgeBias;");
            add("uniform float SCENEJS_uSpecularFresnelPower;");
            add("uniform vec3 SCENEJS_uSpecularFresnelCenterColor;");
            add("uniform vec3 SCENEJS_uSpecularFresnelEdgeColor;");
        }

        if (alphaFresnel) {
            add("uniform float SCENEJS_uAlphaFresnelCenterBias;");
            add("uniform float SCENEJS_uAlphaFresnelEdgeBias;");
            add("uniform float SCENEJS_uAlphaFresnelPower;");
            add("uniform vec3 SCENEJS_uAlphaFresnelCenterColor;");
            add("uniform vec3 SCENEJS_uAlphaFresnelEdgeColor;");
        }

        if (reflectFresnel) {
            add("uniform float SCENEJS_uReflectFresnelCenterBias;");
            add("uniform float SCENEJS_uReflectFresnelEdgeBias;");
            add("uniform float SCENEJS_uReflectFresnelPower;");
            add("uniform vec3 SCENEJS_uReflectFresnelCenterColor;");
            add("uniform vec3 SCENEJS_uReflectFresnelEdgeColor;");
        }

        if (emitFresnel) {
            add("uniform float SCENEJS_uEmitFresnelCenterBias;");
            add("uniform float SCENEJS_uEmitFresnelEdgeBias;");
            add("uniform float SCENEJS_uEmitFresnelPower;");
            add("uniform vec3 SCENEJS_uEmitFresnelCenterColor;");
            add("uniform vec3 SCENEJS_uEmitFresnelEdgeColor;");
        }

        if (fragmentFresnel) {
            add("uniform float SCENEJS_uFragmentFresnelCenterBias;");
            add("uniform float SCENEJS_uFragmentFresnelEdgeBias;");
            add("uniform float SCENEJS_uFragmentFresnelPower;");
            add("uniform vec3 SCENEJS_uFragmentFresnelCenterColor;");
            add("uniform vec3 SCENEJS_uFragmentFresnelEdgeColor;");
        }

        add("varying vec3 SCENEJS_vViewEyeVec;");                          // Direction of world-space vertex from eye

        if (normals) {

            add("uniform mat4 SCENEJS_uVNMatrix;");
            add("varying vec3 SCENEJS_vViewNormal;");

            if (fresnel) {
                add("varying vec3 SCENEJS_vWorldNormal;");
            }

            if (tangents) {
                add("varying vec3 SCENEJS_vTangent;");
            }
            var light;
            for (var i = 0; i < states.lights.lights.length; i++) {
                light = states.lights.lights[i];
                if (light.mode == "ambient") {
                    continue;
                }
                add("uniform vec3  SCENEJS_uLightColor" + i + ";");

                if (light.mode == "dir") {
                    add("uniform vec3 SCENEJS_uLightDir" + i + ";");
                }

                if (light.mode == "point") {
                    add("uniform vec3  SCENEJS_uLightAttenuation" + i + ";");
                    add("uniform vec3 SCENEJS_uLightPos" + i + ";");
                }

                if (light.mode == "spot") {
                    add("uniform vec3  SCENEJS_uLightAttenuation" + i + ";");
                    add("uniform vec3 SCENEJS_uLightPos" + i + ";");
                    add("uniform vec3 SCENEJS_uLightDir" + i + ";");
                    add("uniform float SCENEJS_uInnerCone" + i + ";");
                    add("uniform float SCENEJS_uOuterCone" + i + ";");
                }

            }
        }

        if (customFragmentShader.code) {
            add("\n" + customFragmentShader.code + "\n");
        }

        if (diffuseFresnel || specularFresnel || alphaFresnel || reflectFresnel || emitFresnel || fragmentFresnel) {
            add("float fresnel(vec3 viewDirection, vec3 worldNormal, float edgeBias, float centerBias, float power) {");
            add("    float fr = abs(dot(viewDirection, worldNormal));");
            add("    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);");
            add("    return pow(finalFr, power);");
            add("}");
        }

        add("void main(void) {");

        // World-space arbitrary clipping planes

        if (clipping) {
            add("if (SCENEJS_uClipping) {");
            add("  float dist = 0.0;");
            for (var i = 0; i < states.clips.clips.length; i++) {
                add("  if (SCENEJS_uClipMode" + i + " != 0.0) {");
                add("      dist += clamp(dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) - SCENEJS_uClipNormalAndDist" + i + ".w, 0.0, 1000.0);");
                add("  }");
            }
            add("  if (dist > 0.0) { discard; }");
            add("}");
        }

        if (normals) {
            add("vec3 worldEyeVec = normalize(SCENEJS_uWorldEye - SCENEJS_vWorldVertex.xyz);");            // World-space eye position

            if (fresnel) {
                add("vec3 worldNormal = normalize(SCENEJS_vWorldNormal); ")
            }

            if (solid) {

                add("  if (gl_FrontFacing == false) {");
                add("     gl_FragColor = vec4(SCENEJS_uSolidColor.xyz, 1.0);");
                add("     return;");
                add("  }");
            }
        }

        add("  vec3 ambient= SCENEJS_uAmbientColor;");

        //if (texturing && states.geometry.uvBuf && fragmentHooks.texturePos) {
        //    add(fragmentHooks.texturePos + "(SCENEJS_vUVCoord);");
        //}

        if (fragmentHooks.viewPos) {
            add(fragmentHooks.viewPos + "(SCENEJS_vViewVertex);");
        }

        if (normals && fragmentHooks.viewNormal) {
            add(fragmentHooks.viewNormal + "(SCENEJS_vViewNormal);");
        }

        if (states.geometry.colorBuf) {
            add("  vec3    color   = SCENEJS_vColor.rgb;");
            add("  float   colorA  = SCENEJS_vColor.a;");
        } else {
            add("  vec3    color   = SCENEJS_uMaterialColor;")
        }

        add("  float alpha         = SCENEJS_uMaterialAlpha;");
        add("  float emit          = SCENEJS_uMaterialEmit;");
        add("  float specular      = SCENEJS_uMaterialSpecular;");
        add("  vec3  specularColor = SCENEJS_uMaterialSpecularColor;");
        add("  vec3  emitColor     = SCENEJS_uMaterialEmitColor;");
        add("  float shine         = SCENEJS_uMaterialShine;");

        if (fragmentHooks.materialBaseColor) {
            add("color=" + fragmentHooks.materialBaseColor + "(color);");
        }
        if (fragmentHooks.materialAlpha) {
            add("alpha=" + fragmentHooks.materialAlpha + "(alpha);");
        }
        if (fragmentHooks.materialEmit) {
            add("emit=" + fragmentHooks.materialEmit + "(emit);");
        }
        if (fragmentHooks.materialSpecular) {
            add("specular=" + fragmentHooks.materialSpecular + "(specular);");
        }
        if (fragmentHooks.materialSpecularColor) {
            add("specularColor=" + fragmentHooks.materialSpecularColor + "(specularColor);");
        }
        if (fragmentHooks.materialShine) {
            add("shine=" + fragmentHooks.materialShine + "(shine);");
        }

        if (normals) {
            add("  float   attenuation = 1.0;");
            if (tangents) {
                add("  vec3    viewNormalVec = vec3(0.0, 1.0, 0.0);");
            } else {

                // Normalize the interpolated normals in the per-fragment-fragment-shader,
                // because if we linear interpolated two nonparallel normalized vectors, the resulting vector wont be of length 1
                add("  vec3    viewNormalVec = normalize(SCENEJS_vViewNormal);");
            }
            add("vec3 viewEyeVec = normalize(SCENEJS_vViewEyeVec);");
        }

        var layer;
        if (texturing) {

            add("  vec4    texturePos;");
            add("  vec2    textureCoord=vec2(0.0,0.0);");

            // ------------ Texture maps ------------------------------------

            if (texturing) {
                for (var i = 0, len = states.texture.layers.length; i < len; i++) {
                    layer = states.texture.layers[i];

                    var applyFrom = layer.applyFrom;

                    // Texture input

                    if (applyFrom == "normal" && normals) {

                        if (states.geometry.normalBuf) {
                            add("texturePos=vec4(viewNormalVec.xyz, 1.0);");
                        } else {
                            SceneJS.log.warn("Texture layer applyFrom='normal' but geo has no normal vectors");
                            continue;
                        }

                    } else {

                        // Apply from UV layers

                        var matches = applyFrom.match(/\d+$/);
                        var uvLayerIndex = matches ? parseInt(matches[0]) : 0;

                        var uvBufs = states.geometry.uvBufs;

                        if (uvBufs[uvLayerIndex]) {
                            add("texturePos = vec4(SCENEJS_vUVCoord" + uvLayerIndex + ".s, SCENEJS_vUVCoord" + uvLayerIndex + ".t, 1.0, 1.0);");
                        } else {
                            SceneJS.log.warn("Texture layer applyTo='uv' but geometry has no UV coordinates for layer " + uvLayerIndex);
                            continue;
                        }
                    }

                    /* Texture matrix
                     */
                    if (layer.matrix) {
                        add("textureCoord=(SCENEJS_uLayer" + i + "Matrix * texturePos).xy;");
                    } else {
                        add("textureCoord=texturePos.xy;");
                    }

                    /* Alpha from Texture
                     */
                    if (layer.applyTo == "alpha") {
                        if (layer.blendMode == "multiply") {
                            add("alpha = alpha * (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).b);");
                        } else if (layer.blendMode == "add") {
                            add("alpha = ((1.0 - SCENEJS_uLayer" + i + "BlendFactor) * alpha) + (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).b);");
                        }
                    }

                    /* Texture output
                     */
                    if (layer.applyTo == "baseColor") {
                        if (layer.blendMode == "multiply") {
                            add("color = color * (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).rgb);");
                        } else {
                            add("color = ((1.0 - SCENEJS_uLayer" + i + "BlendFactor) * color) + (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).rgb);");
                        }
                    }

                    if (layer.applyTo == "emit") {
                        if (layer.blendMode == "multiply") {
                            add("emit  = emit * (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).r);");
                        } else {
                            add("emit = ((1.0 - SCENEJS_uLayer" + i + "BlendFactor) * emit) + (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).r);");
                        }
                    }

                    if (layer.applyTo == "specular" && normals) {
                        if (layer.blendMode == "multiply") {
                            add("specular  = specular * (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).r);");
                        } else {
                            add("specular = ((1.0 - SCENEJS_uLayer" + i + "BlendFactor) * specular) + (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).r);");
                        }
                    }

                    if (layer.applyTo == "shine") {
                        if (layer.blendMode == "multiply") {
                            add("shine  = shine * (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).r);");
                        } else {
                            add("shine = ((1.0 - SCENEJS_uLayer" + i + "BlendFactor) * shine) + (SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, 1.0 - textureCoord.y)).r);");
                        }
                    }

                    if (layer.applyTo == "normals" && normals) {
                        add("viewNormalVec = normalize(texture2D(SCENEJS_uSampler" + i + ", vec2(textureCoord.x, -textureCoord.y)).xyz * 2.0 - 1.0);");
                    }
                }
            }
        }

        if (normals && cubeMapping) {
            add("float reflectFactor = 1.0;");

            if (reflectFresnel) {
                add("float reflectFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uReflectFresnelEdgeBias,  SCENEJS_uReflectFresnelCenterBias, SCENEJS_uReflectFresnelPower);");
                add("reflectFactor *= mix(SCENEJS_uReflectFresnelEdgeColor.b, SCENEJS_uReflectFresnelCenterColor.b, reflectFresnel);");
            }

            add("vec4 v = SCENEJS_uVNMatrix * vec4(SCENEJS_vViewEyeVec, 1.0);");
            add("vec3 v1 = v.xyz;");

            add("v = SCENEJS_uVNMatrix * vec4(viewNormalVec, 1.0);");
            add("vec3 v2 = v.xyz;");

            add("vec3 envLookup = reflect(v1, v2);");

            add("envLookup.y = envLookup.y * -1.0;"); // Need to flip textures on Y-axis for some reason
            add("vec4 envColor;");
            for (var i = 0, len = states.cubemap.layers.length; i < len; i++) {
                layer = states.cubemap.layers[i];
                add("envColor = textureCube(SCENEJS_uCubeMapSampler" + i + ", envLookup);");
                add("color = mix(color, envColor.rgb, reflectFactor * specular * SCENEJS_uCubeMapIntensity" + i + ");");
            }
        }

        add("  vec4    fragColor;");

        if (normals) {

            add("  vec3    lightValue      = vec3(0.0, 0.0, 0.0);");
            add("  vec3    specularValue   = vec3(0.0, 0.0, 0.0);");
            add("  vec3    viewLightVec;");
            add("  vec3    viewLightDir;")
            add("  float   dotN;");
            add("  float   spotDirRatio;");
            add("  float   lightDist;");

            if (tangents) {

                // Compute tangent-bitangent-normal matrix

                add("vec3 tangent = normalize(SCENEJS_vTangent);");
                add("vec3 bitangent = cross(SCENEJS_vViewNormal, tangent);");
                add("mat3 TBM = mat3(tangent, bitangent, SCENEJS_vViewNormal);");
            }

            var light;

            for (var i = 0, len = states.lights.lights.length; i < len; i++) {
                light = states.lights.lights[i];

                if (light.mode == "ambient") {
                    continue;
                }

                if (light.mode == "point") {

                    if (light.space == "world") {

                        // World space

                        add("viewLightVec = SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz;"); // Vector from World coordinate to light pos

                        // Transform to View space
                        add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;");

                        if (tangents) {

                            // Transform to Tangent space
                            add("viewLightVec *= TBM;");
                        }

                    } else {

                        // View space

                        add("viewLightVec = SCENEJS_uLightPos" + i + ".xyz - SCENEJS_vViewVertex.xyz;"); // Vector from View coordinate to light pos

                        if (tangents) {

                            // Transform to tangent space
                            add("viewLightVec *= TBM;");
                        }
                    }

                    add("dotN = max(dot(viewNormalVec, normalize(viewLightVec)), 0.0);");

                    add("lightDist = length( SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz);");

                    add("attenuation = 1.0 - (" +
                        "  SCENEJS_uLightAttenuation" + i + ".x + " +
                        "  SCENEJS_uLightAttenuation" + i + ".y * lightDist + " +
                        "  SCENEJS_uLightAttenuation" + i + ".z * lightDist * lightDist);");

                    if (light.diffuse) {
                        add("      lightValue += dotN * SCENEJS_uLightColor" + i + " * attenuation;");
                    }

                    if (light.specular) {
                        add("    specularValue += specularColor * SCENEJS_uLightColor" + i +
                            " * specular * pow(max(dot(reflect(normalize(-viewLightVec), normalize(-viewNormalVec)), normalize(-SCENEJS_vViewVertex.xyz)), 0.0), shine) * attenuation;");
                    }
                }

                if (light.mode == "spot") {

                    add("viewLightDir = SCENEJS_uLightDir" + i + ";")

                    if (light.space == "world") {

                        // World space

                        add("viewLightVec = SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz;"); // Vector from World coordinate to light pos

                        // Transform to View space
                        add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;");
                        add("viewLightDir = vec3(SCENEJS_uVMatrix * vec4(viewLightDir, 0.0)).xyz;");

                        if (tangents) {

                            // Transform to Tangent space
                            add("viewLightVec *= TBM;");
                            add("viewLightDir *= TBM;");
                        }

                    } else {

                        // View space

                        add("viewLightVec = SCENEJS_uLightPos" + i + ".xyz - SCENEJS_vViewVertex.xyz;"); // Vector from View coordinate to light pos

                        if (tangents) {

                            // Transform to tangent space
                            add("viewLightVec *= TBM;");
                            add("viewLightDir *= TBM;");
                        }
                    }

                    add("dotN = max(dot(viewNormalVec, normalize(viewLightVec)), 0.0);");
                    add("spotDirRatio = 1.0 - max(dot(normalize(viewLightDir), normalize(-viewLightVec)), 0.0);");

                    add("lightDist = length( SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz);");

                    add("attenuation = 1.0 - (" +
                        "  SCENEJS_uLightAttenuation" + i + ".x + " +
                        "  SCENEJS_uLightAttenuation" + i + ".y * lightDist + " +
                        "  SCENEJS_uLightAttenuation" + i + ".z * lightDist * lightDist);");

                    // Attenuations due to spotlight cones
                    add("attenuation *= 1.0 - clamp((spotDirRatio - SCENEJS_uInnerCone" + i + ") / max(SCENEJS_uOuterCone" + i + " - SCENEJS_uInnerCone" + i + ", 0.0001), 0.0, 1.0);");

                    if (light.diffuse) {
                        add("      lightValue += dotN * SCENEJS_uLightColor" + i + " * attenuation;");
                    }

                    if (light.specular) {
                        add("    specularValue += specularColor * SCENEJS_uLightColor" + i +
                            " * specular * pow(max(dot(reflect(normalize(-viewLightVec), normalize(-viewNormalVec)), normalize(-SCENEJS_vViewVertex.xyz)), 0.0), shine) * attenuation;");
                    }
                }

                if (light.mode == "dir") {

                    if (light.space == "world") {

                        // World space light

                        add("viewLightVec = normalize(SCENEJS_uLightDir" + i + ");");

                        // Transform to View space
                        add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;");

                        if (tangents) {

                            // Transform to Tangent space
                            add("viewLightVec *= TBM;");
                        }

                    } else {

                        // View space light

                        add("viewLightVec = normalize(SCENEJS_uLightDir" + i + ");");

                        if (tangents) {

                            // Transform to Tangent space
                            add("viewLightVec *= TBM;");
                        }
                    }

                    add("viewLightVec = -viewLightVec;");

                    add("dotN = max(dot(viewNormalVec, normalize(viewLightVec)), 0.0);");

                    if (light.diffuse) {
                        add("lightValue += dotN * SCENEJS_uLightColor" + i + ";");
                    }

                    if (light.specular) {
                        add("specularValue += specularColor * SCENEJS_uLightColor" + i +
                            " * specular * pow(max(dot(reflect(normalize(-viewLightVec), normalize(-viewNormalVec)), normalize(-SCENEJS_vViewVertex.xyz)), 0.0), shine);");
                    }
                }
            }

            if (states.geometry.colorBuf) {
                add("alpha *= colorA;");
            }

            if (diffuseFresnel || specularFresnel || alphaFresnel || emitFresnel) {

                if (diffuseFresnel) {
                    add("float diffuseFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uDiffuseFresnelEdgeBias, SCENEJS_uDiffuseFresnelCenterBias, SCENEJS_uDiffuseFresnelPower);");
                    add("color.rgb *= mix(SCENEJS_uDiffuseFresnelEdgeColor.rgb, SCENEJS_uDiffuseFresnelCenterColor.rgb, diffuseFresnel);");
                }

                if (specularFresnel) {
                    add("float specFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uSpecularFresnelEdgeBias, SCENEJS_uSpecularFresnelCenterBias, SCENEJS_uSpecularFresnelPower);");
                    add("specularValue *= mix(SCENEJS_uSpecularFresnelEdgeColor.rgb, SCENEJS_uSpecularFresnelCenterColor.rgb, specFresnel);");
                }

                if (alphaFresnel) {
                    add("float alphaFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uAlphaFresnelEdgeBias, SCENEJS_uAlphaFresnelCenterBias, SCENEJS_uAlphaFresnelPower);");
                    add("alpha *= mix(SCENEJS_uAlphaFresnelEdgeColor.r, SCENEJS_uAlphaFresnelCenterColor.r, alphaFresnel);");
                }

                if (emitFresnel) {
                    add("float emitFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uEmitFresnelEdgeBias, SCENEJS_uEmitFresnelCenterBias, SCENEJS_uEmitFresnelPower);");
                    add("emitColor.rgb *= mix(SCENEJS_uEmitFresnelEdgeColor.rgb, SCENEJS_uEmitFresnelCenterColor.rgb, emitFresnel);");
                }
            }

            add("fragColor = vec4((specularValue.rgb + color.rgb * (lightValue.rgb + ambient.rgb)) + (emit * emitColor.rgb), alpha);");

        } else { // No normals
            add("fragColor = vec4((color.rgb + (emit * color.rgb)) *  (vec3(1.0, 1.0, 1.0) + ambient.rgb), alpha);");
        }

        if (regionInteraction) {

            // Region map highlighting

            add("vec3 regionColor = texture2D(SCENEJS_uRegionMapSampler, vec2(SCENEJS_vRegionMapUV.s, 1.0 - SCENEJS_vRegionMapUV.t)).rgb;");
            add("float tolerance = 0.01;");
            add("vec3 colorDelta = abs(SCENEJS_uRegionMapRegionColor - regionColor);");
            if (states.regionMap.mode === "highlight" || states.regionMap.mode === "hide") {
                add("if (max(colorDelta.x, max(colorDelta.y, colorDelta.z)) < tolerance) {");
                if (states.regionMap.mode === "highlight") {
                    add("  fragColor.rgb *= SCENEJS_uRegionMapHighlightFactor;");
                } else {
                    // mode = "hide"
                    add("  fragColor.a = SCENEJS_uRegionMapHideAlpha;");
                }
                add("}");
            } else {
                // mode = "isolate"
                add("if (max(colorDelta.x, max(colorDelta.y, colorDelta.z)) > tolerance) {");
                add("  fragColor.a = SCENEJS_uRegionMapHideAlpha;");
                add("}");
            }
        }

        if (fragmentHooks.pixelColor) {
            add("fragColor=" + fragmentHooks.pixelColor + "(fragColor);");
        }
        if (false && debugCfg.whitewash === true) {

            add("    fragColor = vec4(1.0, 1.0, 1.0, 1.0);");

        } else {

            if (depthTargeting) {

                // Only compile in depth mode support if a depth render target is present

                add("    if (SCENEJS_uDepthMode) {");
                add("          float depth = length(SCENEJS_vViewVertex) / (SCENEJS_uZFar - SCENEJS_uZNear);");
                add("          const vec4 bias = vec4(1.0 / 255.0,");
                add("          1.0 / 255.0,");
                add("          1.0 / 255.0,");
                add("          0.0);");
                add("          float r = depth;");
                add("          float g = fract(r * 255.0);");
                add("          float b = fract(g * 255.0);");
                add("          float a = fract(b * 255.0);");
                add("          vec4 colour = vec4(r, g, b, a);");
                add("          fragColor = colour - (colour.yzww * bias);");
                add("    }");
            }
        }

        if (fragmentFresnel) {
            add("float fragmentFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uFragmentFresnelEdgeBias, SCENEJS_uFragmentFresnelCenterBias, SCENEJS_uFragmentFresnelPower);");
            add("fragColor.rgb *= mix(SCENEJS_uFragmentFresnelEdgeColor.rgb, SCENEJS_uFragmentFresnelCenterColor.rgb, fragmentFresnel);");
        }

        if (!depthTargeting) {
            add("fragColor.rgb *= fragColor.a;");
        }

        add("gl_FragColor = fragColor;");

        add("}");

//        console.log(src.join("\n"));
        return end();
    }

    // Start fresh program source
    function begin() {
        src = [];
    }

    // Append to program source
    function add(txt) {
        src.push(txt || "");
    }

    // Finish building program source
    function end() {
        return src;
    }

    function getFSFloatPrecision(gl) {
        if (!gl.getShaderPrecisionFormat) {
            return "mediump";
        }

        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
            return "highp";
        }

        if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
            return "mediump";
        }

        return "lowp";
    }

})
();
;/**
 * @class Source code for pick and draw shader programs, to be compiled into one or more {@link SceneJS_Program}s
 * @private
 * 
 * @param {String} hash Hash code identifying the rendering capabilities of the programs
 * @param {String} pickVertexSrc Source code of the pick vertex shader
 * @param {String} pickFragmentSrc Source code of the pick fragment shader
 * @param {String} drawVertexSrc Source code of the draw vertex shader
 * @param {String} drawFragmentSrc Source code of the draw fragment shader
 */
var SceneJS_ProgramSource = function(hash, pickVertexSrc, pickFragmentSrc, drawVertexSrc, drawFragmentSrc) {

    /**
     * Hash code identifying the capabilities of the {@link SceneJS_Program} that is compiled from this source
     * @type String
     */
    this.hash = hash;

    /**
     * Source code for pick vertex shader
     * @type String
     */
    this.pickVertexSrc = pickVertexSrc;

    /**
     * Source code for pick fragment shader
     * @type String
     */
    this.pickFragmentSrc = pickFragmentSrc;

    /**
     * Source code for draw vertex shader
     * @type String
     */
    this.drawVertexSrc = drawVertexSrc;

    /**
     * Source code for draw fragment shader
     * @type String
     */
    this.drawFragmentSrc = drawFragmentSrc;

    /**
     * Count of {@link SceneJS_Program}s compiled from this program source code
     * @type Number
     */
    this.useCount = 0;
};

;/**  
 * @class Manages creation, sharing and recycle of {@link SceneJS_Program} instances
 * @private
 */
var SceneJS_ProgramFactory = function(stats, cfg) {

    this.stats = stats;

    this._canvas = cfg.canvas;

    this._programs = {};

    this._nextProgramId = 0;
};

/**
 * Gets a program to render the given states
 */
SceneJS_ProgramFactory.prototype.getProgram = function(hash, states) {

    var program = this._programs[hash];

    if (!program) {

        var source = SceneJS_ProgramSourceFactory.getSource(hash, states);

        program = new SceneJS_Program(this.stats, this._nextProgramId++, hash, source, this._canvas.gl);

        this._programs[hash] = program;

        this.stats.memory.programs++;
    }

    program.useCount++;

    return program;
};

/**
 * Releases a program back to the shader factory
 */
SceneJS_ProgramFactory.prototype.putProgram = function(program) {

    if (--program.useCount <= 0) {

        program.draw.destroy();
        program.pick.destroy();

        SceneJS_ProgramSourceFactory.putSource(program.hash);

        delete this._programs[program.hash];

        this.stats.memory.programs--;
    }
};

/**
 * Notifies this shader factory that the WebGL context has been restored after previously being lost
 */
SceneJS_ProgramFactory.prototype.webglRestored = function() {

    var gl = this._canvas.gl;
    var program;

    for (var id in this._programs) {
        if (this._programs.hasOwnProperty(id)) {
            program = this._programs[id];
            if (program && program.build) {
                program.build(gl);
            }
        }
    }
};

/**
 * Destroys this shader factory
 */
SceneJS_ProgramFactory.prototype.destroy = function() {
};
;/**
 * @class Vertex and fragment shaders for pick and draw
 * @private
 *
 * @param {*} stats Collects runtime statistics
 * @param {Number} id ID unique among all programs in the owner {@link SceneJS_ProgramFactory}
 * @param {String} hash Hash code which uniquely identifies the capabilities of the program, computed from hashes on the {@link Scene_Core}s that the {@link SceneJS_ProgramSource} composed to render
 * @param {SceneJS_ProgramSource} source Sourcecode from which the the program is compiled in {@link #build}
 * @param {WebGLRenderingContext} gl WebGL context 
 */
var SceneJS_Program = function(stats, id, hash, source, gl) {

    this.stats = stats;

    /**
     * ID for this program, unique among all programs in the display
     * @type Number
     */
    this.id = id;

    /**
     * Hash code for this program's capabilities, same as the hash on {@link #source}
     * @type String
     */
    this.hash = source.hash;

    /**
     * Source code for this program's shaders
     * @type SceneJS_ProgramSource
     */
    this.source = source;

    /**
     * WebGL context on which this program's shaders are allocated
     * @type WebGLRenderingContext
     */
    this.gl = gl;

    /**
     * The drawing program
     * @type SceneJS._webgl.Program
     */
    this.draw = null;

    /**
     * The picking program
     * @type SceneJS._webgl.Program
     */
    this.pick = null;

    /**
     * The count of display objects using this program
     * @type Number
     */
    this.useCount = 0;

    this.build(gl);
};

/**
 *  Creates the render and pick programs.
 * This is also re-called to re-create them after WebGL context loss.
 */
SceneJS_Program.prototype.build = function(gl) {

    this.gl = gl;
    this.draw = new SceneJS._webgl.Program(this.stats, gl, [this.source.drawVertexSrc.join("\n")], [this.source.drawFragmentSrc.join("\n")]);
    this.pick = new SceneJS._webgl.Program(this.stats, gl, [this.source.pickVertexSrc.join("\n")], [this.source.pickFragmentSrc.join("\n")]);
};
;/**
 * @class Manages creation and recycle of {@link SceneJS_Object} instances
 * @private
 */
var SceneJS_ObjectFactory = function() {

};

/**
 * @property {[SceneJS_Object]} _freeObjects Pool of free display objects, shared by all object factories
 */
SceneJS_ObjectFactory.prototype._freeObjects = [];

/**
 * @property {Number} _numFreeObjects Number of free objects
 */
SceneJS_ObjectFactory.prototype._numFreeObjects = 0;

/**
 * Gets a display object from this factory
 *
 * @param {String} id ID to assign to the object
 * @returns {SceneJS_Object} The object
 */
SceneJS_ObjectFactory.prototype.getObject = function(id) {

    var object;

    if (this._numFreeObjects > 0) {

        object = this._freeObjects[--this._numFreeObjects];
        object.id = id;

        return object;
    }

    return new SceneJS_Object(id);
};

/**
 * Releases a display object back to this factory
 * @param {SceneJS_Object} object Object to release
 */
SceneJS_ObjectFactory.prototype.putObject = function (object) {

  //  this._freeObjects[this._numFreeObjects++] = object;
};;/**
 * @class An object within a {@link SceneJS_Display}
 * @private
 */
var SceneJS_Object = function(id) {

    /**
     * ID for this objects, unique among all objects in the display
     * @type Number
     */
    this.id = id;

    /**
     * Hash code for this object, unique among all objects in the display
     * @type String
     */
    this.hash = null;

    /**
     * State sort key, computed from {@link #layer}, {@link #program} and {@link #texture}
     * @type Number
     */
    this.sortKey1 = null;
    this.sortKey2 = null;

    /**
     * Sequence of state chunks applied to render this object
     * @type {[SceneJS_Chunk]} chunks
     */
    this.chunks = [];

    /**
     * Number of state chunks applied to render this object
     * @type Number
     */
    this.chunksLen = 0;

    /**
     * Shader programs that render this object, also used for (re)computing {@link #sortKey}
     * @type SceneJS_Program
     */
    this.program = null;

    /**
     * State core for the {@link SceneJS.Layer} that this object was compiled from, used for (re)computing {@link #sortKey} and visibility cull
     */
    this.layer = null;

     /**
     * State core for the {@link SceneJS.Texture} that this object was compiled from, used for (re)computing {@link #sortKey}
     */
    this.texture = null;

    /**
     * State core for the {@link SceneJS.Flags} that this object was compiled from, used for visibility cull
     */
    this.flags = null;

    /**
     * State core for the {@link SceneJS.Tag} that this object was compiled from, used for visibility cull
     */
    this.tag = null;

    /**
    *   Used to calculate the depth for depth sorting
    */
    this.centroid = null;
};

(function() {
    var tempVec4 = new SceneJS_math_vec4();

    SceneJS_Object.prototype.getDepth = function() {
        if (!this.centroid) {
            this.centroid = this._calculateCentroid(this);
        }

        var modelMatrix = this.modelTransform.mat;
        var viewMatrix = this.viewTransform.mat;

        var viewCentroid = SceneJS_math_transformVector4(modelMatrix, this.centroid, tempVec4);

        SceneJS_math_transformVector4(viewMatrix, viewCentroid, viewCentroid);

        return -viewCentroid[2];
    };

    SceneJS_Object.prototype._calculateCentroid = function() {

        var centroid = SceneJS_math_vec4();

        var positions = this.geometry.arrays.positions;
        var indices = this.geometry.arrays.indices;

        var xmin = Infinity;
        var ymin = Infinity;
        var zmin = Infinity;
        var xmax = -Infinity;
        var ymax = -Infinity;
        var zmax = -Infinity;

        var min = Math.min;
        var max = Math.max;

        for (var i = 0, len = indices.length; i < len; i++) {
            var vi = indices[i] * 3;
            var x = positions[vi];
            var y = positions[vi + 1];
            var z = positions[vi + 2];

            xmin = min(x, xmin);
            ymin = min(y, ymin);
            zmin = min(z, zmin);
            xmax = max(x, xmax);
            ymax = max(y, ymax);
            zmax = max(z, zmax);
        }

        centroid[0] = 0.5 * (xmin + xmax);
        centroid[1] = 0.5 * (ymin + ymax);
        centroid[2] = 0.5 * (zmin + zmax);
        centroid[3] = 1;

        return centroid;
    };
})();


;/**
 * @class A facade which exposes internal scene rendering state to "rendered" event listeners bound to scene graph nodes with {@link SceneJS.Node#bind}.
 *
 * <p>The listener is fired for each {@link SceneJS.Geometry} that is rendered within the subgraph of the bound node.
 * An instance of this facade is passed into the listener's handler, enabling the listener to obtain the various transform
 * matrices that are active at that {@link SceneJS.Geometry}.</p>
 *
 * <p>The facade instance is only valid within the callback's execution; internally, SceneJS reuses the same instance of the
 * facade with each scene.</p>
 */
SceneJS.RenderContext = function(frameCtx) {
    this._frameCtx = frameCtx;
};

/**
 * Get the projection matrix, as defined by the active {@link SceneJS.Camera} node.
 */
SceneJS.RenderContext.prototype.getCameraMatrix = function() {
    return this._frameCtx.cameraMat;
};

/**
 * Get the view matrix, as defined by the active {@link SceneJS.LookAt} node.
 */
SceneJS.RenderContext.prototype.getViewMatrix = function() {
    return this._frameCtx.viewMat;
};

/**
 * Get the model matrix, as defined by the active {@link SceneJS.XForm} node.
 */
SceneJS.RenderContext.prototype.getModelMatrix = function() {
    return this._frameCtx.modelMat;
};

/**
 * Transforms the given world coordinate by the model, view and projection matrices defined by the active {@link SceneJS.XForm}, {@link SceneJS.LookAt} and {@link SceneJS.Camera} nodes.
 * @returns [Number] The 2D Canvas-space coordinate
 */
SceneJS.RenderContext.prototype.getCanvasPos = function(offset) {

    this.getProjPos(offset);

    var canvas = this._frameCtx.canvas.canvas;
    var resolutionScaling = this._frameCtx.canvas.resolutionScaling;
    var canvasWidth = canvas.width / resolutionScaling;
    var canvasHeight = canvas.height / resolutionScaling;

    /* Projection division and map to canvas
     */
    var pc = this._pc;

    var x = (pc[0] / pc[3]) * canvasWidth * 0.5;
    var y = (pc[1] / pc[3]) * canvasHeight * 0.5;

    return {
        x: x + (canvasWidth * 0.5),
        y: canvasHeight - y - (canvasHeight * 0.5)
    };
};

/**
 * Transforms the given world coordinate by the model and view matrices defined by the active {@link SceneJS.XForm} and {@link SceneJS.LookAt} nodes.
 * @returns [Number] The 3D Projection-space coordinate
 */
SceneJS.RenderContext.prototype.getCameraPos = function(offset) {
    this.getProjPos(offset);
    this._camPos = SceneJS_math_normalizeVec3(this._pc, [0,0,0]);
    return { x: this._camPos[0], y: this._camPos[1], z: this._camPos[2] }; // TODO: return _camPos and lose the temp object
};


SceneJS.RenderContext.prototype.getProjPos = function(offset) {
    this.getViewPos(offset);
    this._pc = SceneJS_math_transformPoint3(this._frameCtx.cameraMat, this._vc);
    return { x: this._pc[0], y: this._pc[1], z: this._pc[2],  w: this._pc[3] };
};

SceneJS.RenderContext.prototype.getViewPos = function(offset) {
    this.getWorldPos(offset);
    this._vc = SceneJS_math_transformPoint3(this._frameCtx.viewMat, this._wc);
    return { x: this._vc[0], y: this._vc[1], z: this._vc[2],  w: this._vc[3] };
};

SceneJS.RenderContext.prototype.getWorldPos = function(offset) {
    this._wc = SceneJS_math_transformPoint3(this._frameCtx.modelMat, offset || [0,0,0]);
    return { x: this._wc[0], y: this._wc[1], z: this._wc[2],  w: this._wc[3] };
};
;/**
 * @class A chunk of WebGL state changes to render a {@link SceneJS_Core} for drawing and picking (if applicable to the core type).
 *
 * <p>Instances of this class are created and recycled by a {@link SceneJS_ChunkFactory}.</p>
 *
 * <p>Each {@link SceneJS_Object} has a list of chunks to render it's {@link SceneJS_Core}s</p>
 *
 * @private
 */
var SceneJS_Chunk = function() {};

/**
 * Initialises the chunk. This is called within the constructor, and also to by the owner {@link SceneJS_ChunkFactory}
 * when recycling a chunk from its free chunk pool. This method sets the given properties on the chunk, then calls the
 * chunk instance's <b>build</b> method if the chunk has been augmented with one.
 *
 * @param {String} id Chunk ID
 * @param {SceneJS_Program} program Program to render the chunk
 * @param {SceneJS_Core} core The state core rendered by this chunk
 * @param {SceneJS_Core} core2 Another state core rendered by this chunk, only used for geometry
 */
SceneJS_Chunk.prototype.init = function(id, program, core, core2) {

    this.id = id;
    this.program = program;
    this.core = core;
    this.core2 = core2;

    if (this.build) {
        this.build();
    }
};
;/**
 * @class Manages creation, reuse and destruction of {@link SceneJS_Chunk}s for the nodes within a single {@link SceneJS_Display}.
 * @private
 */
var SceneJS_ChunkFactory = function() {

    this._chunks = {};
    this.chunkTypes = SceneJS_ChunkFactory.chunkTypes;
};

/**
 * Sub-classes of {@link SceneJS_Chunk} provided by this factory
 */
SceneJS_ChunkFactory.chunkTypes = {};    // Supported chunk classes, installed by #createChunkType

/**
 * Free pool of unused {@link SceneJS_Chunk} instances
 */
SceneJS_ChunkFactory._freeChunks = {};    // Free chunk pool for each type

/**
 * Creates a chunk class for instantiation by this factory
 *
 * @param params Members to augment the chunk class prototype with
 * @param params.type Type name for the new chunk class
 * @param params.draw Method to render the chunk in draw render
 * @param params.pick Method to render the chunk in pick render
 * @param params.drawAndPick Method to render the chunk in both draw and pick renders
 */
SceneJS_ChunkFactory.createChunkType = function(params) {

    if (!params.type) {
        throw "'type' expected in params";
    }

    var supa = SceneJS_Chunk;

    var chunkClass = function() { // Create the class
        this.useCount = 0;
        this.init.apply(this, arguments);
    };

    chunkClass.prototype = new supa();              // Inherit from base class
    chunkClass.prototype.constructor = chunkClass;

    if (params.drawAndPick) {                       // Common method for draw and pick render
        params.draw = params.pick = params.drawAndPick;
    }

    SceneJS_ChunkFactory.chunkTypes[params.type] = chunkClass;

    SceneJS._apply(params, chunkClass.prototype);   // Augment subclass

    SceneJS_ChunkFactory._freeChunks[params.type] = { // Set up free chunk pool for this type
        chunks: [],
        chunksLen: 0
    };

    return chunkClass;
};

/**
 *
 */
SceneJS_ChunkFactory.prototype.getChunk = function(chunkId, type, program, core, core2) {

    var chunkClass = SceneJS_ChunkFactory.chunkTypes[type]; // Check type supported

    if (!chunkClass) {
        throw "chunk type not supported: '" + type + "'";
    }

    var chunk = this._chunks[chunkId];  // Try to reference an existing chunk

    if (chunk) {
        chunk.useCount++;
        return chunk;
    }

    //var freeChunks = SceneJS_ChunkFactory._freeChunks[type]; // Try to recycle a free chunk
    //
    //if (freeChunks.chunksLen > 0) {
    //    chunk = freeChunks.chunks[--freeChunks.chunksLen];
    //}
    //
    //if (chunk) {    // Reinitialise the recycled chunk
    //
    //    chunk.init(chunkId, program, core, core2);
    //
    //} else {        // Instantiate a fresh chunk

        chunk = new chunkClass(chunkId, program, core, core2); // Create new chunk

//    }

    chunk.type = type;

    chunk.useCount = 1;

    this._chunks[chunkId] = chunk;

    return chunk;
};

/**
 * Releases a display state chunk back to this factory, destroying it if the chunk's use count is then zero.
 *
 * @param {SceneJS_Chunk} chunk Chunk to release
 */
SceneJS_ChunkFactory.prototype.putChunk = function (chunk) {

    if (chunk.useCount == 0) {
        return; // In case of excess puts
    }

    if (--chunk.useCount <= 0) {    // Release shared core if use count now zero

        if (chunk.recycle) {
            chunk.recycle();
        }

        delete this._chunks[chunk.id];

    //    var freeChunks = SceneJS_ChunkFactory._freeChunks[chunk.type];

    //    freeChunks.chunks[freeChunks.chunksLen++] = chunk;
    }
};

/**
 * Re-cache shader variable locations for each active chunk and reset VAOs if any
 */
SceneJS_ChunkFactory.prototype.webglRestored = function () {

    var chunk;

    for (var chunkId in this._chunks) {

        if (this._chunks.hasOwnProperty(chunkId)) {

            chunk = this._chunks[chunkId]; // Re-cache chunk's shader variable locations

            if (chunk && chunk.build) {
                chunk.build();
            }
        }
    }
};
;SceneJS_ChunkFactory.createChunkType({

    type: "camera",

    build : function() {

        this._uPMatrixDraw = this.program.draw.getUniform("SCENEJS_uPMatrix");
        this._uZNearDraw = this.program.draw.getUniform("SCENEJS_uZNear");
        this._uZFarDraw = this.program.draw.getUniform("SCENEJS_uZFar");

        this._uPMatrixPick = this.program.pick.getUniform("SCENEJS_uPMatrix");
        this._uZNearPick = this.program.pick.getUniform("SCENEJS_uZNear");
        this._uZFarPick = this.program.pick.getUniform("SCENEJS_uZFar");
    },

    draw : function(frameCtx) {

        if (this.core.checkAspect) {
            this.core.checkAspect(this.core, frameCtx.aspect);
        }

        var gl = this.program.gl;

        if (this._uPMatrixDraw) {
            this._uPMatrixDraw.setValue(this.core.mat);
        }

        if (this._uZNearDraw) {
            this._uZNearDraw.setValue(this.core.optics.near);
        }

        if (this._uZFarDraw) {
            this._uZFarDraw.setValue(this.core.optics.far);
        }

        frameCtx.cameraMat = this.core.mat; // Query only in draw pass
    },


    pick : function(frameCtx) {

        if (this.core.checkAspect) {
            this.core.checkAspect(this.core, frameCtx.aspect);
        }

        var gl = this.program.gl;

        if (this._uPMatrixPick) {
            this._uPMatrixPick.setValue(this.core.mat);
        }

        if (frameCtx.rayPick) { // Z-pick pass: feed near and far clip planes into shader

            if (this._uZNearPick) {
                this._uZNearPick.setValue(this.core.optics.near);
            }

            if (this._uZFarPick) {
                this._uZFarPick.setValue(this.core.optics.far);
            }
        }

        frameCtx.cameraMat = this.core.mat; // Query only in draw pass
    }
});;/**
 * Create display state chunk type for draw and pick render of user clipping planes
 */
SceneJS_ChunkFactory.createChunkType({

    type: "clips",

    build : function() {

        this._draw = this._draw || [];

        var draw = this.program.draw;

        for (var i = 0, len = this.core.clips.length; i < len; i++) {
            this._draw[i] = {
                uClipMode :draw.getUniform("SCENEJS_uClipMode" + i),
                uClipNormalAndDist: draw.getUniform("SCENEJS_uClipNormalAndDist" + i)
            };
        }

        this._pick = this._pick || [];

        var pick = this.program.pick;

        for (var i = 0, len = this.core.clips.length; i < len; i++) {
            this._pick[i] = {
                uClipMode :pick.getUniform("SCENEJS_uClipMode" + i),
                uClipNormalAndDist: pick.getUniform("SCENEJS_uClipNormalAndDist" + i)
            };
        }
    },

    drawAndPick: function(frameCtx) {

        var picking = frameCtx.picking;
        var vars = picking ? this._pick : this._draw;
        var mode;
        var normalAndDist;
        var clips = this.core.clips;
        var clip;
        var gl = this.program.gl;

        for (var i = 0, len = clips.length; i < len; i++) {

            if (picking) {
                mode = vars[i].uClipMode;
                normalAndDist = vars[i].uClipNormalAndDist;
            } else {
                mode = vars[i].uClipMode;
                normalAndDist = vars[i].uClipNormalAndDist;
            }

            if (mode && normalAndDist) {

                clip = clips[i];

                if (clip.mode == "inside") {

                    mode.setValue(2);
                    normalAndDist.setValue(clip.normalAndDist);

                } else if (clip.mode == "outside") {

                    mode.setValue(1);
                    normalAndDist.setValue(clip.normalAndDist);

                } else { // disabled
                    mode.setValue(0);
                }
            }
        }
    }
});;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type: "draw",

    /**
     * As we apply a list of state chunks in a {@link SceneJS_Display}, we track the ID of each chunk
     * in order to avoid redundantly re-applying the same chunk.
     *
     * We don't want that for draw chunks however, because they contain GL drawElements calls,
     * which we need to do for each object.
     */
    unique: true,

    build: function () {

        this._depthModeDraw = this.program.draw.getUniform("SCENEJS_uDepthMode");

        this._uPickColor = this.program.pick.getUniform("SCENEJS_uPickColor");
    },


    draw: function (frameCtx) {

        var core = this.core;
        var gl = this.program.gl;

        if (this._depthModeDraw) {
            this._depthModeDraw.setValue(frameCtx.depthMode);
        }

        if (core.indexBuf) {
            gl.drawElements(core.primitive, core.indexBuf.numItems, core.indexBuf.itemType, 0);
            frameCtx.drawElements++;
        } else {
            gl.drawArrays(core.primitive, 0, core.vertexBuf.numItems / 3);
            frameCtx.drawArrays++;
        }

        //frameCtx.textureUnit = 0;
    },

    pick: function (frameCtx) {

        var core = this.core;
        var gl = this.program.gl;

        if (frameCtx.pickObject || frameCtx.pickRegion) {

            if (frameCtx.pickObject) {

                if (this._uPickColor) {

                    var a = frameCtx.pickIndex >> 24 & 0xFF;
                    var b = frameCtx.pickIndex >> 16 & 0xFF;
                    var g = frameCtx.pickIndex >> 8 & 0xFF;
                    var r = frameCtx.pickIndex & 0xFF;

                    frameCtx.pickIndex++;

                    this._uPickColor.setValue([r / 255, g / 255, b / 255, a / 255]);
                }
            }

            if (core.indexBuf) {
                gl.drawElements(core.primitive, core.indexBuf.numItems, core.indexBuf.itemType, 0);            
            } else {
                gl.drawArrays(core.primitive, 0, core.vertexBuf.numItems / 3);
            }

        } else if (frameCtx.pickTriangle) {

            var pickPositions = core.getPickPositions();

            if (pickPositions) {
                gl.drawArrays(core.primitive, 0, pickPositions.numItems / 3);
            }
        }
    }
});
;/**
 *  Create display state chunk type for draw and pick render of flags
 */
SceneJS_ChunkFactory.createChunkType({

    type: "flags",

    build: function () {

        var draw = this.program.draw;

        this._uClippingDraw = draw.getUniform("SCENEJS_uClipping");
        this._uSolidDraw = draw.getUniform("SCENEJS_uSolid");
        this._uSolidColorDraw = draw.getUniform("SCENEJS_uSolidColor");

        var pick = this.program.pick;

        this._uClippingPick = pick.getUniform("SCENEJS_uClipping");
    },

    drawAndPick: function (frameCtx) {

        var gl = this.program.gl;

        var backfaces = this.core.backfaces;

        if (frameCtx.backfaces != backfaces) {
            if (backfaces) {
                gl.disable(gl.CULL_FACE);
            } else {
                gl.enable(gl.CULL_FACE);
            }
            frameCtx.backfaces = backfaces;
        }

        var frontface = this.core.frontface;

        if (frameCtx.frontface != frontface) {
            if (frontface == "ccw") {
                gl.frontFace(gl.CCW);
            } else {
                gl.frontFace(gl.CW);
            }
            frameCtx.frontface = frontface;
        }

        var picking = frameCtx.picking;

        if (picking) {

            if (this._uClippingPick) {
                this._uClippingPick.setValue(this.core.clipping);
            }

        } else {

            var transparent = this.core.transparent;

            if (frameCtx.transparent != transparent) {

                if (transparent) {

                    // Entering a transparency bin

                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                    frameCtx.blendEnabled = true;

                } else {

                    // Leaving a transparency bin

                    gl.disable(gl.BLEND);
                    frameCtx.blendEnabled = false;
                }

                frameCtx.transparent = transparent;
            }

            if (this._uClippingDraw) {
                this._uClippingDraw.setValue(this.core.clipping);
            }

            if (this._uSolidDraw) {
                this._uSolidDraw.setValue(this.core.solid);
            }

            if (this._uSolidColorDraw) {
                this._uSolidColorDraw.setValue(this.core.solidColor);
            }
        }
    }
});
;/**
 *   Create display state chunk type for draw and pick render of renderTarget
 */
SceneJS_ChunkFactory.createChunkType({

    type: "renderTarget",

    // Avoid reapplication of this chunk type after a program switch.
    programGlobal: true,

    draw: function (frameCtx) {

        var gl = this.program.gl;

        // Flush and unbind any render buffer already bound
        if (frameCtx.renderBuf) {
            gl.flush();
            frameCtx.renderBuf.unbind();
            frameCtx.renderBuf = null;
        }

        // Set depthMode false and bail if no render buffer for this chunk
        var renderBuf = this.core.renderBuf;
        if (!renderBuf) {
            frameCtx.depthMode = false;
            return;
        }

        // Bind this chunk's render buffer, set depthMode, enable blend if depthMode false, clear buffer
        renderBuf.bind();

        frameCtx.depthMode = (this.core.bufType === "depth");

        if (!frameCtx.depthMode) {

            //  Enable blending for non-depth targets
            if (frameCtx.blendEnabled) {
                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
            }
        }

        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        gl.clearColor(frameCtx.ambientColor[0], frameCtx.ambientColor[1], frameCtx.ambientColor[2], 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
      //  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        frameCtx.renderBuf = renderBuf;
    }
});;/**
 *  Create display state chunk type for draw and pick render of geometry
 */
SceneJS_ChunkFactory.createChunkType({

    type: "geometry",

    build: function () {

        var draw = this.program.draw;

        this._aRegionMapUVDraw = draw.getAttribute("SCENEJS_aRegionMapUV");
        this._aVertexDraw = draw.getAttribute("SCENEJS_aVertex");
        this._aNormalDraw = draw.getAttribute("SCENEJS_aNormal");

        // Get attributes for unlimited UV layers

        this._aUVDraw = [];
        var aUV;
        for (var i = 0; i < 1000; i++) { // Assuming we'll never have more than 1000 UV layers
            aUV = draw.getAttribute("SCENEJS_aUVCoord" + i);
            if (!aUV) {
                break;
            }
            this._aUVDraw.push(aUV);
        }

        this._aTangentDraw = draw.getAttribute("SCENEJS_aTangent");
        this._aColorDraw = draw.getAttribute("SCENEJS_aVertexColor");

        this._aMorphVertexDraw = draw.getAttribute("SCENEJS_aMorphVertex");
        this._aMorphNormalDraw = draw.getAttribute("SCENEJS_aMorphNormal");
        this._aMorphTangentDraw = draw.getAttribute("SCENEJS_aMorphTangent");
        this._uMorphFactorDraw = draw.getUniform("SCENEJS_uMorphFactor");
        this._uPointSizeDraw = draw.getUniform("SCENEJS_uPointSize");

        var pick = this.program.pick;

        this._aRegionMapUVPick = pick.getAttribute("SCENEJS_aRegionMapUV");
        this._aVertexPick = pick.getAttribute("SCENEJS_aVertex");
        this._aColorPick = pick.getAttribute("SCENEJS_aColor");
        this._aMorphVertexPick = pick.getAttribute("SCENEJS_aMorphVertex");
        this._uMorphFactorPick = pick.getUniform("SCENEJS_uMorphFactor");
        this._uPointSizePick = draw.getUniform("SCENEJS_uPointSize");

        this.VAO = null;
        this.VAOMorphKey1 = 0;
        this.VAOMorphKey2 = 0;
        this.VAOHasInterleavedBuf = false;
    },

    recycle: function () {
        if (this.VAO) {
            // Guarantee that the old VAO is deleted immediately when recycling the object.
            var VAOExt = this.program.gl.getExtension("OES_vertex_array_object");
            VAOExt.deleteVertexArrayOES(this.VAO);
            this.VAO = null;
        }
    },

    morphDraw: function (frameCtx) {

        this.VAOMorphKey1 = this.core.key1;
        this.VAOMorphKey2 = this.core.key2;

        var key1 = this.core.key1;
        var key2 = this.core.key2;

        var target1 = this.core.targets[key1]; // Keys will update
        var target2 = this.core.targets[key2];

        if (this._aMorphVertexDraw) {
            this._aVertexDraw.bindFloatArrayBuffer(target1.vertexBuf);
            this._aMorphVertexDraw.bindFloatArrayBuffer(target2.vertexBuf);
            frameCtx.bindArray += 2;

        } else if (this._aVertexDraw) {
            this._aVertexDraw.bindFloatArrayBuffer(this.core2.vertexBuf);
            frameCtx.bindArray++;
        }

        if (this._aMorphNormalDraw) {
            this._aNormalDraw.bindFloatArrayBuffer(target1.normalBuf);
            this._aMorphNormalDraw.bindFloatArrayBuffer(target2.normalBuf);
            frameCtx.bindArray += 2;

        } else if (this._aNormalDraw) {
            this._aNormalDraw.bindFloatArrayBuffer(this.core2.normalBuf);
            frameCtx.bindArray++;
        }

        if (this._aMorphTangentDraw || this._aTangentDraw) {

            // Bind tangent arrays from geometry and morphGeometry

            // In the texture chunk we remembered which UV layer we're using for the normal
            // map so that we can lazy-generate the tangents from the appropriate UV layer
            // in the geometry chunk.

            // Note that only one normal map is allowed per drawable, so there
            // will be only one UV layer used for normal mapping.

            var normalMapUVLayerIdx = frameCtx.normalMapUVLayerIdx;
            if (normalMapUVLayerIdx >= 0) {
                if (this._aMorphTangentDraw) {
                    this._aTangentDraw.bindFloatArrayBuffer(this.core.getTangents(key1, this.core2.arrays.indices, this.core2.arrays.uvs[normalMapUVLayerIdx]));
                    this._aMorphTangentDraw.bindFloatArrayBuffer(this.core.getTangents(key2, this.core2.arrays.indices, this.core2.arrays.uvs[normalMapUVLayerIdx]));
                    frameCtx.bindArray += 2;

                } else if (this._aTangentDraw) {

                    // TODO: What's this for?
                    //this._aTangentDraw.bindFloatArrayBuffer(this.core2.tangentBuf);
                }
            }
        }

        // Bind UV layer from geometry

        var uvBuf;
        for (var i = 0, len = this._aUVDraw.length; i < len; i++) {
            uvBuf = this.core2.uvBufs[i];
            if (uvBuf) {
                this._aUVDraw[i].bindFloatArrayBuffer(uvBuf);
                frameCtx.bindArray++;
            }
        }

        if (this._aColorDraw) {
            this._aColorDraw.bindFloatArrayBuffer(this.core2.colorBuf);
            frameCtx.bindArray++;
        }

        this.setDrawMorphFactor();
    },

    setDrawMorphFactor: function () {
        if (this._uMorphFactorDraw) {
            this._uMorphFactorDraw.setValue(this.core.factor); // Bind LERP factor
        }
    },

    draw: function (frameCtx) {
        var doMorph = this.core.targets && this.core.targets.length;
        var cleanInterleavedBuf = this.core2.interleavedBuf && !this.core2.interleavedBuf.dirty;

        if (this._uPointSizeDraw) {
            this._uPointSizeDraw.setValue(this.core2.pointSize);
        }

        if (this.VAO && frameCtx.VAO) { // Workaround for https://github.com/xeolabs/scenejs/issues/459
            frameCtx.VAO.bindVertexArrayOES(this.VAO);
            if (doMorph) {
                if (this.VAOMorphKey1 == this.core.key1 && this.VAOMorphKey2 == this.core.key2) {
                    this.setDrawMorphFactor();
                    return;
                }
            } else if (cleanInterleavedBuf || !this.VAOHasInterleavedBuf) {
                return;
            }
        } else if (frameCtx.VAO) {
            // Start creating a new VAO by switching to the default VAO, which doesn't have attribs enabled.
            frameCtx.VAO.bindVertexArrayOES(null);
            this.VAO = frameCtx.VAO.createVertexArrayOES();
            frameCtx.VAO.bindVertexArrayOES(this.VAO);
        }

        if (doMorph) {
            this.morphDraw(frameCtx);
        } else {
            if (cleanInterleavedBuf) {
                this.VAOHasInterleavedBuf = true;
                this.core2.interleavedBuf.bind();
                if (this._aVertexDraw) {
                    this._aVertexDraw.bindInterleavedFloatArrayBuffer(3, this.core2.interleavedStride, this.core2.interleavedPositionOffset);
                    frameCtx.bindArray++;
                }
                if (this._aNormalDraw) {
                    this._aNormalDraw.bindInterleavedFloatArrayBuffer(3, this.core2.interleavedStride, this.core2.interleavedNormalOffset);
                    frameCtx.bindArray++;
                }
                for (var i = 0, len = this._aUVDraw.length; i < len; i++) {
                    this._aUVDraw[i].bindInterleavedFloatArrayBuffer(2, this.core2.interleavedStride, this.core2.interleavedUVOffsets[i]);
                    frameCtx.bindArray++;
                }
                if (this._aColorDraw) {
                    this._aColorDraw.bindInterleavedFloatArrayBuffer(4, this.core2.interleavedStride, this.core2.interleavedColorOffset);
                    frameCtx.bindArray++;
                }
            } else {
                this.VAOHasInterleavedBuf = false;
                if (this._aVertexDraw) {
                    this._aVertexDraw.bindFloatArrayBuffer(this.core2.vertexBuf);
                    frameCtx.bindArray++;
                }
                if (this._aNormalDraw) {
                    this._aNormalDraw.bindFloatArrayBuffer(this.core2.normalBuf);
                    frameCtx.bindArray++;
                }
                var uvBuf;
                for (var i = 0, len = this._aUVDraw.length; i < len; i++) {
                    uvBuf = this.core2.uvBufs[i];
                    if (uvBuf) {
                        this._aUVDraw[i].bindFloatArrayBuffer(uvBuf);
                        frameCtx.bindArray++;
                    }
                }
                if (this._aColorDraw) {
                    this._aColorDraw.bindFloatArrayBuffer(this.core2.colorBuf);
                    frameCtx.bindArray++;
                }
            }

            if (this._aTangentDraw) {

                // In the texture chunk we remembered which UV layer we're using for the normal
                // map so that we can lazy-generate the tangents from the appropriate UV layer
                // in the geometry chunk.

                // Note that only one normal map is allowed per drawable, so there
                // will be only one UV layer used for normal mapping.

                var normalMapUVLayerIdx = frameCtx.normalMapUVLayerIdx;
                if (normalMapUVLayerIdx >= 0) {
                    this._aTangentDraw.bindFloatArrayBuffer(this.core2.getTangents(normalMapUVLayerIdx));
                    frameCtx.bindArray++;
                }
            }
        }

        if (this._aRegionMapUVDraw) {
            var regionMapUVLayerIdx = frameCtx.regionMapUVLayerIdx; // Set by regionMapChunk
            if (regionMapUVLayerIdx >= 0) {
                var uvBufs = this.core2.uvBufs;
                if (regionMapUVLayerIdx < uvBufs.length) {
                    this._aRegionMapUVDraw.bindFloatArrayBuffer(uvBufs[regionMapUVLayerIdx]);
                    frameCtx.bindArray++;
                }
            }
        }

        if (this.core2.indexBuf) {
            this.core2.indexBuf.bind();
        }
    },

    morphPick: function (frameCtx) {

        var core = this.core;
        var core2 = this.core2;

        var target1 = core.targets[core.key1];
        var target2 = core.targets[core.key2];

        if (frameCtx.pickObject || frameCtx.pickRegion) {

            if (this._aMorphVertexPick) {

                this._aVertexPick.bindFloatArrayBuffer(target1.vertexBuf);
                this._aMorphVertexPick.bindFloatArrayBuffer(target2.vertexBuf);

            } else if (this._aVertexPick) {
                this._aVertexPick.bindFloatArrayBuffer(core2.vertexBuf);
            }

            core2.indexBuf.bind();

        } else if (frameCtx.pickTriangle) {

            if (this._aMorphVertexPick) {

                var pickPositionsBuf = core.getPickPositions(core.key1, core2.arrays.indices);
                if (pickPositionsBuf) {
                    this._aVertexPick.bindFloatArrayBuffer(pickPositionsBuf);
                }

                pickPositionsBuf = core.getPickPositions(core.key2, core2.arrays.indices);
                if (pickPositionsBuf) {
                    this._aMorphVertexPick.bindFloatArrayBuffer(pickPositionsBuf);
                }

                if (this._aColorPick) {
                    this._aColorPick.bindFloatArrayBuffer(core2.getPickColors());
                }

            } else if (this._aVertexPick) {

                this._aVertexPick.bindFloatArrayBuffer(core2.vertexBuf);

                core2.indexBuf.bind();
            }
        }

        if (this._uMorphFactorPick) {
            this._uMorphFactorPick.setValue(core.factor);
        }
    },

    pick: function (frameCtx) {

        var core = this.core;
        var core2 = this.core2;

        if (core.targets && core.targets.length) {

            this.morphPick(frameCtx);

        } else {

            if (frameCtx.pickObject || frameCtx.pickRegion) {

                if (this._aVertexPick) {
                    this._aVertexPick.bindFloatArrayBuffer(core2.vertexBuf);
                }

                if (this._aRegionMapUVPick) {
                    this._aRegionMapUVPick.bindFloatArrayBuffer(core2.uvBufs[frameCtx.regionMapUVLayerIdx]); // Set by regionMapChunk
                }

                if (core2.indexBuf) {
                    core2.indexBuf.bind();
                }

            } else if (frameCtx.pickTriangle) {

                if (this._aVertexPick) {
                    this._aVertexPick.bindFloatArrayBuffer(core2.getPickPositions());
                }

                if (this._aColorPick) {
                    this._aColorPick.bindFloatArrayBuffer(core2.getPickColors());
                }

            }

            if (this._uPointSizePick) {
                this._uPointSizePick.setValue(this.core2.pointSize);
            }
        }
    }
});
;/**
 *  Create display state chunk type for draw render of lights projection
 */
SceneJS_ChunkFactory.createChunkType({

    type:"lights",

    build:function () {

        this._uAmbientColor = this._uAmbientColor || [];
        this._uLightColor = this._uLightColor || [];
        this._uLightDir = this._uLightDir || [];
        this._uLightPos = this._uLightPos || [];
        this._uLightCutOff = this._uLightCutOff || [];
        this._uLightSpotExp = this._uLightSpotExp || [];
        this._uLightAttenuation = this._uLightAttenuation || [];
        this._uInnerCone = this._uInnerCone || [];
        this._uOuterCone = this._uOuterCone || [];

        var lights = this.core.lights;
        var program = this.program;

        for (var i = 0, len = lights.length; i < len; i++) {

            switch (lights[i].mode) {

                case "ambient":
                    this._uAmbientColor[i] = (program.draw.getUniform("SCENEJS_uAmbientColor"));
                    break;

                case "dir":
                    this._uLightColor[i] = program.draw.getUniform("SCENEJS_uLightColor" + i);
                    this._uLightPos[i] = null;
                    this._uLightDir[i] = program.draw.getUniform("SCENEJS_uLightDir" + i);
                    break;

                case "point":
                    this._uLightColor[i] = program.draw.getUniform("SCENEJS_uLightColor" + i);
                    this._uLightPos[i] = program.draw.getUniform("SCENEJS_uLightPos" + i);
                    this._uLightDir[i] = null;
                    this._uLightAttenuation[i] = program.draw.getUniform("SCENEJS_uLightAttenuation" + i);
                    break;

                case "spot":
                    this._uLightColor[i] = program.draw.getUniform("SCENEJS_uLightColor" + i);
                    this._uLightPos[i] = program.draw.getUniform("SCENEJS_uLightPos" + i);
                    this._uLightDir[i] = program.draw.getUniform("SCENEJS_uLightDir" + i);
                    this._uLightAttenuation[i] = program.draw.getUniform("SCENEJS_uLightAttenuation" + i);
                    this._uInnerCone[i] = program.draw.getUniform("SCENEJS_uInnerCone" + i);
                    this._uOuterCone[i] = program.draw.getUniform("SCENEJS_uOuterCone" + i);
                    break;
            }
        }
    },

    draw:function (frameCtx) {

        if (frameCtx.dirty) {
            this.build();
        }

        var lights = this.core.lights;
        var light;

        var gl = this.program.gl;

        for (var i = 0, len = lights.length; i < len; i++) {

            light = lights[i];

            if (this._uAmbientColor[i]) {
                this._uAmbientColor[i].setValue(light.color);

            } else {

                if (this._uLightColor[i]) {
                    this._uLightColor[i].setValue(light.color);
                }

                if (this._uLightPos[i]) {
                    this._uLightPos[i].setValue(light.pos);

                    if (this._uLightAttenuation[i]) {
                        this._uLightAttenuation[i].setValue(light.attenuation);
                    }
                }

                if (this._uLightDir[i]) {
                    this._uLightDir[i].setValue(light.dir);
                }

                if (this._uInnerCone[i]) {
                    this._uInnerCone[i].setValue(light.innerCone);
                }

                if (this._uOuterCone[i]) {
                    this._uOuterCone[i].setValue(light.outerCone);
                }
            }
        }
    }
});
;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type: "listeners",

    // Avoid reapplication of a chunk after a program switch.
    programGlobal:true,

    build : function() {
    },

    draw : function(frameCtx) {

        var listeners = this.core.listeners;
        var renderListenerCtx = frameCtx.renderListenerCtx;

        for (var i = listeners.length - 1; i >= 0; i--) { // Child listeners first
            if (listeners[i](renderListenerCtx) === true) { // Call listener with query facade object as scope
                return true;
            }
        }
    }
});;/**
 * Create display state chunk type for draw and pick render of lookAt transform
 */
SceneJS_ChunkFactory.createChunkType({

    type: "lookAt",

    build : function() {

        this._uvMatrixDraw = this.program.draw.getUniform("SCENEJS_uVMatrix");
        this._uVNMatrixDraw = this.program.draw.getUniform("SCENEJS_uVNMatrix");
        this._uWorldEyeDraw = this.program.draw.getUniform("SCENEJS_uWorldEye");

        this._uvMatrixPick = this.program.pick.getUniform("SCENEJS_uVMatrix");
    },

    draw : function(frameCtx) {

        if (this.core.dirty) {
            this.core.rebuild();
        }

        var gl = this.program.gl;

        if (this._uvMatrixDraw) {
            this._uvMatrixDraw.setValue(this.core.mat);
        }

        if (this._uVNMatrixDraw) {
            this._uVNMatrixDraw.setValue(this.core.normalMat);
        }

        if (this._uWorldEyeDraw) {
            this._uWorldEyeDraw.setValue(this.core.lookAt.eye);
        }

        frameCtx.viewMat = this.core.mat;
    },

    pick : function(frameCtx) {

        var gl = this.program.gl;

        if (this._uvMatrixPick) {
            this._uvMatrixPick.setValue(this.core.mat);
        }

        frameCtx.viewMat = this.core.mat;
    }
});;SceneJS_ChunkFactory.createChunkType({

    type: "material",

    build: function () {

        var draw = this.program.draw;

        this._uMaterialBaseColor = draw.getUniform("SCENEJS_uMaterialColor");
        this._uMaterialSpecularColor = draw.getUniform("SCENEJS_uMaterialSpecularColor");
        this._uMaterialEmitColor = draw.getUniform("SCENEJS_uMaterialEmitColor");

        this._uMaterialSpecular = draw.getUniform("SCENEJS_uMaterialSpecular");
        this._uMaterialShine = draw.getUniform("SCENEJS_uMaterialShine");
        this._uMaterialEmit = draw.getUniform("SCENEJS_uMaterialEmit");

        this._uMaterialAlpha = draw.getUniform("SCENEJS_uMaterialAlpha");
    },

    draw: function () {

        var gl = this.program.gl;

        if (this._uMaterialBaseColor) {
            this._uMaterialBaseColor.setValue(this.core.baseColor);
        }

        if (this._uMaterialSpecularColor) {
            this._uMaterialSpecularColor.setValue(this.core.specularColor);
        }

        if (this._uMaterialEmitColor) {
            this._uMaterialEmitColor.setValue(this.core.emitColor);
        }

        if (this._uMaterialSpecular) {
            this._uMaterialSpecular.setValue(this.core.specular);
        }

        if (this._uMaterialShine) {
            this._uMaterialShine.setValue(this.core.shine);
        }

        if (this._uMaterialEmit) {
            this._uMaterialEmit.setValue(this.core.emit);
        }

        if (this._uMaterialAlpha) {
            this._uMaterialAlpha.setValue(this.core.alpha);
        }
    }
});
;SceneJS_ChunkFactory.createChunkType({

    type: "program",

    build: function () {

        // Note that "program" chunks are always after "renderTarget" chunks
        this._depthModeDraw = this.program.draw.getUniform("SCENEJS_uDepthMode");
        this._pickMode = this.program.pick.getUniform("SCENEJS_uPickMode");
    },

    draw: function (frameCtx) {
        var drawProgram = this.program.draw;
        drawProgram.bind();
        frameCtx.textureUnit = 0;
        var gl = this.program.gl;
        if (this._depthModeDraw) {
            this._depthModeDraw.setValue(frameCtx.depthMode);
        }
        if (!frameCtx.VAO) {
            for (var i = 0; i < 10; i++) {
                gl.disableVertexAttribArray(i);
            }
        }

        frameCtx.drawProgram = this.program.draw;
        frameCtx.useProgram++;
    },

    pick: function (frameCtx) {

        var pickProgram = this.program.pick;
        pickProgram.bind();

        var gl = this.program.gl;

        // Set the picking mode

        if (frameCtx.pickObject) {
            this._pickMode.setValue(0.0); // Pick object

        } else if (frameCtx.pickTriangle) {
            this._pickMode.setValue(1.0);// Pick triangle

        } else {
            this._pickMode.setValue(2.0); // Pick region
        }

        frameCtx.textureUnit = 0;

        for (var i = 0; i < 10; i++) {
            gl.disableVertexAttribArray(i);
        }
    }
});



;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type: "renderer",

    build: function () {
    },

    drawAndPick: function (frameCtx) {

        if (this.core.props) {
            var gl = this.program.gl;
            if (frameCtx.renderer) {
                frameCtx.renderer.props.restoreProps(gl);
                frameCtx.renderer = this.core;
            }
            this.core.props.setProps(gl);
        }
    }
});
;SceneJS_ChunkFactory.createChunkType({

    type: "regionMap",

    build: function () {
        this._uRegionMapRegionColor = this.program.draw.getUniform("SCENEJS_uRegionMapRegionColor");
        this._uRegionMapHighlightFactor = this.program.draw.getUniform("SCENEJS_uRegionMapHighlightFactor");
        this._uRegionMapHideAlpha = this.program.draw.getUniform("SCENEJS_uRegionMapHideAlpha");
        this._uRegionMapSampler = "SCENEJS_uRegionMapSampler";
    },

    draw: function (frameCtx) {

        var texture = this.core.texture;

        if (texture) {

            this.program.draw.bindTexture(this._uRegionMapSampler, texture, frameCtx.textureUnit);
            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;
        }

        var gl = this.program.gl;
        var transparent = this.core.mode === "hide" || this.core.mode === "isolate";

        if (frameCtx.transparent != transparent) {

            if (transparent) {

                // Entering a transparency bin

                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                frameCtx.blendEnabled = true;

            } else {

                // Leaving a transparency bin

                gl.disable(gl.BLEND);
                frameCtx.blendEnabled = false;
            }

            frameCtx.transparent = transparent;
        }

        if (texture) {

            if (this._uRegionMapRegionColor) {
                this._uRegionMapRegionColor.setValue(this.core.regionColor);
            }

            if (this._uRegionMapHighlightFactor) {
                this._uRegionMapHighlightFactor.setValue(this.core.highlightFactor);
            }

            if (this._uRegionMapHideAlpha) {
                this._uRegionMapHideAlpha.setValue(this.core.hideAlpha);
            }

            frameCtx.regionMapUVLayerIdx = this.core.uvLayerIdx;

        } else {

            frameCtx.regionMapUVLayerIdx = -1;
        }
    },

    pick: function (frameCtx) {

        var texture = this.core.texture;

        if (texture) {

            frameCtx.regionData = this.core.regionData;

            frameCtx.textureUnit = 0;

            this.program.pick.bindTexture(this._uRegionMapSampler, texture, frameCtx.textureUnit);
            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;

            frameCtx.regionMapUVLayerIdx = this.core.uvLayerIdx;

        } else {

            frameCtx.regionMapUVLayerIdx = -1;
        }
    }
});;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type:"depthBuffer",

    // Avoid reapplication of a chunk after a program switch.
    programGlobal:true,

    drawAndPick:function (frameCtx) {

        var gl = this.program.gl;

        var enabled = this.core.enabled;

        if (frameCtx.depthbufEnabled != enabled) {
            if (enabled) {
                gl.enable(gl.DEPTH_TEST);
            } else {
                gl.disable(gl.DEPTH_TEST);
            }
            frameCtx.depthbufEnabled = enabled;
        }

        var clearDepth = this.core.clearDepth;

        if (frameCtx.clearDepth != clearDepth) {
            gl.clearDepth(clearDepth);
            frameCtx.clearDepth = clearDepth;
        }

        var depthFunc = this.core.depthFunc;

        if (frameCtx.depthFunc != depthFunc) {
            gl.depthFunc(depthFunc);
            frameCtx.depthFunc = depthFunc;
        }

        if (this.core.clear) {
            gl.clear(gl.DEPTH_BUFFER_BIT);
        }
    }
});
;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type: "stencilBuffer",

    // Avoid reapplication of a chunk after a program switch.
    programGlobal: true,

    drawAndPick: function (frameCtx) {

        var gl = this.program.gl;

        var enabled = this.core.enabled;

        if (frameCtx.stencilbufEnabled != enabled) {
            if (enabled) {
                gl.enable(gl.STENCIL_TEST);
            } else {
                gl.disable(gl.STENCIL_TEST);
            }
            frameCtx.stencilbufEnabled = enabled;
        }

        var clearStencil = this.core.clearStencil;

        if (clearStencil !== undefined) {
            if (frameCtx.clearStencil != clearStencil) {
                gl.clearStencil(clearStencil);
                frameCtx.clearStencil = clearStencil;
            }
        }
        
        var stencilFuncFuncFront = this.core.stencilFuncFuncFront;
        var stencilFuncRefFront = this.core.stencilFuncRefFront;
        var stencilFuncMaskFront = this.core.stencilFuncMaskFront;

        if (stencilFuncFuncFront) {
            if (frameCtx.stencilFuncFuncFront != stencilFuncFuncFront ||
                frameCtx.stencilFuncRefFront != stencilFuncRefFront ||
                frameCtx.stencilFuncMaskFront != stencilFuncMaskFront
                ) {
                gl.stencilFuncSeparate(gl.FRONT, stencilFuncFuncFront, stencilFuncRefFront, stencilFuncMaskFront);
                frameCtx.stencilFuncFuncFront = stencilFuncFuncFront;
                frameCtx.stencilFuncRefFront = stencilFuncRefFront;
                frameCtx.stencilFuncMaskFront = stencilFuncMaskFront;
            }
        }

        var stencilFuncFuncBack = this.core.stencilFuncFuncBack;
        var stencilFuncRefBack = this.core.stencilFuncRefBack;
        var stencilFuncMaskBack = this.core.stencilFuncMaskBack;

        if (stencilFuncFuncBack) {
            if (frameCtx.stencilFuncFuncBack != stencilFuncFuncBack ||
                frameCtx.stencilFuncRefBack != stencilFuncRefBack ||
                frameCtx.stencilFuncMaskBack != stencilFuncMaskBack
                ) {
                gl.stencilFuncSeparate(gl.BACK, stencilFuncFuncBack, stencilFuncRefBack, stencilFuncMaskBack);
                frameCtx.stencilFuncFuncBack = stencilFuncFuncBack;
                frameCtx.stencilFuncRefBack = stencilFuncRefBack;
                frameCtx.stencilFuncMaskBack = stencilFuncMaskBack;
            }
        }

        var stencilOpSfailFront = this.core.stencilOpSfailFront;
        var stencilOpDpfailFront = this.core.stencilOpDpfailFront;
        var stencilOpDppassFront = this.core.stencilOpDppassFront;

        if (stencilOpSfailFront) {
            if (frameCtx.stencilOpSfailFront != stencilOpSfailFront ||
                frameCtx.stencilOpDpfailFront != stencilOpDpfailFront ||
                frameCtx.stencilOpDppassFront != stencilOpDppassFront
                ) {
                gl.stencilOpSeparate(gl.FRONT, stencilOpSfailFront, stencilOpDpfailFront, stencilOpDppassFront);
                frameCtx.stencilOpSfailFront = stencilOpSfailFront;
                frameCtx.stencilOpDpfailFront = stencilOpDpfailFront;
                frameCtx.stencilOpDppassFront = stencilOpDppassFront;
            }
        }

        var stencilOpSfailBack = this.core.stencilOpSfailBack;
        var stencilOpDpfailBack = this.core.stencilOpDpfailBack;
        var stencilOpDppassBack = this.core.stencilOpDppassBack;

        if (stencilOpSfailBack) {
            if (frameCtx.stencilOpSfailBack != stencilOpSfailBack ||
                frameCtx.stencilOpDpfailBack != stencilOpDpfailBack ||
                frameCtx.stencilOpDppassBack != stencilOpDppassBack
                ) {
                gl.stencilOpSeparate(gl.BACK, stencilOpSfailBack, stencilOpDpfailBack, stencilOpDppassBack);
                frameCtx.stencilOpSfailBack = stencilOpSfailBack;
                frameCtx.stencilOpDpfailBack = stencilOpDpfailBack;
                frameCtx.stencilOpDppassBack = stencilOpDppassBack;
            }
        }

        if (this.core.clear) {
            gl.clear(gl.STENCIL_BUFFER_BIT);
        }
    }
});
;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type:"colorBuffer",

    // Avoid reapplication of a chunk after a program switch.
    programGlobal:true,

    build:function () {
    },

    drawAndPick:function (frameCtx) {

        if (!frameCtx.transparent) { // Blending forced when rendering transparent bin

            var blendEnabled = this.core.blendEnabled;

            var gl = this.program.gl;

            if (frameCtx.blendEnabled != blendEnabled) {
                if (blendEnabled) {
                    gl.enable(gl.BLEND);
                } else {
                    gl.disable(gl.BLEND);
                }
                frameCtx.blendEnabled = blendEnabled;
            }

            var colorMask = this.core.colorMask;
            gl.colorMask(colorMask.r, colorMask.g, colorMask.b, colorMask.a);
        }
    }
});
;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type:"view",

    // Avoid reapplication of a chunk after a program switch.
    programGlobal:true,

    build:function () {
    },

    drawAndPick:function (frameCtx) {

        var scissorTestEnabled = this.core.scissorTestEnabled;

        if (frameCtx.scissorTestEnabled != scissorTestEnabled) {
            var gl = this.program.gl;
            if (scissorTestEnabled) {
                gl.enable(gl.SCISSOR_TEST);
            } else {
                gl.disable(gl.SCISSOR_TEST);
            }
            frameCtx.scissorTestEnabled = scissorTestEnabled;
        }
    }
});
;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type: "shader",

    build : function() {
    },

    drawAndPick : function(frameCtx) {

        var paramsStack = this.core.paramsStack;

        if (paramsStack) {

            var program = frameCtx.picking ? this.program.pick : this.program.draw;
            var params;
            var name;

            for (var i = 0, len = paramsStack.length; i < len; i++) {
                params = paramsStack[i];
                for (name in params) {
                    if (params.hasOwnProperty(name)) {
                        program.setUniform(name, params[name]);  // TODO: cache locations
                    }
                }
            }
        }
    }
});;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type: "shaderParams",

    build : function() {
    },

    drawAndPick: function(frameCtx) {

        var paramsStack = this.core.paramsStack;

        if (paramsStack) {

            var program = frameCtx.picking ? this.program.pick : this.program.draw;
            var params;
            var name;

            for (var i = 0, len = paramsStack.length; i < len; i++) {
                params = paramsStack[i];
                for (name in params) {
                    if (params.hasOwnProperty(name)) {
                        program.setUniform(name, params[name]);  // TODO: cache locations
                    }
                }
            }
        }
    }
});;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type:"style",

    // Avoid reapplication of a chunk after a program switch.
    programGlobal:true,

    drawAndPick:function (frameCtx) {

        var lineWidth = this.core.lineWidth;

        if (frameCtx.lineWidth != lineWidth) {
            var gl = this.program.gl;
            gl.lineWidth(lineWidth);
            frameCtx.lineWidth = lineWidth;
        }
    }
});
;SceneJS_ChunkFactory.createChunkType({

    type: "texture",

    build : function() {

        this._uTexSampler = this._uTexSampler || [];
        this._uTexMatrix = this._uTexMatrix || [];
        this._uTexBlendFactor = this._uTexBlendFactor || [];

        var layers = this.core.layers;

        if (layers) {

            var layer;
            var draw = this.program.draw;

            for (var i = 0, len = layers.length; i < len; i++) {

                layer = layers[i];

                this._uTexSampler[i] = "SCENEJS_uSampler" + i;

                this._uTexMatrix[i] = draw.getUniform("SCENEJS_uLayer" + i + "Matrix");

                this._uTexBlendFactor[i] = draw.getUniform("SCENEJS_uLayer" + i + "BlendFactor");
            }
        }
    },

    draw : function(frameCtx) {

        frameCtx.textureUnit = 0;
        frameCtx.normalMapUVLayerIdx = -1;

        var layers = this.core.layers;

        if (layers) {

            var draw = this.program.draw;
            var layer;

            for (var i = 0, len = layers.length; i < len; i++) {

                layer = layers[i];

                if (this._uTexSampler[i] && layer.texture) {    // Lazy-loads

                    draw.bindTexture(this._uTexSampler[i], layer.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;

                    frameCtx.bindTexture++;

                    if (layer._matrixDirty && layer.buildMatrix) {
                        layer.buildMatrix.call(layer);
                    }

                    if (this._uTexMatrix[i]) {
                        this._uTexMatrix[i].setValue(layer.matrixAsArray);
                    }

                    if (this._uTexBlendFactor[i]) {
                        this._uTexBlendFactor[i].setValue(layer.blendFactor);
                    }

                    if (layer.isNormalMap) {

                        // Remember which UV layer we're using for the normal
                        // map so that we can lazy-generate the tangents from the
                        // appropriate UV layer in the geometry chunk.

                        // Note that only one normal map is allowed per drawable, so there
                        // will be only one UV layer used for normal mapping.

                        frameCtx.normalMapUVLayerIdx = layer.uvLayerIdx;
                    }

                } else {
                     // draw.bindTexture(this._uTexSampler[i], null, i); // Unbind
                }
            }
        }

        frameCtx.texture = this.core;
    }
});;SceneJS_ChunkFactory.createChunkType({

    type: "fresnel",

    build: function () {

        var draw = this.program.draw;

        var core = this.core;

        if (core.diffuse) {
            this._uDiffuseFresnelCenterBias = draw.getUniform("SCENEJS_uDiffuseFresnelCenterBias");
            this._uDiffuseFresnelEdgeBias = draw.getUniform("SCENEJS_uDiffuseFresnelEdgeBias");
            this._uDiffuseFresnelPower = draw.getUniform("SCENEJS_uDiffuseFresnelPower");
            this._uDiffuseFresnelCenterColor = draw.getUniform("SCENEJS_uDiffuseFresnelCenterColor");
            this._uDiffuseFresnelEdgeColor = draw.getUniform("SCENEJS_uDiffuseFresnelEdgeColor");
        }

        if (core.specular) {
            this._uSpecularFresnelCenterBias = draw.getUniform("SCENEJS_uSpecularFresnelCenterBias");
            this._uSpecularFresnelEdgeBias = draw.getUniform("SCENEJS_uSpecularFresnelEdgeBias");
            this._uSpecularFresnelPower = draw.getUniform("SCENEJS_uSpecularFresnelPower");
            this._uSpecularFresnelCenterColor = draw.getUniform("SCENEJS_uSpecularFresnelCenterColor");
            this._uSpecularFresnelEdgeColor = draw.getUniform("SCENEJS_uSpecularFresnelEdgeColor");
        }

        if (core.alpha) {
            this._uAlphaFresnelCenterBias = draw.getUniform("SCENEJS_uAlphaFresnelCenterBias");
            this._uAlphaFresnelEdgeBias = draw.getUniform("SCENEJS_uAlphaFresnelEdgeBias");
            this._uAlphaFresnelPower = draw.getUniform("SCENEJS_uAlphaFresnelPower");
            this._uAlphaFresnelCenterColor = draw.getUniform("SCENEJS_uAlphaFresnelCenterColor");
            this._uAlphaFresnelEdgeColor = draw.getUniform("SCENEJS_uAlphaFresnelEdgeColor");
        }

        if (core.reflect) {
            this._uReflectFresnelCenterBias = draw.getUniform("SCENEJS_uReflectFresnelCenterBias");
            this._uReflectFresnelEdgeBias = draw.getUniform("SCENEJS_uReflectFresnelEdgeBias");
            this._uReflectFresnelPower = draw.getUniform("SCENEJS_uReflectFresnelPower");
            this._uReflectFresnelCenterColor = draw.getUniform("SCENEJS_uReflectFresnelCenterColor");
            this._uReflectFresnelEdgeColor = draw.getUniform("SCENEJS_uReflectFresnelEdgeColor");
        }

        if (core.emit) {
            this._uEmitFresnelCenterBias = draw.getUniform("SCENEJS_uEmitFresnelCenterBias");
            this._uEmitFresnelEdgeBias = draw.getUniform("SCENEJS_uEmitFresnelEdgeBias");
            this._uEmitFresnelPower = draw.getUniform("SCENEJS_uEmitFresnelPower");
            this._uEmitFresnelCenterColor = draw.getUniform("SCENEJS_uEmitFresnelCenterColor");
            this._uEmitFresnelEdgeColor = draw.getUniform("SCENEJS_uEmitFresnelEdgeColor");
        }

        if (core.fragment) {
            this._uFragmentFresnelCenterBias = draw.getUniform("SCENEJS_uFragmentFresnelCenterBias");
            this._uFragmentFresnelEdgeBias = draw.getUniform("SCENEJS_uFragmentFresnelEdgeBias");
            this._uFragmentFresnelPower = draw.getUniform("SCENEJS_uFragmentFresnelPower");
            this._uFragmentFresnelCenterColor = draw.getUniform("SCENEJS_uFragmentFresnelCenterColor");
            this._uFragmentFresnelEdgeColor = draw.getUniform("SCENEJS_uFragmentFresnelEdgeColor");
        }
    },

    draw: function () {

        var gl = this.program.gl;

        var core = this.core;

        if (core.diffuse) {
            
            if (this._uDiffuseFresnelCenterBias) {
                this._uDiffuseFresnelCenterBias.setValue(core.diffuse.centerBias);
            }

            if (this._uDiffuseFresnelEdgeBias) {
                this._uDiffuseFresnelEdgeBias.setValue(core.diffuse.edgeBias);
            }

            if (this._uDiffuseFresnelPower) {
                this._uDiffuseFresnelPower.setValue(core.diffuse.power);
            }

            if (this._uDiffuseFresnelCenterColor) {
                this._uDiffuseFresnelCenterColor.setValue(core.diffuse.centerColor);
            }

            if (this._uDiffuseFresnelEdgeColor) {
                this._uDiffuseFresnelEdgeColor.setValue(core.diffuse.edgeColor);
            }
        }

        if (core.specular) {

            if (this._uSpecularFresnelCenterBias) {
                this._uSpecularFresnelCenterBias.setValue(core.specular.centerBias);
            }

            if (this._uSpecularFresnelEdgeBias) {
                this._uSpecularFresnelEdgeBias.setValue(core.specular.edgeBias);
            }

            if (this._uSpecularFresnelPower) {
                this._uSpecularFresnelPower.setValue(core.specular.power);
            }

            if (this._uSpecularFresnelCenterColor) {
                this._uSpecularFresnelCenterColor.setValue(core.specular.centerColor);
            }

            if (this._uSpecularFresnelEdgeColor) {
                this._uSpecularFresnelEdgeColor.setValue(core.specular.edgeColor);
            }
        }

        if (core.alpha) {

            if (this._uAlphaFresnelCenterBias) {
                this._uAlphaFresnelCenterBias.setValue(core.alpha.centerBias);
            }

            if (this._uAlphaFresnelEdgeBias) {
                this._uAlphaFresnelEdgeBias.setValue(core.alpha.edgeBias);
            }

            if (this._uAlphaFresnelPower) {
                this._uAlphaFresnelPower.setValue(core.alpha.power);
            }

            if (this._uAlphaFresnelCenterColor) {
                this._uAlphaFresnelCenterColor.setValue(core.alpha.centerColor);
            }

            if (this._uAlphaFresnelEdgeColor) {
                this._uAlphaFresnelEdgeColor.setValue(core.alpha.edgeColor);
            }
        }

        if (core.reflect) {

            if (this._uReflectFresnelCenterBias) {
                this._uReflectFresnelCenterBias.setValue(core.reflect.centerBias);
            }

            if (this._uReflectFresnelEdgeBias) {
                this._uReflectFresnelEdgeBias.setValue(core.reflect.edgeBias);
            }

            if (this._uReflectFresnelPower) {
                this._uReflectFresnelPower.setValue(core.reflect.power);
            }

            if (this._uReflectFresnelCenterColor) {
                this._uReflectFresnelCenterColor.setValue(core.reflect.centerColor);
            }

            if (this._uReflectFresnelEdgeColor) {
                this._uReflectFresnelEdgeColor.setValue(core.reflect.edgeColor);
            }
        }

        if (core.emit) {

            if (this._uEmitFresnelCenterBias) {
                this._uEmitFresnelCenterBias.setValue(core.emit.centerBias);
            }

            if (this._uEmitFresnelEdgeBias) {
                this._uEmitFresnelEdgeBias.setValue(core.emit.edgeBias);
            }

            if (this._uEmitFresnelPower) {
                this._uEmitFresnelPower.setValue(core.emit.power);
            }

            if (this._uEmitFresnelCenterColor) {
                this._uEmitFresnelCenterColor.setValue(core.emit.centerColor);
            }

            if (this._uEmitFresnelEdgeColor) {
                this._uEmitFresnelEdgeColor.setValue(core.emit.edgeColor);
            }
        }

        if (core.fragment) {

            if (this._uFragmentFresnelCenterBias) {
                this._uFragmentFresnelCenterBias.setValue(core.fragment.centerBias);
            }

            if (this._uFragmentFresnelEdgeBias) {
                this._uFragmentFresnelEdgeBias.setValue(core.fragment.edgeBias);
            }

            if (this._uFragmentFresnelPower) {
                this._uFragmentFresnelPower.setValue(core.fragment.power);
            }

            if (this._uFragmentFresnelCenterColor) {
                this._uFragmentFresnelCenterColor.setValue(core.fragment.centerColor);
            }

            if (this._uFragmentFresnelEdgeColor) {
                this._uFragmentFresnelEdgeColor.setValue(core.fragment.edgeColor);
            }
        }
    }
});
;SceneJS_ChunkFactory.createChunkType({

    type: "cubemap",

    build: function () {
        this._uCubeMapSampler = this._uCubeMapSampler || [];
        this._uCubeMapIntensity = this._uCubeMapIntensity || [];
        var layers = this.core.layers;
        if (layers) {
            var layer;
            var draw = this.program.draw;
            for (var i = 0, len = layers.length; i < len; i++) {
                layer = layers[i];
                this._uCubeMapSampler[i] = "SCENEJS_uCubeMapSampler" + i;
                this._uCubeMapIntensity[i] = draw.getUniform("SCENEJS_uCubeMapIntensity" + i);
            }
        }
    },

    draw: function (frameCtx) {
        var layers = this.core.layers;
        if (layers) {
            var layer;
            var draw = this.program.draw;
            for (var i = 0, len = layers.length; i < len; i++) {
                layer = layers[i];
                if (this._uCubeMapSampler[i] && layer.texture) {

                    draw.bindTexture(this._uCubeMapSampler[i], layer.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;

                    if (this._uCubeMapIntensity[i]) {
                        this._uCubeMapIntensity[i].setValue(layer.intensity);
                    }
                }
            }
        }
    }
});;SceneJS_ChunkFactory.createChunkType({

    type: "xform",

    build: function () {

        var draw = this.program.draw;

        this._uMatLocationDraw = draw.getUniform("SCENEJS_uMMatrix");
        this._uNormalMatLocationDraw = draw.getUniform("SCENEJS_uMNMatrix");

        var pick = this.program.pick;

        this._uMatLocationPick = pick.getUniform("SCENEJS_uMMatrix");
    },

    draw: function (frameCtx) {

        /* Rebuild core's matrix from matrices at cores on path up to root
         */
        if (SceneJS_configsModule.configs.forceXFormCoreRebuild === true || this.core.dirty && this.core.build) {
            this.core.build();
        }

        var gl = this.program.gl;

        if (this._uMatLocationDraw) {
            this._uMatLocationDraw.setValue(this.core.mat);
        }

        if (this._uNormalMatLocationDraw) {
            this._uNormalMatLocationDraw.setValue(this.core.normalMat);
        }

        frameCtx.modelMat = this.core.mat;
    },

    pick: function (frameCtx) {

        /* Rebuild core's matrix from matrices at cores on path up to root
         */
        if (this.core.dirty) {
            this.core.build();
        }

        var gl = this.program.gl;

        if (this._uMatLocationPick) {
            this._uMatLocationPick.setValue(this.core.mat);
        }

        frameCtx.modelMat = this.core.mat;
    }
});
;// SceneJS configuration
SceneJS.configure({

    // Point SceneJS at where dynamically-loaded plugins live
    // This is relative to the index document
    pluginPath: location.origin + location.pathname.substring(0, location.pathname.lastIndexOf("/")) + "/lib/scenejs/plugins"
});;/**
 * Box geometry node type
 *
 * @author xeolabs / http://xeolabs.com
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/box",
 *      xSize: 10,
 *      ySize: 20,
 *      zSize: 1.5,
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/box", {

        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        var x, y, z;
        if (params.size) {
            x = params.size[0];
            y = params.size[1];
            z = params.size[2];
        } else {
            // Deprecated
            x = params.xSize || 1;
            y = params.ySize || 1;
            z = params.zSize || 1;
        }

        var coreId = "geometry/box_" + x + "_" + y + "_" + z + (params.wire ? "wire" : "_solid");

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type:"geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry
        return {
            type:"geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId:coreId,
            positions:new Float32Array([
                x, y, z, -x, y, z, -x, -y, z, x, -y, z, // v0-v1-v2-v3 front
                x, y, z, x, -y, z, x, -y, -z, x, y, -z, // v0-v3-v4-v5 right
                x, y, z, x, y, -z, -x, y, -z, -x, y, z, // v0-v5-v6-v1 top
                -x, y, z, -x, y, -z, -x, -y, -z, -x, -y, z, // v1-v6-v7-v2 left
                -x, -y, -z, x, -y, -z, x, -y, z, -x, -y, z, // v7-v4-v3-v2 bottom
                x, -y, -z, -x, -y, -z, -x, y, -z, x, y, -z // v4-v7-v6-v5 back
            ]),
            normals:new Float32Array([
                0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // v0-v1-v2-v3 front
                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v3-v4-v5 right
                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // v0-v5-v6-v1 top
                -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // v1-v6-v7-v2 left
                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // v7-v4-v3-v2 bottom
                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1     // v4-v7-v6-v5 back
            ]),
            uv:new Float32Array([
                x, y, 0, y, 0, 0, x, 0, // v0-v1-v2-v3 front
                0, y, 0, 0, x, 0, x, y, // v0-v3-v4-v5 right
                x, 0, x, y, 0, y, 0, 0, // v0-v5-v6-v1 top
                x, y, 0, y, 0, 0, x, 0, // v1-v6-v7-v2 left
                0, 0, x, 0, x, y, 0, y, // v7-v4-v3-v2 bottom
                0, 0, x, 0, x, y, 0, y    // v4-v7-v6-v5 back
            ]),
            indices:new Uint16Array([
                0, 1, 2, 0, 2, 3, // front
                4, 5, 6, 4, 6, 7, // right
                8, 9, 10, 8, 10, 11, // top
                12, 13, 14, 12, 14, 15, // left
                16, 17, 18, 16, 18, 19, // bottom
                20, 21, 22, 20, 22, 23   // back
            ])
        };
    }
})();;/**
 * Quad geometry node type
 *
 *  @author xeolabs / http://xeolabs.com
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/quad",
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/quad", {
        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        // TODO: support size properties like 'geometry/plane'

        var coreId = "geometry/quad" + (params.wire ? "wire" : "_solid");

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type: "geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry
        return {
            type: "geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId:coreId,
            positions:[ 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0 ],
            normals:[ -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 ],
            uv:[ 1, 1, 0, 1, 0, 0, 1, 0 ],
            indices:[ 0, 1, 2, 0, 2, 3 ]
        };
    }
})();;/**
 * Sphere geometry node type
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/sphere",
 *      latitudeBands: 30, // Default
 *      longitudeBands: 30, // Default
 *      radius: 1, // Default
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/sphere", {

        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        // Thanks awfully to: http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere

        var latitudeBands = params.latitudeBands || 30;
        var longitudeBands = params.longitudeBands || 30;
        var radius = params.radius || 1;

        var coreId = "geometry/sphere_" + (params.wire ? "wire" : "_solid") + radius + "_" + longitudeBands + "_" + latitudeBands;

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type: "geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry

        var positions = [];
        var normals = [];
        var uvs = [];
        for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1- (longNumber / longitudeBands);
                var v = latNumber / latitudeBands;

                normals.push(x);
                normals.push(y);
                normals.push(z);
                uvs.push(u);
                uvs.push(v);
                positions.push(radius * x);
                positions.push(radius * y);
                positions.push(radius * z);
            }
        }

        var indices = [];
        for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                indices.push(first + 1);
                indices.push(second + 1);
                indices.push(second);
                indices.push(first + 1);
                indices.push(second);
                indices.push(first);
            }
        }

        return {
            type: "geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId : coreId,
            positions : new Float32Array(positions),
            normals: new Float32Array(normals),
            uv : new Float32Array(uvs),
            indices : new Uint16Array(indices)
        };
    }
})();;/**
 * Plane geometry node type
 *
 * @author xeolabs / http://xeolabs.com
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/plane",
 *      width: 10,
 *      height: 20,
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/plane", {

        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        var width = params.width || 1.0;
        var height = params.height || 1.0;

        var widthSegments = params.widthSegments || 1;
        var heightSegments = params.heightSegments || 1;

        var coreId = "geometry/plane_" + (params.wire == true ? "wire_" : "") + height + "_" + widthSegments + "_" + heightSegments;

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type: "geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry

        var positions = [];
        var normals = [];
        var uvs = [];
        var indices = [];

        var ix, iz;
        var halfWidth = width / 2;
        var halfHeight = height / 2;

        var gridX = widthSegments;
        var gridZ = heightSegments;

        var gridX1 = gridX + 1;
        var gridZ1 = gridZ + 1;

        var segWidth = width / gridX;
        var segHeight = height / gridZ;

        var x;
        var y;

        for (iz = 0; iz < gridZ1; iz++) {
            for (ix = 0; ix < gridX1; ix++) {

                x = ix * segWidth - halfWidth;
                y = iz * segHeight - halfHeight;

                positions.push(x);
                positions.push(-y);
                positions.push(0);

                normals.push(0);
                normals.push(0);
                normals.push(1);

                uvs.push(ix / gridX);
                uvs.push(1 - iz / gridZ);
            }
        }

        var a;
        var b;
        var c;
        var d;

        for (iz = 0; iz < gridZ; iz++) {
            for (ix = 0; ix < gridX; ix++) {

                a = ix + gridX1 * iz;
                b = ix + gridX1 * ( iz + 1 );
                c = ( ix + 1 ) + gridX1 * ( iz + 1 );
                d = ( ix + 1 ) + gridX1 * iz;

                indices.push(a);
                indices.push(b);
                indices.push(c);

                indices.push(c);
                indices.push(d);
                indices.push(a);
            }
        }

        return {
            type: "geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId:coreId,
            positions:new Float32Array(positions),
            normals:new Float32Array(normals),
            uv:new Float32Array(uvs),
            indices:new Uint16Array(indices)
        };
    }
})();
;/**

 Customizable skybox node type, which allows you to customize its texture

 @author xeolabs / http://xeolabs.com

 <p>Usage example:</p>

 <pre>
 someNode.addNode({
       type: "skybox",
       texture: "foo/bar/mySkyboxTexture.jpg",
       size: 5000 // Box half-size on each axis - default is 5000
   });
 </pre>
 */
SceneJS.Types.addType("skybox", {

    // TODO: expose node props to tweak the geometry coords to map to variations in texture UV mappings?

    construct: function (params) {

        var self = this;

        var src = params.src;

        // Sky box dimensions on each axis
        var size = params.size || 5000.0;

        var srcIsArray = SceneJS._isArray(src);

        // Reflection
//        if (params.reflect && srcIsArray) {
//            this.addNode({
//                type: "reflect",
//                intensity: params.intensity,
//                src: params.src,
//                nodes: params.nodes
//            });
//        } else {
//            if (params.nodes) {
//                this.addNodes(params.nodes);
//            }
//        }

        // Vertex shader which anchors the skybox translation
        var shader = self.addNode({
            type: "shader",
            shaders: [
                {
                    stage: "vertex",
                    code: [
                        "mat4 myViewMatrix(mat4 m) {",
                        "   m[3][0] =m[3][1] = m[3][2] = 0.0;",
                        "return m;",
                        "}"
                    ],
                    // Bind our injected functions to SceneJS hook points
                    hooks: {
                        viewMatrix: "myViewMatrix"
                    }
                }
            ]
        });

        // Disable lighting and picking for the sky box
        var flags = shader.addNode({
            type: "flags",
            flags: {
                specular: false,
                diffuse: false,
                ambient: false,
                picking: false
            }});

        var material = flags.addNode({
            type: "material",
            color: { r: 0, g: 0, b: 0  },
            emit: 0.0
        });

        var scale = material.addNode({
            type: "scale",
            x: size, y: size, z: size
        });

        if (srcIsArray) {

            // Array of textures given, one for each face

            scale.addNodes([

                // Front
                {
                    type: "texture",
                    src: src[0],
                    blendMode: "add",
                    nodes: [
                        {
                            type: "geometry",
                            positions: [ 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ], // v0-v1-v2-v3 front
                            uv: [ 1, 0, 0, 0, 0, 1, 1, 1 ],
                            indices: [ 2, 1, 0, 3, 2, 0 ]
                        }
                    ]
                },

                // Right
                {
                    type: "texture",
                    src: src[1],
                    blendMode: "add",
                    nodes: [
                        {
                            type: "geometry",
                            positions: [ 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1 ], // v0-v3-v4-v5 right
                            uv: [ 1, 0, 0, 0, 0, 1, 1, 1 ],
                            indices: [ 2, 1, 0, 3, 2, 0 ]
                        }
                    ]
                },

                // Top
                {
                    type: "texture",
                    src: src[2],
                    blendMode: "add",
                    nodes: [
                        {
                            type: "geometry",
                            positions: [ 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1 ], // v0-v5-v6-v1 top
                            uv: [ 1, 0, 0, 0, 0, 1, 1, 1 ],
                            indices: [ 2, 1, 0, 3, 2, 0 ]
                        }
                    ]
                },

                // Left
                {
                    type: "texture",
                    src: src[3],
                    blendMode: "add",
                    nodes: [
                        {
                            type: "geometry",
                            positions: [ -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1 ], // v1-v6-v7-v2 left
                            uv: [ 1, 0, 0, 0, 0, 1, 1, 1 ],
                            indices: [ 0, 1, 2, 0, 2, 3]
                        }
                    ]
                },

                // Bottom
                {
                    type: "texture",
                    src: src[4],
                    blendMode: "add",
                    nodes: [
                        {
                            type: "geometry",
                            positions: [ -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1  ], // v7-v4-v3-v2 bottom
                            uv: [ 1, 0, 0, 0, 0, 1, 1, 1 ],
                            indices: [ 2, 1, 0, 3, 2, 0 ]
                        }
                    ]
                },

                // Back
                {
                    type: "texture",
                    src: src[5],
                    blendMode: "add",
                    nodes: [
                        {
                            type: "geometry",
                            positions: [ 1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 ], // v4-v7-v6-v5 back
                            uv: [ 1, 0, 0, 0, 0, 1, 1, 1 ],
                            indices: [ 0, 1, 2, 0, 2, 3]
                        }
                    ]
                }
            ]);

        } else {

            // Single texture given

            material.addNode({
                type: "texture",
                src: src,
                blendMode: "add",

                nodes: [
                    {
                        type: "scale",
                        x: size, y: size, z: size,
                        nodes: [
                            // Sky box geometry
                            {
                                type: "geometry",
                                positions: [
                                    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, // v0-v1-v2-v3 front
                                    1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, // v0-v3-v4-v5 right
                                    1, 1, 1, 1, 1, -1, -1, 1, -1, -1, 1, 1, // v0-v5-v6-v1 top
                                    -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, // v1-v6-v7-v2 left
                                    -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, // v7-v4-v3-v2 bottom
                                    1, -1, -1, -1, -1, -1, -1, 1, -1, 1, 1, -1 // v4-v7-v6-v5 back
                                ],
                                uv: [
                                    0.5, 0.6666,
                                    0.25, 0.6666,
                                    0.25, 0.3333,
                                    0.5, 0.3333,

                                    0.5, 0.6666,
                                    0.5, 0.3333,
                                    0.75, 0.3333,
                                    0.75, 0.6666,

                                    0.5, 0.6666,
                                    0.5, 1,
                                    0.25, 1,
                                    0.25, 0.6666,

                                    0.25, 0.6666,
                                    0.0, 0.6666,
                                    0.0, 0.3333,
                                    0.25, 0.3333,

                                    0.25, 0,
                                    0.50, 0,
                                    0.50, 0.3333,
                                    0.25, 0.3333,

                                    0.75, 0.3333,
                                    1.0, 0.3333,
                                    1.0, 0.6666,
                                    0.75, 0.6666
                                ],
                                indices: [
                                    0, 1, 2,
                                    0, 2, 3,
                                    4, 5, 6,
                                    4, 6, 7,
                                    8, 9, 10,
                                    8, 10, 11,
                                    12, 13, 14,
                                    12, 14, 15,

                                    16, 17, 18,
                                    16, 18, 19,

                                    20, 21, 22,
                                    20, 22, 23
                                ]
                            }
                        ]
                    }
                ]
            });
        }
    }
});
;/**
 * @namespace The core engine namespace.
 */
(function () {
    "use strict";

    var Human = window.Human = {};

    var VERSION = "8.1.1";
    VERSION = VERSION.indexOf("ENGINE_VERSION") > 0 ? "qa" : VERSION;

    var API_VERSION = "2.0.1";
    API_VERSION = API_VERSION.indexOf("API_VERSION") > 0 ? "qa" : API_VERSION;


    /**
     * Engine version.
     *
     * @memberof Human
     * @name VERSION
     * @property
     * @type {string}
     */
    Human.VERSION = VERSION;
    Human.API_VERSION = API_VERSION;

    /** True when this engine instance is running on the Web
     *
     * @type {boolean}
     * @memberof Human
     */
    Human.deployed = !( window.location.hostname.match(/(localhost|192\.168\.11\.\d{1,3})/) ||
        window.location.protocol === "file:" );

    /* IDs of nodes in the document and scene graph
     */
    Human.CANVAS_ID = "theCanvas";
    Human.CONTAINER_ID = "container";
    Human.SCENE_ROOT_ID = "bds-human";
    Human.CONTENT_ROOT_ID = "outline";
    Human.MATERIAL_ROOT_ID = "human.outline";
    Human.NULL_OBJECT_ID = "null-object";   // ID of invisible object at origin, used for anchoring things like labels to
    Human.NULL_OBJECT_ID2 = "null-object-2";   // ID of invisible object at origin, used for anchoring things like labels to
    Human.CLIP_INDICATORS_ATTACH_ID = "clip-indicators";
    Human.CLIP_ATTACH_ID = "clips";
    Human.LOOKAT_ID = "theLookat";
    Human.CAMERA_ID = "theCamera";
    Human.VIEW_SPACE_ID = "viewSpace";


    /*-----------------------------------------------------------------------------------------------------------------
     * Error management
     *---------------------------------------------------------------------------------------------------------------*/

    SceneJS.bind("error",
        function (e) {
            Human._error("WEBGL", e.errorName, e.exception, true);
        });

    /**
     * Signals non-fatal error.
     * @memberof Human
     */
    Human.error = function (name, msg) {
        if (msg === undefined) {
            msg = name;
            name = "ERROR";
        }
        return Human._error("HUMAN", name, msg, false);
    };

    /**
     * Signals fatal error.
     * @memberof Human
     */
    Human.fatalError = function (name, msg) {
        if (msg === undefined) {
            msg = name;
            name = "ERROR";
        }
        return Human._error("HUMAN", name, msg, true);
    };

    Human._error = function (type, name, msg, fatal) {

        Human.events.fire("error", {
            type: type,
            name: name,
            message: msg,
            fatal: fatal,
            log: Human.log.messages.join("\n"),
            stack: Human.utils.getStackTrace(),
            webglInfo: SceneJS.WEBGL_INFO
        });

        return msg;
    };

    var annotationCanvas = document.getElementById("annotationCanvas");

    // Chrome seems to switch to WebGL canvas if not initialized?
    // On Windows/Linux
    if (annotationCanvas) {
        annotationCanvas.getContext("2d");
    }

})();

;/**
 * @class Base class for the various engine modules.
 *
 * @constructor
 */

(function() {
    "use strict";

    Human.Component = function () {

    };


    Human.Component.prototype = {

        _init:function (ctx) {

            this._ctx = ctx;

            this._handleMap = new Human.utils.Map(); // Subscription handle pool
            this._topicSubs = {}; // A [handle -> callback] map for each topic name
            this._handleTopics = {}; // Maps handles to topic names
            this._topicPubs = {}; // Maps topics to publications
        },

        /**
         * Publishes to a topic.
         *
         * Immediately notifies existing subscriptions to that topic, retains the publication to give to
         * any subsequent notifications on that topic as they are made.
         *
         * This is called internally by proxies. Only they create publications, which are subscribed
         * to by client code.
         *
         * @param topic Publication topic
         * @param pub The publication
         * @param once True to publish once ie. not retain
         * @private
         */
        publish:function (topic, pub, once) {
            if (!once) {
                this._topicPubs[topic] = pub; // Save notification
            }
            var subsForTopic = this._topicSubs[topic];
            if (subsForTopic) { // Notify subscriptions
                for (var handle in subsForTopic) {
                    if (subsForTopic.hasOwnProperty(handle)) {
                        subsForTopic[handle].call(this, pub);
                    }
                }
            }
        },

        /**
         * Listen for data changes at a particular location on this component.
         *
         * <p>This is the primary way to read data from the Human API. Your callback will be triggered for
         * the initial data and again whenever the data changes. Use {@link #unsubscribe} to stop receiving updates.</p>
         *
         * <p>The callback is be called with this component as scope.</p>
         *
         * @param {String} topic Publication location
         * @param {Function(data)} callback Called when fresh data is available at the location
         * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
         */
        on:function (topic, callback) {
            var subsForTopic = this._topicSubs[topic];
            if (!subsForTopic) {
                subsForTopic = {};
                this._topicSubs[topic] = subsForTopic;
            }
            var handle = this._handleMap.addItem(); // Create unique handle
            subsForTopic[handle] = callback;
            this._handleTopics[handle] = topic;
            var pub = this._topicPubs[topic];
            if (pub) { // A publication exists, notify callback immediately
                callback.call(this, pub);
            }
            return handle;
        },

        /**
         * Unsubscribes from a publication on this proxy that was previously made with {@link #on}.
         * @param handle Publication handle
         */
        off:function (handle) {
            var topic = this._handleTopics[handle];
            if (topic) {
                delete this._handleTopics[handle];
                var topicSubs = this._topicSubs[topic];
                if (topicSubs) {
                    delete topicSubs[handle];
                }
                this._handleMap.removeItem(handle); // Release handle
            }
        },

        /**
         * Listens for exactly one data update at the specified location, and then stops listening.
         * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
         * @param {String} topic Data location to listen to
         * @param {Function(data)} callback Called when fresh data is available at the location
         */
        once:function (topic, callback) {
            var self = this;
            var sub = this.on(topic,
                function (pub) {
                    self.off(sub);
                    callback(pub);
                });
        }
    };

})();

;/** @namespace
 * @private
 */

(function() {
    "use strict";

    Human.utils = Human.utils || {};

    /**
     * Tests if the given object is an array (including typed arrays)
     */
    Human.utils.isArray = function (testObject) {
        return testObject && !(testObject.propertyIsEnumerable('length')) &&
                typeof testObject === 'object' && typeof testObject.length === 'number';
    };

    /**
     * Tests if the given object is a simple object
     */
    Human.utils.isObject = function (testObject) {
        return !!testObject && Object.prototype.toString.call(testObject) === "[object Object]";
    };

    /**
     * Tests if the argument is of a primitive type
     */
    Human.utils.isPrimitive = function (value) {
        return  value === null || !!(typeof value).match(/^(string|number|boolean|undefined)$/);
    };

    /* Tests if the given value is a string.
     */
    Human.utils.isString = function (value) {
        return (typeof value === "string" || value instanceof String);
    };

    /* Filters elements from an array in place.
     */
    Human.utils.filterInPlace = function filter(array, fn) {
        var skip = 0;

        for (var i = 0, len = array.length; i < len; i++) {
            if (!fn(array[i])) {
                skip++;
                continue;
            }
            array[i - skip] = array[i];
        }

        array.length = array.length - skip;

        return array;
    };

    /**
     * Return a string representing the current call stack
     */
    Human.utils.getStackTrace = function() {
        var error = new Error();
        var stack;
        if (error.stack) {
            stack = error.stack;
        } else {
            try {
                throw error;
            } catch (e) {
                stack = e.stack;
            }
        }

        return stack || null;
    };

    /**
     * @private
     * @param childObj
     * @param parentObj
     */
    Human.utils.extend = function (childObj, parentObj) {
        var TmpObj = function () {
        };
        TmpObj.prototype = parentObj.prototype;
        childObj.prototype = new TmpObj();
        childObj.prototype.constructor = childObj;
    };

    /** Add properties of o to o2, overwriting them on o2 if already there
     */
    Human.utils.apply = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /**
     * Add properties of o to o2 where undefined or null on o2
     * @private
     */
    Human.utils.applyIf = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                if (o2[name] === undefined || o2[name] === null) {
                    o2[name] = o[name];
                }
            }
        }
        return o2;
    };

    Human.utils.applyIf2 = function (p, q) {
        p = p || {};
        var r = {};
        for (var key in q) {
            if (q.hasOwnProperty(key)) {
                r[key] = p[key] !== undefined ? p[key] : q[key];
            }
        }
        return r;
    };

    /** Returns shallow copy of object
     * @private
     */
    Human.utils.shallowClone = function (o) {
        var o2 = {};
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /**
     * Returns true if given map has no items
     * @private
     */
    Human.utils.isEmpty = function (map) {
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    };

    /**
     * Gets directory from given path
     * @private
     */
    Human.utils.getDir = function (path) {
        var i = path.lastIndexOf("/");
        return (i > -1) ? path.substring(0, i > 0 ? i + 1 : 0) : "";
    };

    /**
     * Run function asynchronously (i.e. wait for next exec context)
     * @private
     */
    Human.utils.async = function(fn) {
        setTimeout(fn, 0);
    };

    /**
     * Null function
     * @private
     */
    Human.utils.noop = function () {
    };

    /**
     * Gets keys on given map in array
     * @private
     */
    Human.utils.getKeys = function (map) {
        var keys = [];
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys;
    };

    /**
     * Returns new universally unique ID
     * @private
     */
    Human.utils.createUUID = function () {
        var data = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
        var data2 = ["8", "9", "A", "B"];
        var uuid = [];
        for (var i = 0; i < 38; i++) {
            switch (i) {
                case 8:
                    uuid.push("-");
                    break;
                case 13:
                    uuid.push("-");
                    break;
                case 18:
                    uuid.push("-");
                    break;
                case 14:
                    uuid.push("4");
                    break;
                case 19:
                    uuid.push(data2[Math.round(Math.random() * 3)]);
                    break;
                default:
                    uuid.push(data[Math.round(Math.random() * 15)]);
                    break;
            }
        }
        return uuid.join("");
    };

    /**
     * Look up interval in sorted array where value x resides.
     * Returns both left-index,left-value, right-index, right-value.
     * Out of Bounds cases:
     *   - if target < first item in sequence return [null,null,0,sequence[0]]
     *   - if target > last item in sequence return [end,sequence[end], null, null]
     *
     * @param lessThan(value, element) : function that returns true if value < element
     *    - value is of whatever type you pass to target.
     *    - element is the type of an element in the sequence.
     *
    */

    function defaultCompare(arrayElement, target){
        if (arrayElement < target){
            return -1;
        } else if (arrayElement > target){
            return 1;
        } else {
            return 0;
        }
    }

    Human.utils.binarySearch = function (array, target, compare, result){
        compare = compare || defaultCompare;
        result = result || {
            index1: null,
            index2: null,
            value1: null,
            value2: null
        };

        var lowIndex = 0;
        var highIndex = array.length - 1;
        var mid, value1, value2;

        // Boundary Cases
        if (compare(array[0], target) > 0) {
            result.index1 = null;
            result.value1 = null;
            result.index2 = 0;
            result.value2 = array[0];
            return result;
        } else if (compare(array[highIndex], target) < 0){
            result.index1 = highIndex;
            result.value1 = array[highIndex];
            result.index2 = null;
            result.value2 = null;
            return result;
        }

        // Do Bisection Search
        while (lowIndex <= highIndex){
            mid = Math.floor((lowIndex + highIndex) / 2);
            value1 = array[mid];
            value2 = array[mid + 1];

            if (compare(value1, target) <= 0 && compare(value2, target) >= 0){
                result.index1 = mid;
                result.index2 = mid + 1;
                result.value1 = value1;
                result.value2 = value2;
                return result;
            } else if (compare(value1, target) > 0) {
                highIndex = mid - 1;
            } else {
                lowIndex = mid + 1;
            }
        }
    };

    /**
     * Converts binary buffer to string
     * @private
     */
    Human.utils.atos = function(buffer, index, length) {
        index = index || 0;
        length = length || buffer.byteLength;
        var view = new Uint8Array(buffer, index, length);
        var str = new TextDecoder("utf-8").decode(view);
        return str;
    };

    /**
     * Converts binary buffer to JSON
     * @private
     */
    Human.utils.atoj = function(buffer, index, length) {
        return JSON.parse(Human.utils.atos(buffer, index, length));
    };

    /**
     * Benchmark a function.
     * @private
     */
    Human.utils.benchmark = function(fn, iterations) {
        iterations = iterations || 10000000;

        var t = performance.now();

        for (var i = 0; i < iterations; i++) {
            fn();
        }

        t = performance.now() - t;

        console.log("Total time: " + t.toFixed(3) + "ms");
        console.log("Time / operation: " + (t / iterations).toExponential(3) + "ms");
    };

})();
;
/**
 * @namespace Math functions
 * @private
 */

(function() {
    "use strict";

    var HumanMath = Human.math = {};
    var tempVec = new Float64Array(4);
    var tempMat4 = new Float64Array(16);

    /**
     *
     */
    HumanMath.clamp = function(u, min, max) {
       return (u < min) ? min : ((u > max) ? max : u);
    };

    HumanMath.vec2 = function() {
        return new Float64Array(2);
    };

    HumanMath.vec3 = function() {
        return new Float64Array(3);
    };

    HumanMath.vec4 = function() {
        return new Float64Array(4);
    };

    /**
     *
     */
    HumanMath.mat3 = function() {
        return new Float64Array(9);
    };

    /**
     *
     */
    HumanMath.mat4 = function() {
        return new Float64Array(16);
    };

    HumanMath.setVec = function(s, dest) {
        var r = dest || HumanMath.vec4();
        var i, len;

        for (i = 0, len = r.length; i < len; i++) {
            r[i] = s;
        }

        return r;
    };

    HumanMath.zeroVec = function(dest) {
        return HumanMath.setVec(0, dest);
    }; 

    /**
     *
     */
    HumanMath.divVec3 = function(u, v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = u[0] / v[0];
        result[1] = u[1] / v[1];
        result[2] = u[2] / v[2];

        return result;
    };

    /**
     *
     */
    HumanMath.negateVector4 = function(v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = -v[0];
        result[1] = -v[1];
        result[2] = -v[2];
        result[3] = -v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.addVec4 = function(u, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = u[0] + v[0];
        result[1] = u[1] + v[1];
        result[2] = u[2] + v[2];
        result[3] = u[3] + v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.addVec4s = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] + s;
        result[1] = v[1] + s;
        result[2] = v[2] + s;
        result[3] = v[3] + s;

        return result;
    };


    /**
     *
     */
    HumanMath.addScalarVec4 = function(s, v, dest) {
        return HumanMath.addVec4s(v, s, dest);
    };

    /**
     *
     */
    HumanMath.addVec3 = function(u, v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = u[0] + v[0];
        result[1] = u[1] + v[1];
        result[2] = u[2] + v[2];

        return result;
    };


    /**
     *
     */
    HumanMath.addVec3s = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] + s;
        result[1] = v[1] + s;
        result[2] = v[2] + s;

        return result;
    };

    /**
     *
     */
    HumanMath.subVec4 = function(u, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = u[0] - v[0];
        result[1] = u[1] - v[1];
        result[2] = u[2] - v[2];
        result[3] = u[3] - v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.subVec3 = function(u, v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = u[0] - v[0];
        result[1] = u[1] - v[1];
        result[2] = u[2] - v[2];

        return result;
    };

    /**
     *
     */
    HumanMath.lerpVec3 = function(t, t1, t2, p1, p2, dest) {
        dest = dest || HumanMath.vec3();
        var f = (t - t1) / (t2 - t1);

        dest[0] = p1[0] + (f * (p2[0] - p1[0]));
        dest[1] = p1[1] + (f * (p2[1] - p1[1]));
        dest[2] = p1[2] + (f * (p2[2] - p1[2]));
        
        return dest;
    };

    /**
     *
     */
    HumanMath.lerpVec2 = function(t, t1, t2, p1, p2, dest) {
        var result = dest || HumanMath.vec2();
        var f = (t - t1) / (t2 - t1);

        result[0] = p1[0] + (f * (p2[0] - p1[0]));
        result[1] = p1[1] + (f * (p2[1] - p1[1]));
        
        return result;
    };
    
    
    /**
     * @return short rotation from r1 to r2
     */
    HumanMath.getShortRotation = function (r1, r2) {
        var flip = r2 > r1 ? 1 : -1;
        var gap = (r2 - r1) * flip;
        gap = (gap + Math.PI) % (Math.PI * 2) - Math.PI;
        return gap * flip;
    };
    
    /**
     * f: [0, 1]
     * r1, r2 : [-PI, PI]
     */
    HumanMath.lerpRadian = function (f, r1, r2) {
        var gap = HumanMath.getShortRotation(r1, r2);
        var result = r1 + f * gap;
        return result;
    };
    
    /**
     *
     */
    HumanMath.lerpVec3Cylindrical = function(t, t1, t2, p1, p2, dest) {
        dest = dest || HumanMath.vec3();
        var f = (t - t1) / (t2 - t1);

        dest[0] = p1[0] + (f * (p2[0] - p1[0]));
        dest[1] = HumanMath.lerpRadian(f, p1[1], p2[1]);
        dest[2] = p1[2] + (f * (p2[2] - p1[2]));
        
        return dest;
    };

    /**
     *
     */
    HumanMath.negateVector3 = function(v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = -v[0];
        result[1] = -v[1];
        result[2] = -v[2];

        return result;
    };

    /**
     *
     */
    HumanMath.subVec2 = function(u, v, dest) {
        var result = dest || HumanMath.vec2();
        result[0] = u[0] - v[0];
        result[1] = u[1] - v[1];

        return result;
    };


    /**
     *
     */
    HumanMath.subVec4Scalar = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] - s;
        result[1] = v[1] - s;
        result[2] = v[2] - s;
        result[3] = v[3] - s;

        return result;
    };


    /**
     *
     */
    HumanMath.subScalarVec4 = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = s - v[0];
        result[1] = s - v[1];
        result[2] = s - v[2];
        result[3] = s - v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.mulVec4 = function(u, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = u[0] * v[0];
        result[1] = u[1] * v[1];
        result[2] = u[2] * v[2];
        result[3] = u[3] * v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.mulVec4Scalar = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] * s;
        result[1] = v[1] * s;
        result[2] = v[2] * s;
        result[3] = v[3] * s;

        return result;
    };


    /**
     *
     */
    HumanMath.mulVec3Scalar = function(v, s, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = v[0] * s;
        result[1] = v[1] * s;
        result[2] = v[2] * s;

        return result;
    };


    /**
     *
     */
    HumanMath.mulVec2Scalar = function(v, s, dest) {
        var result = dest || HumanMath.vec2();
        result[0] = v[0] * s;
        result[1] = v[1] * s;

        return result;
    };

    /**
     *
     */
    HumanMath.divVec4 = function(u, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = u[0] / v[0];
        result[1] = u[1] / v[1];
        result[2] = u[2] / v[2];
        result[3] = u[3] / v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.divScalarVec3 = function(s, v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = s / v[0];
        result[1] = s / v[1];
        result[2] = s / v[2];

        return result;
    };


    /**
     *
     */
    HumanMath.divVec3s = function(v, s, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = v[0] / s;
        result[1] = v[1] / s;
        result[2] = v[2] / s;

        return result;
    };


    /**
     *
     */
    HumanMath.divVec4s = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] / s;
        result[1] = v[1] / s;
        result[2] = v[2] / s;
        result[3] = v[3] / s;

        return result;
    };


    /**
     *
     */
    HumanMath.divScalarVec4 = function(s, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = s / v[0];
        result[1] = s / v[1];
        result[2] = s / v[2];
        result[3] = s / v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.dotVector4 = function(u, v) {
        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);
    };


    /**
     *
     */
    HumanMath.cross3Vec4 = function(u, v, dest) {
        var r = dest || HumanMath.vec4();

        tempVec[0] = u[1] * v[2] - u[2] * v[1];
        tempVec[1] = u[2] * v[0] - u[0] * v[2];
        tempVec[2] = u[0] * v[1] - u[1] * v[0];
        tempVec[3] = 0.0;

        r[0] = tempVec[0]; 
        r[1] = tempVec[1]; 
        r[2] = tempVec[2]; 
        r[3] = tempVec[3]; 

        return r;
    };


    HumanMath.cross3Vec3 = function(u, v, dest) {
        var r = dest || HumanMath.vec3();

        tempVec[0] = u[1] * v[2] - u[2] * v[1];
        tempVec[1] = u[2] * v[0] - u[0] * v[2];
        tempVec[2] = u[0] * v[1] - u[1] * v[0];

        r[0] = tempVec[0]; 
        r[1] = tempVec[1]; 
        r[2] = tempVec[2];

        return r;
    };


    /**
     *
     */
    HumanMath.sqLenVec4 = function(v) {
        return HumanMath.dotVector4(v, v);
    };


    /**
     *
     */
    HumanMath.lenVec4 = function(v) {
        return Math.sqrt(HumanMath.sqLenVec4(v));
    };


    /**
     *
     */
    HumanMath.dotVector3 = function(u, v) {
        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);
    };


    /**
     *
     */
    HumanMath.dotVector2 = function(u, v) {
        return (u[0] * v[0] + u[1] * v[1]);
    };


    /**
     *
     */
    HumanMath.sqLenVec3 = function(v) {
        return HumanMath.dotVector3(v, v);
    };


    /**
     *
     */
    HumanMath.sqLenVec2 = function(v) {
        return HumanMath.dotVector2(v, v);
    };


    /**
     *
     */
    HumanMath.lenVec3 = function(v) {
        return Math.sqrt(HumanMath.sqLenVec3(v));
    };


    /**
     *
     */
    HumanMath.lenVec2 = function(v) {
        return Math.sqrt(HumanMath.sqLenVec2(v));
    };


    /**
     *
     */
    HumanMath.rcpVec3 = function(v, dest) {
        return HumanMath.divScalarVec3(1.0, v, dest);
    };

    /**
     *
     */
    HumanMath.vec3ObjToArray = function(v, dest) {
        var result = dest || HumanMath.vec3();

        result[0] = v.x || 0;
        result[1] = v.y || 0;
        result[2] = v.z || 0;

        return result;
    };

    /**
     *
     */
    HumanMath.vec3ArrayToObj = function(v) {
        return { x: v[0], y: v[1], z: v[2] };
    };


    /**
     *
     */
    HumanMath.normalizeVec4 = function(v, dest) {
        var f = 1.0 / HumanMath.lenVec4(v);
        return HumanMath.mulVec4Scalar(v, f, dest);
    };


    /**
     *
     */
    HumanMath.normalizeVec3 = function(v, dest) {
        var f = 1.0 / HumanMath.lenVec3(v);
        return HumanMath.mulVec3Scalar(v, f, dest);
    };

    HumanMath.normalizeVec2 = function(v, dest) {
        var f = 1.0 / HumanMath.lenVec2(v);
        return HumanMath.mulVec2Scalar(v, f, dest);
    };
    
    
    /** cartesian coordinate (x,y,z) to cylindrical coordinate (r, theta, h)
     * x - left, y - up, z - in (right hand)
     * r = x^2 + z^2
     * theta = atan2(x, z)
     * h = y
     */
    HumanMath.cartesianToCylindrical = function (v, dest) {
        var result = dest || HumanMath.vec3();

        result[0] = Math.sqrt( v[0] * v[0] + v[2] * v[2]);
        result[1] = Math.atan2( v[0], v[2] );
        result[2] = v[1];

        return result;
    };
    
    /** cylindrical coordinate (r, theta, h) to cartesian coordinate (x,y,z)
     * x - left, y - up, z - in (right hand)
     * x = r * sin(theta)
     * y = h
     * z = r * cos(theta)
     */
    HumanMath.cylindricalToCartesian = function (v, dest) {
        var result = dest || HumanMath.vec3();

        result[0] = v[0] * Math.sin(v[1]);
        result[1] = v[2];
        result[2] = v[0] * Math.cos(v[1]);

        return result;
    };
    
    

    /**
     *
     */
    HumanMath.dupMat4 = function(m, dest) {
        var result = dest || HumanMath.mat4();

        result.set(m);

        return result;
    };


    /**
     *
     */
    HumanMath.getCellMat4 = function(m, row, col) {
        return m[row + col * 4];
    };


    /**
     *
     */
    HumanMath.setCellMat4 = function(m, row, col, s) {
        m[row + col * 4] = s;
    };


    /**
     *
     */
    HumanMath.getRowMat4 = function(m, r, dest) {
        var result = dest || HumanMath.vec4();

        result[0] = m[r + 0]; 
        result[1] = m[r + 4]; 
        result[2] = m[r + 8]; 
        result[3] = m[r + 12];

        return result;
    };


    /**
     *
     */
    HumanMath.setRowMat4 = function(m, r, v) {
        m[r + 0] = v[0];
        m[r + 4] = v[1];
        m[r + 8] = v[2];
        m[r + 12] = v[3];
    };


    /**
     *
     */
    HumanMath.setRowMat4c = function(m, r, x, y, z, w) {
        HumanMath.setRowMat4(m, r, [x,y,z,w]);
    };


    /**
     *
     */
    HumanMath.setRowMat4s = function(m, r, s) {
        HumanMath.setRowMat4c(m, r, s, s, s, s);
    };


    /**
     *
     */
    HumanMath.getColMat4 = function(m, c, dest) {
        var result = dest || HumanMath.vec4();
        var i = c * 4;

        result[0] = m[i + 0]; 
        result[1] = m[i + 1];
        result[2] = m[i + 2];
        result[3] = m[i + 3];

        return result;
    };


    /**
     *
     */
    HumanMath.setColMat4v = function(m, c, v) {
        var i = c * 4;
        m[i + 0] = v[0];
        m[i + 1] = v[1];
        m[i + 2] = v[2];
        m[i + 3] = v[3];
    };


    /**
     *
     */
    HumanMath.setColMat4c = function(m, c, x, y, z, w) {
        HumanMath.setColMat4v(m, c, [x,y,z,w]);
    };


    /**
     *
     */
    HumanMath.setColMat4Scalar = function(m, c, s) {
        HumanMath.setColMat4c(m, c, s, s, s, s);
    };


    /**
     *
     */
    HumanMath.mat4To3 = function(m, dest) {
        var result = dest || HumanMath.mat3();

        result[0] = m[0];
        result[1] = m[1];
        result[2] = m[2];
        result[3] = m[4];
        result[4] = m[5];
        result[5] = m[6];
        result[6] = m[8];
        result[7] = m[9];
        result[8] = m[10];

        return result;
    };


    /**
     *
     */
    HumanMath.m4s = function(s, dest) {
        var result = dest || HumanMath.mat4();

        result[0] = s;
        result[1] = s;
        result[2] = s;
        result[3] = s;
        result[4] = s;
        result[5] = s;
        result[6] = s;
        result[7] = s;
        result[8] = s;
        result[9] = s;
        result[10] = s;
        result[11] = s;
        result[12] = s;
        result[13] = s;
        result[14] = s;
        result[15] = s;

        return result;
    };


    /**
     *
     */
    HumanMath.setMat4ToZeroes = function(dest) {
        return HumanMath.m4s(0.0, dest);
    };


    /**
     *
     */
    HumanMath.setMat4ToOnes = function(dest) {
        return HumanMath.m4s(1.0, dest);
    };

    /**
     *
     */
    HumanMath.diagonalMat4v = function(v, dest) {
        var result = dest || HumanMath.mat4();

        result[0] = v[0];
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = v[1];
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = v[2];
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = v[3];

        return result;
    };

    /**
     *
     */
    HumanMath.diagonalMat4c = function(x, y, z, w, dest) {
        return HumanMath.diagonalMat4v([x,y,z,w], dest);
    };

    /**
     *
     */
    HumanMath.diagonalMat4s = function(s, dest) {
        return HumanMath.diagonalMat4c(s, s, s, s, dest);
    };

    /**
     *
     */
    HumanMath.identityMat4 = function(dest) {
        return HumanMath.diagonalMat4s(1.0, dest);
    };

    /**
     *
     */
    HumanMath.isIdentityMat4 = function(m) {
        var i = 0;
        var j = 0;
        var s = 0.0;
        for (i = 0; i < 4; ++i) {
            for (j = 0; j < 4; ++j) {
                s = m[i + j * 4];
                if ((i === j)) {
                    if (s !== 1.0) {
                        return false;
                    }
                }
                else {
                    if (s !== 0.0) {
                        return false;
                    }
                }
            }
        }
        return true;
    };

    /**
     *
     */
    HumanMath.negateMat4 = function(m, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = -m[i];
        }
        return r;
    };

    /**
     *
     */
    HumanMath.addMat4 = function(a, b, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = a[i] + b[i];
        }
        return r;
    };

    /**
     *
     */
    HumanMath.addMat4Scalar = function(m, s, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = m[i] + s;
        }
        return r;
    };

    /**
     *
     */
    HumanMath.addScalarMat4 = function(s, m, dest) {
        return HumanMath.addMat4Scalar(m, s, dest);
    };

    /**
     *
     */
    HumanMath.subMat4 = function(a, b, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = a[i] - b[i];
        }
        return r;
    };

    /**
     *
     */
    HumanMath.subMat4Scalar = function(m, s, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = m[i] - s;
        }
        return r;
    };

    /**
     *
     */
    HumanMath.subScalarMat4 = function(s, m, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = s - m[i];
        }
        return r;
    };

    /**
     * @param a mat4
     * @param b mat4
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, a otherwise
     * @private
     */
    HumanMath.mulMat4 = function(a, b, dest) {
        if (!dest) {
            dest = a;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        var b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
        var b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
        var b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
        var b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];

        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

        return dest;
    };


    /**
     *
     */
    HumanMath.mulMat4s = function(m, s, dest)
    {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = m[i] * s;
        }
        return r;
    };

    /**
     *
     */
    HumanMath.mulMat4v4 = function(m, v, dest) {
        var r = dest || HumanMath.vec4();

        r[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];
        r[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];
        r[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];
        r[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];
        
        return r;
    };

    /**
     *
     */
    HumanMath.transposeMat4 = function(m, dest) {
        var r = dest || HumanMath.mat4();
        var i = 0;
        var j = 0;
        for (i = 0; i < 4; ++i) {
            for (j = 0; j < 4; ++j) {
                r[i + j * 4] = m[i * 4 + j];
            }
        }
        return r;
    };

    /**
     *
     */
    HumanMath.determinantMat4 = function(m) {
        var f = HumanMath.getCellMat4;
        return (
                f(m, 0, 3) * f(m, 1, 2) * f(m, 2, 1) * f(m, 3, 0) - f(m, 0, 2) * f(m, 1, 3) * f(m, 2, 1) * f(m, 3, 0) - f(m, 0, 3) * f(m, 1, 1) * f(m, 2, 2) * f(m, 3, 0) + f(m, 0, 1) * f(m, 1, 3) * f(m, 2, 2) * f(m, 3, 0) +
                f(m, 0, 2) * f(m, 1, 1) * f(m, 2, 3) * f(m, 3, 0) - f(m, 0, 1) * f(m, 1, 2) * f(m, 2, 3) * f(m, 3, 0) - f(m, 0, 3) * f(m, 1, 2) * f(m, 2, 0) * f(m, 3, 1) + f(m, 0, 2) * f(m, 1, 3) * f(m, 2, 0) * f(m, 3, 1) +
                f(m, 0, 3) * f(m, 1, 0) * f(m, 2, 2) * f(m, 3, 1) - f(m, 0, 0) * f(m, 1, 3) * f(m, 2, 2) * f(m, 3, 1) - f(m, 0, 2) * f(m, 1, 0) * f(m, 2, 3) * f(m, 3, 1) + f(m, 0, 0) * f(m, 1, 2) * f(m, 2, 3) * f(m, 3, 1) +
                f(m, 0, 3) * f(m, 1, 1) * f(m, 2, 0) * f(m, 3, 2) - f(m, 0, 1) * f(m, 1, 3) * f(m, 2, 0) * f(m, 3, 2) - f(m, 0, 3) * f(m, 1, 0) * f(m, 2, 1) * f(m, 3, 2) + f(m, 0, 0) * f(m, 1, 3) * f(m, 2, 1) * f(m, 3, 2) +
                f(m, 0, 1) * f(m, 1, 0) * f(m, 2, 3) * f(m, 3, 2) - f(m, 0, 0) * f(m, 1, 1) * f(m, 2, 3) * f(m, 3, 2) - f(m, 0, 2) * f(m, 1, 1) * f(m, 2, 0) * f(m, 3, 3) + f(m, 0, 1) * f(m, 1, 2) * f(m, 2, 0) * f(m, 3, 3) +
                f(m, 0, 2) * f(m, 1, 0) * f(m, 2, 1) * f(m, 3, 3) - f(m, 0, 0) * f(m, 1, 2) * f(m, 2, 1) * f(m, 3, 3) - f(m, 0, 1) * f(m, 1, 0) * f(m, 2, 2) * f(m, 3, 3) + f(m, 0, 0) * f(m, 1, 1) * f(m, 2, 2) * f(m, 3, 3)
                );
    };

    /**
     *
     */
    HumanMath.inverseMat4 = function(m, dest) {
        var m0 = m[ 0], m1 = m[ 1], m2 = m[ 2], m3 = m[ 3],
                m4 = m[ 4], m5 = m[ 5], m6 = m[ 6], m7 = m[ 7],
                m8 = m[ 8], m9 = m[ 9], m10 = m[10], m11 = m[11],
                m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15]  ;

        var n = dest || HumanMath.mat4();
        HumanMath.identityMat4(n);

        n[ 0] = (m9 * m14 * m7 - m13 * m10 * m7 + m13 * m6 * m11 - m5 * m14 * m11 - m9 * m6 * m15 + m5 * m10 * m15);
        n[ 1] = (m13 * m10 * m3 - m9 * m14 * m3 - m13 * m2 * m11 + m1 * m14 * m11 + m9 * m2 * m15 - m1 * m10 * m15);
        n[ 2] = (m5 * m14 * m3 - m13 * m6 * m3 + m13 * m2 * m7 - m1 * m14 * m7 - m5 * m2 * m15 + m1 * m6 * m15);
        n[ 3] = (m9 * m6 * m3 - m5 * m10 * m3 - m9 * m2 * m7 + m1 * m10 * m7 + m5 * m2 * m11 - m1 * m6 * m11);

        n[ 4] = (m12 * m10 * m7 - m8 * m14 * m7 - m12 * m6 * m11 + m4 * m14 * m11 + m8 * m6 * m15 - m4 * m10 * m15);
        n[ 5] = (m8 * m14 * m3 - m12 * m10 * m3 + m12 * m2 * m11 - m0 * m14 * m11 - m8 * m2 * m15 + m0 * m10 * m15);
        n[ 6] = (m12 * m6 * m3 - m4 * m14 * m3 - m12 * m2 * m7 + m0 * m14 * m7 + m4 * m2 * m15 - m0 * m6 * m15);
        n[ 7] = (m4 * m10 * m3 - m8 * m6 * m3 + m8 * m2 * m7 - m0 * m10 * m7 - m4 * m2 * m11 + m0 * m6 * m11);

        n[ 8] = (m8 * m13 * m7 - m12 * m9 * m7 + m12 * m5 * m11 - m4 * m13 * m11 - m8 * m5 * m15 + m4 * m9 * m15);
        n[ 9] = (m12 * m9 * m3 - m8 * m13 * m3 - m12 * m1 * m11 + m0 * m13 * m11 + m8 * m1 * m15 - m0 * m9 * m15);
        n[10] = (m4 * m13 * m3 - m12 * m5 * m3 + m12 * m1 * m7 - m0 * m13 * m7 - m4 * m1 * m15 + m0 * m5 * m15);
        n[11] = (m8 * m5 * m3 - m4 * m9 * m3 - m8 * m1 * m7 + m0 * m9 * m7 + m4 * m1 * m11 - m0 * m5 * m11);

        n[12] = (m12 * m9 * m6 - m8 * m13 * m6 - m12 * m5 * m10 + m4 * m13 * m10 + m8 * m5 * m14 - m4 * m9 * m14);
        n[13] = (m8 * m13 * m2 - m12 * m9 * m2 + m12 * m1 * m10 - m0 * m13 * m10 - m8 * m1 * m14 + m0 * m9 * m14);
        n[14] = (m12 * m5 * m2 - m4 * m13 * m2 - m12 * m1 * m6 + m0 * m13 * m6 + m4 * m1 * m14 - m0 * m5 * m14);
        n[15] = (m4 * m9 * m2 - m8 * m5 * m2 + m8 * m1 * m6 - m0 * m9 * m6 - m4 * m1 * m10 + m0 * m5 * m10);

        var s = 1.0 / (
                m12 * m9 * m6 * m3 - m8 * m13 * m6 * m3 - m12 * m5 * m10 * m3 + m4 * m13 * m10 * m3 +
                m8 * m5 * m14 * m3 - m4 * m9 * m14 * m3 - m12 * m9 * m2 * m7 + m8 * m13 * m2 * m7 +
                m12 * m1 * m10 * m7 - m0 * m13 * m10 * m7 - m8 * m1 * m14 * m7 + m0 * m9 * m14 * m7 +
                m12 * m5 * m2 * m11 - m4 * m13 * m2 * m11 - m12 * m1 * m6 * m11 + m0 * m13 * m6 * m11 +
                m4 * m1 * m14 * m11 - m0 * m5 * m14 * m11 - m8 * m5 * m2 * m15 + m4 * m9 * m2 * m15 +
                m8 * m1 * m6 * m15 - m0 * m9 * m6 * m15 - m4 * m1 * m10 * m15 + m0 * m5 * m10 * m15
                );
        for (var i = 0; i < 16; ++i) {
            n[i] *= s;
        }
        return n;
    };

    /**
     *
     */
    HumanMath.traceMat4 = function(m) {
        return (m[0] + m[5] + m[10] + m[15]);
    };

    /**
     *
     */
    HumanMath.translationMat4v = function(v, dest) {
        var m = dest || HumanMath.mat4();
        HumanMath.identityMat4(m);
        
        m[12] = v[0];
        m[13] = v[1];
        m[14] = v[2];

        return m;
    };

    /**
     *
     */
    HumanMath.translationMat4c = function(x, y, z, dest) {
        return HumanMath.translationMat4v([x,y,z], dest);
    };

    /**
     *
     */
    HumanMath.translationMat4s = function(s, dest) {
        return HumanMath.translationMat4c(s, s, s, dest);
    };

    /**
     *
     */
    HumanMath.rotationMat4v = function(anglerad, axis, dest) {
        var ax = HumanMath.normalizeVec4([axis[0],axis[1],axis[2],0.0]);
        var s = Math.sin(anglerad);
        var c = Math.cos(anglerad);
        var q = 1.0 - c;

        var x = ax[0];
        var y = ax[1];
        var z = ax[2];

        var xx,yy,zz,xy,yz,zx,xs,ys,zs;

        xx = x * x;
        yy = y * y;
        zz = z * z;
        xy = x * y;
        yz = y * z;
        zx = z * x;
        xs = x * s;
        ys = y * s;
        zs = z * s;

        var m = dest || HumanMath.mat4();

        m[0] = (q * xx) + c;
        m[1] = (q * xy) + zs;
        m[2] = (q * zx) - ys;
        m[3] = 0.0;

        m[4] = (q * xy) - zs;
        m[5] = (q * yy) + c;
        m[6] = (q * yz) + xs;
        m[7] = 0.0;

        m[8] = (q * zx) + ys;
        m[9] = (q * yz) - xs;
        m[10] = (q * zz) + c;
        m[11] = 0.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 0.0;
        m[15] = 1.0;

        return m;
    };

    /**
     * Uses NASA standard aeroplane conventions as described on page:
    *   http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm
    *   Coordinate System: right hand
    *   Positive angle: right hand
    *   Order of euler angles: heading first, then attitude, then bank
    *   matrix row column ordering:
    *   [m00 m01 m02]
    *   [m10 m11 m12]
    *   [m20 m21 m22]*/
    HumanMath.rotationEulerMat4v = function(x, y, z, dest) {

        var ch = Math.cos(-y);
        var sh = Math.sin(-y);
        var ca = Math.cos(-z);
        var sa = Math.sin(-z);
        var cb = Math.cos(-x);
        var sb = Math.sin(-x);

        var m = dest || HumanMath.mat4();

        m[0] = ch * ca;
        m[1] = sh * sb - ch * sa * cb;
        m[2] = ch * sa * sb + sh * cb;
        m[3] = 0;
        m[4] = sa;
        m[5] = ca * cb;
        m[6] = -ca * sb;
        m[7] = 0;
        m[8] = -sh * ca;
        m[9] = sh * sa * cb + ch * sb;
        m[10] = -sh * sa * sb + ch * cb;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;

        return m;
    };


    //    m[0] = ch * ca;
    //    m01 = sh * sb - ch * sa * cb;
    //    m02 = ch * sa * sb + sh * cb;
    //    m10 = sa;
    //    m11 = ca * cb;
    //    m12 = -ca * sb;
    //    m20 = -sh * ca;
    //    m21 = sh * sa * cb + ch * sb;
    //    m22 = -sh * sa * sb + ch * cb;
    /**
     *
     */
    HumanMath.rotationMat4c = function(anglerad, x, y, z, dest) {
        return HumanMath.rotationMat4v(anglerad, [x,y,z], dest);
    };

    /**
     *
     */
    HumanMath.scalingMat4v = function(v, dest) {
        var m = dest || HumanMath.mat4();
        HumanMath.identityMat4(m);

        m[0] = v[0];
        m[5] = v[1];
        m[10] = v[2];

        return m;
    };

    /**
     *
     */
    HumanMath.scalingMat4c = function(x, y, z, dest) {
        return HumanMath.scalingMat4v([x,y,z], dest);
    };

    /**
     *
     */
    HumanMath.scalingMat4s = function(s, dest) {
        return HumanMath.scalingMat4c(s, s, s, dest);
    };

    /**
     *
     */

    var pos4 = HumanMath.vec4();
    var v = HumanMath.vec4();
    var u = HumanMath.vec4();
    var s = Human.math.vec4();

    HumanMath.lookAtMat4v = function(pos, target, up, dest) {
        pos4[0] = pos[0];
        pos4[1] = pos[1];
        pos4[2] = pos[2];
        pos4[3] = 0.0;

        v[0] = target[0];
        v[1] = target[1];
        v[2] = target[2];
        v[3] = 0.0;

        u[0] = up[0];
        u[1] = up[1];
        u[2] = up[2];
        u[3] = 0.0;

        HumanMath.subVec4(v, pos4, tempVec);

        HumanMath.normalizeVec4(tempVec, v);
        HumanMath.normalizeVec4(u, u);

        HumanMath.cross3Vec4(v, u, tempVec);
        HumanMath.normalizeVec4(tempVec, s);

        HumanMath.cross3Vec4(s, v, tempVec);
        HumanMath.normalizeVec4(tempVec, u);

        var m = dest || HumanMath.mat4();

        m[0] = s[0];
        m[1] = u[0];
        m[2] = -v[0];
        m[3] = 0.0;

        m[4] = s[1];
        m[5] = u[1];
        m[6] = -v[1];
        m[7] = 0.0;

        m[8] = s[2];
        m[9] = u[2];
        m[10] = -v[2];
        m[11] = 0.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 0.0;
        m[15] = 1.0;

        HumanMath.negateVector4(pos4, pos4);
        HumanMath.translationMat4v(pos4, tempMat4);

        HumanMath.mulMat4(m, tempMat4, m);

        return m;
    };

    /**
     *
     */
    HumanMath.lookAtMat4c = function(posx, posy, posz, targetx, targety, targetz, upx, upy, upz, dest) {
        return HumanMath.lookAtMat4v([posx,posy,posz], [targetx,targety,targetz], [upx,upy,upz], dest);
    };

    /**
     *
     */
    HumanMath.orthoMat4v = function(omin, omax, dest) {
        var omin4 = [omin[0],omin[1],omin[2],0.0];
        var omax4 = [omax[0],omax[1],omax[2],0.0];
        var vsum = HumanMath.addVec4(omax4, omin4);
        var vdif = HumanMath.subVec4(omax4, omin4);

        var m = dest || HumanMath.mat4();

        m[0] = 2.0 / vdif[0];
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;

        m[4] = 0.0;
        m[5] = 2.0 / vdif[1];
        m[6] = 0.0;
        m[7] = 0.0;

        m[8] = 0.0;
        m[9] = 0.0;
        m[10] = -2.0 / vdif[2];
        m[11] = 0.0;

        m[12] = -vsum[0] / vdif[0];
        m[13] = -vsum[1] / vdif[1];
        m[14] = -vsum[2] / vdif[2];
        m[15] = 1.0;

        return m;
    };

    /**
     *
     */
    HumanMath.orthoMat4c = function(left, right, bottom, top, znear, zfar, dest) {
        return HumanMath.orthoMat4v([left,bottom,znear], [right,top,zfar], dest);
    };

    /**
     *
     */
    HumanMath.frustumMat4v = function(fmin, fmax, dest) {
        var fmin4 = [fmin[0],fmin[1],fmin[2],0.0];
        var fmax4 = [fmax[0],fmax[1],fmax[2],0.0];
        var vsum = HumanMath.addVec4(fmax4, fmin4);
        var vdif = HumanMath.subVec4(fmax4, fmin4);
        var t = 2.0 * fmin4[2];

        var m = dest || HumanMath.mat4();

        m[0] = t / vdif[0];
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;

        m[4] = 0.0;
        m[5] = t / vdif[1];
        m[6] = 0.0;
        m[7] = 0.0;

        m[8] = vsum[0] / vdif[0];
        m[9] = vsum[1] / vdif[1];
        m[10] = -vsum[2] / vdif[2];
        m[11] = -1.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = -t * fmax4[2] / vdif[2];
        m[15] = 0.0;

        return m;
    };

    /**
     *
     */
    HumanMath.frustumMatrix4 = function(left, right, bottom, top, znear, zfar, dest) {
        return HumanMath.frustumMat4v([left, bottom, znear], [right, top, zfar], dest);
    };

    /**
     *
     */
    HumanMath.perspectiveMatrix4 = function(fovyrad, aspectratio, znear, zfar, dest) {
        var pmin = HumanMath.vec4();
        var pmax = HumanMath.vec4();

        pmin[2] = znear;
        pmax[2] = zfar;

        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);
        pmin[1] = -pmax[1];

        pmax[0] = pmax[1] * aspectratio;
        pmin[0] = -pmax[0];

        return HumanMath.frustumMat4v(pmin, pmax, dest);
    };

    /**
     *
     */
    HumanMath.transformPoint3 = function(m, p, dest) {
        var r = dest || HumanMath.vec4();

        tempVec[0] = (m[0] * p[0]) + (m[4] * p[1]) + (m[8] * p[2]) + m[12];
        tempVec[1] = (m[1] * p[0]) + (m[5] * p[1]) + (m[9] * p[2]) + m[13];
        tempVec[2] = (m[2] * p[0]) + (m[6] * p[1]) + (m[10] * p[2]) + m[14];
        tempVec[3] = (m[3] * p[0]) + (m[7] * p[1]) + (m[11] * p[2]) + m[15];

        r[0] = tempVec[0];
        r[1] = tempVec[1];
        r[2] = tempVec[2];
        r[3] = tempVec[3];
        
        return r;
    };

    /**
     *
     */
    HumanMath.transformPoint4 = function(m, v, dest) {
        var r = dest || HumanMath.vec4();

        tempVec[0] = m[ 0] * v[0] + m[ 4] * v[1] + m[ 8] * v[2] + m[12] * v[3];
        tempVec[1] = m[ 1] * v[0] + m[ 5] * v[1] + m[ 9] * v[2] + m[13] * v[3];
        tempVec[2] = m[ 2] * v[0] + m[ 6] * v[1] + m[10] * v[2] + m[14] * v[3];
        tempVec[3] = m[ 3] * v[0] + m[ 7] * v[1] + m[11] * v[2] + m[15] * v[3];

        r[0] = tempVec[0];
        r[1] = tempVec[1];
        r[2] = tempVec[2];
        r[3] = tempVec[3];

        return r;
    };

    /**
     *
     */
    HumanMath.transformPoints3 = function(m, points) {
        var len = points.length;
        var result = new Array(len);
        for (var i = 0; i < len; i++) {
            result[i] = HumanMath.transformPoint3(m, points[i]);
        }
        return result;
    };


    /**
     *
     */
    HumanMath.transformVector3 = function(m, v, dest) {
        var r = dest || HumanMath.vec3();

        tempVec[0] = (m[0] * v[0]) + (m[4] * v[1]) + (m[8] * v[2]);
        tempVec[1] = (m[1] * v[0]) + (m[5] * v[1]) + (m[9] * v[2]);
        tempVec[2] = (m[2] * v[0]) + (m[6] * v[1]) + (m[10] * v[2]);

        r[0] = tempVec[0];
        r[1] = tempVec[1];
        r[2] = tempVec[2];
       
        return r;
    };


    /**
     *
     */
    HumanMath.projectVec4 = function(v, dest) {
        var r = dest || HumanMath.vec4();
        var f = 1.0 / v[3];

        r[0] = v[0] * f; 
        r[1] = v[1] * f; 
        r[2] = v[2] * f; 
        r[3] = 1.0;
        
        return r;
    };


    /**
     *
     */
    HumanMath.Plane3 = function (normal, offset, normalize) {
        this.normal = new Float64Array([0.0, 0.0, 1.0]);
        this.offset = 0.0;
        if (normal && offset) {
            this.normal[0] = normal[0];
            this.normal[1] = normal[1];
            this.normal[2] = normal[2];
            this.offset = offset;

            if (normalize) {
                var s = Math.sqrt(
                        this.normal[0] * this.normal[0] +
                        this.normal[1] * this.normal[1] +
                        this.normal[2] * this.normal[2]
                        );
                if (s > 0.0) {
                    s = 1.0 / s;
                    this.normal[0] *= s;
                    this.normal[1] *= s;
                    this.normal[2] *= s;
                    this.offset *= s;
                }
            }
        }
    };


    HumanMath.MAX_DOUBLE = Number.POSITIVE_INFINITY;
    HumanMath.MIN_DOUBLE = Number.NEGATIVE_INFINITY;

    HumanMath.MAX_NUMBER = Number.POSITIVE_INFINITY;
    HumanMath.MIN_NUMBER = Number.NEGATIVE_INFINITY;


    /**
     *
     */
    HumanMath.Box3 = function(min, max) {
        this.min = min || [ HumanMath.MAX_DOUBLE,HumanMath.MAX_DOUBLE,HumanMath.MAX_DOUBLE ];
        this.max = max || [ HumanMath.MIN_DOUBLE,HumanMath.MIN_DOUBLE,HumanMath.MIN_DOUBLE ];


        this.init = function(min, max) {
            for (var i = 0; i < 3; ++i) {
                this.min[i] = min[i];
                this.max[i] = max[i];
            }
            return this;
        };


        this.fromPoints = function(points) {
            var points2 = [];
            for (var i = 0; i < points.length; i++) {
                points2.push([points[i][0] / points[i][3], points[i][1] / points[i][3], points[i][2] / points[i][3]]);
            }
            points = points2;
            for (i = 0; i < points.length; i++) {
                var v = points[i];
                for (var j = 0; j < 3; j++) {
                    if (v[j] < this.min[j]) {
                        this.min[j] = v[j];
                    }
                    if (v[j] > this.max[j]) {
                        this.max[j] = v[j];
                    }
                }
            }
            return this;
        };


        this.isEmpty = function() {
            return (
                    (this.min[0] >= this.max[0]) && 
                        (this.min[1] >= this.max[1]) && 
                        (this.min[2] >= this.max[2])
                    );
        };


        this.getCenter = function() {
            return new Float64Array([
                (this.max[0] + this.min[0]) / 2.0,
                (this.max[1] + this.min[1]) / 2.0,
                (this.max[2] + this.min[2]) / 2.0
            ]);
        };


        this.getSize = function() {
            return new Float64Array([
                (this.max[0] - this.min[0]),
                (this.max[1] - this.min[1]),
                (this.max[2] - this.min[2])
            ]);
        };


        this.getFacesAreas = function() {
            var s = this.size;
            return new Float64Array([
                (s[1] * s[2]),
                (s[0] * s[2]),
                (s[0] * s[1])
            ]);
        };


        this.getSurfaceArea = function() {
            var a = this.getFacesAreas();
            return ((a[0] + a[1] + a[2]) * 2.0);
        };


        this.getVolume = function() {
            var s = this.size;
            return (s[0] * s[1] * s[2]);
        };


        this.getOffset = function(halfDelta) {
            for (var i = 0; i < 3; ++i) {
                this.min[i] -= halfDelta;
                this.max[i] += halfDelta;
            }
            return this;
        };
    };

    /** @private
     *
     * @param min
     * @param max
     */
    HumanMath.AxisBox3 = function(min, max) {
        this.verts = [
            [min[0], min[1], min[2]],
            [max[0], min[1], min[2]],
            [max[0], max[1], min[2]],
            [min[0], max[1], min[2]],

            [min[0], min[1], max[2]],
            [max[0], min[1], max[2]],
            [max[0], max[1], max[2]],
            [min[0], max[1], max[2]]
        ];


        this.toBox3 = function() {
            var box = new HumanMath.Box3();
            for (var i = 0; i < 8; i++) {
                var v = this.verts[i];
                for (var j = 0; j < 3; j++) {
                    if (v[j] < box.min[j]) {
                        box.min[j] = v[j];
                    }
                    if (v[j] > box.max[j]) {
                        box.max[j] = v[j];
                    }
                }
            }
        };

        this.toBoundary = function() {
            var box = new HumanMath.Box3();
            for (var i = 0; i < 8; i++) {
                var v = this.verts[i];
                for (var j = 0; j < 3; j++) {
                    if (v[j] < box.min[j]) {
                        box.min[j] = v[j];
                    }
                    if (v[j] > box.max[j]) {
                        box.max[j] = v[j];
                    }
                }
            }
        };
    };

    /** @private
     *
     * @param center
     * @param radius
     */
    HumanMath.Sphere3 = function(center, radius) {
        this.center = new Float64Array(center);
        this.radius = radius;


        this.isEmpty = function() {
            return (this.radius === 0.0);
        };


        this.surfaceArea = function() {
            return (4.0 * Math.PI * this.radius * this.radius);
        };


        this.getVolume = function() {
            return ((4.0 / 3.0) * Math.PI * this.radius * this.radius * this.radius);
        };
    };

    /** Creates billboard matrix from given view matrix
     * @private
     */
    HumanMath.billboardMat = function(viewMatrix, dest) {
        var rotVec = [
            HumanMath.getColMat4(viewMatrix, 0),
            HumanMath.getColMat4(viewMatrix, 1),
            HumanMath.getColMat4(viewMatrix, 2)
        ];

        var scaleVec = new Float64Array([
            HumanMath.lenVec4(rotVec[0]),
            HumanMath.lenVec4(rotVec[1]),
            HumanMath.lenVec4(rotVec[2])
        ]);

        var scaleVecRcp = HumanMath.rcpVec3(scaleVec);
        var sMat = HumanMath.scalingMat4v(scaleVec);

        HumanMath.mulVec4Scalar(rotVec[0], scaleVecRcp[0], rotVec[0]);
        HumanMath.mulVec4Scalar(rotVec[1], scaleVecRcp[1], rotVec[1]);
        HumanMath.mulVec4Scalar(rotVec[2], scaleVecRcp[2], rotVec[2]);

        var result = dest || HumanMath.mat4();

        HumanMath.identityMat4(result);

        HumanMath.setRowMat4(result, 0, rotVec[0]);
        HumanMath.setRowMat4(result, 1, rotVec[1]);
        HumanMath.setRowMat4(result, 2, rotVec[2]);

        HumanMath.mulMat4(result, sMat, result);

        return result;
        // return HumanMath.mulMat4(sMat, HumanMath.mulMat4(rotMatInverse, sMat));
        //return HumanMath.mulMat4(sMatInv, HumanMath.mulMat4(rotMatInverse, sMat));
    };

    /**
     *
     */
    HumanMath.identityQuaternion = function(dest) {
        var r = dest || HumanMath.vec4;

        r[0] = 0;
        r[1] = 0;
        r[2] = 0;
        r[3] = 1;

        return r;
    };

    /**
     *
     */
    HumanMath.angleAxisQuaternion = function(axis, radians, dest) {
       // var angleRad = (degrees / 180.0) * Math.PI;
        //var angleRad = degrees;
        var r = dest || HumanMath.vec4();
        var halfAngle = radians / 2.0;
        var fsin = Math.sin(halfAngle);

        r[0] = fsin * axis[0];
        r[1] = fsin * axis[1];
        r[2] = fsin * axis[2];
        r[3] = Math.cos(halfAngle);

        return r;
    };

    /**
     *
     */
    HumanMath.mulQuaternions = function(p, q, dest) {
        var r;
        if(p === dest || q === dest) {
            r = tempVec;
        } else {
            r = dest || HumanMath.vec4();
        }

        r[0] = p[3] * q[0] + p[0] * q[3] + p[1] * q[2] - p[2] * q[1];
        r[1] = p[3] * q[1] + p[1] * q[3] + p[2] * q[0] - p[0] * q[2];
        r[2] = p[3] * q[2] + p[2] * q[3] + p[0] * q[1] - p[1] * q[0];
        r[3] = p[3] * q[3] - p[0] * q[0] - p[1] * q[1] - p[2] * q[2];
        
        if( r === tempVec) {
            dest[0] = r[0];
            dest[1] = r[1];
            dest[2] = r[2];
            dest[3] = r[3];
        }
        

        return r;
    };

    /**
     *
     */
    HumanMath.newMat4FromQuaternion = function(q, dest) {
        var tx = 2.0 * q[0];
        var ty = 2.0 * q[1];
        var tz = 2.0 * q[2];
        var twx = tx * q[3];
        var twy = ty * q[3];
        var twz = tz * q[3];
        var txx = tx * q[0];
        var txy = ty * q[0];
        var txz = tz * q[0];
        var tyy = ty * q[1];
        var tyz = tz * q[1];
        var tzz = tz * q[2];
        var m = dest || HumanMath.mat4();
        HumanMath.identityMat4(m);
        HumanMath.setCellMat4(m, 0, 0, 1.0 - (tyy + tzz));
        HumanMath.setCellMat4(m, 0, 1, txy - twz);
        HumanMath.setCellMat4(m, 0, 2, txz + twy);
        HumanMath.setCellMat4(m, 1, 0, txy + twz);
        HumanMath.setCellMat4(m, 1, 1, 1.0 - (txx + tzz));
        HumanMath.setCellMat4(m, 1, 2, tyz - twx);
        HumanMath.setCellMat4(m, 2, 0, txz - twy);
        HumanMath.setCellMat4(m, 2, 1, tyz + twx);
        HumanMath.setCellMat4(m, 2, 2, 1.0 - (txx + tyy));
        return m;
    };


    //HumanMath.slerp(t, q1, q2) {
    //    var result = HumanMath.identityQuaternion();
    //    var cosHalfAngle = q1[3] * q2[3] + q1[0] * q2[0] + q1[1] * q2[1] + q1[2] * q2[2];
    //    if (Math.abs(cosHalfAngle) >= 1) {
    //        return [ q1[0],q1[1], q1[2], q1[3] ];
    //    } else {
    //        var halfAngle = Math.acos(cosHalfAngle);
    //        var sinHalfAngle = Math.sqrt(1 - cosHalfAngle * cosHalfAngle);
    //        if (Math.abs(sinHalfAngle) < 0.001) {
    //            return [
    //                q1[0] * 0.5 + q2[0] * 0.5,
    //                q1[1] * 0.5 + q2[1] * 0.5,
    //                q1[2] * 0.5 + q2[2] * 0.5,
    //                q1[3] * 0.5 + q2[3] * 0.5
    //            ];
    //        } else {
    //            var a = Math.sin((1 - t) * halfAngle) / sinHalfAngle;
    //            var b = Math.sin(t * halfAngle) / sinHalfAngle;
    //            return [
    //                q1[0] * a + q2[0] * b,
    //                q1[1] * a + q2[1] * b,
    //                q1[2] * a + q2[2] * b,
    //                q1[3] * a + q2[3] * b
    //            ];
    //        }
    //    }
    //}

    /**
     *
     */
    HumanMath.slerp = function(t, q1, q2, dest) {
        var r = dest || HumanMath.vec4();
        var q13 = q1[3] * 0.0174532925;
        var q23 = q2[3] * 0.0174532925;
        var cosHalfAngle = q13 * q23 + q1[0] * q2[0] + q1[1] * q2[1] + q1[2] * q2[2];
        if (Math.abs(cosHalfAngle) >= 1) {
            r[0] = q1[0];
            r[1] = q1[1];
            r[2] = q1[2];
            r[3] = q1[3];

            return r;
        } else {
            var halfAngle = Math.acos(cosHalfAngle);
            var sinHalfAngle = Math.sqrt(1 - cosHalfAngle * cosHalfAngle);
            if (Math.abs(sinHalfAngle) < 0.001) {
                r[0] = q1[0] * 0.5 + q2[0] * 0.5;
                r[1] = q1[1] * 0.5 + q2[1] * 0.5;
                r[2] = q1[2] * 0.5 + q2[2] * 0.5;
                r[3] = q1[3] * 0.5 + q2[3] * 0.5;

                return r;
            } else {
                var a = Math.sin((1 - t) * halfAngle) / sinHalfAngle;
                var b = Math.sin(t * halfAngle) / sinHalfAngle;

                r[0] = q1[0] * a + q2[0] * b;
                r[1] = q1[1] * a + q2[1] * b;
                r[2] = q1[2] * a + q2[2] * b;
                r[3] = (q13 * a + q23 * b) * 57.295779579;
                
                return r;
            }
        }
    };


    /**
     * 
     */
    HumanMath.easeOut = function (t, b, c, d) {
        var ts = (t /= d) * t;
        var tc = ts * t;
        return b + c * (-1 * ts * ts + 4 * tc + -6 * ts + 4 * t);
    };

    /**
     * 
     */
    HumanMath.easeIn = function (t, b, c, d) {
        var ts = (t /= d) * t;
        var tc = ts * t;
        return b + c * (tc * ts);
    };

    /**
     *
     */
    HumanMath.normalizeQuaternion = function(q, dest) {
        var r = dest || HumanMath.vec4();
        var len = HumanMath.lenVec3([q[0], q[1], q[2]]);

        r[0] = q[0] / len;
        r[1] = q[1] / len;
        r[2] = q[2] / len;
        r[3] = q[3] / len;

        return r;
    };


    /**
     *
     */
    HumanMath.conjugateQuaternion = function(q, dest) {
        var r = dest || HumanMath.vec4();

        r[0] = -q[0];
        r[1] = -q[1];
        r[2] = -q[2];
        r[3] = q[3];

        return r;
    };

    /**
     *
     */
    HumanMath.angleAxisFromQuaternion = function(q) {        
        HumanMath.normalizeQuaternion(q, q);
        var angle = 2 * Math.acos(q[3]);
        var s = Math.sqrt(1 - q[3] * q[3]);
        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
            return {
                x : q[0],
                y : q[1],
                z : q[2],
                angle: angle
            };
        } else {
            return {
                x : q[0] / s,
                y : q[1] / s,
                z : q[2] / s,
                angle: angle
            };
        }
    };

    /**
     *
     */
    HumanMath.getBoundaryCenter = function(boundary, dest) {
        var r = dest || HumanMath.vec3();

        r[0] = (boundary.xmax + boundary.xmin ) * 0.5;
        r[1] = (boundary.ymax + boundary.ymin ) * 0.5;
        r[2] = (boundary.zmax + boundary.zmin ) * 0.5;

        return r;
    };
    /**
     *
     */
    var min = HumanMath.vec3();
    var max = HumanMath.vec3();
    HumanMath.getBoundaryDiag = function(boundary) {
        
        min[0] = boundary.xmin;
        min[1] = boundary.ymin;
        min[2] = boundary.zmin;

        max[0] = boundary.xmax;
        max[1] = boundary.ymax;
        max[2] = boundary.zmax;

        HumanMath.subVec3(max, min, tempVec);

        return Math.abs(HumanMath.lenVec3(tempVec));
    };

    // A plane defined by a point and normal vector.
    HumanMath.createPlane = function createPlane(p, n) {

        var plane = {
            p: p || HumanMath.vec3(),
            n: n || HumanMath.vec3(),
            d: 0
        };

        plane.update = function(p, n) {
            plane.p.set(p);
            plane.n.set(n);

            plane.d = -HumanMath.dotVector3(plane.n, p);
        };

        // Signed distance
        plane.distance = function(p) {
            return HumanMath.dotVector3(plane.n, p) + plane.d;
        };

        // Test if an AABB is on the right side of the plane
        plane.boundaryInside = function(xmin, xmax, ymin, ymax, zmin, zmax) {
            var pos = tempVec;
            pos[0] = xmin;
            pos[1] = ymin;
            pos[2] = zmin;

            if (plane.n[0] >= 0) {
                pos[0] = xmax;
            }
            if (plane.n[1] >= 0) {
                pos[1] = ymax;
            }
            if (plane.n[2] >= 0) {
                pos[2] = zmax;
            }

            if (plane.distance(pos) < 0) {
                return false;
            } else {
                return true;
            }

        };

        return plane;
    };

})();
;/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/
(function() {
  "use strict";

    // math-inlining.
  var abs = Math.abs,
      cos = Math.cos,
      sin = Math.sin,
      atan2 = Math.atan2,
      sqrt = Math.sqrt,
      pow = Math.pow,
      // a zero coordinate, which is surprisingly useful
      ZERO = {x:0,y:0,z:0};


  // Bezier utils 
  var bezierUtils = {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    Tvalues: [
      -0.0640568928626056260850430826247450385909,
      0.0640568928626056260850430826247450385909,
      -0.1911188674736163091586398207570696318404,
      0.1911188674736163091586398207570696318404,
      -0.3150426796961633743867932913198102407864,
      0.3150426796961633743867932913198102407864,
      -0.4337935076260451384870842319133497124524,
      0.4337935076260451384870842319133497124524,
      -0.5454214713888395356583756172183723700107,
      0.5454214713888395356583756172183723700107,
      -0.6480936519369755692524957869107476266696,
      0.6480936519369755692524957869107476266696,
      -0.7401241915785543642438281030999784255232,
      0.7401241915785543642438281030999784255232,
      -0.8200019859739029219539498726697452080761,
      0.8200019859739029219539498726697452080761,
      -0.8864155270044010342131543419821967550873,
      0.8864155270044010342131543419821967550873,
      -0.9382745520027327585236490017087214496548,
      0.9382745520027327585236490017087214496548,
      -0.9747285559713094981983919930081690617411,
      0.9747285559713094981983919930081690617411,
      -0.9951872199970213601799974097007368118745,
      0.9951872199970213601799974097007368118745
    ],

    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    Cvalues: [
      0.1279381953467521569740561652246953718517,
      0.1279381953467521569740561652246953718517,
      0.1258374563468282961213753825111836887264,
      0.1258374563468282961213753825111836887264,
      0.1216704729278033912044631534762624256070,
      0.1216704729278033912044631534762624256070,
      0.1155056680537256013533444839067835598622,
      0.1155056680537256013533444839067835598622,
      0.1074442701159656347825773424466062227946,
      0.1074442701159656347825773424466062227946,
      0.0976186521041138882698806644642471544279,
      0.0976186521041138882698806644642471544279,
      0.0861901615319532759171852029837426671850,
      0.0861901615319532759171852029837426671850,
      0.0733464814110803057340336152531165181193,
      0.0733464814110803057340336152531165181193,
      0.0592985849154367807463677585001085845412,
      0.0592985849154367807463677585001085845412,
      0.0442774388174198061686027482113382288593,
      0.0442774388174198061686027482113382288593,
      0.0285313886289336631813078159518782864491,
      0.0285313886289336631813078159518782864491,
      0.0123412297999871995468056670700372915759,
      0.0123412297999871995468056670700372915759
    ],

    arcfn: function(t, derivativeFn) {
      var d = derivativeFn(t);
      var l = d.x*d.x + d.y*d.y;
      if(typeof d.z !== "undefined") {
        l += d.z*d.z;
      }
      return sqrt(l);
    },

    length: function(derivativeFn) {
      var z=0.5,sum=0,len=bezierUtils.Tvalues.length,i,t;
      for(i=0; i<len; i++) {
        t = z * bezierUtils.Tvalues[i] + z;
        sum += bezierUtils.Cvalues[i] * bezierUtils.arcfn(t,derivativeFn);
      }
      return z * sum;
    },

    map: function(v, ds,de, ts,te) {
      var d1 = de-ds, d2 = te-ts, v2 =  v-ds, r = v2/d1;
      return ts + d2*r;
    },

    lerp: function(r, v1, v2) {
      var ret = {
        x: v1.x + r*(v2.x-v1.x),
        y: v1.y + r*(v2.y-v1.y)
      };
      if(!!v1.z && !!v2.z) {
        ret.z =  v1.z + r*(v2.z-v1.z);
      }
      return ret;
    },

    pointToString: function(p) {
      var s = p.x+"/"+p.y;
      if(typeof p.z !== "undefined") {
        s += "/"+p.z;
      }
      return s;
    },

    pointsToString: function(points) {
      return "[" + points.map(bezierUtils.pointToString).join(", ") + "]";
    },

    angle: function(o,v1,v2) {
      var dx1 = v1.x - o.x,
          dy1 = v1.y - o.y,
          dx2 = v2.x - o.x,
          dy2 = v2.y - o.y,
          cross = dx1*dy2 - dy1*dx2,
          m1 = sqrt(dx1*dx1+dy1*dy1),
          m2 = sqrt(dx2*dx2+dy2*dy2),
          dot;
      dx1/=m1; dy1/=m1; dx2/=m2; dy2/=m2;
      dot = dx1*dx2 + dy1*dy2;
      return atan2(cross, dot);
    },

    dist: function(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
      return sqrt(dx*dx+dy*dy);
    },

    abcratio: function(t, n) {
      // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var bottom = pow(t,n) + pow(1-t,n), top = bottom - 1;
      return abs(top/bottom);
    },

    projectionratio: function(t, n) {
      // see u(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var top = pow(1-t, n), bottom = pow(t,n) + top;
      return top/bottom;
    },

    align: function(points, line) {
      var tx = line.p1.x,
          ty = line.p1.y,
          a = -atan2(line.p2.y-ty, line.p2.x-tx),
          d = function(v) {
            return {
              x: (v.x-tx)*cos(a) - (v.y-ty)*sin(a),
              y: (v.x-tx)*sin(a) + (v.y-ty)*cos(a)
            };
          };
      return points.map(d);
    }

  };
  
  //--------------------------------------


  /**
   * Bezier curve constructor. The constructor argument can be one of three things:
   *
   * 1. array/4 of {x:..., y:..., z:...}, z optional
   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4
   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4
   *
   */
  var Bezier = Human.math.bezier = function(coords) {
    var args = (coords && coords.forEach) ? coords : [].slice.call(arguments);
    var coordlen = false;
    if(typeof args[0] === "object") {
      coordlen = args.length;
      var newargs = [];
      args.forEach(function(point) {
        ['x','y','z'].forEach(function(d) {
          if(typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }
    var higher = false;
    var len = args.length;
    if (coordlen) {
      if(coordlen>4) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
        higher = true;
      }
    } else {
      if(len!==6 && len!==8 && len!==9 && len!==12) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
      }
    }
    var _3d = (!higher && (len === 9 || len === 12)) || (coords && coords[0] && typeof coords[0].z !== "undefined");
    this._3d = _3d;
    var points = [];
    for(var idx=0, step=(_3d ? 3 : 2); idx<len; idx+=step) {
      var point = {
        x: args[idx],
        y: args[idx+1]
      };
      if(_3d) { point.z = args[idx+2]; }
      points.push(point);
    }
    this.order = points.length - 1;
    this.points = points;
    var dims = ['x','y'];
    if(_3d) {dims.push('z');}
    this.dims = dims;
    this.dimlen = dims.length;
    (function(curve) {
      var a = bezierUtils.align(points, {p1:points[0], p2:points[curve.order]});
      for(var i=0; i<a.length; i++) {
        if(abs(a[i].y) > 0.0001) {
          curve._linear = false;
          return;
        }
      }
      curve._linear = true;
    }(this));
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  };

  function getABC(n,S,B,E,t) {
    if(typeof t === "undefined") { t = 0.5; }
    var u = bezierUtils.projectionratio(t,n),
        um = 1-u,
        C = {
          x: u*S.x + um*E.x,
          y: u*S.y + um*E.y
        },
        s = bezierUtils.abcratio(t,n),
        A = {
          x: B.x + (B.x-C.x)/s,
          y: B.y + (B.y-C.y)/s
        };
    return { A:A, B:B, C:C };
  }

  Bezier.quadraticFromPoints = function(p1,p2,p3, t) {
    if(typeof t === "undefined") { t = 0.5; }
    // shortcuts, although they're really dumb
    if(t===0) { return new Bezier(p2,p2,p3); }
    if(t===1) { return new Bezier(p1,p2,p2); }
    // real fitting.
    var abc = getABC(2,p1,p2,p3,t);
    return new Bezier(p1, abc.A, p3);
  };

  Bezier.cubicFromPoints = function(S,B,E, t,d1) {
    if(typeof t === "undefined") { t = 0.5; }
    var abc = getABC(3,S,B,E,t);
    if(typeof d1 === "undefined") { d1 = bezierUtils.dist(B,abc.C); }
    var d2 = d1 * (1-t)/t;

    var selen = bezierUtils.dist(S,E),
        lx = (E.x-S.x)/selen,
        ly = (E.y-S.y)/selen,
        bx1 = d1 * lx,
        by1 = d1 * ly,
        bx2 = d2 * lx,
        by2 = d2 * ly;
    // derivation of new hull coordinates
    var e1  = { x: B.x - bx1, y: B.y - by1 },
        e2  = { x: B.x + bx2, y: B.y + by2 },
        A = abc.A,
        v1  = { x: A.x + (e1.x-A.x)/(1-t), y: A.y + (e1.y-A.y)/(1-t) },
        v2  = { x: A.x + (e2.x-A.x)/(t), y: A.y + (e2.y-A.y)/(t) },
        nc1 = { x: S.x + (v1.x-S.x)/(t), y: S.y + (v1.y-S.y)/(t) },
        nc2 = { x: E.x + (v2.x-E.x)/(1-t), y: E.y + (v2.y-E.y)/(1-t) };
    // ...done
    return new Bezier(S,nc1,nc2,E);
  };


  Bezier.prototype = {
    valueOf: function() {
      return this.toString();
    },
    toString: function() {
      return bezierUtils.pointsToString(this.points);
    },
    update: function() {
      // one-time compute derivative coordinates
      this.dpoints = [];
      for(var p=this.points, d=p.length, c=d-1; d>1; d--, c--) {
        var list = [];
        for(var j=0, dpt; j<c; j++) {
          dpt = {
            x: c * (p[j+1].x - p[j].x),
            y: c * (p[j+1].y - p[j].y)
          };
          if(this._3d) {
            dpt.z = c * (p[j+1].z - p[j].z);
          }
          list.push(dpt);
        }
        this.dpoints.push(list);
        p = list;
      }
      this.computedirection();
    },
    computedirection: function() {
      var points = this.points;
      var angle = bezierUtils.angle(points[0], points[this.order], points[1]);
      this.clockwise = angle > 0;
    },
    length: function() {
      return bezierUtils.length(this.derivative.bind(this));
    },
    _lut: [],
    getLUT: function(steps) {
      steps = steps || 100;
      if (this._lut.length === steps) { return this._lut; }
      this._lut = [];
      for(var t=0; t<=steps; t++) {
        this._lut.push(this.compute(t/steps));
      }
      return this._lut;
    },
    on: function(point, error) {
      error = error || 5;
      var lut = this.getLUT(), hits = [], c, t=0;
      for(var i=0; i<lut.length; i++) {
        c = lut[i];
        if (bezierUtils.dist(c,point) < error) {
          hits.push(c);
          t += i / lut.length;
        }
      }
      if(!hits.length) {return false;}
      return t /= hits.length;
    },
    get: function(t) {
      return this.compute(t);
    },
    point: function(idx) {
      return this.points[idx];
    },
    compute: function(t) {
      // shortcuts
      if(t===0) { return this.points[0]; }
      if(t===1) { return this.points[this.order]; }

      var p = this.points;
      var mt = 1-t;
      var ret;

      // linear?
      if(this.order===1) {
        ret = {
          x: mt*p[0].x + t*p[1].x,
          y: mt*p[0].y + t*p[1].y
        };
        if (this._3d) { ret.z = mt*p[0].z + t*p[1].z; }
        return ret;
      }

      // quadratic/cubic curve?
      if(this.order<4) {
        var mt2 = mt*mt,
            t2 = t*t,
            a,b,c,d = 0;
        if(this.order===2) {
          p = [p[0], p[1], p[2], ZERO];
          a = mt2;
          b = mt*t*2;
          c = t2;
        }
        else if(this.order===3) {
          a = mt2*mt;
          b = mt2*t*3;
          c = mt*t2*3;
          d = t*t2;
        }
        ret = {
          x: a*p[0].x + b*p[1].x + c*p[2].x + d*p[3].x,
          y: a*p[0].y + b*p[1].y + c*p[2].y + d*p[3].y
        };
        if(this._3d) {
          ret.z = a*p[0].z + b*p[1].z + c*p[2].z + d*p[3].z;
        }
        return ret;
      }

      // higher order curves: use de Casteljau's computation
      var dCpts = JSON.parse(JSON.stringify(this.points));
      while(dCpts.length > 1) {
        for (var i=0; i<dCpts.length-1; i++) {
          dCpts[i] = {
            x: dCpts[i].x + (dCpts[i+1].x - dCpts[i].x) * t,
            y: dCpts[i].y + (dCpts[i+1].y - dCpts[i].y) * t
          };
          if (typeof dCpts[i].z !== "undefined") {
            dCpts[i] = dCpts[i].z + (dCpts[i+1].z - dCpts[i].z) * t;
          }
        }
        dCpts.splice(dCpts.length-1, 1);
      }
      return dCpts[0];
    },
    derivative: function(t) {
      var mt = 1-t,
          a,b,c=0,
          p = this.dpoints[0];
      if(this.order===2) { p = [p[0], p[1], ZERO]; a = mt; b = t; }
      if(this.order===3) { a = mt*mt; b = mt*t*2; c = t*t; }
      var ret = {
        x: a*p[0].x + b*p[1].x + c*p[2].x,
        y: a*p[0].y + b*p[1].y + c*p[2].y
      };
      if(this._3d) {
        ret.z = a*p[0].z + b*p[1].z + c*p[2].z;
      }
      return ret;
    }
  };

}());
;
/**
 * Applies a callback to each item in a map concurrently, Returns via callback when
 * all items processed. In addition to the key and item, passes a context into callback also.
 * @param map
 * @param context
 * @param fn
 * @param ok
 * @param error
 */
Human.utils.concurrentMapIterate = function (map, context, fn, ok, error) {
    "use strict";

    var keys = [];
    for (var key in map) {
        if (map.hasOwnProperty(key)) {
            keys.push(key);
        }
    }
    var numKeys = keys.length;

    // Immediate ok when no items
    if (numKeys === 0) {
        ok();
        return;
    }

    var numComplete = 0;
    var wasError = false;

    // Fires ok when all items processed
    function done() {
        if (++numComplete >= numKeys && !wasError) {
            ok();
        }
    }

    // Catches only first error to avoid cascade
    function error2(message) {
        if (!wasError) {
            wasError = true;
            error(message);
        }
    }

    if (context) {
        for (var i = 0, len = keys.length; i < len; i++) {
            fn.call(context, keys[i], map[keys[i]], done, error2);
        }
    } else {
        for (i = 0, len = keys.length; i < len; i++) {
            fn(keys[i], map[keys[i]], done, error2);
        }
    }
};
;
/**
 * Executes a collection of tasks concurrently, signals completion
 * when all tasks complete, or error as soon as a task fails.
 */
Human.utils.ConcurrentTasks = function() {
    "use strict";

    var tasks = [];
    var numTasks = 0;
    var _onComplete;
    var _onError;
    var wasError = false;

    /**
     * Adds a task, like this:
     *
     * add(function(done, error) {
     *
     *      // Do task here, then call done() on success, or error("some error") on failure
     *
     * })
     *
     */
    this.add = function(task) {
        tasks[numTasks++] = task;
    };

    function done() {
        if (--numTasks <= 0 && !wasError) {
            _onComplete();
        }
    }

    function error(errMsg) {
        if (!wasError) {
            wasError = true;
            _onError(errMsg);
        }
    }

    /**
     * Runs added tasks concurrently.
     *
     * Calls onComplete as soon as all tasks have called their done() callbacks, else onError
     * as soon as one task calls its error() callback.
     *
     * The onError callback is only called once, for the first task that fails.
     */
    this.go = function(onComplete, onError) {
        _onComplete = onComplete;
        _onError = onError;
        wasError = false;
        if (numTasks > 0) {
            for (var i = 0, len = numTasks; i < len; i++) {
                (tasks[i])(done, error);
            }
        } else {
            onComplete();
        }
    };
};
;/**
 * Tests if files exist on server, caches results.
 */
(function () {
    "use strict";

    var FileExists = Human.utils.fileExists = {}; 

    // Caches flags for URLs
    var cache = {};

    // Ensures that cache doesn't grow too much
    var evictionQueue = [];
    var maxSize = 200;

    /**
     * Test if file exists at the given URL.
     * @param {String} url The file URL
     * @param {Function} callback callback which returns boolean flag which indicates if file exists
     */
    FileExists.test = function (url, callback) {

        var exists = cache[url];

        if (exists !== undefined) {
            callback(exists);
            return;
        }

        var http = new XMLHttpRequest();

        http.open('HEAD', url);

        http.onreadystatechange = function () {
            // response completed
            if (http.readyState === 4) {

                // Evict least-recently-used
                // if cache size limit reached

                if (evictionQueue.length >= maxSize) {
                    var evictURL = evictionQueue.shift();
                    delete cache[evictURL];
                }

                // Cache result
                exists = http.status !== 404;
                cache[url] = exists;
                evictionQueue.push(url);

                // Return result
                callback(exists);
            }
        };
        http.send();
    };

})();






;// TODO: Why is this a constructor?
Human.utils.ArrayIteration = function(array, fn, onComplete, onError) {
    "use strict";

    this.push = function(item) {
        array.push(item);
        window.setTimeout(next, 1);
    };

    var wasError = false;

    if (array.length === 0) {
        if (onComplete) {
            onComplete();
        }
        return;
    }

    function done() {
        if (array.length === 0) {
            if (onComplete) {
                onComplete();
            }
        } else {
            window.setTimeout(next, 1);
        }
    }

    function error(msg) {
        if (!wasError) {
            wasError = true;
            if (onError) {
                onError(msg);
            } else {
                if (onComplete) {
                    onComplete();
                }
            }
        }
    }

    function next() {
        if (array.length > 0) {
            fn(array.shift(), done, error);
        }
    }

    window.setTimeout(next, 1);
};
;
/**
 * Maps tags to items, supports fast queries to find items matching queries on tags
 */
Human.utils.TagMap = function () {
    "use strict";

    // Map of tags to items
    var tagMap = {};

    // Count of items mapped to each tag
    var tagCounts = {};

    // Map of all items by ID
    var items = {};

    // Search results cached against sets of query tags
    var cachedSearchResults;

    /**
     * Insert item into tag map
     */
    this.addItem = function (itemId, tags, item) {
        var tag;
        var tagItems;
        var tagCount;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagItems = tagMap[tag];
            if (!tagItems) {
                tagItems = tagMap[tag] = {};
            }
            tagItems[itemId] = item;
            tagCount = tagCounts[tag];
            if (!tagCount) {
                tagCounts[tag] = 1;
            } else {
                tagCounts[tag]++;
            }
        }
        items[itemId] = item;

        /* Blow away search results cache - could refine this
         */
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };

    /**
     * Returns items that match the given tags.
     * Caches them against the tags for fast re-query.
     */
    this.findItems = function (withTags) {

        withTags = withTags || {};

        var tags = withTags.tags || [];
        var key = tags.join(".");

        var matching = withTags.matching || "any";

        if (!cachedSearchResults) {
            cachedSearchResults = {};
        }
        var matchTypeCache = cachedSearchResults[matching];
        if (!matchTypeCache) {
            matchTypeCache = cachedSearchResults[matching] = {};
        }

        var result = matchTypeCache[key];

        if (!result) {
            switch (matching) {

                case "most":
                    result = this._findHitsMost(tags);
                    break;

                case "atLeast":
                    result = this._findHitsAtLeast(tags);
                    break;

                case "any":
                    result = this._findHitsAny(tags);
                    break;
            }
            matchTypeCache[key] = result;
        }

        return result;
    };

    /**
     * Returns the first item found (in lexical order) that matches the largest subset of the given tags.
     */
    this._findHitsMost = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var bestItemId;
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {                // With each item info for tag
                    if (items.hasOwnProperty(itemId)) {
                        var hits = itemHits[itemId];       // Record tag hit for item info
                        if (!hits) {
                            hits = itemHits[itemId] = 1;
                        } else {
                            hits = ++itemHits[itemId];
                        }
                        if (!bestItemId || hits > itemHits[bestItemId]) { // Track item info with most hits
                            bestItemId = itemId;
                        }
                    }
                }
            }
        }
        var result = {};// Return item info with most hits
        if (bestItemId) {
            result[bestItemId] = items[bestItemId];
        }
        return result;
    };

    /**
     * Returns items matching the complete set of given tags
     */
    this._findHitsAtLeast = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var numTags = tags.length;
        var result = {};
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) { // With each item info for tag
                        var hits = itemHits[itemId];    // Record tag hit for item info
                        if (!hits) {
                            hits = itemHits[itemId] = 1;
                        } else {
                            hits = ++itemHits[itemId];
                        }
                        if (hits === numTags) {          // Collect item infos matching
                            result[itemId] = items[itemId]; // all the query tags
                        }
                    }
                }
            }
        }
        return result;
    };

    /**
     * Returns item infos matching any of the given tags
     */
    this._findHitsAny = function (tags) {
        var tag;
        var items;
        var result = {};
        for (var i = 0, len = tags.length; i < len; i++) {  // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) {   // With each item info for tag
                        result[itemId] = items[itemId];   // Collect item infos matching the tag
                    }
                }
            }
        }
        return result;
    };

    /** Remove item from map
     */
    this.removeItem = function (itemId) {
        var tagItems;
        var item;
        for (var tag in tagMap) {
            if (tagMap.hasOwnProperty(tag)) {
                tagItems = tagMap[tag];
                item = tagItems[itemId];
                if (item) {
                    delete tagItems[itemId];
                    if (--tagCounts[tag] === 0) {
                        delete tagMap[tag];
                        delete tagCounts[tag];
                    }
                }
            }
        }
        delete items[itemId];
        // Blow away search results cache - could refine this
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };
};;/**
 * Maps tags to lists of items, supports fast queries to find items matching given tags
 */
Human.utils.TagMapList = function () {
    "use strict";

    //  Map of tags to items
    var tagMap = {};

    //  Count of items mapped to each tag
    var tagCounts = {};

    //  Map of all items by ID
    var items = {};

    /**
     * Search results cached against sets of query tags
     */
    var cachedSearchResults;

    /**
     * Insert item into tag map
     */
    this.addItem = function (itemId, tags, item) {
        // Must have tags
        if (tags.length === 0) {
            return;
        }

        var tag;
        var tagItems;
        var tagCount;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagItems = tagMap[tag];
            if (!tagItems) {
                tagItems = tagMap[tag] = {};
            }
            tagItems[itemId] = item;
            tagCount = tagCounts[tag];
            if (!tagCount) {
                tagCounts[tag] = 1;
            } else {
                tagCounts[tag]++;
            }
        }
        items[itemId] = item;

        // Blow away search results cache - could refine this
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };

    /**
     * Returns items that match the given tags.
     * Caches them against the tags for fast re-query.
     */
    this.findItems = function (withTags) {
        withTags = withTags || {};
        var tags = withTags.tags || [];
        var key = tags.join(".");
        var matching = withTags.matching || "any";
        if (!cachedSearchResults) {
            cachedSearchResults = {};
        }
        var matchTypeCache = cachedSearchResults[matching];
        if (!matchTypeCache) {
            matchTypeCache = cachedSearchResults[matching] = {};
        }
        var result = matchTypeCache[key];
        if (!result) {
            switch (matching) {
                case "most":
                    result = this._findHitsMost(tags);
                    break;
                case "atLeast":
                    result = this._findHitsAtLeast(tags);
                    break;
                case "any":
                    result = this._findHitsAny(tags);
                    break;
                case "except":
                    result = this._findHitsExcept(tags);
            }
            matchTypeCache[key] = result;
        }
        return result;
    };

    /**
     * Returns the first item found (in lexical order) that
     * matches the largest subset of the given tags.
     */
    this._findHitsMost = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var bestItemId;
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) { // With each item info for tag
                    if (items.hasOwnProperty(itemId)) {
                        var hits = itemHits[itemId]; // Record tag hit for item info
                        if (!hits) {
                            hits = itemHits[itemId] = 1;
                        } else {
                            hits = ++itemHits[itemId];
                        }
                        if (!bestItemId || hits > itemHits[bestItemId]) { // Track item info with most hits
                            bestItemId = itemId;
                        }
                    }
                }
            }
        }
        var result = []; // Return item info with most hits
        if (bestItemId) {
            result.push(items[bestItemId]);
        }
        return result;
    };

    /**
     * Returns items matching the complete set of given tags
     */
    this._findHitsAtLeast = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var numTags = tags.length;
        var got = {};
        var result = [];
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) { // With each item info for tag
                        if (!got[itemId]) {
                            var hits = itemHits[itemId];    // Record tag hit for item info
                            if (!hits) {
                                hits = itemHits[itemId] = 1;
                            } else {
                                hits = ++itemHits[itemId];
                            }
                            if (hits === numTags) {          // Collect item infos matching
                                result.push(items[itemId]); // all the query tags
                                got[itemId] = true;
                            }
                        }
                    }
                }
            }
        }
        return result;
    };

    /**
     * Returns item infos matching any of the given tags
     */
    this._findHitsAny = function (tags) {
        var tag;
        var items;
        var got = {};
        var result = [];
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) { // With each item info for tag
                        if (!got[itemId]) {
                            result.push(items[itemId]);  // Collect item infos matching the tag
                            got[itemId] = true;
                        }
                    }
                }
            }
        }
        return result;
    };

    /**
     * Returns item infos not matching the given tags
     */
    this._findHitsExcept = function (tags) {
        var result = [];

        // Go through each item
        for (var itemId in items) {
            if (items.hasOwnProperty(itemId)) {
                // Go through each given tag
                for (var i = 0; i < tags.length; i++) {
                    // Does the item exist in the tagmap?
                    var tagItems = tagMap[tags[i]];
                    if (tagItems !== undefined) {
                        if (tagItems[itemId] !== undefined) {
                            break;
                        }
                    }
                    if (i === (tags.length-1)) {
                        result.push(items[itemId]);
                    }
                }
            }
        }

        return result;
    };

    /** Remove item from map
     */
    this.removeItem = function (itemId) {
        var tagItems;
        var item;
        for (var tag in tagMap) {
            if (tagMap.hasOwnProperty(tag)) {
                tagItems = tagMap[tag];
                item = tagItems[itemId];
                if (item) {
                    delete tagItems[itemId];
                    if (--tagCounts[tag] === 0) {
                        delete tagMap[tag];
                        delete tagCounts[tag];
                    }
                }
            }
        }

        delete items[itemId];

        /* Blow away search results cache - could refine this
         */
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };
};;/**
 * @class Generic map of IDs to items - can generate own IDs or accept given IDs. IDs should be strings in order to not
 * clash with internally generated IDs, which are numbers.
 * @private
 */
Human.utils.Map = function (items, _baseId) {
    "use strict";

    /**
     * @property Items in this map
     */
    this.items = items || [];


    var baseId = _baseId || 0;
    var lastUniqueId = baseId;
    // Attach id number to make unique
    if (typeof baseId !== "number") {
        lastUniqueId = baseId + "0";
    }

    /**
     * Adds an item to the map and returns the ID of the item in the map. If an ID is given, the item is
     * mapped to that ID. Otherwise, the map automatically generates the ID and maps to that.
     *
     * id = myMap.addItem("foo") // ID internally generated
     *
     * id = myMap.addItem("foo", "bar") // ID is "foo"
     *
     */
    this.addItem = function () {

        var item;

        if (arguments.length === 2) {

            var id = arguments[0];

            item = arguments[1];

            if (this.items[id]) { // Won't happen if given ID is string
                throw "ID clash: '" + id + "'";
            }

            this.items[id] = item;

            return id;

        } else {

            while (true) {

                item = arguments[0];

                // Last unique id is either # or prefix + #
                var findId;
                if (typeof baseId === "number") {
                    findId = lastUniqueId++;
                } else {
                    findId = baseId + parseInt(lastUniqueId.substr(baseId.length));
                    lastUniqueId = baseId + (parseInt(lastUniqueId.substr(baseId.length)) + 1);
                }

                if (!this.items[findId]) {
                    this.items[findId] = item;
                    return findId;
                }
            }
        }
    };

    /**
     * Removes the item of the given ID from the map and returns it
     */
    this.removeItem = function (id) {
        var item = this.items[id];

        if (item !== undefined) {
            // Remove id from item list
            delete this.items[id];
            // Update last unique id -- prevents holes
            lastUniqueId = id;
        }

        return item;
    };
};;
/**
 * A fast pool of reusable ids
 */
Human.utils.IDPool = function(cfg) {
    "use strict";

    cfg = cfg || {};

    var prefix = cfg.prefix || "id";
    var prefixLen = prefix.length;
    var idNums = [];
    var clientIds = {};    // IDs explicitly supplied by client
    var internalIds = {};  // IDs internally generated

    /** Gets new ID
     */
    this.getId = function(clientId) {
        if (clientId) {
            // Explicit user-supplied ID
            if (clientIds[clientId] || internalIds[clientId]) {
                throw "ID already in use: " + clientId;
            }
            clientIds[clientId] = true;
            return clientId;
        }
        var internalId;
        // Try to find hole in ID nums
        for (var i = 0, len = idNums.length; i < len; i++) {
            if (!idNums[i]) {
                internalId = prefix + i;
                if (!clientIds[internalId]) { // Don't clobber user ID
                    idNums[i] = true;
                    internalIds[internalId] = true;
                    return internalId;
                }
            }
        }
        // No hole found in ID nums - append new one
        idNums.push(true);
        internalId = prefix + (idNums.length - 1);
        internalIds[internalId] = true;
        return internalId;
    };

    /** Returns true if given ID in use
     *
     * @param id
     * @return {Boolean}
     */
    this.containsId = function(id) {
        return clientIds[id] !== undefined || internalIds[id] !== undefined;
    };

    /** Releases ID to the pool for reuse
     */
    this.putId = function(id) {
        if (clientIds[id]) {
            delete clientIds[id];
        } else if (internalIds[id]) {
            // Additional check to make sure that id exists in pool

            idNums[parseInt(id.substr(prefixLen))] = false;
            delete internalIds[id];
        }
    };

};
;

/**
 * Base class for all content library loader types.
 *
 * Provides template methods to overload to do the actual load and unload of libraries.
 *
 * Tracks what's loaded against a model/state ID so you can just unload using that ID.
 *
 * @param cfg
 * @param cfg.libraries Library container this loader loads into
 * @param cfg.load Loader strategy

 */
Human.utils.Loader = function () {
    "use strict";

    // Tracks asset libraries that are loaded for models
    this._loadedModelLibs = {};

    /**
     * Override this template method to configure the loader subclass
     */
    this.configure = function () {
    };

    /**
     * Loads a library for a given model
     *
     * @param moduleId
     * @param modelId
     * @param libraryId
     * @param params
     * @param ok
     * @param error
     */
    this.load = function (moduleId, modelId, libraryId, params, ok, error) {
        this._loadedModelLibs[modelId] = this._loadedModelLibs[modelId] || {};
        if (this._loadedModelLibs[modelId][libraryId]) {
            Human.log.warn("Human.utils.Loader.load", "Library '" + libraryId + "' already loaded for model '" + modelId + "' - not reloading");
            ok();
            return;
        }
        var self = this;
        var _ok = function () {
            self._loadedModelLibs[modelId][libraryId] = true;
            ok();
        };
        this._load(moduleId, modelId, libraryId, params,_ok, error);
    };

    /** Override this template method to implement the load method
     *
     * @param moduleId Module that owns this model
     * @param modelId State collection we're loading for
     * @param libraryId Library we're loading
     * @param params Whatever params are involved for this load
     * @param ok Success callback
     * @param error Failure callback
     * @private
     */

    this._load = function (moduleId, modelId, libraryId, params, ok, error) {
        // jshint unused:false

        Human.log.error("Human.utils.Loader._load not implemented");
        ok();
    };

    /**
     * Unloads libraries for the given model
     *
     * @param modelId
     */
    this.unload = function (modelId) {
    //    Human.log.info("Human.utils.Loader.unload", "Unloading model '" + modelId + "'");
        var loaded = this._loadedModelLibs[modelId];
        if (loaded) {
            for (var libraryId in loaded) {
                if (loaded.hasOwnProperty(libraryId)) {
                    this._unload(modelId + "." + libraryId);
                }
            }
            delete this._loadedModelLibs[modelId];
        }
    };

    /** Override this template method to implement unload
     *
     * @param globalLibraryId Library to unload
     * @private
     */
    this._unload = function (globalLibraryId) {
        // jshint unused:false
        
        Human.log.error("Human.utils.Loader._unload", "This method needs to be implemented");
    };
};

;/**
 * @namespace Provides methods for sending and subscribing events.
 */
(function () {
    "use strict";

    var HumanEvents = Human.events = {};

    var eventBinders = {};

    var DEFAULT_EVENT_CHANNEL = 0;

    var eventChannels = [
        {} // Default channel
    ];

    var enabledEventChannels = {};

    var remembered = {};

    var suspendEvents = false;   // If set to true, events will be blocked.

    /**
     * Injects a factory function which creates bindings for a given event type. This enables an event source
     * to decide when to fire events based on an event-specific mask that may be optionally given to the .onEvent method.
     *
     * <h3>Works like this:</h3>
     *
     * Human.events.addBinder(
     *      "my-event-type",
     *      function(mask, fn) {  // The factory function
     *
     *          // Creates bindings where fn will be called
     *          // by event source, passing event to it,
     *          // when criteria in mask are met.
     *
     *      });
     * </pre>
     *
     * @memberof Human.events
     */
    HumanEvents.addBinder = function (eventName, eventBinder) {
        (eventBinders[eventName] || (eventBinders[eventName] = [])).push(eventBinder);
    };

    /**
     * Creates an event channel. Events can be fired on these channels,
     * which can be selectively enabled/disabled for efficient dynamic event
     * subscription/unsubsubscription.
     *
     * <h3>Example:</h3>
     * <pre>
     *     var myNewChannel = createEventChannel({
     *        enabled: true
     *     });
     * </pre>
     *
     * @memberof Human.events
     */
    HumanEvents.createChannel = function (cfg) {
        var channel = eventChannels.length;
        eventChannels.push({});
        if (cfg && cfg.enabled) {
            HumanEvents.enableChannel(channel, cfg.enabled);
        }
        return channel;
    };

    /**
     * Enable or disable an event channel.
     *
     * @memberof Human.events
     */
    HumanEvents.enableChannel = function (channel, enable) {
        enabledEventChannels[channel] = enable;
    };

    /**
     * Registers a handler for a type of engine event.
     *
     * <p>The handler can be registered with an optional priority number which specifies the order it is
     * called among the other handler already registered for the event.</p>
     *
     * <p>So, with n being the number of handlers registered for the given event:</p>
     * <ul>
     * <li>(priority <= 0)      - handler will be the first called</li>
     * <li>(priority >= n)      - handler will be the last called</li>
     * <li>(0 < priority < n)   - handler will be called at the order given by the priority</li>
     *
     * @param channel - Optional channel name, falls back on default channel when omitted
     * @param type Event type - one of the values in SceneJS._eventModule
     * @param fn - Handler function that will accept whatever parameter object accompanies the event
     * @param priority - Optional priority number (see above)
     * @memberof Human.events
     */
    HumanEvents.onEvent = HumanEvents.on = function () {
        var channel;
        var type;
        var fn;
        var options;
        if (typeof arguments[0] === "number") {
            channel = arguments[0];
            if (channel > eventChannels.length - 1) {
                Human.log.error("Human_event.onEvent", "Channel not created: " + channel +
                    " - should be created first with Human.events.createChannel");
                return;
            }
            type = arguments[1];
            fn = arguments[2];
            options = arguments[3];
        } else if (typeof arguments[0] === "object") {
            var params = arguments[0];
            type = params.type;
            fn = params.fn;
            // Masked subscriptions not (yet) channeled or prioritised
            var binders = eventBinders[type];
            if (binders) {
                var mask = params.mask || {};
                for (var i = 0, len = binders.length; i < len; i++) {
                    binders[i](mask, fn);
                }
            }
            channel = (params.channel !== undefined && params.channel !== null) ? params.channel : DEFAULT_EVENT_CHANNEL;
            options = params.options;
        } else {
            channel = DEFAULT_EVENT_CHANNEL;
            type = arguments[0];
            fn = arguments[1];
            options = arguments[2];
        }
        enabledEventChannels[channel] = (options && options.enable !== undefined && options.enable !== null) ? options.enable : true;
        options = options || {};
        var subscriberLists = eventChannels[channel];
        if (!subscriberLists) {
            subscriberLists = eventChannels[channel] = {};
        }
        var list = subscriberLists[type];
        if (!list) {
            list = [];
            subscriberLists[type] = list;
        }
        var handler = {
            fn: fn,
            priority: (options.priority === undefined) ? list.length : options.priority,
            once: options.once
        };
        for (i = 0; i < list.length; i++) {
            if (list[i].priority > handler.priority) {
                list.splice(i, 0, handler);
                return;
            }
        }
        list.push(handler);
        if (remembered[type]) {
            handler.fn(remembered[type]);
        }
    };

    /** Single-shot event subscribe
     *
     * @param type
     * @param ok
     */
    HumanEvents.once = function (type, ok) {
        var fn = function (result) {
            HumanEvents.off(type, fn);
            ok(result);
        };
        HumanEvents.on(type, fn);
    };

    /**
     * Fire an event.
     * @param {String} type Event type name
     * @param {{}} [params] Map of parameters to accompany the event - must be JSON-serializable.
     * @memberof Human.events
     */
    HumanEvents.fireEvent = HumanEvents.fire = function (type, params, remember) {
        if (suspendEvents) {
            return;
        }

        var subscriberLists;
        var list;
        for (var channel = 0, numChannels = eventChannels.length; channel < numChannels; channel++) {
            if (enabledEventChannels[channel]) {
                subscriberLists = eventChannels[channel];
                list = subscriberLists[type];
                if (list) {
                    if (!params) {
                        params = {};
                    }
                    var toRemove;
                    var handler;
                    for (var i = 0, len = list.length; i < len; i++) {
                        handler = list[i];
                        // A handler could be undefined by this time,
                        // should we ever unEvent it before we get here.
                        try {
                            handler.fn(params);
                            if (handler.once) {
                                if (!toRemove) {
                                    toRemove = [];
                                }
                                toRemove.push(i);
                            }
                       } catch(exception) {
                           Human.log.error(exception);
                       }
                    }
                    if (toRemove) {
                        for (i = toRemove.length - 1; i >= 0; i--) {
                            list.splice(toRemove[i]);
                        }
                    }
                }
            }
        }
        if (remember) {
            remembered[type] = params;
        }
    };

    HumanEvents.blockEvents = function(fn) {
        suspendEvents = true;
        try {
            fn();
        } catch (e) {
            Human.log.error(e.message);
        }
        suspendEvents = false;
    };

    /** Remove a Handler with a certain Function from the List of Handlers for
     * an Event of a certain Type.
     * @memberof Human.events
     * @param channel to turn off -- default if undefined
     * @param type of the channel
     * @param fn -- function to call
     */
    HumanEvents.unEvent = HumanEvents.off = function (type, fn, channel) {  // TODO: unbind for optional channel
        // If channel unspecified -- it is default channel
        // If channel does not exist, nothing to turn off
        if (channel === undefined || channel === null) {
            channel = DEFAULT_EVENT_CHANNEL;
        } else if (channel >= eventChannels.length || channel < 0) {
            throw "Channel does not exist: " + channel;
        }

        var subscriberLists = eventChannels[ channel ];
        if (!subscriberLists) {
            subscriberLists = eventChannels[ channel ] = {};
        }
        var list = subscriberLists[ type ];
        if (!list) {
            list = [];
            subscriberLists[ type ] = list;
        }
        for (var i = list.length; i--;) {
            if (list[ i ].fn === fn) {
                list.splice(i, 1);
            }
        }
    };
})();
;/**
 @namespace Engine configs definition, update, subscription and query.

 <p>Properties are various engine configurations, such as background color in the 3D view, or mouse sensitivity.</p>

 <h3>Setting a property:</h3>
 <p>This will define the property if it doesn't already exist.</p>
 <pre>
 Human.properties.set({
        "annotations.style.default" : {
            displayName: "Default annotation config",
            pinHeadColor: { r: 1.0, g: 0.5, b: 0.5 },
            pinShaftColor: { r: 1.0, b: 1.0, g: 0.0 }
        }
  });
 </pre>
 <h3>Setting multiple properties:</h3>
 <pre>
 Human.properties.set({
        "annotation.teacher" : {
            pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
            pinShaftColor: { r: 1.0,b: 0.0, g: 1.0 }
        }
        "annotation.student" : {
            pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 }
            pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
        }
    });
 </pre>
 <h3>Querying properties</h3>
 <p>Querying all engine properties:</p>
 <pre>
 Human.properties.query();
 </pre>
 <p>Result:</p>
 <pre>
 {
     "annotation.default" : {
          pinHeadColor: { r: 1.0, g: 0.5, b: 0.5 },
          pinShaftColor: { r: 1.0, b: 1.0, g: 0.0 }
      },
      "annotation.teacher" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      },
      "annotation.student" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      }
  }
 </pre>

 <p>Querying engine properties with keys matching a regular expression:</p>
 <pre>
 Human.properties.query("teacher");
 </pre>
 <p>Result:</p>
 <pre>
 {
      "annotation.teacher" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      }
  }
 </pre>

 <h3>Subscribing to a property</h3>
 <p>A property may be subscribed to by a consumer who wants to be notified of any change to its value.</p>
 <ul>
 <li>The property will be created first if it does not yet exist, and a subscriber can provide an initial value to assign to the property if
 it is being created.</li>
 <li>The subscription will return an ID which is a handle to the subscription which can be used to unsubscribe. By default,
 the subscription ID is automatically generated, but the subscriber may optionally provide their own subscription ID instead.</li>
 </ul>
 <pre>
 var subId = Human.properties.subscribe({

          // Optional subscriber-managed ID.
          // Auto-generated if not supplied.
          subId: "mySub",

          // Mandatory property ID
          propId: "annotation.student",

          // Default config properties - these are overridden by
          // any properties that are previously or subsequently set
          // by a Config.Set command:
          value: {
              pinHeadColor:  { r: 1, g: 0, b: 0 },
              pinShaftColor: { r: 1, g: 1, b: 0 }
          },

          // Callback fired each time the config properties are set,
          // and immediately when the config is bound in this call:
          callback: function(props) {

              if (props.pinHeadColor) {
                 theAnnotation.setPinHeadColor(props.pinHeadColor);
              }

              if (props.pinShaftColor) {
                theAnnotation.setPinShaftColor(props.pinShaftColor);
             }

          }
  });
 </pre>

 <h3>Unsubscribing from a property:</h3>
 <pre>
 Human.properties.unsubscribe(subId);
 </pre>
 */
(function () {
    "use strict";

    var HumanProperties = Human.properties = {};

    // Subscription handle map, can internally generate new handles,
    // as well as insert user-generated handles
    var idPool = new Human.utils.IDPool();

    /**
     * Currently defined properties
     * @type {{*}}
     * @memberof Human.properties
     */
    HumanProperties.properties = {};

    // Maps subscription handles to callbacks
    var subCallbacks = {};

    // For each style, a map of callbacks mapped to subscription IDs
    var propSubCallbacks = {};

    // Maps subscription handles to property IDs
    var subProps = {};

    /**
     * Subscribes to a property, defining it first if not defined, and optionally setting its value
     *
     * <pre>
     *
     * // This format is extensible, eg. in case we want to add metadata etc
     *
     * var subId = Human.properties.subscribe({
     *          subId: "foo", // Call can opt to manage subscription IDs themselves
     *          propId: "myProperty",
     *          value: {
     *              color: { r: 0.2, g: 0.7, b: 1.0 },
     *              width: 1.2
     *          },
     *          callback: function(config) {
     *              someElement.setColor(config.color);
     *              someElement.setWidth(config.width);
     *          }
     *     });
     * </pre>
     *
     * @memberof Human.properties
     * @return {String} Handle to the subscription, which can be given to {@link Human.properties.unsubscribe} to unsubscribe
     */
    HumanProperties.subscribe = function (params) {

        params = params || {};

        // Every property has an ID
        var propId = params.propId;
        if (!propId) {
            Human.log.error("Human.properties.subscribe", "Param expected: propId");
            return null;
        }

        // Subscriber gets updates via callback
        var callback = params.callback;
        if (!callback) {
            Human.log.error("Human.properties.subscribe", "Param expected: callback");
            return null;
        }

        // If caller supplies own subscription handle, ensure no clash with existing handles
        if (params.subId) {
            if (idPool.containsId(params.subId)) {
                Human.log.error("Human.properties.subscribe", "Subscription already exists with this ID: " + params.subId);
                return null;
            }
        }

        var value = params.value;
        var subId = idPool.getId(params.subId); // Generate or insert subscription handle in map
        var prop = HumanProperties.properties[propId];

        if (prop) {

            // Property already exists

            if (value) {

                // New value supplied; set the property
                HumanProperties.properties[propId] = value;
            }

            // Map callback to subscription handle
            subCallbacks[subId] = callback;

            // Map property to subscription handle
            subProps[subId] = propId;

            // Notify callback of new property value
            callback(value);

            // Return subscription handle
            return subId;
        }

        // Register callback for the new property
        var callbacks = (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}));
        callbacks[subId] = callback;

        // Initial value not given, initialize to default
        if (value === undefined || value === null) {
            value = {}; // Might as well be a literal object
        }

        // Set property to new value
        HumanProperties.properties[propId] = value;

        // Map callback to subscription handle
        subCallbacks[subId] = callback;

        // Map property to subscription handle
        subProps[subId] = propId;

        // Notify callback of new property
        callback(value);

        // Return subscription handle
        return subId;
    };

    /**
     * Switches a subscription to a different property
     *
     * @param {String} subId Subscription handle that was obtained with {@link Human.properties.subscribe}
     * @param {String} propId ID of property to switch the subscription to
     * @memberof Human.properties
     */
    HumanProperties.resubscribe = function (subId, propId) {
        var callback = subCallbacks[subId];
        if (!callback) {
            Human.log.warn("Human.properties.resubscribe", "Subscription not found: '" + subId + "'");
            return;
        }
        var oldPropId = subProps[subId];
        var newProp = HumanProperties.properties[propId];
        if (oldPropId && newProp) {
            if (propSubCallbacks[oldPropId]) {
                delete propSubCallbacks[oldPropId][subId];
            }
            (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}))[subId] = callback;
            subProps[subId] = propId;
            callback(newProp);
        }
    };

    /**
     * Creates or edits one or more properties
     * @memberof Human.properties
     * @param {String} propId ID of config
     * @param {*} props Properties to write to the config
     */
    HumanProperties.set = function (props) {
        var value;
        var callbacks;
        for (var propId in props) {
            if (props.hasOwnProperty(propId)) {
                value = props[propId];
                HumanProperties.properties[propId] = value;
                callbacks = propSubCallbacks[propId];
                if (callbacks) {
                    for (var subId in callbacks) {
                        if (callbacks.hasOwnProperty(subId)) {
                            callbacks[subId](value);
                        }
                    }
                }
            }
        }
    };

    /**
     * Unsubscribes from a property
     * @memberof Human.properties
     * @param {String} subId Subscription ID
     */
    HumanProperties.unsubscribe = function (subId) {
        var propId = subProps[subId];
        if (!propId) {
            return;
        }
        delete subProps[subId];
        delete propSubCallbacks[propId][subId];
    };

    /**
     * Query existing props
     * @param {String} [regex] Regular expression to select properties by name
     * @returns {*} JSON map of queried props
     */
    HumanProperties.query = function (regex) {
        if (!regex) {
            return HumanProperties.properties;
        }
        var props;
        if (regex) {
            var pattern = new RegExp(regex);
            props = {};
            for (var propId in HumanProperties.properties) {
                if (HumanProperties.properties.hasOwnProperty(propId)) {
                    if (pattern.test(propId)) {
                        props[propId] = HumanProperties.properties[propId];
                    }
                }
            }
        }
        return props;
    };


    var defaults = {
      "annotations.margins":{
         "top":80,
         "left":50,
         "right":50,
         "bottom":50
      },
      "annotations.labelWidth":120,
      "annotations.horizontalLines":false,
      "annotations.occludedAngle":100,
      "annotations.fadeoutAngle":100,
      "annotation.layout.wires":true,
      "annotation.layout.labelMargins":100,
      "annotation.layout.labelWidth":100,
      "annotations.hideWhileCameraMoving":false,
      "annotations.layout.type":"draggable",
      "annotations.style.xray":{
         "line":{
            "color":{
               "r":1,
               "g":0.5,
               "b":0
            }
         }
      },
      "annotations.style.standard":{
         "line":{
            "color":{
               "r":0.3,
               "g":0.3,
               "b":0.3
            }
         }
      },
      "annotations.style.default":{
         "pin":{
            "color":{
               "r":1,
               "g":0.4,
               "b":0
            }
         }
      },
      'background.radial': {},
      'backgrounds': {
        black: [0,0,0,0,0,0,0,0,0,0,0,0],
        quiz: [1,1,1,1,1,1,1,1,1,1,1,1],
        standard: [0.13, 0.15, 0.17, 0.13, 0.15, 0.17, 0.54, 0.58, 0.64, 0.54, 0.58, 0.64],
        white: [1,1,1,1,1,1,1,1,1,1,1,1]
      },
      'camera.constrainBoundaryToCanvas': false,
      'camera.constrainBoundaryToCanvas.boundaryScale':1,
      'camera.constrainBoundaryToCanvas.showBoundary': false,
      'camera.constrainRotateX': false,
      'camera.constrainSceneToCanvas': false,
      'camera.flyTo': {
        'stopFOV': 55,
        'velocity': 30
      },
      'camera.gimbalLockY': true,
      'camera.optics.far': 5000,
      'camera.optics.fov': 55,
      'camera.optics.near': 0.1,
      'camera.zoomLimits':{
        max: 150,
        min: 0.01
      },
      'data.medline.enabled': true,
      'data.wikipedia.enabled': true,
      'hacks.alwaysBackfaces': false,
      'hacks.neverBackfaces': false,
      'highlight.enabled': true,
      'labels.enabled': true,
      'locale': 'en_US',
      'pick.alwaysRayPic': false,
      'skyboxes.activeSkybox': null,
      'timeline.autoPlay.enabled': false,
      'timeline.autoPlay.timeoutSecs': 10,
      'timeline.autoPlay.type': 'play',
      'timeline.cameraAnimationEnabled': true,
      'timeline.chapterCamerasEnabled': true,
      'timeline.prevNextMode': 'scrub',
      'tooltips.enabled': true,
      'ui.mouseWheel.capture': true,
      'ui.zoom.mouseWheel.enabled': true,
      'xray.color': false,
      'xray.colorsForBackgrounds':{
        black: [0.8, 0.8, 0.9],
        default: [0.8, 0.8, 0.9],
        standard: [0.8,0.8,0.9],
        white: [0, 0, 0.1]
      },
      'xray.enabled': true,
      'xray.glassFactor': 1,
      'xray.glassFactorForBackgrounds':{
        black: 0.9,
        default: 1,
        standard: 1,
        white: 0.7
      },
      'xray.glassFactorsForBackgrounds':{
        black: 1,
        default: 1,
        standard: 1,
        white: 1
      },
      'xray.murkiness': 0.5,
      'xray.murkinessForBackgrounds':{
        black: 0.75,
        default: 0.8,
        standard: 0.8,
        white: 0.8
      }
    };

    HumanProperties.getDefaults = function(prop){
      if (!!prop){
        if (defaults.hasOwnProperty(prop)){
          return defaults[prop];
        }
      } else {
        return Human.utils.shallowClone(defaults);
      }
    };

    HumanProperties.setDefaults = function (props) {
        Human.utils.apply(props, defaults);
    };

})();
;/**
 * @namespace Provides methods for logging debug info, warnings and errors.
 */
(function () {
    "use strict";

    var log = Human.log = {};

    /**
     * Logging level at which nothing is logged
     * @memberof Human.log
     * @private
     */
    log.LOG_NONE = 0;

    /**
     * Logging level at which everything is logged
     * @memberof Human.log
     * @private
     */
    log.LOG_DEBUG = 1;

    /**
     * Logging level at which only info, warnings and errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_INFO = 2;

    /**
     * Logging level at which only warnings and errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_WARN = 3;

    /**
     * Logging level at only errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_ERROR = 4;

    // Store messages for reporting
    log.messages = [];
    log.maxMessages = 100;

    // Used in event that notifies on each logged message
    var levelNames = ["none", "debug", "info", "warn", "error"];

    // Buffers messages until engine ready, at which point
    // they are each fired off in a Log.Message event
    var messageBuf = log.messageBuf = [];
    var maxMessageBuf = 200;

    var minLogLevel = log.LOG_WARN;

    // Field-of-View angle in degrees
    Human.properties.subscribe({
        propId: "log.level",
        value: minLogLevel,
        callback: function (value) {
            minLogLevel = value;
        }
    });

    // Reporters which may be registered to report logging messages as they happen
    var reporters = log.reporters = {};

    /**
     * Sets minimum log level. Messages logged to levels below that will then not be reported.
     * @memberof Human.log
     * @private
     */
    log.setLevel = function (newLevel) {
        minLogLevel = newLevel;
    };

    /**
     * Returns the current minimum log level
     * @memberof Human.log
     * @private
     */
    log.getLevel = function () {
        return minLogLevel;
    };

    /**
     * Logs a message at the given logging level.
     * @memberof Human.log
     * @private
     */
    log.log = function (message, level) {
        level = (level === undefined || level === null) ? log.INFO : level;
        switch (level) {
            case log.LOG_DEBUG:
                if (minLogLevel <= log.LOG_DEBUG && window.console && window.console.debug) {
                    window.console.debug(message);
                    recordMessage(message, level);
                }
                break;
            case log.LOG_ERROR:
                if (minLogLevel <= log.LOG_ERROR && window.console && window.console.error) {
                    window.console.error(message);
                    recordMessage(message, level);
                }
                break;
            case log.LOG_INFO:
                if (minLogLevel <= log.LOG_INFO && window.console && window.console.info) {
                    window.console.info(message);
                    recordMessage(message, level);
                }
                break;
            case log.LOG_WARN:
                if (minLogLevel <= log.LOG_WARN && window.console && window.console.warn) {
                    window.console.warn(message);
                    recordMessage(message, level);
                }
                break;
        }
        var event = {
            message: message,
            level: levelNames[level]
        };
        // Fire off to existing reporters
        for (var reporterId in reporters) {
            if (reporters.hasOwnProperty(reporterId)) {
                Human.events.fire(reporterId, event);
            }
        }
        // If message buffer now too long, flush and start it again with warning
        if (messageBuf.length > maxMessageBuf) {
            messageBuf.length = 0;
            messageBuf.push({
                message: "Logging buffer exceeded max length of " + maxMessageBuf +
                    " - messages to this point were flushed",
                level: levelNames[log.LOG_WARN]
            });
        }
        // Buffer message for reporters which may be created later
        messageBuf.push(event);
    };

    /** Logs a debugging message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.debug = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_DEBUG);
    };

    function pad(str) {
        return (str.length < 45) ? str + "                                                           ".substr(0, 45 - str.length) : str;
    }

    /** Logs an error message
     * @name error
     * @function
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.error = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_ERROR);
    };

    /** Logs an info message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.info = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_INFO);
    };

    /** Logs a warning message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.warn = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_WARN);
    };

    // Relay engine errors through logging methods
    Human.events.on("error",
        function (event) {
            log.error(event.message);
        });

    function recordMessage(message, level) {
        var levelName = levelNames[level].toUpperCase();

        if (log.messages.length > log.maxMessages) {
            log.messages.shift();
        }

        message = "[" + levelName + "]\t" + message;

        log.messages.push(message);
    }

})();



;/**
 * @namespace Supports query of params on URL in browser location bar.
 */
(function () {
    "use strict";

    var request = Human.request = {};

    var prevHash;
    var hashParams;
    var searchParams;

    request.getHashStr = function () {
        return window.location.hash;
    };

    /**
     * Gets all hash params.
     * @memberof Human.request
     * @return {*}
     */
    request.getHashParams = function () {
        if (!hashParams || prevHash !== window.location.hash) {
            hashParams = {};
            var stringAfterHash = window.location.hash.slice(1);
            var paramsAfterHash = stringAfterHash.split(',');
            var tokens;
            for (var i = 0, len = paramsAfterHash.length; i < len; i++) {
                tokens = paramsAfterHash[i].split("=");
                hashParams[tokens[0]] = tokens[1];
            }
            prevHash = window.location.hash;
        }
        return hashParams;
    };

    /** Gets a selected hash param - those params after the hash in the URL.
     * @memberof Human.request
     *
     * @param {String} key Hash parameter key
     * @return {String} Value of the hash parameter
     */
    request.getHashParam = function (key) {
        if (!hashParams || prevHash !== window.location.hash) {
            request.getHashParams();
        }
        return hashParams[key];
    };

    /**
     * Gets the search string - those params after the "?" in the URL.
     * @memberof Human.request
     * @return {String} The search string
     */
    request.getSearchStr = function () {
        return window.location.search;
    };

    /**
     * Get all search parameters.
     * @memberof Human.request
     * @return {*}
     */
    request.getSearchParams = function () {
        if (!searchParams) {
            searchParams = {};
            var search = window.location.search.slice(1);
            var params = search.split('&');
            var tokens;
            for (var i = 0, len = params.length; i < len; i++) {
                tokens = params[i].split("=");
                searchParams[tokens[0]] = tokens[1];
            }
        }
        return searchParams;
    };

    /** Gets a selected search parameter
     * @memberof Human.request
     *
     * @param {String} key Search parameter key
     * @return {String} Value of the search parameter
     */
    request.getSearchParam = function (key) {
        if (!searchParams) {
            request.getSearchParams();
        }
        return searchParams[key];
    };

})();;
// This section is actually documenting rpc.js from human-rpc
/**
 * Human API constructor
 * @param {string} iframeId - ID of the iFrame that the Human is loaded into
 * @returns A HumanAPI instance
 *
 * @class HumanAPI
 * @classdesc The HumanAPI class is the core of the BioDIgital Human API.  A
 * HumanAPI instance will be attached to an iframe containing BioDIgital Human
 * content and can be used to send messages to or receive messages from it.
 */

/**
 * Send an API message to the Human.
 *
 * @param {string} message - Name of the API message
 * @param {object} [params] - Message parameters
 * @method
 * @name HumanAPI#send
 */

/**
 * Subscribe to a Human event
 *
 * @function
 * @name HumanAPI#on
 * @param {string} eventName - Name of the API event
 * @param {function} callback - Event handler function
 */

 /**
 * Subscribe to the next Human event of the given type
 *
 * @function
 * @name HumanAPI#once
 * @param {string} eventName - Name of the API event
 * @param {function} callback - Event handler function
 */


(function () {
    "use strict";

    var rpc = Human.rpc = {
        windowClientEnabled: true
    };

    var MAX_LOG_SIZE = 10000;

    /** Map of procedures that have been created with {@link Human.rpc.define}.
     * @memberof Human.rpc
     * @type {{}}
     */
    rpc._procedures = {};

    // Map of RPC event names to engine event names.
    rpc._eventMap = {};

    // Callbacks registered with #onResult
    var resultCallbacks = [];

    // Allow definition of several deprecated functions at a time.
    var globalHideDefinitions = false;

    var hiddenProcedures = {};

    var log = [];


    /**
     * Execution scope for a procedure execution.
     * <p>A fresh one of these is instantiated for every procedure call, providing the procedure with
     * methods for returning the procedure result and logging.</p>
     * @param {string} procName Procedure name, for logging
     * @param {string} callId ID of procedure call, against which procedure result, if any, will be published
     * @constructor
     */
    function Scope(procName, callId) {
        this.procName = procName;
        this.callId = callId;
    }

    /**
     * Publishes the result of the procedure call.
     * <p>The result value is published against the ID of the caller,
     * who may subscribe to that ID using methods like {#link Human.rpc.on} in order to get the result.</p>
     * @param {{}} value The result value
     */
    Scope.prototype.setResult = function (value) {
        for (var i = 0, len = resultCallbacks.length; i < len; i++) {
            resultCallbacks[i](this.callId, value);
        }
    };

    /**
     * Logs debug info in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.info = function (msg) {
        Human.log.info(this.procName, msg);
    };

    /**
     * Logs a warning in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.warn = function (msg) {
        Human.log.warn(this.procName, msg);
    };

    /**
     * Logs an error in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.error = function (msg) {
        Human.log.error(this.procName, msg);
    };

    /**
     * Registers a procedure, which may then be called with {@link #call}.
     *
     * @param {string} procName Procedure name
     * @param {function} proc The procedure
     */
    rpc.define = function (procName, proc, params) {
        if (rpc._procedures[procName]) {
            Human.log.warn("Human.rpc.define", "Redefining procedure: " + procName);
        }

        params = params || {};

        if (params.hidden || globalHideDefinitions) {
            hiddenProcedures[procName] = true;
        }

        rpc._procedures[procName] = function (callId, params) {
            proc.call(new Scope(procName, callId), params || {});
        };
    };

    rpc.defineEvent = function(rpcEventName, params) {

        if (rpc._eventMap[rpcEventName]) {
            Human.log.warn("Human.rpc.defineEvent", "Redefining event: " + rpcEventName);
        }

        rpc._eventMap[rpcEventName] = params || rpcEventName;
    };

    rpc.enableEvent = function(scope, rpcEventName, once) {

        if (!rpc._eventMap[rpcEventName]) {
            Human.log.warn("Human.rpc.enableEvent", "Event: " + rpcEventName + " not defined.");
            return;
        }

        var params = rpc._eventMap[rpcEventName];

        if (typeof params === "string") {
            var eventFn = once ? "once" : "on";

            Human.events[eventFn](params, function(event) {
                scope.setResult(event);
            });
        } else {
            mapEvents(scope, params, once);
        }

    };

    function mapEvents(scope, params, once) {

        var triggered = false;

        var eventFn = once ? "once" : "on";

        var eventNames = params.events;
        var mapFn = params.map;

        if (params.init) {
            params.init();
        }

        function callback(event) {
            if (once && triggered) {
                return;
            }

            triggered = true;

            var result = mapFn ? mapFn(event) : event;

            if (result !== null) {
                scope.setResult(result || {});
            }

        }

        for (var i = 0, len = eventNames.length; i < len; i++) {

            Human.events[eventFn](eventNames[i], callback);

        }
    }

    // Get names of all available, public procedures
    rpc.getProcedures = function() {
        var procNames = Object.keys(rpc._procedures);

        Human.utils.filterInPlace(procNames, function(name) {
            return !hiddenProcedures[name];
        });

        return procNames;
    };

    // Get names of all available events
    rpc.getEvents = function() {
        return ["human.ready"].concat(Object.keys(rpc._eventMap));
    };

    // RPC procedures created in the callback function
    // will be considered hidden.
    rpc.hideDefinitions = function(fn) {
        globalHideDefinitions = true;

        try {
            fn();
        } finally {
            globalHideDefinitions = false;
        }
    };

    /**
     * Subscribes to results of subsequent RPC calls.
     *
     * <p>Each time a procedure returns a result, the given callback will be fired
     * with the the ID of the procedure call and the value that was returned.</p>
     *
     * <pre>
     *     #onResult(function(callId, value) {
     *         //..
     *     });
     *
     * @param {function(callId, value)} callback The callback
     * @function
     * @name onResult
     * @memberof Human.rpc
     */
    rpc.onResult = function (callback) {
        resultCallbacks.push(callback);
    };


    rpc.call = function (callId, procName, params) {
        var proc = rpc._procedures[procName];
        if (!proc) {
            Human.log.warn("Human.rpc.call", "Target procedure not found: " + procName);
            return;
        }

        proc(callId, params);
    };

    rpc.log = function(procName) {
        if (log.length > MAX_LOG_SIZE) {
            log.shift();
        }

        log.push({
            "engine_version": Human.VERSION,
            "api_version": Human.API_VERSION,
            "identifier": procName,
            "category": procName.split(".")[0]
        });
    };

    rpc.getLog = function() {
        return log;
    };

    rpc.logPending = function() {
        return log.length > 0;
    };

    rpc.resetLog = function() {
        log.length = 0;
    };

    rpc.filterUnsafeProperties = function(obj) {
        if (!Human.utils.isObject(obj)) {
            return obj;
        }

        var clean = {};

        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (isSafe(obj[key])) {
                    clean[key] = obj[key];
                }
            }
        }

        return clean;
    };

    function isSafe(obj) {
        if (!obj || typeof obj !== "object") {
            return true;
        }

        // Window
        if (obj === window) {
            return false;
        }

        // Dom Element
        if (typeof obj.nodeName === "string" && typeof obj.querySelectorAll === "function" && typeof obj.getElementsByTagName === "function") {
            return false;
        }

        // Event
        if (typeof obj.preventDefault === "function" && typeof obj.stopPropagation === "function") {
            return false;
        }

        return true;
    }

})();
;/**
 * This is the global Human namespace, used primarly to get system or API
 * info.
 *
 * @namespace human
 */

(function () {
    "use strict";

    /**
     * @memberof human
     * @callback HumanInfoCallback
     * @param {object} params
     * @param {string} params.version - Human version number
     * @param {object} params.webglInfo - Client WebGL capabilities
     * @param {array} params.apiFunctions - Available API functions
     * @param {array} params.apiEvents - Available API events
     *
     */

    /**
     * Query human info
     *
     * @apimethod human.send
     * @function info
     * @memberof human
     *
     * @param {human.HumanInfoCallback} callback
     *
     * @example <caption>Get Human API info</caption> <codepen>http://codepen.io/biodigital/pen/d3ea3aed40f2b829b405ad2c6b5ae6a0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.send("human.info", function(human) {
     *     console.log("Gathering human info:");
     *     console.log(JSON.stringify(human));
     * });
     */
    Human.rpc.define("human.info", function () {
        this.setResult({
            version: Human.VERSION,
            webglInfo: SceneJS.WEBGL_INFO,
            apiFunctions: Human.rpc.getProcedures().sort(),
            apiEvents: Human.rpc.getEvents().sort(),
        });
    });

    Human.rpc.defineEvent("human.error", "error");

    // Events

    /**
     * Fired when the Human has loaded and is ready to respond to the API
     *
     * @event human.ready
     * @apimethod human.on
     * @memberof human
     *
     * @example <caption>Human ready event</caption> <codepen>http://codepen.io/biodigital/pen/df05be58332b56811acb9adaa39e4b03</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Listening for human.ready event");
     *
     * human.on("human.ready", function() {
     *     console.log("Human loaded!");
     * });
     */

})();
;/**
 * Annotations are custom labels that you can pin to the Human anatomy to
 * add descriptive text or bring attention to areas of interest. Each
 * annotation is defined by its 3D position, the object it's attached to,
 * summary text (the title), and optionally, longer descriptive text
 * (the description).
 *
 * @namespace annotations
 */
(function() {
    "use strict";

    /**
     * @memberof annotations
     * @callback AnnotationInfoCallback
     * @param {object} annotationList - A map of annotations IDs to annotation info
     *
     * @param {string} annotationList[].annotationId
     * @param {string} annotationList[].objectId - Id of the object this annotation is attached to
     * @param {string} annotationList[].title - Annotation title text
     * @param {string} annotationList[].description - Annotation description text
     * @param {array} annotationList[].position - Annotation's 3D position
     * @param {array} annotationList[].canvasPosition - Annotation's position on the canvas
     * @param {boolean} annotationList[].shown - Is the annotation currently visible?
     * @param {boolean} annotationList[].occludable - Can the annotation be hidden by objects in the scene
     *
     */

    /**
     * Get annotation Info
     *
     * @apimethod human.send
     * @function annotations.info
     *
     * @param {AnnotationInfoCallback} callback
     *
     * @example <caption>Get annotation info</caption> <codepen>http://codepen.io/biodigital/pen/82019c254ffbc102291e383336d9215b</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Annother annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * human.send("annotations.info", function(annotations) {
     *     console.log("Gathering annotation info:");
     *     console.log(JSON.stringify(annotations));
     * });
     */
    Human.rpc.define("annotations.info",
        function () {
            var annotations = Human.view.annotations.annotations;
            var result = {};
            var annotation;

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    result[annotationId] = getAnnotationResult(annotation);
                }
            }

            this.setResult(result);
        });

    /**
     * Create an annotation
     *
     * @apimethod human.send
     * @function create
     * @memberof annotations
     *
     * @fires annotations.created
     *
     * @param {object} params
     * @param {string} [params.annotationId] - ID to assign to the annotation, generated internally if omitted
     * @param {string} [params.title] - Annotation title text
     * @param {string} [params.description] - Annotation description text
     * @param {boolean} [params.shown=true] - Should this annotation be shown initially?
     * @param {boolean} [params.occludable=true] - Can the annotation be hidden by objects in the scene?
     * @param {string} [params.objectId] - ID of an object to attach to
     * @param {array} [params.position] - Position of the annotation pin in 3D space
     * @param {array} [params.labelOffset] - X and Y offsets of the label's position from the pin's
     *
     * @param {function} [callback]
     * @param {object} callback.annotation - The new annotation, or null if an error occurred
     *
     * @example <caption>Create an annotation</caption><codepen>http://codepen.io/biodigital/pen/93e75938ed8e2e662baeba55a885fd94</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotation attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID"
     * });
     */
    Human.rpc.define("annotations.create", function (params) {
        // Default to saving annotation when created via API
        params.saved = params.saved !== false;

        if (params.position) {
            params.pos = params.position;
        }

        var annotation = Human.view.annotations.createAnnotation(params);

        this.setResult(getAnnotationResult(annotation));
    });

    /**
     * Update an annotation
     *
     * @apimethod human.send
     * @function update
     * @memberof annotations
     *
     * @param {object} params
     * @param {string} params.annotationId - ID of the annotation to update
     * @param {string} [params.title] - New annotation title text
     * @param {string} [params.description] - New annotation description text
     *
     * @example <caption>Update annotations</caption> <codepen>http://codepen.io/biodigital/pen/2d6a49383f0194dd97291ce48ab07849</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotation attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     *
     *     // Provide annotation ID (must be unique!) so we can
     *     // refer to this annotation later.
     *     annotationId: "myAnnotationId"
     * });
     *
     * human.on("human.ready", function () {
     *     console.log("Updating annotation in 2s");
     *
     *     setTimeout(function() {
     *
     *         // Update annotation title and description using the
     *         // annotation ID we provided on creation.
     *         human.send("annotations.update", {
     *             annotationId: "myAnnotationId",
     *             title: "My updated annotation",
     *             description: "This annotation was created and updated via the API."
     *         });
     *
     *         console.log("Annotation updated");
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("annotations.update", function (params) {
        Human.view.annotations.updateAnnotation(params.annotationId, params);
        this.setResult(true);
    });

    /**
     * Show all annotations
     *
     * @apimethod human.send
     * @function show
     * @memberof annotations
     *
     * @fires annotations.shown
     *
     * @example <caption>Show and hide annotations</caption> <codepen>http://codepen.io/biodigital/pen/bbd8fca7fe2a6514374c23612b5e4bd0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Another annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * var shown = true;
     *
     * setInterval(function() {
     *     shown = !shown;
     *
     *     if (shown) {
     *         console.log("Show annotations")
     *         human.send("annotations.show");
     *     } else {
     *         console.log("Hide annotations")
     *         human.send("annotations.hide");
     *     }
     *
     * }, 2000);
     *
     */
    Human.rpc.define("annotations.show", function () {
        Human.view.annotations.setShown(true);
        this.setResult(true);
    });

    /**
     * Hide all annotations
     *
     * @apimethod human.send
     * @function hide
     * @memberof annotations
     *
     * @fires annotations.hidden
     *
     * @example <caption>Show and hide annotations</caption> <codepen>http://codepen.io/biodigital/pen/bbd8fca7fe2a6514374c23612b5e4bd0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Annother annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * var shown = true;
     *
     * setInterval(function() {
     *     shown = !shown;
     *
     *     if (shown) {
     *         console.log("Show annotations")
     *         human.send("annotations.show");
     *     } else {
     *         console.log("Hide annotations")
     *         human.send("annotations.hide");
     *     }
     *
     * }, 2000);
     */
    Human.rpc.define("annotations.hide", function () {
        Human.view.annotations.setShown(false);
        this.setResult(true);
    });

    /**
     * Destroy an annotation
     *
     * @apimethod human.send
     * @function destroy
     * @memberof annotations
     *
     * @fires annotations.destroyed
     *
     * @param {string} annotationId - ID of the annotation to destroy
     *
     * @example <caption>Destroy an annotation</caption> <codepen>http://codepen.io/biodigital/pen/aacf76b1dddd4aa9b628f15c75c5b86f</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotation attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     *
     *     // Provide annotation ID (must be unique!) so we can
     *     // refer to this annotation later.
     *     annotationId: "myAnnotationId"
     * });
     *
     * human.on("human.ready", function() {
     *     console.log("Destroying annotation in 2s");
     *
     *     setTimeout(function() {
     *
     *         // Destroy annotation using the annotation ID we provided
     *         // on creation.
     *         human.send("annotations.destroy", "myAnnotationId");
     *         console.log("Annotation destroyed");
     *     }, 2000);
     * });
     */
    Human.rpc.define("annotations.destroy", function (params) {
        if (typeof params === "string") {
            params = {
                annotationId: params
            };
        }
        var annotation = Human.view.annotations.annotations[params.annotationId];
        if (annotation) {
            annotation.destroy();
        }
        this.setResult(true);
    });




    // Events

    /**
     * @event
     * @name created
     * @apimethod human.on
     * @memberof annotations
     * @param {object} event
     * @param {string} event.annotationId
     * @param {string} event.objectId - Id of the object this annotation is attached to
     * @param {string} event.title - Annotation title text
     * @param {string} event.description - Annotation description text
     * @param {array} event.position - Annotation's 3D position
     * @param {array} event.canvasPosition - Annotation's position on the canvas
     * @param {boolean} event.shown - Is the annotation currently visible?
     * @param {boolean} event.occludable - Can the annotation be hidden by objects in the scene
     *
     * @example <caption>Created event</caption> <codepen>http://codepen.io/biodigital/pen/a1a13ec4bda1c3714d48db502c9f1534</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("annotations.created", function (event) {
     *     console.log("Annotation created!");
     *     console.log("annotations.created event info: " + JSON.stringify(event));
     * });
     *
     * console.log("Listening for annotations.created event");
     *
     * human.on("human.ready", function() {
     *     setTimeout(function() {
     *
     *         human.send("annotations.create", {
     *             title: "My annotation",
     *             description: "This annotation was created via the API.",
     *             objectId: "maleAdult_standard-Frontal_bone_52734_ID"
     *         });
     *
     *     }, 2000);
     * });
     */
    Human.rpc.defineEvent("annotations.created", {
        events: ["annotations.created"],
        map: getAnnotationResult
    });

    /**
     * @event annotations.destroyed
     * @apimethod human.on
     * @memberof annotations
     * @param {object} event
     * @param {string} event.annotationId
     *
     * @example <caption>Destroyed event</caption> <codepen>http://codepen.io/biodigital/pen/9c290307f91a098ed4f57e0c7c578c61</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("annotations.destroyed", function (event) {
     *     console.log("Annotation destroyed!");
     *     console.log("annotations.destroyed event info: " + JSON.stringify(event));
     * });
     *
     * // Create annotation attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     *
     *     // Provide annotation ID (must be unique!) so we can
     *     // refer to this annotation later.
     *     annotationId: "myAnnotationId"
     * });
     *
     * console.log("Listening for annotations.destroyed event");
     *
     * human.on("human.ready", function() {
     *     setTimeout(function() {
     *
     *         human.send("annotations.destroy", "myAnnotationId");
     *
     *     }, 2000);
     * });
     */
    Human.rpc.defineEvent("annotations.destroyed");

    /**
     * @event annotations.shown
     * @apimethod human.on
     * @memberof annotations
     *
     * @example <caption>Shown/hidden events</caption> <codepen>http://codepen.io/biodigital/pen/2032fc8bb50a363f7bb8bee19570d43f</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Annother annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * console.log("Listening for annotation shown and hidden events.")
     *
     * human.on("annotations.shown", function () {
     *     console.log("Annotations shown!");
     * });
     *
     * human.on("annotations.hidden", function () {
     *     console.log("Annotations hidden!");
     * });
     *
     * var shown = true;
     *
     * setInterval(function() {
     *     shown = !shown;
     *
     *     if (shown) {
     *         human.send("annotations.show");
     *     } else {
     *         human.send("annotations.hide");
     *     }
     *
     * }, 2000);
     */
    Human.rpc.defineEvent("annotations.shown", {
        events: ["annotations.shown"],
        map: function(event) {
            if (!event.shown) {
                return null;
            }
        }
    });

    /**
     * @event annotations.hidden
     * @apimethod human.on
     * @memberof annotations
     *
     * @example <caption>Shown/hidden events</caption> <codepen>http://codepen.io/biodigital/pen/2032fc8bb50a363f7bb8bee19570d43f</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Annother annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * console.log("Listening for annotation shown and hidden events.")
     *
     * human.on("annotations.shown", function () {
     *     console.log("Annotations shown!");
     * });
     *
     * human.on("annotations.hidden", function () {
     *     console.log("Annotations hidden!");
     * });
     *
     * var shown = true;
     *
     * setInterval(function() {
     *     shown = !shown;
     *
     *     if (shown) {
     *         human.send("annotations.show");
     *     } else {
     *         human.send("annotations.hide");
     *     }
     *
     * }, 2000);
     */
    Human.rpc.defineEvent("annotations.hidden", {
        events: ["annotations.shown"],
        map: function(event) {
            if (event.shown) {
                return null;
            }
        }
    });

    function getAnnotationResult(annotation) {
        annotation = Human.view.annotations.annotations[annotation.annotationId];

        var pin = annotation.pin;

        if (!pin.canvasPos) {
            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();
            var canvas = document.getElementById("annotationCanvas");

            pin.transform(viewMat, projMat, canvas);
        }

        return {
            annotationId: annotation.annotationId,
            title: annotation.label.title,
            description: annotation.label.description,
            objectId: annotation.object ? annotation.object.objectId : null,
            position: {
                x: pin.pos[0],
                y: pin.pos[1],
                z: pin.pos[2]
            },
            canvasPosition: {
                x: pin.canvasPos[0],
                y: pin.canvasPos[1]
            },
            occludable: annotation.occludable,
            shown: annotation.pin.shown
        };

    }
})();
;/**
 * The camera is your point of view into the 3D anatomy scene. It
 * is defined by its position in 3D space and the 3D point it's aimed at
 * (the target). Optionally, you can also set an "up" direction for the
 * camera, which allows you to get rotated or upside-down views of the
 * anatomy.
 *
 * @namespace camera
 */
(function() {
    "use strict";

    /**
     * @memberof camera
     * @callback CameraInfoCallback
     * @param {object} camera
     * @param {object} [camera.position] - Camera position in 3D space
     * @param {number} [camera.position.x]
     * @param {number} [camera.position.y]
     * @param {number} [camera.position.z]
     * @param {object} [camera.target] - 3D position the camera is focused on
     * @param {number} [camera.target.x]
     * @param {number} [camera.target.y]
     * @param {number} [camera.target.z]
     * @param {object} [camera.up] - Vector indicating which way is up for the camera
     * @param {number} [camera.up.x]
     * @param {number} [camera.up.y]
     * @param {number} [camera.up.z]
     * @param {number} camera.zoom - Camera zooming factor
     *
     */

    /**
     * Update camera location
     *
     * @apimethod human.send
     * @function set
     * @memberof camera
     *
     * @fires camera.updated
     *
     * @param {object} params
     * @param {string} [params.objectId] - ID of an object to focus on
     * @param {object} [params.position] - Camera position in 3D space
     * @param {number} [params.position.x]
     * @param {number} [params.position.y]
     * @param {number} [params.position.z]
     * @param {object} [params.target] - 3D position the camera should focus on
     * @param {number} [params.target.x]
     * @param {number} [params.target.y]
     * @param {number} [params.target.z]
     * @param {object} [params.up] - Vector indicating which way is up for the camera
     * @param {number} [params.up.x]
     * @param {number} [params.up.y]
     * @param {number} [params.up.z]
     * @param {boolean} [params.animate=false] - Animate camera's movement to new location
     * @param {string} [params.animationStyle="around"] - Animation can be straight to new position ("direct") or around objects in the scene ("around")
     * @param {function} [callback]
     *
     * @example <caption>Set camera position</caption> <codepen>http://codepen.io/biodigital/pen/daa6398b1a6b9aa6d18afe06eab5d5b4</codepen>
     * human.send("camera.set", {
     *     position: {
     *         x: 20,
     *         y: 40,
     *         z: 0
     *     }
     * });
     *
     * @example <caption>Set camera target</caption> <codepen>http://codepen.io/biodigital/pen/bf3783911239a812253a19e8e0b4f567</codepen>
     * human.send("camera.set", {
     *     target: {
     *         x: 3,
     *         y: 23,
     *         z: 0
     *     }
     * });
     *
     * @example <caption>Animate camera target</caption> <codepen>http://codepen.io/biodigital/pen/f11d3263bd4b411af27f7aa242c8199d</codepen>
     * human.send("camera.set", {
     *     target: {
     *         x: 3,
     *         y: 23,
     *         z: 0
     *     },
     *     animate: true
     * }, function() {
     *     console.log("Camera update complete");
     * });
     *
     * @example <caption>Animate camera position</caption> <codepen>http://codepen.io/biodigital/pen/1aef21b044d3f266082167805d61469f</codepen>
     * human.send("camera.set", {
     *     position: {
     *         x: 20,
     *         y: 40,
     *         z: 0
     *     },
     *     animate: true
     * }, function() {
     *     console.log("Camera update complete");
     * });
     */
    Human.rpc.define("camera.set", function (params) {
        var self = this;

        if (params.position) {
            params.eye = params.position;
        }

        if (params.target) {
            params.look = params.target;
        }

        if (params.animationStyle === "direct") {
            params.cylindricalView = false;
        }

        if (params.animate) {
            Human.view.camera.fly.flyTo(params,
                function () {
                    self.setResult(true);
                });
        } else {
            Human.view.camera.fly.jumpTo(params,
                function () {
                    self.setResult(true);
                });
        }

    });

    /**
     * Orbit around camera's current point of focus
     *
     * @apimethod human.send
     * @function orbit
     * @memberof camera
     *
     * @param {object} params
     * @param {number} [params.yaw]
     * @param {number} [params.pitch]
     *
     * @param {function} [callback]
     *
     * @example <caption>Orbit the camera</caption> <codepen>http://codepen.io/biodigital/pen/5bb309c23d8c0f84b39916ece2c397ef</codepen>
     * (function update() {
     *     // Orbit camera horizontally around target
     *     human.send("camera.orbit", {
     *         yaw: 0.2
     *     });
     *     requestAnimationFrame(update);
     * })();
     */
    Human.rpc.define("camera.orbit", function (params) {
        if (params.yaw) {
            Human.view.camera.rotateY(params.yaw);
        }
        if (params.pitch) {
            Human.view.camera.rotateX(params.pitch);
        }
        this.setResult(true);
    });


    /**
     * Pan camera to new position
     *
     * @apimethod human.send
     * @function pan
     * @memberof camera
     *
     * @param {object} params
     * @param {number} [params.x]
     * @param {number} [params.y]
     * @param {number} [params.z]
     *
     * @param {function} [callback]
     *
     * @example <caption>Pan the camera</caption> <codepen>http://codepen.io/biodigital/pen/e90560867be3fd3790cae2dfdf8a1ffe</codepen>
     * var MAX_PAN = 10;
     * var currentPan = 0;
     * var velocity = 0.1;
     *
     * (function update() {
     *     // Pan camera to the left or right
     *     human.send("camera.pan", {
     *         x: velocity
     *     });
     *
     *     currentPan += velocity;
     *     // Switch directions if outside range
     *     if (Math.abs(currentPan) > MAX_PAN) {
     *         velocity *= -1;
     *     }
     *     requestAnimationFrame(update);
     * })();
     */
    Human.rpc.define("camera.pan", function (params) {
        Human.view.camera.pan({
            x: params.x || 0,
            y: params.y || 0,
            z: params.z || 0
        });
        this.setResult(true);
    });

    /**
     * Zoom the camera in or out of its point of focus
     *
     * @apimethod human.send
     * @function zoom
     * @memberof camera
     *
     * @param {number} zoom - zoom factor, between 0 and 1
     * @param {function} [callback]
     *
     * @example <caption>Zoom the camera</caption> <codepen>http://codepen.io/biodigital/pen/1d49b190475ef182628c5f202c457b1b</codepen>
     * var currentZoom = 0.5;
     * var increment = 0.001;
     *
     * (function update() {
     *
     *     // Zoom camera in and out
     *     human.send("camera.zoom", currentZoom);
     *     currentZoom += increment;
     *
     *     // Switch directions if outside range (zoom range is 0..1)
     *     if (currentZoom > 0.9 || currentZoom < 0) {
     *         increment *= -1;
     *     }
     *     requestAnimationFrame(update);
     * })();
     */
    Human.rpc.define("camera.zoom", function (zoom) {
        var factor = typeof zoom === "number" ? zoom : zoom.factor;

        factor = Math.max(0, Math.min(factor || 0, 1));

        Human.view.camera.setZoom(factor);

        this.setResult(true);
    });

    /* NOTE: CURRENTLY UNDOCUMENTED
     * Camera path animation
     *
     * @apimethod human.send
     * @function path
     * @memberof camera
     *
     * @param {object} params
     * @param {object[]} params.points
     *
     * @param {object} params.points[].position - Camera position (eye)
     * @param {number} params.points[].position.x
     * @param {number} params.points[].position.y
     * @param {number} params.points[].position.z
     * @param {object} params.points[].target - Camera Target position (look at)
     * @param {number} params.points[].target.x
     * @param {number} params.points[].target.y
     * @param {number} params.points[].target.z
     * @param {object} [params.points[].up] - Camera Up Vector
     * @param {number} params.points[].up.x
     * @param {number} params.points[].up.y
     * @param {number} params.points[].up.z
     * @param {number} [params.velocity=1] - Camera velocity
     * @param {boolean} [params.constrainUp=false] - Fix camera up vector
     * @param {boolean} [params.easing=true] - Whether easeOut the animation
     *
     * @param {function} [callback]
     *
     * @example <caption>Define a camera path</caption> <codepen>http://codepen.io/biodigital/pen/88c88c62d9b9f4fd0a08209220cc8b7c</codepen>
     * // Get initial camera position
     * human.send("camera.info", function(info) {
     *
     * // Define camera path.
     * // Initial camera position is inserted into path
     * // to avoid an initial jump.
     * human.send("camera.path", {
     *     points: [
     *     {
     *         position: info.position,
     *         target: info.target,
     *         up: info.up
     *     },
     *     {
     *         position: {
     *             x: 7.2915048649119685,
     *             y: 26.166339470455814,
     *             z: -11.74759554602381
     *         },
     *         target: {
     *             x: -0.06749999523162842,
     *             y: 19.702000617980957,
     *             z: 0.15849995613098145
     *         },
     *         up: {
     *             y:1
     *         }
     *     },
     *     ...
     *     ],
     *     velocity: 0.1,
     *     easing: false,
     *     constrainUp: true
     * },
     * function() {
     *     console.log("Camera path animation complete!");
     * });
     */
    Human.rpc.define("camera.path", function (params) {
        var self = this;

        Human.view.camera.fly.flyAlongCurvePath(params,
            function () {
                self.setResult(true);
            });
    });

     /**
     * Get current camera information
     *
     * @apimethod human.send
     * @function info
     * @memberof camera
     *
     * @param {camera.CameraInfoCallback} callback
     *
     * @example <caption>Get camera info</caption> <codepen>http://codepen.io/biodigital/pen/f1659672f956bf2baec635994463b57d</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.console("camera.info", function(camera) {
     *     console.log("Gathering camera info:");
     *     console.log(JSON.stringify(camera));
     * });
     */
    Human.rpc.define("camera.info", function () {
        this.setResult(getCameraResult());
    });

    /**
     * Reset camera to original position
     *
     * @apimethod human.send
     * @function reset
     * @memberof camera
     *
     * @param {function} callback
     *
     * @example <caption>Reset camera</caption> <codepen>http://codepen.io/biodigital/pen/c25f90dab23d1cd3a87aca50745b9883</codepen>
     * human.send("camera.set", {
     *     position: {
     *         x: 20,
     *         y: 40,
     *         z: 0
     *     },
     *     animate: true
     * }, function() {
     *     console.log("Camera update complete");
     *     console.log("Resetting camera in 2s");
     *
     *     setTimeout(function() {
     *         // Return camera to original position
     *         human.send("camera.reset", function() {
     *             console.log("Camera reset complete");
     *         });
     *     }, 2000);
     * });
     */
    Human.rpc.define("camera.reset",
        function () {
            var self = this;
            Human.init.resetCamera(function () {
                self.setResult(true);
            });
        });

    // Events

    /**
     * @event camera.updated
     * @apimethod human.on
     * @memberof camera
     * @param {object} camera
     * @param {object} camera.position - Camera position in 3D space
     * @param {number} camera.position.x
     * @param {number} camera.position.y
     * @param {number} camera.position.z
     * @param {object} camera.target - 3D position the camera should focus on
     * @param {number} camera.target.x
     * @param {number} camera.target.y
     * @param {number} camera.target.z
     * @param {object} camera.up - Vector indicating which way is up for the camera
     * @param {number} camera.up.x
     * @param {number} camera.up.y
     * @param {number} camera.up.z
     * @param {number} camera.zoom - Camera zoom level
     *
     * @example <caption>Updated event</caption> <codepen>http://codepen.io/biodigital/pen/cf5cd1b2721a46903e814a76c7e7f725</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Listening for camera updated event");
     *
     * human.on("camera.updated", function(event) {
     *     console.log("Camera updated!");
     *     console.log("camera.updated event info: " + JSON.stringify(event));
     * });
     *
     * human.on("human.ready", function() {
     *     setTimeout(function() {
     *         human.send("camera.set", {
     *             position: {
     *                 x: 20,
     *                 y: 40,
     *                 z: 0
     *             },
     *             animate: true
     *         });
     *     }, 2000);
     * });
     */
    Human.rpc.defineEvent("camera.updated", {
        events: ["camera.rested"],
        map: getCameraResult
    });

    function getCameraResult() {
        var lookAt = Human.view.camera.getLookAt();

        return {
            position: lookAt.eye,
            target: lookAt.look,
            up: lookAt.up,
            zoom: Human.view.camera.getZoom()
        };
    }

})();
;/*
 * RPC procedures for subscription to engine events.
 *
 */

Human.rpc.hideDefinitions(function () {
    "use strict";

    Human.rpc.define("apiEvents.on", function (eventName) {
        Human.rpc.enableEvent(this, eventName, false);
    });

    Human.rpc.define("apiEvents.once", function (eventName) {
        Human.rpc.enableEvent(this, eventName, true);
    });

});
;/**
 * The input namespace defines messages that allow you to enable
 * or disable mouse and keyboard interaction with the Human scene.
 *
 * @namespace input
 */
(function() {
	"use strict";

	/**
     * Disable user input
     *
     * @apimethod human.send
     * @function disable
     * @memberof input
     *
	 * @example <caption>Enable/disable user input</caption> <codepen>http://codepen.io/biodigital/pen/67b7b6b1e689a745323efd14a464f590</codepen>
	 * // Initialize API
	 * var human = new HumanAPI("embeddedHuman");
	 *
	 * var enabled = true;
	 *
	 * setInterval(function() {
	 *     enabled = !enabled;
	 *
	 *     if (enabled) {
	 *         console.log("Input enabled (try clicking and dragging)")
	 *         human.send("input.enable");
	 *     } else {
	 *         console.log("Input disabled (try clicking and dragging)")
	 *         human.send("input.disable");
	 *     }
	 *
	 * }, 2000);
     */
	Human.rpc.define("input.disable",
	    function () {
	        Human.input.setEnabled(false);
	    });

	/**
     * Enable user input
     *
     * @apimethod human.send
     * @function enable
     * @memberof input
     *
	 * @example <caption>Enable/disable user input</caption> <codepen>http://codepen.io/biodigital/pen/67b7b6b1e689a745323efd14a464f590</codepen>
	 * // Initialize API
	 * var human = new HumanAPI("embeddedHuman");
	 *
	 * var enabled = true;
	 *
	 * setInterval(function() {
	 *     enabled = !enabled;
	 *
	 *     if (enabled) {
	 *         console.log("Input enabled (try clicking and dragging)")
	 *         human.send("input.enable");
	 *     } else {
	 *         console.log("Input disabled (try clicking and dragging)")
	 *         human.send("input.disable");
	 *     }
	 *
	 * }, 2000);
     */
	Human.rpc.define("input.enable",
	    function () {
	        Human.input.setEnabled(true);
	    });


})();
;/**
 * The scene is the collection of 3D objects currently being rendered. Scene messages allow
 * you to control what scenes are loaded, how they're rendered and to gather information
 * about what's currently in the scene.
 *
 * @namespace scene
 */
(function() {
    "use strict";

    /**
     * @memberof scene
     * @callback PickInfoCallback
     * @property {object} pick
     * @property {string} pick.objectId - ID of the object that was picked
     * @property {object} pick.canvasPosition - 2D coordinates of the pick location on the canvas
     * @property {number} pick.canvasPosition.x
     * @property {number} pick.canvasPosition.y
     * @property {object} pick.position - 3D coordinates of the pick location in the scene
     * @property {number} pick.position.x
     * @property {number} pick.position.y
     * @property {number} pick.position.z
     *
     */

     /**
      * Load new content into the scene. This can be either a module (core
      * content created by BioDigital), or bookmark
      *
      * @apimethod HumanAPI.call
      * @function load
      * @memberof scene
      *
      * @fires scene.picked
      *
      * @param {string} [id] - ID of the module or bookmark to load
      * @param {scene.PickInfoCallback} callback
      *
      * @example <caption>Load a scene programmatically</caption> <codepen>http://codepen.io/biodigital/pen/643226c9138ca64ebca9db497d8cd70d</codepen>
      * var sceneState;
      *
      * // Initialize API
      * var human = new HumanAPI("embeddedHuman");
      *
      * var sceneIds = ["production/maleAdult/heart.json", "production/maleAdult/artery.json", "1FAM", "1FAQ"];
      * var i = 0;
      *
      * console.log("Loading scenes programmatically");
      *
      * (function loadScene() {
      *     console.log("Loading scene ID: " + sceneIds[i]);
      *
      *     human.send("scene.load", sceneIds[i], function() {
      *         i = (i + 1) % sceneIds.length;
      *
      *         setTimeout(loadScene, 5000);
      *     });
      * })();
      */
     Human.rpc.define("scene.load",
         function (params) {
            var self = this;

            var bookmarkId = null;
            var moduleId = null;

            if (typeof params === "string") {
                if (params.slice(-5) === ".json") {
                    moduleId = params;
                } else {
                    bookmarkId = params;
                }
            } else {
                moduleId = params.moduleId;
                bookmarkId = params.bookmarkId;
            }


            Human.modules.destroyModules();

            if (bookmarkId) {
                jQuery.ajax({
                    dataType: "json",
                    url: "/search/bookmarks/data?be=" + bookmarkId,
                    success: function (index) {
                        Human.bookmarks.restore(index.bookmark, function() {
                            self.setResult(true);
                        });
                    },
                    error: function() {
                        self.setResult(false);
                    }
                });

            } else if (moduleId) {

                Human.modules.activateModuleWithAssets(moduleId,
                    function() {
                        self.setResult(true);
                    },
                    function() {
                        self.setResult(false);
                    });

            }

        });

    /**
     * Get info about the 3D scene at a given canvas location. Optionally, trigger
     * actions associated with the current pick mode
     *
     * @apimethod human.send
     * @function pick
     * @memberof scene
     *
     * @fires scene.picked
     *
     * @param {object} params
     * @param {number} params.x - Canvas X-coordinate
     * @param {number} params.y - Canvas Y-coordinate
     * @param {booleans} [params.triggerActions=false] - Trigger pick actions
     * @param {scene.PickInfoCallback} callback
     *
     * @example <caption>Programmatic picking</caption> <codepen>http://codepen.io/biodigital/pen/32ebcd4698b19d9d059462ba2f52691e</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var iframe = document.getElementById("embeddedHuman");
     *
     * var w = iframe.clientWidth;
     * var h = iframe.clientHeight;
     *
     * setInterval(function () {
     *     var canvasX = Math.round(Math.random() * 300 - 150 + w / 2);
     *     var canvasY = Math.round(Math.random() * 300 - 150 + h / 2);
     *
     *     console.log("Try pick at " + canvasX + ", " + canvasY);
     *     human.send("scene.pick", { x: canvasX, y: canvasY },
     *         function (hit) {
     *             if (hit) {
     *                 console.log("Hit: " + JSON.stringify(hit));
     *             } else {
     *                 console.log("Miss");
     *             }
     *         });
     * }, 2000);
     */
    Human.rpc.define("scene.pick",
        function (params) {
            var result;

            if (params.x !== undefined) {
                params.canvasX = params.x;
            }

            if (params.y !== undefined) {
                params.canvasY = params.y;
            }

            params.rayPick = params.rayPick !== false;

            if (params.triggerActions) {
                result = Human.view.pick.pick(params);
            } else {
                result = Human.view.pick.queryPick(params);
            }
            this.setResult(getPickResult(result));
        });

    /**
     * Set action to be triggered when an object is picked
     *
     * @apimethod human.send
     * @function pickingMode
     * @memberof scene
     *
     * @param {string} mode - Picking mode: "dissect" removes picked objects,
     * "highlight" highlights picked objects, "annotate" annotates picked objects
     *
     * @example <caption>Picking mode</caption> <codepen>http://codepen.io/biodigital/pen/17ae01cc6c14533f48c18a7e26fa4e15</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Alternating between highlight and dissect picking modes");
     *
     * var mode = "highlight";
     *
     * (function switchMode() {
     *     human.send("scene.pickingMode", mode);
     *
     *     mode = mode === "highlight" ? "dissect" : "highlight";
     *
     *     setTimeout(switchMode, 4000);
     * })();
     *
     * human.on("scene.pickingModeUpdated", function(event) {
     *     console.log("Enabling " + event.pickingMode + " mode. Click to " + event.pickingMode + " an object");
     * });
     */
    Human.rpc.define("scene.pickingMode",
        function (mode) {
            if (mode === "dissect") {
                Human.events.blockEvents(function() {
                    Human.view.annotations.setEnabled(false);
                });
                Human.view.dissect.setEnabled(true);
            } else if (mode === "annotate") {
                Human.events.blockEvents(function() {
                    Human.view.dissect.setEnabled(false);
                });
                Human.view.annotations.setEnabled(true);
            } else if (mode === "highlight") {
                Human.events.blockEvents(function() {
                    Human.view.dissect.setEnabled(false);
                    Human.view.annotations.setEnabled(false);
                });
                Human.view.highlight.setEnabled(true);
            }

            this.setResult(true);
        });

    /**
     * Set behavior of selected objects
     *
     * @apimethod human.send
     * @function selectionMode
     * @memberof scene
     *
     * @fires scene.selectionModeUpdated
     *
     * @param {string} mode - Selection mode: "isolate" hides all unselected object,
     * "highlight" highlights selected objects, "none" does nothing
     *
     * @example <caption>Selection mode</caption> <codepen>http://codepen.io/biodigital/pen/6db6bbd189097f63aeec640a165e45ff</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Switch between highlight and isolate selection modes");
     *
     * // These commands will be buffered before Human is loaded
     * human.send("scene.selectObjects", {
     *     "maleAdult_standard-Left_Craniofacial_Bones_ID": true
     * });
     *
     * var mode = "highlight";
     * var select = true;
     *
     * (function switchMode() {
     *     human.send("scene.selectionMode", mode);
     *
     *     mode = mode === "highlight" ? "isolate" : "highlight";
     *
     *     setTimeout(switchMode, 6000);
     * })();
     *
     * (function toggleSelect() {
     *     console.log("Change selected object")
     *     human.send("scene.selectObjects", {
     *         "maleAdult_standard-Left_Craniofacial_Bones_ID": select,
     *         "maleAdult_standard-Right_Craniofacial_Bones_ID": !select
     *     });
     *
     *     select = !select;
     *
     *     setTimeout(toggleSelect, 2000);
     * })();
     *
     * human.on("scene.selectionModeUpdated", function(event) {
     *     console.log("Enabling " + event.selectionMode + " mode. Will " + event.selectionMode + " selected objects");
     * });
     */
    Human.rpc.define("scene.selectionMode",
        function (mode) {
            if (mode === "isolate") {
                Human.events.blockEvents(function() {
                    Human.view.highlight.setEnabled(false);
                });
                Human.view.isolate.setEnabled(true);
            } else if (mode === "highlight") {
                Human.events.blockEvents(function() {
                    Human.view.isolate.setEnabled(false);
                });
                Human.view.highlight.setEnabled(true);
            } else if (mode === "none") {
                Human.events.blockEvents(function() {
                    Human.view.isolate.setEnabled(false);
                });
                Human.view.highlight.setEnabled(false);
            }

            this.setResult(true);
        });

    /**
     * Enable xray mode (make all unselected objects transparent)
     *
     * @apimethod human.send
     * @function enableXray
     * @memberof scene
     *
     * @fires scene.xrayEnabled
     *
     * @param {function} [callback]
     */
    Human.rpc.define("scene.enableXray",
        function () {
            Human.view.xray.setEnabled(true);
            this.setResult(true);
        });

    /**
     * Disable xray mode (see {@link scene.enableXray})
     *
     * @apimethod human.send
     * @function disableXray
     * @memberof scene
     *
     * @fires scene.xrayDisabled
     *
     * @param {function} [callback]
     */
    Human.rpc.define("scene.disableXray",
        function () {
            Human.view.xray.setEnabled(false);
            this.setResult(true);
        });

    /**
     * Capture a JPEG snapshot of the current scene.
     *
     * @apimethod human.send
     * @function snapshot
     * @memberof scene
     *
     * @param {object} params
     * @param {number} [params.width] - Snapshot width
     * @param {number} [params.height] - Snapshot height
     * @param {function} callback - Callback function to receive the image
     *
     * @example <caption>Scene snapshot</caption> <codepen>http://codepen.io/biodigital/pen/8ab3a692daf7d086931c7ee8331e2c42</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function () {
     *     console.log("Capture image of scene in 2s");
     *     setTimeout(function(){
     *
     *         human.send("scene.snapshot", {
     *             openInTab: true
     *         }, function(img) {
     *             console.log("Snapshot captured");
     *         });
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("scene.snapshot",
        function (params) {
            var self = this;
            Human.view.snapshot.getSnapshot(params,
                function (image) {
                    self.setResult(image.src);
                });
        });

    function fmaIdsToObjectIds(map) {
        var result = {};
        var objectsByFMA = Human.rpc.fmaIds;
        var objectIds;
        var maleStateId = Human.modules.MALE_STATE_ID;
        var femaleStateId = Human.modules.FEMALE_STATE_ID;
        for (var fmaId in map) {
            if (map.hasOwnProperty(fmaId)) {
                objectIds = objectsByFMA[fmaId];
                for (var i = 0; i < objectIds.length; i++) {
                    var object = Human.scene.objects[maleStateId + "-" + objectIds[i]] ||
                        Human.scene.objects[femaleStateId + "-" + objectIds[i]];
                    if (object) {
                        result[object.objectId] = map[fmaId];
                    }
                }
            }
        }
        return result;
    }

    /**
     * Show or hide objects in the scene
     *
     * @apimethod human.send
     * @function showObjects
     * @memberof scene
     *
     * @fires scene.objectsShown
     *
     * @param {object} selectionMap - Map of object IDs or FMA IDs to true to show, false to hide
     * @param {boolean} selectionMap.replace=false - Hide any objects not shown in the current map
     *
     * @example <caption>Show objects</caption> <codepen>http://codepen.io/biodigital/pen/9da13866ed038955dab0738236201bf4</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var show = true;
     *
     * console.log("Intermittent showing and hiding of scene objects");
     *
     * (function toggleShow() {
     *     human.send("scene.showObjects", {
     *         "maleAdult_standard-Left_Craniofacial_Bones_ID": show,
     *         "maleAdult_standard-Right_Craniofacial_Bones_ID": !show
     *     });
     *
     *     show = !show;
     *
     *     setTimeout(toggleShow, 3000);
     * })();
     *
     * human.on("scene.objectsShown", function(event) {
     *     var shown = [];
     *     var hidden = [];
     *
     *     // Event contains a map of objects that were shown
     *     // or hidden by this update.
     *     Object.keys(event).forEach(function(objectId) {
     *         if (event[objectId]) {
     *             shown.push(objectId);
     *         } else {
     *             hidden.push(objectId);
     *         }
     *     });
     *
     *     console.log("Shown objects: " + shown.join(", "));
     *     console.log("Hidden objects: " + hidden.join(", "));
     * });
     */
    Human.rpc.define("scene.showObjects",
        function (params) {
            var replace = !!params.replace;
            delete params.replace;

            if (params.fmaIds) {
                params = fmaIdsToObjectIds(params.fmaIds);
            }

            Human.scene.setEnabledObjects({ objects: params, replace: replace });
            this.setResult(true);
        });

    /**
     * Select or deselect objects in the scene
     *
     * @apimethod human.send
     * @function selectObjects
     * @memberof scene
     *
     * @fires scene.objectsSelected
     *
     * @param {object} selectionMap - Map of object IDs or FMA IDs to true to select, false to deselect
     * @param {boolean} selectionMap.replace=false - Deselect any objects not selected in the current map
     *
     * @example <caption>Select object</caption> <codepen>http://codepen.io/biodigital/pen/905dc4a79f3a6102cf16f4d763763ee4</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var select = true;
     *
     * console.log("Intermittent switching of selected objects");
     *
     * (function toggleSelect() {
     *     human.send("scene.selectObjects", {
     *         "maleAdult_standard-Left_Craniofacial_Bones_ID": select,
     *         "maleAdult_standard-Right_Craniofacial_Bones_ID": !select
     *     });
     *
     *     select = !select;
     *
     *     setTimeout(toggleSelect, 3000);
     * })();
     *
     * human.on("scene.objectsSelected", function(event) {
     *     var selected = [];
     *     var deselected = [];
     *
     *     // Event contains a map of objects that were selected
     *     // or deselected by this update.
     *     Object.keys(event).forEach(function(objectId) {
     *         if (event[objectId]) {
     *             selected.push(objectId);
     *         } else {
     *             deselected.push(objectId);
     *         }
     *     });
     *
     *     console.log("Selected objects: " + selected.join(", "));
     *     console.log("Deslected objects: " + deselected.join(", "));
     * });
     */
    Human.rpc.define("scene.selectObjects",
        function (params) {
            var replace = !!params.replace;
            delete params.replace;

            if (params.fmaIds) {
                params = fmaIdsToObjectIds(params.fmaIds);
            }

            Human.scene.setSelectedObjects({ objects: params, replace: replace });
            this.setResult(true);
        });



    /**
     * @memberof scene
     * @callback SceneInfoCallback
     * @param {string} name - Name of the currently loaded scene
     * @param {object} objectMap - A map of object IDs to object info
     * @param {string} objectMap[].objectId
     * @param {string} objectMap[].name - Object name
     * @param {string} objectMap[].description - Object description
     * @param {boolean} objectMap[].shown - Is the object currently being shown?
     * @param {boolean} objectMap[].selected  - Is the object currently being shown?
     * @param {string} objectMap[].parent - parent objectId
     * @param {array} objectMap[].children - objectIds of children
     *
     */

    /**
     * Gather information about the objects in the scene
     *
     * @apimethod human.send
     * @function info
     * @memberof scene
     *
     * @param {scene.SceneInfoCallback} callback
     *
     * @example <caption>Scene info</caption> <codepen>http://codepen.io/biodigital/pen/499e3700dd02f7e134ce49e99b07b6f9</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.send("scene.info", function (data) {
     *     console.log(JSON.stringify(data));
     * });
     */
    (function () {
        Human.rpc.define("scene.info",
            function (params) {
                var result = {};

                var activeModule = Human.modules.activeModules[Object.keys(Human.modules.activeModules)[0]];

                result.name = activeModule ? activeModule.displayName : null;

                var scenegraph = result.objects = {};
                var object;
                if (params.objectId) {
                    var objectId = params.objectId;
                    object = Human.scene.objects[objectId];
                    if (object) {
                        scenegraph[object.objectId] = getObjectDescription(object);
                    }
                } else {
                    // Get parent objects before their children so that on the API side we
                    // will always create HumanAPI.Objects for the parents BEFORE those for
                    // their children, so that each child's HumanAPI.Object can be instantiated
                    // with a reference to its parent's HumanAPI.Object.
                    for (var i = 0, len = Human.scene.rootObjects.length; i < len; i++) {
                        buildHierarchy(Human.scene.rootObjects[i].getRenderableObjects(), scenegraph);
                    }

                }
                this.setResult(result);
            });

        function buildHierarchy(objects, result) {

            function gatherObject(o) {
                if (!result[o.objectId]) {
                    result[o.objectId] = getObjectDescription(o);
                }
            }

            for (var i = 0, len = objects.length; i < len; i++) {
                objects[i].traverseUp(gatherObject);
            }

        }

        function getObjectDescription(object) {
            var desc = {
                objectId: object.objectId,
                name: object.name,
                description: object.description || "",
                shown: object.shown,
                selected: object.selected
            };

            desc.children = [];

            for (var i = 0, len = object.objects.length; i < len; i++) {
                desc.children.push(object.objects[i].objectId);
            }

            desc.parent = object.parent ? object.parent.objectId : null;

            return desc;
        }
    })();


    /**
     * Transform object to new position or orientation
     *
     * @apimethod human.send
     * @function transformObject
     * @memberof scene
     *
     * @param {object} params
     * @param {string} params.objectId - ID of object to transform
     * @param {object} [params.translate] - Translation transform
     * @param {number} [params.translate.x] - Translation along x axis
     * @param {number} [params.translate.y] - Translation along y axis
     * @param {number} [params.translate.z] - Translation along z axis
     * @param {object} [params.rotate] - Rotation transform
     * @param {number} [params.rotate.x] - Rotation about x axis
     * @param {number} [params.rotate.y] - Rotation about y axis
     * @param {number} [params.rotate.z] - Rotation about z axis
     * @param {object} [params.scale] - Scaling transform
     * @param {number} [params.scale.x] - Scaling along x axis
     * @param {number} [params.scale.y] - Scaling along y axis
     * @param {number} [params.scale.z] - Scaling along z axis
     * @param {object} [params.pivot] - 3D origin point for the defined transform
     * @param {number} [params.pivot.x]
     * @param {number} [params.pivot.y]
     * @param {number} [params.pivot.z]
     *
     * @example <caption>Transform objects</caption> <codepen>http://codepen.io/biodigital/pen/5309a4a58e565315f25c18239b99f975</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var t = 0;
     * var inc = 0.01;
     *
     * console.log("Animating object position");
     *
     * (function animate() {
     *     t += inc;
     *
     *     if (t > 1) {
     *         t = 1;
     *         inc *= -1;
     *     }
     *
     *     if (t < 0) {
     *         t = 0;
     *         inc *= -1;
     *     }
     *
     *      human.send("scene.transformObject", {
     *         objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     *         translate: {x: -8 * t, y: 2 * t, z: -8 * t},
     *         rotate: { y: t * 90 }
     *     });
     *
     *     requestAnimationFrame(animate);
     * })();
     */
    Human.rpc.define("scene.transformObject",
        function (params) {
            var objectId = params.objectId;
            var object = Human.scene.objects[objectId];
            if (object) {
                object.setTransform(params);
                this.setResult(true);
            } else {
                this.error("Scene object not found: '" + objectId + "'");
                this.setResult(false);
            }
        });



    /**
     * @memberof scene
     * @callback SceneCaptureCallback
     * @param {object} sceneState - Captured scene state. Can be passed to {@link scene.restore}
     *
     */

    /**
     * Captures the current scene state
     *
     * @apimethod human.send
     * @function capture
     * @memberof scene
     *
     * @param {scene.SceneCaptureCallback} callback
     *
     * @example <caption>Scene capture and restore</caption> <codepen>http://codepen.io/biodigital/pen/baa38aa7bf10fc98ceb8c33ff075a6de</codepen>
     * var sceneState;
     *
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *
     *     console.log("Highlighting objects");
     *
     *     human.send("scene.selectObjects", {
     *         "maleAdult_standard-Right_Craniofacial_Bones_ID": true
     *     });
     *
     *     console.log("Setting camera");
     *
     *     human.send("camera.set", {
     *         position: {
     *             x: 20,
     *             y: 40,
     *             z: 0
     *         }
     *     }, function() {
     *         console.log("Capturing scene state");
     *
     *         // Capturing the scene state provides a JavaScript object
     *         // containing the data necessary to recreate the scene.
     *         // This object can be passed to "scene.restore" to re-create
     *         // the scene.
     *         human.send("scene.capture",
     *             function (scene) {
     *                 sceneState = scene;
     *             });
     *
     *         console.log("Resetting scene in 2s")
     *         setTimeout(function() {
     *             human.send("scene.reset");
     *
     *             console.log("Restoring scene state in 2s");
     *             setTimeout(function() {
     *
     *                 // Here, we pass the scene state object that
     *                 // was captured by "scene.capture" to "scene.restore"
     *                 // so it can restore the scene to the captured state.
     *                 human.send("scene.restore", sceneState);
     *
     *             }, 2000);
     *         }, 2000);
     *     });
     *
     * });
     *
     * // Fired whenever scene is restored to a captured state
     * human.on("scene.restored", function() {
     *     console.log("Scene restored!");
     * });
     */
    Human.rpc.define("scene.capture",
        function () {
            this.setResult(Human.bookmarks.capture());
        });

    /**
     * Restores scene state from description captured by {@link scene.capture}
     *
     * @apimethod human.send
     * @function restore
     * @memberof scene
     *
     * @fires scene.restored
     *
     * @param {object} sceneState - Scene state captured from {@link scene.capture}
     * @param {function} [callback]
     */
    Human.rpc.define("scene.restore",
        function (params) {
            var self = this;
            Human.bookmarks.restore(params, function () {
                self.setResult(true);
            });
        });

    /**
     * Reset the scene to its original state
     *
     * @apimethod human.send
     * @function reset
     * @memberof scene
     *
     * @param {function} [callback]
     *
     * @example <caption>Scene reset</caption> <codepen>http://codepen.io/biodigital/pen/401be856566cbf4824656102e666c213</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Setting camera")
     * human.send("camera.set", {
     *     position: {
     *         x: 20,
     *         y: 40,
     *         z: 0
     *     }
     * }, function() {
     *     console.log("Scene reset in 2s");
     *     setTimeout(function() {
     *         human.send("scene.reset");
     *     }, 2000);
     * });
     */
    Human.rpc.define("scene.reset",
        function () {
            var self = this;
            Human.init.reset(function () {
                    self.setResult(true);
                });
        });



    // Events

    /**
     * @event scene.objectsShown
     * @apimethod human.on
     * @memberof scene
     * @property {object} event - Map listing object IDs and whether they were shown or hidden
     */
    Human.rpc.defineEvent("scene.objectsShown", {
        events: ["scene.objectsShown"],
        map: function(event) {
            return event.enabledObjectsUpdate;
        }
    });

    /**
     * @event scene.objectsSelected
     * @apimethod human.on
     * @memberof scene
     * @property {object} event - Map listing object IDs and whether they were selected or deselected
     */
    Human.rpc.defineEvent("scene.objectsSelected", {
        events: ["scene.objectsSelected"],
        map: function(event) {
            return event.selectedObjectsUpdate;
        }
    });

    /**
     * @event scene.restored
     * @apimethod human.on
     * @memberof scene
     * @property {object} event - Scene state captured by {@link scene.capture}
     */
    Human.rpc.defineEvent("scene.restored", "bookmarks.restored");

    /**
     * @event scene.picked
     * @apimethod human.on
     * @memberof scene
     * @property {object} event
     * @property {string} event.objectId - ID of the object that was picked
     * @property {object} event.canvasPosition - 2D coordinates of the pick location on the canvas
     * @property {number} event.canvasPosition.x
     * @property {number} event.canvasPosition.y
     * @property {object} event.position - 3D coordinates of the pick location in the scene
     * @property {number} event.position.x
     * @property {number} event.position.y
     * @property {number} event.position.z
     *
     * @example <caption>Pick event</caption> <codepen>http://codepen.io/biodigital/pen/4f2da0e54e201754a0c0d9ef11d5a1cb</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Pick or hover over something!");
     * human.on("scene.picked",
     *     function (pickEvent) {
     *         console.log("'scene.picked' event: " + JSON.stringify(pickEvent));
     * });
     */
    Human.rpc.defineEvent("scene.picked", {
        events: ["pick.picked"],
        init: function() {
            // API expects to always get raypick results
            Human.properties.set({ "pick.alwaysRayPick": true });
        },
        map: getPickResult
    });

    /**
     * @event scene.pickingModeUpdated
     * @apimethod human.on
     * @memberof scene
     * @property {object} event
     * @property {string} event.pickingMode
     */
    var pickingMode;

    Human.rpc.defineEvent("scene.pickingModeUpdated", {
        events: ["highlight.toggled", "dissect.toggled", "annotations.toggled"],
        map: function () {
            var newPickingMode;

            if (Human.view.dissect.enabled) {
                newPickingMode = "dissect";
            } else if (Human.view.annotations.enabled) {
                newPickingMode = "annotate";
            } else if (Human.view.highlight.enabled) {
                newPickingMode = "highlight";
            }

            if (newPickingMode === pickingMode) {
                return null;
            }

            pickingMode = newPickingMode;

            return {
                pickingMode: pickingMode
            };
        }
    });

    /**
     * @event scene.selectionModeUpdated
     * @apimethod human.on
     * @memberof scene
     * @property {object} event
     * @property {string} event.selectionMode
     */
    var selectionMode;

    Human.rpc.defineEvent("scene.selectionModeUpdated", {
        events: ["highlight.toggled", "isolate.toggled"],
        map: function () {
            var newSelectionMode;

            if (Human.view.isolate.enabled) {
                newSelectionMode = "isolate";
            } else if (Human.view.highlight.enabled) {
                newSelectionMode = "highlight";
            } else {
                newSelectionMode = "none";
            }

            if (newSelectionMode === selectionMode) {
                return null;
            }

            selectionMode = newSelectionMode;

            return {
                selectionMode: selectionMode
            };
        }
    });

    /**
     * @event scene.xrayEnabled
     * @apimethod human.on
     * @memberof scene
     *
     * @example <caption>Enable xray</caption> <codepen>http://codepen.io/biodigital/pen/fe721c86655e2dfab0480670cdc63383</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var enable = true;
     *
     * human.on("scene.xrayEnabled", function() {
     *     console.log("Xray mode enabled");
     * });
     *
     * human.on("scene.xrayDisabled", function() {
     *     console.log("Xray mode disabled");
     * });
     *
     * human.on("human.ready", toggleXray);
     *
     * function toggleXray() {
     *     human.send(enable ? "scene.enableXray" : "scene.disableXray");
     *
     *     enable = !enable;
     *
     *     setTimeout(toggleXray, 3000);
     * }
     */
    Human.rpc.defineEvent("scene.xrayEnabled", {
        events: ["xray.toggled"],
        map: function(event) {
            if (!event.enabled) {
                return null;
            }
        }
    });

    /**
     * @event scene.xrayDisabled
     * @apimethod human.on
     * @memberof scene
     *
     * @example <caption>Enable xray</caption> <codepen>http://codepen.io/biodigital/pen/fe721c86655e2dfab0480670cdc63383</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var enable = true;
     *
     * human.on("scene.xrayEnabled", function() {
     *     console.log("Xray mode enabled");
     * });
     *
     * human.on("scene.xrayDisabled", function() {
     *     console.log("Xray mode disabled");
     * });
     *
     * human.on("human.ready", toggleXray);
     *
     * function toggleXray() {
     *     human.send(enable ? "scene.enableXray" : "scene.disableXray");
     *
     *     enable = !enable;
     *
     *     setTimeout(toggleXray, 3000);
     * }
     */
    Human.rpc.defineEvent("scene.xrayDisabled", {
        events: ["xray.toggled"],
        map: function(event) {
            if (event.enabled) {
                return null;
            }
        }
    });

    function getPickResult(hit) {
        if (!hit) {
            return null;
        }

        var result = {};

        result.objectId = hit.objectId;
        result.canvasPosition = {
            x: hit.canvasPos[0],
            y: hit.canvasPos[1]
        };

        if (hit.worldPos) {
            result.position = {
                x: hit.worldPos[0],
                y: hit.worldPos[1],
                z: hit.worldPos[2]
            };
        }

        return result;
    }


})();
;/**
 * The timeline is in charge of animation and tours in the Human. Timeline messages allow you
 * to fast-forward or rewind animations, or to jump back or ahead in the chapters of a tour.
 *
 * @namespace timeline
 */

(function() {
    "use strict";


    /**
     * @memberof timeline
     * @callback TimelineInfoCallback
     * @param {object} timeline
     * @param {array} timeline.chapters - IDs of the chapters currently on the timeline
     * @param {number} timeline.time - Current time on the timeline
     * @param {number} timeline.startTime - Starting time of the timeline
     * @param {number} timeline.endTime - Ending time of the timeline
     * @param {boolean} timeline.playing - Is the timeline currently playin?
     */

    /**
     * Gather information about the timeline
     *
     * @apimethod human.send
     * @function info
     * @memberof timeline
     *
     * @param {timeline.TimelineInfoCallback} callback
     *
     * @example <caption>Get timeline info</caption> <codepen>http://codepen.io/biodigital/pen/8698a3446b0ff14dd367063736158bd6</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.send("timeline.info", function(timeline) {
     *     console.log("Gathering timeline info:");
     *     console.log(JSON.stringify(timeline));
     * });
     */
    Human.rpc.define("timeline.info",
        function () {
            this.setResult(getTimelineResult());
        });

    /**
     * Jump to a given point on the timeline
     *
     * @apimethod human.send
     * @function set
     * @memberof timeline
     *
     * @param {object} params
     * @param {number} [params.time] - Jump to the specified time
     * @param {string} [params.chapterId] - Jump to the specified chapter
     *
     * @example <caption>Setting the timeline</caption> <codepen>http://codepen.io/biodigital/pen/68045d3795f8c7bc7d62c16753ac9ac8</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *
     *     human.send("timeline.pause");
     *
     *     var currentTime = 0;
     *
     *     setInterval(function() {
     *
     *         currentTime += 0.3;
     *
     *         if (currentTime > 1) {
     *             currentTime = 0;
     *         }
     *
     *         console.log("Setting timeline to: " + currentTime.toFixed(1) + "s");
     *         human.send("timeline.set", { time: currentTime });
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.set",
        function (params) {
            Human.timeline.scrub(params);
            this.setResult(true);
        });

    /**
     * Play the timeline
     *
     * @apimethod human.send
     * @function play
     * @memberof timeline
     *
     * @param {object} [params]
     * @param {number} [params.time] - Start at the specified time
     * @param {string} [params.chapterId] - Start at the specified chapter
     * @param {boolean} [params.loop=false] - Loop back to beginning when end of timeline is reached
     *
     * @example <caption>Pause/play timeline</caption> <codepen>http://codepen.io/biodigital/pen/93f7a9c1b7167553ca88d1a18b0501c0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *     var playing = true;
     *
     *     setInterval(function() {
     *         playing = !playing;
     *
     *         if (playing) {
     *             console.log("Playing timeline")
     *             human.send("timeline.play", { loop: true });
     *         } else {
     *             console.log("Pausing timeline")
     *             human.send("timeline.pause");
     *         }
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.play",
        function (params) {

            if (params.time) {
                params.startTime = params.time;
            }

            if (params.chapterId) {
                params.startChapterId = params.chapterId;
            }

            Human.timeline.play(params);
            this.setResult(true);
        });

    /**
     * Pause the timeline
     *
     * @apimethod human.send
     * @function pause
     * @memberof timeline
     *
     * @example <caption>Pause/play timeline</caption> <codepen>http://codepen.io/biodigital/pen/93f7a9c1b7167553ca88d1a18b0501c0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *     var playing = true;
     *
     *     setInterval(function() {
     *         playing = !playing;
     *
     *         if (playing) {
     *             console.log("Playing timeline")
     *             human.send("timeline.play", { loop: true });
     *         } else {
     *             console.log("Pausing timeline")
     *             human.send("timeline.pause");
     *         }
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.pause",
        function () {
            Human.timeline.pause();
            this.setResult(true);
        });

    /**
     * Jump back to the previous chapter on the timeline
     *
     * @apimethod human.send
     * @function previousChapter
     * @memberof timeline
     *
     * @example <caption>Navigating chapters</caption> <codepen>http://codepen.io/biodigital/pen/290cd16a6df9c1a0387d16e6ce2f60db</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *     var count = 0;
     *     var step = 1;
     *     var next = true;
     *
     *     setInterval(function() {
     *
     *         if (next) {
     *             console.log("Next chapter")
     *             human.send("timeline.nextChapter");
     *         } else {
     *             console.log("Previous chapter")
     *             human.send("timeline.previousChapter");
     *         }
     *
     *         count += step;
     *
     *         if (count >= 3 || count <= 0) {
     *             next = !next;
     *             step *= -1;
     *         }
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.previousChapter",
        function () {
            Human.timeline.prev();
            this.setResult(true);
        });

    /**
     * Jump ahead to the next chapter on the timeline
     *
     * @apimethod human.send
     * @function nextChapter
     * @memberof timeline
     *
     * @example <caption>Navigating chapters</caption> <codepen>http://codepen.io/biodigital/pen/290cd16a6df9c1a0387d16e6ce2f60db</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *     var count = 0;
     *     var step = 1;
     *     var next = true;
     *
     *     setInterval(function() {
     *
     *         if (next) {
     *             console.log("Next chapter")
     *             human.send("timeline.nextChapter");
     *         } else {
     *             console.log("Previous chapter")
     *             human.send("timeline.previousChapter");
     *         }
     *
     *         count += step;
     *
     *         if (count >= 3 || count <= 0) {
     *             next = !next;
     *             step *= -1;
     *         }
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.nextChapter",
        function () {
            Human.timeline.next();
            this.setResult(true);
        });

    /**
     * @event timeline.chapterTransition
     * @apimethod human.on
     * @memberof timeline
     * @property {object} event
     * @property {number} event.previousChapter - Number of the chapter that was previously playing
     * @property {number} event.currentChapter - Number of the chapter that was just entered
     * @property {number} event.time - Current time on the timeline
     */
    Human.rpc.defineEvent("timeline.chapterTransition", {
        events: ["timeline.chapters.activated"],
        map: function(event) {
            return {
                previousChapter: event.oldChapterIndex,
                currentChapter: event.newChapterIndex,
                time: event.time
            };
        }
    });

    function getTimelineResult() {
        var timeframe = Human.timeline.getTimeFrame();

        return {
            time: Human.timeline.time,
            startTime: timeframe.firstTime,
            endTime: timeframe.lastTime,
            chapters: Object.keys(Human.timeline.chapters),
            playing: Human.timeline.playing
        };
    }

})();
;Human.rpc.hideDefinitions(function() {
    "use strict";

    /** Captures a bookmark of current Human state, returns it as JSON
     *
     */
    Human.rpc.define("bookmarks.capture",
        function () {
            this.setResult(Human.bookmarks.capture());
        });

    /** Restores Human state from given bookmark JSON
     */
    Human.rpc.define("bookmarks.restore",
        function (params) {
            var self = this;
            Human.bookmarks.restore(params, function () {
                self.setResult(true);
            });
        });

    /**
     * Unsubscribes from an engine event
     */
    Human.rpc.define("events.off",
        function (params) {
            if (params.id) {
                // Undo specific subscription
                unbindEvent(params.id);
            } else if (params.ids) {
                // Undo list of subscriptions
                var ids = params.ids;
                for (var i = 0, len = ids.length; i < len; i++) {
                    unbindEvent(ids[i]);
                }
            } else {
                // Undo all subscriptions
                for (var id in callbacks) {
                    if (callbacks.hasOwnProperty(id)) {
                        unbindEvent(id);
                    }
                }
            }
        });

    /**
     * Queries the current state of the timeline - chapters, time and play/pause state.
     */
    Human.rpc.define("timeline.query",
        function () {
            this.setResult(Human.timeline.query());
        });

    Human.rpc.define("camera.query", function () {
        var camera = Human.view.camera.getLookAt();
        camera.zoom = Human.view.camera.getZoom();

        this.setResult(camera);
    });

    Human.rpc.define("properties.query",
        function (params) {
            this.setResult(Human.properties.query(params.regex));
        });

    Human.rpc.define("actions.doAction",
        function (params) {
            Human.actions._doAction([params.action, params.arguments]);
        });

    Human.rpc.define("alert",
        function (params) {
            window.alert(params.message || "");
        });

    Human.rpc.define("videos.getClips",
        function () {
            this.setResult(Human.media.videos.clipsList);
        });

    Human.rpc.define("videos.open",
        function (params) {
            var self = this;
            Human.media.videos.open(params.clipId,
                function () {
                    self.setResult(true); // Opened
                });
        });

    Human.rpc.define("videos.play",
        function (params) {
            Human.media.videos.play(params.clipId);
        });

    Human.rpc.define("videos.scrub",
        function (params) {
            Human.media.videos.scrub(params.clipId, params.time);
        });

    Human.rpc.define("videos.pause",
        function (params) {
            Human.media.videos.pause(params.clipId);
        });

    Human.rpc.define("videos.stop",
        function (params) {
            Human.media.videos.stop(params.clipId);
        });

    Human.rpc.define("videos.close",
        function (params) {
            Human.media.videos.close(params.clipId);
        });

    Human.rpc.define("audio.getClips",
        function () {
            this.setResult(Human.media.audio.clipsList);
        });

    Human.rpc.define("audio.open",
        function (params) {
            var self = this;
            Human.media.audio.open(params.clipId,
                function () {
                    self.setResult(true); // Opened
                });
        });

    Human.rpc.define("audio.play",
        function (params) {
            Human.media.audio.play(params.clipId);
        });

    Human.rpc.define("audio.scrub",
        function (params) {
            Human.media.audio.scrub(params.clipId, params.time);
        });

    Human.rpc.define("audio.pause",
        function (params) {
            Human.media.audio.pause(params.clipId);
        });

    Human.rpc.define("audio.stop",
        function (params) {
            Human.media.audio.stop(params.clipId);
        });

    Human.rpc.define("audio.close",
        function (params) {
            Human.media.videos.close(params.clipId);
        });

    Human.rpc.define("modules.getModules",
        function (params) {
            this.setResult(Human.modules.query(params));
        });

    Human.rpc.define("modules.activate",
        function (params) {
            var self = this;
            Human.modules.activateModules(params,
                function () {
                    self.setResult(true); // Activated
                });
        });

    Human.rpc.define("modules.deactivate",
        function (params) {
            Human.modules.deactivateModules(params);
        });

    Human.rpc.define("properties.subscribe",
        function (params) {
            var self = this;
            Human.properties.subscribe({
                subId: params.subId,
                propId: "myProperty",
                callback: function (value) {
                    self.setResult(value);
                }
            });
        });

    Human.rpc.define("properties.resubscribe",
        function (params) {
            Human.properties.resubscribe(params.subId, params.propId);
        });

    Human.rpc.define("properties.unsubscribe",
        function (params) {
            Human.properties.unsubscribe(params.subId);
        });

    Human.rpc.define("renderer.getBGColor", function () {
        this.setResult(Human.renderer.bg.getBGColor());
    });

    Human.rpc.define("renderer.setBGColor", function (params) {
        Human.renderer.bg.setBGColor(params.color);
    });

    Human.rpc.define("request.getParams",
        function () {
            this.setResult({
                hashParams: Human.request.getHashParams(),
                hashStr: Human.request.getHashStr(),
                searchParams: Human.request.getSearchParams(),
                searchStr: Human.request.getSearchStr()
            });
        });

    Human.rpc.define("scene.queryBoundary",
        function (params) {
            var boundary, object, fmaId;
            if (params.objectId) {

                // Get boundary of object by ID
                boundary = Human.scene.getBoundary({ objectId: params.objectId });

            } else if (params.fmaId) {

                // get boundary of object by FMA ID
                fmaId = params.fmaId;
                object = Human.scene.objectsByFMAID[fmaId];
                if (!object) {
                    this.error("No scene object found for the given FMA ID: '" + fmaId + "'");
                    return;
                }
                boundary = object.getBoundary();

            } else if (params.objectIds) {

                // Get collective boundary of multiple objects by IDs
                boundary = Human.scene.getBoundary({ objectIds: params.objectIds });

            } else if (params.fmaIds) {

                // Get collective boundary of multiple objects by FMA IDs
                var fmaIds = params.fmaIds;
                var objectIds = [];
                for (var i = 0, len = fmaIds.length; i < len; i++) {
                    fmaId = fmaIds[i];
                    object = Human.scene.objectsByFMAID[fmaId];
                    if (!object) {
                        this.error("No scene object found for the given FMA ID: '" + fmaId + "'");
                        return;
                    }
                    objectIds.push(object.objectId);
                }
                boundary = Human.scene.getBoundary({ objectIds: objectIds });

            } else if (params.selectedObjects) {

                // Get collective boundary of all currently selected objects
                boundary = Human.scene.getBoundary({ objects: Human.scene.selectedObjects });
            } else if (params.enabledObjects) {

                // Get collective boundary of all currently visible objects
                boundary = Human.scene.getBoundary({ objects: Human.scene.enabledObjects });
            } else {

                // Default: get boundary of all objects
                boundary = Human.scene.getBoundary();
            }
            this.setResult(boundary);
        });


    function fmaIdsToObjectIds(map) {
        var result = {};
        var objectsByFMA = Human.rpc.fmaIds;
        var objectIds;
        var maleStateId = Human.modules.MALE_STATE_ID;
        var femaleStateId = Human.modules.FEMALE_STATE_ID;
        for (var fmaId in map) {
            if (map.hasOwnProperty(fmaId)) {
                objectIds = objectsByFMA[fmaId];
                for (var i = 0; i < objectIds.length; i++) {
                    var object = Human.scene.objects[maleStateId + "-" + objectIds[i]] ||
                        Human.scene.objects[femaleStateId + "-" + objectIds[i]];
                    if (object) {
                        result[object.objectId] = map[fmaId];
                    }
                }
            }
        }
        return result;
    }

    Human.rpc.define("scene.setTransparentObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human.utils.isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            params.objectIds = objectIds;
            Human.scene.setTransparentObjects(params);
        });

    Human.rpc.define("scene.showBoundary",
        function (params) {
            var boundary;
            if (params.objectId) {
                boundary = Human.scene.getBoundary({ objectId: params.objectId });
                if (boundary) {
                    Human.view.boundary.setBoundary(boundary, true);
                }
            } else {
                Human.view.boundary.setBoundary(false);
            }
        });

    (function () {
        var canvas = document.getElementById('theCanvas');

        var getCanvasPos = function (worldPos, offset) {
            if(offset) {
                Human.math.addVec3(worldPos, offset, worldPos);
            }

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();
            var projPos = Human.math.vec4();

            Human.math.transformPoint3(viewMat, worldPos, projPos);
            projPos[3]  = 1; // Need homogeneous 'w' for perspective division
            Human.math.transformPoint4(projMat, projPos, projPos);

            var x = projPos[0];
            var y = projPos[1];
            var w = projPos[3];

            return [
                Math.round((1 + x / w) * canvas.width  / 2),
                Math.round((1 - y / w) * canvas.height / 2)
            ];
        };

        Human.rpc.define("scene.getCanvasPos",
            function (params) {
                this.setResult(getCanvasPos(params.worldPos, params.offset));
            });

        Human.rpc.define("scene.getObjectCanvasPos",
            function (params) {
               var object = Human.scene.objects[params.objectId];

               if(object) {
                   var worldPos = object.getCenter();
                   this.setResult(getCanvasPos(worldPos, params.offset));
               }
            });
    })();

    Human.rpc.define("annotations.setTitle", function (params) {
        var annotation = Human.view.annotations.annotations[params.annotationId];
        if (annotation) {
            annotation.label.setTitle(params.title);
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.setDescription", function (params) {
        var annotation = Human.view.annotations.annotations[params.annotationId];
        if (annotation) {
            annotation.label.setDescription(params.description);
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.setLabelStyles", function (styles) {
        if (styles.label) {
            $('.annotationContainer').css(styles.label);
        }

        if (styles.title) {
            $('.annotationContainer > .title').css(styles.title);
        }

        if (styles.description) {
            $('.annotationContainer > .description').css(styles.description);
        }

        Human.view.annotations.updateDimensions(); //updates width property
        Human.view.annotations.layouts.redrawLayout(); //redraws positions
        this.setResult(true);
    });

    Human.rpc.define("annotations.setPinStyles", function (styles) {
        if (styles.hasOwnProperty('pin')) {
            $('.annotationPin').css(styles.pin);

            if (styles.hasOwnProperty('after')) {
                //can't access :after pseudo element via js, so approximating...
                $('.annotationPin').html('<div class="after"></div>');
                $('.annotationPin > .after').css(styles.after);
            }
        } else {
            $('.annotationPin').css(styles);
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.setWireStyles", function (styles) {
        $('.annotationWire').css(styles);
        this.setResult(true);
    });

    //
    // Opens or closes annotations, either per their IDs and/or the IDs of their scene objects.
    //
    Human.rpc.define("annotations.setLabelsShown", function (params) {
        Human.view.annotations.setLabelsShown(params);
        this.setResult(true);
    });

        // Captures bookmark of timeline playing state
    Human.rpc.define("timeline.getBookmark",
        function () {
            this.setResult(Human.timeline.getBookmark());
        });

    // Restores playing state of timeline to given bookmark
    Human.rpc.define("timeline.setBookmark",
        function (params) {
            Human.timeline.setBookmark(params);
        });

     Human.rpc.define("clip.set",
        function (params) {
            if (params.clips) {
                var clips = params.clips;
                var clip;
                for (var clipId in clips) {
                    if (clips.hasOwnProperty(clipId)) {
                        clip = clips[clipId];
                        clip.clipId = clipId;
                        Human.view.clip.setClip(clip);
                    }
                }
            } else if (params.clip) {
                Human.view.clip.setClip(params.clip);
            }
        });

    Human.rpc.define("clip.reset",
        function () {
            Human.view.clip.reset();
        });

        /**
     * Queries what effects exist
     */
    Human.rpc.define("effects.getEffects",
        function () {
            var result = [];
            var effect;
            var effects = Human.view.effects.effects;
            for (var effectId in effects) {
                if (effects.hasOwnProperty(effectId)) {
                    effect = effects[effectId];
                    result.push({
                        effectId: effectId,
                        displayName: effect.displayName,
                        description: effect.description,
                        enabled: effect.enabled,
                        params: effect.params
                    });
                }
            }
            this.setResult(result);
        });

    /**
     * Enables or disables effects
     */
    Human.rpc.define("effects.setEnabled",
        function (params) {
            Human.view.effects.setEnabled(params);
        });

    /**
     * Sets parameters for effects
     */
    Human.rpc.define("effects.setParams",
        function (params) {
            Human.view.effects.setParams(params);
        });

    Human.rpc.define("focus.focusObject",
        function (params) {
            var self = this;
            Human.view.focus.focusObject(
                params, function () {
                    self.setResult(true);  // Completion RPC result
                });
        });

        Human.rpc.define("labels.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.labels.getEnabled();
            }
            Human.view.labels.setEnabled(enable);
        });

    Human.rpc.define("labels.create",
        function (params) {
            if (!params.objectId) {
                this.error("parameter expected: 'objectId'");
                return;
            }
            if (params.replace) {
                Human.view.labels.clearLabels();
            }
            Human.view.labels.createLabel(params);
        });

    Human.rpc.define("labels.clear",
        function () {
            Human.view.labels.clearLabels();
        });

    /**
     * Queries what lights exist
     */
    Human.rpc.define("lights.getLights",
        function () {
            var result = [];
            var light;
            var lights = Human.view.lights.lights;
            for (var lightId in lights) {
                if (lights.hasOwnProperty(lightId)) {
                    light = lights[lightId];
                    result.push({
                        lightId: lightId,
                        displayName: light.displayName,
                        description: light.description,
                        enabled: light.enabled,
                        params: light.params
                    });
                }
            }
            this.setResult(result);
        });

    /**
     * Enables or disables lights
     */
    Human.rpc.define("lights.setEnabled",
        function (params) {
            Human.view.lights.setEnabled(params);
        });

    /**
     * Sets parameters for lights
     */
    Human.rpc.define("lights.setParams",
        function (params) {
            Human.view.lights.setParams(params);
        });

    Human.rpc.define("tooltips.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {   // Toggle by default
                enable = !Human.view.tooltips.getEnabled();
            }
            Human.view.tooltips.setEnabled(enable);
        });

    Human.rpc.define("dissect.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.dissect.enabled;
            }
            checkUnsavedAnnotation(enable,
                function () {
                    Human.view.dissect.setEnabled(enable);
                    if (enable) {
                        Human.view.pick.setMultiPickEnabled(false);
                        Human.view.pick.setSinglePickEnabled(false);
                        Human.view.annotations.setEnabled(false);
                    } else {
                        Human.view.pick.setSinglePickEnabled(true);
                    }
                });
        });

    Human.rpc.define("highlight.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.highlight.enabled;
            }
            Human.view.highlight.setEnabled(enable);
            if (enable) {
                Human.view.isolate.setEnabled(false);
                Human.view.xray.setEnabled(false);
            }
        });

    Human.rpc.define("isolate.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.isolate.enabled;
            }
            if (enable) {
                var selection = Human.scene.anySelected();
                if (!selection) {
                    return;
                }
            }
            Human.view.isolate.setEnabled(enable);
            if (enable) {
                Human.view.highlight.setEnabled(false);
                Human.view.xray.setEnabled(false);
                Human.view.pick.setSinglePickEnabled(true); // Multi-pick doesn't make sense in Isolate mode
                Human.view.pick.setMultiPickEnabled(false);
            }
        });

    Human.rpc.define("pick.single.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.pick.getSinglePickEnabled();
            }
            checkUnsavedAnnotation(enable,
                function () {
                    Human.view.pick.setSinglePickEnabled(enable);
                    if (enable) {
                        Human.view.pick.setMultiPickEnabled(false);
                        Human.view.dissect.setEnabled(false);
                        Human.view.annotations.setEnabled(false);
                    }
                });
        });

    Human.rpc.define("pick.multi.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.pick.getMultiPickEnabled();
            }
            checkUnsavedAnnotation(enable,
                function () {
                    Human.view.pick.setMultiPickEnabled(enable);
                    if (enable) {
                        Human.view.pick.setSinglePickEnabled(false);
                        Human.view.dissect.setEnabled(false);
                        Human.view.annotations.setEnabled(false);
                    } else {
                        Human.view.pick.setSinglePickEnabled(true);
                    }
                });
        });

    Human.rpc.define("pick.doublePick",
        function (params) {
            Human.view.pick.doublePick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });

    Human.rpc.define("pick.hoverPick",
        function (params) {
            Human.view.pick.hoverPick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });

    Human.rpc.define("annotations.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.annotations.enabled;
            }
            checkUnsavedAnnotation(!enable, // Don't check, if enabling annotation mode
                function () {
                    Human.view.annotations.setEnabled(enable);
                    if (enable) {
                        Human.view.pick.setSinglePickEnabled(false);
                        Human.view.pick.setMultiPickEnabled(false);
                        Human.view.dissect.setEnabled(false);
                    } else {
                        Human.view.pick.setSinglePickEnabled(true);
                    }
                });
        });

    Human.rpc.define("xray.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.xray.enabled;
            }
            Human.view.xray.setEnabled(enable);
            if (enable) {
                Human.view.highlight.setEnabled(false);
                Human.view.isolate.setEnabled(false);
            }
        });

    Human.rpc.define("queryModes",
        function () {
            var data = {
                xray: Human.view.xray.enabled,
                highlight: Human.view.highlight.enabled,
                annotation: Human.view.annotations.enabled,
                singlePick: Human.view.pick.singleEnabled,
                multipick: Human.view.pick.multiEnabled,
                dissect: Human.view.dissect.enabled
            };
            this.setResult(data);
        });

    //UI outside of the canvas
    Human.rpc.define("jquery",
        function (params) {
            if(params.selector === 'document'){
                params.selector = document;
            }

            $.fn[params.method].apply($(params.selector), params.args);
        });

    Human.rpc.define("navigation.setEnabled",
        function (params) {
            _setUIEnabled('navigator_container', params.enable);
        });

    Human.rpc.define("fullscreen.setEnabled",
        function (params) {
            _setUIEnabled('embed-full-screen', params.enable);
        });

    Human.rpc.define("injectStyles",
        function (params) {
            if(window === top) {
                return;
            }

            var css  = params.styles,
                head = document.head || document.getElementsByTagName('head')[0],
                styleSheets = document.getElementsByTagName('link'),
                lastSheet   = styleSheets[ styleSheets.length - 1 ],
                style       = document.createElement('style');

                style.type  = 'text/css';

            if (style.styleSheet){
                style.styleSheet.cssText = css;
            } else {
                style.appendChild(document.createTextNode(css));
            }

            head.insertBefore(style, lastSheet);

            Human.view.annotations.updateDimensions(); //updates width property
            Human.view.annotations.layouts.redrawLayout(); // redraws positions
        });

    var reporters = Human.log.reporters;
    var messageBuf = Human.log.messageBuf;

    // Creates a log reporter
    // For network efficiency, this allows networked clients to only get
    // logging if they are interested in it. Potentially this is also
    // good for compression of that logging.
    Human.rpc.define("log.createReporter",
        function (params) {
            if (!params.id) {
                Human.log.error("param expected: id");
                return;
            }
            var id = "log.reporters." + params.id;
            if (reporters[id]) {
                // TODO: complain
                return;
            }
            reporters[id] = {};
            // Update reporter with events so far
            for (var i = 0, len = messageBuf.length; i < len; i++) {
                Human.events.fire(id, messageBuf[i]);
            }
        });

    // Destroys a log reporter
    Human.rpc.define("log.destroyReporter",
        function (params) {
            if (!params.id) {
                Human.log.error("param expected: id");
                return;
            }
            var id = "log.reporters." + params.id;
            delete reporters[id];
        });

    // Annotation object -> plain result object, only primitives, no private props
    function makeAnnotationResult(annotation) {
        var result = {};
        var value;

        for (var key in annotation) {
            if (annotation.hasOwnProperty(key)) {
                value = annotation[key];

                if(Human.utils.isPrimitive(value) && key[0] !== '_') {
                    result[key] = value;
                }
            }
        }

        // special prop adapting
        result.objectId = annotation.object ? annotation.object.objectId : "";

        result.title = annotation.label.title;
        result.description = annotation.label.description;

        result.pos = annotation.pin.pos;
        result.pinVec = annotation.pin.dir;
        result.visible = annotation.pin.visible;

        return result;
    }

    Human.rpc.define("annotations.getAnnotations",
        function () {
            var annotations = Human.view.annotations.annotations;
            var result = {};
            var annotation;

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    result[annotationId] = makeAnnotationResult(annotation);
                }
            }

            this.setResult(result);
        });

    Human.rpc.define("annotations.setShown", function (params) {
        Human.view.annotations.setShown(params.shown);
        this.setResult(true);
    });


    Human.rpc.define("camera.flyTo", function (params) {
        var self = this;
        Human.view.camera.fly.flyTo(params,
            function () {
                self.setResult(true);
            });
    });


    Human.rpc.define("camera.jumpTo", function (params) {
        var self = this;
        Human.view.camera.fly.jumpTo(params,
            function () {
                self.setResult(true);
            });
    });

    Human.rpc.define("camera.getZoom", function () {
        this.setResult(Human.view.camera.getZoom());
    });

    var callbacks = {};

    /**
     * Subscribes to an engine event
     */
    Human.rpc.define("events.on",
        function (params) {
            var self = this;
            var id = this.id;
            if (id) {
                if (callbacks[id]) {
                    // Support "events.off" for this subscription
                    this.error("an event is already bound to this ID: '" + id + "'");
                    return;
                }
            }
            var type = params.type;
            if (!type) {
                this.error("parameter expected: 'type'");
                return;
            }
            var fn = function (event) {
                self.setResult(event);
            };
            if (params.mask) {
                params.fn = fn;
                Human.events.on(params);
            } else {
                Human.events.on(params.type, fn);
            }
            if (id) { // So we can unbind with "events.off"
                callbacks[id] = [type, fn];
            }
        });

    /**
     * Subscribes to the next engine event of the given type
     */
    Human.rpc.define("events.once",
        function (params) {
            var self = this;
            var type = params.type;
            if (!type) {
                this.error("parameter expected: 'type'");
                return;
            }
            Human.events.once(type, function (event) {
                self.setResult(event);
            });
        });

    function unbindEvent(id) {
        var callback = callbacks[id];
        if (callback) {
            var type = callback[0];
            var fn = callback[1];
            Human.unEvent(type, fn);
            delete callbacks[id];
        }
    }

    /**
     * Triggers an engine event
     */
    Human.rpc.define("events.fire",
        function (params) {
            Human.events.fire(params.eventName, params.params);
        });

    Human.rpc.define("reset",
        function () {
            var self = this;
            Human.init.reset(function () {
                    self.setResult(true);
                });
        });

    Human.rpc.define("reload",
        function () {
            Human.init.reload();
        });

    Human.rpc.define("pick.pick",
        function (params) {
            Human.view.pick.pick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });


    Human.rpc.define("pick.queryPick",
        function (params) {
            this.setResult(Human.view.pick.queryPick({ canvasX: params.canvasX, canvasY: params.canvasY, rayPick: params.rayPick }) || {});
        });

    Human.rpc.define("scene.setEnabledObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human.utils.isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            Human.scene.setEnabledObjects({ objects: objectIds, replace: params.replace });
        });

    Human.rpc.define("scene.setSelectedObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human.utils.isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            params.objectIds = objectIds;
            Human.scene.setSelectedObjects(params);
        });

    (function () {
        Human.rpc.define("scene.getObjects",
            function (params) {
                var result = [];
                var object;
                if (params.objectId) {
                    var objectId = params.objectId;
                    object = Human.scene.objects[objectId];
                    if (object) {
                        result.push(getObjectDescription(object));
                    }
                } else {
                    // Get parent objects before their children so that on the API side we
                    // will always create HumanAPI.Objects for the parents BEFORE those for
                    // their children, so that each child's HumanAPI.Object can be instantiated
                    // with a reference to its parent's HumanAPI.Object.
                    for (var i = 0, len = Human.scene.rootObjects.length; i < len; i++) {
                        traverseObjects(Human.scene.rootObjects[i], result);
                    }
                }
                this.setResult(result);
            });

        function traverseObjects(object, result) {
            if (!object) {
                return;
            }
            result.push(getObjectDescription(object));
            for (var i = 0, len = object.objects.length; i < len; i++) {
                traverseObjects(object.objects[i], result);
            }
        }

        function getObjectDescription(object) {
            var desc = {};

            for (var prop in object) {
                if (object.hasOwnProperty(prop) && prop[0] !== "_") {
                    var value = object[prop];

                    if (Human.utils.isPrimitive(value)) {
                        desc[prop] = value;
                    }
                }
            }

            desc.parentObjectId = object.parent ? object.parent.objectId : null;

            return desc;
        }
    })();



    Human.rpc.define("scene.setObjectTransform",
        function (params) {
            var objectId = params.objectId;
            var fmaId = params.fmaId;
            var object;
            if (objectId) { // Find object by ID
                object = Human.scene.objects[objectId];
                if (!object) {
                    this.error("Scene object not found: '" + objectId + "'");
                    return;
                }
            } else if (fmaId) { // Find object by FMA ID
                object = Human.scene.objectsByFMAID[fmaId];
                if (!object) {
                    this.error("scene object not found for the given FMA ID: '" + fmaId + "'");
                    return;
                }
            }
            object.setTransform(params);
        });

    Human.rpc.define("snapshot.get",
        function (params) {
            var self = this;
            Human.view.snapshot.getSnapshot(params,
                function (image) {
                    self.setResult(image.src);
                });
        });

    /**
     * Scrub timeline to time or chapter
     *
     * Scrub to given time in seconds:
     *
     * {
     *    time: 15
     * }
     *
     * Scrub to start of given chapter:
     *
     * {
     *    chapterId: "makeIncision"
     * }
     *
     */
    Human.rpc.define("timeline.scrub",
        function (params) {
            Human.timeline.scrub(params);
        });

    // Stops timeline if currently playing
    Human.rpc.define("timeline.stop",
        function () {
            Human.timeline.stop();
        });

    // Winds timeline to start of previous chapter
    Human.rpc.define("timeline.prev",
        function () {
            Human.timeline.prev();
        });

    // Winds timeline to start of next chapter
    Human.rpc.define("timeline.next",
        function () {
            Human.timeline.next();
        });

    // Unpauses timeline if currently paused
    Human.rpc.define("timeline.unpause",
        function () {
            Human.timeline.unpause();
        });

    Human.rpc.define("properties.set",
        function (params) {
            //backwards compatibility for older API libraries
            var props = params.props || params;
            Human.properties.set(props || {});
        });

    //Private methods

    var _setUIEnabled = function (id, enable) {
      var _enable = (typeof enable === 'undefined') ? true : enable;
      var el = document.getElementById(id);
      el.style.display = (_enable) ? 'block' : 'none';
    };

    function checkUnsavedAnnotation(doCheck, ok) {
        if (doCheck && Human.view.annotations.unsavedAnnotation) {
            alert("Please save or cancel annotation first");
        } else {
            ok();
        }
    }
});
;Human.rpc.fmaIds = {
    "3734": [
        "Base_of_aorta_3734_ID"
    ],
    "3768": [
        "Aortic_arch_3768_ID"
    ],
    "3784": [
        "Descending_Aorta_3784_ID"
    ],
    "3818": [
        "Marginal_branch_of_right_coronary_artery_3818_ID"
    ],
    "3829": [
        "Anterior_atrial_branch_of_right_coronary_artery_3829_ID"
    ],
    "3837": [
        "Posterior_left_ventricular_branch_of_left_coronary_artery_3837_ID"
    ],
    "3932": [
        "left_lower_subclavian_artery_3932_ID",
        "Right_Brachiocephalic_trunk_3932_ID"
    ],
    "3941": [
        "Right_common_carotid_artery_3941_ID"
    ],
    "3945": [
        "Right_external_carotid_artery_3945_ID"
    ],
    "3949": [
        "Right_Internal_Carotid_Artery_3949_ID"
    ],
    "3950": [
        "Right_Internal_Carotid_Artery_3950_ID"
    ],
    "3958": [
        "Right_Vertebral_Artery_3958_ID"
    ],
    "3969": [
        "Right_internal_thoracic_artery_3969_ID"
    ],
    "3988": [
        "Superior_right_epigastric_artery_3988_ID",
        "Right_Superior_epigastric_artery_3988_ID"
    ],
    "4058": [
        "Left_common_carotid_artery_4058_ID",
        "Base_of_left_common_carotid_artery_4058_ID",
        "Base_of_Left_common_carotid_artery_4058_ID"
    ],
    "4060": [
        "Left_external_carotid_artery_4060_ID"
    ],
    "4062": [
        "Left_Internal_Carotid_Artery_4062_ID"
    ],
    "4066": [
        "Left_Vertebral_Artery_4066_ID"
    ],
    "4068": [
        "Left_internal_thoracic_artery_4068_ID"
    ],
    "4083": [
        "Left_Superior_epigastric_artery_4083_ID"
    ],
    "4085": [
        "Right_costocervical_trunk_4085_ID"
    ],
    "4086": [
        "Right_costocervical_trunk_4086_ID",
        "Left_costocervical_trunk_4086_ID"
    ],
    "4134": [
        "Left_deep_cervical_artery_4134_ID",
        "left_deep_cervical_artery_4134_ID"
    ],
    "4634": [
        "Right_Subcostal_artery_4634_ID",
        "Right_subcostal_artery_4634_ID"
    ],
    "4654": [
        "Left_Subcostal_artery_4654_ID",
        "Left_subcostal_artery_4654_ID"
    ],
    "4693": [
        "Right_subclavian_artery_4693_ID"
    ],
    "4694": [
        "left_subclavian_artery_4694_ID",
        "Left_Lower_Subclavian_artery_4694_ID",
        "right_subclavian_artery_4694_ID"
    ],
    "4706": [
        "Coronary_sinus_4706_ID"
    ],
    "4707": [
        "Great_cardiac_vein_4707_ID"
    ],
    "4712": [
        "Posterior_vein_of_left_ventricle_4712_ID"
    ],
    "4713": [
        "Middle_cardiac_vein_4713_ID"
    ],
    "4714": [
        "Small_cardiac_vein_4714_ID"
    ],
    "4715": [
        "Oblique_vein_of_left_atrium_4715_ID"
    ],
    "4720": [
        "Superior_Vena_Cava_4720_ID"
    ],
    "4728": [
        "Inferior_Thyroid_vein_4728_ID"
    ],
    "4751": [
        "Right_Brachiocephalic_vein_4751_ID",
        "Right_brachiocephalic_vein_4751_ID"
    ],
    "4755": [
        "Right_internal_jugular_vein_4755_ID"
    ],
    "4756": [
        "Right_Vertebral_vein_4756_ID"
    ],
    "4758": [
        "Right_internal_thoracic_vein_4758_ID"
    ],
    "4761": [
        "Left_Brachiocephalic_vein_4761_ID",
        "Left_brachiocephalic_vein_4761_ID"
    ],
    "4763": [
        "Left_internal_jugular_vein_4763_ID"
    ],
    "4764": [
        "Left_Vertebral_vein_4764_ID"
    ],
    "4766": [
        "Left_internal_thoracic_vein_4766_ID"
    ],
    "4771": [
        "Right_Superior_epigastric_vein_4771_ID",
        "Right_superior_epigastric_vein_4771_ID"
    ],
    "4785": [
        "Left_superior_epigastric_vein_4785_ID"
    ],
    "4838": [
        "Azygos_Vein_4838_ID",
        "Azygos_vein_4838_ID"
    ],
    "4843": [
        "Right_ascending_lumbar_vein_4843_ID"
    ],
    "4944": [
        "Hemiazgos_vein_4944_ID",
        "Hemiazygos_vein_4944_ID"
    ],
    "4950": [
        "Left_ascending_lumbar_vein_4950_ID"
    ],
    "5011": [
        "Left_Accessory_Hemiazgos_vein_5011_ID",
        "Left_Accessory_Hemiazygos_vein_5011_ID"
    ],
    "5883": [
        "Right_Splanchnic_Nerve_5883_ID",
        "Left_Splanchnic_Nerve_5883_ID"
    ],
    "6192": [
        "Right_Phrenic_Nerve_6192_ID"
    ],
    "6193": [
        "Left_Phrenic_Nerve_6193_ID"
    ],
    "6246": [
        "Left_Recurrent_Laryngeal_Nerve_6246_ID",
        "Right_Recurrent_Laryngeal_Nerve_6246_ID"
    ],
    "6258": [
        "Left_Sympathetic_Chain_6258_ID",
        "Right_Sympathetic_Chain_6258_ID"
    ],
    "6259": [
        "Right_Sympathetic_Chain_6259_ID"
    ],
    "6442": [
        "Left_C1_Spinal_Nerve_6442_ID",
        "Right_C1_Spinal_Nerve_6442_ID"
    ],
    "6451": [
        "Left_C2_Spinal_Nerve_6451_ID",
        "Right_C2_Spinal_Nerve_6451_ID"
    ],
    "6453": [
        "Left_C3_Spinal_Nerve_6453_ID",
        "Right_C3_Spinal_Nerve_6453_ID"
    ],
    "6456": [
        "Left_C4_Spinal_Nerve_6456_ID",
        "Right_C4_Spinal_Nerve_6456_ID"
    ],
    "6457": [
        "Right_C5_Spinal_Nerve_6457_ID",
        "Left_C5_Spinal_Nerve_6457_ID"
    ],
    "6459": [
        "Left_C6_Spinal_Nerve_6459_ID",
        "Right_C6_Spinal_Nerve_6459_ID"
    ],
    "6461": [
        "Right_C7_Spinal_Nerve_Group_6461_ID",
        "Left_C7_Spinal_Nerve_6461_ID",
        "Right_C7_Spinal_Nerve_6461_ID",
        "Left_C7_Spinal_Nerve_Group_6461_ID"
    ],
    "6465": [
        "Left_C8_Spinal_Nerve_6465_ID",
        "Right_C8_Spinal_Nerve_6465_ID"
    ],
    "6582": [
        "Ansa_Subclavia_6582_ID"
    ],
    "6642": [
        "Superior_hypogastric_nerve_plexus_6642_ID"
    ],
    "6643": [
        "Inferior_hypogastric_nerve_plexus_6643_ID"
    ],
    "6647": [
        "Prostatic_nerve_plexus_6647_ID"
    ],
    "7088": [
        "Heart_7088_ID"
    ],
    "7096": [
        "Right_atrium_7096_ID"
    ],
    "7097": [
        "Left_atrium_7097_ID"
    ],
    "7098": [
        "Right_Ventricle_7098_ID"
    ],
    "7101": [
        "Left_Ventricle_7101_ID"
    ],
    "7131": [
        "Esophagus_7131_ID"
    ],
    "7133": [
        "Interventricular_Septum_7133_ID"
    ],
    "7148": [
        "Stomach_7148_ID"
    ],
    "7196": [
        "Spleen_7196_ID"
    ],
    "7197": [
        "Liver_7197_ID"
    ],
    "7198": [
        "Pancreas_7198_ID"
    ],
    "7200": [
        "Small_intestine_7200_ID"
    ],
    "7202": [
        "Gallbladder_7202_ID"
    ],
    "7204": [
        "Left_Kidney_7204_ID",
        "Right_Kidney_7204_ID"
    ],
    "7205": [
        "Right_Kidney_7205_ID",
        "Left_Kidney_7205_ID"
    ],
    "7206": [
        "Duodenum_7206_ID"
    ],
    "7207": [
        "Jejunum_7207_ID"
    ],
    "7208": [
        "Ileum_7208_ID"
    ],
    "7209": [
        "Ovaries_7209_ID"
    ],
    "7211": [
        "Right_testis_7211_ID"
    ],
    "7212": [
        "Left_testis_7212_ID"
    ],
    "7213": [
        "Right_Ovary_7213_ID"
    ],
    "7214": [
        "Left_Ovary_7214_ID"
    ],
    "7218": [
        "Right_auricle_7218_ID"
    ],
    "7219": [
        "Left_auricle_7219_ID"
    ],
    "7234": [
        "Tricuspid_Valve_7234_ID"
    ],
    "7235": [
        "Mitral_valve_7235_ID"
    ],
    "7236": [
        "Aortic_Valve_7236_ID"
    ],
    "7246": [
        "Pulmonary_Valve_7246_ID"
    ],
    "7309": [
        "Right_Lung_7309_ID"
    ],
    "7310": [
        "Left_Lung_7310_ID"
    ],
    "7333": [
        "Right_Superior_Lobe_7333_ID"
    ],
    "7337": [
        "Right_Inferior_Lobe_7337_ID"
    ],
    "7370": [
        "Left_Superior_Lobe_7370_ID"
    ],
    "7371": [
        "Left_Inferior_Lobe_7371_ID"
    ],
    "7383": [
        "Right_Middle_Lobe_7383_ID"
    ],
    "7394": [
        "Trachea_7394_ID"
    ],
    "7486": [
        "manubrium_of_sternum_7486_ID",
        "body_of_sternum_7486_ID"
    ],
    "7591": [
        "Right_Costal_Cartilage_7591_ID",
        "Left_Costal_Cartilage_7591_ID"
    ],
    "7592": [
        "Left_Costal_Cartilage_7592_ID",
        "Right_Costal_Cartilage_7592_ID"
    ],
    "7647": [
        "spinal_cord_7647_ID"
    ],
    "7857": [
        "Left_first_rib_7857_ID",
        "Right_first_rib_7857_ID"
    ],
    "7882": [
        "Right_second_rib_7882_ID"
    ],
    "7883": [
        "Left_second_rib_7883_ID"
    ],
    "7909": [
        "Right_third_rib_7909_ID"
    ],
    "7910": [
        "Left_third_rib_7910_ID"
    ],
    "7957": [
        "Right_fourth_rib_7957_ID"
    ],
    "7958": [
        "Left_fourth_rib_7958_ID"
    ],
    "8066": [
        "Right_fifth_rib_8066_ID",
        "Left_fifth_rib_8066_ID"
    ],
    "8175": [
        "Left_sixth_rib_8175_ID",
        "Right_sixth_rib_8175_ID"
    ],
    "8229": [
        "Left_seventh_rib_8229_ID",
        "Right_seventh_rib_8229_ID"
    ],
    "8283": [
        "Left_eighth_rib_8283_ID",
        "Right_eighth_rib_8283_ID"
    ],
    "8364": [
        "Left_ninth_rib_8364_ID",
        "Right_ninth_rib_8364_ID"
    ],
    "8445": [
        "Right_tenth_rib_8445_ID",
        "Left_tenth_rib_8445_ID"
    ],
    "8531": [
        "Left_eleventh_rib_8531_ID",
        "Right_eleventh_rib_8531_ID"
    ],
    "8533": [
        "Right_twelfth_rib_8533_ID",
        "Left_twelfth_rib_8533_ID"
    ],
    "8612": [
        "Pulmonary_trunk_8612_ID"
    ],
    "9165": [
        "First_thoracic_vertebra_9165_ID"
    ],
    "9187": [
        "Second_thoracic_vertebra_9187_ID"
    ],
    "9209": [
        "Third_thoracic_vertebra_9209_ID"
    ],
    "9248": [
        "Fourth_thoracic_vertebra_9248_ID"
    ],
    "9600": [
        "Prostate_9600_ID"
    ],
    "9603": [
        "Thyroid_Gland_9603_ID"
    ],
    "9615": [
        "Cricoid_cartilage_9615_ID"
    ],
    "9706": [
        "Bile_Ducts_9706_ID"
    ],
    "9707": [
        "Penis_9707_ID"
    ],
    "9710": [
        "Vomer_9710_ID"
    ],
    "9711": [
        "Maxilla_9711_ID"
    ],
    "9761": [
        "Right_Transversus_thoracis_9761_ID"
    ],
    "9762": [
        "Right_Transversus_thoracis_9762_ID",
        "Left_Transversus_thoracis_9762_ID"
    ],
    "9922": [
        "Fifth_thoracic_vertebra_9922_ID"
    ],
    "9945": [
        "Sixth_thoracic_vertebra_9945_ID"
    ],
    "9968": [
        "Seventh_thoracic_vertebra_9968_ID"
    ],
    "9991": [
        "Eighth_thoracic_vertebra_9991_ID"
    ],
    "10014": [
        "Ninth_thoracic_vertebra_10014_ID"
    ],
    "10037": [
        "Tenth_thoracic_vertebra_10037_ID"
    ],
    "10059": [
        "Eleventh_thoracic_vertebra_10059_ID"
    ],
    "10081": [
        "Twelfth_thoracic_vertebra_10081_ID"
    ],
    "10551": [
        "Right_dorsal_scapular_artery_10551_ID"
    ],
    "10552": [
        "right_dorsal_scapular_artery_10552_ID",
        "left_dorsal_scapular_artery_10552_ID"
    ],
    "10660": [
        "Right_deep_cervical_artery_10660_ID"
    ],
    "10679": [
        "Right_inferior_thyroid_artery_10679_ID"
    ],
    "10680": [
        "left_inferior_thyroid_artery_10680_ID",
        "Right_suprascapular_artery_10680_ID"
    ],
    "10681": [
        "left_suprascapular_artery_10681_ID",
        "Right_transverse_cervical_artery_10681_ID",
        "right_suprascapular_artery_10681_ID"
    ],
    "10682": [
        "left_transverse_cervical_artery_10682_ID",
        "Right_superficial_cervical_artery_10682_ID"
    ],
    "10683": [
        "left_superficial_cervical_artery_10683_ID"
    ],
    "10951": [
        "Inferior_vena_cava_10951_ID",
        "base_of_inferior_vena_cava_10951_ID"
    ],
    "12519": [
        "Atlas_C1_12519_ID"
    ],
    "12520": [
        "Axis_C2_12520_ID"
    ],
    "12521": [
        "Third_cervical_vertebra_12521_ID"
    ],
    "12522": [
        "Fourth_cervical_vertebra_12522_ID"
    ],
    "12523": [
        "Fifth_cervical_vertebra_12523_ID"
    ],
    "12524": [
        "Sixth_cervical_vertebra_12524_ID"
    ],
    "12525": [
        "Seventh_cervical_vertebra_12525_ID"
    ],
    "12770": [
        "Deep_lateral_cervical_lymph_nodes_12770_ID"
    ],
    "12858": [
        "Union_between_ascending_lumbar_veins_12858_ID"
    ],
    "13072": [
        "First_lumbar_vertebra_13072_ID"
    ],
    "13073": [
        "Second_lumbar_vertebra_13073_ID"
    ],
    "13074": [
        "Third_lumbar_vertebra_13074_ID"
    ],
    "13075": [
        "Fourth_lumbar_vertebra_13075_ID"
    ],
    "13076": [
        "Fifth_lumbar_vertebra_13076_ID"
    ],
    "13111": [
        "Right_external_jugular_vein_13111_ID"
    ],
    "13112": [
        "Left_external_jugular_vein_13112_ID",
        "Right_external_jugular_vein_13112_ID"
    ],
    "13113": [
        "Left_external_jugular_vein_13113_ID"
    ],
    "13295": [
        "Diaphragm_13295_ID"
    ],
    "13322": [
        "Right_Clavicle_13322_ID"
    ],
    "13323": [
        "Left_Clavicle_13323_ID"
    ],
    "13325": [
        "Right_cephalic_vein_13325_ID"
    ],
    "13326": [
        "right_cephalic_vein_13326_ID",
        "left_cephalic_vein_13326_ID"
    ],
    "13328": [
        "Left_Clavicle_13328_ID"
    ],
    "13336": [
        "Right_external_oblique_13336_ID"
    ],
    "13337": [
        "Left_external_oblique_13337_ID"
    ],
    "13346": [
        "Right_Sternohyoid_13346_ID"
    ],
    "13347": [
        "Left_Sternohyoid_13347_ID"
    ],
    "13350": [
        "Right_Sternothyroid_13350_ID"
    ],
    "13351": [
        "Left_Sternothyroid_13351_ID"
    ],
    "13352": [
        "Right_Thyrohyoid_13352_ID"
    ],
    "13353": [
        "Left_Thyrohyoid_13353_ID"
    ],
    "13354": [
        "Intercostal_Muscles_of_Left_Thorax_13354_ID",
        "Intercostal_Muscles_of_Right_Thorax_13354_ID"
    ],
    "13358": [
        "Right_latissimus_dorsi_13358_ID"
    ],
    "13359": [
        "Left_latissimus_dorsi_13359_ID"
    ],
    "13373": [
        "Right_pectoralis_major_13373_ID"
    ],
    "13374": [
        "Left_pectoralis_major_13374_ID",
        "Right_pectoralis_major_13374_ID"
    ],
    "13375": [
        "Right_Pectoralis_minor_13375_ID"
    ],
    "13376": [
        "Left_Pectoralis_minor_13376_ID",
        "Right_Pectoralis_minor_13376_ID"
    ],
    "13377": [
        "Right_Rectus_Abdominis_13377_ID"
    ],
    "13378": [
        "Left_Rectus_Abdominis_13378_ID"
    ],
    "13379": [
        "Right_Rectus_Abdominis_13379_ID"
    ],
    "13381": [
        "Right_Rhomboid_Major_13381_ID"
    ],
    "13382": [
        "Left_Rhomboid_Major_13382_ID"
    ],
    "13383": [
        "Right_Rhomboid_Minor_13383_ID"
    ],
    "13384": [
        "Left_Rhomboid_Minor_13384_ID"
    ],
    "13395": [
        "Right_Scapula_13395_ID"
    ],
    "13396": [
        "Left_Scapula_13396_ID",
        "Right_Scapula_13396_ID"
    ],
    "13398": [
        "Right_serratus_anterior_13398_ID"
    ],
    "13399": [
        "Left_serratus_anterior_13399_ID"
    ],
    "13403": [
        "Right_Serratus_Posterior_Superior_13403_ID"
    ],
    "13404": [
        "Left_Serratus_Posterior_Superior_13404_ID"
    ],
    "13405": [
        "Right_Serratus_Posterior_Inferior_13405_ID"
    ],
    "13406": [
        "Left_Serratus_Posterior_Inferior_13406_ID"
    ],
    "13408": [
        "Right_Sternocleidomastoid_13408_ID"
    ],
    "13409": [
        "Left_Sternocleidomastoid_13409_ID"
    ],
    "13410": [
        "Right_Subclavius_13410_ID"
    ],
    "13411": [
        "Left_Subclavius_13411_ID",
        "Right_Subclavius_13411_ID"
    ],
    "13414": [
        "Right_subscapularis_13414_ID"
    ],
    "13415": [
        "Left_subscapularis_13415_ID",
        "Right_subscapularis_13415_ID"
    ],
    "13417": [
        "Right_Thoracoepigastric_vein_13417_ID"
    ],
    "13418": [
        "Left_Thoracoepigastric_vein_13418_ID"
    ],
    "13419": [
        "Right_Trapezius_13419_ID"
    ],
    "13420": [
        "Left_Trapezius_13420_ID"
    ],
    "13421": [
        "Ligamentum_arteriosum_13421_ID"
    ],
    "13478": [
        "Vertebral_Column_13478_ID"
    ],
    "13889": [
        "Pituitary_Gland_13889_ID"
    ],
    "13890": [
        "Parathyroid_Glands_13890_ID"
    ],
    "13892": [
        "Right_Internal_oblique_13892_ID"
    ],
    "13893": [
        "Left_Internal_oblique_13893_ID"
    ],
    "13912": [
        "Anterior_interventricular_artery_13912_ID"
    ],
    "14331": [
        "splenic_vein_14331_ID"
    ],
    "14332": [
        "superior_mesenteric_vein_14332_ID"
    ],
    "14335": [
        "Right_renal_vein_14335_ID"
    ],
    "14336": [
        "Left_renal_vein_14336_ID"
    ],
    "14338": [
        "Right_Hepatic_Vein_14338_ID"
    ],
    "14339": [
        "Left_Hepatic_Vein_14339_ID"
    ],
    "14341": [
        "Right_testicular_vein_14341_ID"
    ],
    "14345": [
        "Left_testicular_vein_14345_ID"
    ],
    "14384": [
        "Right_median_nerve_14384_ID"
    ],
    "14385": [
        "Left_median_nerve_14385_ID"
    ],
    "14468": [
        "Right_Recurrent_Laryngeal_Nerve_14468_ID"
    ],
    "14469": [
        "Left_Recurrent_Laryngeal_Nerve_14469_ID"
    ],
    "14542": [
        "Appendix_14542_ID"
    ],
    "14543": [
        "Colon_14543_ID"
    ],
    "14544": [
        "Rectum_14544_ID"
    ],
    "14545": [
        "Ascending_colon_14545_ID"
    ],
    "14546": [
        "Transverse_colon_14546_ID"
    ],
    "14547": [
        "Descending_Colon_14547_ID"
    ],
    "14548": [
        "Sigmoid_Colon_14548_ID"
    ],
    "14735": [
        "Right_Lumbar_artery_14735_ID",
        "Left_Lumbar_Artery_14735_ID",
        "Right_Lumbar_Artery_14735_ID"
    ],
    "14746": [
        "Right_Inferior_Phrenic_Artery_14746_ID"
    ],
    "14747": [
        "Left_Inferior_Phrenic_Artery_14747_ID"
    ],
    "14749": [
        "superior_mesenteric_artery_14749_ID"
    ],
    "14750": [
        "Inferior_Mesenteric_artery_14750_ID"
    ],
    "14752": [
        "Right_renal_artery_14752_ID"
    ],
    "14753": [
        "Left_Renal_artery_14753_ID"
    ],
    "14759": [
        "Right_testicular_artery_14759_ID"
    ],
    "14760": [
        "Left_testicular_artery_14760_ID"
    ],
    "14768": [
        "Left_Gastric_Artery_14768_ID"
    ],
    "14771": [
        "Common_hepatic_artery_14771_ID"
    ],
    "14772": [
        "Hepatic_artery_proper_14772_ID"
    ],
    "14773": [
        "Splenic_artery_14773_ID"
    ],
    "14775": [
        "Gastroduodenal_artery_14775_ID"
    ],
    "14776": [
        "Right_Gastric_artery_14776_ID"
    ],
    "14778": [
        "Right_hepatic_artery_14778_ID"
    ],
    "14779": [
        "Left_hepatic_artery_14779_ID"
    ],
    "14781": [
        "Right_Gastroepiploic_artery_14781_ID"
    ],
    "14787": [
        "Dorsal_pancreatic_artery_14787_ID"
    ],
    "14790": [
        "Inferior_pancreatic_artery_14790_ID"
    ],
    "14791": [
        "Prepancreatic_Artery_14791_ID"
    ],
    "14792": [
        "Great_pancreatic_artery_14792_ID"
    ],
    "14793": [
        "Caudal_pancreatic_artery_14793_ID"
    ],
    "14796": [
        "Left_Gastroepiploic_artery_14796_ID"
    ],
    "14810": [
        "middle_colic_artery_14810_ID"
    ],
    "14811": [
        "Right_colic_artery_14811_ID"
    ],
    "14812": [
        "Celiac_Trunk_14812_ID"
    ],
    "14815": [
        "Ileocolic_artery_14815_ID"
    ],
    "14819": [
        "ileal_branch_of_ileocolic_artery_14819_ID"
    ],
    "14820": [
        "Ileal_branch_of_ileocolic_vein_14820_ID",
        "Colic_branch_of_ileocolic_vein_14820_ID"
    ],
    "14822": [
        "Superior_branch_of_ileocolic_artery_14822_ID"
    ],
    "14826": [
        "Left_colic_artery_14826_ID"
    ],
    "14830": [
        "Sigmoid_artery_14830_ID"
    ],
    "14831": [
        "Marginal_artery_of_colon_14831_ID"
    ],
    "14832": [
        "Superior_Rectal_artery_14832_ID"
    ],
    "14835": [
        "Cystic_artery_14835_ID"
    ],
    "15388": [
        "Pancreatic_tributary_of_splenic_vein_15388_ID"
    ],
    "15390": [
        "left_gastroepiploic_vein_15390_ID"
    ],
    "15391": [
        "Inferior_Mesenteric_vein_15391_ID"
    ],
    "15394": [
        "Left_colic_vein_15394_ID"
    ],
    "15395": [
        "Sigmoid_vein_15395_ID"
    ],
    "15397": [
        "Right_gastroepiploic_vein_15397_ID"
    ],
    "15398": [
        "Anterior_Superior_pancreaticoduodenal_vein_15398_ID",
        "Anterior_Inferior_pancreaticoduodenal_vein_15398_ID",
        "Pancreaticoduodenal_vein_15398_ID",
        "Posterior_Superior_pancreaticoduodenal_vein_15398_ID",
        "Posterior_Inferior_pancreaticoduodenal_vein_15398_ID"
    ],
    "15399": [
        "Left_Gastric_vein_15399_ID"
    ],
    "15400": [
        "Right_Gastric_vein_15400_ID"
    ],
    "15407": [
        "right_colic_vein_15407_ID"
    ],
    "15408": [
        "Ileocolic_vein_15408_ID"
    ],
    "15414": [
        "Right_Hepatic_Portal_Vein_15414_ID"
    ],
    "15415": [
        "Left_Hepatic_Portal_Vein_15415_ID"
    ],
    "15571": [
        "Right_Ureter_15571_ID"
    ],
    "15572": [
        "Left_Ureter_15572_ID"
    ],
    "15629": [
        "Right_Adrenal_Gland_15629_ID"
    ],
    "15630": [
        "Left_Adrenal_Gland_15630_ID"
    ],
    "15710": [
        "Internal_anal_sphincter_15710_ID"
    ],
    "15900": [
        "Bladder_15900_ID"
    ],
    "16202": [
        "Sacrum_16202_ID"
    ],
    "16491": [
        "Right_iliohypogastric_nerve_16491_ID"
    ],
    "16492": [
        "Left_iliohypogastric_nerve_16492_ID"
    ],
    "16493": [
        "Right_ilioinguinal_nerve_16493_ID"
    ],
    "16494": [
        "Left_ilioinguinal_nerve_16494_ID"
    ],
    "16497": [
        "Right_lateral_femoral_cutaneous_nerve_16497_ID"
    ],
    "16498": [
        "Left_lateral_femoral_cutaneous_nerve_16498_ID"
    ],
    "16499": [
        "Right_femoral_nerve_16499_ID"
    ],
    "16500": [
        "Left_femoral_nerve_16500_ID"
    ],
    "16501": [
        "Right_obturator_nerve_16501_ID"
    ],
    "16502": [
        "Left_obturator_nerve_16502_ID"
    ],
    "17559": [
        "Uterus_17559_ID"
    ],
    "17740": [
        "Cervix_of_uterus_17740_ID"
    ],
    "18245": [
        "Right_Fallopian_Tube_18245_ID",
        "Left_Fallopian_Tube_18245_ID"
    ],
    "18256": [
        "Right_epididymis_18256_ID"
    ],
    "18257": [
        "Left_epididymis_18257_ID"
    ],
    "18806": [
        "Right_external_iliac_artery_18806_ID"
    ],
    "18807": [
        "Left_external_iliac_artery_18807_ID"
    ],
    "18809": [
        "Right_internal_iliac_artery_18809_ID"
    ],
    "18810": [
        "Left_internal_iliac_artery_18810_ID"
    ],
    "18824": [
        "Right_inferior_vesical_artery_18824_ID"
    ],
    "18825": [
        "Left_inferior_vesical_artery_18825_ID"
    ],
    "18829": [
        "Left_Uterine_Artery_18829_ID",
        "Right_Uterine_Artery_18829_ID"
    ],
    "18836": [
        "Right_internal_pudendal_artery_18836_ID"
    ],
    "18837": [
        "Left_internal_pudendal_artery_18837_ID"
    ],
    "18846": [
        "Right_iliolumbar_artery_18846_ID"
    ],
    "18847": [
        "Left_iliolumbar_artery_18847_ID"
    ],
    "18856": [
        "Right_lateral_sacral_artery_18856_ID"
    ],
    "18857": [
        "Left_lateral_sacral_artery_18857_ID"
    ],
    "18866": [
        "Right_obturator_artery_18866_ID"
    ],
    "18867": [
        "Left_obturator_artery_18867_ID"
    ],
    "18869": [
        "Right_superior_gluteal_artery_18869_ID"
    ],
    "18870": [
        "Right_superior_gluteal_artery_18870_ID",
        "Left_superior_gluteal_artery_18870_ID"
    ],
    "18872": [
        "Right_inferior_gluteal_artery_18872_ID"
    ],
    "18873": [
        "Left_inferior_gluteal_artery_18873_ID"
    ],
    "18885": [
        "Right_external_iliac_vein_18885_ID"
    ],
    "18886": [
        "Left_external_iliac_vein_18886_ID"
    ],
    "18887": [
        "Right_internal_iliac_vein_18887_ID"
    ],
    "18888": [
        "Left_internal_iliac_vein_18888_ID"
    ],
    "18891": [
        "Right_inferior_vesical_vein_18891_ID"
    ],
    "18892": [
        "Left_inferior_vesical_vein_18892_ID"
    ],
    "18897": [
        "Right_Uterine_Vein_18897_ID"
    ],
    "18898": [
        "Left_Uterine_Vein_18898_ID"
    ],
    "18903": [
        "Right_iliolumbar_vein_18903_ID"
    ],
    "18904": [
        "Left_iliolumbar_vein_18904_ID"
    ],
    "18906": [
        "Right_lateral_sacral_vein_18906_ID"
    ],
    "18907": [
        "Left_lateral_sacral_vein_18907_ID"
    ],
    "18909": [
        "Right_superior_gluteal_vein_18909_ID"
    ],
    "18910": [
        "Left_superior_gluteal_vein_18910_ID"
    ],
    "18912": [
        "Right_inferior_gluteal_vein_18912_ID"
    ],
    "18913": [
        "Left_inferior_gluteal_vein_18913_ID"
    ],
    "18915": [
        "Right_obturator_vein_18915_ID"
    ],
    "18916": [
        "Left_obturator_vein_18916_ID"
    ],
    "18918": [
        "Right_internal_pudendal_vein_18918_ID"
    ],
    "18919": [
        "Left_internal_pudendal_vein_18919_ID"
    ],
    "19086": [
        "Muscles_of_the_Pelvis_19086_ID"
    ],
    "19087": [
        "Levator_Ani_19087_ID"
    ],
    "19090": [
        "Pubococcygeus_19090_ID"
    ],
    "19091": [
        "Puborectalis_19091_ID"
    ],
    "19119": [
        "Right_Uterosacral_Ligament_19119_ID"
    ],
    "19120": [
        "Left_Uterosacral_Ligament_19120_ID"
    ],
    "19235": [
        "Right_vas_deferens_19235_ID"
    ],
    "19236": [
        "Left_vas_deferens_19236_ID"
    ],
    "19387": [
        "Right_Seminal_Vesicle_19387_ID"
    ],
    "19388": [
        "Left_Seminal_Vesicle_19388_ID"
    ],
    "19617": [
        "Corpus_spongiosum_of_penis_19617_ID"
    ],
    "19618": [
        "Right_corporus_cavernosum_of_penis_19618_ID",
        "Left_corporus_cavernosum_of_penis_19618_ID"
    ],
    "19667": [
        "Urethra_19667_ID"
    ],
    "19668": [
        "Male_urethra_19668_ID"
    ],
    "19730": [
        "Left_Ischiocavernosus_19730_ID",
        "Right_Ischiocavernosus_19730_ID"
    ],
    "19731": [
        "Right_Superficial_Transverse_Perineal_Muscle_19731_ID",
        "Left_Superficial_Transverse_Perineal_Muscle_19731_ID"
    ],
    "19732": [
        "Deep_transverse_perineal_muscle_19732_ID"
    ],
    "19949": [
        "Vagina_19949_ID"
    ],
    "20224": [
        "Right_Ribs_20224_ID"
    ],
    "20225": [
        "Right_Ribs_20225_ID",
        "Left_Ribs_20225_ID"
    ],
    "20226": [
        "Right_Bony_Pelvis_20226_ID",
        "Left_Ribs_20226_ID",
        "Right_side_of_bony_pelvis_20226_ID"
    ],
    "20227": [
        "Left_Bony_Pelvis_20227_ID",
        "Left_side_of_bony_pelvis_20227_ID"
    ],
    "20274": [
        "Perineal_Body_20274_ID"
    ],
    "20630": [
        "Right_genitofemoral_nerve_20630_ID"
    ],
    "20631": [
        "Left_genitofemoral_nerve_20631_ID"
    ],
    "20632": [
        "Genital_branch_of_right_genitofemoral_nerve_20632_ID"
    ],
    "20633": [
        "Genital_branch_of_left_genitofemoral_nerve_20633_ID"
    ],
    "20634": [
        "Femoral_branch_of_right_genitofemoral_nerve_20634_ID"
    ],
    "20635": [
        "Femoral_branch_of_left_genitofemoral_nerve_20635_ID"
    ],
    "20688": [
        "Right_Inferior_Epigastric_Artery_20688_ID"
    ],
    "20689": [
        "Left_Inferior_Epigastric_Artery_20689_ID"
    ],
    "20735": [
        "Right_Superficial_Epigastric_Artery_20735_ID"
    ],
    "20736": [
        "Left_Superficial_Epigastric_Artery_20736_ID"
    ],
    "20796": [
        "Right_deep_femoral_artery_20796_ID"
    ],
    "20797": [
        "Left_deep_femoral_artery_20797_ID"
    ],
    "20801": [
        "Right_lateral_circumflex_femoral_artery_20801_ID"
    ],
    "20802": [
        "Left_lateral_circumflex_femoral_artery_20802_ID"
    ],
    "20807": [
        "Right_Medial_circumflex_femoral_artery_20807_ID"
    ],
    "20808": [
        "Left_Medial_circumflex_femoral_artery_20808_ID"
    ],
    "20818": [
        "Right_dorsal_artery_of_penis_20818_ID"
    ],
    "20819": [
        "Left_dorsal_artery_of_penis_20819_ID"
    ],
    "20967": [
        "Prostatic_part_of_right_inferior_vesical_artery_20967_ID"
    ],
    "20968": [
        "Prostatic_part_of_left_inferior_vesical_artery_20968_ID"
    ],
    "21163": [
        "Right_Inferior_Epigastric_Vein_21163_ID"
    ],
    "21164": [
        "Left_Inferior_Epigastric_Vein_21164_ID"
    ],
    "21188": [
        "Right_Femoral_Vein_21188_ID"
    ],
    "21189": [
        "Left_Femoral_Vein_21189_ID"
    ],
    "21378": [
        "Superficial_Veins_of_the_Left_Leg_21378_ID",
        "Superficial_Veins_of_the_Right_Leg_21378_ID"
    ],
    "21379": [
        "Right_Great_Saphenous_Vein_21379_ID"
    ],
    "21380": [
        "Left_Great_Saphenous_Vein_21380_ID"
    ],
    "21422": [
        "Descending_branch_of_right_lateral_circumflex_femoral_artery_21422_ID"
    ],
    "21423": [
        "Descending_branch_of_left_lateral_circumflex_femoral_artery_21423_ID"
    ],
    "21863": [
        "Right_Pudendal_nerve_21863_ID"
    ],
    "21864": [
        "Left_Pudendal_nerve_21864_ID"
    ],
    "21919": [
        "Right_superficial_transverse_perineal_muscle_21919_ID"
    ],
    "21920": [
        "Left_superficial_transverse_perineal_muscle_21920_ID"
    ],
    "21921": [
        "Right_bulbospongiosus_21921_ID"
    ],
    "21922": [
        "Left_bulbospongiosus_21922_ID"
    ],
    "21923": [
        "Right_ischiocavernosus_21923_ID"
    ],
    "21924": [
        "Left_ischiocavernosus_21924_ID"
    ],
    "21930": [
        "External_Anal_Sphincter_21930_ID"
    ],
    "22109": [
        "Right_Tibial_nerve_22109_ID"
    ],
    "22110": [
        "Left_Tibial_nerve_22110_ID"
    ],
    "22111": [
        "Right_sciatic_nerve_22111_ID"
    ],
    "22112": [
        "Left_sciatic_nerve_22112_ID"
    ],
    "22171": [
        "Right_inferior_ulnar_collateral_artery_22171_ID"
    ],
    "22172": [
        "right_inferior_ulnar_collateral_artery_22172_ID",
        "left_inferior_ulnar_collateral_artery_22172_ID"
    ],
    "22322": [
        "Right_Iliacus_22322_ID"
    ],
    "22323": [
        "Left_Iliacus_22323_ID"
    ],
    "22324": [
        "Right_Obturator_Internus_22324_ID"
    ],
    "22325": [
        "Left_Obturator_Internus_22325_ID"
    ],
    "22326": [
        "Right_Obturator_externus_22326_ID"
    ],
    "22327": [
        "Left_Obturator_externus_22327_ID"
    ],
    "22328": [
        "Right_gluteus_maximus_22328_ID"
    ],
    "22329": [
        "Left_gluteus_maximus_22329_ID"
    ],
    "22330": [
        "Right_gluteus_medius_22330_ID"
    ],
    "22331": [
        "Left_gluteus_medius_22331_ID"
    ],
    "22332": [
        "Right_Gluteus_minimus_22332_ID"
    ],
    "22333": [
        "Left_Gluteus_minimus_22333_ID"
    ],
    "22334": [
        "Right_superior_gemellus_22334_ID"
    ],
    "22335": [
        "Left_superior_gemellus_22335_ID"
    ],
    "22336": [
        "Right_inferior_gemellus_22336_ID"
    ],
    "22337": [
        "Left_inferior_gemellus_22337_ID"
    ],
    "22338": [
        "Right_Quadratus_femoris_22338_ID"
    ],
    "22339": [
        "Left_Quadratus_femoris_22339_ID"
    ],
    "22340": [
        "Right_Piriformis_22340_ID"
    ],
    "22341": [
        "Left_Piriformis_22341_ID"
    ],
    "22342": [
        "Right_Psoas_Major_22342_ID"
    ],
    "22343": [
        "Left_Psoas_Major_22343_ID"
    ],
    "22344": [
        "Right_Transversus_abdominis_22344_ID"
    ],
    "22345": [
        "Left_Transversus_abdominis_22345_ID"
    ],
    "22348": [
        "Right_Quadratus_lumborum_22348_ID"
    ],
    "22349": [
        "Left_Quadratus_lumborum_22349_ID"
    ],
    "22351": [
        "Right_Psoas_Minor_22351_ID"
    ],
    "22352": [
        "Left_Psoas_Minor_22352_ID"
    ],
    "22354": [
        "Right_Sartorius_22354_ID"
    ],
    "22355": [
        "Left_Sartorius_22355_ID"
    ],
    "22358": [
        "Right_Semitendinosus_22358_ID"
    ],
    "22359": [
        "Left_Semitendinosus_22359_ID"
    ],
    "22360": [
        "Right_Biceps_Femoris_22360_ID"
    ],
    "22361": [
        "Left_Biceps_Femoris_22361_ID"
    ],
    "22425": [
        "Right_Tensor_Fasciae_Latae_22425_ID"
    ],
    "22426": [
        "Left_Tensor_Fasciae_Latae_22426_ID"
    ],
    "22444": [
        "Right_quadriceps_femoris_22444_ID"
    ],
    "22445": [
        "Left_quadriceps_femoris_22445_ID"
    ],
    "22446": [
        "Right_Articularis_Genus_22446_ID"
    ],
    "22447": [
        "Left_Articularis_Genus_22447_ID"
    ],
    "22448": [
        "Right_Semimembranosus_22448_ID"
    ],
    "22449": [
        "Left_Semimembranosus_22449_ID"
    ],
    "22450": [
        "Right_Pectineus_22450_ID"
    ],
    "22451": [
        "Left_Pectineus_22451_ID"
    ],
    "22456": [
        "Right_Adductor_Longus_22456_ID"
    ],
    "22457": [
        "Right_Adductor_Longus_22457_ID",
        "Left_Adductor_Longus_22457_ID"
    ],
    "22458": [
        "Left_Adductor_Longus_22458_ID"
    ],
    "22459": [
        "Right_Adductor_Magnus_22459_ID"
    ],
    "22460": [
        "Left_Adductor_Magnus_22460_ID"
    ],
    "22507": [
        "Right_descending_genicular_artery_22507_ID"
    ],
    "22508": [
        "Left_descending_genicular_artery_22508_ID"
    ],
    "22539": [
        "Right_Fibularis_tertius_22539_ID",
        "Left_Fibularis_tertius_22539_ID"
    ],
    "22545": [
        "Right_Tibialis_anterior_22545_ID",
        "Left_Tibialis_anterior_22545_ID"
    ],
    "22547": [
        "Left_Extensor_hallucis_longus_22547_ID",
        "Right_Extensor_hallucis_longus_22547_ID"
    ],
    "22548": [
        "Right_Extensor_hallucis_longus_22548_ID",
        "Left_Extensor_hallucis_longus_22548_ID"
    ],
    "22549": [
        "Right_extensor_digitorum_longus_22549_ID",
        "Left_extensor_digitorum_longus_22549_ID"
    ],
    "22551": [
        "Right_Fibularis_tertius_22551_ID",
        "Left_Fibularis_tertius_22551_ID"
    ],
    "22553": [
        "Right_Fibularis_longus_22553_ID",
        "Left_Fibularis_longus_22553_ID"
    ],
    "22555": [
        "Left_Fibularis_brevis_22555_ID",
        "Right_Fibularis_brevis_22555_ID"
    ],
    "22556": [
        "Right_Gastrocnemius_22556_ID"
    ],
    "22557": [
        "Left_Gastrocnemius_22557_ID"
    ],
    "22559": [
        "Right_Soleus_22559_ID",
        "Left_Soleus_22559_ID"
    ],
    "22561": [
        "Left_Plantaris_22561_ID",
        "Right_Plantaris_22561_ID"
    ],
    "22586": [
        "Right_superior_medial_genicular_artery_22586_ID"
    ],
    "22587": [
        "Left_superior_medial_genicular_artery_22587_ID"
    ],
    "22588": [
        "Right_superior_lateral_genicular_artery_22588_ID"
    ],
    "22589": [
        "Left_superior_lateral_genicular_artery_22589_ID"
    ],
    "22592": [
        "Right_Popliteus_22592_ID",
        "Left_Popliteus_22592_ID"
    ],
    "22655": [
        "Right_Axillary_artery_22655_ID"
    ],
    "22656": [
        "Left_Axillary_artery_22656_ID",
        "Right_Axillary_artery_22656_ID"
    ],
    "22669": [
        "right_superior_thoracic_artery_22669_ID"
    ],
    "22670": [
        "left_superior_thoracic_artery_22670_ID"
    ],
    "22675": [
        "Right_lateral_thoracic_artery_22675_ID"
    ],
    "22676": [
        "right_lateral_thoracic_artery_22676_ID",
        "left_lateral_thoracic_artery_22676_ID"
    ],
    "22679": [
        "Right_subscapular_artery_22679_ID"
    ],
    "22680": [
        "left_subscapular_artery_22680_ID",
        "right_subscapular_artery_22680_ID"
    ],
    "22682": [
        "Right_anterior_humeral_circumflex_artery_22682_ID"
    ],
    "22683": [
        "right_anterior_humeral_circumflex_artery_22683_ID",
        "left_anterior_humeral_circumflex_artery_22683_ID"
    ],
    "22686": [
        "Right_posterior_humeral_circumflex_artery_22686_ID"
    ],
    "22687": [
        "left_posterior_humeral_circumflex_artery_22687_ID",
        "right_posterior_humeral_circumflex_artery_22687_ID"
    ],
    "22691": [
        "Right_brachial_artery_22691_ID"
    ],
    "22692": [
        "right_brachial_artery_22692_ID",
        "left_brachial_artery_22692_ID"
    ],
    "22696": [
        "Right_deep_brachial_artery_22696_ID"
    ],
    "22697": [
        "right_deep_brachial_artery_22697_ID",
        "left_deep_brachial_artery_22697_ID"
    ],
    "22707": [
        "Right_superior_ulnar_collateral_artery_22707_ID"
    ],
    "22708": [
        "right_superior_ulnar_collateral_artery_22708_ID",
        "left_superior_ulnar_collateral_artery_22708_ID"
    ],
    "22726": [
        "Right_Splenius_cervicis_22726_ID"
    ],
    "22727": [
        "Left_Splenius_cervicis_22727_ID"
    ],
    "22728": [
        "Right_Splenius_capitis_22728_ID"
    ],
    "22729": [
        "Left_Splenius_capitis_22729_ID"
    ],
    "22733": [
        "Right_radial_artery_22733_ID"
    ],
    "22734": [
        "Right_radial_artery_22734_ID",
        "Left_radial_artery_22734_ID"
    ],
    "22740": [
        "Right_Iliocostalis_Lumborum_22740_ID"
    ],
    "22741": [
        "Left_Iliocostalis_Lumborum_22741_ID"
    ],
    "22742": [
        "Right_Iliocostalis_Thoracis_22742_ID"
    ],
    "22743": [
        "Left_Iliocostalis_Thoracis_22743_ID"
    ],
    "22744": [
        "Right_Iliocostalis_Cervicis_22744_ID"
    ],
    "22745": [
        "Left_Iliocostalis_Cervicis_22745_ID"
    ],
    "22751": [
        "Right_Longissimus_Thoracis_22751_ID"
    ],
    "22753": [
        "Left_Longissimus_Thoracis_22753_ID"
    ],
    "22754": [
        "Right_Longissimus_Capitis_22754_ID"
    ],
    "22756": [
        "Left_Longissimus_Capitis_22756_ID"
    ],
    "22757": [
        "Right_Longissimus_Cervicis_22757_ID"
    ],
    "22758": [
        "Left_Longissimus_Cervicis_22758_ID"
    ],
    "22765": [
        "Right_radial_recurrent_artery_22765_ID"
    ],
    "22766": [
        "left_radial_recurrent_artery_22766_ID",
        "right_radial_recurrent_artery_22766_ID"
    ],
    "22772": [
        "dorsal_carpal_branch_of_Right_radial_artery_22772_ID"
    ],
    "22773": [
        "dorsal_carpal_branch_of_left_radial_artery_22773_ID",
        "dorsal_carpal_branch_of_right_radial_artery_22773_ID"
    ],
    "22779": [
        "Right_Spinalis_Thoracis_22779_ID"
    ],
    "22780": [
        "Left_Spinalis_Thoracis_22780_ID"
    ],
    "22781": [
        "Right_Spinalis_Cervicis_22781_ID"
    ],
    "22782": [
        "Left_Spinalis_Cervicis_22782_ID"
    ],
    "22783": [
        "Right_Spinalis_Capitis_22783_ID"
    ],
    "22784": [
        "Left_Spinalis_Capitis_22784_ID"
    ],
    "22798": [
        "Right_ulnar_artery_22798_ID",
        "Left_ulnar_artery_22798_ID"
    ],
    "22801": [
        "Right_anterior_ulnar_recurrent_artery_22801_ID"
    ],
    "22802": [
        "right_anterior_ulnar_recurrent_artery_22802_ID",
        "left_anterior_ulnar_recurrent_artery_22802_ID"
    ],
    "22804": [
        "Right_posterior_ulnar_recurrent_artery_22804_ID"
    ],
    "22805": [
        "right_posterior_ulnar_recurrent_artery_22805_ID",
        "left_posterior_ulnar_recurrent_artery_22805_ID"
    ],
    "22807": [
        "Right_common_interosseous_artery_22807_ID"
    ],
    "22808": [
        "left_common_interosseous_artery_22808_ID",
        "right_common_interosseous_artery_22808_ID"
    ],
    "22812": [
        "Right_anterior_interosseous_artery_22812_ID"
    ],
    "22813": [
        "left_anterior_interosseous_artery_22813_ID",
        "right_anterior_interosseous_artery_22813_ID"
    ],
    "22821": [
        "dorsal_carpal_branch_of_Right_ulnar_artery_22821_ID"
    ],
    "22822": [
        "dorsal_carpal_branch_of_left_ulnar_artery_22822_ID",
        "dorsal_carpal_branch_of_right_ulnar_artery_22822_ID"
    ],
    "22836": [
        "Right_superficial_palmar_arch_22836_ID"
    ],
    "22837": [
        "left_superficial_palmar_arch_22837_ID",
        "right_superficial_palmar_arch_22837_ID"
    ],
    "22839": [
        "Right_deep_palmar_arterial_arch_22839_ID"
    ],
    "22840": [
        "left_deep_palmar_venous_arch_22840_ID",
        "right_deep_palmar_venous_arch_22840_ID",
        "right_deep_palmar_arterial_arch_22840_ID",
        "left_deep_palmar_arterial_arch_22840_ID",
        "right_deep_palmar_arch_22840_ID",
        "left_deep_palmar_arch_22840_ID"
    ],
    "22872": [
        "Right_Semispinalis_thoracis_22872_ID"
    ],
    "22873": [
        "Left_Semispinalis_thoracis_22873_ID"
    ],
    "22874": [
        "Right_Semispinalis_cervicis_22874_ID"
    ],
    "22875": [
        "Left_Semispinalis_cervicis_22875_ID"
    ],
    "22876": [
        "Right_Semispinalis_capitis_22876_ID"
    ],
    "22877": [
        "Left_Semispinalis_capitis_22877_ID"
    ],
    "22878": [
        "Right_Multifidus_22878_ID"
    ],
    "22879": [
        "Left_Multifidus_22879_ID"
    ],
    "22909": [
        "Right_basilic_vein_22909_ID"
    ],
    "22910": [
        "right_basilic_vein_22910_ID",
        "left_basilic_vein_22910_ID",
        "Left_basilic_vein_22910_ID"
    ],
    "22920": [
        "Right_palmar_metacarpal_veins_22920_ID"
    ],
    "22921": [
        "right_palmar_metacarpal_veins_22921_ID",
        "left_palmar_metacarpal_veins_22921_ID"
    ],
    "22935": [
        "Right_medial_brachial_vein_22935_ID"
    ],
    "22936": [
        "right_medial_brachial_vein_22936_ID",
        "left_medial_brachial_vein_22936_ID"
    ],
    "22948": [
        "Right_radial_vein_22948_ID"
    ],
    "22949": [
        "left_radial_vein_22949_ID",
        "right_radial_vein_22949_ID"
    ],
    "22951": [
        "right_ulnar_vein_22951_ID"
    ],
    "22952": [
        "right_ulnar_vein_22952_ID",
        "left_ulnar_vein_22952_ID"
    ],
    "22964": [
        "Right_median_cubital_vein_22964_ID"
    ],
    "22965": [
        "right_median_cubital_vein_22965_ID",
        "left_median_cubital_vein_22965_ID"
    ],
    "22968": [
        "Right_median_antebrachial_vein_22968_ID"
    ],
    "22969": [
        "left_median_antebrachial_vein_22969_ID",
        "right_median_antebrachial_vein_22969_ID"
    ],
    "23111": [
        "Right_deep_dorsal_vein_23111_ID"
    ],
    "23112": [
        "right_deep_dorsal_vein_23112_ID",
        "left_deep_dorsal_vein_23112_ID"
    ],
    "23123": [
        "Right_medial_collateral_artery_23123_ID"
    ],
    "23124": [
        "right_medial_collateral_artery_23124_ID",
        "left_medial_collateral_artery_23124_ID"
    ],
    "23126": [
        "Right_radial_collateral_artery_23126_ID"
    ],
    "23127": [
        "right_radial_collateral_artery_23127_ID",
        "left_radial_collateral_artery_23127_ID"
    ],
    "23130": [
        "Right_Humerus_23130_ID",
        "Left_Humerus_23130_ID"
    ],
    "23180": [
        "Right_circumflex_scapular_artery_23180_ID"
    ],
    "23181": [
        "right_circumflex_scapular_artery_23181_ID",
        "left_circumflex_scapular_artery_23181_ID"
    ],
    "23464": [
        "Left_radius_23464_ID",
        "Right_radius_23464_ID"
    ],
    "23467": [
        "Left_Ulna_23467_ID",
        "Right_Ulna_23467_ID"
    ],
    "23707": [
        "Right_Interosseous_membrane_23707_ID"
    ],
    "23708": [
        "Left_Interosseous_membrane_23708_ID"
    ],
    "24160": [
        "Bones_of_the_Right_Arm_24160_ID"
    ],
    "24162": [
        "Bones_of_the_Left_Arm_24162_ID"
    ],
    "24435": [
        "Right_scaphoid_bone_24435_ID",
        "Left_scaphoid_bone_24435_ID"
    ],
    "24437": [
        "Left_lunate_bone_24437_ID",
        "Right_lunate_bone_24437_ID"
    ],
    "24439": [
        "Left_triquetral_bone_24439_ID",
        "Right_triquetral_bone_24439_ID"
    ],
    "24441": [
        "Right_pisiform_24441_ID",
        "Left_pisiform_24441_ID"
    ],
    "24443": [
        "Right_trapezium_24443_ID",
        "Left_trapezium_24443_ID"
    ],
    "24444": [
        "Right_trapezoid_bone_24444_ID",
        "Left_trapezoid_bone_24444_ID"
    ],
    "24446": [
        "Right_capitate_bone_24446_ID",
        "Left_capitate_bone_24446_ID"
    ],
    "24448": [
        "Left_hamate_bone_24448_ID",
        "Right_hamate_bone_24448_ID"
    ],
    "24474": [
        "Right_femur_24474_ID"
    ],
    "24475": [
        "Left_femur_24475_ID"
    ],
    "24477": [
        "Right_tibia_24477_ID"
    ],
    "24478": [
        "Right_tibia_24478_ID",
        "Left_tibia_24478_ID"
    ],
    "24480": [
        "Right_fibula_24480_ID"
    ],
    "24481": [
        "Right_fibula_24481_ID",
        "Left_fibula_24481_ID"
    ],
    "24482": [
        "Right_talus_24482_ID"
    ],
    "24483": [
        "Right_talus_24483_ID",
        "Left_talus_24483_ID"
    ],
    "24486": [
        "Right_patella_24486_ID"
    ],
    "24487": [
        "Right_patella_24487_ID",
        "Left_patella_24487_ID"
    ],
    "24497": [
        "Right_calcaneus_24497_ID"
    ],
    "24498": [
        "Right_calcaneus_24498_ID",
        "Left_calcaneus_24498_ID"
    ],
    "24500": [
        "Navicular_bone_of_right_foot_24500_ID"
    ],
    "24501": [
        "Navicular_of_right_foot_24501_ID",
        "Navicular_of_left_foot_24501_ID",
        "Navicular_bone_of_left_foot_24501_ID"
    ],
    "24521": [
        "Right_medial_Cuneiform_bone_24521_ID"
    ],
    "24522": [
        "Left_medial_Cuneiform_bone_24522_ID",
        "Right_medial_Cuneiform_bone_24522_ID"
    ],
    "24523": [
        "Right_intermediate_Cuneiform_bone_24523_ID"
    ],
    "24524": [
        "Right_intermediate_Cuneiform_bone_24524_ID",
        "Left_intermediate_Cuneiform_bone_24524_ID"
    ],
    "24525": [
        "Right_lateral_Cuneiform_bone_24525_ID"
    ],
    "24526": [
        "Right_lateral_Cuneiform_bone_24526_ID",
        "Left_lateral_Cuneiform_bone_24526_ID"
    ],
    "24528": [
        "Right_cuboid_bone_24528_ID"
    ],
    "24529": [
        "Left_cuboid_bone_24529_ID",
        "Right_cuboid_bone_24529_ID"
    ],
    "25005": [
        "Anterior_atlanto_occipital_membrane_25005_ID",
        "Anterior_atlantooccipital_membrane_25005_ID"
    ],
    "29711": [
        "Prostatic_venous_plexus_29711_ID"
    ],
    "31893": [
        "Anterior_longitudinal_ligament_31893_ID"
    ],
    "32530": [
        "Right_Rectus_capitis_posterior_major_32530_ID"
    ],
    "32531": [
        "Left_Rectus_Capitis_posterior_major_32531_ID"
    ],
    "32532": [
        "Right_Rectus_capitis_posterior_minor_32532_ID"
    ],
    "32533": [
        "Left_Rectus_capitis_posterior_minor_32533_ID",
        "Right_Rectus_Capitis_posterior_major_32533_ID"
    ],
    "32535": [
        "Right_Rectus_capitis_posterior_minor_32535_ID"
    ],
    "32540": [
        "Right_Levator_Scapulae_32540_ID",
        "Right_Levator_scapulae_32540_ID"
    ],
    "32541": [
        "Left_Levator_scapulae_32541_ID"
    ],
    "32542": [
        "Right_Deltoid_32542_ID"
    ],
    "32543": [
        "Left_Deltoid_32543_ID",
        "Right_Deltoid_32543_ID"
    ],
    "32544": [
        "Right_supraspinatus_32544_ID",
        "Right_Supraspinatus_32544_ID"
    ],
    "32545": [
        "Left_Supraspinatus_32545_ID"
    ],
    "32547": [
        "Right_infraspinatus_32547_ID"
    ],
    "32548": [
        "Left_infraspinatus_32548_ID"
    ],
    "32551": [
        "Right_Teres_Major_32551_ID"
    ],
    "32552": [
        "Left_Teres_Major_32552_ID"
    ],
    "32553": [
        "Right_teres_minor_32553_ID"
    ],
    "32554": [
        "Left_teres_minor_32554_ID"
    ],
    "33098": [
        "Right_Rotatores_short_fibers_33098_ID",
        "Right_Rotatores_long_fibers_33098_ID"
    ],
    "33099": [
        "Left_Rotatores_long_fibers_33099_ID",
        "Left_Rotatores_short_fibers_33099_ID"
    ],
    "33520": [
        "Right_pectoral_girdle_muscles_33520_ID"
    ],
    "33521": [
        "Left_pectoral_girdle_muscles_33521_ID",
        "Right_pectoral_girdle_muscles_33521_ID"
    ],
    "37318": [
        "Right_ulnar_nerve_37318_ID"
    ],
    "37319": [
        "Left_ulnar_nerve_37319_ID"
    ],
    "37386": [
        "Right_Abductor_pollicis_brevis_37386_ID"
    ],
    "37387": [
        "Left_Abductor_pollicis_brevis_37387_ID"
    ],
    "37388": [
        "Right_Flexor_pollicis_brevis_37388_ID"
    ],
    "37389": [
        "Left_Flexor_pollicis_brevis_37389_ID"
    ],
    "37390": [
        "Right_Opponens_pollicis_37390_ID"
    ],
    "37391": [
        "Left_Opponens_pollicis_37391_ID"
    ],
    "37392": [
        "Right_Adductor_pollicis_37392_ID"
    ],
    "37393": [
        "Left_Adductor_pollicis_37393_ID",
        "Right_Palmaris_brevis_37393_ID"
    ],
    "37395": [
        "Left_Palmaris_brevis_37395_ID"
    ],
    "37396": [
        "Right_Abductor_digiti_minimi_37396_ID"
    ],
    "37397": [
        "Left_Abductor_digiti_minimi_37397_ID"
    ],
    "37398": [
        "Right_Flexor_digiti_minimi_brevis_37398_ID"
    ],
    "37399": [
        "Left_Flexor_digiti_minimi_brevis_37399_ID"
    ],
    "37400": [
        "Right_Opponens_digiti_minimi_37400_ID"
    ],
    "37401": [
        "Left_Opponens_digiti_minimi_37401_ID"
    ],
    "37460": [
        "Right_Abductor_hallucis_37460_ID",
        "Left_Abductor_hallucis_37460_ID"
    ],
    "37462": [
        "Right_Flexor_digiti_minimi_brevis_37462_ID",
        "Left_Flexor_digiti_minimi_brevis_37462_ID"
    ],
    "37464": [
        "Abductor_digiti_minimi_of_right_foot_37464_ID",
        "Abductor_digiti_minimi_of_left_foot_37464_ID"
    ],
    "37468": [
        "Left_Flexor_hallucis_brevis_37468_ID",
        "Right_Flexor_hallucis_brevis_37468_ID"
    ],
    "37470": [
        "Left_Adductor_hallucis_37470_ID",
        "Left_Adductor_hallucis_oblique_head_37470_ID",
        "Left_Adductor_hallucis_transverse_head_37470_ID",
        "Right_Adductor_hallucis_37470_ID",
        "Right_Adductor_hallucis_oblique_head_37470_ID",
        "Right_Adductor_hallucis_transverse_head_37470_ID"
    ],
    "37665": [
        "Right_Coracobrachialis_37665_ID"
    ],
    "37666": [
        "Left_Coracobrachialis_37666_ID",
        "Right_Coracobrachialis_37666_ID"
    ],
    "37668": [
        "Right_Brachialis_37668_ID"
    ],
    "37669": [
        "Left_Brachialis_37669_ID"
    ],
    "37671": [
        "Right_Biceps_Brachii_37671_ID"
    ],
    "37672": [
        "Right_Biceps_Brachii_37672_ID",
        "Left_Biceps_Brachii_37672_ID"
    ],
    "37689": [
        "Right_Triceps_Brachii_37689_ID"
    ],
    "37690": [
        "Right_Triceps_Brachii_37690_ID",
        "Left_Triceps_Brachii_37690_ID"
    ],
    "37705": [
        "Right_anconeus_37705_ID"
    ],
    "37706": [
        "Left_anconeus_37706_ID",
        "Right_anconeus_37706_ID"
    ],
    "38451": [
        "Right_Pronator_teres_38451_ID"
    ],
    "38452": [
        "Left_Pronator_teres_38452_ID"
    ],
    "38454": [
        "Right_Pronator_quadratus_38454_ID"
    ],
    "38455": [
        "Left_Pronator_quadratus_38455_ID"
    ],
    "38460": [
        "Right_Flexor_carpi_radialis_longus_38460_ID"
    ],
    "38461": [
        "Left_Flexor_carpi_radialis_longus_38461_ID"
    ],
    "38463": [
        "Right_Palmaris_longus_38463_ID"
    ],
    "38464": [
        "Left_Palmaris_longus_38464_ID"
    ],
    "38466": [
        "Right_Flexor_carpi_ulnaris_38466_ID"
    ],
    "38467": [
        "Left_Flexor_carpi_ulnaris_38467_ID"
    ],
    "38483": [
        "Right_flexor_pollicis_longus_38483_ID"
    ],
    "38484": [
        "Left_flexor_pollicis_longus_38484_ID"
    ],
    "38486": [
        "Right_Brachioradialis_38486_ID"
    ],
    "38487": [
        "Left_Brachioradialis_38487_ID"
    ],
    "38495": [
        "Right_Extensor_carpi_radialis_longus_38495_ID"
    ],
    "38496": [
        "Left_Extensor_carpi_radialis_longus_38496_ID"
    ],
    "38498": [
        "Right_Extensor_carpi_radialis_brevis_38498_ID"
    ],
    "38499": [
        "Left_Extensor_carpi_radialis_brevis_38499_ID"
    ],
    "38504": [
        "Right_Extensor_digiti_minimi_38504_ID"
    ],
    "38505": [
        "Left_Extensor_digiti_minimi_38505_ID"
    ],
    "38507": [
        "Right_Extensor_carpi_ulnaris_38507_ID"
    ],
    "38508": [
        "Left_Extensor_carpi_ulnaris_38508_ID"
    ],
    "38513": [
        "Right_Supinator_38513_ID"
    ],
    "38514": [
        "Left_Supinator_38514_ID"
    ],
    "38516": [
        "Right_Abductor_pollicis_longus_38516_ID"
    ],
    "38517": [
        "Left_Abductor_pollicis_longus_38517_ID"
    ],
    "38519": [
        "Right_Extensor_pollicis_brevis_38519_ID"
    ],
    "38520": [
        "Left_Extensor_pollicis_brevis_38520_ID"
    ],
    "38522": [
        "Right_Extensor_pollicis_longus_38522_ID"
    ],
    "38523": [
        "Left_Extensor_pollicis_longus_38523_ID"
    ],
    "38525": [
        "Right_Extensor_indicis_38525_ID"
    ],
    "38526": [
        "Left_Extensor_indicis_38526_ID"
    ],
    "38928": [
        "Right_Rectus_Femoris_38928_ID"
    ],
    "38929": [
        "Left_Rectus_Femoris_38929_ID"
    ],
    "38930": [
        "Right_Vastus_Lateralis_38930_ID"
    ],
    "38931": [
        "Left_Vastus_Lateralis_38931_ID"
    ],
    "38932": [
        "Right_Vastus_Medialis_38932_ID"
    ],
    "38933": [
        "Left_Vastus_Medialis_38933_ID"
    ],
    "38934": [
        "Right_Vastus_Intermedius_38934_ID"
    ],
    "38935": [
        "Left_Vastus_Intermedius_38935_ID"
    ],
    "39091": [
        "Left_forearm_muscles_39091_ID"
    ],
    "39092": [
        "Right_forearm_muscles_39092_ID"
    ],
    "39987": [
        "Right_Extensor_retinaculum_of_hand_39987_ID",
        "Left_Extensor_retinaculum_of_hand_39987_ID"
    ],
    "39988": [
        "Right_Flexor_retinaculum_of_hand_39988_ID",
        "Left_Flexor_retinaculum_of_hand_39988_ID"
    ],
    "42313": [
        "Right_Pisohamate_Ligament_42313_ID",
        "Left_Pisohamate_Ligament_42313_ID"
    ],
    "42369": [
        "Right_hand_muscles_42369_ID"
    ],
    "42370": [
        "Left_hand_muscles_42370_ID"
    ],
    "43883": [
        "Right_Gracilis_43883_ID"
    ],
    "43884": [
        "Left_Gracilis_43884_ID"
    ],
    "43890": [
        "Right_inferior_medial_genicular_artery_43890_ID"
    ],
    "43891": [
        "Left_inferior_medial_genicular_artery_43891_ID",
        "Right_inferior_medial_genicular_artery_43891_ID"
    ],
    "43892": [
        "Right_inferior_lateral_genicular_artery_43892_ID"
    ],
    "43893": [
        "Left_inferior_lateral_genicular_artery_43893_ID"
    ],
    "43896": [
        "Right_anterior_tibial_artery_43896_ID"
    ],
    "43897": [
        "Right_anterior_tibial_artery_43897_ID",
        "Left_anterior_tibial_artery_43897_ID"
    ],
    "43898": [
        "Left_anterior_tibial_artery_43898_ID",
        "Right_posterior_tibial_artery_43898_ID"
    ],
    "43899": [
        "Left_posterior_tibial_artery_43899_ID"
    ],
    "43907": [
        "Right_anterior_tibial_recurrent_artery_43907_ID"
    ],
    "43908": [
        "Left_anterior_tibial_recurrent_artery_43908_ID"
    ],
    "43916": [
        "Right_dorsalis_pedis_artery_43916_ID"
    ],
    "43917": [
        "Left_dorsalis_pedis_artery_43917_ID"
    ],
    "43922": [
        "Right_fibular_artery_43922_ID"
    ],
    "43923": [
        "Left_fibular_artery_43923_ID"
    ],
    "43929": [
        "Right_medial_plantar_artery_43929_ID"
    ],
    "43930": [
        "Left_medial_plantar_artery_43930_ID"
    ],
    "43931": [
        "Right_lateral_plantar_artery_43931_ID"
    ],
    "43932": [
        "Left_lateral_plantar_artery_43932_ID"
    ],
    "43935": [
        "Right_deep_medial_plantar_artery_43935_ID"
    ],
    "43936": [
        "Left_deep_medial_plantar_artery_43936_ID"
    ],
    "43943": [
        "Right_plantar_arch_43943_ID"
    ],
    "43944": [
        "Left_plantar_arch_43944_ID"
    ],
    "43950": [
        "Calcaneal_branch_of_right_fibular_artery_43950_ID"
    ],
    "43951": [
        "Calcaneal_branch_of_left_fibular_artery_43951_ID"
    ],
    "44227": [
        "Left_Popliteal_Lymph_Nodes_44227_ID",
        "Right_Popliteal_Lymph_Nodes_44227_ID"
    ],
    "44249": [
        "Right_Long_plantar_ligament_44249_ID",
        "Left_Long_plantar_ligament_44249_ID"
    ],
    "44310": [
        "Lymphatics_of_the_Lower_Limb_44310_ID"
    ],
    "44326": [
        "Descending_branch_of_right_lateral_circumflex_femoral_Vein_44326_ID"
    ],
    "44327": [
        "Descending_branch_of_left_lateral_circumflex_femoral_Vein_44327_ID"
    ],
    "44328": [
        "Right_Popliteal_vein_44328_ID"
    ],
    "44329": [
        "Left_Popliteal_vein_44329_ID"
    ],
    "44334": [
        "Right_small_saphenous_vein_44334_ID"
    ],
    "44335": [
        "Left_small_saphenous_vein_44335_ID"
    ],
    "44336": [
        "Right_Anterior_Tibial_Vein_44336_ID"
    ],
    "44337": [
        "Left_Anterior_Tibial_Vein_44337_ID"
    ],
    "44338": [
        "Right_Posterior_Tibial_Vein_44338_ID"
    ],
    "44339": [
        "Left_Posterior_Tibial_Vein_44339_ID"
    ],
    "44340": [
        "Right_superficial_epigastric_vein_44340_ID"
    ],
    "44341": [
        "Left_superficial_epigastric_vein_44341_ID"
    ],
    "44583": [
        "Right_Oblique_Popliteal_Ligament_44583_ID"
    ],
    "44584": [
        "Left_Oblique_Popliteal_Ligament_44584_ID"
    ],
    "44585": [
        "Right_Patellar_Ligament_44585_ID"
    ],
    "44586": [
        "Left_Patellar_Ligament_44586_ID"
    ],
    "44597": [
        "Right_Arcuate_Popliteal_Ligament_44597_ID"
    ],
    "44599": [
        "Left_Arcuate_Popliteal_Ligament_44599_ID"
    ],
    "44601": [
        "Right_Tibial_Collateral_Ligament_44601_ID"
    ],
    "44602": [
        "Left_Tibial_Collateral_Ligament_44602_ID"
    ],
    "44609": [
        "Right_Fibular_Collateral_Ligament_44609_ID"
    ],
    "44610": [
        "Left_Fibular_Collateral_Ligament_44610_ID"
    ],
    "44615": [
        "Right_Anterior_Cruciate_Ligament_44615_ID"
    ],
    "44616": [
        "Left_Anterior_Cruciate_Ligament_44616_ID"
    ],
    "44618": [
        "Right_Posterior_Cruciate_Ligament_44618_ID"
    ],
    "44619": [
        "Left_Posterior_Cruciate_Ligament_44619_ID"
    ],
    "44741": [
        "Right_proper_plantar_digital_nerves_44741_ID"
    ],
    "44742": [
        "Left_proper_plantar_digital_nerves_44742_ID"
    ],
    "44874": [
        "Right_dorsal_branch_of_ulnar_nerve_44874_ID"
    ],
    "44875": [
        "Left_dorsal_branch_of_ulnar_nerve_44875_ID"
    ],
    "44881": [
        "Branch_of_Dorsal_venous_arch_of_Right_foot_44881_ID",
        "Right_Dorsalis_pedis_vein_44881_ID",
        "Dorsal_venous_arch_of_Right_foot_44881_ID"
    ],
    "44882": [
        "Branch_of_Dorsal_venous_arch_of_Left_foot_44882_ID",
        "Dorsal_venous_arch_of_Left_foot_44882_ID",
        "Left_Dorsalis_pedis_vein_44882_ID"
    ],
    "44883": [
        "Medial_branch_of_Plantar_venous_arch_of_right_foot_44883_ID",
        "Plantar_venous_arch_of_Right_foot_44883_ID",
        "Lateral_branch_of_Plantar_venous_arch_of_right_foot_44883_ID"
    ],
    "44884": [
        "Medial_branch_of_Plantar_venous_arch_of_left_foot_44884_ID",
        "Lateral_branch_of_Plantar_venous_arch_of_left_foot_44884_ID",
        "Plantar_venous_arch_of_Left_foot_44884_ID"
    ],
    "44885": [
        "Right_Fibular_vein_44885_ID"
    ],
    "44886": [
        "Left_Fibular_vein_44886_ID"
    ],
    "44887": [
        "Right_Superior_Medial_Genicular_vein_44887_ID",
        "Right_Genicular_Veins_44887_ID",
        "Right_Inferior_Medial_Genicular_Vein_44887_ID",
        "Right_Superior_Lateral_Genicular_vein_44887_ID",
        "Right_Inferior_Lateral_Genicular_Vein_44887_ID"
    ],
    "44888": [
        "Left_Inferior_Lateral_Genicular_Vein_44888_ID",
        "Left_Genicular_Veins_44888_ID",
        "Left_Inferior_Medial_Genicular_Vein_44888_ID",
        "Left_Superior_Medial_Genicular_vein_44888_ID",
        "Left_Superior_Lateral_Genicular_vein_44888_ID"
    ],
    "44918": [
        "Right_medial_circumflex_femoral_vein_44918_ID"
    ],
    "44919": [
        "Left_medial_circumflex_femoral_vein_44919_ID"
    ],
    "44920": [
        "Right_lateral_circumflex_femoral_vein_44920_ID"
    ],
    "44922": [
        "Left_lateral_circumflex_femoral_vein_44922_ID"
    ],
    "45257": [
        "Right_Intermediate_Femoral_Cutaneous_Nerve_45257_ID"
    ],
    "45258": [
        "Left_Intermediate_Femoral_Cutaneous_Nerve_45258_ID"
    ],
    "45263": [
        "Right_saphenous_nerve_45263_ID"
    ],
    "45264": [
        "Left_saphenous_nerve_45264_ID"
    ],
    "45338": [
        "Right_Posterior_femoral_cutaneous_nerve_45338_ID"
    ],
    "45339": [
        "Left_Posterior_femoral_cutaneous_nerve_45339_ID"
    ],
    "45357": [
        "Right_common_fibular_nerve_45357_ID"
    ],
    "45358": [
        "Left_common_fibular_nerve_45358_ID"
    ],
    "45363": [
        "Right_superficial_fibular_nerve_45363_ID"
    ],
    "45364": [
        "Left_superficial_fibular_nerve_45364_ID"
    ],
    "45387": [
        "Right_deep_fibular_nerve_45387_ID"
    ],
    "45388": [
        "Left_deep_fibular_nerve_45388_ID"
    ],
    "45389": [
        "Right_Lateral_terminal_branch_of_deep_fibular_nerve_45389_ID"
    ],
    "45390": [
        "Left_Lateral_terminal_branch_of_deep_fibular_nerve_45390_ID"
    ],
    "45426": [
        "Right_sural_nerve_45426_ID"
    ],
    "45427": [
        "Left_sural_nerve_45427_ID"
    ],
    "45434": [
        "Right_medial_proper_plantar_nerve_45434_ID"
    ],
    "45435": [
        "Left_medial_proper_plantar_nerve_45435_ID"
    ],
    "45450": [
        "Right_lateral_plantar_nerve_45450_ID"
    ],
    "45451": [
        "Left_lateral_plantar_nerve_45451_ID"
    ],
    "45654": [
        "Female_Internal_Genitalia_45654_ID"
    ],
    "45739": [
        "Right_platysma_45739_ID"
    ],
    "45740": [
        "Left_platysma_45740_ID"
    ],
    "45769": [
        "Internal_Urethral_Sphincter_45769_ID"
    ],
    "45826": [
        "Right_Stylohyoid_45826_ID"
    ],
    "45827": [
        "Left_Stylohyoid_45827_ID"
    ],
    "45858": [
        "Right_Iliococcygeus_45858_ID"
    ],
    "45859": [
        "Left_Iliococcygeus_45859_ID"
    ],
    "45890": [
        "Right_Biceps_Femoris_Short_Head_45890_ID"
    ],
    "45891": [
        "Left_Biceps_Femoris_Short_Head_45891_ID"
    ],
    "46283": [
        "Superior_oblique_part_of_right_longus_colli_46283_ID"
    ],
    "46284": [
        "Superior_oblique_part_of_left_longus_colli_46284_ID"
    ],
    "46285": [
        "Vertical_Intermediate_part_of_right_longus_colli_46285_ID"
    ],
    "46286": [
        "Vertical_Intermediate_part_of_left_longus_colli_46286_ID"
    ],
    "46287": [
        "Inferior_oblique_part_of_right_longus_colli_46287_ID"
    ],
    "46288": [
        "Inferior_oblique_part_of_left_longus_colli_46288_ID"
    ],
    "46292": [
        "Right_Digastric_46292_ID",
        "Right_Digastric_muscle_46292_ID"
    ],
    "46293": [
        "Left_Digastric_46293_ID",
        "Left_Digastric_muscle_46293_ID"
    ],
    "46309": [
        "Right_Longus_capitis_46309_ID"
    ],
    "46310": [
        "Left_Longus_capitis_46310_ID"
    ],
    "46313": [
        "Right_Rectus_capitis_anterior_46313_ID"
    ],
    "46314": [
        "Left_Rectus_capitis_anterior_46314_ID"
    ],
    "46317": [
        "Right_Rectus_capitis_lateralis_46317_ID"
    ],
    "46318": [
        "Right_Rectus_capitis_lateralis_46318_ID",
        "Left_Rectus_capitis_lateralis_46318_ID"
    ],
    "46319": [
        "Left_Rectus_capitis_lateralis_46319_ID"
    ],
    "46321": [
        "Right_Mylohyoid_muscle_46321_ID",
        "Right_Mylohyoid_Muscle_46321_ID"
    ],
    "46322": [
        "Left_Mylohyoid_46322_ID",
        "Left_Mylohyoid_Muscle_46322_ID"
    ],
    "46326": [
        "Right_Geniohyoid_46326_ID"
    ],
    "46327": [
        "Left_Geniohyoid_46327_ID"
    ],
    "46443": [
        "Right_Coccygeus_46443_ID"
    ],
    "46444": [
        "Left_Coccygeus_46444_ID"
    ],
    "46563": [
        "Vertical_part_of_left_cricothyroid_muscle_46563_ID",
        "Right_Cricothyroid_muscle_46563_ID",
        "Oblique_part_of_left_cricothyroid_muscle_46563_ID"
    ],
    "46564": [
        "Vertical_part_of_left_cricothyroid_muscle_46564_ID",
        "Left_Cricothyroid_muscle_46564_ID",
        "Oblique_part_of_left_cricothyroid_muscle_46564_ID"
    ],
    "46621": [
        "Superior_Pharyngeal_Constrictor_46621_ID"
    ],
    "46622": [
        "Middle_Pharyngeal_Constrictor_46622_ID"
    ],
    "46623": [
        "Inferior_Pharyngeal_Constrictor_46623_ID"
    ],
    "46690": [
        "Genioglossus_46690_ID"
    ],
    "46703": [
        "Right_Hyoglossus_46703_ID"
    ],
    "46704": [
        "Left_Hyoglossus_46704_ID"
    ],
    "46705": [
        "Right_Styloglossus_46705_ID"
    ],
    "46706": [
        "Right_Styloglossus_46706_ID",
        "Left_Styloglossus_46706_ID"
    ],
    "46759": [
        "Right_frontalis_46759_ID"
    ],
    "46760": [
        "Left_frontalis_46760_ID"
    ],
    "46761": [
        "Right_occipitalis_46761_ID"
    ],
    "46762": [
        "Left_occipitalis_46762_ID"
    ],
    "46768": [
        "Epicranial_aponeurosis_46768_ID"
    ],
    "46777": [
        "Depressor_septi_nasi_46777_ID"
    ],
    "46792": [
        "Right_orbicularis_oculi_46792_ID"
    ],
    "46793": [
        "Left_orbicularis_oculi_46793_ID"
    ],
    "46796": [
        "Right_corrugator_supercilii_46796_ID"
    ],
    "46797": [
        "Left_corrugator_supercilii_46797_ID"
    ],
    "46803": [
        "Right_levator_labii_superioris_alaeque_nasi_46803_ID"
    ],
    "46804": [
        "Left_levator_labii_superioris_alaeque_nasi_46804_ID"
    ],
    "46806": [
        "Right_levator_labii_superioris_46806_ID"
    ],
    "46807": [
        "Left_levator_labii_superioris_46807_ID"
    ],
    "46812": [
        "Right_zygomaticus_major_46812_ID"
    ],
    "46813": [
        "Left_zygomaticus_major_46813_ID"
    ],
    "46814": [
        "Right_zygomaticus_minor_46814_ID"
    ],
    "46815": [
        "Left_zygomaticus_minor_46815_ID"
    ],
    "46817": [
        "Right_depressor_labii_inferioris_46817_ID"
    ],
    "46818": [
        "Left_depressor_labii_inferioris_46818_ID"
    ],
    "46823": [
        "Right_levator_anguli_oris_46823_ID"
    ],
    "46824": [
        "Left_levator_anguli_oris_46824_ID"
    ],
    "46826": [
        "Right_mentalis_46826_ID"
    ],
    "46827": [
        "Left_mentalis_46827_ID"
    ],
    "46829": [
        "Right_depressor_anguli_oris_46829_ID"
    ],
    "46830": [
        "Left_depressor_anguli_oris_46830_ID"
    ],
    "46835": [
        "Right_buccinator_46835_ID"
    ],
    "46836": [
        "Left_buccinator_46836_ID"
    ],
    "46839": [
        "Right_risorius_46839_ID"
    ],
    "46840": [
        "Left_risorius_46840_ID"
    ],
    "46841": [
        "Orbicularis_oris_46841_ID"
    ],
    "48025": [
        "Left_Tendon_of_Digastric_48025_ID",
        "Right_Tendon_of_Digastric_48025_ID",
        "Right_Tendon_of_Digastric_Muscle_48025_ID",
        "Left_Tendon_of_Digastric_Muscle_48025_ID"
    ],
    "48957": [
        "Right_auricularis_superior_48957_ID"
    ],
    "48958": [
        "Left_auricularis_superior_48958_ID"
    ],
    "48959": [
        "Right_auricularis_anterior_48959_ID"
    ],
    "48960": [
        "Left_auricularis_anterior_48960_ID"
    ],
    "48961": [
        "Right_auricularis_posterior_48961_ID"
    ],
    "48962": [
        "Left_auricularis_posterior_48962_ID"
    ],
    "48997": [
        "Right_masseter_48997_ID"
    ],
    "48998": [
        "Left_masseter_48998_ID"
    ],
    "49007": [
        "Right_temporalis_49007_ID"
    ],
    "49008": [
        "Left_temporalis_49008_ID"
    ],
    "49012": [
        "Right_Medial_Pterygoid_49012_ID"
    ],
    "49013": [
        "Left_Medial_Pterygoid_49013_ID"
    ],
    "49016": [
        "Right_inferior_lateral_pterygoid_49016_ID",
        "Right_superior_lateral_pterygoid_49016_ID"
    ],
    "49017": [
        "Left_superior_lateral_pterygoid_49017_ID",
        "Left_inferior_lateral_pterygoid_49017_ID"
    ],
    "49036": [
        "Left_inferior_rectus_49036_ID"
    ],
    "49044": [
        "Right_superior_rectus_49044_ID"
    ],
    "49045": [
        "Left_superior_rectus_49045_ID"
    ],
    "49046": [
        "Right_inferior_rectus_49046_ID"
    ],
    "49047": [
        "Left_inferior_rectus_49047_ID"
    ],
    "49048": [
        "Right_levator_palpebrae_superioris_49048_ID"
    ],
    "49049": [
        "Left_levator_palpebrae_superioris_49049_ID"
    ],
    "49050": [
        "Right_inferior_oblique_49050_ID"
    ],
    "49051": [
        "Left_inferior_oblique_49051_ID"
    ],
    "49052": [
        "Right_superior_oblique_49052_ID"
    ],
    "49053": [
        "Left_superior_oblique_49053_ID"
    ],
    "49054": [
        "Right_lateral_rectus_49054_ID"
    ],
    "49055": [
        "Left_lateral_rectus_49055_ID"
    ],
    "49056": [
        "Right_medial_rectus_49056_ID"
    ],
    "49057": [
        "Left_medial_rectus_49057_ID"
    ],
    "49152": [
        "Right_Ciliary_Muscle_49152_ID"
    ],
    "49153": [
        "Left_Ciliary_Muscle_49153_ID"
    ],
    "49177": [
        "Upper_Gastrointestinal_Tract_49177_ID"
    ],
    "49386": [
        "Right_Inferior_extensor_retinaculum_49386_ID",
        "Left_Inferior_extensor_retinaculum_49386_ID"
    ],
    "49388": [
        "Right_Superior_extensor_retinaculum_49388_ID",
        "Left_Superior_extensor_retinaculum_49388_ID"
    ],
    "49481": [
        "Right_superior_laryngeal_artery_49481_ID"
    ],
    "49482": [
        "Left_superior_laryngeal_artery_49482_ID"
    ],
    "49486": [
        "Right_superior_thyroid_artery_49486_ID"
    ],
    "49487": [
        "Left_superior_thyroid_artery_49487_ID"
    ],
    "49498": [
        "Right_ascending_pharyngeal_artery_49498_ID"
    ],
    "49499": [
        "Left_ascending_pharyngeal_artery_49499_ID"
    ],
    "49550": [
        "Right_facial_artery_49550_ID"
    ],
    "49551": [
        "Left_facial_artery_49551_ID",
        "Right_facial_artery_49551_ID"
    ],
    "49552": [
        "Left_facial_artery_49552_ID"
    ],
    "49556": [
        "Right_ascending_palatine_artery_49556_ID"
    ],
    "49557": [
        "Left_ascending_palatine_artery_49557_ID"
    ],
    "49559": [
        "Right_tonsillar_artery_49559_ID"
    ],
    "49560": [
        "Left_tonsillar_artery_49560_ID"
    ],
    "49561": [
        "Right_tonsillar_artery_49561_ID"
    ],
    "49567": [
        "Inferior_labial_artery_49567_ID"
    ],
    "49570": [
        "Superior_labial_artery_49570_ID"
    ],
    "49584": [
        "Right_angular_artery_49584_ID"
    ],
    "49585": [
        "Left_angular_artery_49585_ID"
    ],
    "49625": [
        "Right_posterior_auricular_artery_49625_ID"
    ],
    "49626": [
        "Left_posterior_auricular_artery_49626_ID"
    ],
    "49651": [
        "Right_superficial_temporal_artery_49651_ID"
    ],
    "49652": [
        "Left_superficial_temporal_artery_49652_ID"
    ],
    "49658": [
        "Right_transverse_facial_artery_49658_ID"
    ],
    "49659": [
        "Left_transverse_facial_artery_49659_ID"
    ],
    "49660": [
        "Right_transverse_facial_artery_49660_ID"
    ],
    "49676": [
        "Right_maxillary_artery_49676_ID"
    ],
    "49677": [
        "Left_maxillary_artery_49677_ID"
    ],
    "49678": [
        "Right_maxillary_artery_49678_ID"
    ],
    "49705": [
        "Right_mental_artery_49705_ID",
        "branch_of_right_mental_artery_49705_ID"
    ],
    "49706": [
        "Left_mental_artery_49706_ID",
        "branch_of_left_mental_artery_49706_ID"
    ],
    "49712": [
        "Right_middle_meningeal_artery_49712_ID"
    ],
    "49713": [
        "Left_middle_meningeal_artery_49713_ID"
    ],
    "49743": [
        "Right_deep_temporal_artery_49743_ID"
    ],
    "49744": [
        "Left_deep_temporal_artery_49744_ID"
    ],
    "49755": [
        "Right_buccal_artery_49755_ID"
    ],
    "49756": [
        "Left_buccal_artery_49756_ID"
    ],
    "49768": [
        "Right_infraorbital_artery_49768_ID"
    ],
    "49769": [
        "Left_infraorbital_artery_49769_ID"
    ],
    "49792": [
        "Right_descending_palatine_artery_49792_ID"
    ],
    "49793": [
        "Left_descending_palatine_artery_49793_ID"
    ],
    "49799": [
        "Left_greater_palatine_artery_49799_ID"
    ],
    "49800": [
        "Right_greater_palatine_artery_49800_ID"
    ],
    "49802": [
        "Right_lesser_palatine_artery_49802_ID"
    ],
    "49803": [
        "Left_lesser_palatine_artery_49803_ID"
    ],
    "49805": [
        "Right_sphenopalatine_artery_49805_ID"
    ],
    "49806": [
        "Left_sphenopalatine_artery_49806_ID"
    ],
    "49810": [
        "Right_posterior_lateral_nasal_artery_49810_ID"
    ],
    "49811": [
        "Left_posterior_lateral_nasal_artery_49811_ID"
    ],
    "49812": [
        "Posterior_septal_branch_of_right_sphenopalatine_artery_49812_ID"
    ],
    "49813": [
        "Posterior_septal_branch_of_left_sphenopalatine_artery_49813_ID"
    ],
    "49869": [
        "Right_opthalmic_artery_49869_ID",
        "Right_ophthalmic_artery_49869_ID"
    ],
    "49870": [
        "Left_opthalmic_artery_49870_ID",
        "Left_ophthalmic_artery_49870_ID"
    ],
    "49881": [
        "Right_central_retinal_artery_49881_ID",
        "Left_central_retinal_artery_49881_ID"
    ],
    "49911": [
        "Right_Inferior_Pulmonary_vein_49911_ID"
    ],
    "49913": [
        "Left_Inferior_Pulmonary_vein_49913_ID"
    ],
    "49914": [
        "Right_Superior_Pulmonary_vein_49914_ID"
    ],
    "49916": [
        "Left_Superior_Pulmonary_vein_49916_ID"
    ],
    "49928": [
        "Right_lacrimal_artery_49928_ID"
    ],
    "49929": [
        "Left_lacrimal_artery_49929_ID"
    ],
    "49974": [
        "Right_supraorbital_artery_49974_ID"
    ],
    "49975": [
        "Left_supraorbital_artery_49975_ID"
    ],
    "49987": [
        "Right_anterior_ethmoidal_artery_49987_ID"
    ],
    "49988": [
        "Left_anterior_ethmoidal_artery_49988_ID"
    ],
    "49990": [
        "Right_posterior_ethmoidal_artery_49990_ID"
    ],
    "49991": [
        "Left_posterior_ethmoidal_artery_49991_ID"
    ],
    "50001": [
        "Right_dorsal_nasal_artery_50001_ID"
    ],
    "50002": [
        "Left_dorsal_nasal_artery_50002_ID"
    ],
    "50026": [
        "Right_supratrochlear_artery_50026_ID"
    ],
    "50027": [
        "Left_supratrochlear_artery_50027_ID",
        "Right_supratrochlear_artery_50027_ID"
    ],
    "50028": [
        "Left_supratrochlear_artery_50028_ID"
    ],
    "50029": [
        "Right_anterior_cerebral_artery_50029_ID"
    ],
    "50030": [
        "Left_anterior_cerebral_artery_50030_ID"
    ],
    "50031": [
        "Left_anterior_cerebral_artery_50031_ID"
    ],
    "50038": [
        "Left_coronary_artery_50038_ID"
    ],
    "50039": [
        "Right_Coronary_Artery_50039_ID"
    ],
    "50082": [
        "Right_Middle_Cerebral_Artery_50082_ID"
    ],
    "50083": [
        "Left_Middle_Cerebral_Artery_50083_ID"
    ],
    "50085": [
        "Right_Posterior_Communicating_Artery_50085_ID"
    ],
    "50086": [
        "Left_Posterior_Communicating_Artery_50086_ID"
    ],
    "50169": [
        "Anterior_Communicating_Artery_50169_ID"
    ],
    "50197": [
        "Muscles_of_the_Right_Arm_50197_ID"
    ],
    "50198": [
        "Muscles_of_the_Right_Arm_50198_ID",
        "Muscles_of_the_Left_Arm_50198_ID"
    ],
    "50203": [
        "Right_upper_arm_muscles_50203_ID"
    ],
    "50204": [
        "Right_upper_arm_muscles_50204_ID",
        "Left_upper_arm_muscles_50204_ID"
    ],
    "50221": [
        "Right_shoulder_muscles_50221_ID",
        "Left_shoulder_muscles_50221_ID"
    ],
    "50222": [
        "Left_shoulder_muscles_50222_ID",
        "Right_shoulder_muscles_50222_ID"
    ],
    "50542": [
        "Basilar_Artery_50542_ID"
    ],
    "50545": [
        "Right_Anterior_Inferior_cerebellar_artery_50545_ID",
        "Right_anterior_Inferior_cerebellar_artery_50545_ID"
    ],
    "50546": [
        "Left_Anterior_Inferior_cerebellar_artery_50546_ID",
        "Left_anterior_Inferior_cerebellar_artery_50546_ID"
    ],
    "50574": [
        "Right_Superior_Cerebellar_artery_50574_ID"
    ],
    "50575": [
        "Left_Superior_Cerebellar_Artery_50575_ID",
        "Left_Superior_Cerebellar_artery_50575_ID"
    ],
    "50584": [
        "Right_Posterior_cerebral_artery_50584_ID",
        "Right_posterior_cerebral_artery_50584_ID"
    ],
    "50585": [
        "Left_Posterior_cerebral_artery_50585_ID",
        "Left_posterior_cerebral_artery_50585_ID"
    ],
    "50718": [
        "Superior_Terminal_Branch_of_Right_Middle_Cerebral_Artery_50718_ID"
    ],
    "50719": [
        "Superior_Terminal_Branch_of_Left_Middle_Cerebral_Artery_50719_ID"
    ],
    "50735": [
        "Hepatic_Portal_and_Associated_Branches_50735_ID"
    ],
    "50764": [
        "Right_transverse_sinus_50764_ID"
    ],
    "50765": [
        "Left_transverse_sinus_50765_ID"
    ],
    "50767": [
        "Superior_sagittal_sinus_50767_ID"
    ],
    "50768": [
        "Inferior_Sagittal_Sinus_50768_ID"
    ],
    "50769": [
        "Straight_Sinus_50769_ID"
    ],
    "50773": [
        "Intercavernous_sinus_50773_ID"
    ],
    "50781": [
        "Occipital_Sinus_50781_ID"
    ],
    "50784": [
        "Sinus_Confluence_50784_ID"
    ],
    "50808": [
        "Right_superior_thyroid_vein_50808_ID"
    ],
    "50809": [
        "Left_superior_thyroid_vein_50809_ID"
    ],
    "50852": [
        "Right_posterior_auricular_vein_50852_ID"
    ],
    "50853": [
        "Left_posterior_auricular_vein_50853_ID"
    ],
    "50859": [
        "Right_suprascapular_vein_50859_ID"
    ],
    "50860": [
        "Left_suprascapular_vein_50860_ID",
        "Right_suprascapular_vein_50860_ID"
    ],
    "50872": [
        "Right_Pulmonary_artery_50872_ID"
    ],
    "50873": [
        "Left_Pulmonary_artery_50873_ID"
    ],
    "50875": [
        "Right_optic_nerve_50875_ID"
    ],
    "50876": [
        "Left_Facial_Vein_50876_ID",
        "Right_Facial_Vein_50876_ID"
    ],
    "50877": [
        "Right_Facial_Vein_50877_ID",
        "Left_Facial_Vein_50877_ID"
    ],
    "50878": [
        "Left_optic_nerve_50878_ID"
    ],
    "50879": [
        "Right_oculomotor_nerve_50879_ID"
    ],
    "50880": [
        "Left_oculomotor_nerve_50880_ID"
    ],
    "50881": [
        "Right_trochlear_nerve_50881_ID"
    ],
    "50882": [
        "Left_trochlear_nerve_50882_ID"
    ],
    "50886": [
        "Right_abducens_nerve_50886_ID"
    ],
    "50887": [
        "Left_abducens_nerve_50887_ID"
    ],
    "50888": [
        "Right_facial_nerve_50888_ID"
    ],
    "50889": [
        "Left_facial_nerve_50889_ID"
    ],
    "50890": [
        "Right_vestibulocochlear_nerve_50890_ID"
    ],
    "50891": [
        "Left_vestibulocochlear_nerve_50891_ID"
    ],
    "50892": [
        "Right_glossopharyngeal_nerve_50892_ID"
    ],
    "50894": [
        "Left_glossopharyngeal_nerve_50894_ID"
    ],
    "50897": [
        "Right_spinal_accessory_nerve_50897_ID",
        "Left_spinal_accessory_nerve_50897_ID"
    ],
    "50899": [
        "Left_spinal_accessory_nerve_50899_ID"
    ],
    "50902": [
        "Right_hypoglossal_nerve_50902_ID"
    ],
    "50903": [
        "Left_hypoglossal_Nerve_50903_ID"
    ],
    "50929": [
        "Right_retromandibular_vein_50929_ID"
    ],
    "50930": [
        "Left_retromandibular_vein_50930_ID"
    ],
    "50933": [
        "Right_Superficial_Temporal_Vein_50933_ID"
    ],
    "50934": [
        "Left_Superficial_Temporal_Vein_50934_ID"
    ],
    "51042": [
        "Right_Deep_Femoral_vein_51042_ID"
    ],
    "51043": [
        "Left_Deep_Femoral_vein_51043_ID"
    ],
    "51085": [
        "Tendon_of_left_flexor_digitorum_brevis_51085_ID",
        "Tendon_of_right_flexor_digitorum_brevis_51085_ID",
        "Right_flexor_digitorum_longus_51085_ID",
        "Left_flexor_digitorum_longus_51085_ID"
    ],
    "51289": [
        "Right_superior_petrosal_sinus_51289_ID"
    ],
    "51290": [
        "Left_superior_petrosal_sinus_51290_ID"
    ],
    "51402": [
        "Right_Cavernous_sinus_51402_ID"
    ],
    "51403": [
        "Left_Cavernous_Sinus_51403_ID"
    ],
    "51489": [
        "Right_occipital_vein_51489_ID"
    ],
    "51490": [
        "Left_occipital_vein_51490_ID"
    ],
    "51885": [
        "Left_central_retinal_vein_51885_ID",
        "Right_central_retinal_vein_51885_ID"
    ],
    "51942": [
        "Right_superior_central_retinal_artery_51942_ID",
        "Left_superior_central_retinal_artery_51942_ID"
    ],
    "51944": [
        "Right_inferior_central_retinal_artery_51944_ID",
        "Left_inferior_central_retinal_artery_51944_ID"
    ],
    "52619": [
        "Right_trigeminal_ganglion_52619_ID"
    ],
    "52620": [
        "Left_trigeminal_ganglion_52620_ID"
    ],
    "52629": [
        "Right_lacrimal_nerve_52629_ID"
    ],
    "52630": [
        "Left_lacrimal_nerve_52630_ID"
    ],
    "52639": [
        "Right_opthalmic_nerve_52639_ID"
    ],
    "52640": [
        "Left_opthalmic_nerve_52640_ID"
    ],
    "52643": [
        "Right_supratrochlear_nerve_52643_ID"
    ],
    "52644": [
        "Left_supratrochlear_nerve_52644_ID"
    ],
    "52661": [
        "Medial_branch_of_right_supraorbital_nerve_52661_ID"
    ],
    "52662": [
        "Medial_branch_of_left_supraorbital_nerve_52662_ID"
    ],
    "52663": [
        "Lateral_branch_of_right_supraorbital_nerve_52663_ID"
    ],
    "52664": [
        "Lateral_branch_of_left_supraorbital_nerve_52664_ID"
    ],
    "52669": [
        "Right_nasociliary_nerve_52669_ID"
    ],
    "52670": [
        "Left_nasociliary_nerve_52670_ID"
    ],
    "52725": [
        "Right_maxillary_nerve_52725_ID"
    ],
    "52726": [
        "Left_maxillary_nerve_52726_ID"
    ],
    "52734": [
        "Frontal_bone_52734_ID"
    ],
    "52735": [
        "Occipital_bone_52735_ID"
    ],
    "52736": [
        "Sphenoid_bone_52736_ID"
    ],
    "52738": [
        "Right_temporal_bone_52738_ID"
    ],
    "52739": [
        "Left_temporal_bone_52739_ID"
    ],
    "52740": [
        "Ethmoid_bone_52740_ID"
    ],
    "52745": [
        "Nasal_bone_52745_ID"
    ],
    "52746": [
        "Palatine_bone_52746_ID"
    ],
    "52748": [
        "Mandible_52748_ID"
    ],
    "52749": [
        "Hyoid_bone_52749_ID"
    ],
    "52784": [
        "Left_lateral_posterior_superior_nasal_nerve_52784_ID"
    ],
    "52785": [
        "Right_lateral_posterior_superior_nasal_nerve_52785_ID"
    ],
    "52788": [
        "Right_parietal_bone_52788_ID"
    ],
    "52789": [
        "Left_parietal_bone_52789_ID"
    ],
    "52803": [
        "Right_greater_palatine_nerve_52803_ID"
    ],
    "52804": [
        "Left_greater_palatine_nerve_52804_ID"
    ],
    "52806": [
        "Right_lesser_palatine_nerve_52806_ID"
    ],
    "52807": [
        "Left_lesser_palatine_nerve_52807_ID"
    ],
    "52824": [
        "Left_posterior_inferior_nasal_nerve_52824_ID"
    ],
    "52825": [
        "Right_posterior_inferior_nasal_nerve_52825_ID"
    ],
    "52892": [
        "Right_zygomatic_bone_52892_ID"
    ],
    "52893": [
        "Left_zygomatic_bone_52893_ID"
    ],
    "52974": [
        "Zygomaticotemporal_branch_of_right_zygomatic_nerve_52974_ID"
    ],
    "52975": [
        "Zygomaticotemporal_branch_of_left_zygomatic_nerve_52975_ID"
    ],
    "52976": [
        "Zygomaticofacial_branch_of_right_zygomatic_nerve_52976_ID"
    ],
    "52977": [
        "Zygomaticotemporal_branch_of_right_zygomatic_nerve_52977_ID",
        "Zygomaticofacial_branch_of_left_zygomatic_nerve_52977_ID"
    ],
    "52978": [
        "Zygomaticotemporal_branch_of_left_zygomatic_nerve_52978_ID"
    ],
    "52979": [
        "Right_infraorbital_nerve_52979_ID"
    ],
    "52980": [
        "Left_infra_orbital_nerve_52980_ID",
        "Left_infraorbital_nerve_52980_ID"
    ],
    "52997": [
        "Right_Mandibular_Nerve_52997_ID"
    ],
    "52998": [
        "Left_Mandibular_Nerve_52998_ID"
    ],
    "53001": [
        "Right_auriculotemporal_nerve_53001_ID"
    ],
    "53002": [
        "Left_auriculotemporal_nerve_53002_ID"
    ],
    "53069": [
        "Right_pterygopalatine_ganglion_53069_ID"
    ],
    "53070": [
        "Left_pterygopalatine_ganglion_53070_ID"
    ],
    "53121": [
        "Right_zygomatic_bone_53121_ID"
    ],
    "53122": [
        "Left_zygomatic_bone_53122_ID"
    ],
    "53185": [
        "Buccal_branch_of_right_facial_nerve_53185_ID",
        "Buccal_branch_of_Right_Facial_Nerve_53185_ID"
    ],
    "53186": [
        "Buccal_branch_of_Left_Facial_Nerve_53186_ID"
    ],
    "53219": [
        "Right_lingual_nerve_53219_ID"
    ],
    "53220": [
        "Left_lingual_nerve_53220_ID"
    ],
    "53244": [
        "Right_Inferior_Alveolar_Nerve_53244_ID"
    ],
    "53245": [
        "Left_Inferior_Alveolar_Nerve_53245_ID"
    ],
    "53251": [
        "Right_mental_nerve_53251_ID",
        "Left_mental_nerve_53251_ID"
    ],
    "53252": [
        "Left_mental_nerve_53252_ID"
    ],
    "53279": [
        "Right_posterior_auricular_nerve_53279_ID"
    ],
    "53280": [
        "Left_posterior_auricular_nerve_53280_ID"
    ],
    "53290": [
        "Temporal_branch_of_the_right_facial_nerve_53290_ID"
    ],
    "53291": [
        "Temporal_branch_of_the_left_facial_nerve_53291_ID",
        "Temporal_branch_of_the_right_facial_nerve_53291_ID"
    ],
    "53366": [
        "Marginal_mandibular_branch_of_right_facial_nerve_53366_ID"
    ],
    "53367": [
        "Marginal_mandibular_branch_of_left_facial_nerve_53367_ID"
    ],
    "53398": [
        "Cervical_branch_of_right_facial_nerve_53398_ID"
    ],
    "53399": [
        "Cervical_branch_of_left_facial_nerve_53399_ID"
    ],
    "53549": [
        "Right_ciliary_ganglion_53549_ID"
    ],
    "53550": [
        "Left_ciliary_ganglion_53550_ID"
    ],
    "53641": [
        "Right_ear_53641_ID"
    ],
    "53642": [
        "Left_ear_53642_ID"
    ],
    "53643": [
        "Left_ear_53643_ID"
    ],
    "53645": [
        "Right_Lacrimal_Bone_53645_ID"
    ],
    "53646": [
        "Left_lacrimal_bone_53646_ID"
    ],
    "53654": [
        "Palatine_bone_53654_ID"
    ],
    "54375": [
        "Nasal_septum_54375_ID"
    ],
    "54449": [
        "Right_eye_54449_ID"
    ],
    "54450": [
        "Left_eye_54450_ID"
    ],
    "54640": [
        "Tongue_54640_ID"
    ],
    "55099": [
        "Thyroid_Cartilage_55099_ID"
    ],
    "55123": [
        "Lower_part_of_cricopharyngeus_55123_ID"
    ],
    "55132": [
        "Thyrohyoid_Membrane_55132_ID"
    ],
    "55143": [
        "Right_ansa_cervicalis_nerve_55143_ID"
    ],
    "55144": [
        "left_ansa_cervicalis_nerve_55144_ID"
    ],
    "55145": [
        "Right_ansa_cervicalis_nerve_55145_ID"
    ],
    "55233": [
        "Cricothyroid_ligament_55233_ID"
    ],
    "55560": [
        "Right_Superior_Parathyroid_55560_ID"
    ],
    "55561": [
        "Left_Superior_Parathyroid_55561_ID"
    ],
    "55562": [
        "Right_Inferior_Parathyroid_55562_ID"
    ],
    "55563": [
        "Left_Inferior_Parathyroid_55563_ID"
    ],
    "55610": [
        "Right_procerus_55610_ID"
    ],
    "55611": [
        "Left_procerus_55611_ID"
    ],
    "55612": [
        "Transverse_part_of_right_nasalis_55612_ID"
    ],
    "55613": [
        "Transverse_part_of_left_nasalis_55613_ID"
    ],
    "55614": [
        "Alar_part_of_right_nasalis_55614_ID"
    ],
    "55615": [
        "Alar_part_of_left_nasalis_55615_ID"
    ],
    "56103": [
        "Right_Internal_acoustic_meatus_56103_ID"
    ],
    "56104": [
        "Left_Internal_acoustic_meatus_56104_ID"
    ],
    "56427": [
        "Right_tympanic_membrane_56427_ID"
    ],
    "56428": [
        "Left_tympanic_membrane_56428_ID"
    ],
    "58236": [
        "Right_Iris_58236_ID"
    ],
    "58237": [
        "Left_Iris_58237_ID"
    ],
    "58242": [
        "Right_Lens_58242_ID"
    ],
    "58243": [
        "Left_Lens_58243_ID"
    ],
    "58271": [
        "Right_Sclera_58271_ID"
    ],
    "58272": [
        "Left_Sclera_58272_ID"
    ],
    "58299": [
        "Right_Choroid_58299_ID"
    ],
    "58300": [
        "Left_Choroid_58300_ID"
    ],
    "58302": [
        "Right_Retina_58302_ID"
    ],
    "58303": [
        "Left_Retina_58303_ID"
    ],
    "58841": [
        "Right_Hyaloid_Canal_58841_ID"
    ],
    "58842": [
        "Left_Hyaloid_Canal_58842_ID"
    ],
    "59102": [
        "Right_lacrimal_gland_59102_ID"
    ],
    "59103": [
        "Left_lacrimal_gland_59103_ID"
    ],
    "59505": [
        "Right_major_alar_cartilage_59505_ID"
    ],
    "59506": [
        "Left_major_alar_cartilage_59506_ID"
    ],
    "59512": [
        "Right_lateral_nasal_cartilage_59512_ID"
    ],
    "59513": [
        "Left_lateral_nasal_cartilage_59513_ID"
    ],
    "59545": [
        "Right_lacrimal_sac_59545_ID"
    ],
    "59546": [
        "Left_lacrimal_sac_59546_ID"
    ],
    "59797": [
        "Left_Parotid_Gland_59797_ID",
        "Right_Parotid_Gland_59797_ID"
    ],
    "59798": [
        "Right_Parotid_Gland_59798_ID",
        "Left_Parotid_Gland_59798_ID"
    ],
    "59802": [
        "Right_Submandibular_Gland_59802_ID"
    ],
    "59803": [
        "Left_Submandibular_Gland_59803_ID"
    ],
    "59804": [
        "Right_Sublingual_Gland_59804_ID"
    ],
    "59805": [
        "Left_Sublingual_Gland_59805_ID"
    ],
    "59866": [
        "Right_Parotid_Duct_59866_ID"
    ],
    "59867": [
        "Left_Parotid_Duct_59867_ID"
    ],
    "59964": [
        "Right_Submandibular_Duct_59964_ID"
    ],
    "59965": [
        "Left_Submandibular_Duct_59965_ID"
    ],
    "60180": [
        "Right_osseous_labyrinth_60180_ID"
    ],
    "60181": [
        "Left_osseous_labyrinth_60181_ID"
    ],
    "60188": [
        "Right_Anterior_semicircular_canal_60188_ID"
    ],
    "60189": [
        "Left_Anterior_semicircular_canal_60189_ID"
    ],
    "60191": [
        "Right_Posterior_semicircular_canal_60191_ID"
    ],
    "60192": [
        "Left_Posterior_semicircular_canal_60192_ID"
    ],
    "60194": [
        "Right_Lateral_semicircular_canal_60194_ID"
    ],
    "60195": [
        "Left_Lateral_semicircular_canal_60195_ID"
    ],
    "60202": [
        "Right_Cochlea_60202_ID"
    ],
    "60203": [
        "Left_Cochlea_60203_ID"
    ],
    "61020": [
        "Right_Internal_Ear_61020_ID"
    ],
    "61021": [
        "Left_Internal_Ear_61021_ID"
    ],
    "61735": [
        "Right_external_acoustic_tube_61735_ID"
    ],
    "61736": [
        "Left_external_acoustic_tube_61736_ID"
    ],
    "61965": [
        "fornix_61965_ID"
    ],
    "62008": [
        "hypothalamus_62008_ID"
    ],
    "62033": [
        "Pineal_Gland_62033_ID"
    ],
    "62045": [
        "optic_chiasm_62045_ID"
    ],
    "64919": [
        "Right_Iliopsoas_64919_ID"
    ],
    "64920": [
        "Left_Iliopsoas_64920_ID"
    ],
    "65015": [
        "Left_Flexor_hallucis_longus_65015_ID",
        "Right_Flexor_hallucis_longus_65015_ID"
    ],
    "65019": [
        "Left_Tibialis_posterior_65019_ID",
        "Right_Tibialis_posterior_65019_ID"
    ],
    "65281": [
        "Right_long_thoracic_nerve_65281_ID"
    ],
    "65282": [
        "Left_long_thoracic_nerve_65282_ID"
    ],
    "65536": [
        "Right_lumbosacral_trunk_nerve_65536_ID"
    ],
    "65537": [
        "Left_lumbosacral_trunk_nerve_65537_ID",
        "Left_lumbosacral_trunk_65537_ID"
    ],
    "66321": [
        "Right_thoracodorsal_artery_66321_ID"
    ],
    "66322": [
        "right_thoracodorsal_artery_66322_ID",
        "left_thoracodorsal_artery_66322_ID"
    ],
    "67584": [
        "Left_nerve_of_pterygoid_canal_67584_ID",
        "Right_nerve_of_pterygoid_canal_67584_ID"
    ],
    "67944": [
        "cerebellum_67944_ID"
    ],
    "69316": [
        "Right_Brachiocephalic_trunk_69316_ID"
    ],
    "69490": [
        "Right_lateral_tarsal_artery_69490_ID"
    ],
    "69491": [
        "Left_lateral_tarsal_artery_69491_ID"
    ],
    "69494": [
        "Right_arcuate_artery_69494_ID"
    ],
    "69495": [
        "Left_arcuate_artery_69495_ID"
    ],
    "69514": [
        "Right_deep_plantar_artery_69514_ID"
    ],
    "69515": [
        "Right_deep_plantar_artery_69515_ID"
    ],
    "69516": [
        "Left_deep_plantar_artery_69516_ID"
    ],
    "69726": [
        "Calcaneal_branch_of_right_posterior_tibial_artery_69726_ID"
    ],
    "69727": [
        "Calcaneal_branch_of_left_posterior_tibial_artery_69727_ID"
    ],
    "70249": [
        "Right_femoral_artery_70249_ID"
    ],
    "70250": [
        "Left_femoral_artery_70250_ID"
    ],
    "70799": [
        "Right_dorsal_metacarpal_arteries_70799_ID"
    ],
    "70800": [
        "left_dorsal_metacarpal_arteries_70800_ID",
        "right_dorsal_metacarpal_arteries_70800_ID"
    ],
    "70801": [
        "left_dorsal_digital_arteries_70801_ID",
        "right_dorsal_digital_arteries_70801_ID",
        "Right_dorsal_digital_arteries_70801_ID",
        "Right_palmar_metacarpal_arteries_70801_ID"
    ],
    "70802": [
        "left_palmar_metacarpal_arteries_70802_ID",
        "right_palmar_metacarpal_arteries_70802_ID",
        "Right_common_palmar_digital_arteries_70802_ID"
    ],
    "70803": [
        "right_common_palmar_digital_arteries_70803_ID",
        "Right_proper_palmar_digital_arteries_70803_ID",
        "left_common_palmar_digital_arteries_70803_ID"
    ],
    "70804": [
        "left_proper_palmar_digital_arteries_70804_ID",
        "right_proper_palmar_digital_arteries_70804_ID",
        "left_common_palmar_digital_arteries_70804_ID"
    ],
    "70809": [
        "Set_of_Jejunal_arteries_70809_ID"
    ],
    "70810": [
        "Set_of_ileal_arteries_70810_ID"
    ],
    "70815": [
        "Perforating_arteries_of_left_deep_fibular_artery_70815_ID",
        "Perforating_arteries_of_right_deep_fibular_artery_70815_ID"
    ],
    "70889": [
        "Left_lumbar_vein_70889_ID",
        "Right_lumbar_vein_70889_ID"
    ],
    "70917": [
        "Right_palmar_digital_veins_70917_ID"
    ],
    "70918": [
        "right_palmar_digital_veins_70918_ID",
        "left_palmar_digital_veins_70918_ID"
    ],
    "70922": [
        "Right_distal_perforating_veins_70922_ID",
        "Perforating_veins_of_right_deep_femoral_artery_70922_ID",
        "Perforating_veins_of_left_deep_femoral_artery_70922_ID",
        "Left_distal_perforating_veins_70922_ID"
    ],
    "70927": [
        "Set_of_jejunal_veins_70927_ID"
    ],
    "70928": [
        "Set_of_ileal_veins_70928_ID"
    ],
    "71132": [
        "Gastrointestinal_Tract_71132_ID"
    ],
    "71211": [
        "Right_lateral_thoracic_vein_71211_ID"
    ],
    "71212": [
        "Left_lateral_thoracic_vein_71212_ID",
        "Right_lateral_thoracic_vein_71212_ID"
    ],
    "71214": [
        "Right_thoracodorsal_vein_71214_ID",
        "Left_thoracodorsal_vein_71214_ID"
    ],
    "71215": [
        "Right_thoracodorsal_vein_71215_ID"
    ],
    "71287": [
        "Muscles_of_the_Head_and_Neck_71287_ID"
    ],
    "71291": [
        "Muscles_of_the_Back_71291_ID"
    ],
    "71293": [
        "Muscles_of_the_Thorax_71293_ID"
    ],
    "71310": [
        "Left_Intertransversarii_71310_ID",
        "Right_Intertransversarii_71310_ID"
    ],
    "71398": [
        "Left_Radiate_Sternocostal_Ligaments_71398_ID",
        "Right_Radiate_Sternocostal_Ligaments_71398_ID"
    ],
    "71894": [
        "Right_carpal_bones_71894_ID",
        "Left_carpal_bones_71894_ID"
    ],
    "71898": [
        "Right_metacarpal_bones_of_hand_71898_ID",
        "Left_metacarpal_bones_of_hand_71898_ID"
    ],
    "71900": [
        "Phalanges_of_right_hand_71900_ID",
        "Phalanges_of_left_hand_71900_ID"
    ],
    "72063": [
        "Set_of_cervical_vertebrae_72063_ID"
    ],
    "72064": [
        "Set_of_thoracic_vertebrae_72064_ID"
    ],
    "72065": [
        "Set_of_lumbar_vertebrae_72065_ID"
    ],
    "72309": [
        "Right_Stylohyoid_Ligament_72309_ID"
    ],
    "72311": [
        "Left_Stylohyoid_Ligament_72311_ID"
    ],
    "72316": [
        "Set_of_intervertebral_discs_72316_ID"
    ],
    "72826": [
        "right_caudate_nucleus_72826_ID"
    ],
    "72827": [
        "left_caudate_nucleus_72827_ID"
    ],
    "72828": [
        "right_putamen_72828_ID"
    ],
    "72829": [
        "left_putamen_72829_ID"
    ],
    "72832": [
        "right_amygdaloid_body_72832_ID"
    ],
    "72833": [
        "left_amygdaloid_body_72833_ID"
    ],
    "72856": [
        "right_lateral_globus_pallidus_72856_ID"
    ],
    "72857": [
        "left_lateral_globus_pallidus_72857_ID"
    ],
    "72858": [
        "right_medial_globus_pallidus_72858_ID"
    ],
    "72859": [
        "left_medial_globus_pallidus_72859_ID"
    ],
    "74048": [
        "Right_stapes_74048_ID"
    ],
    "74049": [
        "Left_stapes_74049_ID"
    ],
    "74050": [
        "Right_Incus_74050_ID"
    ],
    "74051": [
        "Left_Incus_74051_ID"
    ],
    "74052": [
        "Right_malleus_74052_ID"
    ],
    "74053": [
        "Left_malleus_74053_ID"
    ],
    "74073": [
        "Right_Levatores_costarum_74073_ID"
    ],
    "74074": [
        "Left_Levatores_costarum_74074_ID"
    ],
    "74075": [
        "Right_Levatores_costarum_longi_74075_ID"
    ],
    "74076": [
        "Left_Levatores_costarum_longi_74076_ID"
    ],
    "74079": [
        "Right_Subcostales_74079_ID"
    ],
    "74080": [
        "Left_Subcostales_74080_ID"
    ],
    "74525": [
        "Occipital_74525_ID"
    ],
    "75150": [
        "Teeth_75150_ID"
    ],
    "75398": [
        "Superficial_dorsal_vein_of_penis_75398_ID"
    ],
    "75492": [
        "Right_common_plantar_digital_nerves_75492_ID"
    ],
    "75493": [
        "Left_common_plantar_digital_nerves_75493_ID"
    ],
    "76767": [
        "Anterior_cardiac_vein_76767_ID"
    ],
    "76829": [
        "Right_Zonula_Fibers_76829_ID",
        "Left_Zonula_Fibers_76829_ID"
    ],
    "77161": [
        "Intermediate_Hepatic_Vein_77161_ID"
    ],
    "77380": [
        "Right_popliteal_artery_77380_ID"
    ],
    "77381": [
        "Left_popliteal_artery_77381_ID"
    ],
    "77596": [
        "Hypogastric_nerve_77596_ID"
    ],
    "77949": [
        "Right_circumflex_scapular_vein_77949_ID"
    ],
    "77950": [
        "Right_circumflex_scapular_vein_77950_ID",
        "Left_circumflex_scapular_vein_77950_ID"
    ],
    "78023": [
        "Right_lateral_brachial_vein_78023_ID"
    ],
    "78024": [
        "right_lateral_brachial_vein_78024_ID",
        "left_lateral_brachial_vein_78024_ID"
    ],
    "78209": [
        "trunk_of_Hepatic_portal_vein_78209_ID"
    ],
    "78508": [
        "Right_tarsal_bones_78508_ID"
    ],
    "78509": [
        "Left_tarsal_bones_78509_ID"
    ],
    "78510": [
        "Right_metatarsal_bones_78510_ID"
    ],
    "79468": [
        "Right_accessory_meningeal_artery_79468_ID"
    ],
    "79469": [
        "Left_accessory_meningeal_artery_79469_ID"
    ],
    "82695": [
        "trunk_of_Hepatic_portal_vein_82695_ID"
    ],
    "82933": [
        "Right_Nerve_to_levator_ani_82933_ID"
    ],
    "82934": [
        "Left_Nerve_to_levator_ani_82934_ID"
    ],
    "85274": [
        "External_Urethral_Sphincter_85274_ID"
    ],
    "86233": [
        "Lymphatics_of_the_Upper_Limb_86233_ID"
    ],
    "86917": [
        "Muscles_of_the_Abdomen_86917_ID"
    ],
    "87217": [
        "Descending_aorta_thoracic_87217_ID",
        "Descending_thoracic_aorta_87217_ID"
    ],
    "228738": [
        "Muscles_of_the_Throat_228738_ID"
    ],
    "231317": [
        "Phalanges_of_the_right_foot_231317_ID"
    ],
    "231319": [
        "Phalanges_of_the_left_foot_231319_ID"
    ],
    "258714": [
        "right_thalamus_258714_ID"
    ],
    "258716": [
        "left_thalamus_258716_ID"
    ],
    "258847": [
        "Right_Calcaneal_Tendon__aka_Achilles_Tendon_258847_ID"
    ],
    "258848": [
        "Left_Calcaneal_Tendon__aka_Achilles_Tendon_258848_ID"
    ],
    "268668": [
        "Right_interosseous_recurrent_artery_268668_ID"
    ],
    "268669": [
        "right_interosseous_recurrent_artery_268669_ID",
        "left_interosseous_recurrent_artery_268669_ID"
    ]
};
;/**
 *  @namespace Manages network sockets to which remote clients can attach.
 */
(function () {
    "use strict";

    var HumanClients = Human.clients = {};

    /**
     * Number of remote clients connected to this engine
     * @type {number}
     */
    HumanClients.numConnections = 0;

    /**
     * Registers a client type
     * @param clazz
     */
    HumanClients.addClient = function (clientFn) {
        clientFn({
            connected: function () {
                HumanClients.numConnections++;
                Human.events.fire("clients.connected", {});
            },
            disconnected: function () {
                HumanClients.numConnections--;
                Human.events.fire("clients.disconnected", {});
            }
        });
    };

})();
;/**
 WebSocket messaging server
 */

(function () {
    "use strict";

    // Get socket server configs off URL.

    // Can't get these via Human.properties, because the socket connection must start up
    // as soon as Human fires a "loaded" event, which happens before any of the init scripts
    // execute, which is the earliest opportunity that we have for setting engine properties.

    // Socket needs to be started on "loaded" so that API can immediately send across calls
    // to do things like set canvas background color etc.

    // Only enable this code module if URL contains "socketEnabled=true".

    var socketEnabled = Human.request.getSearchParam("socketEnabled") === "true";

    if (!socketEnabled) {
        Human.log.info("Human.clients.webSocketClient", "WebSocket enabled: NO - socketEnabled=true was not found on URL.");
        return;
    }

    Human.log.info("Human.clients.webSocketClient", "WebSocket enabled: YES - socketEnabled=true was found on URL.");

    var socketServerURL = Human.request.getSearchParam("socketURL") || "https://api.biodigitalhuman.com";
    var socketServerPort = Human.request.getSearchParam("socketPort") || 443;
    var socketServerChannel = Human.request.getSearchParam("socketChannel") || "human";

    var socket = null;              // The WebSocket
    // TODO (Tarek): Human.processes no longer exists, so the queuing logic should be removed.
    var countProcesses = 0;         // Human busy when > 0
    var requestQueue = [];          // Buffers incoming requests while countProcesses > 0
    var requestQueuePumpInterval;   // Interval pumps request queue

    var connected = false;
    var error = null;
    var ready = false;

    // Relay all engine errors back to the client

    Human.events.on("error",
        function (e) {
            if (connected) {
                sendResponse({ error: e });
            }
            error = e;
        });

    Human.events.on("started",
        function () {
            if (connected) {
                sendResponse({ message: "ready" });
            }
            ready = true;
        });

    Human.events.on("loaded",
        function () {

            // Engine loaded

            Human.clients.numConnections++;
            Human.events.fire("clients.connected", {});

            Human.log.info("Human.clients.webSocketClient", "WebSocket server enabled.");

            // Load Socket.IO library

            Human.log.info("Human.clients.webSocketClient", "Loading Socket.IO Library...");

            loadSocketIO(function (io) {

                Human.log.info("Human.clients.webSocketClient", "Socket.IO library loaded.");

                // Start the socket server

                // Relay results of all engine RPC calls back to client

                Human.rpc.onResult(
                    function (key, value) {
                        var results = {};
                        results[key] = value;
                        sendResponse({ results: results });
                    });


                // Connect server to socket

                try {

                    socket = io.connect(socketServerURL + ":" + socketServerPort);

                    var socketConnected = false;

                    socket.on('connect',
                        function () {

                            // Server connected to socket

                            if (socketConnected) {
                                return;
                            }

                            socketConnected = true;

                            Human.log.info("Human.clients.webSocketClient", "Connected.");
                            Human.log.info("Human.clients.webSocketClient", "Subscribing");

                            // Subscribe server to channel

                            socket.emit('subscribe', socketServerChannel);
                        });

                    socket.on('status',
                        function (status) {
                              Human.log.info("[client " + socketServerURL + "] received status:" + status);
                        });

                    socket.on('message',
                        function (message) {

                            // Handle message from client

                            Human.log.info("Human.clients.webSocketClient", JSON.stringify(message));

                            if (message.action === "connect") {

                                // Client requests connection

                                Human.log.info("Human.clients.webSocketClient", "Client connected");

                                // Accept connection

                                socket.emit('sendreply', socketServerChannel, { message: "connected" });

                                // Then send any buffered notification of error or readiness

                                if (error) {
                                    socket.emit('sendreply', socketServerChannel, { message: "error", error: error });

                                } else if (ready) {
                                    socket.emit('sendreply', socketServerChannel, { message: "ready" });
                                }

                            } else if (message.call) {

                                // Client makes an RPC call

                                handleCall(message);
                            }
                        });

                } catch (e) {
                    Human.log.error("Human.clients.webSocketClient#start", "Error initializing socket: " + e);
                }
            });
        });


    function loadSocketIO(ok) {
        var socketIOLibraryURL = socketServerURL + ":" + socketServerPort + "/socket.io/socket.io.js";
        Human.log.info("[Socket] Loading Socket.IO library from " + socketIOLibraryURL);
        require([socketIOLibraryURL], function (io) {
            ok(io);
        });
        /*
        var el = document.createElement('script');
        el.type = 'text/javascript';
        el.src = socketIOLibraryURL;
        el.onload = function () {
            ok();
        };
        document.body.appendChild(el);
        */
    }

    function sendResponse(message) {
        try {
            socket.emit('sendreply', socketServerChannel, message);
        } catch (e) {
            Human.log.error("Human.clients.webSocketClient#sendResponse", "Error sending response: " + e);
        }
    }

    function handleCall(message) {

        var procName = message.call;

        // Execute camera commands immediately to avoid queue lag

        if (procName === "camera.pan" ||
            procName === "camera.orbit" ||
            procName === "camera.flyTo" ||
            procName === "camera.jumpTo" ||
            procName === "camera.zoom" ||
            procName === "camera.getZoom" ||

            // Allow procedures marked with connected param to execute immediately (they are not related to the Human)

            (message.params && message.params.connected)) {

            executeCall(message);

            return;
        }

        if (countProcesses === 0) {      // Execute immediately if Human not busy

            // Human not busy, execute call

            executeCall(message);

        } else {

            // Human busy, buffer the call

            requestQueue.push(message);

            if (!requestQueuePumpInterval) {

                // Start call queue pump if not already running

                requestQueuePumpInterval = setInterval(
                    function () {

                        if (requestQueue.length > 0 && countProcesses === 0) {
                            executeCall(requestQueue.shift());
                        }

                        if (requestQueue.length === 0) {

                            // Stop pump when queue empty

                            clearInterval(requestQueuePumpInterval);
                            requestQueuePumpInterval = null;
                        }
                    }, 20);
            }
        }
    }

    function executeCall(message) {
        try {
            Human.rpc.call(message.id, message.call, message.params);
        } catch (e) {
            Human.log.error("Human.clients.webSocketClient", "Error executing RPC call [callId: " + message.id + ", procedure: " + message.call + "]: " + e);
        }
    }
})();
;/**
 Window messaging

 */
Human.clients.addClient(
    function (cfg) {
        "use strict";

        var client;
        var clientOrigin;
        var responseQueue = [];
        var rpcQueue = [];
        // TODO (Tarek): Human.processes no longer exists, so the queuing logic should be removed.
        var countProcesses = 0; // Stalls rpcQueue when > 0
        var pQueueInterval;

        Human.events.on("started",
            function () {
                sendResponse({ message: "status", status: "ready" });
            });

        if (window.addEventListener) {

            // Relay errors back to client
            Human.events.on("error",
                function (error) {
                    sendResponse({ error: error });
                });

            // Relay any RPC procedure call results back to client
            Human.rpc.onResult(
                function (key, value) {
                    var results = {};
                    results[key] = Human.rpc.filterUnsafeProperties(value);
                    sendResponse({ results: results });
                });

            // Handle messages from client
            addEventListener("message",
                function (event) {
                    var msg;
                    try {
                        msg = JSON.parse(event.data);
                    } catch (e) {
                        Human.log.error("Human.clients.windowClient", "JSON parse failed on an incoming Web message: " + e.message || e);
                        return;
                    }
                    if (msg.action === "connect") {
                        // Connection request
                        if (!client) {
                            Human.log.info("Human.clients.windowClient", "Client connected");
                            cfg.connected();
                            client = event.source;
                            clientOrigin = event.origin;
                            sendResponse({ message: "connected" });
                            flushResponseQueue();
                        }
                    } else {
                        // RPC call
                        if (msg.call) {
                            handleCall(msg);
                        }
                    }
                }, false);
        } else {
            Human.log.error("Human.clients.windowClient", "Browser does not support cross-window messaging");
        }

        function sendResponse(json) {
            var message = JSON.stringify(json);
            if (!client) {
                responseQueue.push(message);
                return;
            }
            client.postMessage(message, clientOrigin);
        }

        function flushResponseQueue() {
            while (responseQueue.length > 0) {
                client.postMessage(responseQueue.pop(), clientOrigin);
            }
        }

        function handleCall(msg) {
            var procName = msg.call;
            // Execute camera commands immediately to avoid queue lag
            if (procName === "camera.pan" ||
                procName === "camera.orbit" ||
                procName === "camera.flyTo" ||
                procName === "camera.jumpTo" ||
                procName === "camera.zoom" ||
                //allow procedures marked with connected param to execute immediately (they are not related to the Human)
                (msg.params && msg.params.connected)) {
                executeCall(msg);
                return;
            }
            if (countProcesses === 0) {      // Execute immediately if Human not busy
                executeCall(msg);
            } else {
                rpcQueue.push(msg);        // Else enqueue
                if (!pQueueInterval) {
                    pQueueInterval = setInterval(
                        function () {
                            if (rpcQueue.length > 0 && countProcesses === 0) {
                                executeCall(rpcQueue.shift());
                            }
                            if (rpcQueue.length === 0) {
                                clearInterval(pQueueInterval);
                            }
                        }, 20);
                }
            }
        }

        function executeCall(msg) {
            if (!Human.rpc.windowClientEnabled) {
                return;
            }
            try {
                Human.rpc.call(msg.id, msg.call, msg.params);
                Human.rpc.log(msg.call);
            } catch (e) {
                Human.log.error("Human.clients.windowClient", "Error executing RPC call [callId: " + msg.id + ", procedure: " + msg.call + "]: " + e);
            }
        }

    });


;(function () {
    "use strict";

    var HumanCookies = Human.cookies = {};

//    /**
//     * Values of all available cookies
//     * @type {String:String}
//     */
//    HumanCookies.cookies = {};
//
//    // Get the document's cookies
//    var c = document.cookie.split(';');
//    var tokens;
//    for (var i = 0, len = c.length; i < len; i++) {
//        tokens = c[i].split('=');
//        if (tokens.length == 2) {
//            HumanCookies.cookies[tokens[0]] = tokens[1];
//        }
//    }
//
//    /**
//     * Sets or removes a cookie
//     *
//     * @memberof Human.cookies
//     * @param {String} name Cookie name
//     * @param {String} [value] Cookie value - clears the cookie when null or omitted
//     */
//    HumanCookies.setCookie = function (name, value) {
//        if (value == undefined || value == null) {
//            // Clear cookie
//            delete HumanCookies.cookies[name];
//        } else {
//            // Set cookie
//            HumanCookies.cookies[name] = value;
//        }
//        save.call(this);
//    };
//
//    // Saves cookies on the document
//    function save() {     // TODO: Deferred call on tick if called frequently?
//        var list = [];
//        var numCookies = 0;
//        for (var name in HumanCookies.cookies) {
//            if (HumanCookies.cookies.hasOwnProperty(name)) {
//                if (numCookies++ > 0) {
//                    list.push(";");
//                }
//                list.push(name);
//                list.push("=");
//                list.push(HumanCookies.cookies[name]);
//            }
//        }
//        document.cookie = list.join("");
//    }

    HumanCookies.setCookie = function (name, value, days) {
        var expires;

        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toGMTString();
        }
        else {
            expires = "";
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    };

    HumanCookies.getCookie = function (name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
            }
        }
        return null;
    };

    HumanCookies.eraseCookie = function (name) {
        HumanCookies.setCookie(name, "", -1);
    };
})();;/**
 * @namespace Provides methods for installing initialization scripts and resetting the engine.
 */
(function () {
    "use strict";

    var HumanInit = Human.init = {};

    var requires = [];
    var started = false;

    /**
     * Bookmark of Human's initial state. An full engine reset is performed by restoring this bookmark.
     * @type {{}}
     * @memberof Human.init
     */
    HumanInit.bookmark = {};

    /**
     * Bookmark of Human's initial camera state. A camera reset is performed by restoring this bookmark.
     * @type {{}}
     * @memberof Human.init
     */
    HumanInit.cameraBookmark = {};

    var urlParams = Human.request.getHashParams();
    var pluginsPath = location.origin + location.pathname.substring(0, location.pathname.lastIndexOf("/")) + "/lib/scenejs/plugins";
    var validateShaders = (urlParams.validateShaders === "true");
    var enableVAO = (urlParams.enableVAO !== "false");
    var enableInterleaving = (urlParams.enableInterleaving !== "false");

    // Configure SceneJS
    SceneJS.setConfigs({
        texturing: {
            waitForLoad: true // Set true to make objects wait for their material's textures to load
        },
        // Where SceneJS finds its plugin bundle
        pluginPath: pluginsPath,
        statusPopups: false, // Disable the default status popups
        validateShaders: validateShaders, // Validate shaders before drawing with them - debug mode only
        enableVAO: enableVAO, // Enable or disable the "OES_vertex_array_object" WebGL extension
        enableInterleaving: enableInterleaving // Enable or disable vertex array interleaving
    });

    // RequireJS timeout for slow connections
    require.config({
        waitSeconds: 30
    });

    /**
     * Saves engine state to restore to when {@link #reset} is called.
     * If the engine has multiple modules currently active, then the bookmark will capture only
     * the activation of the first module that was activated. For example, is we have two modules active,
     * say, male anatomy and healthy heart beat, then restoring the bookmark will put the engine back
     * into the state it was in right after loading, before the user selected a condition or
     * bookmark, or whatever additional content.
     */
    HumanInit.saveReset = function () {
        var bookmark = Human.bookmarks.capture();
        var modules = bookmark.modules;
        if (modules) {
            var active = modules.active;
            if (active && active.length > 1) {
                // Ensure only first active module will be reactivated when bookmark restored
                modules.active = [modules.active[0]];
            }
        }
        HumanInit.bookmark = bookmark;
        if (!!Human.timeline.activeRoot){
            // If engine loaded with a module.
            HumanInit.bookmark.camera = Human.timeline.activeRoot._chapters[0].camera.location;
        }

        HumanInit.bookmarkCamera = HumanInit.bookmark.camera;
    };

    /** Adds an init script and optional parameters.
     * <p>Complete info on init scripts may be found on the Human Data
     * Wiki <a href="https://github.com/biodigital/HumanData/wiki/Init-Scripts" target="_other">here</a>.</p>
     *
     * <h3>Example:</h3>
     * <pre>
     * Human.init
     *      .require("foo.js", { someParam: "alpha", otherParam: "beta" })
     *      .require("bar.js")
     *      .require("baz.js");
     * </pre>
     * @function
     * @param path
     * @param params
     * @return {Human.init}
     * @memberof Human.init
     */
    HumanInit.require = function (path, params) {
        if (started) {
            Human.log.error("Human.init.require", "Engine already started, ignoring script: " + path);
            return this;
        }

        requires.push({path: path, params: params || {}});

        return this;
    };


    /** Adds a step to the init sequence.
     * <p>Complete info on init scripts may be found on the Human Data
     * Wiki <a href="https://github.com/biodigital/HumanData/wiki/Init-Scripts" target="_other">here</a>.</p>
     *
     * <h3>Example:</h3>
     * <pre>
     * Human.init
     *      .require("foo.js", { someParam: "alpha", otherParam: "beta" })
     *      .stage(function() {
     *           // Do something
     *      })
     *      .require("baz.js");
     * </pre>
     * @function
     * @param callback
     * @return {Human.init}
     * @memberof Human.init
     */
    HumanInit.step = function (callback) {
        if (started) {
            callback();
            return this;
        }
        requires.push({callback: callback});
        return this;
    };

    /**
     * Resets Human state to how it was just after it started up, ie before the user modifies the
     * view, activates a module, or loads a bookmark.
     *
     * @name reset
     * @function
     * @param {Function} [ok] Callback which signals when reset complete
     * @memberof Human.init
     */
    HumanInit.reset = function (ok) {
        // Resets app by restoring its state to the
        // bookmark that was captured after startup
        if (!HumanInit.bookmark) {
            Human.log.error("Human.init.reset", "Bookmark for reset was not captured");
            if (ok) {
                ok();
            }
            return;
        }
        Human.view.lights.restoreDefaults();
        Human.bookmarks.restore(HumanInit.bookmark,
            function () {
                Human.events.fire("init.reset");
                if(ok) {
                    ok();
                }
            },
            function (err) {
                Human.log.error("Human.init.reset", "Reset failed: " + err);
                if (ok) {
                    ok();
                }
            });
    };

    /**
     * Resets Human camera state to how it was just after it started up, ie before the user modifies the
     * view, activates a module, or loads a bookmark.
     *
     * @name resetCamera
     * @function
     * @param {Function} [ok] Callback which signals when camera reset complete
     * @memberof Human.init
     */
    HumanInit.resetCamera = function (ok) {

        // try to reset to camera of current chapter
        var currentChapterLookat = Human.timeline.getCurrentChapterCamera();
        if (currentChapterLookat) {
            Human.view.camera.fly.flyTo(currentChapterLookat, ok);
            return;
        }

        // Try to reset to the initial camera position off the most recently activated module,
        // otherwise reset to the camera that was captured after the engine started up.

        var mostRecentModule;
        var module;
        var time = 0;
        var activeModules = Human.modules.activeModules;
        for (var moduleId in activeModules) {
            if (activeModules.hasOwnProperty(moduleId)) {
                module = activeModules[moduleId];
                if (module.camera && module.timeActivated > time) {
                    mostRecentModule = module;
                }
            }
        }
        if (mostRecentModule) {
            Human.view.camera.fly.flyTo(mostRecentModule.camera, ok);
            return;
        }

        // Reset to camera bookmarked after startup
        if (!HumanInit.bookmark) {
            Human.log.error("Human.init.resetCamera", "Bookmark for reset was not captured");
            if (ok) {
                ok();
            }
            return;
        }
        Human.view.camera.fly.flyTo(HumanInit.bookmark.camera, ok);
    };

    /** Reloads the page/frame that contains the engine
     * @function
     * @name reload
     * @memberof Human.init
     */
    HumanInit.reload = function () {
        window.location.reload(); // No point in chaining further commands
    };

    /**
     *
     * @param initScript
     */
    HumanInit.start = function (initScript, ok) {
        var initDone = false;
        var rendererReady = false;

        function loadInitModules() {
            if (!initDone || !rendererReady) {
                return;
            }

            var paths = [];
            var paramsList = [];

            requires.forEach(function(r) {
                if (r.path) {
                    paths.push(r.path);
                    paramsList.push(r.params);
                }
            });

            var numPaths = paths.length;

            function modulesLoaded() {
                if (--numPaths > 0) {
                    return;
                }

                var callbacks = [];

                requires.forEach(function(r) {
                    if (r.callback) {
                        callbacks.push(r.callback);
                    }
                });

                var numCallbacks = callbacks.length;

                function callbacksExecuted() {
                    if (--numCallbacks > 0) {
                        return;
                    }

                    // All init scripts executed
                    started = true;
                    HumanInit.saveReset();
                    Human.events.fire("started");
                    if (ok) {
                        ok();
                    }
                }

                if (numCallbacks === 0) {
                    callbacksExecuted();
                    return;
                }

                callbacks.forEach(function(callback) {
                    callback(callbacksExecuted);
                });
            }

            require(paths, function () {
                var modules = Array.prototype.slice.call(arguments);

                if (numPaths === 0) {
                    modulesLoaded();
                    return;
                }

                modules.forEach(function(module, i) {
                    var path = paths[i];
                    var params = paramsList[i];

                    Human.log.info("Human.init", "Loading init script: " + path);
                    module(params, modulesLoaded);
                });
            });
        }

        // Load root init script
        require([initScript], function(init) {
            init();
            initDone = true;
            loadInitModules();
        });

        // Initialize SceneJS renderer, which initialized asynchronously because
        // it may have to pull in lazy-loaded plugins for extra scene node types.
        Human.renderer.init(function () {

            // Renderer ready and all engine JS scripts loaded
            Human.events.fire("loaded");

            rendererReady = true;
            loadInitModules();
        });
    };

})();
;/**
 * Human.renderer
 *
 * @namespace Provides access to the SceneJS WebGL engine
 */
(function () {

    "use strict";

    var HumanRenderer = Human.renderer = {};

    HumanRenderer.NULL_OBJECT_ID = "null-object";   // ID of invisible object at origin, used for anchoring things like labels to

    var scene;

    HumanRenderer.init = function (ok) {

        scene = HumanRenderer.graph.init();

        // Lost WebGL context testing
        // keep this here for quick check on how well that's handled

        var timeStarted = Date.now();
        var timeLast = timeStarted;
        var tick = 0;

        scene.on("tick",
            function () {

                var timeNow = Date.now();

                Human.events.fire("tick", {
                    timeStarted: timeStarted,
                    timeLast: timeLast,
                    timeNow: timeNow,
                    tick: tick
                });

                timeLast = timeNow;
                tick++;
            });

        scene.on("sleep", // Fired after SceneJS finds 3D view needs no refresh
            function () {
                Human.events.fire("Scene.Sleep");
            });

        if (ok) {
            ok();
        }
    };

    HumanRenderer.setFPS = function (fps) {
        scene.setFPS(fps);
    };

    /**
     * Pauses the renderer.
     *
     * <p>This actually pushes a 'pause' directive onto a stack. Only once the same number of pops are done
     * with {@link #popPause} will the renderer unpause again.</p>
     *
     * <p>You would normally do this when you want to do batches of content creation, to prevent the
     * renderer from slowing things down as it works to keeps the 3D view in synch. Then when you've
     * done all your creation, you'd unpause the renderer again.</p>
     */
    HumanRenderer.pushPause = function () {
        HumanRenderer._pauses = (!HumanRenderer._pauses) ? 1 : HumanRenderer._pauses + 1;
        if (HumanRenderer._pauses === 1) {
            scene.pause(true);
        }
    };

    /**
     * Un-pauses the renderer.
     *
     * <p>As described in {@link #pushPause}, this pops a pause directive that was made with that method. Only once the same
     * number of pops are done with this method will the renderer unpause again.</p>
     */
    HumanRenderer.popPause = function () {
        if (!HumanRenderer._pauses) {
            return;
        }
        if (--HumanRenderer._pauses === 0) {
            scene.pause(false);
            scene.renderFrame();   // Forces garbage collection
        }
    };


    HumanRenderer.pauseCompilation = function () {
        scene.pauseCompilation();
    };

    HumanRenderer.resumeCompilation = function () {
        scene.resumeCompilation();
    };

    /**
     * Fires callback as soon as current task count is zero
     */
    HumanRenderer.onTasksComplete = function (ok) {
        if (HumanRenderer._pauses !== undefined && HumanRenderer._pauses !== null && HumanRenderer._pauses > 0) {
            Human.log.error("Human.renderer.onTaskComplete", "Renderer deadlock: Human.renderer.pushPause has " +
                "paused renderer. Renderer needs to be unpaused in order to complete pending tasks.");
        }
        var numTasks = Human.renderer.getScene().getStatus().numTasks;
        if (!numTasks || numTasks === 0) {
            ok();
            return;
        }
        if (HumanRenderer.__checkLoaded) {
            throw "Human.renderer.onTasksComplete: already blocking";
        }
        HumanRenderer.__checkLoaded = window.setInterval(
            function () {
                var numTasks = Human.renderer.getScene().getStatus().numTasks;
                if (!numTasks || numTasks === 0) {
                    window.clearInterval(HumanRenderer.__checkLoaded);
                    HumanRenderer.__checkLoaded = null;
                    ok();
                }
            }, 200);
    };

    // Force compilation of the SceneJS scenegraph
    HumanRenderer.compile = function () {
        this.shader.compile();
        scene.compile();
    };

    /** Forces renderer to render a frame
     */
    HumanRenderer.forceRenderFrame = function () {
        scene.renderFrame({force: true});
    };

    var rayPickEnabled = false;

    /**
     * Enable or disable ray-picking mode
     * You'd only want ray picking enabled when you're actually going to do the sort of
     * picking that needs 3D intersection results, like attaching annotations. Otherwise
     * you'd want ray-picking off, for things like regular object selection.
     * @param enable
     */
    HumanRenderer.enableRayPick = function (enable) {
        rayPickEnabled = enable;
    };

    HumanRenderer.pick = function (canvasX, canvasY, rayPick) {
        if (!scene) {
            Human.log.error("Human.renderer.pick", "Engine not started, ignoring pick");
            return null;
        }
        return scene.pick(canvasX, canvasY, {rayPick: rayPick});
    };

    HumanRenderer.getScene = function () {
        return SceneJS.scene(Human.SCENE_ROOT_ID);
    };

    HumanRenderer.getContentRootNode = function () {
        return HumanRenderer.getNode(Human.CONTENT_ROOT_ID);
    };

    HumanRenderer.getNode = function (nodeId) {
        return scene.findNode(nodeId);
    };

    HumanRenderer.getLookAt = function () {
        return HumanRenderer.getNode(Human.LOOKAT_ID);
    };

    HumanRenderer.nodeExists = function (nodeId) {
        var node = scene.findNode(nodeId);
        return (node !== null && node !== undefined);
    };

    /**
     * Returns the 4x4 View transform matrix.
     * <p>Transform World-space coordinates by this matrix to obtain View-space coordinates.</p>
     */
    HumanRenderer.getViewMat = function () {
        return HumanRenderer.getNode(Human.LOOKAT_ID).getMatrix();
    };

    /**
     * Returns the 4x4 Projection transform matrix.
     * <p>Transform View-space coordinates by this matrix to obtain Canvas-space coordinates.</p>
     */
    HumanRenderer.getProjMat = function () {
        return HumanRenderer.getNode(Human.CAMERA_ID).getMatrix();
    };

})();
;(function() {
	"use strict";

	var contentRootID = Human.CONTENT_ROOT_ID;  // TODO: Get rid of Human.CONTENT_ROOT_ID, no need to make public now
	var libraryRootID = "assetLibraryRoot";
	var skyboxRootID = "skyboxRoot";

	var sceneRootNode;
	var contentRootNode;


	var NODE_ORDER_RANK = {
	    xform:          1,
	    texture: 		2,
	    _texture:       2,
	    material:       3,
	    reflect:        4,
	    fresnel:        5,
	    flags:          6,
	    billboard: 		7,
	    name: 		    8,
	    layer:          9,
	    shader:         10,
	    shaderParams:  	11,
	    morphGeometry: 	12,
	    geometry:      	13
	};

	var graph = Human.renderer.graph = {};

	/**
	 * Root nodes of built-in subtrees.
	 *
	 * Insert core-shared asset nodes into this with:
	 *
	 * #insertNode( #rootNodes.library, myAssetNode );
	 * #insertNode( #rootNodes.skybox, mySkyboxNode );
	 *
	 * etc.
	 *
	 * @type {{String: SceneJS.Node}}
	 */
	graph.rootNodes = {

		/**
		 * Root node of the library subgraph.
		 * Insert core-shared asset nodes into this with #insertNode( #libraryRootNode, myAssetNode );
		 * @type {SceneJS.Library}
		 */
		library: null,

		/**
		 * Root node of the skybox subgraph.
		 * Insert skyboxes into this with #insertNode( #skyboxRootNode, mySkyboxNode );
		 * @type {SceneJS.Node}
		 */
		skybox: null
	};

	// This allows for super sample anti-aliasing if anti-aliasing isn't available on the WebGL context
	graph.SSAA_MULTIPLIER = (function () {
	    var ssaaParam = parseInt(Human.request.getSearchParam("forceSSAA"), 10);

	    if (ssaaParam >= 1) {
	        return ssaaParam;
	    }

	    var canvas = document.createElement("canvas");
	    var gl = canvas.getContext("webgl", {antialias: true}) || canvas.getContext("experimental-webgl", {antialias: true});

	    return gl && gl.getContextAttributes().antialias ? 1 : 2;
	})();

	// Create scene graph
	var SCENE_DEFINITION = {
	    type: "scene",
	    id: Human.SCENE_ROOT_ID,
	    canvasId: Human.CANVAS_ID,
	    // transparent canvas
	    transparent: true,

	    contextAttr: {

	        // Default: false. If false, once the drawing buffer is presented as described in theDrawing Buffer
	        // section, the contents of the drawing buffer are cleared to their default values. All elements of the
	        // drawing buffer (color, depth and stencil) are cleared. If the value is true the buffers will not be
	        // cleared and will preserve their values until cleared or overwritten by the author.
	        // On some hardware setting the preserveDrawingBuffer flag to true can have significant performance implications.
	        // http://code.google.com/p/chromium/issues/detail?id=82086
	        preserveDrawingBuffer: false,
	        antialias: true
	    },

	    nodes: [
	        {type: "library", id: "assetLibraryRoot"},

	        // Camera for projection
	        {
	            type: "camera",
	            id: Human.CAMERA_ID,
	            optics: { type: "perspective",
	                fovy: 60, near: 0.01, far: 400.0
	            },

	            // Screen-space pan
	            pan: {x: 0, y: 0, z: 0},

	            nodes: [

	                // Illuminated annotation labels in their own frustum space
	                // Don't rely on SceneJS default lookat for label wires
	                {
	                    type: "lookAt", eye: {x: 0.0, y: 0.0, z: 0.05}, look: {x: 0.0, y: 0, z: 0}, up: {y: 1.0},
	                    nodes: [
	                        {
	                            type: "lights",
	                            lights: [
	                                {
	                                    mode: "dir",
	                                    color: {r: 1.0, g: 1.0, b: 1.0},
	                                    dir: {x: 0.0, y: 0.0, z: -1.0},
	                                    diffuse: true, specular: true, space: "view"
	                                }
	                            ],
	                            nodes: [
	                                {type: "node", id: "annotation-labels"}
	                            ]
	                        }
	                    ]
	                },

	                // Main view transform
	                {
	                    // Camera attributes will be overwritten by Human.view.camera
	                    type: "lookAt",
	                    id: Human.LOOKAT_ID,
	                    eye: {x: 0.0, y: 0.0, z: 55}, look: {x: 0.0, y: 0, z: 0}, up: {y: 1.0},
	                    nodes: [

							// Skybox nodes will be inserted here
							{
								id: skyboxRootID
							},

	                        // Clip indicators
	                        {
	                            type: "layer", priority: 10000,
	                            nodes: [
	                                {
	                                    type: "flags",
	                                    id: Human.CLIP_INDICATORS_ATTACH_ID,
	                                    flags: {picking: false}
	                                }
	                            ]
	                        },

	                        // Clipping planes will be inserted here
	                        // See ./view/clip/clip.js
	                        {
	                            id: "clips",
	                            nodes: [

	                                // Annotation 3D occlusion test primitives are inserted here
	                                // See ./view/annotations/utils/occlusionQuery.js
	                                {
	                                    id: "occlusionIndicators"
	                                },

	                                // Lights node will be inserted here, above "lights.subtree"
	                                // See ./view/lights/lights.js
	                                {
	                                    id: "lights",
	                                    nodes: [

	                                        // Subnodes of lights
	                                        {
	                                            id: "lights.subtree",
	                                            nodes: [

	                                                // Postprocessing nodes will be inserted here, above "effects.subtree"
	                                                // See ./view/effects/effects.js
	                                                {
	                                                    id: "effect",
	                                                    nodes: [

	                                                        // Subnodes of effects
	                                                        {
	                                                            id: "effect.subtree",
	                                                            nodes: [


	                                                                // Default material around content
	                                                                {
	                                                                    type: "material", id: Human.MATERIAL_ROOT_ID,
	                                                                    emit: 0, baseColor: { r: 0.9, g: 0.9, b: 0.9 },
	                                                                    specularColor: { r: 0.9, g: 0.9, b: 0.9 }, specular: 0.9,
	                                                                    shine: 100.0,
	                                                                    nodes: [

	                                                                        // Null objects - hack to give global labels something to bind to.
	                                                                        // Note we avoid scaling transforms around the null object, because
	                                                                        // those will distort the offset that is fed into the "rendered"
	                                                                        // handler.
	                                                                        // We have multiple null objects - one for labels, another for
	                                                                        // annotations. For some reason those clobber each other when on
	                                                                        // same null object.

	                                                                        // Null object #1
	                                                                        {
	                                                                            type: "node", id: Human.renderer.NULL_OBJECT_ID,
	                                                                            nodes: [
	                                                                                // Infintesimally small dummy triangle.
	                                                                                //
	                                                                                // Was getting SceneJS problems with primitives like "points"
	                                                                                // and "lines" where the lighting/shading states of other
	                                                                                // "triangles" geometries subsequent in the scene
	                                                                                // were not applied, ie. coming up black for some reason.
	                                                                                {
	                                                                                    type: "geometry",
	                                                                                    positions: [0, 0, 0, 0.1, 0.1, 0.1, 0.2, 0.2, 0.2],
	                                                                                    indices: [0, 1, 2],
	                                                                                    uv: [0, 0, 1, 0, 1, 1],
	                                                                                    normals: [0, 1, 0, 0, 1, 0, 0, 1, 0], // Above error happens when normals missing
	                                                                                    primitive: "triangles"

	                                                                                }
	                                                                            ]
	                                                                        },

	                                                                        // Default flags at content root
	                                                                        // Content attached here
	                                                                        {
	                                                                            type: "flags",
	                                                                            id: contentRootID,
	                                                                            flags: {
	                                                                                picking: true,
	                                                                                enabled: true,
	                                                                                specular: true,
	                                                                                backfaceLighting: true,
	                                                                                backfaceTexturing: true,
	                                                                                backfaces: true,
	                                                                                reflection: false
	                                                                            }
	                                                                        }
	                                                                    ]
	                                                                },

	                                                                // Object Boundary - shown when flying. rotating. panning etc
	                                                                {
	                                                                    type: "flags",
	                                                                    id: "object-boundary-flags",
	                                                                    flags: { enabled: false, transparent: true, clipping: false },
	                                                                    nodes: [
	                                                                        {
	                                                                            type: "material",
	                                                                            baseColor: {r: 0.0, g: 1.0, b: 0.0},
	                                                                            specularColor: { r: 0.0, g: 1.0, b: 0.0 },
	                                                                            emit: 1.0, alpha: 0.4,
	                                                                            nodes: [
	                                                                                {
	                                                                                    type: "style",
	                                                                                    lineWidth: 1, // Thickness of boundary box wire
	                                                                                    nodes: [
	                                                                                        {
	                                                                                            type: "geometry",
	                                                                                            id: "object-boundary-geo",
	                                                                                            positions: [
	                                                                                                1.0, 1.0, 1.0, 1.0, -1.0, 1.0,
	                                                                                                -1.0, -1.0, 1.0, -1.0, 1.0, 1.0,
	                                                                                                1.0, 1.0, -1.0, 1.0, -1.0, -1.0,
	                                                                                                -1.0, -1.0, -1.0, -1.0, 1.0, -1.0
	                                                                                            ],
	                                                                                            primitive: "lines",
	                                                                                            indices: [
	                                                                                                0, 1, 1, 2, 2, 3, 3, 0, 4,
	                                                                                                5, 5, 6, 6, 7, 7, 4, 0, 4,
	                                                                                                1, 5, 2, 6, 3, 7
	                                                                                            ]
	                                                                                        }
	                                                                                    ]
	                                                                                }
	                                                                            ]
	                                                                        }
	                                                                    ]
	                                                                }
	                                                            ]
	                                                        }
	                                                    ]
	                                                }
	                                            ]
	                                        }
	                                    ]
	                                }
	                            ]
	                        }
	                    ]
	                }
	            ]
	        }
	    ]
	};

	graph.init = function() { // TODO: Why not build whole scene graph here?

		var simulateWebGLContextLost = Human.request.getSearchParam("testContextLost");

		sceneRootNode = SceneJS.createScene(SCENE_DEFINITION, {
		    resolutionScaling: graph.SSAA_MULTIPLIER,
		    simulateWebGLContextLost: !!simulateWebGLContextLost
		});

		if (simulateWebGLContextLost) {

		    var interval = parseInt(simulateWebGLContextLost);

		    // Simulate WebGL context loss on interval
		    window.setInterval(
		        function () {

		            //  alert("losing webgl context");
		            sceneRootNode.loseWebGLContext();

		        }, interval * 1000);
		}

		contentRootNode = sceneRootNode.getNode(contentRootID);

		graph.rootNodes.library = sceneRootNode.getNode(libraryRootID);
		graph.rootNodes.skybox = sceneRootNode.getNode(skyboxRootID);

		return sceneRootNode;
	};

	/**
	 * Creates a subtree within this render graph. You can then call #insertNode to create nodes
     * within the subtree, or #destroySubtree to destroy the subtree.
	 *
	 * @param {SceneJS.Node} [parent] Optional leaf node belonging to a parent Human.sceneObject.
	 * @returns {SceneJS.Node} Root of new subtree.
	 */
	graph.createSubtree = function(parent) {

		// Eventually, we'll not create roots within roots, where the SceneJS subgraphs for Human objects will
		// be flat, ie. not nested within the SceneJS scene graph. Before we do that however, we need to manage the
		// nested coordinate spaces (ie multiplication of nested matrices) within Human, rather than rely on
		// SceneJS' inherited coordinate spaces, as we do currently.

		if (!contentRootNode) {
			throw "Not initialized - call #init first";
		}

		var rootNode;

		if (parent) {
			rootNode = parent.addNode();

		} else {
			rootNode = contentRootNode.addNode();
		}

		return rootNode;
	};

	/**
	 * Inserts a SceneJS node into the given subtree, which must have been created earlier with #createSubtree.
	 *
	 * The subtree can either be one of the built-in subtrees in #rootNodes,
	 * or one that was created earlier with #createSubtree.
	 *
	 * @param {SceneJS.Node} rootNode Root of subtree.
	 * @param {SceneJS.Node | *} insertNode Node to insert, given as either instance or JSON config.
	 * @returns {SceneJS.Node} Node that was newly inserted.
	 */
	graph.insertNode = function(rootNode, insertNode) {

		if (insertNode instanceof SceneJS.Node) {
			insertNode = {
				type: insertNode.type,
				coreId: insertNode.getCoreId()
			};
		}

		var type = insertNode.type;
		var insertNodeScore = NODE_ORDER_RANK[type];

		var currentNode = rootNode;

		while(currentNode) {
		    var currentNodeScore = NODE_ORDER_RANK[currentNode.type] ? NODE_ORDER_RANK[currentNode.type] : 0;

		    if(insertNodeScore < currentNodeScore) {
		        var parent = currentNode.parent;

		        currentNode.disconnect();
		        insertNode = parent.addNode(insertNode);

		        insertNode.addNode(currentNode);

		        return insertNode;
		    } else if(currentNode.nodes.length === 0) {
	            return currentNode.addNode(insertNode);
		    }

		    currentNode = currentNode.nodes[0];
		}
	};

	/**
	 * Destroys the given subtree, which must have been created earlier with #createSubtree.
	 * Also destroys all nodes that were inserted into the subtree with #insertNode.
	 *
	 * @param {SceneJS.Node} rootNode Root of subtree to destroy.
	 */
	graph.destroySubtree = function(rootNode) {

		// For API pedantry make sure we don't destroy one of the built-in subtree roots
		var rootNodes = this.rootNodes;
		for (var key in rootNodes) {
			if (rootNodes.hasOwnProperty(key)) {
				if (rootNodes[key].id === rootNode.id) {
					Human.log.warn("Human.renderer.graph.destroySubtree", "Tried to destroy one of the built-in root nodes");
					return;
				}
			}
		}

		rootNode.destroy();
	};

})();
;/**
 * Human.renderer.bg
 *
 * @namespace Manages the background color and configures Human.renderer.shader accordingly
 */
(function () {
    "use strict";

    var bgDefault = Human.request.getSearchParam('bgstd') || Human.cookies.getCookie('background') || 'standard';
    var bgRadial = true;
    var bgColorPositions = [0, 100];

    var bgDirty = true;

    var HumanRendererBG = Human.renderer.bg = {};

    HumanRendererBG.bgColor = bgDefault;
    HumanRendererBG.bgColors = {};

    HumanRendererBG.getBGColor = function () {
        return HumanRendererBG.bgColor;
    };

    Human.properties.subscribe({
        propId: "backgrounds",
        subId: "background",
        value: HumanRendererBG.bgColors,
        callback: function (value) {
            HumanRendererBG.bgColors = value;
            bgDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "background.radial",
        callback: function (value) {
            value = !!value;
            if (bgRadial !== value) {
                bgRadial = value;
                bgDirty = true;
            }
        }
    });

    Human.properties.subscribe({
        propId: "background.colorPositions",
        value: bgColorPositions,
        callback: function (value) {
            if (value[0] !== bgColorPositions[0] || value[1] !== bgColorPositions[1]) {
                bgColorPositions = value;
                bgDirty = true;
            }
        }
    });

    Human.events.on(
        "tick",
        function () {
            if (bgDirty) {
                HumanRendererBG.setBGColor(HumanRendererBG.bgColor, bgRadial, bgColorPositions);
                bgDirty = false;
            }
        });

    // Bind activation of backgrounds for various modes. As we get notification from Human
    // that each mode (Highlight, X-Ray, Quiz) is activated, we select an appropriate background
    // from among those we just defined above.

    Human.events.on("highlight.toggled", // Highlight
        function (event) {
            if (event.enabled === true) {
                var bgPreference = Human.cookies.getCookie("background") || 'standard';
                Human.properties.resubscribe("background", "background." + bgPreference);
            }
        });

    /**
     *
     */
    Human.renderer.setBGColor = // HACK for UI backward compatibility
        HumanRendererBG.setBGColor = function(color, radial, colorPositions) {
        radial = radial !== false;

        if(!colorPositions) {
            colorPositions = bgColorPositions;
        }

        var top, bottom;

        //lengths between 3-16
        var csv = /^([\d\.]+,){2,15}[\d\.]+$/.test(color);

        var is256Scale = function (channels) {
            for (var i = 0; i < channels.length; i++) {
                if (parseFloat(channels[i]) > 1) {
                    return true;
                }
            }

            return false;
        };

        if (!color) {
            color = bgDefault;
        }

        if (typeof color === 'string') {

            if (csv) {

                var channels = color.split(",");
                var length = channels.length;
                var multiply = !is256Scale(channels);

                switch (length) {
                    case 16: //backwards compatibility
                        top = cssRGB(channels.slice(0, 3));
                        bottom = cssRGB(channels.slice(12, 15));
                        break;
                    case 12:
                        top = cssRGB(channels.slice(0, 3));
                        bottom = cssRGB(channels.slice(9, 12));
                        break;
                    case 6:
                        top = cssRGB(channels.slice(0, 3), multiply);
                        bottom = cssRGB(channels.slice(3, 6), multiply);
                        break;
                    case 3:
                        top = bottom = cssRGB(channels, false); //RGB color
                        break;
                    default:
                        return;
                }

                color = 'custom'; //for subsequent getting

            } else if (HumanRendererBG.bgColors[color]) {

                top = cssRGB(HumanRendererBG.bgColors[color].slice(0, 3));
                bottom = cssRGB(HumanRendererBG.bgColors[color].slice(9, 12));

            } else {

                top = bottom = color; //css color name
            }

        } else {

            return;
        }

        HumanRendererBG.bgColor = color;

        //this is necessary for annotations / elements that respond to bg color
        setBGClass(/rgb\([\d,]+\)/.test(HumanRendererBG.bgColor) ? 'custom' : HumanRendererBG.bgColor);

        //only one way gradient for now
        setBGCSS(top, bottom, radial, colorPositions);

        Human.renderer.shader.setBGColor(HumanRendererBG.bgColor);
    };

    function cssRGB(arr, multiply) {
        var values = [];
        multiply = typeof multiply === 'boolean' ? multiply : true;

        for (var i = 0; i < arr.length; i++) {
            values.push(Math.round(arr[i] * (multiply ? 255 : 1)));
        }

        return "rgb(" + values.join(',') + ")";
    }

    function setBGCSS(top, bottom, radial, colorPositions) {
        var $container = $("#container");

        var prefixes = ['-webkit-', '-moz-', '-ms-', '-o-', ''];
        var _rule;

        if (radial) {
            //Safari
            $container.css("background-image", "-gradient(radial, center center, 0px, center center, 100%, color-stop(" + colorPositions[0] + "%," + bottom + "), color-stop(" + colorPositions[1] + "%," + top + "))");
            _rule = "radial-gradient(ellipse at center, "  + bottom + " " + colorPositions[0] + "%, " + top + " " + colorPositions[1] + "%)";
        } else {
            //Safari
            $container.css("background-image", "-webkit-gradient(linear, left top, left bottom, color-stop(" + (colorPositions[0] / 100) + ", " + top + "), color-stop(" + (colorPositions[1] / 100) + ", " + bottom + ")");
            _rule = "linear-gradient(top, " + top + " " + colorPositions[0] + "%, " + bottom + " " + colorPositions[1] + "%)";
        }

        for (var i = 0; i < prefixes.length; i++) {
            var rule = prefixes[i] + _rule;
            $container.css("background-image", rule);
        }
    }

    function setBGClass(color) {
        var className = document.body.className;
        //remove old
        document.body.className = className = className.replace(/bg-([^\s]*)/, '');
        //add new
        var newClass = 'bg-' + color;
        document.body.className = (className + ' ' + newClass).trim();
    }


})();
;/**
 * Human.renderer.shader
 *
 * This module inserts a custom shader node into the SceneJS scene graph, tailored for XRay and/or
 * highlighting functionality, depending on which of those are currently enabled via engine configs.
 *
 * This module listens to two boolean engine configs: "xray.enabled" and "highlight.enabled".
 *
 * Whenever either of these configs are set true, this module will dynamically insert a shader node
 * to support XRay and/or highlighting, depending on which of the two configs are true.
 *
 * When both of these configs are false, this module will remove the shader node from
 * the scene graph altogether.
 *
 * This module also ensures that certain colors used within the XRay effect are appropriate for
 * for the current background color, which is indicated to this module via Human.renderer.setBGColor().
 *
 * @namespace Manages the XRay and Highlight shader
 */
(function () {
    "use strict";

    // Exports

    var HumanRendererShader = Human.renderer.shader = {
        setBGColor: setBGColor
    };

    // Default desaturated rendering colors for transparent objects in X-Ray mode for each background color
    // May be overridden in properties init script

    var colorsForBackgrounds = {
        "white": [0.0, 0.0, 0.1],
        "black": [0.8, 0.8, 0.9],
        "standard": [0.8, 0.8, 0.9],
        "default": [0.8, 0.8, 0.9]   // When Bg color name is none of the above
    };

    // Default glassFactor properties for transparent objects in X-Ray mode for each background color
    // May be overridden in properties init script

    var glassFactorsForBackgrounds = {
        "white": 1.0,
        "black": 1.0,
        "standard": 1.0,
        "default": 1.0
    };

    // Default murkiness properties for transparent objects in X-Ray mode for each background color
    // May be overridden in properties init script

    var murkinessForBackgrounds = {
        "white": 0.8,
        "black": 0.8,
        "standard": 0.8,
        "default": 0.8
    };

    var enableXRay = true;
    var enableHighlight = true;
    var enableFog = false;
    var fogMode = "exp";

    var shaderDirty = true;

    var params = {};
    var paramsDirty = false;

    var shaderNode = null;

    var bgColor = Human.request.getSearchParam('bgstd') || Human.cookies.getCookie('background') || 'standard';

    var bgDirty = true;

    var defaultParams = {
        transparent: false,
        xray: false,
        glassFactor: 0.4, // Full glass effect
        murkiness: 0.8,
        xrayGlassFactor: 1.0, // Full glass effect
        xrayMurkiness: 0.8,
        highlight: false,
        highlightColor: [1.5, 1.5, 0.5],
        opacity: 1.0,
        desaturate: false,
        xrayBGColor: [0.0, 0.0, 0.1],
        fogDensity: 0.01,
        fogStart: 0,
        fogEnd: 1000,
        fogMin: 0.0,
        fogMax: 1.0,
        fogColor: [1, 1, 1]
    };


    Human.properties.subscribe({
        subId: "colorsForBackgrounds",
        propId: "xray.colorsForBackgrounds",
        value: colorsForBackgrounds,
        callback: function (value) {
            colorsForBackgrounds = value;
            bgDirty = true;
        }
    });

    Human.properties.subscribe({
        subId: "glassFactorsForBackgrounds",
        propId: "xray.glassFactorsForBackgrounds",
        value: glassFactorsForBackgrounds,
        callback: function (value) {
            glassFactorsForBackgrounds = value;
            bgDirty = true;
        }
    });

    Human.properties.subscribe({
        subId: "murkinessForBackgrounds",
        propId: "xray.murkinessForBackgrounds",
        value: murkinessForBackgrounds,
        callback: function (value) {
            murkinessForBackgrounds = value;
            bgDirty = true;
        }
    });

    Human.properties.subscribe({
        subId: "glassFactor",
        propId: "xray.glassFactor",
        value: defaultParams.glassFactor,
        callback: function (value) {
            setParams({
                glassFactor: value
            });
        }
    });

    Human.properties.subscribe({
        subId: "murkiness",
        propId: "xray.murkiness",
        value: defaultParams.murkiness,
        callback: function (value) {
            setParams({
                murkiness: value
            });
        }
    });

    Human.properties.subscribe({
        propId: "xray.enabled",
        value: enableXRay,
        callback: function (value) {
            enableXRay = value;
            shaderDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "highlight.enabled",
        value: enableHighlight,
        callback: function (value) {
            enableHighlight = value;
            shaderDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "highlight.color",
        value: defaultParams.highlightColor,
        callback: function (value) {
            setParams({
                highlightColor: value
            });
        }
    });

    Human.properties.subscribe({
        propId: "fog.enabled",
        value: enableFog,
        callback: function (value) {
            enableFog = value;
            shaderDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.mode",
        value: fogMode,
        callback: function (value) {
            fogMode = value;
            shaderDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.start",
        value: defaultParams.fogStart,
        callback: function (value) {
            setParams({
                fogStart: value
            });
        }
    });

    Human.properties.subscribe({
        propId: "fog.end",
        value: defaultParams.fogEnd,
        callback: function (value) {
            setParams({
                fogEnd: value
            });
        }
    });

    Human.properties.subscribe({
        propId: "fog.min",
        value: defaultParams.fogMin,
        callback: function (value) {
            setParams({
                fogMin: value
            });
        }
    });

    Human.properties.subscribe({
        propId: "fog.max",
        value: defaultParams.fogMax,
        callback: function (value) {
            setParams({
                fogMax: value
            });
        }
    });

    Human.properties.subscribe({
        propId: "fog.density",
        value: defaultParams.fogDensity,
        callback: function (value) {
            setParams({
                fogDensity: value
            });
        }
    });

    Human.properties.subscribe({
        propId: "fog.color",
        value: defaultParams.fogColor,
        callback: function (value) {
            setParams({
                fogColor: value
            });
        }
    });

    // Force compilation of the shader node.
    HumanRendererShader.compile = function() {
        if (shaderDirty) {
            if (enableXRay || enableHighlight) {
                createShaderNode();
                paramsDirty = true;
                bgDirty = true;
            } else {
                destroyShaderNode();
            }

            shaderDirty = false;
        }

        if (shaderNode) {
            if (paramsDirty) {
                shaderNode.setParams(params);
                paramsDirty = false;
                bgDirty = true;
            }

            if (bgDirty) {
                updateShader();
            }
        }
    };

    Human.events.on(
        "tick",
        function () {

            HumanRendererShader.compile();
        });


    function setBGColor(color) {
        bgColor = color;
        bgDirty = true;
    }

    function setParams(p) {
        if (shaderNode) {
            shaderNode.setParams(p);
        } else {
            paramsDirty = true;
        }
        Human.utils.apply(p, params);
    }

    function createShaderNode() {

        destroyShaderNode();


        // Compose a shader that performs XRay and/or highlighting, depending on what
        // functionality is enabled

        var code = []; // GLSL fragment shader code

        var hooks = {}; // Function hooks

        if (enableXRay) {
            code.push("uniform bool  transparent;");
            code.push("uniform bool  xray;");
            code.push("uniform float glassFactor;");
            code.push("uniform float murkiness;");
            code.push("uniform float xrayGlassFactor;");
            code.push("uniform float xrayMurkiness;");
            code.push("uniform float opacity;");
        }

        if (enableXRay || enableHighlight) {
            code.push("uniform vec3  xrayBGColor;");
        }

        if (enableXRay || enableHighlight) {
            code.push("uniform bool highlight;");
            code.push("uniform bool desaturate;");
        }

        if (enableHighlight) {
            code.push("uniform vec3 highlightColor;");
        }

        if (enableFog) {
            code.push("uniform float  fogDensity;");
            code.push("uniform float  fogStart;");
            code.push("uniform float  fogEnd;");
            code.push("uniform float  fogMin;");
            code.push("uniform float  fogMax;");
            code.push("uniform vec3   fogColor;");

            code.push("vec4 _std_viewPos;");

            code.push("void _std_viewPosFunc(vec4 viewPos) {");
            code.push("   _std_viewPos = viewPos;");
            code.push("}");

            hooks.viewPos = "_std_viewPosFunc";
        }

        if (enableXRay) {
            code.push("vec3 _std_viewNormal = vec3(0.0, 0.0,  -1.0);");
            code.push("vec3 _std_viewEyeVec = vec3(0.0, 0.0, -1.0);");

            // Intercept the View-space normal vector
            code.push("void _std_ViewNormalFunc(vec3 vec) {");
            code.push("   _std_viewNormal = vec;");
            code.push("}");

            // Intercept material alpha, adjust according to angle between the vectors
            code.push("float _std_MaterialAlphaFunc(float alpha) {");

            // If in X-Ray, ignore base material alpha
            code.push("   if (xray) {");
            code.push("       alpha = 1.0;");
            code.push("   }");

            // If in transparency mode, set transparency to lowest among 'opacity' and 'alpha'
            code.push("   else if (transparent) {");
            code.push("       alpha = min(alpha, opacity);");
            code.push("       float gf = (glassFactor  * (murkiness - abs(dot(_std_viewNormal, _std_viewEyeVec))));");
            code.push("       alpha = max(alpha, gf);");
            code.push("   }");

            code.push("   return alpha;");
            code.push("}");

            // Function hooks

            hooks.viewNormal = "_std_ViewNormalFunc";
            hooks.materialAlpha = "_std_MaterialAlphaFunc";
        }

        if (enableXRay || enableHighlight || enableFog) {

            code.push("vec4 _std_PixelColorFunc(vec4 color) {");
            code.push("   if (xray) {");
            code.push("       color.a *= (xrayGlassFactor  * (xrayMurkiness - abs(dot(_std_viewNormal, _std_viewEyeVec))));");
            code.push("   }");
            code.push("   if (highlight) {");
            if (enableHighlight) {
                code.push("       float intensity = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;");
                code.push("       color = vec4((intensity * -0.1) + color.rgb * (1.0 + 0.1), color.a);");
                code.push("       color.r = clamp(color.r * highlightColor.r, 0.3, 1.0);");
                code.push("       color.g = clamp(color.g * highlightColor.g, 0.3, 1.0);");
                code.push("       color.b = color.b * highlightColor.b;");
            }
            code.push("   } else if (desaturate) {");
            if (enableXRay) {
                code.push("       color.rgb = xrayBGColor;");
            }
            code.push("   } ");
            if (enableFog) {
                if (fogMode === "linear") {
                    code.push("float fog = (length(_std_viewPos.xyz) - fogStart) / (fogEnd - fogStart);");
                } else {
                    code.push("float attenuation = fogDensity * max(length(_std_viewPos.xyz) - fogStart, 0.0);");
                    if (fogMode === "exp2") {
                        code.push("attenuation = attenuation * attenuation;");
                    }
                    code.push("float fog = 1.0 - exp(-attenuation);");

                }
                code.push("fog = clamp(fog, fogMin, fogMax);");
                code.push("color.rgb = mix(color.rgb, fogColor, fog);");
            }
            code.push("   return color;");
            code.push("}");

            // Function hooks

            hooks.pixelColor = "_std_PixelColorFunc";
        }


        var json = {
            "type": "shader",
            "shaders": [
                {
                    "stage": "fragment",
                    "code": code,
                    "hooks": hooks
                }
            ],

            // Params that don't correspond to anything in the shader
            // are ignored, so won't bother to specify these conditionally

            "params": defaultParams
        };

        // Insert shader node above scene graph content root

        var contentRootNode = Human.renderer.getContentRootNode();

        var parent = contentRootNode.parent;

        var children = parent.disconnectNodes();

        shaderNode = parent.addNode(json);

        shaderNode.addNodes(children);
    }

    //
    function destroyShaderNode() {

        if (!shaderNode) {
            return;
        }

        // Extract shader node from scene graph,
        // moving its children up to its parent

        shaderNode.splice();

        shaderNode.destroy();

        shaderNode = null;
    }

    function updateShader() {

        var color = colorsForBackgrounds[bgColor] || colorsForBackgrounds["default"] || [0.8, 0.8, 1.0];

        var glassFactor = glassFactorsForBackgrounds[bgColor];

        if (glassFactor === undefined || glassFactor === null) {
            glassFactor = glassFactorsForBackgrounds["default"];
        }

        if (glassFactor === undefined || glassFactor === null) {
            glassFactor = 1.0;
        }

        var murkiness = murkinessForBackgrounds[bgColor];

        if (murkiness === undefined || murkiness === null) {
            murkiness = murkinessForBackgrounds["default"];
        }

        if (murkiness === undefined || murkiness === null) {
            murkiness = 0.8;
        }

        setParams({
            xrayBGColor: color,
            xrayGlassFactor: glassFactor,
            xrayMurkiness: murkiness
        });

        bgDirty = false;
    }

})();
;/**
 * Human.renderer.canvas
 *
 * @namespace Manages the WebGL canvas
 */
(function () {
    "use strict";

    var canvas = $("#" + Human.CANVAS_ID);
    var annotationCanvas = $("#annotationCanvas");

    Human.renderer.canvas = {
        canvas: canvas,
        getCanvas: function() {
            return canvas;
        }
    };

    // HACK for UI compatibility
    Human.renderer.resize = resize;

    $(window).resize(resize);

    resize();

    function resize() {

        var canvasBody = canvas.parent();

        var canvasWidth = canvasBody.width();
        var canvasHeight = canvasBody.height();

        var ssaaMultiplier = Human.renderer.SSAA_MULTIPLIER;

        canvas.attr({
            width: canvasWidth * ssaaMultiplier,
            height: canvasHeight * ssaaMultiplier
        });
        canvas.css({ width: canvasWidth, height: canvasHeight });

        annotationCanvas.attr({ width: canvasWidth, height: canvasHeight });

        Human.events.fire("canvas.resized", {
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight
        });
    }

})();
;/**
 * Human.tasks
 *
 * @namespace Provides ability to schedule asynchronous tasks to a FIFO queue that is pumped on each frame.
 */
(function () {

    "use strict";

    var HumanTasks = Human.tasks = {};

    // How long in milliseconds we're allowed to spend in each frame
    // processing tasks scheduled with #scheduleTask
    var TASK_BUDGET_MSECS = 8;

    Human.events.on("tick",
        function () {

        var timeNow = Date.now();

        // Process as many enqueued tasks as we can
        // within the per-frame task budget

        HumanTasks._runScheduledTasks(timeNow + TASK_BUDGET_MSECS);
    });

    // Task queue, which is pumped on each frame;
    // tasks are pushed to it with calls to #schedule

    HumanTasks._taskQueue = [];

    /**
     * Schedule a task to run at a sunsequent frame.
     *
     * Internally, this pushes the task to a FIFO queue. Within each frame interval, we process the queue
     * for a certain period of time, popping tasks and running them. After each frame interval, tasks that did not
     * get a chance to run during the task are left in the queue to be run next time.
     *
     * @method schedule
     * @param {Function} callback Callback that runs the task.
     * @param {Object} [scope] Scope for the callback.
     */
    HumanTasks.scheduleTask = function (callback, scope) {
        HumanTasks._taskQueue.push(callback);
        HumanTasks._taskQueue.push(scope);
    };

    // Pops and processes tasks in the queue, until the
    // given number of milliseconds has elapsed.
    HumanTasks._runScheduledTasks = function (until) {

        var time = Date.now();
        var taskQueue = HumanTasks._taskQueue;
        var callback;
        var scope;

        while (taskQueue.length > 0 && time < until) {
            callback = taskQueue.shift();
            scope = taskQueue.shift();
            if (scope) {
                callback.call(scope);
            } else {
                callback();
            }
            time = Date.now();
        }
    };
})();;/** @namespace Holds functionality relating to the way the {@link Human.scene} is viewed.
 *
 */
(function() {
  "use strict";

  var view = Human.view = {};

  var modes = ["Highlight", "Xray", "Isolate"];
  
  view.currentMode = modes[0];
  
  view.setModeEnabled = function (mode) {
      mode = mode.toLowerCase();
      
      if(mode === 'isolate') {
          if (!Human.scene.anySelected()) {
              alert("Please select an object before Isolating.");
              return;
          }
      } 
    
      var _modes = modes.map(function (mode) {
          return mode.toLowerCase();
      });
      
      var enabledIndex = _modes.indexOf(mode);
      
      if(enabledIndex >= 0) {
          _modes.forEach(function (mode, i) {
              var enable = (enabledIndex === i);
              Human.view[mode].setEnabled(enable);
          });
      }
  };
})();;/**
 * @namespace Manages the camera
 */
(function () {
    "use strict";

    var HumanViewCamera = Human.view.camera = {};

    // Scene graph nodes, initialized when engine loaded
    var lookatNode = null;
    var cameraNode = null;

    // Used in some methods for distance calculations
    var eyeVec = Human.math.vec3();
    var lookVec = Human.math.vec3();
    var upVec = Human.math.vec3();
    var eyeVecNorm = Human.math.vec3();
    var lookVecNorm = Human.math.vec3();
    var upVecNorm = Human.math.vec3();
    var leftVec = Human.math.vec3();
    var panVec = Human.math.vec3();
    var tempVec = Human.math.vec3();
    var tempMat4 = Human.math.mat4();

    var orbitOrigin = Human.math.vec3();

    /**
     Current eye position
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanViewCamera.eye = { x: 0, y: 0, z: -80 };

    /**
     Current point-of-interest
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanViewCamera.look = { x: 0, y: 0, z: 0 };

    /**
     Current "up" vector
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanViewCamera.up = { x: 0, y: 1, z: 0 };

    /**
     * Offset added to the "look" point in View-space, allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     * @type {{x: number, y: number, z: number}}
     */
    HumanViewCamera._screenPan = {x: 0, y: 0, z: 0 };

    HumanViewCamera._startcamera = {
      eye: { x: 0, y: 0, z: -80 },
      look: { x: 0, y: 0, z: 0 },
      up: { x: 0, y: 1, z: 0 }
    };

    // Schedules scene graph updates when true

    var lookatNodeDirty = false;
    var cameraNodeDirty = false;

    // True when no scene graph updates pending
    var rested = false;

    // Constraints registered with #addConstraint
    var constraints = [];

    /**
     * When true, causes camera to ignore calls to pan or rotate.
     * This is set and unset by Human.camera.fly to stop the user from panning or rotating
     * the camera while flight is in progress, which screws things up.
     */
    HumanViewCamera.lock = false;

    /**
     Camera aspect ration
     @type {number}
     @readonly
     */
    HumanViewCamera.aspect = 1;

    // // Field-of-View angle in degrees
    // Human.properties.subscribe({
    //     propId: "camera.optics.aspect",
    //     value: HumanViewCamera.aspect,
    //     callback: function (value) {
    //         HumanViewCamera.aspect = value;
    //         cameraNodeDirty = true;
    //     }
    // });

    /**
     Field-ov-view angle on Y-axis
     @type {number}
     @readonly
     */
    HumanViewCamera.fovy = 55;

    // Field-of-View angle in degrees
    Human.properties.subscribe({
        propId: "camera.optics.fov",
        value: HumanViewCamera.fovy,
        callback: function (value) {
            HumanViewCamera.fovy = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Distance to the near clipping plane
     @type {number}
     @readonly
     */
    HumanViewCamera.near = 0.1;

    // Distance to near clipping plane
    Human.properties.subscribe({
        propId: "camera.optics.near",
        value: 0.1,
        callback: function (value) {
            HumanViewCamera.near = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Distance to the near clipping plane
     @type {number}
     @readonly
     */
    HumanViewCamera.far = 5000;

    // Distance to far clipping plane
    Human.properties.subscribe({
        propId: "camera.optics.far",
        value: 5000,
        callback: function (value) {
            HumanViewCamera.far = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Minimum allowed distance between {@link #eye} and {@link #look}
     @type {number}
     @readonly
     */
    HumanViewCamera.minZoom = 0.01;

    /**
     Maximum allowed distance between {@link #eye} and {@link #look}
     @type {number}
     @readonly
     */
    HumanViewCamera.maxZoom = 150;

    // Zoom limits - distance between eye and look
    Human.properties.subscribe({
        propId: "camera.zoomLimits",
        value: {
            min: 0.01,
            max: 150
        },
        callback: function (value) {
            if (value.min < 0.01) {
                Human.log.error("Human.view.camera", "Property 'camera.zoomLimits.min' too small - should be >= 0.01");
                return;
            }
            if (value.min >= value.max) {
                Human.log.error("Human.view.camera", "Property 'camera.zoomLimits.min' should be less than camera.zoomLimits.max");
                return;
            }
            HumanViewCamera.minZoom = value.min;
            HumanViewCamera.maxZoom = value.max;
            lookatNodeDirty = true;
        }
    });

    // Gimbal lock constraint
    // When true, camera is "gimbal locked" and spins about model's Y axis
    var gimbalLockY = true;

    Human.properties.subscribe({
        propId: "camera.gimbalLockY",
        value: gimbalLockY,
        callback: function (value) {

            gimbalLockY = value;
        }
    });

    // Pitch constraint
    // When true, prevents camera from being rotated outside [0..180] about X-axis
    var constrainRotateX = false;

    Human.properties.subscribe({
        propId: "camera.constrainRotateX",
        value: constrainRotateX,
        callback: function (value) {

            constrainRotateX = value;

            // Need to reset the camera position because it might
            // be currently outside of the rotation constraint

            // HumanViewCamera.viewAnterior();
        }
    });


    // When engine started
    Human.events.on(
        "loaded",
        function () {

            // Get scene graph nodes

            HumanViewCamera._lookatNode = lookatNode = Human.renderer.getNode(Human.LOOKAT_ID);
            HumanViewCamera._cameraNode = cameraNode = Human.renderer.getNode(Human.CAMERA_ID);

            // Initialise projection aspect ratio

            var optics = cameraNode.getOptics();

            HumanViewCamera.aspect = optics.aspect;
            HumanViewCamera.fovy = optics.fovy;

            // Schedule update of view and projection transforms for next tick

            lookatNodeDirty = true;
            cameraNodeDirty = true;

            // Camera not at rest now
            rested = false;

        });

    // Adjust camera aspect on canvas resize
    Human.events.on("canvas.resized",
        function (params) {
            HumanViewCamera.setAspect(params.canvasWidth / params.canvasHeight);
        });

    Human.events.on(
        "tick",
        function () {

            if (lookatNodeDirty) {

                // View transform update scheduled for scene graph

                lookatNode.setEye(HumanViewCamera.eye);
                lookatNode.setLook(HumanViewCamera.look);
                lookatNode.setUp(HumanViewCamera.up);

                Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
                Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
                Human.math.subVec3(eyeVec, lookVec, tempVec);

                Human.events.fire("camera.updated", {

                    // Camera position
                    eye: HumanViewCamera.eye,
                    look: HumanViewCamera.look,
                    up: HumanViewCamera.up,

                    // Distance from viewpoint to point-of-interest
                    dist: Math.abs(Human.math.lenVec3(tempVec))
                });

                // Camera not at rest now
                rested = false;

                // Scene camera position now up to date
                lookatNodeDirty = false;

            } else {

                // Else camera position now at rest

                if (!rested) {

                    rested = true;

                    Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
                    Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
                    Human.math.subVec3(eyeVec, lookVec, tempVec);

                    Human.events.fire("camera.rested", {

                        // Camera position
                        eye: HumanViewCamera.eye,
                        look: HumanViewCamera.look,
                        up: HumanViewCamera.up,

                        // Distance from viewpoint to point-of-interest
                        dist: Math.abs(Human.math.lenVec3(tempVec))
                    });
                }
            }

            if (cameraNodeDirty) {

                // Update the scene graph

                cameraNode.setOptics({
                        type: "perspective",
                        fovy: HumanViewCamera.fovy,
                        near: HumanViewCamera.near,
                        far: HumanViewCamera.far,
                        aspect: HumanViewCamera.aspect
                    });
                cameraNode.setPan(HumanViewCamera._screenPan);

                // Scene projection now up to date
                cameraNodeDirty = false;
            }

        });

    /**
     Installs a constraint callback into this camera.

     <p>Every time the camera is about to update state, it will only allow that to happen if all constraint callbacks return "true".</p>

     <p>Unexpected results may occur if you add the same callback more than once.</p>

     @param {Function} callback The constraint callback
     */
    HumanViewCamera.addConstraint = function (callback) {
        constraints.push(callback);
    };

    /**
     Removes a constraint callback that was installed previously with {@link #addConstraint}.

     @param {Function} callback The constraint callback
     */
    HumanViewCamera.removeConstraint = function (callback) {
        for (var i = 0, len = constraints.length; i < len; i++) {
            if (constraints[i] === callback) {
                constraints.splice(i, 1);
                return;
            }
        }
    };

    /**
     Sets the position of the camera.

     @param params
     @param [params.eye]
     @param [params.look]
     @param [params.up]
     */
    HumanViewCamera.setLookAt = function (params) {
        HumanViewCamera._setConstrainedLookat(params.eye, params.look, params.up, params.updateOrbitOrigin !== false);
    };

    /**
     * Sets lookat state as long as it passes constraints,
     * return false if constrained else true.
     */
    HumanViewCamera._setConstrainedLookat = function (eye, look, up, updateOrbitOrigin) {

        if (eye) {
            //HumanViewCamera.clampEye(eye);
        }

        eye = eye || HumanViewCamera.eye;
        look = look || HumanViewCamera.look;
        up = up || HumanViewCamera.up;

        for (var i = 0, len = constraints.length; i < len; i++) {

            if (!constraints[i](eye, look, up)) {

                // Camera constrained

                // Need to cancel camera behaviours like fly-to
                // which may be sending the camera off on a wild journey

                Human.events.fire("camera.constrained");

                return false;
            }
        }

        // Not constrained, set state and schedule scene update

        HumanViewCamera.eye = eye;
        HumanViewCamera.look = look;
        HumanViewCamera.up = up;

        if (updateOrbitOrigin) {
            HumanViewCamera.setOrbitOrigin(look);
        }

        lookatNodeDirty = true;
    };

    HumanViewCamera._clampEye = function (pos) {
        lookVec[0] = HumanViewCamera.look.x;
        lookVec[1] = HumanViewCamera.look.y;
        lookVec[2] = HumanViewCamera.look.z;

        eyeVec[0] = pos.x;
        eyeVec[1] = pos.y;
        eyeVec[2] = pos.z;

        Human.math.subVec3(eyeVec, lookVec, tempVec); // Vector from eye to look
        Human.math.normalizeVec3(tempVec, tempVec);
        var dist = Math.abs(Human.math.lenVec3(tempVec));   // Distance from center to pos
        if (dist < HumanViewCamera.minZoom) {
            Human.math.mulVec3Scalar(tempVec, HumanViewCamera.minZoom, tempVec);
            Human.math.addVec3(lookVec, tempVec, tempVec);
        } else if (dist > HumanViewCamera.maxZoom) {
            Human.math.mulVec3Scalar(tempVec, HumanViewCamera.maxZoom, tempVec);
            Human.math.addVec3(lookVec, tempVec, tempVec);
        } else {
            return pos;
        }
        return {
            x: tempVec[0],
            y: tempVec[1],
            z: tempVec[2]
        };
    };

    /**
     Returns the position of this camera.
     @returns {{eye: *, look: *, up: *}}
     */
    HumanViewCamera.getLookAt = function () {
        return {
            eye: HumanViewCamera.eye,
            look: HumanViewCamera.look,
            up: HumanViewCamera.up
        };
    };

    /** Returns the eye position.
     * @returns {{x: Number, y: Number, z: Number}}
     */
    HumanViewCamera.getEye = function () {
        return HumanViewCamera.eye;
    };

    /** Returns the 'look' position.
     * @returns {{x: Number, y: Number, z: Number}}
     */
    HumanViewCamera.getLook = function () {
        return HumanViewCamera.look;
    };

    /** Returns the 'up' vector.
     * @returns {{x: Number, y: Number, z: Number}}
     */
    HumanViewCamera.getUp = function () {
        return HumanViewCamera.up;
    };

    /**
     * Sets offset added to the "look" position in View-space, which allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     *
     * @param {{x: number, y: number, z: number}} screenPan The View-space pan vector
     */
    HumanViewCamera.setScreenPan = function (screenPan) {
        HumanViewCamera._screenPan.x = screenPan.x || 0;
        HumanViewCamera._screenPan.y = screenPan.y || 0;
        HumanViewCamera._screenPan.z = screenPan.z || 0;
        cameraNodeDirty = true;
    };

    /**
     * Gets offset that's added to the "look" point in View-space, which allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     *
     * @return {{x: number, y: number, z: number}} The View-space pan vector
     */
    HumanViewCamera.getScreenPan = function () {
        return HumanViewCamera._screenPan;
    };

    HumanViewCamera._reset = {
        eye: { x: HumanViewCamera.eye.x, y: HumanViewCamera.eye.y, z: HumanViewCamera.eye.z },
        look: { x: HumanViewCamera.look.x, y: HumanViewCamera.look.y, z: HumanViewCamera.look.z },
        up: { x: HumanViewCamera.up.x, y: HumanViewCamera.up.y, z: HumanViewCamera.up.z }
    };

    /**
     * Resets this camera to initial position
     */
    HumanViewCamera.reset = function () {
        HumanViewCamera.yaw = 0;
        HumanViewCamera.pitch = 90;
        HumanViewCamera._eye = { x: HumanViewCamera._reset.eye.x, y: HumanViewCamera._reset.eye.y, z: HumanViewCamera._reset.eye.z };
        HumanViewCamera._look = { x: HumanViewCamera._reset.look.x, y: HumanViewCamera._reset.look.y, z: HumanViewCamera._reset.look.z };
        HumanViewCamera._up = { x: HumanViewCamera._reset.up.x, y: HumanViewCamera._reset.up.y, z: HumanViewCamera._reset.up.z };
        lookatNodeDirty = true;
    };


    /**
     * Rotate look->eye vector about 'orbitOrigin', around the 'up' vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */

    HumanViewCamera.rotateSceneY = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(eyeVec, lookVec, lookVec);

        // Get 'orbitOrigin' -> 'eye' vector
        Human.math.subVec3(eyeVec, orbitOrigin, eyeVec);

        // Rotate 'orbitOrigin' -> 'eye' vector about 'up' vector
        Human.math.rotationMat4v(angle * 0.0174532925, gimbalLockY ? [0, 1, 0] : upVec, tempMat4);
        Human.math.transformVector3(tempMat4, eyeVec, eyeVec);

        // Rotate 'look' -> 'eye' vector
        Human.math.transformVector3(tempMat4, lookVec, lookVec);

        // Get 'eye' position
        Human.math.addVec3(orbitOrigin, eyeVec, eyeVec);

        // Get 'look' position
        Human.math.subVec3(eyeVec, lookVec, lookVec);

        if (gimbalLockY) {

            // Rotate 'up' vector about orthogonal vector
            Human.math.transformVector3(tempMat4, upVec, upVec);
        }

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },

            look: {
                x: lookVec[0], 
                y: lookVec[1],
                z: lookVec[2]
            },

            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }, 

            updateOrbitOrigin: false
        });
    };



    /**
     * Rotate 'eye' about 'look', around the 'up' vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */

    HumanViewCamera.rotateY = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(eyeVec, lookVec, eyeVec);

        // Rotate 'eye' vector about 'up' vector
        Human.math.rotationMat4v(angle * 0.0174532925, gimbalLockY ? [0, 1, 0] : upVec, tempMat4);
        Human.math.transformVector3(tempMat4, eyeVec, eyeVec);

        // Set eye position as 'look' plus 'eye' vector
        Human.math.addVec3(eyeVec, lookVec, eyeVec);

        if (gimbalLockY) {

            // Rotate 'up' vector about orthogonal vector
            Human.math.transformVector3(tempMat4, upVec, upVec);
        }

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },

            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }
        });
    };



    /**
     * Rotate look->eye vector about 'orbitOrigin', around the Orthogonal Vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */

    HumanViewCamera.rotateSceneX = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(eyeVec, lookVec, lookVec);

        // Get 'orbitOrigin' -> 'eye' vector
        Human.math.subVec3(eyeVec, orbitOrigin, eyeVec);

        Human.math.normalizeVec3(lookVec, eyeVecNorm);
        Human.math.mulVec3Scalar(eyeVecNorm, -1);
        Human.math.normalizeVec3(upVec, upVecNorm);
        
        // Get orthogonal vector from 'eye' and 'up'
        Human.math.cross3Vec3(eyeVecNorm, upVecNorm, leftVec);

        // Rotate 'orbitOrigin' -> 'eye' vector about orthogonal vector
        Human.math.rotationMat4v(angle * 0.0174532925, leftVec, tempMat4);
        Human.math.transformVector3(tempMat4, eyeVec, eyeVec);

        // Rotate 'look' -> 'eye' vector
        Human.math.transformVector3(tempMat4, lookVec, lookVec);

        // Get 'eye' position
        Human.math.addVec3(orbitOrigin, eyeVec, eyeVec);

        // Get 'look' position
        Human.math.subVec3(eyeVec, lookVec, lookVec);

        // Rotate 'up' vector about orthogonal vector
        Human.math.transformVector3(tempMat4, upVec, upVec);

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },

            look: {
                x: lookVec[0], 
                y: lookVec[1],
                z: lookVec[2]
            },

            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }, 

            updateOrbitOrigin: false
        });
    };


    /**
     * Rotate 'eye' about 'look' around the Orthogonal Vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */

    HumanViewCamera.rotateX = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(eyeVec, lookVec, eyeVec);

        Human.math.normalizeVec3(eyeVec, eyeVecNorm);
        Human.math.normalizeVec3(upVec, upVecNorm);
        
        // Get orthogonal vector from 'eye' and 'up'
        Human.math.cross3Vec3(eyeVecNorm, upVecNorm, leftVec);

        // Rotate 'eye' vector about orthogonal vector
        Human.math.rotationMat4v(angle * 0.0174532925, leftVec, tempMat4);
        Human.math.transformVector3(tempMat4, eyeVec, eyeVec);

        if (constrainRotateX) {

            // Pitch constraint
            // Prevents camera from being rotated outside [0..180] about X-axis
            // TODO: This implementation does not work through full 360 degrees
//
//        var alt =  (57.2957795 * Math.atan2(eye2[1], Math.sqrt(eye2[0] * eye2[0] + eye2[2] * eye2[2])));
//        var az = 57.2957795 * Math.atan2(-eye2[0], -eye2[2]);
//        if (alt > 80 || alt < -80) {
//            return;
//        }
        }

        // Set eye position as 'look' plus 'eye' vector
        Human.math.addVec3(eyeVec, lookVec, eyeVec);

        // Rotate 'up' vector about orthogonal vector
        Human.math.transformVector3(tempMat4, upVec, upVec);

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },

            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }
        });
    };

    /**
     * Rotate 'look' about 'eye', around the 'up' vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */
    HumanViewCamera.rotateLookY = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(lookVec, eyeVec, lookVec);

        // Rotate 'look' vector about 'up' vector
        Human.math.rotationMat4v(angle * 0.0174532925, gimbalLockY ? [0, 1, 0] : upVec, tempMat4);
        Human.math.transformVector3(tempMat4, lookVec, lookVec);

        // Set look position as 'look' plus 'eye' vector
        Human.math.addVec3(lookVec, eyeVec, lookVec);

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },
            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }
        });
    };

    /**
     * Rotate 'eye' about 'look' around the X-axis
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */
    HumanViewCamera.rotateLookX = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(lookVec, eyeVec, lookVec);

        Human.math.normalizeVec3(lookVec, lookVecNorm);
        Human.math.normalizeVec3(upVec, upVecNorm);


        // Get orthogonal vector from 'eye' and 'up'
        Human.math.cross3Vec3(lookVecNorm, upVecNorm, leftVec);

        // Rotate 'look' vector about orthogonal vector
        Human.math.rotationMat4v(angle * 0.0174532925, leftVec, tempMat4);
        Human.math.transformVector3(tempMat4, lookVec, lookVec);

        // Set eye position as 'look' plus 'eye' vector
        Human.math.addVec3(lookVec, eyeVec, lookVec);

        // Rotate 'up' vector about orthogonal vector
        Human.math.transformVector3(tempMat4, upVec, upVec);

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },
            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }
        });
    };


    /**
     * Set orbitOrigin used for camera orbiting when inputOrbitSpecializedMode == true
     * Called from focus.js when focusObject
     */
    HumanViewCamera.setOrbitOrigin = function (newPos) {
        orbitOrigin[0] = newPos.x || 0;
        orbitOrigin[1] = newPos.y || 0;
        orbitOrigin[2] = newPos.z || 0;
    };

    /**
     * Pans the camera along X and Y axis.
     * Applies constraints added with {@link #addConstraint}.
     * @param pan The pan vector
     */

    var eyeVec2 = Human.math.vec3();

    HumanViewCamera.pan = function (pan) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        // Get eye, look and up as arrays
        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(eyeVec, lookVec, eyeVec2);

        // Building this pan vector
        Human.math.zeroVec(panVec);

        if (pan.x !== undefined && pan.x !== null) {

            // Pan along orthogonal vector to 'look' and 'up'

            Human.math.normalizeVec3(eyeVec2, eyeVecNorm);
            Human.math.normalizeVec3(upVec, upVecNorm);

            var left = Human.math.cross3Vec3(eyeVec2, upVec, leftVec);
            Human.math.normalizeVec3(Human.math.cross3Vec3(eyeVec2, upVec, leftVec), left);

            Human.math.mulVec3Scalar(left, pan.x, tempVec);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        if (pan.y !== undefined && pan.y !== null) {

            // Pan along 'up' vector
            Human.math.normalizeVec3(upVec, upVecNorm);

            Human.math.mulVec3Scalar(upVecNorm, pan.y, tempVec);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        if (pan.z !== undefined && pan.z !== null) {

            // Pan along 'eye'- -> 'look' vector

            Human.math.normalizeVec3(eyeVec, eyeVecNorm);

            Human.math.mulVec3Scalar(eyeVecNorm, pan.z, tempVec);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        Human.math.addVec3(eyeVec, panVec, eyeVec);
        Human.math.addVec3(lookVec, panVec, lookVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },
            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },
            updateOrbitOrigin: false
        });
    };

    /** Sets the projection aspect ratio
     */
    HumanViewCamera.setAspect = function (aspect) {
        HumanViewCamera.aspect = aspect;
        cameraNodeDirty = true;
    };

    /**
     Positions camera to look at the scene from along the -X axis.
     */
    HumanViewCamera.viewRight = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: -dist, y: elev, z: 0 },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the +X axis.
     */
    HumanViewCamera.viewLeft = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: dist, y: elev, z: 0 },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the +Z axis.
     */
    HumanViewCamera.viewPosterior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: elev, z: -dist },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the -Z axis.
     */
    HumanViewCamera.viewAnterior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: elev, z: dist },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the +Y axis.
     */
    HumanViewCamera.viewSuperior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: -dist + elev, z: 0 },
            up: {x: 0, y: 0, z: 1 }
        });

    };

    /**
     Positions camera to look at the scene from along the +Y axis.
     */
    HumanViewCamera.viewInferior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: dist + elev, z: 0 },
            up: {x: 0, y: 0, z: -1 }
        });

    };

    /**
     * Increments/decrements zoom factor, ie. distance between eye and look.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @param delta
     */
    HumanViewCamera.zoom = function (delta) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.subVec3(eyeVec, lookVec, eyeVec);            // Get vector from eye to look
        var lenLook = Math.abs(Human.math.lenVec3(eyeVec));    // Get len of that vector
        var newLenLook = Math.abs(lenLook + delta);         // Get new len after zoom

        if (HumanViewCamera.minZoom && HumanViewCamera.maxZoom) {

            var f = (lenLook / HumanViewCamera.maxZoom) * 0.6;

            delta = (40 * delta) * f;

            newLenLook = Math.abs(lenLook + delta);

            if (newLenLook < HumanViewCamera.minZoom) {
                newLenLook = HumanViewCamera.minZoom;

            } else if (newLenLook > HumanViewCamera.maxZoom) {
                newLenLook = HumanViewCamera.maxZoom;
            }
        }

        Human.math.normalizeVec3(eyeVec, eyeVecNorm);  // Get normalised vector
        Human.math.mulVec3Scalar(eyeVecNorm, newLenLook, eyeVec);
        Human.math.addVec3(lookVec, eyeVec, eyeVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            }, 

            updateOrbitOrigin: false
        });
    };

    /**
     * Sets the zoom as a factor indicating a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @param {Number} zoomFactor The factor
     */
    HumanViewCamera.setZoom = function (zoomFactor) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        Human.math.subVec3(eyeVec, lookVec, eyeVec);  // Get vector from eye to look
        Human.math.normalizeVec3(eyeVec, eyeVecNorm);  // Get normalised vector
        Human.math.mulVec3Scalar(eyeVecNorm, HumanViewCamera.minZoom + (1.0 - zoomFactor) * (HumanViewCamera.maxZoom - HumanViewCamera.minZoom), eyeVec);

        Human.math.addVec3(lookVec, eyeVec, eyeVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            }
        });
    };

    /**
     * Returns the zoom as a factor indicating a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * @return {Number} The zoom factor
     */
    HumanViewCamera.getZoom = function () {

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        Human.math.subVec3(eyeVec, lookVec, eyeVec);            // Get vector from eye to look
        var lenLook = Math.abs(Human.math.lenVec3(eyeVec));    // Get len of that vector

        return 1 - (((lenLook - HumanViewCamera.minZoom) / HumanViewCamera.maxZoom));
    };


    /**
     * Sets the zoom via a percentage factor which indicates a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @deprecated
     * @param {Number} zoomPercent The percentage factor
     */
    HumanViewCamera.setZoomPercent = function (zoomPercent) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        Human.math.subVec3(eyeVec, lookVec, eyeVec);  // Get vector from eye to look
        Human.math.normalizeVec3(eyeVec, eyeVecNorm);  // Get normalised vector

        Human.math.mulVec3Scalar(eyeVecNorm, HumanViewCamera.minZoom + (100.0 - zoomPercent) * 0.01 * (HumanViewCamera.maxZoom - HumanViewCamera.minZoom), eyeVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: lookVec[0] + eyeVec[0],
                y: lookVec[1] + eyeVec[1],
                z: lookVec[2] + eyeVec[2]
            }
        });
    };

    /**
     * @deprecated
     */
    HumanViewCamera.getZoomPercent = function () {

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        Human.math.subVec3(eyeVec, lookVec, eyeVec);            // Get vector from eye to look
        var lenLook = Math.abs(Human.math.lenVec3(eyeVec));    // Get len of that vector

        return 100 - (((lenLook - HumanViewCamera.minZoom) / HumanViewCamera.maxZoom) * 100);
    };
})();
;/**
 * @namespace Manages camera curve path, an array of 3d cubic bezier curves
 */
(function () {
    "use strict";
    
    Human.view.camera.CurvePath = function() {
        var curves = [];
        
        var numPoints, numCurves;
        
        var pathLength = 0;

        var tempVec3 = Human.math.vec3();
        
        var Bezier = Human.math.bezier;
        
        /** Build the curves array. 
         * param {[Human.math.vec3]} points
         */
        this.init = function(points) {
            curves = [];
            pathLength = 0;
            numPoints = points.length;
            numCurves = numPoints - 1;
            
            if(numPoints < 2) {
                // invalid
                Human.log.error('curvePath init no enough points');
            }
            
            // used to compute control points at edge
            var startPoint = Human.math.vec3();
            var endPoint = Human.math.vec3();
            
            Human.math.subVec3(points[0], points[1], tempVec3);
            Human.math.mulVec3Scalar(tempVec3, 0.25, tempVec3);
            Human.math.addVec3(points[0], tempVec3, startPoint);
            
            Human.math.subVec3(points[numPoints - 1], points[numPoints - 2], tempVec3);
            Human.math.mulVec3Scalar(tempVec3, 0.25, tempVec3);
            Human.math.addVec3(points[numPoints - 1], tempVec3, endPoint);
            
            var i;
            var p00, p0, p1, p11;   // 4 interpolate points
            var b0; 
            var b1 = Human.math.vec3();
            var b2 = Human.math.vec3();
            var b3;   // 4 control points for one cubic bezier curve
            for(i = 1; i < numPoints; ++i) {
                p0 = points[i-1];
                p1 = points[i];
                b0 = p0;
                b3 = p1;
                                
                // b1 = b0 + ((p1 - p00) * 0.25);
                if ( i <= 1) {
                    Human.math.subVec3(p0, startPoint, tempVec3);
                } else {
                    p00 = points[i-2];
                    Human.math.subVec3(p1, p00, tempVec3);
                    Human.math.mulVec3Scalar(tempVec3, 0.25, tempVec3);
                }
                Human.math.addVec3(b0, tempVec3, b1);
                
                // b2 = b3 - ((p2 - p0) * 0.25);
                if ( i >= numPoints - 1) {
                    Human.math.subVec3(endPoint, p1, tempVec3);
                } else {
                    p11 = points[i+1];
                    Human.math.subVec3(p11, p0, tempVec3);
                    Human.math.mulVec3Scalar(tempVec3, 0.25, tempVec3);
                }
                Human.math.subVec3(b3, tempVec3, b2);
                                
                curves.push(new Bezier(
                    b0[0], b0[1], b0[2],
                    b1[0], b1[1], b1[2],
                    b2[0], b2[1], b2[2],
                    b3[0], b3[1], b3[2]
                ));
            }
            
            // calculate curve path total length by summing up length of each segment
            for(i = 0; i < numCurves; ++i) {
                pathLength += curves[i].length();
            } 
            
        };
        
        /**
         * t: 0-1
         */
        
        this.getPosition = function(t) {
            var p = this.getParameter(t);
            
            return {position: curves[p.i].compute(p.t01), i: p.i, t01: p.t01};
        };
        
        /**
         * i: 0 , numPoints - 2
         */
        this.getParameter = function(t) {
            var i, t01;
            t01 = t * (numPoints-1);
            t01 = Human.math.clamp(t01, 0, numPoints - 1);
            
            i = Math.floor(t01);
            if (i >= numPoints - 1) {
                i -= 1;
            }
            
            t01 -= i;
            
            return {i: i, t01: t01};
        };
        
        /**
         * 
         */
        this.getPathLength = function() {
            return pathLength;
        };
    };
})();;/**
 * @namespace Manages camera flights
 */
(function () {
    "use strict";

    var fly = Human.view.camera.fly = {};

    // TODO: delete this, for tweaking only
    fly.flyTimeScale = 1;
    fly.cylindricalView = false;
    fly.cylindricalOnly = false;
    fly.cylindricalRotationLerpMin = Math.PI / 6;
    fly.cylindricalRotationLerpMax = Math.PI / 2;
    fly.cylindricalRadiusLerpMin = 0.2;
    fly.cylindricalRadiusLerpMax = 1.0;

    var stopFOV;

    Human.properties.subscribe({
        propId: "camera.flyTo",
        value: {
            stopFOV: 55
        },
        callback: function (value) {
            stopFOV = value.stopFOV || 55;
        }
    });

    var callbacks = [];
    var animation = null;
    var eyeVec3 = Human.math.vec3();
    var lookVec3 = Human.math.vec3();
    var paramLookVec3 = Human.math.vec3();
    var tempVec3 = Human.math.vec3();

    var eyeCurvePath = new Human.view.camera.CurvePath();
    var lookCurvePath = new Human.view.camera.CurvePath();

    Human.events.on("tick",
        function () {
            if (animation) {
                animation.update(Date.now());
            }
        });

    fly.cancelAnimation = function () {
        if (animation) {
            //animation._onComplete(animation);
            finishAnimation();
            animation = null;
        }
    };

    /** Initiates camera flight along a catmull rom spline
     *
     * <p>This method can be called again at any time during a fly-to to initiate a new flight
     * that replaces any already in progress.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {[Object]} [params.points]
     * @param {*} [params.points[].eye] (alias position) Eye position to fly to
     * @param {*} [params.points[].look] (alias look) Look vector to fly to
     * @param {Number} [params.velocity] Camera flight velocity factor - default is 1.0
     * @param {Boolean} [params.constrainUp]
     * @param {Boolean} [params.easing]
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.view.camera.fly
     */
    fly.flyAlongCurvePath = function (params, ok, error) {

        ok = ok || function () {
        };
        error = error || function (msg) {
            Human.log.error("Human.view.camera.fly.flyAlongCurvePath", msg);
            ok();
        };

        if(!params) {
            error("params must be defined");
            ok();
        }

        var velocity = params.velocity !== undefined ? params.velocity : 1;


        var eyePoints = [];
        var lookPoints = [];
        var upVecs = [];

        var i, len;
        for(i = 0, len = params.points.length; i < len; ++i) {
            eyePoints.push(Human.math.vec3ObjToArray(params.points[i].eye || params.points[i].position));
            lookPoints.push(Human.math.vec3ObjToArray(params.points[i].look || params.points[i].target));
            upVecs.push(Human.math.vec3ObjToArray(params.points[i].up));
        }

        eyeCurvePath.init(eyePoints);
        lookCurvePath.init(lookPoints);

        flyAlongCurvePath({
            eyeCurvePath: eyeCurvePath, lookCurvePath: lookCurvePath, upVecs: upVecs,
            velocity: velocity, constrainUp: params.constrainUp, easing: params.easing
        }, ok);

    };

    function flyAlongCurvePath(params, ok) {

        Human.view.camera.lock = true;

        // Keep callbacks already registered so
        // that their owners still get completion
        if (ok) {
            callbacks.push(ok);
        }
        params = params || {};

        // Replace old animation if one existing
        animation = new Human.view.camera.fly.CurvePathAnimation({
            //mode: 'curvePath',
            eyeCurvePath: params.eyeCurvePath,
            lookCurvePath: params.lookCurvePath,
            upVecs: params.upVecs,
            velocity: params.velocity,
            constrainUp: params.constrainUp,
            easing: params.easing,

            onComplete: finishAnimation
        });

        animation.update(Date.now());
    }

    /** Initiates camera flight to the given target
     *
     * <p>This method can be called again at any time during a fly-to to initiate a new flight
     * that replaces any already in progress.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {String} [params.objectId] Scene object to fly to, given by ID
     * @param {String} [params.fmaId] Scene object to fly to, given by FMAID
     * @param {*} [params.boundary] Boundary to fly to
     * @param {*} [params.lookVec] Look vector to fly along
     * @param {*} [params.eye] Eye position to fly to, used in conjunction with params.look
     * @param {*} [params.look] Look vector to fly to, used in conjunction with params.eye
     * @param {Boolean} [params.selectedObjects] Flies to boundary of all currently selected scene objects when true
     * @param {Boolean} [params.selectedLeafObjects] Flies to boundary of all currently selected scene leaf objects when true
     * @param {Boolean} [params.enabledObjects] Flies to boundary of all currently enabled scene objects when true
     * @param {Number} [params.velocity] Camera flight velocity factor - default is 1.0
     * @param {Number} [params.arc] Camera flight arc factor - 0.0 for no arc, 1.0 for maximum arc - default is 0.0
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.view.camera.fly
     */
    fly.flyTo = function (params, ok, error) {
        var object, boundary, objectId;

        ok = ok || function () {
        };
        error = error || function (msg) {
            Human.log.error("Human.view.camera.fly", msg);
            ok();
        };

        if (params.objectId) {

            // Fly to scene object, found by ID

            objectId = params.objectId;
            object = Human.scene.objects[objectId];
            if (!object) {
                error("No scene object found for the given ID: '" + objectId + "'");
                return;
            }
            boundary = Human.scene.getBoundary({ objectId: objectId });
            if (boundary) {
                Human.view.boundary.setBoundary(boundary, true);     // Show boundary
                flyTo({
                        target: { boundary: boundary },
                        arc: params.arc,
                        backOff: params.backOff,
                        velocity: params.velocity,
                        cylindricalView: params.cylindricalView
                    },
                    function () {
                        Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                        ok();
                    });
            } else {
                ok();
            }
        } else if (params.fmaId) {

            // Fly to scene object, found by FMAID

            var fmaId = params.fmaId;
            object = Human.scene.objectsByFMAID[fmaId];
            if (!object) {
                error("no object found for the given FMA ID: '" + fmaId + "'");
                return;
            }
            boundary = Human.scene.getBoundary({ objectId: object.objectId });
            if (boundary) {
                Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
                flyTo({
                    target: { boundary: boundary },
                    arc: params.arc,
                    backOff: params.backOff,
                    velocity: params.velocity,
                    cylindricalView: params.cylindricalView
                }, function () {
                    Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                    ok();
                });
            } else {
                ok();
            }

        } else if (params.boundary) {

            // Fly to look at given boundary

            boundary = params.boundary;
            Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
            flyTo({
                target: { boundary: boundary },
                arc: params.arc,
                backOff: params.backOff,
                velocity: params.velocity,
                cylindricalView: params.cylindricalView
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                ok();
            });

        } else if (params.lookVec) {

            // Fly along look vector

            var lookVec = params.lookVec;
            var eye = Human.view.camera.eye;
            var look = Human.view.camera.look;

            paramLookVec3[0] = lookVec.x;
            paramLookVec3[1] = lookVec.y;
            paramLookVec3[2] = lookVec.z;

            eyeVec3[0] = eye.x;
            eyeVec3[1] = eye.y;
            eyeVec3[2] = eye.z;

            lookVec3[0] = look.x;
            lookVec3[1] = look.y;
            lookVec3[2] = look.z;

            Human.math.subVec3(lookVec3, eyeVec3, tempVec3);
            // Distance from current eye to look
            var distEyeLook = Human.math.lenVec3(tempVec3);

            Human.math.subVec3(paramLookVec3, eyeVec3, tempVec3);
            // Distance from current eye to the given point we'll point the look at
            var distVec = Human.math.lenVec3(tempVec3);
            // Ratio of distances
            var factor = distEyeLook / distVec;
            // Find point on vector [eye->lookVec] that is the same dist from eye as [eye->look]
            Human.math.lerpVec3(
                factor,
                0,
                1,
                lookVec3,
                paramLookVec3,
                lookVec3);    // New look vector destination
            // Fly to it, without arcing movement
            flyTo({
                    target: {
                        look: { x: lookVec3[0], y: lookVec3[1], z: lookVec3[2] }
                    },
                    arc: params.arc,
                    velocity: params.velocity,
                    cylindricalView: params.cylindricalView
                },
                ok);

        } else if (params.eye || params.look) {

            // Fly to given eye point and look vector

            flyTo({
                    target: { eye: params.eye, look: params.look, up: params.up },
                    arc: params.arc,
                    backOff: params.backOff,
                    velocity: params.velocity,

                    // Want to animate "up" vector, which we don't animate by default
                    // in order to preserve camera's upwards orientation while flying
                    constrainUp: false,

                    cylindricalView: params.cylindricalView
                },
                ok);

        } else if (params.selectedObjects) {

            // Fly to boundary of all currently selected scene objects

            boundary = Human.scene.getBoundary({ objects: Human.scene.selectedObjects });
            Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
            flyTo({
                target: { boundary: boundary }, arc: params.arc, backOff: params.backOff,
                velocity: params.velocity,
                cylindricalView: params.cylindricalView
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                ok();
            });

        } else if (params.selectedLeafObjects) {

            // Fly to boundary of all currently selected scene leaf objects

            var list = [];
            var selectedObjects = Human.scene.selectedObjects;
            for (objectId in selectedObjects) {
                if (selectedObjects.hasOwnProperty(objectId)) {
                    object = selectedObjects[objectId];
                    if (object.objects.length === 0) {
                        list.push(objectId);
                    }
                }
            }
            boundary = Human.scene.getBoundary({ objectIds: list });
            Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
            flyTo({
                target: { boundary: boundary }, arc: params.arc, backOff: params.backOff,
                velocity: params.velocity,
                cylindricalView: params.cylindricalView
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                ok();
            });

        } else if (params.enabledObjects) {

            // Fly to boundary of all currently visible scene objects

            boundary = Human.scene.getBoundary({ objects: Human.scene.enabledObjects });
            flyTo({
                target: { boundary: boundary }, arc: params.arc, backOff: params.backOff,
                velocity: params.velocity,
                cylindricalView: params.cylindricalView
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                ok();
            });

        } else if (params.objects) {

            // Fly to boundary of given scene objects

            boundary = Human.scene.getBoundary({ objectIds: params.objects });
            flyTo({
                target: { boundary: boundary }, arc: params.arc, backOff: params.backOff,
                velocity: params.velocity,
                cylindricalView: params.cylindricalView
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                ok();
            });
        } else {

            // Fly to default position

            flyTo({
                    target: {
                        eye: { x: 0.0, y: 6.0, z: -70.0 },
                        look: { x: 0.0, y: 0.0, z: 0 },
                        up: {x: 0.0, y: 1.0, z: 0.0}
                    },
                    arc: params.arc,
                    backOff: params.backOff,
                    velocity: params.velocity,
                    cylindricalView: params.cylindricalView
                },
                function () {
                    ok();
                });
        }
    };

    function flyTo(params, ok) {

        Human.view.camera.lock = true;

        // Keep callbacks already registered so
        // that their owners still get completion
        if (ok) {
            callbacks.push(ok);
        }
        params = params || {};
        // Replace old animation if one existing
        animation = new Human.view.camera.fly.Animation({
            target: params.target, arc: params.arc, backOff: params.backOff, velocity: params.velocity,
            constrainUp: params.constrainUp,
            onComplete: finishAnimation,
            cylindricalView: params.cylindricalView
        });
        animation.update(Date.now());
    }

    function finishAnimation() {
        animation = null;
        while (callbacks.length > 0) {
            callbacks.pop()();
        }
        Human.view.camera.lock = false;
    }

    /** Jumps camera to the given target
     *
     * <p>Terminates any camera flight in progress and signals its completion.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {String} [params.objectId] Scene object to fly to, given by ID
     * @param {String} [params.fmaId] Scene object to fly to, given by FMAID
     * @param {*} [params.boundary] Boundary to fly to
     * @param {*} [params.lookVec] Look vector to fly along
     * @param {*} [params.eye] Eye position to fly to, used in conjunction with params.look
     * @param {*} [params.look] Look vector to fly to, used in conjunction with params.eye
     * @param {Boolean} [params.selectedObjects] Flies to boundary of all currently selected scene objects when true
     * @param {Boolean} [params.enabledObjects] Flies to boundary of all currently enabled scene objects when true
     * @param {Number} [params.backOff] Camera back-off factor in range of [0..1], when 0 is close (default), 1 is far
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.view.camera.fly
     */
    fly.jumpTo = function (params, ok, error) {
        var object, boundary, objectId;

        ok = ok || function () {
        };

        error = error || function (msg) {
            Human.log.error("Human.view.camera.fly", msg);
            ok();
        };

        var target;

        if (params.objectId) {

            // Boundary of scene object, found by ID

            objectId = params.objectId;
            object = Human.scene.objects[objectId];
            if (!object) {
                error("No scene object found for the given ID: '" + objectId + "'");
                return;
            }
            boundary = Human.scene.getBoundary({ objectId: objectId });

            if (boundary) {
                target = {
                    target: {
                        boundary: boundary
                    },
                    backOff: params.backOff
                };
            }

        } else if (params.fmaId) {

            // Boundary of scene object, found by FMAID

            var fmaId = params.fmaId;
            object = Human.scene.objectsByFMAID[fmaId];
            if (!object) {
                error("no object found for the given FMA ID: '" + fmaId + "'");
                return;
            }
            boundary = Human.scene.getBoundary({ objectId: object.objectId });
            if (boundary) {
                target = {
                    target: {
                        boundary: boundary
                    },
                    backOff: params.backOff
                };
            }

        } else if (params.boundary) {

            target = jumpToBoundary(params);

        } else if (params.eye || params.look) {

            // Given eye point and look vector

            if (!params.eye && !params.look) {
                error("incomplete parameter configuration: both 'eye' and 'look' expected");
                return;
            }
            target = {
                target: {
                    eye: params.eye,
                    look: params.look,
                    up: params.up
                }
            };

        } else if (params.selectedObjects) {

            // Boundary of all currently selected scene objects

            boundary = Human.scene.getBoundary({ objects: Human.scene.selectedObjects });
            Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
            target = {
                target: {
                    boundary: boundary
                },
                backOff: params.backOff
            };

        } else if (params.enabledObjects) {

            // Boundary of all currently visible scene objects

            boundary = Human.scene.getBoundary({ objects: Human.scene.enabledObjects });
            target = {
                target: {
                    boundary: boundary
                },
                backOff: params.backOff
            };

        } else if (params.lookVec) {

            // Fly along look vector

            var lookVec = params.lookVec;
            var eye = Human.view.camera.eye;
            var look = Human.view.camera.look;

            // Distance from current eye to look
            var distEyeLook = Human.math.lenVec3(Human.math.subVec3([look.x, look.y, look.z], [eye.x, eye.y, eye.z]));

            // Distance from current eye to the given point we'll point the look at
            var distVec = Human.math.lenVec3(Human.math.subVec3([lookVec.x, lookVec.y, lookVec.z], [eye.x, eye.y, eye.z]));

            // Ratio of distances
            var factor = distEyeLook / distVec;

            // Find point on vector [eye->lookVec] that is the same dist from eye as [eye->look]
            var newLook = Human.math.lerpVec3(
                factor,
                0,
                1,
                [look.x, look.y, look.z],
                [lookVec.x, lookVec.y, lookVec.z]);
            // Fly to it, without arcing movement
            target = {
                target: {
                    look: { x: newLook[0], y: newLook[1], z: newLook[2] }
                }
            };

        } else {

            // Default position

            target = {
                target: {
                    eye: { x: 0.0, y: 6.0, z: -70.0 },
                    look: { x: 0.0, y: 0.0, z: 0 },
                    up: {x: 0.0, y: 1.0, z: 0.0}
                },
                backOff: params.backOff
            };
        }

        if (target) {

            finishAnimation();

            if (target.target.boundary) {
                target.target.stopFOV = stopFOV || target.target.stopFOV;
                Human.view.camera.fly.jumpTo(target.target);
            } else {
                Human.view.camera.setLookAt(target.target);
            }
        }

        ok();
    };

    /*
    * Force cancellation of currently running animation.
    */
    fly.cancel = finishAnimation;

    function jumpToBoundary(params) {
        // Given boundary
        var backOff = params.backOff || 0;
        if (backOff < 0) {
            backOff = 0;
        } else if (backOff > 1) {
            backOff = 1;
        }
        backOff = 1 - backOff;

        var cameraLook = Human.math.vec3ObjToArray(Human.view.camera.look);
        var cameraEye = Human.math.vec3ObjToArray(Human.view.camera.eye);
        var vec = Human.math.vec3();

        Human.math.subVec3(cameraEye, cameraLook, vec);
        Human.math.normalizeVec3(vec, vec);

        var boundary = params.boundary;
        var boundaryCenter = Human.math.getBoundaryCenter(boundary);
        var stopFOV = params.stopFOV;
        var lenVec = Human.math.lenVec3(vec);
        var diag = Human.math.getBoundaryDiag(boundary);
        var len = Math.abs((diag / (1.0 + (backOff * 0.8))) / Math.tan(stopFOV / 2));  /// Tweak this to set final camera distance on arrival
        var sca = len / lenVec;

        Human.math.mulVec3Scalar(vec, sca, vec);
        Human.math.addVec3(boundaryCenter, vec, vec);

        return {
            target: {
                eye: {
                    x: vec[0],
                    y: vec[1],
                    z: vec[2]
                },
                look: {
                    x: boundaryCenter[0],
                    y: boundaryCenter[1],
                    z: boundaryCenter[2]
                },
                up: {
                    x: 0,
                    y: 1,
                    z: 0
                }
            }
        };
    }

})();
;/**
 * @class Interpolates a {@link Human.view.camera} along a curved path from current position to look at a
 * target region of space.
 * @private
 *
 */
(function () {
    "use strict";

    var velocity;
    var stopFOV;

    var tempVec = Human.math.vec3();
    // For cyliner coordinate
    var eye1Cylinder = Human.math.vec3();
    var eye2Cylinder = Human.math.vec3();

    Human.properties.subscribe({
        propId: "camera.flyTo",
        value: {
            velocity: 1.0,
            stopFOV: 55
        },
        callback: function (value) {
            velocity = value.velocity || 1.0;
            stopFOV = value.stopFOV || 55;
        }
    });

    /**
     * Returns a value t between 0 and 1, eye2 = (1-t) * translation_eye2 + t * cylindrical_eye2 (nlerp) 
     * @private
     */
    function getCylindricalAndTranslationBlendFactor(rotation, radius) {
        var fly = Human.view.camera.fly;
        var t1 = Human.math.clamp((rotation - fly.cylindricalRotationLerpMin) / (fly.cylindricalRotationLerpMax - fly.cylindricalRotationLerpMin), 0, 1); 
        var t2 = Human.math.clamp((radius - fly.cylindricalRadiusLerpMin) / (fly.cylindricalRadiusLerpMax - fly.cylindricalRadiusLerpMin), 0, 1);
        return Math.min(t1,t2);
    }

    /**
     * @private
     */
    Human.view.camera.fly.Animation = function (cfg) {
        var target = cfg.target;

        var cylindricalView = cfg.cylindricalView !== undefined ? cfg.cylindricalView : Human.view.camera.fly.cylindricalView;

        this.arc = cylindricalView ? (cfg.arc === undefined ? 1.0 : cfg.arc) : 0;

        this.easing = cfg.easing === undefined ? true : cfg.easing;

        // When true, we'll not change the camera's "up" vector
        //this.constrainUp = cfg.constrainUp !== false;
        this.constrainUp = cfg.constrainUp === undefined ? false : cfg.constrainUp;

        if (!target) {
            Human.log.error("Human.view.camera.fly.Animation config missing: target");
            if (cfg.onComplete) {
                cfg.onComplete();
            }
            return;
        }
        // Initial camera state
        var camera = Human.view.camera;
        this._look1 = Human.math.vec3ObjToArray(camera.look);
        this._eye1 = Human.math.vec3ObjToArray(camera.eye);
        this._up1 = Human.math.vec3ObjToArray(camera.up);

        Human.math.subVec3(this._eye1, this._look1, tempVec);

        // this._vec : dir from look1 to eye1
        this._vec = Human.math.normalizeVec3(tempVec);
        // Back-off factor in range of [0..1], when 0 is close, 1 is far
        var backOff = cfg.backOff || 0;
        if (backOff < 0) {
            backOff = 0;
        } else if (backOff > 1) {
            backOff = 1;
        }
        backOff = 1 - backOff;
        // Final camera state
        if (target.boundary) {
            // Zooming to look and eye computed from boundary
            var boundary = target.boundary;
            var dist = target.dist || 2.5;
            // ?? : this._vec is normalized, this might be changed to lenVec = 1
            var lenVec = Math.abs(Human.math.lenVec3(this._vec));
            var diag = Human.math.getBoundaryDiag(boundary);
            var len = Math.abs((diag / (1.0 + (backOff * 0.8))) / Math.tan(stopFOV / 2));  /// Tweak this to set final camera distance on arrival
            var sca = (len / lenVec) * dist;
            this._look2 = Human.math.getBoundaryCenter(boundary);
            if (target.offset) {
                this._look2[0] += target.offset[0];
                this._look2[1] += target.offset[1];
                this._look2[2] += target.offset[2];
            }
            
            // calculate this._eye2
            var cylindricalOnly = Human.view.camera.fly.cylindricalOnly;
            
            if (cylindricalView) {
                this.arc = 1;
                Human.math.cartesianToCylindrical(this._look1, eye1Cylinder);   //use eye1Cylinder as a tempVec for cylindrical coordinate of look1
                Human.math.cartesianToCylindrical(this._look2, eye2Cylinder);   //use eye2Cylinder as a tempVec for cylindrical coordinate of look2
                var rotation = Human.math.getShortRotation(eye1Cylinder[1], eye2Cylinder[1]);
                var radius = eye2Cylinder[0];
                var t = getCylindricalAndTranslationBlendFactor(Math.abs(rotation), radius);
                
                if(!cylindricalOnly) {
                    eye2Cylinder[0] = sca;  //look2 -> eye2
                    eye2Cylinder[2] = 0;
                    this._eye2 = Human.math.cylindricalToCartesian(eye2Cylinder);  // this._eye2 used as tempVec here
                    
                    //blend with original look dir
                    Human.math.mulVec3Scalar(this._vec, sca, tempVec);
                    Human.math.lerpVec3(t, 0, 1, tempVec, this._eye2, tempVec);
                    Human.math.normalizeVec3(tempVec, tempVec);
                    Human.math.mulVec3Scalar(tempVec, sca, tempVec);
                    Human.math.addVec3(this._look2, tempVec, this._eye2);
                } else {
                    eye2Cylinder[0] = eye2Cylinder[0] + sca;
                    this._eye2 = Human.math.cylindricalToCartesian(eye2Cylinder);
                }
                
            } else {
                Human.math.mulVec3Scalar(this._vec, sca, tempVec);
                this._eye2 = Human.math.addVec3(this._look2, tempVec);
            }
            
            
            this._up2 = Human.math.vec3();
            
            if (this.constrainUp) {
                this._up2[0] = camera.up.x;
                this._up2[1] = camera.up.y;
                this._up2[2] = camera.up.z;
            } else if (target.up) {
                this._up2[0] = target.up.x || 0;
                this._up2[1] = target.up.y || 0;
                this._up2[2] = target.up.z || 0;
            } else {
                this._up2[1] = 1;
            }
            
        } else {
            // Zooming to specific look and eye points
            var look = target.look;
            var eye = target.eye;
            var up = target.up;
            var cameraEye = Human.view.camera.eye;
            var cameraLook = Human.view.camera.look;
            var cameraUp = Human.view.camera.up;
            this._look2 = Human.math.vec3();
            this._eye2 = Human.math.vec3();
            this._up2 = Human.math.vec3();

            if (look) {
                this._look2[0] = look.x || 0;
                this._look2[1] = look.y || 0;
                this._look2[2] = look.z || 0;
            } else {
                this._look2[0] = cameraLook.x;
                this._look2[1] = cameraLook.y;
                this._look2[2] = cameraLook.z;
            }

            if (eye) {
                this._eye2[0] = eye.x || 0;
                this._eye2[1] = eye.y || 0;
                this._eye2[2] = eye.z || 0;
            } else {
                this._eye2[0] = cameraEye.x;
                this._eye2[1] = cameraEye.y;
                this._eye2[2] = cameraEye.z;
            }

            if (up && !this.constrainUp) {
                this._up2[0] = up.x || 0;
                this._up2[1] = up.y || 0;
                this._up2[2] = up.z || 0;
            } else {
                this._up2[0] = cameraUp.x;
                this._up2[1] = cameraUp.y;
                this._up2[2] = cameraUp.z;
            }

        }

        // Distance to travel
        Human.math.subVec3(this._look2, this._look1, tempVec);
        var lookDist = Math.abs(Human.math.lenVec3(tempVec));
        
        Human.math.subVec3(this._eye2, this._eye1, tempVec);
        
        // simple lerp straight line distance
        var eyeDist = Math.abs(Human.math.lenVec3(tempVec));

        // Curve animation setup
        if (this.arc > 0.0) {
            Human.math.cartesianToCylindrical(this._eye1, eye1Cylinder);
            Human.math.cartesianToCylindrical(this._eye2, eye2Cylinder);
            
            // dist = (r1 + r2) * radian
            var shortRotation = Human.math.getShortRotation(eye1Cylinder[1], eye2Cylinder[1]);
            var v = (eye1Cylinder[0] + eye2Cylinder[0]) * Math.abs(shortRotation);
            var h = eye2Cylinder[2] - eye1Cylinder[1];
            var cylinderDist = Math.sqrt( v*v + h*h );
            eyeDist = (1 - this.arc) * eyeDist + this.arc * cylinderDist;
        }

        this._dist = lookDist > eyeDist ? lookDist : eyeDist;
        
        // Duration of travel
        this._duration = Human.view.camera.fly.flyTimeScale * 1000.0 * ((this._dist / ((cfg.velocity || velocity) * 200.0)) + 1); // extra seconds to ensure arrival

        // Completion callback
        this._onComplete = cfg.onComplete;
    };


    /** Update the interpolation to push the next state to the bound {@link Human.view.camera}
     */

    var eyeVec = Human.math.vec3();
    var lookVec = Human.math.vec3();

    Human.view.camera.fly.Animation.prototype.update = function (time) {
        if (this._time1 === undefined) {
            this._time1 = time;
            this._time2 = this._time1 + this._duration;
        }

        if (this._done || time > this._time2) {
            if (!this._done) {
                Human.view.camera.setLookAt({
                    look: Human.math.vec3ArrayToObj(this._look2),
                    eye: Human.math.vec3ArrayToObj(this._eye2),
                    up:  Human.math.vec3ArrayToObj(this._up2)
                });
            }
            this._done = true;
            this._onComplete(this);
            return;
        }
        var t = (time - this._time1) / this._duration;
        var easedTime = this.easing ? Human.math.easeOut(t, 0, 1, 1) : t;
        
        Human.math.lerpVec3(easedTime, 0, 1, this._look1, this._look2, lookVec);
        
        if (this.arc > 0.0) {
            Human.math.lerpVec3Cylindrical(easedTime, 0, 1, eye1Cylinder, eye2Cylinder, tempVec);
            Human.math.cylindricalToCartesian(tempVec, eyeVec);
            
            if (this.arc < 1.0) {
                // simple lerp of eye
                Human.math.lerpVec3(
                    easedTime,
                    0,
                    1,
                    this._eye1,
                    this._eye2,
                    tempVec); // Destination
                
                // blend the curved animation with lerp animation
                Human.math.lerpVec3(this.arc, 0, 1, tempVec, eyeVec, eyeVec);
            }
            
        } else {
            // simple lerp of eye
            Human.math.lerpVec3(
                easedTime,
                0,
                1,
                this._eye1,
                this._eye2,
                eyeVec); // Destination
        }

        if (this.constrainUp) {

            // Interpolating "eye" and "look" but not "up"

            Human.view.camera.setLookAt({
                look: Human.math.vec3ArrayToObj(lookVec),
                eye: Human.math.vec3ArrayToObj(eyeVec)
            });

        } else {

            // Interpolating "eye", "look" and "up"

            var up = Human.math.lerpVec3(easedTime, 0, 1, this._up1, this._up2, []);

            Human.view.camera.setLookAt({
                look: Human.math.vec3ArrayToObj(lookVec),
                eye: Human.math.vec3ArrayToObj(eyeVec),
                up:  Human.math.vec3ArrayToObj(up)
            });
        }
    };

    Human.view.camera.fly.Animation.prototype.stop = function () {
    };
})();;/**
 * @class Interpolates a {@link Human.view.camera} along an array of bezier curves (curve path)
 * @private
 *
 */
(function () {
    "use strict";

    var velocity = 1.0;
    //var stopFOV;

    var up1 = Human.math.vec3();

    Human.properties.subscribe({
        propId: "camera.flyCurvePath",
        value: {
            velocity: 1.0,
        },
        callback: function (value) {
            velocity = value.velocity || 1.0;
        }
    });

    /**
     * @private
     */
    Human.view.camera.fly.CurvePathAnimation = function (cfg) {

        this.easing = cfg.easing === undefined ? true : cfg.easing;

        // When true, we'll not change the camera's "up" vector
        this.constrainUp = cfg.constrainUp === undefined ? false : cfg.constrainUp;

        this._eyeCurvePath = cfg.eyeCurvePath;
        this._lookCurvePath = cfg.lookCurvePath;
        this._upVecs = cfg.upVecs;

        var camera = Human.view.camera;

        var t = 1;
        var p = this._lookCurvePath.getParameter(t);
        var i = p.i;
        this._look2 = Human.math.vec3ObjToArray(this._lookCurvePath.getPosition(t).position);
        this._eye2 = Human.math.vec3ObjToArray(this._eyeCurvePath.getPosition(t).position);
        this._up2 = this.constrainUp ? Human.math.vec3ObjToArray(camera.up) : this._upVecs[i+1];

        // Distance to travel
        var eyeLength = this._eyeCurvePath.getPathLength();
        var lookLength = this._lookCurvePath.getPathLength();

        this._dist = Math.max(eyeLength, lookLength);

        // Duration of travel
        this._duration = Human.view.camera.fly.flyTimeScale * 1000.0 * ((this._dist / ((cfg.velocity || velocity) * 200.0)) + 1); // extra seconds to ensure arrival

        // Completion callback
        this._onComplete = cfg.onComplete;
    };


    /** Update the interpolation to push the next state to the bound {@link Human.view.camera}
     */

    Human.view.camera.fly.CurvePathAnimation.prototype.update = function (time) {
        if (this._time1 === undefined) {
            this._time1 = time;
            this._time2 = this._time1 + this._duration;
        }

        if (this._done || time > this._time2) {
            if (!this._done) {
                Human.view.camera.setLookAt({
                    look: Human.math.vec3ArrayToObj(this._look2),
                    eye: Human.math.vec3ArrayToObj(this._eye2),
                    up:  Human.math.vec3ArrayToObj(this._up2)
                });
            }
            this._done = true;
            this._onComplete(this);
            return;
        }
        var t = (time - this._time1) / this._duration;
        var easedTime = this.easing ? Human.math.easeOut(t, 0, 1, 1) : t;

        var look = this._lookCurvePath.getPosition(easedTime).position;
        var eye = this._eyeCurvePath.getPosition(easedTime).position;

        if (this.constrainUp) {

            // Interpolating "eye" and "look" but not "up"
            Human.view.camera.setLookAt({
                look: look,
                eye: eye
            });

        } else {

            // Interpolating "eye", "look" and "up"
            var p = this._lookCurvePath.getParameter(easedTime);
            Human.math.lerpVec3(p.t01, 0, 1, this._upVecs[p.i], this._upVecs[p.i+1], up1);

            Human.view.camera.setLookAt({
                look: look,
                eye: eye,
                up:  Human.math.vec3ArrayToObj(up1)
            });


        }
    };

})();
;/**
 * A camera constraint that blocks any updates to the camera that would cause
 * the objects in the 3D scene from being shifted off the canvas.
 *
 * Active while the "camera.constrainSceneToCanvas" property is set "true".
 *
 * Installed into Human.view.camera, this constraint works by tracking the
 * current center of the scene (updated whenever a module is activated or deactivated),
 * then the camera can poll it on every incoming camera update to see if the update
 * would cause that center to fall of the canvas. If so, returns false, which
 * indicates to the camera that it should ignore the update.
 */
(function () {
    "use strict";

    var viewMat = Human.math.mat4();
    var viewCenter = Human.math.vec4();
    var projCenter = Human.math.vec4();

    // Holds the center point, but potentially could hold a group of points.
    // Just the center for now and we'll see how well that works.
    var points = [
        [0, 0, 0]
    ];

    var canvas;

    Human.events.on("loaded",
        function () {
            canvas = document.getElementById(Human.CANVAS_ID);
        });

    // Property activates or deactivates this constraint
    Human.properties.subscribe({
        propId: "camera.constrainSceneToCanvas",
        value: false,
        callback: function (value) {
            if (value) {
                activate();
            } else {
                deactivate();
            }
        }
    });

    // Activates this constraint
    function activate() {

        // Track scene center point on change
        Human.events.on("modules.activated", saveCenter);
        Human.events.on("modules.deactivated", saveCenter);

        // Install the constraint callback into camera
        Human.view.camera.addConstraint(constrain);
    }

    // Saves center point
    function saveCenter() {
        var b = Human.scene.getBoundary();
        points[0] = [
                b.xmin + ((b.xmax - b.xmin) / 2),
                b.ymin + ((b.ymax - b.ymin) / 2),
                b.zmin + ((b.zmax - b.zmin) / 2)
        ];
    }

    // Runs the constraint
    function constrain(eye, look, up) {

        // Build view matrix
        Human.math.lookAtMat4c(eye.x, eye.y, eye.z, look.x, look.y, look.z, up.x, up.y, up.z, viewMat);

        // Assume projection matrix not changed
        var projMat = Human.renderer.getProjMat();

        // Test points against canvas, return true as soon as one is found inside

        for (var i = 0, len = points.length; i < len; i++) {

            // Transform point to View space
            Human.math.transformPoint3(viewMat, points[i], viewCenter);
            viewCenter[3] = 1; // Need homogeneous 'w' for perspective division

            if (viewCenter[2] > -0.1 || viewCenter[2] < -10000) {
                //      return false;
            }

            // Transform point to Projection space
            Human.math.transformPoint4(projMat, viewCenter, projCenter);

            var x = projCenter[0];
            var y = projCenter[1];
            var w = projCenter[3];

            var canvasX = (1 + x / w) * canvas.width / 2;
            if (canvasX < 0 || canvasX > canvas.width) {

                // Point outside of canvas X extents
                continue;
            }

            var canvasY = (1 - y / w) * canvas.height / 2;
            if (canvasY <  0 || canvasY > canvas.height) {

                // Point outside of canvas Y extents
                continue;
            }

            // Point inside canvas, constraint passes
            return true;
        }

        // No points in canvas, constraint fails
        return false;
    }

    // Deactivates this constraint
    function deactivate () {

        // Remove constraint callback from camera
        Human.view.camera.removeConstraint(constrain);

        // Unsubscribe from module updates
        Human.events.off("modules.activated", saveCenter);
        Human.events.off("modules.deactivated", saveCenter);

    }

})();
;/**
 * A camera constraint that blocks any updates to the camera that would cause
 * the objects in the 3D scene from being shifted off the canvas.
 *
 * Active while the "camera.constrainBoundaryToCanvas" property is set "true".
 *
 * Installed into Human.view.camera, this constraint works by tracking the
 * current AABB of the scene, then the camera can poll it on every incoming
 * camera update to see if the update would cause that boundary to fall outside
 * the canvas. If so, returns false, which indicates to the camera that it should
 * ignore the update.
 */
(function () {
    "use strict";

    var math = Human.math;

    var boundaryScale = 1;
    var showBoundary = false;

    var eye = math.vec3();
    var look = math.vec3();
    var up = math.vec3();
    var right = math.vec3();
    var d = math.vec3();
    var temp = math.vec3();

    var nc  = math.vec3();
    var fc  = math.vec3();

    var fov, aspect;
    var near, far;

    // Scene boundary
    var xmin = 0;
    var ymin = 0;
    var zmin = 0;
    var xmax = 0;
    var ymax = 0;
    var zmax = 0;

    // Frustum
    var leftPlane   = math.createPlane();
    var rightPlane  = math.createPlane();
    var topPlane    = math.createPlane();
    var bottomPlane = math.createPlane();

    // Property activates or deactivates this constraint
    Human.properties.subscribe({
        propId: "camera.constrainBoundaryToCanvas",
        value: false,
        callback: function (value) {
            if (value) {
                activate();
            } else {
                deactivate();
            }
        }
    });

    // Amount by which to scale the boundary using for testing
    Human.properties.subscribe({
        propId: "camera.constrainBoundaryToCanvas.boundaryScale",
        value: boundaryScale,
        callback: function (value) {
            if (typeof value === "number") {
                boundaryScale = value;
            }
        }
    });

    // Whether or not to show the testing boundary
    Human.properties.subscribe({
        propId: "camera.constrainBoundaryToCanvas.showBoundary",
        value: showBoundary,
        callback: function (value) {
            showBoundary = value;
            if (showBoundary) {
                getBoundary();
            }else if (Human.view.boundary) {
                Human.view.boundary.setBoundary({}, false);
            }
        }
    });

    function extractFrustumPlanes(e, l, u) {
        eye[0] = e.x;
        eye[1] = e.y;
        eye[2] = e.z;
        look[0] = l.x;
        look[1] = l.y;
        look[2] = l.z;
        up[0] = u.x;
        up[1] = u.y;
        up[2] = u.z;
        var camera = Human.view.camera._cameraNode._core.optics;
        near = camera.near;
        far = camera.far;
        fov = camera.fovy * Math.PI / 180;
        aspect = camera.aspect;

        var nearHalfHeight = Math.tan(fov * 0.5) * near;
        var nearHalfWidth = nearHalfHeight * aspect;

        math.normalizeVec3(up, up);

        math.subVec3(look, eye, d);
        math.normalizeVec3(d, d);

        math.cross3Vec3(d, up, right);
        math.normalizeVec3(right, right);

        math.mulVec3Scalar(d, near, temp);
        math.addVec3(eye, temp, nc);

        math.mulVec3Scalar(d, far, temp);
        math.addVec3(eye, temp, fc);

        math.mulVec3Scalar(right, nearHalfWidth, temp);
        math.addVec3(nc, temp, temp);
        math.subVec3(temp, eye, temp);
        math.normalizeVec3(temp, temp);
        math.cross3Vec3(up, temp, temp);
        rightPlane.update(eye, temp);

        math.mulVec3Scalar(right, -nearHalfWidth, temp);
        math.addVec3(nc, temp, temp);
        math.subVec3(temp, eye, temp);
        math.normalizeVec3(temp, temp);
        math.cross3Vec3(temp, up, temp);
        leftPlane.update(eye, temp);

        math.mulVec3Scalar(up, nearHalfHeight, temp);
        math.addVec3(nc, temp, temp);
        math.subVec3(temp, eye, temp);
        math.normalizeVec3(temp, temp);
        math.cross3Vec3(temp, right, temp);
        topPlane.update(eye, temp);

        math.mulVec3Scalar(up, -nearHalfHeight, temp);
        math.addVec3(nc, temp, temp);
        math.subVec3(temp, eye, temp);
        math.normalizeVec3(temp, temp);
        math.cross3Vec3(right, temp, temp);
        bottomPlane.update(eye, temp);
    }

    // Activates this constraint
    function activate() {
        // Install the constraint callback into camera
        Human.view.camera.removeConstraint(constrain); // In case it's already set
        Human.view.camera.addConstraint(constrain);
    }

    function getBoundary() {
        var b = Human.scene.getBoundary();
        var s = (1 - boundaryScale) * 0.5;
        var dx = (b.xmax - b.xmin) * s;
        var dy = (b.ymax - b.ymin) * s;
        var dz = (b.zmax - b.zmin) * s;

        xmin = b.xmin + dx;
        ymin = b.ymin + dy;
        zmin = b.zmin + dz;
        xmax = b.xmax - dx;
        ymax = b.ymax - dy;
        zmax = b.zmax - dz;

        if (showBoundary) {
            Human.view.boundary.setBoundary({
                xmin: xmin,
                ymin: ymin,
                zmin: zmin,
                xmax: xmax,
                ymax: ymax,
                zmax: zmax
            }, true);
        }
    }

    // Runs the constraint
    function constrain(eye, look, up) {
        getBoundary();
        extractFrustumPlanes(eye, look, up);

        if (!topPlane.boundaryInside(xmin, xmax, ymin, ymax, zmin, zmax)) {
            return false;
        }

        if (!bottomPlane.boundaryInside(xmin, xmax, ymin, ymax, zmin, zmax)) {
            return false;
        }

        if (!leftPlane.boundaryInside(xmin, xmax, ymin, ymax, zmin, zmax)) {
            return false;
        }

        if (!rightPlane.boundaryInside(xmin, xmax, ymin, ymax, zmin, zmax)) {
            return false;
        }
       return true;
    }

    // Deactivates this constraint
    function deactivate () {

        // Remove constraint callback from camera
        Human.view.camera.removeConstraint(constrain);

    }

})();
;/**
 * @namespace Manages a box-shaped boundary indicator in the 3d view
 */
(function () {
    "use strict";

    var HumanViewBoundary = Human.view.boundary = {};

    var flagsNode;
    var geoNode;
    var ready = false;
    var showing = false;

    Human.events.on(
        "loaded",
        function () {
            flagsNode = Human.renderer.getNode("object-boundary-flags");
            geoNode = Human.renderer.getNode("object-boundary-geo");
            ready = true;
        });

    /**
     * Updates the boundary indicator
     *
     *
     * <pre>
     *     Examples:
     *
     * var boundary = { xmin: -10, ymin: -2, zmin: -123, xmax: 20, ymax: 100, zmax: 23 };
     *
     * setBoundary(boundary)          // Set up new boundary, dont change visibility status
     *
     * boundary = { xmin: -40, ymin: -100, zmin: -33, xmax: 20, ymax: 200, zmax: 450 };
     *
     * setBoundary(boundary, true)    // Set up new boundary, make visible
     *
     * setBoundary(false)             // Keep boundary setup, make invisible
     * setBoundary(true)              // Keep boundary setup, make visible
     * </pre>
     * @memberof Human.view.boundary
     */
    HumanViewBoundary.setBoundary = function () {
        if (!ready) {
            return;
        }
        if (arguments.length === 0) {
            HumanViewBoundary.reset();
            return;
        }
        var boundary;
        var enable;
        if (arguments.length === 1) {
            if (typeof arguments[0] === "boolean") {
                enable = !!arguments[0];
                HumanViewBoundary._showBoundary(enable);
            } else {
                boundary = arguments[0];
                HumanViewBoundary._setBoundaryExtents(boundary);
            }
        } else {
            boundary = arguments[0];
            enable = arguments[1];
            HumanViewBoundary._setBoundaryExtents(boundary);
            HumanViewBoundary._showBoundary(enable);
        }
    };
    HumanViewBoundary._setBoundaryExtents = function (boundary) {
        flagsNode.setEnabled(showing);
        var xmin = boundary.xmin;
        var ymin = boundary.ymin;
        var zmin = boundary.zmin;
        var xmax = boundary.xmax;
        var ymax = boundary.ymax;
        var zmax = boundary.zmax;
        geoNode.setPositions({
            positions:[
                xmax, ymax, zmax, xmax, ymin, zmax, xmin, ymin, zmax, xmin, ymax, zmax,
                xmax, ymax, zmin, xmax, ymin, zmin, xmin, ymin, zmin, xmin, ymax, zmin
            ]
        });
    };

    HumanViewBoundary._showBoundary = function (doShow) {
        if (showing === doShow) {
            return;
        }
        flagsNode.setEnabled(doShow);
        showing = doShow;
    };

    /** Clears the boundary indicator. Makes it invisible and zero size.
     * @memberof Human.view.boundary
     */
    HumanViewBoundary.reset = function () {
        HumanViewBoundary._setBoundaryExtents({ xmin:0, ymin:0, zmin:0, xmax:0, ymax:0, zmax:0 });
        HumanViewBoundary._showBoundary(false);
    };
})();
;/** @namespace Manages the Tooltips view mode
 */
(function () {
    "use strict";

    var tooltips = Human.view.tooltips = {};

    var enabled = true;
    var tooltipId = null;
    var labelElement;               // Single tooltip element

    var enabledAnatomyLabels = {};  // Currently visible labels from Human.view.labels - don't tooltip

    // Whether or not tooltips are enabled by default
    Human.properties.subscribe({
        propId: "tooltips.enabled",
        value: true,
        callback: function (value) {
            enabled = !!value;
        }
    });

    Human.events.on("loaded",
        function () {
            var containerSelector = "#" + Human.CONTAINER_ID;
            $(containerSelector).append("<div id=\"objectToolTip\" style=\"display: none;\" class=\"objectTooltip\">XXXX</div>");
            labelElement = $("#objectToolTip");
            tooltips._hide();
        });

    // Destroy tooltip when object destroyed
    Human.events.on("scene.objectDestroyed", // Destroy label when object destroyed
        function (params) {
            if (labelElement && tooltipId) {
                if (params.objectId === tooltipId) {
                    tooltips._hide();
                }
            }
        });

    // Destroy tooltip when object disabled
    Human.events.on("scene.objectsShown",
        function (params) {
            if (labelElement && tooltipId) {
                if (params.enabledObjectsUpdate[tooltipId] === false) {      // Newly enabled/disabled objects
                    tooltips._hide();
                }
            }
        });

    // Track the currently labelled anatomy objects so we don't tooltip them
    Human.events.on("labels.updated", // Don't tooltip over labelled object
        function (params) {
            enabledAnatomyLabels = params.enabledLabels;
            if (tooltipId && enabledAnatomyLabels[tooltipId]) {
                //tooltips._hide();
            }
        });

    Human.events.on("camera.updated", function () {
        if (labelElement && tooltipId) {
            tooltips._hide();
        }
    });

    tooltips.setTooltip = function (params) {
        var objectId = params.objectId;
        if (objectId) {  // Only tooltip anatomy objects
            if (labelElement) {
                if (tooltipId) {
                    tooltips._hide();
                }
                tooltips._show(params);
            }
        }
    };

    tooltips.clearTooltip = function () {
        if (labelElement && tooltipId) {
            tooltips._hide();
        }
    };

    /**
     * Show tooltip on object at given canvas coordinates
     */
    tooltips._show = function (params) {
        if (!enabled) {
            return;
        }
        var title;
        if (params.objectId) {
            tooltipId = params.objectId;
            if (enabledAnatomyLabels[tooltipId]) {
                tooltips._hide();
                return;
            }
            var object = Human.scene.objects[params.objectId];
            title = object.name;
        }
        title = params.title || title;
        labelElement.css({
            "left": params.canvasX + 10,
            "top": params.canvasY + 0
        });
        labelElement.text(title);
        labelElement.show();
    };

    /**
     * Hide tooltip if shown
     */
    tooltips._hide = function () {
        if (!tooltipId || !labelElement) {
            return;
        }
        labelElement.hide();
        tooltipId = null;
    };

    tooltips.getEnabled = function () {
        return enabled;
    };

    tooltips.setEnabled = function (enable) {
        if (enabled !== enable) {
            if (!enable) {
                tooltips._hide();
            }
            enabled = enable;
        }
        Human.events.fire("tooltips.toggled", {
            enabled: enabled
        });
    };
})();






;/**
 * @namespace Manages labels on objects in {@link Human.scene}
 *
 * <p>Observes updates to the currently selected anatomy object set and maintains
 * a set of labels for the currently selected objects.</p>
 *
 */
(function () {
    "use strict";

    var HumanViewLabels = Human.view.labels = {};

    HumanViewLabels.enabled = true;

    var labels = {};
    var numLabels = 0;

    Human.properties.subscribe({
        propId: "labels.enabled",
        value: true,
        callback: function (value) {
            HumanViewLabels.enabled = !!value;
        }
    });

    Human.events.on(
        "loaded",
        function () {
            HumanViewLabels.clearLabels();
        });

    // When a labeled scene object is destroyed, ensure that the label is also destroyed
    Human.events.on(
        "scene.objectDestroyed",
        function (params) {
            if (HumanViewLabels.enabled) {
                if (numLabels > 0) {
                    var objectId = params.objectId;
                    if (labels[objectId]) {
                        HumanViewLabels._destroyLabel(objectId);
                        var enabledLabelsUpdate = {};
                        enabledLabelsUpdate[objectId] = false;
                        Human.events.fire("labels.updated", {
                            enabledLabels:labels
                        });
                    }
                }
            }
        });

    // When a labeled scene object is deselected, ensure that the label is destroyed
    Human.events.on(
        "scene.objectsSelected",
        function (params) {
            if (HumanViewLabels.enabled) {
                if (numLabels > 0) {
                    var objects = params.selectedObjectsUpdate; // Newly selected/deselected objects
                    var anatomyObjects = Human.scene.objects;
                    for (var objectId in objects) {
                        if (objects.hasOwnProperty(objectId)) {
                            if (anatomyObjects[objectId].objects.length === 0) {  // Leaf object
                                if (objects[objectId] === false) {   // Object deselected, destroy label
                                    if (labels[objectId]) {
                                        HumanViewLabels._destroyLabel(objectId);
                                    }
                                }
                            }
                        }
                    }
                    Human.events.fire("labels.updated", {
                        enabledLabels:labels
                    });
                }
            }
        });

    // When a labeled scene object is hidden, ensure that the label is destroyed
    Human.events.on(
        "scene.objectsShown",
        function (params) {
            if (HumanViewLabels.enabled) {
                if (numLabels > 0) {
                    var objects = params.enabledObjectsUpdate;  // Newly enabled/disabled objects
                    for (var objectId in objects) {
                        if (objects.hasOwnProperty(objectId)) {
                            if (objects[objectId] === false) { // Object disabled, destroy label
                                if (labels[objectId]) {
                                    HumanViewLabels._destroyLabel(objectId);
                                }
                            }
                        }
                    }
                    Human.events.fire("labels.updated", {
                        enabledLabels:labels
                    });

                }
            }
        });

    HumanViewLabels._destroyLabel = function (objectId) {
        var label = labels[objectId];
        if (label) {
            label.destroy();
            delete labels[objectId];
            numLabels--;
        }
    };

    /**
     * Creates a label on an object in {@link Human.scene}
     * @memberof Human.view.labels
     * @param params
     */
    HumanViewLabels.createLabel = function (params) {
        var objectId = params.objectId;
        var object = Human.scene.objects[objectId];
        if (!object) { // Not likely
            Human.log.warn("Human.view.labels.createLabel", "Scene object not found: '" + objectId + "'");
            return;
        }
        if (params.replace) {
            HumanViewLabels.clearLabels();
        }
        if (!object.displayName) {
            Human.log.warn("Human.view.labels.createLabel", "Scene object has no displayName: '" + objectId + "'");
            return;
        }
        var offset = params.offset || object.getCenter();
        labels[objectId] = new Human.view.labels.Label({
            labelId:objectId,
            text:object.displayName,
            style:null, // Default style
            offset:offset,
            nodeId:objectId,
            objectId:objectId,
            enabled:HumanViewLabels.enabled,
            onHide:function () {
                HumanViewLabels._destroyLabel(objectId);
            }
        });
        Human.events.fire("labels.updated", {
            enabledLabels:labels
        });
        numLabels++;
    };

    /**
     * Clears all labels currently in {@link Human.scene}
     * @memberof Human.view.labels
     */
    HumanViewLabels.clearLabels = function () {
        if (numLabels > 0) {
            HumanViewLabels._clearLabels();
            Human.events.fire("labels.updated", {
                enabledLabels:labels
            });
        }
    };

    HumanViewLabels._clearLabels = function () {
        for (var labelId in labels) {
            if (labels.hasOwnProperty(labelId)) {
                HumanViewLabels._destroyLabel(labelId);
            }
        }
        numLabels = 0;
    };

    /** Enables or disables Label mode
     * <p>Disabling will remove all labels.</p>
     * @memberof Human.view.labels
     * @param {Boolean} enable Enables or disables Label mode
     */
    HumanViewLabels.setEnabled = function (enable) {
        if (HumanViewLabels.enabled === enable) {
            return;
        }
        HumanViewLabels.enabled = enable;
        if (!enable) {
            // Destroy all labels when disabled
            HumanViewLabels._clearLabels();
        }
        Human.events.fire("labels.toggled", {
            enabled:enable
        });
    };

    /** Queries whether or not Label mode is enabled
     * @memberof Human.view.labels
     * @returns true if Label mode enabled else false
     */
    HumanViewLabels.getEnabled = function () {
        return HumanViewLabels.enabled;
    };

})();







;(function () {
    "use strict";

    var container;
    var audio;
    var labels = {};
    var canvasWidth;
    var canvasHeight;

    Human.events.on("loaded",
        function () {
            container = $("#container");
            audio = initAudio();

            var canvas = $(Human.renderer.canvas.getCanvas());
            canvasWidth = canvas.width();
            canvasHeight = canvas.height();
        });

    function initAudio() {
        var id = "___labelNarration";
        var body = document.getElementsByTagName("body")[0];
        var div = document.createElement('div');
        div.innerHTML += ' <audio id="' + id + '" src=""></audio>';
        body.appendChild(div);
        var audio = document.getElementById(id);
        if (!audio) {
            Human.log.error("Scene.view.labels",  "Label audio init failed: Failed to create audio element in DOM");
            return null;
        }
        if (audio.canPlayType('audio/ogg;codecs="vorbis"') !== "probably") {
            Human.log.error("Scene.view.labels",  "Label audio init failed: Codec not supported");
            return null;
        }
        return audio;
    }

    Human.events.on("loaded",
        function () {
            Human.renderer.getNode(Human.renderer.NULL_OBJECT_ID).on("rendered",
                function (event) {
                    for (var labelId in labels) {
                        if (labels.hasOwnProperty(labelId)) {
                            labels[labelId]._onRender(event);
                        }
                    }
                });
        });

    Human.events.on("canvas.resized",
        function (params) {
            canvasWidth = params.canvasWidth;
            canvasHeight = params.canvasHeight;
        });

    /**
     * A label within {@link Human.view.labels}.
     * @param cfg
     * @constructor
     * @private
     */
    Human.view.labels.Label = function (cfg) {

        this.nodeId = cfg.nodeId;               // Always have nodeId
        this.objectId = cfg.objectId;
        this.animationId = cfg.animationId;
        this.offset = cfg.offset;               // Optional
        this.shown = cfg.shown;
        this.enabled = cfg.enabled;
        this.audioText = cfg.text;

        if (this.audioText) {
            this.audioText = this.audioText.toLowerCase().replace(/\s/g, '_');
        }

        this._style = cfg.style || "labelStyleDefault";

        if (cfg.labelId) {
            this.labelId = cfg.labelId;
        } else if (this.animationId) {  // Animation label
            this.labelId = "a." + this.objectId;
        } else if (this.objectId) { // Object label
            this.labelId = "o." + this.objectId;
        } else {
            this.labelId = "n." + this.nodeId;
        }

        /* add class (right, left, bottom or top) according to where the label arrow should appear
          relative to the elemtn */
        this._labelElement = jQuery([
            '<div id="',
            this.labelId,
            '" class="label-container right hidden">',
            '<div class="label-container-header ',
            this.style,
            '">',
            '<span>',
            cfg.text,
            '</span>',
            '<img src="img/shim.gif" alt="Play" class="icon-speaker icon-inverse" />',
            '<img src="img/shim.gif" alt="Close" class="icon-close icon-inverse" />',
            '<div class="label-toggle-secondary icon-expand"></div>',
            '<ul class="options"></ul>',
            '</div>',
            '</div>'
        ].join(""));

        container.append(this._labelElement);

        this._elementWidth = this._labelElement.width();
        this._elementHeight = this._labelElement.height();

        var self = this;

        this._onRender = function (event) {
            self.updatePos({
                canvasPos:event.getCanvasPos(self.offset),
                viewPos: event.getViewPos(self.offset)
            });
        };

        labels[this.labelId] = this;

        var $closeBtn = this._labelElement.find(".icon-close");
        $closeBtn.click(function () {
            cfg.onHide();
        });

        // build options
        var $labelOptions = this._labelElement.find(".options");
        var $optionsToggle = this._labelElement.find(".label-toggle-secondary");
        $labelOptions.hide();        
        $optionsToggle.hide();
        var annotations = Human.view.annotations.getAnnotations({ objectId: this.objectId, type: "secondary" });
        var hasSecondary = Object.keys(annotations).length > 0;
        // toggle label option
        if (hasSecondary) {
            var annotationsShownCount = 0;
            var setAnnotationToggle = function (shown) {
                if (shown) {
                    $optionShowPins.text("Hide Pins");
                }
                else {
                    $optionShowPins.text("Show Pins");
                }
            };
            var setAnnotationShown = function (shown) {
                if (shown === true) {
                    annotationsShownCount++;
                }
                else if (annotationsShownCount > 0) {
                    annotationsShownCount--;
                }
                setAnnotationToggle(annotationsShownCount !== 0);
            };
            var annotationChecked = false;
            var initAnnotationCheck = function () {
                if (annotationChecked === true) {
                    return;
                }
                annotationsShownCount = 0;
                for (var id in annotations) {
                    if (annotations.hasOwnProperty(id)) {
                        var annotation = annotations[id];
                        annotation.label.on("shown", setAnnotationShown);
                        if (annotation.label.shown === true) {
                            annotationsShownCount++;
                        }
                    }
                }
                setAnnotationToggle(annotationsShownCount !== 0);
            };
            
            var $optionShowPins = $("<li />");            
            $optionShowPins.click(function () {
                var shown = annotationsShownCount !== 0;
                var objects = {};
                objects[self.objectId] = !shown;
                // set annotations
                Human.view.annotations.setLabelsShown({
                    objects: objects,
                    type: "secondary",
                    replace: true
                });
            });
            // lazy loaded check
            $optionsToggle.click(function () {
                if (annotationChecked !== true) {
                    initAnnotationCheck();
                    annotationChecked = true;
                }
            });
            $labelOptions.append($optionShowPins);
        }
        // label options available
        if ($labelOptions.children().length > 0) {
            // remove main close btn
            $closeBtn.hide();
            // add close btn option
            var $hideBtn = $("<li />");
            $hideBtn.text("Hide Label");
            $hideBtn.click(function () {
                cfg.onHide();
            });
            $labelOptions.append($hideBtn);
            // setup options toggle
            $optionsToggle.click(function () {
                if ($labelOptions.is(":visible")) {
                    $labelOptions.hide();
                    $optionsToggle.attr("class", "icon-expand");
                }
                else {
                    $labelOptions.show();
                    $optionsToggle.attr("class", "icon-collapse");
                }
            });
            $optionsToggle.show();
        }
        var speakerButton = this._labelElement.find(".icon-speaker");
        speakerButton.hide();

        if (this.objectId) { // Speaking for objects only
            if (audio) {
                // var src = "content/sounds/labels/" + self.objectId + ".ogg";
                var src = "content/sounds/labels/" + self.audioText + ".ogg";
                Human.utils.fileExists.test(src,
                    function (exists) {
                        if (exists) {
                            speakerButton.click(
                                function () {
                                    audio.setAttribute("src", src);
                                    if (!audio.currentTime) {
                                        audio.play();
                                    } else {
                                        // Workaround Firefox not being able to reliably determine audio.duration
                                        // because media data seems unavailable. This is a better method anyway.
                                        if (audio.ended) {
                                            // Workaround Chrome bug(?).
                                            // Chrome will not repeat playback unless the src is destroyed and reset.
                                            audio.pause();
                                            audio.src = '';
                                            audio.setAttribute("src", src);
                                            audio.play();
                                        }
                                    }
                                });
                            self._hasAudioFile = true;
                            speakerButton.show();
                        }
                    });
            }
        }
    };

    Human.view.labels.Label.prototype.updatePos = function (params) {
        var x = params.canvasPos.x;
        var y = params.canvasPos.y + 40;
        var z = params.viewPos.z;

        if (z > 0) { // Behind point of projection
            if (this.shown) {
                this.setShown(false);
            }
            return;
        } 

        x = Math.max(20, Math.min(x, canvasWidth - this._elementWidth - 10));
        y = Math.max(10, Math.min(y, canvasHeight - this._elementHeight - 10));

        this._labelElement.css({
            "left":x,
            "top":y
        });
        if (!this.shown) {
            this.setShown(true);
        }
    };

    Human.view.labels.Label.prototype.update = function (params) {
        var x = params.canvasPos.x;
        var y = params.canvasPos.y;
        if (y <= 0) {                    // Just clip to top - overlap with menus is only issue, other borders OK
            if (this.shown) {
                this.setShown(false);
            }
        } else {
            this._labelElement.css({
                "left":x,
                "top":y + 40
            });
            if (params.style) {
                if (this._style) {
                    this._labelElement.removeClass(this._style);
                }
                this._labelElement.addClass(params.style);
                this._style = params.style;
            }
            if (!this.shown) {
                this.setShown(true);
            }
        }
    };

    Human.view.labels.Label.prototype.setShown = function (doShow) {
        if (this.shown === doShow) {
            return;
        }
        if (doShow && this.enabled) {
            this._labelElement.show();
        } else {
            this._labelElement.hide();
        }
        this.shown = doShow;
    };

    Human.view.labels.Label.prototype.setEnabled = function (enable) {
        if (this.enabled !== enable) {
            if (this.shown && enable) {
                this._labelElement.show();
            } else {
                this._labelElement.hide();
            }
            this.enabled = enable;
        }
    };

    Human.view.labels.Label.prototype.destroy = function () {
        delete labels[this.labelId];
        if (audio && this._hasAudioFile) {
            audio.pause();
            audio.src = '';
        }
        if (this.shown) {
            this.setShown(false);
        }
        if (this._labelElement) {
            this._labelElement.remove();
            this._labelElement = null;
        }
    };

})();;/**
 * @namespace Manages Highlight mode
 */
(function () {
    "use strict";

    var HumanViewHighlight = Human.view.highlight = {};

    HumanViewHighlight.enabled = true;
    var dirty = false;

    Human.events.on(
        "loaded",
        function () {
            HumanViewHighlight.setEnabled(true); // Notifies of initial state
        });

    Human.events.on(
        "scene.objectsSelected", // Track the set of currently selected objects
        function () {
            if (HumanViewHighlight.enabled) {
                dirty = true;
            }
        });

    Human.events.on(
        "tick", // Lazy-highlight when flagged for next render frame
        function () {
            if (dirty) {
                highlight(HumanViewHighlight.enabled);
                dirty = false;
            }
        });

    function highlight(doHighlight) {
        var object, objectId;
        if (!doHighlight) {
            for (objectId in Human.scene.objects) { // De-highlight an highlighted objects
                if (Human.scene.objects.hasOwnProperty(objectId)) {
                    object = Human.scene.objects[objectId];
                    if (object.highlight) {
                        object.setHighlight(false);
                    }
                }
            }
        } else {
            for (objectId in Human.scene.objects) { // Highlight only selected objects
                if (Human.scene.objects.hasOwnProperty(objectId)) {
                    object = Human.scene.objects[objectId];
                    if (object) {
                        if (Human.scene.selectedObjects.hasOwnProperty(objectId)) {
                            if (!object.highlight) {
                                object.setHighlight(true);
                            }
                        } else {
                            if (object.highlight) {
                                object.setHighlight(false);
                            }
                        }
                    }
                }
            }
        }
    }

    HumanViewHighlight.setEnabled = function (enable) {
        if (HumanViewHighlight.enabled !== enable) {
            HumanViewHighlight.enabled = enable;
            dirty = true;
        }
        Human.events.fire("highlight.toggled", { enabled: HumanViewHighlight.enabled });
        if (HumanViewHighlight.enabled) {
            Human.view.currentMode = 'Highlight';
        }
    };

    HumanViewHighlight.getEnabled = function () {
        return HumanViewHighlight.enabled;
    };

})();
;/**
 * @namespace manages Isolation mode
 */
(function () {
    "use strict";

    var HumanViewIsolate = Human.view.isolate = {}; 

    HumanViewIsolate.enabled = false;
    var dirty = true;

    Human.events.on(
        "loaded",
        function () {
            HumanViewIsolate.enabled = false;
            dirty = false;
        });

    Human.events.on(
        "tick",
        function () {
            if (dirty) {
                // Lazy-isolate when flagged for next render frame
                Human.scene.setShowSelectedObjects(HumanViewIsolate.enabled);
                dirty = false;
            }
        });

    Human.events.on(
        "scene.objectsSelected",
        function () {
            if (HumanViewIsolate.enabled) {
                dirty = true;
            }
        });

    HumanViewIsolate.setEnabled = function (enable) {
        if (HumanViewIsolate.enabled !== enable) {
            HumanViewIsolate.enabled = enable;
            dirty = true;
        }
        Human.events.fire("isolate.toggled", { enabled:HumanViewIsolate.enabled });
        if(HumanViewIsolate.enabled) {
            Human.view.currentMode = 'Isolate';
            // Multi-pick doesn't make sense in Isolate mode
            Human.view.pick.setSinglePickEnabled(true);
            Human.view.pick.setMultiPickEnabled(false);
        }
    };

    HumanViewIsolate.getEnabled = function () {
        return HumanViewIsolate.enabled;
    };

})();;/**
 * @namespace Manages Dissection mode
 *
 * Can undo and redo dissections, forgets history when enable status changes.
 */
(function () {
    "use strict";

    var dissect = Human.view.dissect = {};

    dissect.enabled = false;  // Disable by default
    var undoStack = [];
    var redoStack = [];

    Human.events.on(
        "loaded",
        function () {
            dissect.enabled = false;
        });

    /**
     * Enable/disable dissection and notify
     */
    dissect.setEnabled = function (enable) {
        if (dissect.enabled === enable) {
            return;
        }
        dissect.enabled = enable;
        //redoStack.length = 0;
        //undoStack.length = 0;
        Human.events.fire("dissect.toggled", { enabled:dissect.enabled });
    };

    dissect.getEnabled = function () {
        return dissect.enabled;
    };

    /**
     * Dissect an object
     * Causes the object to be disabled (hidden) within the 3D scene
     * @param objectId
     */
    dissect.dissect = function (objectId) {
        if (!dissect.enabled) {
            return;
        }
        redoStack.length = 0;
        undoStack.push(objectId);
        var objects = {};
        objects[objectId] = false;
        Human.scene.setEnabledObjects({
            objectIds:objects
        });
    };

    /**
     * Undo last dissection
     */
    dissect.undo = function () {
        if (!dissect.enabled) {
            //return;
        }
        if (undoStack.length) {
            var objectId = undoStack.pop();
            var objects = {};
            objects[objectId] = true;
            Human.scene.setEnabledObjects({
                objectIds:objects
            });
            redoStack.unshift(objectId);
        }
    };

    /**
     * Redo last dissection
     */
    dissect.redo = function () {
        if (!dissect.enabled) {
            return;
        }
        var objectId;
        var objects;
        if (redoStack.length) {
            objectId = redoStack.shift();
            objects = {};
            objects[objectId] = false;
            Human.scene.setEnabledObjects({
                objects:objects
            });
            undoStack.push(objectId);
        }
    };

    dissect.reset = function () {
        redoStack.length = 0;
        undoStack.length = 0;
    };
})();
;/**
 * @namespace View mode in which annotations can be pinned to objects in {@link Human.scene}.
 */
(function () {
    "use strict";

    var HumanViewAnnotations = Human.view.annotations = {};

    var ID_PREFIX = "__a";

    /**
     * Pool of internally-managed annotation IDs, for annotations that are created without user-supplied IDs.
     * Such annotations are typically created from picking a scene object, while IDs are supplied on annotations
     * that are loaded with bookmarks, conditions etc.
     *
     * @type {Human.utils.IDPool}
     */
    var idPool = new Human.utils.IDPool({
        prefix: ID_PREFIX
    });

    /**
     * True when annotation mode is enabled
     * @type {boolean}
     */
    HumanViewAnnotations.enabled = false;

    /**
     * True when annotations are visible
     * @type {boolean}
     */
    HumanViewAnnotations.shown = true;

    /**
     * The annotations
     * @type {{String:Human.view.annotations.Annotation}}
     */
    HumanViewAnnotations.annotations = {};

    /**
     * Annotations on each scene object
     * @type {{String:Human.view.annotations.Annotation}}
     */
    HumanViewAnnotations.objectAnnotations = {};

    // Annotation currently being created, not yet saved
    HumanViewAnnotations.unsavedAnnotation = null;

    /**
     * Enable or disables annotation mode, in which annotations may be created
     * @memberof Human.view.annotations
     * @param {boolean} enable True to enable, false to disable
     */
    HumanViewAnnotations.setEnabled = function (enable) {
        if (HumanViewAnnotations.enabled !== enable) {
            HumanViewAnnotations.enabled = enable;
            Human.events.fire("annotations.toggled", { enabled: enable });
        }
    };

    /**
     * Creates an annotation on an {@link Human.scene.Object} in {@link Human.scene}.
     *
     * @memberof Human.view.annotations
     * @param {*} params
     * @param {String} [params.annotationId] ID to assign to the annotation, generated internally if omitted.
     * @param {String} params.objectId ID of an {@link Human.scene.Object} in {@link Human.scene}.
     * @param {String} [params.type] Type of annotation, "default" by default.
     * @param {Boolean} [params.saved] True if we are reloading a previously saved annotation
     * @param {Boolean} [params.shown] True to show the annotation initially - default true
     * @param {String} params.title Title for annotation label
     * @param {String} params.description Text for annotation description in label
     * @param {[Number, Number, Number]} params.pos World-space position of annotation pin
     * @param {[Number, Number, Number]} params.dir 3D vector indicating direction the pin is pointing
     * @param {[Number, Number]} [params.labelOffset] 3D vector indicating offset of label in canvas-space
     * @param {Number} [params.primitiveIndex] Index of triangle in mesh.
     * @param {[Number, Number, Number]} [params.barycentric] Barycentric coordinate within triangle.
     * @returns {Human.view.annotations.Annotation} The new annotation, or null if error occurred, in which case the error is logged
     */
    HumanViewAnnotations.createAnnotation = function (params) {

        var object;

        if (params.objectId) {
            object = Human.scene.objects[params.objectId];
            if (!object) {
                Human.log.warn("Human.view.annotations.createAnnotation", "Scene object not found: '" + params.objectId + "'");
            }
        }

        // If annotation already being created, reuse that one
        if (HumanViewAnnotations.unsavedAnnotation) {
            params.title = HumanViewAnnotations.unsavedAnnotation.label.$titleField.val();
            params.description = HumanViewAnnotations.unsavedAnnotation.label.$descriptionField.val();
            params.objectId = HumanViewAnnotations.unsavedAnnotation.object ? HumanViewAnnotations.unsavedAnnotation.object.objectId : null;

            HumanViewAnnotations.unsavedAnnotation.destroy();
            HumanViewAnnotations.unsavedAnnotation = null;
        }

        if (params.annotationId) {
            if (params.annotationId.toString().slice(0, ID_PREFIX.length) === ID_PREFIX) {  // ID was system created. Don't need to keep.
                params.annotationId = idPool.getId();
            } else if (HumanViewAnnotations.annotations[params.annotationId]) {
                Human.log.error("Human.view.annotations.createAnnotation", "Annotation with this ID already exists: '" + params.annotationId + "'");
                return null;
            }
        } else {
            params.annotationId = idPool.getId();
        }

        var annotation = new Human.view.annotations.Annotation(object, params);

        HumanViewAnnotations.annotations[params.annotationId] = annotation;

        addObjectLookup(annotation);

        HumanViewAnnotations.unsavedAnnotation = params.saved ? null : annotation;

        annotation.setAnnotationsShown(HumanViewAnnotations.shown);

        annotation.on("picked",
            function () {
                Human.events.fire("annotations.picked", {
                    annotationId: annotation.annotationId
                });
            });

        annotation.label.on("mouseClick",
            function () {
                Human.events.fire("annotations.mouseClick", {
                    annotationId: annotation.annotationId
                });
            });

        annotation.label.on("mouseEnter",
            function (params) {
                if (annotation.object) {
                    highlightObject(annotation.object, true);
                }
                Human.events.fire("annotations.mouseEnter", params);
            });

        function highlightObject(object, highlight) {
            object.setHighlight(highlight);
            for (var i = 0, len = object.objects.length; i < len; i++) {
                highlightObject(object.objects[i], highlight);
            }
        }

        annotation.label.on("mouseLeave",
            function (params) {
                if (annotation.object) {
                    highlightObject(annotation.object, false);
                }
                Human.events.fire("annotations.mouseLeave", params);
            });

        annotation.label.on("mouseDown",
            function (params) {
                Human.events.fire("annotations.mouseDown", params);
            });

        annotation.label.on("mouseUp",
            function (params) {
                Human.events.fire("annotations.mouseUp", params);
            });

        annotation.on("saved",
            function () {
                if (HumanViewAnnotations.unsavedAnnotation && HumanViewAnnotations.unsavedAnnotation.annotationId === annotation.annotationId) {
                    notify("annotations.created", annotation);
                } else {
                    notify("annotations.updated", annotation);
                }
                HumanViewAnnotations.unsavedAnnotation = null;
            });

        annotation.on("destroyed",
            function () {

                // De-highlight the annotation's object

                if (annotation.object) {
                    highlightObject(annotation.object, false);
                }

                HumanViewAnnotations.unsavedAnnotation = null;
                delete HumanViewAnnotations.annotations[annotation.annotationId];
                removeObjectLookup(annotation);
                Human.events.fire("annotations.destroyed", {
                    annotationId: annotation.annotationId
                });
            });

        if (params.saved) {
            notify("annotations.created", annotation);
            HumanViewAnnotations.unsavedAnnotation = null;
        } else {
            Human.events.fire("annotations.creating", {
                annotationId: annotation.annotationId
            });
        }

        return annotation;
    };

    function addObjectLookup(annotation) {
        if (annotation.object) {
            var object = annotation.object;
            var objAnnots = HumanViewAnnotations.objectAnnotations[object.objectId];
            if (!objAnnots) {
                objAnnots = HumanViewAnnotations.objectAnnotations[object.objectId] = {
                    annotations: {},
                    numAnnotations: 0
                };
            }
            objAnnots.annotations[annotation.annotationId] = annotation;
            objAnnots.numAnnotations++;
        }
    }

    function removeObjectLookup(annotation) {
        if (annotation.object) {
            var object = annotation.object;
            var objAnnots = HumanViewAnnotations.objectAnnotations[object.objectId];
            if (objAnnots) {
                var a = objAnnots.annotations[annotation.annotationId];
                if (a) {
                    delete objAnnots.annotations[annotation.annotationId];
                    if (--objAnnots.numAnnotations === 0) {
                        delete HumanViewAnnotations.objectAnnotations[object.objectId];
                    }
                }
            }
        }
    }

    function notify(event, annotation) {
        Human.events.fire(event, {
            annotationId: annotation.id || annotation.annotationId,
            type: annotation.type,
            styleId: annotation.styleId,
            objectId: annotation.object ? annotation.object.objectId : null,
            title: annotation.label.title,
            description: annotation.label.description,
            pos: annotation.pin.pos,
            pinVec: annotation.pin.dir
        });
    }

    /**
     * Batch updates dimension properties of all annotation labels
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.updateDimensions = function () {
        for (var annotationId in HumanViewAnnotations.annotations) {
            if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                HumanViewAnnotations.annotations[annotationId].label.updateWidth();
            }
        }
    };

    /**
     * Control display of all annotation labels
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.setShown = function (shown) {
        if (HumanViewAnnotations.shown !== shown) {
            for (var annotationId in HumanViewAnnotations.annotations) {
                if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                    HumanViewAnnotations.annotations[annotationId].setAnnotationsShown(shown);
                }
            }
            HumanViewAnnotations.shown = shown;
            Human.events.fire("annotations.shown", {shown: shown });
        }
    };

    /**
     * Destroys all annotations.
     * @param [options]
     * @param [options.keepModuleAnnotations=false] When true, does not clear annotations that were loaded by modules.
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.clearAnnotations = function (options) {
        options = options || {};
        var keepModuleAnnotations = !!options.keepModuleAnnotations;
        HumanViewAnnotations.unsavedAnnotation = null;
        var annotation;
        for (var annotationId in HumanViewAnnotations.annotations) {
            if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                annotation = HumanViewAnnotations.annotations[annotationId];
                if (!keepModuleAnnotations || !annotation.moduleId) {
                    annotation.destroy();
                }
            }
        }
    };

    /**
     Queries annotations, with optional restrictions

     <p>Examples:</p>

     <pre>

     // Get a list of annotations for the Bones of the Head
     Human.view.annotations.getAnnotations({
        objectId: "maleAdult-Bones_of_the_Head"
     });

     // Get a list of secondary annotations for the Diaphragm
     Human.view.annotations.getAnnotations({
        objectId: "maleAdult-Diaphragm_13295",
        type: "secondary"
     });

     </pre>

     @param params
     @param [params.objectId] Object ID of the object to restrict annotation search
     @param [params.type] The type of annotation to restrict the search
     @returns {*}
     */
    HumanViewAnnotations.getAnnotations = function (params) {
        var _annotations = {};
        var searchAnnotations = HumanViewAnnotations.annotations;
        // restrict by object id
        if (params.objectId) {
            if (HumanViewAnnotations.objectAnnotations.hasOwnProperty(params.objectId)) {
                searchAnnotations = HumanViewAnnotations.objectAnnotations[params.objectId].annotations;
            }
            else {
                searchAnnotations = {};
            }
        }
        var type = params.type;
        for (var annotationId in searchAnnotations) {
            if (searchAnnotations.hasOwnProperty(annotationId)) {
                var annotation = searchAnnotations[annotationId];
                // restrict by type
                if (!type || type === annotation.type) {
                    _annotations[annotationId] = annotation;
                }
            }
        }
        return _annotations;
    };

    /**
     Convenience method which opens or closes labels on annotations,
     either per their IDs and/or the IDs of their scene objects.

     <p>Examples:</p>

     <pre>

     // Close labels on all annotations on the male frontal bone

     Human.view.annotations.setLabelsShown({
        objects: {
            "maleAdult-Frontal_bone_52734": false
        }
     });

     // Open labels on all annotations on the male frontal bone
     // Close labels on all other annotations

     Human.view.annotations.setLabelsShown({
        objects: {
            "maleAdult-Frontal_bone_52734": true
        },
        replace: true
     });

     // Hide one annotation and show another
     // Close labels on all other annotations

     Human.view.annotations.setLabelsShown({
        annotations: {
            "foo": false,
            "bar": true
        },
        replace: true
     });

     </pre>

     @param params
     @param [params.annotations] Map of annotation IDs to flags
     @param [params.objects] Map of object IDs to flags
     @param [params.replace] True to close labels on all other annotations - default false
     @param [params.type] When object IDs given, open/close only the annotations of this type on those objects
     */
    HumanViewAnnotations.setLabelsShown = function (params) {

        // Annotations we'll open labels for
        var updates = {};

        var type = params.type;
        var annotation, flags;
        var annotationId;
        var open;

        if (params.annotations) {

            // Show hide labels of given annotations
            // optionally filter on type

            flags = params.annotations;
            for (annotationId in flags) {
                if (flags.hasOwnProperty(annotationId)) {
                    annotation = HumanViewAnnotations.annotations[annotationId];
                    if (annotation) {
                        if (!type || type === annotation.type) {
                            updates[annotationId] = flags[annotationId];
                        }
                    }
                }
            }

        } else if (params.objects) {

            // Show/hide labels for annotations on target objects
            // optionally filter on type

            flags = params.objects;
            for (var objectId in flags) {
                if (flags.hasOwnProperty(objectId)) {
                    var object = Human.scene.objects[objectId];
                    if (object) {
                        var objectAnnotations = HumanViewAnnotations.objectAnnotations[objectId];
                        if (objectAnnotations) {
                            open = flags[objectId];
                            for (annotationId in objectAnnotations.annotations) {
                                if (objectAnnotations.annotations.hasOwnProperty(annotationId)) {
                                    annotation = objectAnnotations.annotations[annotationId];
                                    if (!type || type === annotation.type) {
                                        updates[annotationId] = open;
                                    }
                                }
                            }
                        }
                    }
                }
            }

        } else if (params.type) {

            // Show/hide labels of annotations of given type

            open = params.shown !== false;
            for (annotationId in HumanViewAnnotations.annotations) {
                if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                    annotation = HumanViewAnnotations.annotations[annotationId];
                    if (annotation) {
                        if (!type || type === annotation.type) {
                            updates[annotationId] = open;
                        }
                    }
                }
            }
        }

        if (params.replace) {

            // Close all other annotations

            for (annotationId in HumanViewAnnotations.annotations) {
                if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                    if (!updates[annotationId]) {
                        annotation = HumanViewAnnotations.annotations[annotationId];

                        // When closing or opening annotations of a given type on an object,
                        // ensure that we don't change the state of other annotations not matching the given type.

                        if (!type || type === annotation.type) {
                            annotation.pin.setShown(false);
                            annotation.label.setShown(false);
                        }
                    }
                }
            }
        }

        // Open the labels for the annotations we specified
        for (annotationId in updates) {
            if (updates.hasOwnProperty(annotationId)) {
                var shown = updates[annotationId];
                annotation = HumanViewAnnotations.annotations[annotationId];
                annotation.pin.setShown(shown);
                annotation.label.setShown(shown);
            }
        }
    };

    /**
     * Batch update of an annotation's state, fires an "annotations.updated".
     * This is intended for use by the API via RPC.
     * @param annotationId
     * @param params
     */
    HumanViewAnnotations.updateAnnotation = function (annotationId, params) {
        var annotation = HumanViewAnnotations.annotations[annotationId];
        if (annotation) {
            var label = annotation.label;
            if (params.title && params.title !== label.title) {
                label.setTitle(params.title);
            }
            if (params.description && params.description !== label.description) {
                label.setDescription(params.description);
            }
            // TODO: Other state updates as we need them for the API...
            notify("annotations.updated", annotation);
        }
    };

})();







;(function() {
    "use strict";

    /**
     * @class An annotation within {@link Human.view.annotations}
     * @param [object]
     * @param cfg
     * @constructor
     */
    Human.view.annotations.Annotation = function (object, cfg) {

        var self = this;

        // Call parent class Human.Component init
        this._init();

        /** Module that loaded this annotation, if loaded by a module
         * @type {string}
         */
        this.moduleId = cfg.moduleId;

        /** Type of this annotation.
         *
         * @type {string}
         */
        this.type = cfg.type || "default";

        /** ID of this annotation, unique within {@link Human.view.annotations}
         * @type {String}
         */
        this.annotationId = cfg.annotationId;

        /**
         * Whether or not annotations are globally enabled
         * @type {boolean}
         */
        this.annotationsShown = Human.view.annotations.shown;

        /**
         * True when this annotation was configured with a 'labelOffset'.
         */
        this.draggable = !!cfg.labelOffset;

        /**
         * True when this annotation is hidden when its pin is occluded by another object.
         * @type {boolean}
         */
        this.occludable = cfg.occludable !== false && !!cfg.pos;

        /**
         * True when this annotation should animate with the object it's attached to.
         * @type {boolean}
         */
        this.followsObject = cfg.followsObject !== false && !!object;

        /* DOM order should be Label, Wire, Pin for CSS */

        /** The label for this annotation
         * @type {Human.view.annotations.Label}
         */
        
        cfg.offset = cfg.labelOffset; // Label needs 'offset'

        this.label = new Human.view.annotations.Label(this, cfg);

        /** The wire for this annotation
         */
        this.wire = $('<div class="annotationWire"></div>').appendTo('#container');

        /** The pin for this annotation
         * @type {Human.view.annotations.Pin}
         */
        this.pin = new Human.view.annotations.Pin(this, cfg.annotationId, cfg);

        /** True when this annotation is saved
         * @type {boolean}
         */
        this.saved = (cfg.saved !== undefined && cfg.saved !== null) ? cfg.saved : false;

        // Toggle label visibility when pin picked
        this.pin.on("picked",
            function () {
                if (!self.label.saved) {
                    alert("Please save or cancel annotation before hiding label");
                    return;
                }
                self.label.setShown(!self.label.shown);
                self.publish("picked", true, true);
            });

        // Toggle label visibility when pin picked
        this.label.on("saved",
            function () {
                self.publish("saved", self.saved = true);
            });

        // Toggle label visibility when pin picked
        this.label.on("delete",
            function () {
                self.destroy();
            });

        var _showWire = function (show) {
            if (show) {
                self.wire.show();
            } else {
                self.wire.hide();
            }
        };

        // These events influence whether to show or hide the wire

        // These events influence whether to show or hide the wire
        this.pin.on("enabled", function (enabled) {
            _showWire(
                self.annotationsShown &&
                enabled &&
                !self.label.culled &&
                self.label.shown &&
                self.pin.shown);
        });

        this.label.on("shown", function (shown) {
            _showWire(
                self.annotationsShown && // All annotations visible
                self.pin.enabled &&  // ie. Object visible
                !self.label.culled && // Pin inside view
                shown &&
                self.pin.shown); // Pin shown
        });

        this.label.on("culled", function (culled) {
            _showWire(
                self.annotationsShown &&
                self.pin.enabled &&
                !culled &&
                self.label.shown &&
                self.pin.shown);
        });

        this.label.on("annotationsShown", function () {
            _showWire(
                self.annotationsShown &&
                self.pin.enabled &&
                !self.label.culled &&
                self.label.shown &&
                self.pin.shown);
        });

        //TODO: write code for occlusion
        this.pin.on("occluded", function (occluded) {
            //ensure no opacity when occluded
            //not setting show / hide for simplicity
            if(occluded) {
                self.wire.css('opacity', '0');
            }
        });

        /** The scene object this annotation is attached to
         * @type {Human.scene.Object}
         */
        this.object = null;

        if (object) {
            this.setObject(object);
            if (!cfg.pos) {
                // No pin position was given, so position pin at center of object
                this.pin.setPos(object.getCenter());
            }
        }

        // Behaviours
        if (cfg.on) {
            var on = cfg.on;
            if (on.mouseClick) {
                this.label.on("mouseClick",
                    function () {
                        Human.rpc.call(null, on.mouseClick.call, on.mouseClick);
                    });
            }
        }
    };

    Human.utils.extend(Human.view.annotations.Annotation, Human.Component);


    /**
     * Reassigns annotation to an object
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.setObject = function (object) {

        if (this._objectShown) {
            this.object.off(this._objectShown);
        }
        var self = this;
        // Show/hide annotation in synch with its object
        this._objectShown = object.on("shown",
            function (shown) {
                self.pin.setEnabled(shown);
                self.label.setEnabled(shown);
            });
        // Nuke annotation when its object is destroyed
        this._objectDestroyed = object.on("destroyed",
            function () {
                self.destroy();
            });
        this.publish("object", this.object = object);
    };


    /**
     * Notifies this annotation on change to global toggle of annotation visibilities
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.setAnnotationsShown = function (annotationsShown) {
        this.annotationsShown = annotationsShown;
        this.pin.setAnnotationsShown(annotationsShown);
        this.label.setAnnotationsShown(annotationsShown);
    };

    /**
     * Control display of this annotation
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.setShown = function (shown) {
        this.pin.setShown(shown);
        this.label.setShown(shown);
    };

    /**
     * Destroys this annotation
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.destroy = function () {
        this.pin.destroy();
        this.label.destroy();
        this.wire.remove();

        if (this._objectShown) {
            this.object.off(this._objectShown);
        }
        if (this._objectDestroyed) {
            this.object.off(this._objectDestroyed);
        }
        this.publish("destroyed", true);
    };
})();

;(function() {
    "use strict";


    /**
     * @class A pin belonging to an {@link Human.view.Annotation}
     * @param cfg
     * @constructor
     */
    Human.view.annotations.Pin = function (annotation, id, cfg) {

        var containerSelector = $("#container");

        // Call parent class Human.Component init
        this._init();

        this._id = id;

        /** The {@link Human.view.Annotation} to which this pin belongs
         * @type {Human.view.Annotation}
         */
        this.annotation = annotation;

        /**
         * Whether or not annotations are globally enabled
         * @type {boolean}
         */
        this.annotationsShown = Human.view.annotations.shown;

        /**
         * Whether or not this pin is enabled
         * @type {boolean}
         */
        this.enabled = cfg.enabled !== false;

        /**
         * Whether or not this pin is shown
         * @type {boolean}
         */
        this.shown = cfg.shown !== false;

        /**
         * Whether or not this pin is culled
         * @type {boolean}
         */
        this.culled = false;

        /**
         * World-space position at which this pin is attached to its object.
         * @type {[Number, Number, Number]}
         */
        this.pos = Human.math.vec3();
        
        if (cfg.pos) {
            this.pos[0] = cfg.pos[0];
            this.pos[1] = cfg.pos[1];
            this.pos[2] = cfg.pos[2];
        }

        /**
         * The index of the triangle to which this annotation belongs.
         * @type {Number}
         */
        this.primitiveIndex = cfg.primitiveIndex;

        /**
         * Barycentric coordinates of this annotation within its triangle.
         * @type {[Number, Number, Number]}
         */
        this.barycentric = Human.math.vec3();

        if (cfg.barycentric) {
            this.barycentric[0] = cfg.barycentric[0];
            this.barycentric[1] = cfg.barycentric[1];
            this.barycentric[2] = cfg.barycentric[2];
        } else {
            this.barycentric[0] = this.barycentric[1] = this.barycentric[2] = 1/3;
        }

        this.viewPos = Human.math.vec4();

        /**
         * Whether or not this pin is occluded
         * @type {boolean}
         */
        this.occluded = false;

        /**
         * Direction this pin points
         * @type {[Number, Number, Number]}
         */
        this.dir = cfg.dir || [0, 0, -1];

        this._element = $('<div class="annotationPin"></div>');

        this.setPos(cfg.pos || [0, 0, 0]);
        this.setDir(cfg.dir || [0, 0, 0]);

        this.setAnnotationsShown(Human.view.annotations.shown);
        this.setEnabled((cfg.enabled !== undefined && cfg.enabled !== null) ? cfg.enabled : true);
        this.setShown((cfg.shown !== undefined && cfg.shown !== null) ? cfg.shown : true);
        this.setCulled(!!cfg.culled);
        this.setOpacity(1.0);

        containerSelector.append(this._element);

        this._element.click(this.pick.bind(this));
    };

    Human.utils.extend(Human.view.annotations.Pin, Human.Component);

    /**
     * Notifies this pin of change to global enable of annotation visibilities
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} annotationsShown True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setAnnotationsShown = function (annotationsShown) {
        this._showElement(annotationsShown && this.enabled && this.shown && !this.culled && !this.occluded);
        this.publish("enabled", this.annotationsShown = annotationsShown);
    };

    /**
     * Sets whether or not this pin is enabled
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} enabled True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setEnabled = function (enabled) {
        this._showElement(this.annotationsShown && enabled && this.shown && !this.culled && !this.occluded);
        this.publish("enabled", this.enabled = enabled);
    };

    /**
     * Sets whether or not this pin is shown
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} shown True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setShown = function (shown) {
        this._showElement(this.annotationsShown && this.enabled && shown && !this.culled && !this.occluded);
        this.publish("shown", this.shown = shown);
    };

    Human.view.annotations.Pin.prototype._showElement = function (shown) {
        if (shown) {
            this._element.show();
        } else {
            this._element.hide();
        }
    };

    /**
     * Culls this pin to given rectangle extents - pin is culled if it falls outside
     * @param {Number} xmin
     * @param {Number} ymin
     * @param {Number} xmax
     * @param {Number} ymax
     */
    Human.view.annotations.Pin.prototype.cullToRectangle = function (xmin, ymin, xmax, ymax) {
        var canvasPos = this.canvasPos;
        if (!canvasPos) {
            return;
        }
        this.setCulled(canvasPos[0] < xmin || canvasPos[0] > xmax || canvasPos[1] < ymin || canvasPos[1] > ymax);
        return this.culled;
    };

    /**
     * Sets whether or not this pin is culled
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} culled True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setCulled = function (culled) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !culled && !this.occluded);
        this.publish("culled", this.culled = culled);
    };

    /**
     * Transforms pin to View and Canvas space.
     */

    var projPos = Human.math.vec4();

    Human.view.annotations.Pin.prototype.transform = function (viewMat, projMat, canvas) {
        Human.math.transformPoint3(viewMat, this.pos, this.viewPos);
        this.viewPos[3] = 1; // Need homogeneous 'w' for perspective division
        Human.math.transformPoint4(projMat, this.viewPos, projPos);
        var x = projPos[0];
        var y = projPos[1];
        var w = projPos[3];
        this.canvasPos = [(1 + x / w) * canvas.width / 2, (1 - y / w) * canvas.height / 2];
        this._element.css({ "left": this.canvasPos[0], "top": this.canvasPos[1] });
    };

    /**
     * Sets whether or not this pin is occluded
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} occluded True if occluded
     */
    Human.view.annotations.Pin.prototype.setOccluded = function (occluded) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !this.culled && !occluded);
        this.publish("occluded", this.occluded = occluded);
    };

    /**
     * Sets the pin's angle between it's "direction" and the direction towards the eye
     * @memberof Human.view.annotations.Pin
     * @param {number} viewAngle The angle in degrees
     */
    Human.view.annotations.Pin.prototype.setViewAngle = function (viewAngle) {
        this.publish("angle", this.viewAngle = viewAngle);
    };

    /**
     * Sets the pin's angle between direction and
     * @memberof Human.view.annotations.Pin
     * @param {number} opacity Opacity factor in range [0..1]
     */
    Human.view.annotations.Pin.prototype.setOpacity = function (opacity) {
        this._element.css({ "opacity": this.opacity = opacity });
        this.publish("opacity", opacity);
    };

    /**
     * Sets pin position in World-space coordinates
     * @memberof Human.view.annotations.Pin
     * @param {[Number, Number, Number]} pos World-space position
     */
    Human.view.annotations.Pin.prototype.setPos = function (pos) {
        this.pos[0] = pos[0];
        this.pos[1] = pos[1];
        this.pos[2] = pos[2];
        this.publish("pos", this.pos);
    };

    /**
     * Sets pin direction
     * @memberof Human.view.annotations.Pin
     * @param {[Number, Number, Number]} dir Pin direction vector
     */
    Human.view.annotations.Pin.prototype.setDir = function (dir) {
        this.publish("dir", this.dir = dir);
    };

    /**
     * Notifies this pin that it has been picked
     * @memberof Human.view.annotations.Pin
     * @private
     */
    Human.view.annotations.Pin.prototype.pick = function () {
        this.publish("picked", true, true);
    };

    /**
     * Destroys this pin
     * @memberof Human.view.annotations.Pin
     * @private
     */
    Human.view.annotations.Pin.prototype.destroy = function () {
        Human.renderer.getNode(Human.NULL_OBJECT_ID).off(this._rendered);
        this._element.remove();
        this.publish("destroyed", true);
    };
})();
;(function (Human, $) {
    "use strict";

    /**
     * @class A label belonging to a {@link Human.view.Pin}
     * @param {Human.view.annotations.Annotation} annotation Owner annotation
     * @param {{}} cfg Configs
     * @constructor
     */
    var Label = Human.view.annotations.Label = function (annotation, cfg) {
        this._init(); // Call parent class Human.Component init

        this.annotation = annotation;
        this.saved = !!cfg.saved;

        this.offset = cfg.offset || [70, 70];


        this.offset2 = [this.offset[0], this.offset[1]];


        this.offset2 = [this.offset[0], this.offset[1]];

        var editable = (!cfg.saved || (cfg.saved && cfg.isOwner));

        var editing = this.editing = editable && !this.saved;

        var initialClass = this.saved ? '' : 'new';
        var editableClass = editable ? 'editable' : '';
        var editingClass = editing ? 'editing' : '';
        // layout class
        var layoutType = Human.view.annotations.layouts.activeLayout;
        var layoutClass = layoutType ? layoutType : '';
        var initialClasses = [initialClass, editableClass, editingClass, layoutClass].join(' ');

        var $container = $('#container');

        this.$element = $([
            '<div class="annotationContainer">',
            '<div class="annotationTitle clearfix">', //holds title elements
            '<input type="text" placeholder="">',
            '<h1></h1>',
            '<button class="annotationSave"></button>',
            '<button class="annotationDelete"></button>',
            '</div>',
            '<div class="annotationDescription">', //holds descriptions elements
            '<textarea placeholder=""></textarea>',
            '<p></p>',
            '</div>',
            '<div class="embedContainer"></div>',
            '</div>'
        ].join(''));

        //Select annotation components
        this.$titleContainer = this.$element.find('.annotationTitle');
        this.$title = this.$element.find('h1');
        this.$description = this.$element.find('p');
        this.$titleField = this.$element.find('input');
        this.$descriptionField = this.$element.find('textarea');
        // select buttons
        this.$deleteBtn = this.$element.find('.annotationDelete');
        this.$saveBtn = this.$element.find('.annotationSave');

        _initFieldMaxLength(this.$titleField, 100);
        _initFieldMaxLength(this.$descriptionField, 300); //set length constraints

        this.setTitle(cfg.title || '');
        this.setDescription(cfg.description || ''); //set initial values

        //set initial classes and add to DOM
        this.$element.addClass(initialClasses).appendTo($container);

        this.bindHandlers(editable);

        //Set these states after this.$element is defined
        this.setAnnotationsShown(Human.view.annotations.shown);
        this.setEnabled(cfg.enabled !== false);
        this.setShown(cfg.labelShown !== false);
        this.setCulled(!!cfg.culled);
        this.setOccluded(!!cfg.occluded);

        if (cfg.embed) {
            this.setEmbed(cfg.embed); //support for nested widget
        }

        this.setOffset(cfg.offset || [70, -70]);

        this.updateWidth();
    };

    Human.utils.extend(Human.view.annotations.Label, Human.Component);

    Label.prototype.bindHandlers = function (editable) {
        var self = this,
            $document = $(document);

        var globalSet = function (e) {
            //listen for a click outside the container to cancel editing
            var $target = $(e.target);
            var outsideClick = $target.closest('.annotationContainer').length === 0;

            if (outsideClick) {

                if (self.$titleField.val() || self.$descriptionField.val()) { // save non-empty annotation
                    self.save();
                    $document.off('click.set-annotation'); //turn it off
                } else { //delete empty annotation
                    //
                    if (self.pos) {
                        self.delete();
                        $document.off('click.set-annotation');
                    }
                }
            }
        };

        var setUIPosition = function () {
            var annotation = self.annotation;
            if (annotation.pin) {
                var pin = annotation.pin;
                var label = annotation.label;
                var wirePos1 = pin.canvasPos || [];
                var side = (label.offset[0] < 0);
                var labelPos = [wirePos1[0] + label.offset[0], wirePos1[1] + label.offset[1]];
                if (side) {
                    // Wire attaches to right side,
                    // shift label to the left to accommodate
                    labelPos[0] -= label.getWidth();
                }
                self.setPos(labelPos);
            }
        };

        // capture default font
        var titleFont = getElementFont(self.$titleField);
        var descriptionFont = getElementFont(self.$descriptionField);
        var showPlaceholderWidth = getTextWidth("Description", descriptionFont);

        // set description placeholder
        var setDescriptionUI = function (stripHtml) {
            var title = self.$titleField.val();
            var titleWidth = getTextWidth(title, titleFont, stripHtml);
            // show placeholder when wide enough
            if (title !== "" && titleWidth >= showPlaceholderWidth) {
                self.$descriptionField.attr("placeholder", "Description");
            }
            else {
                self.$descriptionField.attr("placeholder", "");
            }
        };

        var setTitleUI = function (stripHtml) {
            var title = self.$titleField.val();
            var description = self.$descriptionField.val();
            var lines = description.split('\n');
            var descWidth = getTextWidth(lines[0] + "X", descriptionFont, stripHtml);
            var containerMaxWidth = parseInt(self.$element.css("max-width"), 10);
            var maxWidth = containerMaxWidth + '' === 'NaN' ? 200 : containerMaxWidth;
            var width = getTextWidth(title + "X", titleFont, stripHtml);//+ 8;

            var targetWidth = Math.max(width, descWidth);
            targetWidth = Math.min(targetWidth, maxWidth);
            self.$titleContainer.css("width", targetWidth + "px");
            self.$titleField.css("width", targetWidth + "px");
            self.$descriptionField.css("width", targetWidth + "px");

            // set css
            if (title === "" && description === "") {
                if (!self.$element.hasClass("empty")) {
                    self.$element.addClass("empty");
                }
            }
            else {
                self.$element.removeClass("empty");
            }
            setUIPosition();
        };

        var setTextUI = function (stripHtml) {
            setTitleUI(stripHtml);
            setDescriptionUI(stripHtml);
        };

        // track UI handlers
        self.on("title", function () {
            setTextUI(true);
        });

        self.$titleField.on("keypress focus", function () {
            setTextUI(!editable);
        });

        self.$descriptionField.on("keypress focus", function () {
            setTextUI(!editable);
        });

        if (editable && this.editing) {
            //allow setting of newly created annotation on a global click
            $document.on('click.set-annotation', function (e) {
                globalSet(e);
            });
            // focus on title
            self.$titleField.focus();

            // Required for IE/Edge
            Human.utils.async(function () {
                self.$titleField.focus();
            });
        }

        self.on("mouseClick", function (params) {
            var $target = $(params.e.target);
            // enter edit on title header selection
            var titleSelected = $target.is(self.$titleContainer) || self.$titleContainer.has($target).length !== 0;
            if (editable && !self.editing && titleSelected) {

                self.editing = true;

                //give textarea same height as current description
                self.$descriptionField.height(self.$description[0].offsetHeight);

                self.$element.addClass('editing');
                // focus on title
                self.$titleField.focus();

                self.publish("edit", true, true);
                self.publish('updateWidth', true, true);

                $document.on('click.set-annotation', function (e) {
                    globalSet(e);
                });
            }
        });

        self.$descriptionField.blur(function (e) {
            globalSet(e);
        });

        self.$deleteBtn.click(function (e) {
            e.preventDefault();

            self.delete();
        });

        self.$saveBtn.click(function (e) {
            e.preventDefault();

            self.save();
        });

        // track mouse position
        var mouseX = 0;
        var mouseY = 0;
        // track mouse movement
        var trackMouseEvent = function (e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        };

        //Bind simple publishing to Label object
        self.$element.mouseenter(function (e) {
            self.publish("mouseEnter", {
                annotationId: self.annotation.annotationId,
                e: e
            }, true);
            trackMouseEvent(e);
        });

        self.$element.mouseleave(function (e) {
            self.publish("mouseLeave", {
                annotationId: self.annotation.annotationId,
                e: e
            }, true);
            trackMouseEvent(e);
        });

        self.$element.mousedown(function (e) {
            self.publish("mouseDown", {
                annotationId: self.annotation.annotationId,
                x: e.clientX,
                y: e.clientY,
                e: e
            }, true);
            trackMouseEvent(e);
        });

        self.$element.mouseup(function (e) {
            var clientX = e.clientX;
            var clientY = e.clientY;
            self.publish("mouseUp", {
                annotationId: self.annotation.annotationId,
                x: clientX,
                y: clientY,
                e: e
            }, true);
            // click
            if (mouseX === clientX && mouseY === clientY) {
                self.publish("mouseClick", {
                    annotationId: self.annotation.annotationId,
                    x: clientX,
                    y: clientY,
                    e: e
                }, true);
            }
            trackMouseEvent(e);
        });

        //On any human event that changes the Label object's width, update layout
        self.on('updateWidth', this._redrawWireConnection.bind(this));
    };

    Label.prototype.save = function () {
        this.editing = false;

        this.setTitle(this.$titleField.val());
        this.setDescription(this.$descriptionField.val());

        this.$element.removeClass('new editing');

        this.publish("saved", this.saved = true);
        this.publish('updateWidth', true, true);
    };

    Label.prototype.delete = function () {
        this.publish("delete", true, true);
    };

    /**
     * Sets the 2D canvas offset of the label from the pin. default value is [0,0].
     * @memberof Human.view.annotations.Label
     * @param {Array of Number} [offset=[0,0]] Canvas-space 2D offset
     */
    Label.prototype.setOffset = function (offset) {

        this.offset[0] = offset[0];
        this.offset[1] = offset[1];

        this.offset2[0] = offset[0];
        this.offset2[1] = offset[1];

        this.publish("offset", this.offset);
    };

    /**
     * Notifies this label on change to global toggle of annotation visibilities
     * @memberof Human.view.annotations.Label
     * @param {Boolean} annotationsShown True to show, false to hide
     */
    Label.prototype.setAnnotationsShown = function (annotationsShown) {
        this._showElement(annotationsShown && this.enabled && this.shown && !this.culled && !this.occluded);
        this.publish("annotationsShown", this.annotationsShown = annotationsShown);
    };

    /**
     * Sets whether or not this label is enabled
     * @memberof Human.view.annotations.Label
     * @param {Boolean} enabled True to show, false to hide
     */
    Label.prototype.setEnabled = function (enabled) {
        this._showElement(this.annotationsShown && enabled && this.shown && !this.culled && !this.occluded);
        this.publish("enabled", this.enabled = enabled);
    };

    /**
     * Sets whether or not this label is shown
     * @memberof Human.view.annotations.Label
     * @param {Boolean} shown True to show, false to hide
     */
    Label.prototype.setShown = function (shown) {
        this._showElement(this.annotationsShown && this.enabled && shown && !this.culled && !this.occluded);
        this.publish("shown", this.shown = shown);
    };

    /**
     * Sets whether or not this label is culled
     * @memberof Human.view.annotations.Label
     * @param {Boolean} culled True to show, false to hide
     */
    Label.prototype.setCulled = function (culled) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !culled && !this.occluded);
        this.publish("culled", this.culled = culled);
    };

    /**
     * Sets whether or not this label is occluded
     * @memberof Human.view.annotations.Label
     * @param {Boolean} occluded True if occluded
     */
    Label.prototype.setOccluded = function (occluded) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !this.culled && !occluded);
        this.publish("occluded", this.occluded = occluded);
    };

    /**
     * Sets the label's opacity
     * @memberof Human.view.annotations.Label
     * @param {number} opacity Opacity factor in range [0..1]
     */
    Label.prototype.setOpacity = function (opacity) {
        this.$element.css({"opacity": this.opacity = opacity});
        this.publish("opacity", opacity);
    };

    Label.prototype._showElement = function (shown) {
        if (shown) {
            this.$element.css("display", "inline-block");
        } else {
            this.$element.hide();
        }
    };

    /**
     * Sets the title
     * @memberof Human.view.annotations.Label
     * @param {String} title Title text
     */
    Label.prototype.setTitle = function (title) {
        this.$titleField.val(title);
        this.$title.html(title);
        this.publish("title", this.title = title);
    };

    /**
     * Sets the description
     * @memberof Human.view.annotations.Label
     * @param {String} description Description text
     */
    Label.prototype.setDescription = function (description) {
        this.$descriptionField.val(description);
        this.$description.html(description);
        this.publish("description", this.description = description);
    };

    /**
     * Sets the embed window
     * @memberof Human.view.annotations.Label
     * @param {Object} embed Embedded config data
     */
    Label.prototype.setEmbed = function (embed) {
        var params = ['ui-all=false']; //enforce no ui elements in this mode

        for (var key in embed) {
            if (embed.hasOwnProperty(key)) {
                params.push(key + '=' + embed[key]);
            }
        }

        var url = '/embedded.html?' + params.join('&');
        var iframe = '<iframe src="' + url + '" width="150" height="150" border="0"></iframe>';

        this.$element.addClass('annotationEmbed');
        this.$element.find('.embedContainer').append(iframe).show();

        this.publish('embed', this.embed = embed);
    };

    /**
     * Sets the DOM-space position of this label
     * @memberof Human.view.annotations.Label
     * @param {[Number, Number]} pos DOM-space label position
     * @param {Boolean} horizontal Indicates horizontal property set
     */
    Label.prototype.setPos = function (pos, horizontal) {
        if (horizontal) {
            pos[1] = pos[1] - this.$titleContainer[0].offsetHeight;
        }

        this.$element.css({left: pos[0] + 'px', top: pos[1] + 'px'});
        this.publish("pos", this.pos = pos);
    };

    /**
     * Sets the side of the canvas this label is on,
     * as well its wire connection position
     * @memberof Human.view.annotations.Label
     * @param {String} side 'left' or 'right'
     */
    Label.prototype.setSide = function (side) {
        this.side = side;
        this.$element.removeClass('left right').addClass(side);

        this.connectionPoint = [ //set the point where the wire will meet the label
            this.pos[0] + (side === 'left' ? this.getWidth() : 0),
            this.pos[1] + this.$titleContainer[0].offsetHeight
        ];
    };

    /**
     * Gets the top of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Top of label
     */
    Label.prototype.getTop = function () {
        return this.$element[0].offsetTop;
    };

    /**
     * Gets the bottom of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Bottom of label
     */
    Label.prototype.getBottom = function () {
        return this.$element[0].offsetTop + this.getHeight();
    };

    /**
     * Gets the height of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Height of label
     */
    Label.prototype.getHeight = function () {
        return this.$element[0].offsetHeight;
    };

    /**
     * Gets the width of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Width of label
     */
    Label.prototype.getWidth = function () {
        return this.$element[0].offsetWidth;
    };

    /**
     * Synchs the width property of this label with it's DOM outer width
     * @memberof Human.view.annotations.Label
     */
    Label.prototype.updateWidth = function () {
        this.width = this.getWidth();
    };

    Label.prototype._redrawWireConnection = function () {
        this.updateWidth();
        Human.view.annotations.layouts.redrawLayout();
    };

    /**
     * Destroys this label
     * @memberof Human.view.annotations.Label
     * @private
     */
    Label.prototype.destroy = function () {
        this.$element.remove();
        this.publish("destroyed", true);
    };

    //Private Utilities
    var _initFieldMaxLength = function ($element, maxLength) {
        if (maxLength && maxLength > 0) {
            $element.attr("maxlength", maxLength);

            $element.keyup(function (e) {
                if (e.keyCode === 13) { // ignore ENTER
                    return;
                } else if ($element.val().length >= maxLength) {
                    alert('Maximum characters allowed (' + maxLength + ')');
                }
            });
        }
    };

    // Text Utilities
    var textMeasureCanvas;
    // measures text's width in DOM
    var getTextWidth = function (text, font, _stripHtml) {
        textMeasureCanvas = textMeasureCanvas || document.createElement("canvas");

        var context = textMeasureCanvas.getContext("2d");
        context.font = font;

        if(_stripHtml) {
            text = stripHtml(text);
        }

        var metrics = context.measureText(text);

        return metrics.width;
    };

    var stripHtml = function (text) {
        var div = document.createElement("div");
        div.innerHTML = text;
        return div.innerText;
    };

    var getElementFont = function (element) {
        return $(element).css("font");
    };

})(Human, jQuery);
;/**
 * @namespace Pins annotations on anatomy objects while automatically determining their pin direction vectors from the eye position.
 */
(function () {
    "use strict";

    var placer = Human.view.annotations.placer = {};
    var eyePosVec = Human.math.vec3();

    /**
     * Places a fresh annotation at the given World-space position, with pin pointing towards the eye position.
     *
     * <p>The annotation:</p>
     * <ul>
     *     <li>will have empty strings for title and description,</li>
     *      <li>have an initially visible pin and label, and</li>
     *      <li>will be in an unsaved state.</li>
     * </ul>
     *
     * @param {{}} params Placement params
     * @param {String} params.objectId ID of an {@link Human.scene.Object} in {@link Human.scene}.
     * @param {[Number, Number, Number]} params.pos World-space position of annotation pin
     * @param {[Number, Number]} params.mouseDownPos Canvas-space position of mouse click when placing annotation with click-drag-release
     * @param {[Number, Number]} params.labelOffset Canvas-space offset of label from pin
     * @param {Boolean} params.mouseDownPos True when we are also currently positioning the label with the mouse, as we create this annotation
     * @param {[Number, Number, Number]} params.dir 3D vector indicating direction the pin is pointing
     */
    placer.placeAnnotation = function (params) {

        var eyePos = Human.view.camera.eye;

        eyePosVec[0] = eyePos.x;
        eyePosVec[1] = eyePos.y;
        eyePosVec[2] = eyePos.z;

        var eyeVec = Human.math.subVec3(eyePosVec, params.pos);

        Human.view.annotations.createAnnotation({
            objectId: params.objectId,
            title: params.title || "",
            description: params.description || "",
            pos: params.pos,
            mouseDownPos: params.mouseDownPos,
            dir: eyeVec,
            enabled: true,
            shown: true,
            labelShown: true,
            labelOffset: params.labelOffset,
            saved: (params.saved !== undefined && params.saved !== null) ? params.saved : false
        });
    };

})();







;/**
 * @namespace Renders an annotation onto a 2D canvas
 */
(function () {
    "use strict";

    var LABEL_TITLE_FONT_SIZE = 14;
    var LABEL_DESCRIPTION_FONT_SIZE = 12;
    var LABEL_TEXT_ALIGN = "left";
    var PIN_OUTER_RADIUS = 5.0;
    var PIN_INNER_RADIUS = 2.0;

    var renderer = Human.view.annotations.renderer = {};

    /**
     * Renders the annotation, labels, pin, etc... to the canvas object
     *
     * @param {{}} params Rander params
     * @param {Object} params.annotation An {@link Human.view.annotations.Annotation} in {@link Human.view}.
     * @param {Object} params.canvasData Canvas data
     * @param {String} params.bgColor Background color
     */
    renderer.render = function (params) {

        var annotation = params.annotation;
        var canvasData = params.canvasData;
        var bgColor = params.bgColor;

        var context = canvasData.context;
        var label = annotation.label;
        var pin = annotation.pin;
        var connectionPoint = label.connectionPoint;
        var scaleX = canvasData.scaleX;
        var scaleY = canvasData.scaleY;
        var pinX = pin.canvasPos[0] * scaleX;
        var pinY = pin.canvasPos[1] * scaleY;

        var labelShown = label.enabled && label.shown && !label.occluded && !label.culled;

        if (labelShown) {

            var labelX = label.pos[0] * scaleX;
            var connectX = connectionPoint[0] * scaleX;
            var connectY = connectionPoint[1] * scaleY;

            var labelWidth = Math.min((canvasData.width - labelX - 10), label.width * scaleX); //cap max-width

            //set font color based on background
            context.fillStyle = bgColor === 'white' ? "rgb(0, 0, 0)" : "rgb(255, 255, 255)";
            // set text align
            context.textAlign = LABEL_TEXT_ALIGN;

            // scale font to canvas
            var titleFontSize = Math.round(LABEL_TITLE_FONT_SIZE * scaleX);
            var descriptionFontSize = Math.round(LABEL_DESCRIPTION_FONT_SIZE * scaleX);

            // write title
            var getLines = function (context, text, maxWidth) {
                var words = text.split(' ');
                var line = '';
                var lines = [];

                for (var n = 0; n < words.length; n++) {
                    var testLine = line + words[n];
                    var metrics = context.measureText(testLine);
                    if (metrics.width > maxWidth && n > 0) {
                        lines.push(line);
                        line = words[n] + ' ';
                    } else {
                        line = testLine + ' ';
                    }
                }

                lines.push(line);
                return lines;
            };

            //Multi-line text drawing offset from leader line
            var renderText = function (text, fontSize, bold, startOffset) {
                var lineHeight = fontSize * 1.25;
                context.font = (bold ? "bold " : "") + fontSize + "px Arial";

                var lines = getLines(context, text || "", labelWidth);
                var startY = connectY + startOffset(lines, lineHeight);

                for (var i = 0; i < lines.length; i++) {
                    context.fillText(lines[i], labelX, startY + (lineHeight * i));
                }
            };

            renderText(label.title, titleFontSize, true, function (lines, lineHeight) {
                return -(lines.length - 1) * lineHeight - (lineHeight / 2);
            });
            // write description
            renderText(label.description, descriptionFontSize, false, function (lines, lineHeight) {
                return lineHeight;
            });

            //Draw wire (w/ title underline)
            // Need wire a bit more visible than pin
            var wireOpacity = pin.opacity;
            // +0.4;

            context.strokeStyle = "rgba(204, 204, 204, " + wireOpacity + ")";
            context.beginPath();

            context.moveTo(pinX, pinY);
            context.lineTo(connectX, connectY); //wire

            var underlineEnd = label.side === 'left' ? -labelWidth : labelWidth;
            context.lineTo(connectX + underlineEnd, connectY); //underline

            //context.closePath();
            context.stroke();
        }

        var drawCircle = function (radius, color, stroke) {
            context.fillStyle = color;
            context.beginPath();
            context.arc(pinX, pinY, radius, 0, 2 * Math.PI);
            context.fill();

            if (stroke) {
                stroke();
            }
        };

        var outerRadius = PIN_OUTER_RADIUS * scaleX;
        var innerRadius = PIN_INNER_RADIUS * scaleX;

        // draw pin
        drawCircle(outerRadius, 'rgb(255, 255, 255)', function () {
            context.lineWidth = 1;
            context.strokeStyle = 'rgb(204, 204, 204)';
            context.stroke();
        });
        drawCircle(innerRadius, 'rgb(153,0,0)');
    };

})();;/**
 * @namespace Annotation layout manager.
 *
 * <p>Strategies are plugged into this to provide various types of layout for annotation labels.</p>
 *
 * <p>The active layout is bound to the "annotation.layout.type" property.</p>
 */
(function () {
    "use strict";

    var HumanViewAnnotationsLayouts = Human.view.annotations.layouts = {};

    var layouts = {};
    var activeLayout;
    HumanViewAnnotationsLayouts.activeLayout = null;

    // Get annotation canvas when engine loaded
    Human.events.on(
        "loaded",
        function () {

            var canvas = document.getElementById("annotationCanvas");
            if (!canvas) {
                Human.log.error("Human.view.annotations.layouts", "DOM element not found: 'annotationCanvas'");
                return;
            }

            var context = canvas.getContext('2d');
            if (!context) {
                Human.log.error("Human.view.annotations.layouts", "Failed to get 2D canvas context");
                return;
            }

            // Select any layout required in configs
            Human.properties.subscribe({
                propId: "annotations.layout.type",
                value: "columns",  // HACK
                callback: function (value) {
                    //if (value != "") {
                        HumanViewAnnotationsLayouts._selectLayout(value);
                   // }
                }
            });

            // Update dirty layout on each renderer tick
            Human.events.on(
                "tick",
                function () {
                    if (activeLayout && canvas && context) {
                        activeLayout.layout(canvas, context);
                    }
                });
        });

    function layoutDirty() {
        if (activeLayout) {
            activeLayout.setDirty();
        }
    }
        
    // Layout dirty whenever camera moves
    Human.events.on(
        "camera.updated",
        function () {
            layoutDirty();
        });

    // Layout dirty whenever canvas resizes
     Human.events.on(
         "canvas.resized",
         function () {
            layoutDirty();
        });

    // Layout dirty whenever an annotation is created
    Human.events.on(
        "annotations.creating",
        function (params) {
            setLayoutEvents(params);
        });

    // Layout dirty whenever clip planes updated
    Human.events.on(
        "clip.updated",
        function () {
            layoutDirty();
        });

    // Layout dirty whenever scene object visibilities updated
    Human.events.on(
        "scene.objectsShown",
        function () {
            layoutDirty();
        });
    
    // Layout dirty whenever an annotation is loaded from a bookmark
    Human.events.on(
        "annotations.created",
        function (params) {
            setLayoutEvents(params);
        });

    var setLayoutEvents = function (params) {
        Human.events.onEvent("annotations.shown", layoutDirty);
        var annotation = Human.view.annotations.annotations[params.annotationId];
        annotation.on("object", layoutDirty);
        annotation.pin.on("enabled", layoutDirty);
        annotation.pin.on("shown", layoutDirty);
        annotation.label.on("shown", layoutDirty);
        annotation.label.on("edit", layoutDirty);
        annotation.label.on("saved", layoutDirty);
        annotation.label.on("cancel", layoutDirty);
        annotation.label.on("destroyed", layoutDirty);
        layoutDirty();
    };
            
    // Snapshot tool publishes its canvas and context just before it's
    // about to capture the snapshot image from it. We'll intercept it
    // and render the labels to it.
    Human.events.on(
        "snapshot.rendering",
        function (params) {
            if (activeLayout && activeLayout.snapshot) { // Only if active layout supports it
                activeLayout.snapshot(params.canvas, params.context, params.bgColor);
            }
        });

    /**
     * Adds a layout strategy.
     * @param {String} type The layout type name
     * @param {{}} layout The layout strategy
     */
    HumanViewAnnotationsLayouts.addLayoutType = function (type, layout) {
        if (layouts[type]) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout already added: '" + type + "'");
            return;
        }
        if (!layout.setEnabled) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout strategy does not have a 'setEnabled' method");
            return;
        }
        if (!layout.setDirty) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout strategy does not have a 'setDirty' method");
            return;
        }
        if (!layout.layout) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout strategy does not have a 'layout' method");
            return;
        }
        layouts[type] = layout;
        if (!activeLayout) {
            HumanViewAnnotationsLayouts._selectLayout(type); // Select first added by default
        }
    };

    /**
     * Activates a layout type.
     * Bound to a config property (see above)
     * @param {String} type The layout type name
     * @private
     */
    HumanViewAnnotationsLayouts._selectLayout = function (type) {

        // HACK alias names - want to use "columns" instead of "columns-v2"
        if (type === "columns-v2") {
            type = "columns";
        }

        Human.log.info("Human.view.annotations.layouts._selectLayout", "Selecting label type: '" + type + "'");
        if (!layouts[type]) {
            Human.log.error("Human.view.annotations.layouts._selectLayout", "Layout not found: '" + type + "'");
            return;
        }
        if (activeLayout === type) {
            // Already active
            return;
        }
        if (activeLayout) {
            activeLayout.setEnabled(false);
        }
        activeLayout = layouts[type];
        activeLayout.setEnabled(true);
        activeLayout.setDirty();
        HumanViewAnnotationsLayouts.activeLayout = type;
    };

    /**
     * Redraw the active layout.
     */
    HumanViewAnnotationsLayouts.redrawLayout = layoutDirty;

})();;/**
 * @namespace Annotation layout strategy which lays the labels out in left and right columns
 */
Human.view.annotations.layouts.addLayoutType(
    "columns",

    (function () {
        "use strict";

        var HumanViewAnnotations = Human.view.annotations;
        var ColumsLayout = {};

        // Margins config
        var margins;

        Human.properties.subscribe({
            propId: "annotations.margins",
            value: {
                top: 50,
                left: 50,
                right: 50,
                bottom: 50
            },
            callback: function (value) {
                margins = value;
            }
        });

        // Width of labels
        var maxLabelWidth;

        Human.properties.subscribe({
            propId: "annotations.labelWidth",
            value: 150,
            callback: function (value) {
                maxLabelWidth = value;
            }
        });

        // Horizontal lines flag
        var horizontalLines = false;

        Human.properties.subscribe({
            propId: "annotations.horizontalLines",
            value: horizontalLines,
            callback: function (value) {
                horizontalLines = value;
                dirty = true;
            }
        });

        // Angle beyond which labels are occluded
        var occludedAngle = 100;

        Human.properties.subscribe({
            propId: "annotations.occludedAngle",
            value: occludedAngle,
            callback: function (value) {
                occludedAngle = value;
                dirty = true;
            }
        });

        // Angle beyond which labels are faded
        var fadeoutAngle = 80;

        Human.properties.subscribe({
            propId: "annotations.fadeoutAngle",
            value: fadeoutAngle,
            callback: function (value) {
                fadeoutAngle = value;
                dirty = true;
            }
        });

        var enabled = false;
        var dirty = true;

        var leftColumn = [];
        var lenLeftColumn = 0;
        var rightColumn = [];
        var lenRightColumn = 0;

        var layoutCanvasWidth;
        var layoutCanvasHeight;

        /** Notifies this layout that it's enabled
         *
         * @param {boolean} enable True to enable, else false
         */
        ColumsLayout.setEnabled = function (enable) {
            enabled = enable;
            dirty = true;
        };

        /** Notifies this layout that will need to rebuild itself
         */
        ColumsLayout.setDirty = function () {
            dirty = true;
        };

        /**
         * Refreshes this layout.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        ColumsLayout.layout = function (canvas, context) {

            if (!dirty) {
                return;
            }

            context.clearRect(0, 0, canvas.width, canvas.height);

            if (!HumanViewAnnotations.shown) {
                // Annotations globally hidden
                dirty = false;
                return;
            }

            lenLeftColumn = 0;
            lenRightColumn = 0;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var pin;
            var label;
            var left;

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();

            var boundary = getCanvasModelBoundary(canvas, context, viewMat, projMat);

            if (Human.request.getSearchParam("showBoundary")) {
                context.beginPath();
                context.rect(boundary.xmin, boundary.ymin, boundary.xmax - boundary.xmin, boundary.ymax - boundary.ymin);
                context.lineWidth = 2;
                context.strokeStyle = 'black';
                context.stroke();
            }

            // Assign annotations to left and right columns
            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    pin = annotation.pin;
                    label = annotation.label;

                    // Skip over hidden annotations

                    if (!pin.shown || !pin.enabled) {
                        continue;
                    }

                    if (!label.shown && !pin.shown) {
                        continue;
                    }

                    // Transform pin into View and Canvas space
                    pin.transform(viewMat, projMat, canvas);

                    // Test if pin is "hidden" on a backface, ie. pointing away from eye
                    var angle = getPinViewAngle(pin);

                    pin.setViewAngle(angle);

                    var occluded = angle < -occludedAngle || angle > occludedAngle;

                    pin.setOccluded(occluded);

                    var opacity;

                    if (angle >= fadeoutAngle) {
                        opacity = 1 - ((angle - fadeoutAngle) / (occludedAngle - fadeoutAngle));
                        if (opacity < 0) {
                            opacity = 0;
                        }
                    } else {
                        opacity = 1.0;
                    }

                    pin.setOpacity(opacity);
                    label.setOpacity(opacity);

                    // Cull pins outside canvas extents.
                    // For API user convenience, want to update cull status on all pins,
                    // including those not enabled and/or not shown
                    pin.cullToRectangle(margins.left, 0, canvas.width - margins.right - maxLabelWidth, canvas.height);

                    // Cull label in synch with pin
                    if (pin.culled !== label.culled) {
                        label.setCulled(pin.culled);
                    }

                    // Synch label with pin's occlusion status
                    if (pin.occluded !== label.occluded) {
                        label.setOccluded(pin.occluded);
                    }

                    // If label visible, add to left or right column
                    // Label is visible only if pin enabled, shown, not culled and label shown
                    if (pin.enabled && pin.shown && !pin.culled && !pin.occluded && label.shown) {
                        left = (annotation.pin.viewPos[0] < 0);
                        if (left) {
                            leftColumn[lenLeftColumn++] = annotation;
                        } else {
                            rightColumn[lenRightColumn++] = annotation;
                        }
                    }
                }
            }

            // Sort columns by pin positions on Y-axis
            sortColumn(leftColumn, lenLeftColumn);
            sortColumn(rightColumn, lenRightColumn);

            // Lay the columns out
            layoutColumn(canvas, context, boundary, leftColumn, lenLeftColumn, -1);
            layoutColumn(canvas, context, boundary, rightColumn, lenRightColumn, +1);

            // Retain canvas dimensions for when we might render to snapshot
            layoutCanvasWidth = canvas.width;
            layoutCanvasHeight = canvas.height;

            dirty = false;
        };

        var projPos = Human.math.vec4();

        function getCanvasModelBoundary(canvas, context, viewMat, projMat) {

            // Get boundary of visible leaf objects

            var enabled = Human.scene.enabledObjects;
            var b;
            var worldBox;
            var worldPos;

            var x;
            var y;
            var w;

            var canvasBox = {
                xmin: Human.math.MAX_DOUBLE,
                ymin: Human.math.MAX_DOUBLE,
                xmax: Human.math.MIN_DOUBLE,
                ymax: Human.math.MIN_DOUBLE
            };

            for (var objectId in enabled) {
                if (enabled.hasOwnProperty(objectId)) {

                    var object = enabled[objectId];

                    if (object.numSubObjects === 0) {

                        b = object.getBoundary();

                        worldBox = [
                            [b.xmin, b.ymin, b.zmin],
                            [b.xmax, b.ymin, b.zmin],
                            [b.xmax, b.ymax, b.zmin],
                            [b.xmin, b.ymax, b.zmin],
                            [b.xmin, b.ymin, b.zmax],
                            [b.xmax, b.ymin, b.zmax],
                            [b.xmax, b.ymax, b.zmax],
                            [b.xmin, b.ymax, b.zmax]
                        ];

                        for (var i = 0; i < 8; i++) {

                            worldPos = worldBox[i];

                            Human.math.transformPoint3(viewMat, worldBox[i], projPos);

                            if (projPos[2] > 0.1) {

                                // Skip points that are outside the front clip plane

                                continue;
                            }

                            projPos[3] = 1; // Need homogeneous 'w' for perspective division

                            Human.math.transformPoint4(projMat, projPos, projPos);

                            x = projPos[0];
                            y = projPos[1];
                            w = projPos[3];

                            x = (1 + x / w) * canvas.width / 2;
                            y = (1 - y / w) * canvas.height / 2;

                            if (x < 0 || y < 0 || x > canvas.width || y > canvas.height) {

                                // Skip points that project off the canvas

                                continue;
                            }

                            if (canvasBox.xmin > x) {
                                canvasBox.xmin = x;
                            }

                            if (canvasBox.ymin > y) {
                                canvasBox.ymin = y;
                            }

                            if (canvasBox.xmax < x) {
                                canvasBox.xmax = x;
                            }

                            if (canvasBox.ymax < y) {
                                canvasBox.ymax = y;
                            }
                        }
                    }
                }
            }

            return canvasBox;
        }


        var eyeVec = Human.math.vec3();

        function getPinViewAngle(pin) {
            var eyePos = Human.view.camera.eye;

            eyeVec[0] = eyePos.x;
            eyeVec[1] = eyePos.y;
            eyeVec[2] = eyePos.z;

            Human.math.subVec3(eyeVec, pin.pos, eyeVec);
            var dot = Human.math.dotVector3(eyeVec, pin.dir);
            var lenEyeVec = Human.math.lenVec3(eyeVec);
            var lenPinVec = Human.math.lenVec3(pin.dir);
            var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
            return angle;
        }

        function sortColumn(column, len) { // Faster than native JS sort - no callback and less GC
            var temp;
            var min;
            for (var out = 0; out < len - 1; out++) {
                min = out;
                for (var inn = out; inn < len; inn++) {
                    if (column[inn].pin.canvasPos[1] < column[min].pin.canvasPos[1]) { //If max greater => new max
                        min = inn;
                    }
                }
                temp = column[out];
                column[out] = column[min];
                column[min] = temp;
            }
        }

        function layoutColumn(canvas, context, boundary, column, len, side) {
            // Find X position as the closest point possible to the model's
            // current canvas-space boundary, clamped to margins
            var x = (side < 0) ?
                Math.max(margins.left, boundary.xmin - maxLabelWidth - 50) :
                Math.min(canvas.width - margins.right - maxLabelWidth, boundary.xmax);

            var topMargin = Math.max(margins.top, boundary.ymin);
            var bottomMargin = Math.min(margins.bottom, boundary.ymax);
            var y = topMargin;
            var yRange = canvas.height - topMargin - bottomMargin;
            var yInc = yRange / len;
            var annotation;
            var pin, label, wire;

            for (var i = 0; i < len; i++) {
                annotation = column[i];

                pin = annotation.pin;
                label = annotation.label;
                wire = annotation.wire;

                // Draw wire
                var pinX = pin.canvasPos[0];
                var pinY = pin.canvasPos[1];

                // Position the label
                label.setPos([x, horizontalLines ? pinY : y], horizontalLines);
                //sets side & connectionPoint relative to position
                label.setSide(side < 0 ? 'left' : 'right');

                var connection = label.connectionPoint;

                var wireLength = Math.sqrt((Math.pow(connection[0] - pinX, 2) + Math.pow(connection[1] - pinY, 2)));

                var wireAngle;

                if (horizontalLines) {
                    wireAngle = side < 0 ? 0 : 180;
                } else {
                    wireAngle = Math.atan2(pinY - connection[1], pinX - connection[0]) * 180 / Math.PI;
                }

                wire.css({
                    width: wireLength + 'px',
                    left: connection[0] + 'px',
                    top: connection[1] + 'px',
                    opacity: pin.opacity,

                    '-webkit-transform': 'rotate(' + wireAngle + 'deg)',
                    '-moz-transform': 'rotate(' + wireAngle + 'deg)',
                    '-ms-transform': 'rotate(' + wireAngle + 'deg)',
                    '-o-transform': 'rotate(' + wireAngle + 'deg)',
                    transform: 'rotate(' + wireAngle + 'deg)'
                });

                y += yInc;
            }
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        ColumsLayout.snapshot = function (canvas, context, bgColor) {

            if (!HumanViewAnnotations.shown) {
                // Annotations globally hidden
                return;
            }

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates 
            //from layout canvas to snapshot canvas
            var scaleX = snapshotCanvasWidth / layoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / layoutCanvasHeight;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    if (annotation.pin.enabled && !annotation.pin.occluded) {

                        label = annotation.label;

                        if (label.shown) {
                            HumanViewAnnotations.renderer.render({
                                annotation: annotation,
                                canvasData: canvasData,
                                bgColor: bgColor
                            });
                        }
                    }
                }
            }
        };

        return ColumsLayout;
    })());;/**
 * @namespace Annotation layout strategy which arranges the labels on wires that radiate outwards.
 */
Human.view.annotations.layouts.addLayoutType(
    "radial",

    (function () {
        "use strict";

        var HumanViewAnnotations = Human.view.annotations;
        var RadialLayout = {};

        // Whether wires are enabled or not
        var wires = true;
        Human.properties.subscribe({
            propId: "annotation.layout.wires",
            value: true,
            callback: function (value) {
                wires = value;
            }
        });

        // Gap between edge of canvas and labels
        var labelMargins = 100;
        Human.properties.subscribe({
            propId: "annotation.layout.labelMargins",
            value: 100,
            callback: function (value) {
                labelMargins = value;
            }
        });

        // Width of labels
        var labelWidth = 200;
        Human.properties.subscribe({
            propId: "annotation.layout.labelWidth",
            value: 100,
            callback: function (value) {
                labelWidth = value;
            }
        });

        var enabled = false;
        var dirty = true;

        var leftColumn = [];
        var lenLeftColumn = 0;
        var rightColumn = [];
        var lenRightColumn = 0;

        var layoutCanvasWidth;
        var layoutCanvasHeight;


        /** Notifies this layout that it's enabled
         *
         * @param {boolean} enable True to enable, else false
         */
        RadialLayout.setEnabled = function (enable) {
            enabled = enable;
            dirty = true;
        };

        /** Notifies this layout that will need to rebuild itself
         */
        RadialLayout.setDirty = function () {
            dirty = true;
        };

        /**
         * Refreshes this layout.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        RadialLayout.layout = function (canvas, context) {

            if (!dirty) {
                return;
            }

            lenLeftColumn = 0;
            lenRightColumn = 0;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var pin;
            var label;
            var left;

            // Assign annotations to left and right columns
            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    pin = annotation.pin;
                    label = annotation.label;

                    // Cull pins outside canvas extents.
                    // For API user convenience, want to update cull status on all pins,
                    // including those not enabled and/or not shown
                    pin.cullToRectangle(0, 0, canvas.width, canvas.height);

                    // Cull label with pin
                    if (pin.culled !== label.culled) {
                        label.setCulled(pin.culled);
                    }

                    // If label visible, add to left or right column
                    // Label is visible only if pin enabled, shown, not culled and label shown
                    if (pin.enabled && pin.shown && !pin.culled && label.shown) {
                        if (annotation.pin.viewPos) { // Might not have been obtained (ie. pin rendered) yet
                            left = (annotation.pin.viewPos[0] < 0);
                            if (left) {
                                leftColumn[lenLeftColumn++] = annotation;
                            } else {
                                rightColumn[lenRightColumn++] = annotation;
                            }
                        }
                    }
                }
            }

            // Sort columns by pin positions on Y-axis
            sortColumn(leftColumn, lenLeftColumn);
            sortColumn(rightColumn, lenRightColumn);

            context.clearRect(0, 0, canvas.width, canvas.height);

            // Lay the columns out
            layoutColumn(canvas, context, leftColumn, lenLeftColumn, labelMargins);
            layoutColumn(canvas, context, rightColumn, lenRightColumn, canvas.width - labelMargins - labelWidth);

            // Retain canvas dimensions for when we might render to snapshot
            layoutCanvasWidth = canvas.width;
            layoutCanvasHeight = canvas.height;

            dirty = false;
        };

        function sortColumn(column, len) { // Faster than native JS sort - no callback and less GC
            var temp;
            var min;
            for (var out = 0; out < len - 1; out++) {
                min = out;
                for (var inn = out; inn < len; inn++) {
                    if (column[inn].pin.pos[1] > column[min].pin.pos[1]) { //If max greater => new max
                        min = inn;
                    }
                }
                temp = column[out];
                column[out] = column[min];
                column[min] = temp;
            }
        }

        function layoutColumn(canvas, context, column, len, x) {
            var canvasHalfX = canvas.width / 2.0;
            var yRange = canvas.height;
            var yInc = yRange / len;
            var y = 50;
            var annotation;
            var pin;

            var label;
            for (var i = 0; i < len; i++) {
                annotation = column[i];
                pin = annotation.pin;
                label = annotation.label;

                // Position the label
                label.setPos([x, y]);

                // Draw wire
                context.strokeStyle = "rgb(0, 0, 100)";
                context.beginPath();
                context.moveTo(pin.canvasPos[0], pin.canvasPos[1]);
                if (x < canvasHalfX) {
                    context.lineTo(x + label.getWidth(), y);
                } else {
                    context.lineTo(x, y);
                }
                context.closePath();
                context.stroke();

                y += yInc;
            }
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        RadialLayout.snapshot = function (canvas, context) {

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates 
            //from layout canvas to snapshot canvas
            var scaleX = snapshotCanvasWidth / layoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / layoutCanvasHeight;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    if (annotation.pin.enabled) {

                        label = annotation.label;

                        if (label.shown) {
                            HumanViewAnnotations.renderer.render({
                                annotation: annotation,
                                canvasData: canvasData
                            });
                        }
                    }
                }
            }
        };

        return RadialLayout;
    })());
;/**
 * @namespace Annotation layout strategy which floats the labels directly over their pin positions
 */
Human.view.annotations.layouts.addLayoutType(
    "floating",

    (function () {
        "use strict";

        var HumanViewAnnotations = Human.view.annotations;
        var FloatingLayout = {};

        // Width of labels
        var maxLabelWidth;

        Human.properties.subscribe({
            propId: "annotations.labelWidth",
            value: 120,
            callback: function (value) {
                maxLabelWidth = value;
            }
        });

        var enabled = false;
        var dirty = true;

        var layoutCanvasWidth;
        var layoutCanvasHeight;

        // Angle at which to decide whether or not a pin is occluded
        var occludedPinAngle = 90;

        /** Notifies this layout that it's enabled
         *
         * @param {boolean} enable True to enable, else false
         */
        FloatingLayout.setEnabled = function (enable) {
            enabled = enable;
            dirty = true;
        };

        /** Notifies this layout that will need to rebuild itself
         */
        FloatingLayout.setDirty = function () {
            dirty = true;
        };

        /**
         * Refreshes this layout.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        FloatingLayout.layout = function (canvas) {

            if (!dirty) {
                return;
            }

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var pin;
            var label;

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    pin = annotation.pin;
                    label = annotation.label;

                    // Transform pin into View and Canvas space
                    pin.transform(viewMat, projMat, canvas);

                    // Test if pin is "hidden" on a backface, ie. pointing away from eye
                    var angle = getPinViewAngle(pin);
                    pin.setViewAngle(angle);
                    var occluded = angle < -90 || angle > 90;
                    pin.setOccluded(occluded);

                    // Set translucency in proportion to
                    // how much pin points away from eye
                    var opacity = ((0 - 1) * (angle - 0)) / (occludedPinAngle - 0) + 1;
                    if (opacity < 0) {
                        opacity = 0;
                    }
                    pin.setOpacity(opacity);
                    label.setOpacity(opacity + 0.5);

                    // Cull pins outside canvas extents.
                    // For API user convenience, want to update cull status
                    // on all pins, including those not enabled and/or not shown
                    pin.cullToRectangle(0, 0, canvas.width, canvas.height);

                    // Cull label in synch with pin
                    if (pin.culled !== label.culled) {
                        label.setCulled(pin.culled);
                    }

                    // Synch label with pin's occlusion status
                    if (pin.occluded !== label.occluded) {
                        label.setOccluded(pin.occluded);
                    }

                    // Position label is shown
                    // Label is visible only if pin enabled, shown, not culled and label shown
                    if (pin.enabled && pin.shown && !pin.culled && !pin.occluded && label.shown) {
                        label.setPos(pin.canvasPos);
                    }
                }
            }

            // Save canvas dimensions for snapshots
            layoutCanvasWidth = canvas.width;
            layoutCanvasHeight = canvas.height;

            dirty = false;
        };

        var eyeVec = Human.math.vec3();

        function getPinViewAngle(pin) {
            var eyePos = Human.view.camera.eye;

            eyeVec[0] = eyePos.x;
            eyeVec[1] = eyePos.y;
            eyeVec[2] = eyePos.z;

            Human.math.subVec3(eyeVec, pin.pos, eyeVec);
            var dot = Human.math.dotVector3(eyeVec, pin.dir);
            var lenEyeVec = Human.math.lenVec3(eyeVec);
            var lenPinVec = Human.math.lenVec3(pin.dir);
            var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
            return angle;
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        FloatingLayout.snapshot = function (canvas, context) {

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates 
            //from layout canvas to snapshot canvas
            var scaleX = snapshotCanvasWidth / layoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / layoutCanvasHeight;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    if (annotation.pin.enabled && !annotation.pin.occluded) {
                        label = annotation.label;
                        if (label.shown) {
                            HumanViewAnnotations.renderer.render({
                                annotation: annotation,
                                canvasData: canvasData
                            });
                        }
                    }
                }
            }
        };

        return FloatingLayout;
    })());
;/**
 * @namespace Annotation layout strategy which lays the labels out in left and right columns
 */
Human.view.annotations.layouts.addLayoutType(
    "draggable",

    (function () {
        "use strict";

        var HumanViewAnnotations = Human.view.annotations;
        var Layout = {};


        // Margins config
        var margins;

        Human.properties.subscribe({
            propId: "annotations.margins",
            value: {
                top: 50,
                left: 50,
                right: 50,
                bottom: 50
            },
            callback: function (value) {
                margins = value;
            }
        });

        // Angle beyond which labels are occluded
        var occludedAngle = 100;

        Human.properties.subscribe({
            propId: "annotations.occludedAngle",
            value: occludedAngle,
            callback: function (value) {
                occludedAngle = value;
                dirty = true;
            }
        });

        // Angle beyond which labels are faded
        var fadeoutAngle = 80;

        Human.properties.subscribe({
            propId: "annotations.fadeoutAngle",
            value: fadeoutAngle,
            callback: function (value) {
                fadeoutAngle = value;
                dirty = true;
            }
        });


        // True when this layout strategy is enabled
        var enabled = false;

        // True when the whole layout needs to be rebuilt
        var dirty = true;

        // Set to an annotation when we just need to update the layout of that annotation label
        var dirtyAnnotation = null;

        // Save canvas dimensions after doing each layout,
        // Used when rendering the snapshot, which is always preceded by a layout.

        var lastLayoutCanvasWidth;
        var lastLayoutCanvasHeight;


        /** Notifies this layout that it's enabled
         *
         * @param {Boolean} enable True to enable, else false
         */
        Layout.setEnabled = function (enable) {

            enabled = enable;

            dirty = true;
        };


        // Annotation label drag behaviours

        (function () {

            // Annotation who's label we're currently dragging
            var annotation;

            // Previous mouse position while dragging
            var lastX = -1;
            var lastY = -1;


            Human.events.on("annotations.mouseDown",
                function (params) {

                    if (!enabled) {
                        return;
                    }

                    annotation = HumanViewAnnotations.annotations[params.annotationId];

                    lastX = params.x;
                    lastY = params.y;
                });

            $('body').mousemove(
                function (e) {

                    if (!enabled) {
                        return;
                    }

                    if (annotation) {

                        var x = e.clientX;
                        var y = e.clientY;

                        var offset = annotation.label.offset;

                        annotation.label.setOffset([
                            offset[0] + x - lastX,
                            offset[1] + y - lastY
                        ]);

                        lastX = x;
                        lastY = y;

                        dirtyAnnotation = annotation;
                    }
                });

            $('body').mouseup(
                function () {

                    if (!enabled) {
                        return;
                    }

                    annotation = null;
                });
        })();


        /**
         * Indicate that layout needs to be rebuilt
         */
        Layout.setDirty = function () {
            dirty = true;
        };

        /**
         * Rebuilds this layout, if it needs a rebuild.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        var queryAnnotations = [];

        Layout.layout = function (canvas) {

            if (!dirty && !dirtyAnnotation) {

                // Rebuild not needed
                return;
            }

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();
            var annotations, annotation, annotationId;
            queryAnnotations.length = 0;

            if (dirty) {

                annotations = HumanViewAnnotations.annotations;

                // Refresh layout for all annotations

                if (!HumanViewAnnotations.shown) {

                    // Annotations are currently globally hidden
                    dirty = false;
                    return;
                }

                // Update states of all annotations

                for (annotationId in annotations) {
                    if (annotations.hasOwnProperty(annotationId)) {

                        annotation = annotations[annotationId];

                        if (layoutAnnotation(annotation, viewMat, projMat, canvas)) {

                            if (annotation.occludable) {

                                // Schedule an occlusion query for pin position

                                queryAnnotations.push(annotation);

                            } else {
                                renderAnnotation(annotation);
                            }
                        }
                    }
                }

                // Save canvas dimensions after doing each layout,
                // Used when rendering the snapshot, which is always preceded by a layout.

                lastLayoutCanvasWidth = canvas.width;
                lastLayoutCanvasHeight = canvas.height;

                dirty = false;

            } else {

                // Refresh layout for a single annotation

                annotations = {};
                annotations[dirtyAnnotation.annotationId] = dirtyAnnotation;

                if (layoutAnnotation(dirtyAnnotation, viewMat, projMat, canvas)) {

                    // Schedule an occlusion query for pin position

                    if (dirtyAnnotation.occludable) {

                        // Schedule an occlusion query for pin position

                        queryAnnotations.push(dirtyAnnotation);
                    } else {
                        renderAnnotation(dirtyAnnotation);
                    }
                }

                dirtyAnnotation = null;
            }

            // Do occlusion query

            Human.view.annotations.occlusionQuery.runQuery(queryAnnotations, renderAnnotation);
        };

        function layoutAnnotation(annotation, viewMat, projMat, canvas) {

            var pin = annotation.pin;
            var label = annotation.label;

            var canvasHeight = canvas.height;
            var canvasWidth = canvas.width;


            // Skip over hidden annotations

            if (!pin.shown || !pin.enabled) {

                // Label pin not shown, skip annotation
                return;
            }

            if (!pin.shown) {

                // Label and pin not shown, skip annotation
                return;
            }

            // Transform annotation pin position by view and projection transforms
            pin.transform(viewMat, projMat, canvas);

            // Get angle between pin and eye vector
            var angle = getPinViewAngle(pin);

            pin.setViewAngle(angle);

            // Set annotation opacity according to the pin-eye angle
            var opacity;

            if (angle >= fadeoutAngle) {
                opacity = 1 - ((angle - fadeoutAngle) / (occludedAngle - fadeoutAngle));
                if (opacity < 0) {
                    opacity = 0;
                }
            } else {
                opacity = 1.0;
            }

            pin.setOpacity(opacity);
            label.setOpacity(opacity);

            // Clip pins outside canvas extents.
            // For API user convenience, we update the cull status
            // on ALL pins including those not enabled and/or not shown

            pin.cullToRectangle(margins.left, 0, canvasWidth - margins.right, canvasHeight);

            // Cull label in synch with pin
            if (pin.culled !== label.culled) {
                label.setCulled(pin.culled);
            }

            if (pin.culled) {

                // Pin outside canvas, so now culled
                return false;
            }

            return true;
        }

        /**
         * Returns angle indicating how much the given annotation pin points away from the eye,
         * where 0 indicates that it points directly at the eye, while 180 indicates that it points directly away.
         *
         * @param pin
         * @returns {number}
         */
        function getPinViewAngle(pin) {
            var eyePos = Human.view.camera.eye;
            var eyeVec = Human.math.subVec3([eyePos.x, eyePos.y, eyePos.z], pin.pos);
            var dot = Human.math.dotVector3(eyeVec, pin.dir);
            var lenEyeVec = Human.math.lenVec3(eyeVec);
            var lenPinVec = Human.math.lenVec3(pin.dir);
            var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
            return angle;
        }

        function renderAnnotation(annotation) {

            var pin = annotation.pin;
            var label = annotation.label;
            var wire = annotation.wire;

            var wirePos1 = pin.canvasPos;

            var side = (label.offset[0] < 0);

            var labelPos = [wirePos1[0] + label.offset[0], wirePos1[1] + label.offset[1]];

            if (side) {
                // Wire attaches to right side,
                // shift label to the left to accommodate
                labelPos[0] -= label.getWidth();
            }

            label.setPos(labelPos);

            // Sets side & connectionPoint relative to position
            label.setSide(side ? 'left' : 'right');

            var connection = label.connectionPoint;

            var wireLength = Math.sqrt((Math.pow(connection[0] - wirePos1[0], 2) + Math.pow(connection[1] - wirePos1[1], 2)));

            var wireAngle;

            wireAngle = Math.atan2(connection[1] - wirePos1[1], connection[0] - wirePos1[0]) * 180 / Math.PI;

            // Position the wire
            wire.css({
                width: wireLength + 'px',
                left: wirePos1[0] + 'px',
                top: wirePos1[1] + 'px',
                opacity: pin.opacity,

                '-webkit-transform': 'rotate(' + wireAngle + 'deg)',
                '-moz-transform': 'rotate(' + wireAngle + 'deg)',
                '-ms-transform': 'rotate(' + wireAngle + 'deg)',
                '-o-transform': 'rotate(' + wireAngle + 'deg)',
                transform: 'rotate(' + wireAngle + 'deg)'
            });
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * Renders the annotations that are visible and not occluded.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        Layout.snapshot = function (canvas, context, bgColor) {

            if (!HumanViewAnnotations.shown) {
                // Annotations globally hidden
                return;
            }

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates
            //from layout canvas to snapshot canvas

            var scaleX = snapshotCanvasWidth / lastLayoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / lastLayoutCanvasHeight;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var pin;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {

                    annotation = annotations[annotationId];
                    pin = annotation.pin;

                    if (pin.enabled && pin.shown && !pin.occluded) {

                        // Render annotation pins even if labels are hidden

                        HumanViewAnnotations.renderer.render({
                            annotation: annotation,
                            canvasData: canvasData,
                            bgColor: bgColor
                        });
                    }
                }
            }
        };

        return Layout;

    })());
;/**
 * @namespace Hides annotations while camera is moving
 */
(function () {
    "use strict";

    var enabled = false;
    var cameraUpdated = false;
    var timeout;

    Human.properties.subscribe({
        propId: "annotations.hideWhileCameraMoving",
        value: enabled,
        callback: function (value) {
            enabled = value;
        }
    });

    Human.events.on("camera.updated",
        function () {
            cameraUpdated = true;
        });

    Human.events.on("tick",
        function () {
            if (!enabled) {
                return;
            }
            if (cameraUpdated) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                Human.view.annotations.setShown(false);
                cameraUpdated = false;
            } else {
                if (!timeout) {
                    timeout = setTimeout(function () {
                        clearTimeout(timeout);
                        Human.view.annotations.setShown(true);
                    }, 200);
                }
            }
        });


})();
;/**
 * @namespace Activates "draggable" layout manager whenever possible
 */
(function () {
    "use strict";

    Human.events.on("bookmarks.restored", tryActivateDraggable);

    Human.events.on("modules.activated", tryActivateDraggable);

    Human.events.on("modules.deactivated", tryActivateDraggable);

    function tryActivateDraggable(evt) {
        if (moduleAnnotationsLayoutSet(Human.modules.modules[evt.moduleId])) {
            return;
        }

        var layout = canActivateDraggable() ? "draggable": "columns-v2";
        Human.properties.set({ "annotations.layout.type": layout });
    }

    function canActivateDraggable() {
      /*
      annotations are draggable if they have a labelOffset property, and not otherwise.
      */
        var annotations = Human.view.annotations.annotations;
        var chapters = Human.timeline.chapters;
        var annotationId;
        var chapterId;
        for (annotationId in annotations) {
            if (annotations.hasOwnProperty(annotationId)) {
                if (!annotations[annotationId].draggable) {
                    return false;
                }
            }
        }
        for (chapterId in chapters) {
            if (chapters.hasOwnProperty(chapterId)) {
                annotations = chapters[chapterId].annotations || {};
                for (annotationId in annotations) {
                    if (annotations.hasOwnProperty(annotationId)) {
                        if (!annotations[annotationId].draggable) {
                            return false;
                        }
                    }
                }
            }
        }
        // check activeRoot._chapters
        var result = true;
        if (!!Human.timeline.activeRoot){
          Human.timeline.activeRoot._chapters.forEach(function(chapter){
            var annotation;
            var annotationIdx;
            for (annotationIdx=0; annotationIdx < chapter.annotations.length; annotationIdx++){
              annotation = chapter.annotations[annotationIdx];
              if (!annotation.hasOwnProperty("labelOffset")){
                result = false;
              }
            }
          });
        }
        
        return result;
    }

    function moduleAnnotationsLayoutSet(module) {
        if (!module) {
            return false;
        }
        if (module.annotationsLayout) {
            return true;
        }
        if (module.properties && module.properties["annotations.layout.type"]) {
            return true;
        }
        return false;
    }

})();
;/**
 * @namespace Animates positions of pins of annotations on morphing objects.
 */
(function () {
    "use strict";

    // An animation for each annotation on a morph
    var animations = {};

    // Fast iteration array
    var animationsList = [];
    var numAnimations = 0;

    var dirty = false;

    var canvas;

    Human.events.on("loaded",
        function () {

            canvas = document.getElementById("annotationCanvas");
        });

    // We get this event as soon as user clicks on an object in annotation
    // mode, when doing click-move-click annotation placement.
    //

    Human.events.on("annotations.pinning", pauseTimeline);

    // We get this event as soon as an annotation is pinned
    // to an object by the user, before they fill in the label.
    //
    Human.events.on("annotations.creating", pauseTimeline);

    // We get this event as soon as either an annotation is
    // saved by a user who just created it, or is loaded into
    // the engine via a condition or bookmark.
    //
    Human.events.on("annotations.created",
        function (params) {

            var annotationId = params.annotationId;
            var annotation = Human.view.annotations.annotations[annotationId];

            if (!annotation.followsObject) {
                playTimeline();
                return;
            }

            var objectId = params.objectId;
            var object = Human.scene.objects[objectId];

            if (!objectId || !object) {
                playTimeline();
                return;
            }

            var morphingAnnotation = object.morph && object.geometry && annotation.pin.primitiveIndex;

            if (morphingAnnotation) {
                var offset = annotation.label.offset;

                animations[annotationId] = new MorphAnimation({
                    object: object,
                    morph: object.morph,
                    geometry: object.geometry,
                    annotation: annotation,
                    offset: [offset[0], offset[1]]
                });
            } else {
                animations[annotationId] = new XformAnimation({
                    object: object,
                    annotation: annotation
                });
            }

            dirty = true;

            playTimeline();
        });


    // We also get this event when a user has cancelled out of
    // creating an annotation.
    //
    Human.events.on("annotations.destroyed",
        function (params) {

            var annotationId = params.annotationId;

            if (animations[annotationId]) {

                delete animations[annotationId];

                dirty = true;
            }

            playTimeline();
        });

    Human.events.on("tick",
        function () {

            if (dirty) {

                // Lazy-rebuild fast iteration array

                numAnimations = 0;

                for (var annotationId in animations) {
                    if (animations.hasOwnProperty(annotationId)) {
                        animationsList[numAnimations++] = animations[annotationId];
                    }
                }

                dirty = false;
            }

            if (numAnimations > 0) {

                for (var i = 0; i < numAnimations; i++) {
                    animationsList[i].update();
                }

                Human.view.annotations.layouts.redrawLayout();
            }
        });

    var worldToModel = Human.math.mat4();

    function XformAnimation(cfg) {
        this._annotation = cfg.annotation;
        this._object = cfg.object;

        this._pinPos = Human.math.vec3();
        this._pinPos.set(this._annotation.pin.pos);

        Human.math.inverseMat4(this._object.getWorldMatrix(), worldToModel);
        Human.math.transformPoint3(worldToModel, this._pinPos, this._pinPos);
    }


    var pos = Human.math.vec3();

    XformAnimation.prototype.update = function () {

        var annotation = this._annotation;

        if (!annotation.pin.shown) {

            // Don't animate hidden pins
            return;
        }

        Human.math.transformPoint3(this._object.getWorldMatrix(), this._pinPos, pos);

        annotation.pin.setPos(pos);
    };

    // Vertices of each triangle
    var a = Human.math.vec3();
    var b = Human.math.vec3();
    var c = Human.math.vec3();

    function MorphAnimation(cfg) {

        var morph = cfg.morph;
        var geometry = cfg.geometry;
        var annotation = cfg.annotation;
        var pin = annotation.pin;

        this._object = cfg.object;
        this._morph = morph;
        this._annotation = annotation;
        this._times = morph.getKeys();
        this._targets = [];

        // Caches last time frame after each call to #update()
        this._index1 = 0;
        this._index2 = 1;

        // True when looping
        this._loop = !!cfg.loop;

        this._pickPos = Human.math.vec3();

        this._pinPos = Human.math.vec3();
        Human.math.inverseMat4(this._object.getWorldMatrix(), worldToModel);
        Human.math.transformPoint3(worldToModel, annotation.pin.pos, this._pinPos);

        this._offset = [
            annotation.label.offset[0],
            annotation.label.offset[1]
        ];

        var self = this;

        annotation.label.on("offset", function (offset) {
            self._offset = offset;
        });


        // Using the barycentric position, find the target cartesian
        // pin position at each morph target, which we'll tween
        // within to animate the pin in synch with the morph.

        var i;
        var len;
        var mTargets = this._morph.getTargets();
        var positions;
        var primitiveIndex = pin.primitiveIndex;
        var indices = geometry.getIndices();
        var ia = indices[primitiveIndex];
        var ib = indices[primitiveIndex + 1];
        var ic = indices[primitiveIndex + 2];
        var barycentric = pin.barycentric;
        var cartesian;

        for (i = 0, len = mTargets.length; i < len; i++) {

            positions = mTargets[i].positions;

            a[0] = positions[(ia * 3)];
            a[1] = positions[(ia * 3) + 1];
            a[2] = positions[(ia * 3) + 2];

            b[0] = positions[(ib * 3)];
            b[1] = positions[(ib * 3) + 1];
            b[2] = positions[(ib * 3) + 2];

            c[0] = positions[(ic * 3)];
            c[1] = positions[(ic * 3) + 1];
            c[2] = positions[(ic * 3) + 2];

            cartesian = barycentricToCartesian(barycentric, a, b, c, Human.math.vec3());

            this._targets.push(cartesian);
        }

        this._pickPos[0] = this._pinPos[0];
        this._pickPos[1] = this._pinPos[1];
        this._pickPos[2] = this._pinPos[2];
    }

    /**
     * Updates this animation, updating the value of #pos.
     */
    var avgCanvasPos = Human.math.vec2();
    var canvasPos = Human.math.vec2();

    MorphAnimation.prototype.update = function () {

        var annotation = this._annotation;

        if (!annotation.pin.shown) {

            // Don't animate hidden pins
            return;
        }

        var time = this._morph.getFactor();

        if (this._targets.length < 2) {
            return;
        }

        if (time === undefined) {
            time = this._times[0];
        }

        var firstTime = this._times[0];
        var lastTime = this._times[this._times.length - 1];

        if (!this._loop) {

            // Clamp time to range
            // Return clamped value

            if (time <= firstTime) {
                return this._targets[0];

            } else if (time >= lastTime) {
                return this._targets[this._targets.length - 1];
            }

        } else {

            // Wrap time within range

            time = this._times[0] + (time % (lastTime - firstTime));
        }

        // Wind on to enclosing time frame

        // Wind backwards or forwards to find enclosing frame

        while (this._times[this._index1] > time) {
            this._index1--;
            this._index2--;
        }

        while (this._times[this._index2] < time) {
            this._index1++;
            this._index2++;
        }

        // Interpolate

        Human.math.lerpVec3(
            time,

            this._times[this._index1],
            this._times[this._index2],

            this._targets[this._index1],
            this._targets[this._index2],

            this._pinPos);

        Human.math.transformPoint3(this._object.getWorldMatrix(), this._pinPos, this._pinPos);

        annotation.pin.setPos(this._pinPos);

        this._transform(this._pickPos, avgCanvasPos);
        this._transform(this._pinPos, canvasPos);

        annotation.label.offset2[0] = this._offset[0] - (canvasPos[0] - avgCanvasPos[0]);
        annotation.label.offset2[1] = this._offset[1] - (canvasPos[1] - avgCanvasPos[1]);
    };

    var viewPos = Human.math.vec4();
    var projPos = Human.math.vec4();

    MorphAnimation.prototype._transform = function (worldPos, canvasPos) {
        var viewMat = Human.renderer.getViewMat();
        var projMat = Human.renderer.getProjMat();

        Human.math.transformPoint3(viewMat, worldPos, viewPos);

        viewPos[3] = 1; // Need homogeneous 'w' for perspective division

        Human.math.transformPoint4(projMat, viewPos, projPos);

        var x = projPos[0];
        var y = projPos[1];
        var w = projPos[3];

        canvasPos[0] = (1 + x / w) * canvas.width / 2;
        canvasPos[1] = (1 - y / w) * canvas.height / 2;

        return canvasPos;
    };

    /**
     * Gets the cartesian position of a barycentric coordinate within a triangle.
     */
    function barycentricToCartesian(barycentric, a, b, c, cartesian) {
        var u = barycentric[0];
        var v = barycentric[1];
        var w = barycentric[2];
        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;
        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;
        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;
        return cartesian;
    }

    // True whenever this manager has paused the timeline
    // as an annotation is created
    var pausedTimeline = false;
    var pausedFreeAnimations = false;

    function pauseTimeline() {

        if (Human.timeline.playing) {
            Human.timeline.playing = false;
            pausedTimeline = true;
        }

        if (Human.timeline.playfree) {
            Human.timeline.playfree = false;
            pausedFreeAnimations = true;
        }
    }

    function playTimeline() {
        // Unpause the timeline if it is currently paused by this manager.

        if (pausedTimeline) {
            Human.timeline.playing = true;
            pausedTimeline = false;
        }

        if (pausedFreeAnimations) {
            Human.timeline.playfree = true;
            pausedFreeAnimations = false;
        }
    }

})();
;/**
 @namespace tests if annotations atr occluded by objects in the 3D scene.

 <pre>

 // First register some positions with the query:

 var query = Human.view.annotations.occlusionQuery;

 query.clear();

 query.addAnnotation( Human.view.annotations.annotations["a1"] );
 query.addAnnotation( Human.view.annotations.annotations["a2"] );
 query.addAnnotation( Human.view.annotations.annotations["a3"] );
 query.addAnnotation( Human.view.annotations.annotations["a4"] );

 // Run a query to update the occlusion status of the annotations:

 query.doQuery();

 // Log the new occlusion status of each annotation:

 var result;

 for (var i = 0; i < query.lenResult; i++) {

        result = query.result[i];

        annotation = result.annotation;

        if (!result.occluded) {

                // Visible

        } else {
                // Occluded
        }
  }

 </pre>

 */
(function () {

    "use strict";

    var OcclusionQuery = Human.view.annotations.occlusionQuery = {};

    // SceneJS node where we keep 3D position indicators
    var rootNode;
    var canvas;

    // Points to query occlusion status of. These are added
    // with #addAnnotation and cleared after each call to #doQuery
    var points = [];
    var numPoints = 0;

    /**
     * Results of the last occlusion query.
     * @type {Array}
     */
    OcclusionQuery.result = [];

    /**
     * Number of query results.
     * @type {number}
     */
    OcclusionQuery.lenResult = 0;


    // Once the 3D scene is ready, get the scene node
    // where we'll graft the 3D spheres

    Human.events.on("loaded",
        function () {
            rootNode = Human.renderer.getNode("occlusionIndicators");
            canvas = Human.renderer.canvas.canvas[0];
        });

    // Angle beyond which labels are occluded
    var occludedAngle = 100;

    Human.properties.subscribe({
        propId: "annotations.occludedAngle",
        value: occludedAngle,
        callback: function (value) {
            occludedAngle = value;
            dirty = true;
        }
    });

    var TICKS_PER_QUERY = 6;

    var dirty = true;
    var ticks = TICKS_PER_QUERY;

    var queryAnnotations = [];
    var renderCallback = null;
    var viewMat, projMat;
    var canvasWidth, canvasHeight;

    Human.events.on("tick", function() {
        ticks++;
        if (dirty && ticks >= TICKS_PER_QUERY && queryAnnotations.length > 0) {
            viewMat = Human.renderer.getViewMat();
            projMat = Human.renderer.getProjMat();
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;
            _runQuery();
            dirty = false;
            ticks = 0;
        }
    });

    OcclusionQuery.runQuery = function(annotations, render) {
        queryAnnotations = annotations || [];
        renderCallback = render || null;
        dirty = true;

        queryAnnotations.forEach(function(annotation) {
            if (!annotation.pin.occluded) {
                renderCallback(annotation);
            }
        });
    };

    function _runQuery() {
        var i, len;

        OcclusionQuery.clear();

        for (i = 0, len = queryAnnotations.length; i < len; i++) {
            OcclusionQuery.addAnnotation(queryAnnotations[i]);
        }

        OcclusionQuery.doQuery();

        var annotations = Human.view.annotations.annotations;
        var result = OcclusionQuery.result;
        var lenResult = OcclusionQuery.lenResult;
        var annotation, pin, label, r;

        for (i = 0; i < lenResult; i++) {
            r = result[i];
            annotation = annotations[r.annotationId];
            pin = annotation.pin;
            label = annotation.label;
            if (r.occluded) {
                pin.setOccluded(true);
                label.setOccluded(true);

            } else {
                pin.setOccluded(false);
                label.setOccluded(false);

                if (renderCallback) {
                    renderCallback(annotation);
                }
            }
        }
    }

    

    /**
     * Clears occlusion query results.
     */
    OcclusionQuery.clear = function () {

        for (var i = 0; i < numPoints; i++) {
            points[i].point.setShown(false);
        }

        numPoints = 0;
    };

    /**
     * Adds an annotation to include in the occlusion query.
     *
     * The next call to #doQuery will perform an occlusion query for each
     * annotation that was added by this method, and will put the results
     * for each annotation in the #results array.
     *
     * The annotation will be forgotten after the next #doQuery call.
     *
     * @returns {*}
     */

    var cameraPos = Human.math.vec3();
    var worldPos = Human.math.vec3();
    var offset = Human.math.vec3();
    var canvasPos = Human.math.vec2();

    OcclusionQuery.addAnnotation = function (annotation) {

        var pin = annotation.pin;
        var label = annotation.label;

        // Get angle between pin and eye vector
        var angle = getPinViewAngle(pin);

        pin.setViewAngle(angle);

        // Pin is occluded when it points away from the eye
        var occluded = angle < -occludedAngle || angle > occludedAngle;

        pin.setOccluded(occluded);

        if (pin.occluded !== label.occluded) {
            label.setOccluded(occluded);
        }

        if (occluded) {
            return;
        }

        var object = annotation.object;
        var eye = Human.view.camera.eye;
        var clipping = (object && !object.clippable) ? false : true;

        worldPos.set(pin.pos);

        cameraPos[0] = eye.x;
        cameraPos[1] = eye.y;
        cameraPos[2] = eye.z;

        Human.math.subVec3(cameraPos, worldPos, offset);
        var l = Human.math.lenVec3(offset);
        Human.math.divVec3s(offset, l, offset);
        Human.math.mulVec3Scalar(offset, Math.min(l * 0.1, 0.5), offset);
        Human.math.addVec3(worldPos, offset, worldPos);

        world2Canvas(worldPos, viewMat, projMat, canvasWidth, canvasHeight, canvasPos);

        // Register annotation for query

        var point = points[numPoints] || (points[numPoints] = {

                // Inputs canvas coordinates
                x: 0, y: 0,

                // Outputs pixel color at the given coordinates
                r: 0, g: 0, b: 0, a: 0,

                // Sphere for occlusion point in 3D view
                point: new Point(),

                // True when occluded
                occluded: false
            });

        point.annotation = annotation;

        point.x = canvasPos[0];
        point.y = canvasPos[1];

        point.point.setWorldPos(worldPos);

        point.point.setShown(true);

        point.point.setClipping(clipping);

        // Reset query result for the annotation

        var result = OcclusionQuery.result[numPoints] || (OcclusionQuery.result[numPoints] = {
                annotationId: null,
                occluded: false
            });

        result.annotationId = annotation.annotationId;
        result.occluded = false;

        numPoints++;
    };

    /**
     * Performs an occlusion query for each query annotation.
     *
     * The query results are then available in #results.
     *
     * Clears the query annotations.
     *
     */
    OcclusionQuery.doQuery = function () {

        if (numPoints === 0) {
            return;
        }

        var opaqueOnly = true; // Ignore transparent pixels

        Human.renderer.getScene().readPixels(points, numPoints, opaqueOnly);

        var point;

        for (var i = 0; i < numPoints; i++) {

            // Get occlusion state of object, put into result array

            point = points[i];

            OcclusionQuery.result[i].occluded = !(point.r === 0 && point.g === 0 && point.b === 255);

            // Hide the 3D pin indicator
            // This will schedule another render (after next engine "tick"), unfortunately

            point.point.setShown(false);
        }

        OcclusionQuery.lenResult = numPoints;

        // Clear the query points

        numPoints = 0;

    };

    /**
     * Returns angle indicating how much the given annotation pin points away from the eye,
     * where 0 indicates that it points directly at the eye, while 180 indicates that it points directly away.
     *
     * @param pin
     * @returns {number}
     */
    function getPinViewAngle(pin) {
        var eyePos = Human.view.camera.eye;
        var eyeVec = Human.math.subVec3([eyePos.x, eyePos.y, eyePos.z], pin.pos);
        var dot = Human.math.dotVector3(eyeVec, pin.dir);
        var lenEyeVec = Human.math.lenVec3(eyeVec);
        var lenPinVec = Human.math.lenVec3(pin.dir);
        var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
        return angle;
    }

    var pos = Human.math.vec4();

    function world2Canvas(worldPos, viewMat, projMat, canvasWidth, canvasHeight, result) {
        Human.math.transformPoint3(viewMat, worldPos, pos);
        pos[3] = 1; // Need homogeneous 'w' for perspective division
        Human.math.transformPoint4(projMat, pos, pos);
        var x = pos[0];
        var y = pos[1];
        var w = pos[3];
        result[0] = (1 + x / w) * canvasWidth / 2;
        result[1] = (1 - y / w) * canvasHeight / 2;
    }

    /**
     * Renders a point within the 3D view
     *
     * @constructor
     */
    function Point() {

        this._flags = rootNode.addNode({
            type: "flags",
            flags: {
                enabled: false,
                clipping: true,
                picking: false
            }
        });

        this._material = this._flags.addNode({
            type: "material",
            color: {r: 0, g: 0, b: 1},
            specularColor: {r: 0, g: 0, b: 0},
            emitColor: {r: 0, g: 0, b: 1},
            emit: 1
        });

        this._translate = this._material.addNode({
            type: "translate",
            x: 0,
            y: 0,
            z: 0
        });

        this._geometry = this._translate.addNode({
            type: "geometry",
            primitive: "points",
            coreId: "__occludePoint",
            positions: [0, 0, 0],
            pointSize: 3
        });
    }

    Point.prototype.setShown = function (shown) {
        this._flags.setEnabled(!!shown);
    };

    Point.prototype.setClipping = function (clipping) {
        this._flags.setClipping(!!clipping);
    };

    Point.prototype.setWorldPos = function (worldPos) {
        this._translate.setXYZ({
            x: worldPos[0],
            y: worldPos[1],
            z: worldPos[2]
        });
    };

    Point.destroy = function () {
        this._flags.destroy();
    };
})();;/**
 * @namespace Focuses the view on specified objects in the 3D scene.
 */
(function () {
    "use strict";

    var HumanViewFocus = Human.view.focus = {};

    var medlineEnabled = true;

    Human.properties.subscribe({
        propId: "data.medline.enabled",
        value: true,
        callback: function (value) {
            medlineEnabled = value;
        }
    });

    var wikipediaEnabled = true;

    Human.properties.subscribe({
        propId: "data.wikipedia.enabled",
        value: true,
        callback: function (value) {
            wikipediaEnabled = value;
        }
    });

    /**
     * Focuses on an {@link Human.scene.Object} in the {@link Human.scene}.
     * <ol>
     * <li>Shows label on object,</li>
     * <li>flies camera to either a) boundary of object,</li>
     * <li>queries data on object from the 3rd-party data sources enabled on {@link Human.data}, and</li>
     * <li>publishes object's new "focused" status in a "focus.objectFocused" event.</li>
     * @function
     * @param {{}} params Focus params
     * @param {String} [params.objectId] ID of object to focus on
     * @param {String} [params.fmaId] FMA ID of object to focus on
     * @param {Boolean} [params.select]
     * @param {Boolean} [params.allSelected]
     * @param {Boolean} [params.newSelected]
     * @param {Boolean} [params.showLabel=true]
     * @param {Boolean} [params.xray]
     * @param {Number} [params.backOff] Camera back-off factor in range of [0..1], when 0 is close (default), 1 is far
     * @param {Function} ok Completion callback
     * @memberof Human.view.focus
     */
    HumanViewFocus.focusObject = function (params, ok) {

        ok = ok || Human.utils.noop;

        var fmaId = params.fmaId;
        var objectId = params.objectId;
        var objectIds = params.objectIds;

        if (!objectId && !fmaId && !objectIds) {

            // Missing params

            Human.log.error("Human.view.focusObject", "Parameter expected: either 'objectId', 'objectIds' or 'fmaId'");
            ok();
            return;
        }

        var scene = Human.scene;

        var object;

        if (objectId) {

            // Focus on object by ID

            object = scene.objects[objectId];

            if (!object) {
                Human.log.error("Human.view.focusObject", "Scene object not found: '" + objectId + "'");
                ok();
                return;
            }

        } else if (fmaId) {

            // Focus on object by FMA ID

            object = scene.objectsByFMAID[fmaId];

            if (!object) {
                Human.log.error("Human.view.focusObject", "Scene object not found for this FMAID: '" + fmaId + "'");
                ok();
                return;
            }

            objectId = object.objectId;
        }

        if (params.xray === true) {

            // X-Ray mode

            Human.rpc.call(null, "xray.setEnabled", { enable: true });

        } else if (params.xray === false) {

            // No X-Ray

            Human.rpc.call(null, "xray.setEnabled", { enable: false });
        }

        var select = params.select;

        if (select === undefined || select === null) {
            select = params.replace || !scene.selectedObjects[objectId];
        } else {
            select = params.select;
        }

        var flyTo = params.flyTo;
        var boundary;

        if (params.replace) {    // Single focus

            scene.setSelectedObjects({
                objectId: objectId,
                select: select,
                replace: params.replace
            });

        } else if (select) {   // Multi focus

            var objects = {};

            objects[objectId] = select;

            scene.setSelectedObjects({
                objects: objects,
                replace: params.replace
            });
        }

        if ((params.showLabel !== false) || !select) {
            Human.view.labels._clearLabels();
        }

        if (params.showLabel !== false) {
            showLabel(params);
        }

        if (select && flyTo === "newSelected") {

            // Get boundary enclosing newly selected objects

            boundary = object.getBoundary();
            if (boundary) {
                Human.view.boundary.setBoundary(boundary, true);     // Show selected object boundary
                Human.view.camera.fly.flyTo({                               // Fly to selected object
                        boundary: boundary,
                        backOff: params.backOff,
                        arc: 0.0,
                        easing: true
                    },
                    function () {
                        Human.view.boundary.setBoundary(false);      // Hide boundary
                        publishObjectFocused(objectId, flyTo);
                        ok();
                    });
            }

        } else if (!flyTo || flyTo === "allSelected") {

            // Get boundary enclosing currently selected objects

            boundary = scene.getBoundary({ objects: scene.selectedObjects });
            if (boundary) {
                Human.view.boundary.setBoundary(boundary, true);     // Show selected object boundary
                Human.view.camera.fly.flyTo({                               // Fly to selected object
                        boundary: boundary,
                        backOff: params.backOff,
                        arc: 0.0,
                        easing: true
                    },
                    function () {
                        Human.view.boundary.setBoundary(false);      // Hide boundary
                        if (select) {
                            publishObjectFocused(objectId, flyTo);
                        }
                        ok();
                    });
            } else {

                Human.view.boundary.setBoundary(false);      // Hide boundary

                if (select) {
                    publishObjectFocused(objectId, flyTo);
                }

                ok();
            }

        } else if (flyTo === "selectedLeafObjects") {

            // Fly to leaf objects from among those objects that are currently selected
            
            Human.view.camera.fly.flyTo({                        // Fly to selected object
                    selectedLeafObjects: true,
                    backOff: params.backOff,
                    arc: 0.0,
                    easing: true
                },
                function () {
                    Human.view.boundary.setBoundary(false);      // Hide boundary
                    if (select) {
                        publishObjectFocused(objectId, flyTo);
                    }
                    ok();
                });

        } else if (flyTo === "object") {

            boundary = object.getBoundary();

            Human.view.boundary.setBoundary(boundary, true);     // Show selected object boundary

            Human.view.camera.fly.flyTo({                               // Fly to selected object
                    boundary: boundary,
                    backOff: params.backOff,
                    arc: 0.0,
                    easing: true
                },
                function () {
                    Human.view.boundary.setBoundary(false);      // Hide boundary
                    if (select) {
                        publishObjectFocused(objectId, flyTo);
                    }
                    ok();
                });
        } else {
            publishObjectFocused(objectId, flyTo);
            ok();
        }

    };


    function showLabel(params) {
        Human.view.labels.createLabel({ objectId: params.objectId, afterDelay: true });
        Human.renderer.forceRenderFrame();
    }

    function publishObjectFocused(objectId, flyTo) {
        var object = Human.scene.objects[objectId];
        if (object) {
            Human.events.fire("focus.objectFocused", {
                objectId: objectId,
                description: object.description,
                flyTo: flyTo
            });
        }
    }

})();;/** @namespace Manages X-Ray view mode
 */
(function () {
    "use strict";

    var HumanViewXray = Human.view.xray = {};

    HumanViewXray.enabled = false;
    var dirty = true;

    Human.events.on(
        "loaded",
        function () {
            HumanViewXray.enabled = false;
            dirty = false;
        });

    Human.events.on(
        "scene.objectsSelected",
        function () { // Schedule xray for next frame when object selection changes
            if (HumanViewXray.enabled) {
                dirty = true;
            }
        });

    Human.events.on(
        "tick",
        function () {// Apply pending xray for next frame
            if (dirty) {
                xray(HumanViewXray.enabled);
                dirty = false;
            }
        });

    // Applies XRay to enabled model objects, making selected
    // objects opaque and the rest transparent
    function xray(enabled) {
        var model = Human.scene;
        var objects = model.objects;
        var object;
        for (var objectId in objects) { // De-highlight highlighted objects
            if (objects.hasOwnProperty(objectId)) {
                object = objects[objectId];
                if (enabled) { // Do X-ray
                    if (Human.scene.selectedObjects[object.objectId]) { // Opaque
                        object.setXRay(false);
                        object.setHighlight(false);
                    } else { // X-ray
                        object.setXRay(true);
                    }
                } else { // Undo X-ray
                    object.setXRay(false);
                }
            }
        }
    }

    HumanViewXray.setEnabled = function (enable) {
        if (HumanViewXray.enabled !== enable) {
            HumanViewXray.enabled = enable;
            dirty = true;
        }
        Human.events.fire("xray.toggled", { enabled:enable });
        if (HumanViewXray.enabled) {
            Human.view.currentMode = 'Xray';
        }
        xray(enable);
    };

    HumanViewXray.getEnabled = function () {
        return HumanViewXray.enabled;
    };

})();
;/** @namespace Manages picking of {@link Human.scene.Object}s in the {@link Human.scene}.
 */
(function () {
    "use strict";

    var HumanViewPick = Human.view.pick = {};

    HumanViewPick.singleEnabled = true;
    HumanViewPick.multiEnabled = false;

    /**
     * Always get 3D intersection point when picking.
     * API can set this true so that it always gets the 3D point in "pick.picked" events.
     * @type {boolean}
     */
    var alwaysRayPick = false;

    // Whether picking changes visibility of objects
    Human.properties.subscribe({
        propId: "pick.alwaysRayPick",
        value: alwaysRayPick,
        callback: function (value) {
            alwaysRayPick = value;
        }
    });

    var regionsPickAll = false;

    // Whether picking changes visibility of objects
    Human.properties.subscribe({
        propId: "pick.regions.pickAll",
        value: regionsPickAll,
        callback: function (value) {
            regionsPickAll = value;
        }
    });

    Human.events.on(
        "loaded", // Pick enabled by default
        function () {
            HumanViewPick.setSinglePickEnabled(true); // Notifies of initial state
            HumanViewPick.setMultiPickEnabled(false);
        });

    /** Enables or disables single-pick mode
     * @memberof Human.view.pick
     * @param {Boolean} enable Enables or disables single-pick mode
     */
    HumanViewPick.setSinglePickEnabled = function (enable) {
        if (HumanViewPick.singleEnabled !== enable) {
            HumanViewPick.singleEnabled = enable;
        }
        if (enable) {
            if (HumanViewPick.multiEnabled) {
                HumanViewPick.multiEnabled = false;
            }
            Human.events.fire("pick.multi.toggled", { enabled: HumanViewPick.multiEnabled });
        }
        Human.events.fire("pick.single.toggled", { enabled: HumanViewPick.singleEnabled });
    };

    /** Queries whether or not single-pick mode is enabled
     * @memberof Human.view.pick
     * @returns true if single-pick mode enabled else false
     */
    HumanViewPick.getSinglePickEnabled = function () {
        return HumanViewPick.singleEnabled;
    };

    /** Enables or disables multi-pick mode
     * @memberof Human.view.pick
     * @param {Boolean} enable Enables or disables multi-pick mode
     */
    HumanViewPick.setMultiPickEnabled = function (enable) {
        if (HumanViewPick.multiEnabled !== enable) {
            HumanViewPick.multiEnabled = enable;
        }
        if (enable) {
            if (HumanViewPick.singleEnabled) {
                HumanViewPick.singleEnabled = false;
            }
            Human.events.fire("pick.single.toggled", { enabled: HumanViewPick.singleEnabled });
        }
        Human.events.fire("pick.multi.toggled", { enabled: HumanViewPick.multiEnabled });
    };

    /** Queries whether or not multi-pick mode is enabled
     * @memberof Human.view.pick
     * @returns true if multi-pick mode enabled else false
     */
    HumanViewPick.getMultiPickEnabled = function () {
        return HumanViewPick.multiEnabled;
    };

    HumanViewPick.hoverPick = function (params) {
        return HumanViewPick._pick(params, true, false, false, alwaysRayPick, params.regionPick);
    };

    HumanViewPick.hoverOff = function () {
        Human.view.tooltips.clearTooltip();
    };

    HumanViewPick.pick = function (params) {
        return HumanViewPick._pick(params, false, false, false, alwaysRayPick, params.regionPick);
    };

    HumanViewPick.doublePick = function (params) {
        return HumanViewPick._pick(params, false, true, false, alwaysRayPick, params.regionPick);
    };

    HumanViewPick.queryPick = function (params) {
        return HumanViewPick._pick(params, false, false, true, params.rayPick || alwaysRayPick, params.regionPick);
    };

    /**
     * Performs a pick at the given X,Y canvas coordinates
     * @memberof Human.view.pick
     * @param params
     * @param {Number} params.canvasX Canvas X-coordinate
     * @param {Number} params.canvasY Canvas Y-coordinate
     * @param {Boolean} params.mouseDownLeft True when left mouse key is down
     * @param {Boolean} params.mouseDownRight True when right mouse key is down
     * @param {Boolean} params.spaceDown True when SPACE key is down
     * @param {Boolean} params.ctrlDown True when ALT key is down
     * @param {Boolean} hover Set true to do a hover-pick
     * @param {Boolean} doubleClick Set true to do a "double click" pick
     * @return
     */
    HumanViewPick._pick = function (params, hover, doubleClick, query, rayPick, regionPick) {

        var canvasX = params.canvasX;
        var canvasY = params.canvasY;
        var mouseDownLeft = params.mouseDownLeft;
        var mouseDownRight = params.mouseDownRight;
        var spaceDown = params.spaceDown;
        var ctrlDown = params.ctrlDown;
        var hit, regionMapId, object, objects, annotation;
        var pixelColor;

        Human.assets.regionMaps.highlightRegion(null);

        // Querying picked object
        if (query) {
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {

                    var result = Human.utils.apply(hit, {
                        mode: "query",
                        objectId: object.objectId,
                        mouseDownLeft: mouseDownLeft,
                        mouseDownRight: mouseDownRight
                    });

                    if (object.regionMap) {
                        hit = Human.renderer.pick(canvasX, canvasY, rayPick, true);
                        
                        if (hit) {
                            result.regionMapId = object.regionMap.regionMapId;
                            result = Human.utils.apply(result, hit);
                        }
                    }
                    
                    Human.events.fire("pick.picked", result);
                    return result;
                } else {
                    return;
                }
            }
            return;
        }

        if (!HumanViewPick.singleEnabled &&
            !HumanViewPick.multiEnabled &&
            !Human.view.dissect.enabled &&
            !Human.view.annotations.enabled &&
            !Human.view.highlight.enabled) {
            return;
        }

        //If test condition has been started. Disable selection of object
        if (Human.scene.checkTestStarted) { // TODO: Code smell!
            return;
        }

        // Hovering
        if (hover) {
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {
                    var event = Human.utils.apply(hit, {
                        mode: "hover",
                        objectId: object.objectId
                    });
                    var tootipTitle = object.displayName;

                    if (object.regionMap) {
                        hit = Human.renderer.pick(canvasX, canvasY, rayPick, true);
                        
                        if (hit) {
                            if (regionsPickAll) {
                                regionMapId = null;
                            } else {
                                regionMapId = object.regionMap.regionMapId;
                                event.regionMapId = regionMapId;
                                event = Human.utils.apply(event, hit);
                            }

                            pixelColor = hit.color;
                            Human.assets.regionMaps.highlightRegion({
                                regionColor: pixelColor,
                                regionMapId: regionMapId,
                                highlight: true
                            });

                            if (hit.regionData.name) {
                                tootipTitle = hit.regionData.name;
                            }
                        }
                    }

                    Human.view.tooltips.setTooltip({
                        objectId: object.objectId,
                        canvasX: canvasX, canvasY: canvasY,
                        title: tootipTitle
                    });
     
                    Human.events.fire("pick.hoverPicked", event);
                    Human.events.fire("pick.picked", event);
                }
            }
            return;
        }

        // Highlight or XRay mode
        // but do nothing for pick in these modes if in Dissect mode
        if ((Human.view.highlight.enabled || Human.view.xray.enabled) &&
            !Human.view.dissect.enabled &&
            !Human.view.annotations.enabled) {

            hit = Human.renderer.pick(canvasX, canvasY, rayPick, regionPick);

            if (hit) {

                object = findNamedObject(hit.name);
                if (object) {
                    if (doubleClick) {
                        // Scene object double-clicked
                        Human.view.focus.focusObject({
                            objectId: object.objectId,
                            replace: HumanViewPick.singleEnabled,
                            showLabel: true,
                            select: true,
                            flyTo: "selectedLeafObjects"
                        });
                        return;
                    }

                    Human.view.annotations.setLabelsShown({
                        objects: {},
                        type: "secondary",
                        replace: true
                    });
                    if (spaceDown) {
                        // SPACE key down
                        objects = {};
                        objects[object.objectId] = true;
                        Human.view.annotations.setLabelsShown({
                            objects: objects,
                            type: "secondary"
                        });
                        return;
                    }

                    if (ctrlDown) {
                        // ALT key down
                        objects = {};
                        objects[object.objectId] = false;
                        Human.view.annotations.setLabelsShown({
                            objects: objects,
                            type: "secondary"
                        });
                        return;
                    }

                    // Scene object picked
                    if (Human.scene.selectedObjects[object.objectId]) {
                        // Object deselected
                        Human.scene.setSelectedObjects({
                            objectId: object.objectId,
                            select: !Human.scene.selectedObjects[object.objectId], // Deselect if currently selected
                            replace: !HumanViewPick.multiEnabled
                        });
                    } else {
                        // Object selected
                        Human.view.focus.focusObject({
                            objectId: object.objectId,
                            showLabel: true,
                            replace: !HumanViewPick.multiEnabled,
                            flyTo: "none"
                        });
                        // Show tooltip
                        Human.view.tooltips.setTooltip({
                            objectId: object.objectId,
                            canvasX: canvasX,
                            canvasY: canvasY
                        });
                    }
                    Human.events.fire("pick.picked",
                        Human.utils.apply(hit, {
                            mode: Human.view.highlight.enabled ? "highlight" : "xray",
                            objectId: object.objectId,
                            mouseDownLeft: mouseDownLeft,
                            mouseDownRight: mouseDownRight
                        }));
                } else {
                    annotation = Human.view.annotations.annotations[hit.name];
                    if (annotation) {
                        // Annotation pin picked
                        annotation.pin.pick();
                    }
                }
            } else if (doubleClick) {

                // Pick nothing - clear object selection
                // But not in X-Ray mode, because we don't clear selection
                // in that mode when clicking empty canvas.

                if (!Human.view.xray.enabled) {
                    Human.scene.setSelectedObjects({
                        select: false,
                        replace: true
                    });
                }
            }
        }

        // Isolation mode
        if (Human.view.isolate.enabled &&
            !Human.view.dissect.enabled &&
            !Human.view.annotations.enabled) {
            
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {
                    if (doubleClick) {
                        // Scene object double-clicked
                        Human.view.focus.focusObject({
                            objectId: object.objectId,
                            showLabel: true,
                            select: false,
                            flyTo: "object"
                        });
                        return;
                    }

                    // Object selected
                    Human.view.focus.focusObject({
                        objectId: object.objectId,
                        showLabel: true,
                        select: false,
                        flyTo: "none"
                    });
                    // Show tooltip
                    Human.view.tooltips.setTooltip({
                        objectId: object.objectId,
                        canvasX: canvasX,
                        canvasY: canvasY
                    });
                    Human.events.fire("pick.picked",
                        Human.utils.apply(hit, {
                            mode: "isolate",
                            objectId: object.objectId
                        }));
                }
            }
        }

        // Dissection mode
        if (Human.view.dissect.enabled && !Human.view.annotations.enabled) {
            if (doubleClick) {
                return;
            }
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {
                    Human.view.dissect.dissect(object.objectId);
                    Human.events.fire("pick.picked",
                        Human.utils.apply(hit, {
                            mode: "dissect",
                            objectId: object.objectId
                        }));
                }
            }
            return;
        }

        // Annotation mode
        if (Human.view.annotations.enabled) {

            if (doubleClick) {
                return;
            }

            rayPick = true; // Find 3D pick point

            hit = Human.renderer.pick(canvasX, canvasY, rayPick);

            if (hit) {

                var objectId = hit.name;

                object = Human.scene.objects[objectId];

                if (object) {

                    //// Create an annotation on the object that was picked
                    //
                    //Human.view.annotations.placer.placeAnnotation({
                    //    objectId: object.objectId,
                    //    pos: hit.worldPos
                    //});
                    //
                    //// Fire a "pick.picked" event for the first object on the path
                    //// up to the root that has an explicitely-set object ID,
                    //// as opposed to one that was auto-generated by Human.
                    ////
                    //var namedObject = findNamedObject(objectId);
                    //
                    //if (!namedObject) {
                    //    return;
                    //}
                    //
                    //Human.view.tooltips.setTooltip({
                    //    objectId: namedObject.objectId,
                    //    canvasX: canvasX,
                    //    canvasY: canvasY
                    //});
                    //
                    //Human.events.fire("pick.picked",
                    //    Human.utils.apply(hit, {
                    //        mode: "annotation",
                    //        objectId: namedObject.objectId
                    //    }));

                } else {

                    annotation = Human.view.annotations.annotations[hit.name];

                    if (annotation) {
                        // Annotation pin picked
                        annotation.pin.pick();
                    }
                }
            }
            return;
        }
    };

    // Given an object ID, find the first object on path to root, including that object,
    // that was given an explicit ID, as opposed to one that was internally generated for the object.
    function findNamedObject(objectId) {
        var object = Human.scene.objects[objectId];
        while (object && object.anonymous) {
            object = object.parent;
        }
        return object;
    }
})();
;/** @namespace Grabs JPEG canvas snapshots
 */
(function () {
    "use strict";

    var HumanViewSnapshot = Human.view.snapshot = {};

    // Property to select MIME type for snapshot images
    var mimeType;

    Human.properties.subscribe({
        propId: "snapshot.mime",
        value: "image/jpeg",
        callback: function (value) {
            mimeType = value;
        }
    });

    var canvasId = "theCanvas";
    var copyrightImagePath = "img/bhuman-logo-powered.png";
    var copyrightImage = new Image();
    var copyrightImageDimensions = { width: 0, height: 0 };
    copyrightImage.onload = function () {
        copyrightImageDimensions.width = copyrightImage.width;
        copyrightImageDimensions.height = copyrightImage.height;
    };
    var queue = []; // Snapshots cannot be taken asynch, so we queue them

    // init copyright logo
    copyrightImage.src = copyrightImagePath;

    /**
    * Grabs a JPEG snapshot of the 3D view.
    *
    * <p>Snapshot requests are queued, so this may be called while other snapshots are still in progress.</p>
    *
    * @memberof Human.view.snapshot
    * @param {*} params
    * @param {Number} params.width Optional snapshot width
    * @param {Number} params.height Optional snapshot height
    * @param {Boolean} params.openInTab Image opened in new tab when true
    * @param {Function} ok Optional method to returns snapshot image
    * @param {Function} error Optional callback to return error message
    */
    HumanViewSnapshot.getSnapshot = function (params, ok, error) {
        if (params.width !== undefined || params.height !== undefined) {
            if (params.width === undefined || params.height === undefined) {
                var msg = "Snapshot failed: incomplete params: both 'width' and 'height' expected";
                if (error) {
                    error(msg);
                    //TODO: IS THIS A BUG? SHOULDN'T FUNCTION RETURN IF ERROR?
                }
            }
        }
        queue.unshift({ params: params, ok: ok });
        nextSnapshot();
    };

    function nextSnapshot() {
        if (queue.length === 0) {
            return;
        }
        var snapshot = queue.pop();
        var params = snapshot.params;
        var ok = snapshot.ok;
        doSnapshot(params,
            function (image) {
                if (params.openInTab) {
                    window.open(image.src, "_blank");
                }
                if (ok) {
                    ok(image);
                }
                nextSnapshot();
            });
    }

    function doSnapshot(params, ok) {
        Human.events.fire("snapshot.started");
        params = params || {};
        var theCanvas = document.getElementById(canvasId);
        var copyright = (params.copyright !== undefined && params.copyright !== null) ? params.copyright : true;
        // scale, unless turned off
        var scale = params.scale !== false;
        // get current canvas dimensions
        var dimensions = getCanvasDimentions(theCanvas);
        var width = dimensions.width;
        var height = dimensions.height;
        // get target snapshot dimensions
        var targetWidth = params.width || width;
        var targetHeight = params.height || height;
        // aspect fix?
        if (targetWidth >= targetHeight) {
            targetHeight = Math.floor(height / width * targetWidth);
        }
        else if (targetWidth < targetHeight) {
            targetWidth = Math.floor(width / height * targetHeight);
        }
        // scaling
        var adjustCanvasScaling = !scale && targetWidth > width || targetHeight > height;
        // color options
        var color = params.color || Human.renderer.bg.bgColor;
        var currentColor = Human.renderer.bg.bgColor; //store current color

        // resize canvas
        if (adjustCanvasScaling) {
            theCanvas.width = targetWidth;
            theCanvas.height = targetHeight;
        }
        // adjust color
        if (color) {
            Human.renderer.bg.setBGColor(color);
        }

        var wasPlaying = false;

        if (Human.timeline.playing) {
            wasPlaying = true;
            Human.timeline.pause();
        }

        Human.renderer.forceRenderFrame();

        // create output canvas
        var outputCanvas = document.createElement("canvas");
        var outputCanvasContext = outputCanvas.getContext("2d");
        outputCanvas.width = targetWidth;
        outputCanvas.height = targetHeight;

        var theCanvasDimensions = getCanvasDimentions(theCanvas);
        var canvasWidth = theCanvasDimensions.width;
        var canvasHeight = theCanvasDimensions.height;
        // TODO: cropping
        // write canvas

        var bgColor = Human.renderer.bg.bgColors[Human.renderer.bg.bgColor];

        // We'll just to a vertical gradient to begin with
        // and sample just the top-left and bottom-right colors

        var topLeft = bgColor.slice(0, 3);
        var bottomLeft = bgColor.slice(9, 12);

        var rGrad = outputCanvasContext.createLinearGradient(0, 0, 0, outputCanvas.height);
        rGrad.addColorStop(0, cssRGB(topLeft));
        rGrad.addColorStop(1, cssRGB(bottomLeft));
        outputCanvasContext.fillStyle = rGrad;
        outputCanvasContext.fillRect(0,0, outputCanvas.width, outputCanvas.height);

        outputCanvasContext.drawImage(theCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, targetWidth, targetHeight);

        // write copyright: bottom center
        if (copyright) {
            // write watermark
            var watermarkX = Math.max(15, (targetWidth / 2) - (copyrightImageDimensions.width / 2));
            var watermarkY = Math.max(15, targetHeight - 20 - copyrightImageDimensions.height);

            outputCanvasContext.drawImage(copyrightImage, watermarkX, watermarkY);

            // write copy text
            outputCanvasContext.font = "12pt Arial";
            var copyYear = new Date().getFullYear();
            var copysymbol = String.fromCharCode(169);
            var text = copysymbol + " " + copyYear;
            var textX = targetWidth / 2;
            var textY = watermarkY + copyrightImageDimensions.height + 10;
            outputCanvasContext.fillStyle = "#666666";
            outputCanvasContext.textAlign = 'center';

            outputCanvasContext.fillText(text, textX, textY);
        }

        // Let other engine code modules draw their bits to
        // the snapshot, eg. annotations.
        Human.events.fire("snapshot.rendering", { canvas: outputCanvas, context: outputCanvasContext, bgColor: color });

        // post-render cleanup
        // restore canvas
        if (adjustCanvasScaling) {
            theCanvas.width = width;
            theCanvas.height = height;
        }
        // restore color
        if (color) {
            Human.renderer.bg.setBGColor(currentColor);
        }
        Human.renderer.forceRenderFrame();

        if (wasPlaying) {
            Human.timeline.unpause();
        }

        Human.events.fire("snapshot.finished");

        // get output image
        var outputImage = new Image();
        outputImage.width = targetWidth;
        outputImage.height = targetHeight;
        outputImage.onload = function () {
            // publish snapshot
            ok(outputImage);
        };
        outputImage.src = outputCanvas.toDataURL(mimeType);
    }

    function cssRGB(arr) {
        return "rgb(" + Math.round(arr[0] * 255) + ", " + Math.round(arr[1] * 255) + ", " + Math.round(arr[2] * 255) + ")";
    }

    function getCanvasDimentions(canvas) {
        var RADIX = 10;
        return {
            width: parseInt(canvas.getAttribute("width"), RADIX),
            height: parseInt(canvas.getAttribute("height"), RADIX)
        };
    }

})();
;/**
 * @namespace Manages clip planes for cross-section views
 */
(function () {
    "use strict";

    var HumanViewClip = Human.view.clip = {};

    HumanViewClip.LEFT = "left";
    HumanViewClip.RIGHT = "right";
    HumanViewClip.TOP = "top";
    HumanViewClip.BOTTOM = "bottom";
    HumanViewClip.FRONT = "front";
    HumanViewClip.BACK = "back";

    var ready = false;
    var enabled = false;

    var clipsNode;

    // True whenever scene objects have been selected or deselected
    var objectSelectionDirty;

    // Boundary and center of currently-visible objects
    var sceneBoundary;

    // True whenever scene objects have shown or hidden
    var sceneBoundaryDirty = true;

    // True while SceneJS clips node is active
    var active = false;

    HumanViewClip.clips = {};

    HumanViewClip.selectedClip = null;

    Human.events.on(
        "loaded",
        function () {
            enabled = false;

            var libraryNode = Human.renderer.getNode("assetLibraryRoot");
            if (!libraryNode) {
                Human.log.error("Human.view.clip.createClipsNode", "Scene node not found: 'assetlibraryRoot'");
                return;
            }

            clipsNode = libraryNode.addNode({
                type: "clips",
                clips: [
                    {mode: "disabled", x: -1.0, y: 0.0, z: 0.0}, // left
                    {mode: "disabled", x: 1.0, y: 0.0, z: 0.0}, // right
                    {mode: "disabled", x: 0.0, y: -1.0, z: 0.0}, // bottom
                    {mode: "disabled", x: 0.0, y: 1.0, z: 0.0}, // top
                    {mode: "disabled", x: 0.0, y: 0.0, z: -1.0}, // front
                    {mode: "disabled", x: 0.0, y: 0.0, z: 1.0} // back
                ]
            });

            // Create clipping planes

            createClip({
                index: 0,
                type: HumanViewClip.LEFT,
                clipId: HumanViewClip.LEFT
            });

            createClip({
                index: 1,
                type: HumanViewClip.RIGHT,
                clipId: HumanViewClip.RIGHT
            });

            createClip({
                index: 2,
                type: HumanViewClip.TOP,
                clipId: HumanViewClip.TOP
            });

            createClip({
                index: 3,
                type: HumanViewClip.BOTTOM,
                clipId: HumanViewClip.BOTTOM
            });

            createClip({
                index: 4,
                type: HumanViewClip.FRONT,
                clipId: HumanViewClip.FRONT
            });

            createClip({
                index: 5,
                type: HumanViewClip.BACK,
                clipId: HumanViewClip.BACK
            });

            // Updates are sent to front plane by default
            HumanViewClip.selectClip("front");

        });

    function createClip(params) {

        params.onUpdate = function (clip) {
            HumanViewClip._onUpdate(clip);
        };

        HumanViewClip.clips[params.clipId] = new Human.view.clip.Plane(params);
    }

    HumanViewClip._onUpdate = function (clip) {
        var clips = {};
        clips["" + clip.index] = {
            x: clip.x,
            y: clip.y,
            z: clip.z,
            dist: clip.dist,
            mode: clip.clipping ? "inside" : "disabled"
        };
        clipsNode.setClips(clips);
    };

    Human.events.on(
        "tick",
        function () {
            if (objectSelectionDirty) {
                HumanViewClip._updateClipForIsolatedObjects();
                objectSelectionDirty = false;
            }

        });

    // Toggle clipability of currently selected objects
    HumanViewClip._updateClipForIsolatedObjects = function () {
        var objects = Human.scene.objects;
        var selectedObjects = Human.scene.selectedObjects;

        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                objects[objectId].setClippable(!!selectedObjects[objectId] ? false : true);
            }
        }
    };

    // Hide visible clip planes again whenever the renderer goes back to sleep
    Human.events.on(
        "Scene.Sleep",
        function () {
            var plane;
            for (var clipId in HumanViewClip.clips) {
                if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                    plane = HumanViewClip.clips[clipId];
                    if (plane.state === Human.view.clip.Plane.STATE_VISIBLE) {
                        if (plane.framesUntilHide > 0) {
                            plane.framesUntilHide--;
                        } else {
                            Human.view.clip.setClip({
                                clipId: plane.clipId,
                                state: Human.view.clip.Plane.STATE_CLIPPING
                            });
                        }
                    }
                }

            }
        });

    Human.events.on(
        "scene.objectsSelected",
        function () {
            objectSelectionDirty = true;
        });

    Human.events.on(
        "scene.objectsShown",
        function () {
            sceneBoundaryDirty = true;
            for (var clipId in HumanViewClip.clips) {
                if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                    var clip = HumanViewClip.clips[clipId];
                    if (clip.state !== Human.view.clip.Plane.STATE_DORMANT) {
                        HumanViewClip._configureClip(clip);
                    }
                }
            }
        });

    /**
     * Update state of a clipping plane.
     */
    HumanViewClip.setClip = function (params) {
        var clip;
        if (!params.clipId) {
            if (HumanViewClip.selectedClip) {
                clip = HumanViewClip.selectedClip;
            } else {
                Human.log.error("Human.view.clip.setClip", "Parameter expected: 'clipId'");
                return;
            }
        } else {
            clip = HumanViewClip.clips[params.clipId];
            if (!clip) {
                Human.log.error("Human.view.clip.setClip", "Clip plane not found: '" + params.clipId + "'");
                return;
            }
        }

        if (params.state &&
            params.state !== Human.view.clip.Plane.STATE_DORMANT &&
            params.state !== Human.view.clip.Plane.STATE_ACTIVE &&
            params.state !== Human.view.clip.Plane.STATE_CLIPPING &&
            params.state !== Human.view.clip.Plane.STATE_VISIBLE) {
            Human.log.error("Human.view.clip.setClip", "State not recognized: '" + params.state + "'");
            return;
        }

        var oldState = clip.state;
        var newState = params.state || oldState;

        switch (newState) {
            case Human.view.clip.Plane.STATE_DORMANT:

                clip._setClipping(false);
                clip._setVisible(false);

                break;

            case Human.view.clip.Plane.STATE_ACTIVE:

                HumanViewClip._configureClip(clip, params);

                clip._setClipping(false);
                clip._setVisible(false);

                break;

            case Human.view.clip.Plane.STATE_CLIPPING:

                clip._setClipping(true);
                clip._setVisible(false);

                switch (oldState) {
                    case Human.view.clip.Plane.STATE_DORMANT:
                        HumanViewClip._configureClip(clip, params);
                        break;

                    default:
                        if (params.progress) {
                            clip._setProgress(params.progress);
                        }
                }
                break;

            case Human.view.clip.Plane.STATE_VISIBLE:

                clip._setClipping(true);
                clip._setVisible(true);

                switch (oldState) {
                    case Human.view.clip.Plane.STATE_DORMANT:
                        HumanViewClip._configureClip(clip, params);
                        break;

                    default:
                        if (params.progress) {
                            clip._setProgress(params.progress);
                        }
                }
                break;
        }

        clip.state = newState;

        // Notify of new clip plane state
        Human.events.fire("clip.updated", {
            clipId: clip.clipId,
            state: clip.state, // "dormant", "active", "clipping", "visible"
            progress: clip.progress // "left", "right", "top", "bottom", "front", "back"
        });

        // Activate clips node only if clipping is now visibly in effect
        // otherwise disable it
        activateClipsIfNeeded();
    };

    HumanViewClip._configureClip = function (clip, params) {

        params = params || {};

        //  if (!params.pos) {

        if (sceneBoundaryDirty) {
            sceneBoundary = Human.scene.getBoundary({
                objects: Human.scene.enabledObjects
            });
            sceneBoundaryDirty = false;
        }
        //  }


        var xCenter = (sceneBoundary.xmin + sceneBoundary.xmax) * 0.5;
        var yCenter = (sceneBoundary.ymin + sceneBoundary.ymax) * 0.5;
        var zCenter = (sceneBoundary.zmin + sceneBoundary.zmax) * 0.5;

        var pos;
        var dir;
        var size;
        var range;

        switch (clip.type) {

            case HumanViewClip.LEFT:

                pos = {
                    x: sceneBoundary.xmax,
                    y: yCenter,
                    z: zCenter
                };
                dir = {
                    y: 1,
                    angle: -90.0
                };
                size = {
                    x: (sceneBoundary.zmax - sceneBoundary.zmin),
                    y: (sceneBoundary.ymax - sceneBoundary.ymin)
                };
                range = {
                    min: sceneBoundary.xmin,
                    max: sceneBoundary.xmax
                };
                break;

            case HumanViewClip.RIGHT:

                pos = {
                    x: sceneBoundary.xmin,
                    y: yCenter,
                    z: zCenter
                };
                dir = {
                    y: 1,
                    angle: 90.0
                };
                size = {
                    x: (sceneBoundary.zmax - sceneBoundary.zmin),
                    y: (sceneBoundary.ymax - sceneBoundary.ymin)
                };
                range = {
                    min: sceneBoundary.xmin,
                    max: sceneBoundary.xmax
                };
                break;

            case HumanViewClip.FRONT:

                pos = {
                    x: xCenter,
                    y: yCenter,
                    z: sceneBoundary.zmin
                };
                dir = {
                    y: 1,
                    angle: 0.0
                };
                size = {
                    x: (sceneBoundary.xmax - sceneBoundary.xmin),
                    y: (sceneBoundary.ymax - sceneBoundary.ymin)
                };
                range = {
                    min: sceneBoundary.zmin,
                    max: sceneBoundary.zmax
                };
                break;

            case HumanViewClip.BACK:

                pos = {
                    x: -xCenter,
                    y: yCenter,
                    z: sceneBoundary.zmax
                };
                dir = {
                    y: 1,
                    angle: 180.0
                };
                size = {
                    x: (sceneBoundary.xmax - sceneBoundary.xmin),
                    y: (sceneBoundary.ymax - sceneBoundary.ymin)
                };
                range = {
                    min: sceneBoundary.zmin,
                    max: sceneBoundary.zmax
                };
                break;

            case HumanViewClip.TOP:

                pos = {
                    x: xCenter,
                    y: sceneBoundary.ymax,
                    z: zCenter
                };
                dir = {
                    x: 1,
                    angle: 90.0
                };
                size = {
                    x: (sceneBoundary.xmax - sceneBoundary.xmin),
                    y: (sceneBoundary.zmax - sceneBoundary.zmin)
                };
                range = {
                    min: sceneBoundary.ymin,
                    max: sceneBoundary.ymax
                };
                break;

            case HumanViewClip.BOTTOM:

                pos = {
                    x: xCenter,
                    y: sceneBoundary.ymin,
                    z: zCenter
                };
                dir = {
                    x: 1,
                    angle: -90.0
                };
                size = {
                    x: (sceneBoundary.xmax - sceneBoundary.xmin),
                    y: (sceneBoundary.zmax - sceneBoundary.zmin)
                };
                range = {
                    min: sceneBoundary.ymin,
                    max: sceneBoundary.ymax
                };
                break;

            default:

                // TODO: Align to vectored position on sphere when no pos given

                pos = params.pos;
                dir = params.dir;
                size = params.size;
                range = params.range;
                break;
        }

        clip._setPos(pos);
        clip._setDir(dir);
        clip._setRange(range);
        clip._setSize(size);
        
        if (params.progress !== undefined) {
            clip._setProgress(params.progress);
        }

    };

    // Activates the clips node if any clip planes are in effect, otherwise deactivates it
    function activateClipsIfNeeded() {
        var plane;
        for (var clipId in HumanViewClip.clips) {
            if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                plane = HumanViewClip.clips[clipId];
                if (plane.state !== Human.view.clip.Plane.STATE_DORMANT && plane.progress !== 0) {
                    activateClipsNode();
                    return;
                }
            }
        }
        deactivateClipsNode();
    }

    // Moves the clips node from the dormant "library" part of the scene graph
    // into the "live" part so that it then clips the 3D scene
    function activateClipsNode() {

        // Human.log.info("activating");

        if (active) {
            return;
        }

        // Insert clips node above content root
        var contentRootNode = Human.renderer.getNode("clips");
        var parent = contentRootNode.parent;
        var children = parent.disconnectNodes();
        clipsNode.disconnect();
        clipsNode.addNodes(children);
        parent.addNode(clipsNode);

        active = true;

        Human.events.fire("clips.activated");
    }

    // Moves the clips node from the "live" part of the scene graph
    // back into the dormant "library" part so that it then no longer clips the 3D scene
    function deactivateClipsNode() {

        if (!active) {
            return;
        }

        // Extract clips node from scene graph,
        // moving its children up to its parent
        clipsNode.splice();

        // Insert clips node into scene graph's library subgraph
        var libraryNode = Human.renderer.getNode("assetLibraryRoot");

        if (!libraryNode) {
            Human.log.error("Human.view.clip.deactivateClipsNode", "Scene node not found: 'assetlibraryRoot'");
            return;
        }

        libraryNode.addNode(clipsNode);

        active = false;

        Human.events.fire("clips.deactivated");
    }

    /**
     * Selects a clip as the default fallback for setClip.
     * Call with null to stop using the clip plane.
     */
    HumanViewClip.selectClip = function (clipId) {
        var clip;
        if (clipId) {
            clip = HumanViewClip.clips[clipId];
            if (!clip) {
                Human.log.error("Human.view.clip.selectClip", "Clip plane not found: '" + clipId + "'");
                return;
            }
        }
        HumanViewClip.selectedClip = clip;
    };

    /**
     * Reset cross-sections to dormant state
     */
    HumanViewClip.reset = function () {
        var clip;
        for (var clipId in HumanViewClip.clips) {
            if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                clip = HumanViewClip.clips[clipId];
                HumanViewClip.setClip({
                    clipId: clip.clipId,
                    state: Human.view.clip.Plane.STATE_DORMANT
                });
                HumanViewClip._configureClip(clip); // Reset clips' position, dir, progress etc
            }
        }

        if (ready) {
            HumanViewClip.selectClip("front");
        }

        Human.events.fire("CrossSections.Reset");
    };
})();;(function () {
    // jshint camelcase: false, newcap: false
    // ^ Have to turn these off because of SceneJS variables.

    "use strict";

    // Cached transform matrices

    var indicatorMat = Human.math.mat4(); // Transforms indicator plane
    var clipMat = Human.math.mat4(); // Transforms SceneJS clipping planes

    Human.view.clip.Plane = function (cfg) {

        this.index = cfg.index;

        this.clipId = cfg.clipId;
        this.type = cfg.type;
        this.state = Human.view.clip.Plane.STATE_DORMANT;
        this.framesUntilHide = 1;  // Number of SLEEPS this frame is allowed to remain in STATE_VISIBLE

        // Position of center of clipping plane
        var pos = cfg.pos || {};
        this.pos = {
            x: pos.x || 0.0,
            y: pos.y || 0.0,
            z: pos.z || 0.0
        };

        // vector indicating direction of clipping plane
        var dir = cfg.dir || {};
        this.dir = {
            x: dir.x || 0.0,
            y: dir.y || 0.0,
            z: dir.z || 0.0,
            angle: dir.angle || 0.0
        };

        // Width and height of clipping plane indicator
        var size = cfg.size || {};
        this.size = {
            x: size.x || 10.0,
            y: size.y || 10.0
        };

        // Range of movement of clipping plane
        var range = cfg.range || {};
        this.range = {
            min: range.min || 0.0,
            max: range.max || 0.0
        };

        // Factor in range [0..1] indicating progress of clipping plane within its movement range
        this.progress = 0;

        // SceneJS node IDs
        var indicatorFlagsId = cfg.clipId + ".indicator.flags";
        var indicatorXFormId = cfg.clipId + ".indicator.xf";

        // True when clipping plane indicator is visible
        this.visible = cfg.visible || false;

        // True when clipping plane is clipping
        this.clipping = cfg.clipping || false;

        this._onUpdate = cfg.onUpdate;

        // Build SceneJS subgraph for clip plane indicator
        Human.renderer.getNode(Human.CLIP_INDICATORS_ATTACH_ID).addNode({
            type: "flags",
            id: indicatorFlagsId,

            flags: {
                enabled: this.visible,
                //enabled: true,
                transparent: true,
                backfaces: true,
                clipping: false,
                picking: false
            },

            nodes: [
                {
                    type: "xform",
                    id: indicatorXFormId,

                    nodes: [

                        // Solid plane inner
                        {
                            type: "material",
                            emit: 0.9,
                            baseColor: {r: 0.3, g: 0.3, b: 0.4},
                            specularColor: {r: 0.3, g: 0.3, b: 0.4},
                            specular: 0.0,
                            shine: 100.0,
                            alpha: 0.2,

                            nodes: [
                                {
                                    type: "geometry/plane",
                                    width: 2.0,
                                    height: 2.0
                                }
                            ]
                        },

                        // Plane outline
                        {
                            type: "material",
                            emit: 0.9,
                            baseColor: {r: 0.3, g: 0.3, b: 0.4},
                            specularColor: {r: 0.3, g: 0.3, b: 0.4},
                            specular: 0.0,
                            shine: 100,
                            alpha: 0.9,

                            nodes: [
                                {
                                    type: "geometry",
                                    primitive: "lines",
                                    positions: [
                                        1.0, 1.0, 1.0,
                                        1.0, -1.0, 1.0,
                                        -1.0, -1.0, 1.0,
                                        -1.0, 1.0, 1.0,
                                        1.0, 1.0, -1.0,
                                        1.0, -1.0, -1.0,
                                        -1.0, -1.0, -1.0,
                                        -1.0, 1.0, -1.0
                                    ],
                                    indices: [0, 1, 1, 2, 2, 3, 3, 0]
                                }
                            ]
                        }
                    ]
                }
            ]
        });

        this.indicatorFlagsNode = Human.renderer.getNode(indicatorFlagsId);
        this.indicatorXFormNode = Human.renderer.getNode(indicatorXFormId);

        this._updatePosition();
    };

    Human.view.clip.Plane.prototype._updatePosition = function () {

        Human.math.identityMat4(indicatorMat);

        var move = (this.progress * (this.range.max - this.range.min));
        var pos = [this.pos.x, this.pos.y, this.pos.z];

        switch (this.type) {
            case Human.view.clip.BACK:
                pos[2] = this.range.max - move;
                break;
            case Human.view.clip.FRONT:
                pos[2] = this.range.min + move;
                break;
            case Human.view.clip.LEFT:
                pos[0] = this.range.max - move;
                break;
            case Human.view.clip.RIGHT:
                pos[0] = this.range.min + move;
                break;
            case Human.view.clip.TOP:
                pos[1] = this.range.max - move;
                break;
            case Human.view.clip.BOTTOM:
                pos[1] = this.range.min + move;
                break;
        }

        Human.math.mulMat4(indicatorMat, Human.math.translationMat4v(pos), indicatorMat);
        Human.math.mulMat4(indicatorMat, Human.math.rotationMat4v(this.dir.angle * Math.PI / 180.0, [this.dir.x, this.dir.y, this.dir.z]), indicatorMat);
        Human.math.mulMat4(indicatorMat, Human.math.scalingMat4v([this.size.x * 0.5, this.size.y * 0.5, 0]), indicatorMat);

        this.indicatorXFormNode.setElements(indicatorMat);

        Human.math.identityMat4(clipMat);

        Human.math.mulMat4(clipMat, Human.math.translationMat4v(pos), clipMat);
        Human.math.mulMat4(clipMat, Human.math.rotationMat4v(this.dir.angle * Math.PI / 180.0, [this.dir.x, this.dir.y, this.dir.z]), clipMat);
        Human.math.mulMat4(clipMat, Human.math.scalingMat4v([this.size.x * 0.5, this.size.y * 0.5, 0]), clipMat);

        var a = SceneJS_math_transformPoint3(clipMat, [-1, -1, 0]);
        var b = SceneJS_math_transformPoint3(clipMat, [1, -1, 0]);
        var c = SceneJS_math_transformPoint3(clipMat, [1, 1, 0]);

        var normal = SceneJS_math_normalizeVec3(
            SceneJS_math_cross3Vec4(
                SceneJS_math_normalizeVec3(
                    SceneJS_math_subVec3(b, a, [0, 0, 0]), [0, 0, 0]),
                SceneJS_math_normalizeVec3(
                    SceneJS_math_subVec3(b, c, [0, 0, 0]), [0, 0, 0])));

        var dist = SceneJS_math_dotVector3(normal, a);

        this.x = normal[0];
        this.y = normal[1];
        this.z = normal[2];
        this.dist = dist;

        this._onUpdate(this);
    };

    /** States a Plane can be in
     */
    Human.view.clip.Plane.STATE_DORMANT = "dormant";    // Existing but not associated with selected objects
    Human.view.clip.Plane.STATE_ACTIVE = "active";      // Associated with selected objects but not clipping them
    Human.view.clip.Plane.STATE_CLIPPING = "clipping";  // Clipping the selected objects
    Human.view.clip.Plane.STATE_VISIBLE = "visible";    // Clipping and visible

    /**
     * Updates the position of this clipping plane.
     * Called from Human.view.Clip
     */
    Human.view.clip.Plane.prototype._setPos = function (pos) {
        pos = pos || {};
        this.pos = {
            x: pos.x || 0.0,
            y: pos.y || 0.0,
            z: pos.z || 0.0
        };
        this._updatePosition();
    };

    /**
     * Updates the direction of this clipping plane.
     * Called from Human.view.Clip
     */
    Human.view.clip.Plane.prototype._setDir = function (dir) {
        dir = dir || {};
        this.dir = {
            x: dir.x || 0.0,
            y: dir.y || 0.0,
            z: dir.z || 0.0,
            angle: dir.angle || 0.0
        };
        this._updatePosition();
    };

    /**
     * Updates the range of movement of this clipping plane.
     * Called from Human.view.Clip
     */
    Human.view.clip.Plane.prototype._setRange = function (range) {
        range = range || {};
        this.range = {
            min: range.min || 0.0,
            max: range.max || 0.0
        };
        this._updatePosition();
    };

    /** Updates the progress of this clipping plane
     * Called from Human.view.Clip
     * @param progress Factor in range [0..1]
     */
    Human.view.clip.Plane.prototype._setProgress = function (progress) {
        if (this.progress === progress) {
            return;
        }
        if (progress < 0.0) {
            progress = 0.0;
            this._setClipping(false);
        } else if (progress > 1.0) {
            progress = 1.0;
            this._setClipping(false);
        } else {
            this._setClipping(true);
        }
        this.progress = progress;
        this._updatePosition();
    };

    /** Width and height of indicator for this clipping plane
     * Called from Human.view.Clip
     * @param size
     */
    Human.view.clip.Plane.prototype._setSize = function (size) {
        size = size || {};
        this.size = {
            x: size.x || 10.0,
            y: size.y || 10.0
        };
        this._updatePosition();
    };

    /** Shows of hides the indicator for this clipping plane
     * Called from Human.view.Clip
     * @param visible
     */
    Human.view.clip.Plane.prototype._setVisible = function (visible) {
        this.framesUntilHide = visible ? 1 : 0;
        if (this.visible === visible) {
            return;
        }
        var flags = this.indicatorFlagsNode.getFlags();
        flags.enabled = visible;
        this.indicatorFlagsNode.setFlags(flags);
        this.visible = visible;
    };

    /** Sets the mode for this clipping plane
     * Called from Human.view.Clip
     * @param mode
     */
    Human.view.clip.Plane.prototype._setMode = function (mode) {
        if (this.mode === mode) {
            return;
        }
        this.mode = mode;
        this._onUpdate(this);
    };

    /** Sets whether or not this clipping plane is clipping
     * Called from Human.view.Clip
     * @param clipping
     */
    Human.view.clip.Plane.prototype._setClipping = function (clipping) {
        if (this.clipping === clipping) {
            return;
        }
        this.clipping = clipping;
        this._onUpdate(this);
    };

})();

;/**

 @namespace Dynamic lighting support

 <p>Usage:</p>

 <pre>

 // Add some lights

 Human.view.lights.addLight({
                lightId: "light0",
                displayName: "Default ambient",
                description: "Default ambient light source",
                params: {
                    mode: "ambient",
                    color: { r: 0.15, g: 0.15, b: 0.15 },
                    diffuse: true
                }
            });

 Human.view.lights.addLight({
                lightId: "light1",
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 0.15, g: 0.15, b: 0.2 },
                    dir: { x: -0.3, y: 0.4, z: 0.5 },
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

 Human.view.lights.addLight({
                lightId: "light2",
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "point",
                    color: { r: 1.3, g: 1.3, b: 1.2 },
                    pos: { x: -1.0, y: 0.0, z: 1.0},
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

 // Enable and disable lights in a batch

 Human.view.lights.setEnabled({
        lights: {
            "light0": true,
            "light1": true,
            "light2": false
        },
        replace: true // Disable all previously active lights
 });

 // Set light parameters in a batch

 Human.view.lights.setParams({
        "light0": {
            dir: { x: 0.2, y: 0.1, z: -0.2
        },
        "light2": {
            pos: { x: 0, y: 10, z: -20,
            color: { r: .9, g: 0.2, b: 1.0 }
        }
    });

 // Remove a light

 Human.view.lights.removeLight("light0");

 </pre>
 */
(function () {
    "use strict";

    var HumanViewLights = Human.view.lights = {};

    /**
     * Lights mapped to their IDs
     *
     * @type {{String:Human.view.lights.Light}}
     */
    HumanViewLights.lights = {};

    /**
     * Default lights should be stored for re-enabling after custom
     * lights are disabled.
    */
    HumanViewLights.defaultLightIds = [];

    // True when lights in the scene graph need to be rebuilt
    var dirty = false;

    // Create default lights once engine code has loaded, all enabled
    Human.events.on("loaded",
        function () {

            // Need one ambient light
            HumanViewLights.addLight({
                lightId: "light0",
                enabled: true,
                displayName: "Default ambient",
                description: "Default ambient light source",
                params: {
                    mode: "ambient",
                    color: { r: 0.15, g: 0.15, b: 0.15 },
                    diffuse: true
                }
            });
            HumanViewLights.defaultLightIds.push('light0');



            HumanViewLights.addLight({
                lightId: "light2",
                enabled: true,
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 1.3, g: 1.3, b: 1.2 },
                    dir: { x: -1.0, y: 0.0, z: 1.0},
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });
            HumanViewLights.defaultLightIds.push('light2');

            HumanViewLights.addLight({
                lightId: "light3",
                enabled: true,
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 0.5, g: 0.5, b: 0.5 },
                    dir: { x: 1.1, y: 0, z: 1},
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });
            HumanViewLights.defaultLightIds.push('light3');

            HumanViewLights.addLight({
                lightId: "light4",
                enabled: true,
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 1.1, g: 1.1, b: 1.05},
                    dir: { x: -0.05, y: 0, z: -1.0 },
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });
            HumanViewLights.defaultLightIds.push('light4');


        });

    // Lazy-rebuild the lights in the scene graph on next tick
    Human.events.on("tick",
        function () {
            HumanViewLights.compile();
        });

    /**
     * Adds a light
     * @param params
     */
    HumanViewLights.addLight = function (params) {
        var light = new Human.view.lights.Light(params);
        HumanViewLights.lights[params.lightId] = light;
        light.on("enabled",
            function () {
                dirty = true;
            });
        dirty = true;
    };

    /**
     * Removes a light
     * @param lightId ID of light to remove
     */
    HumanViewLights.removeLight = function (lightId) {
        if (HumanViewLights.lights[lightId]) {
            delete HumanViewLights.lights[lightId];
            dirty = true;
        }
    };

    /**
     * Removes all lights
     */
    HumanViewLights.removeAllLights = function () {
        HumanViewLights.lights = {};
        dirty = true;
    };

    /**
     * Enables or disables one or more lights
     *
     * <p>Examples:</p>
     *
     * <pre>
     *
     *  Human.view.lights.setEnabled({
     *      lightId: "myLight",
     *      enable: true
     *  });
     *
     *  Human.view.lights.setEnabled({
     *      lights: {
     *          "myLight": true,
     *          "myOtherlight": false
     *      },
     *      replace: true // Disable any lights that are previously enabled
     *  });
     * </pre>
     * @param params
     */
    HumanViewLights.setEnabled = function (params) {
        // Option to replace the set of enabled lights
        if (params.replace) {
            HumanViewLights.clearEnabled();
        }
        var lightId;
        var light;
        var val;
        if (params.lightId) {
            lightId = params.lightId;
            light = HumanViewLights.lights[lightId];
            if (!light) {
                Human.log.error("Human.view.lights.setEnabled", "Light not found: " + lightId);
                return;
            }
            val = !!params.enable;
            if (light.enabled !== val) {
                light.enabled = val;
                dirty = true;
            }
        } else if (params.lights) {
            var lights = params.lights;
            for (lightId in lights) {
                if (lights.hasOwnProperty(lightId)) {
                    light = HumanViewLights.lights[lightId];
                    if (!light) {
                        Human.log.error("Human.view.lights.setEnabled", "Light not found: " + lightId);
                        continue;
                    }
                    val = !!lights[lightId];
                    if (light.enabled !== val) {
                        light.enabled = val;
                        dirty = true;
                    }
                    if (val && typeof val !== "boolean") {
                        // Light params given
                        light.setParams(val);
                    }
                }
            }
        }
    };

    /**
     * Disables all lights
     */
    HumanViewLights.clearEnabled = function () {
        for (var lightId in HumanViewLights.lights) {
            if (HumanViewLights.lights.hasOwnProperty(lightId)) {
                HumanViewLights.lights[lightId].setEnabled(false);
                dirty = true;
            }
        }
    };

    /**
     * Sets parameters for lights
     * @param params
     */
    HumanViewLights.setParams = function (params) {
        var light;
        for (var lightId in params) {
            if (params.hasOwnProperty(lightId)) {
                light = HumanViewLights.lights[lightId];
                if (!light) {
                    Human.log.error("Human.view.lights.setParams", "Light not found: " + lightId);
                    continue;
                }
                light.setParams(params[lightId]);
            }
        }
    };

    /* Restore Defaults (currently only one set of defaults)
    */
    HumanViewLights.restoreDefaults = function(){
        var params = {
            lights: {},
            replace: true
        };

        HumanViewLights.defaultLightIds.forEach(function(id){
            params.lights[id] = true;
        });
        HumanViewLights.setEnabled(params);
    };

    HumanViewLights.compile = function() {

        if (!dirty) {
            return;
        }

        var scene = Human.renderer.getScene();

        // Get lights container node
        scene.getNode("lights",
            function (container) {

                // Get subtree of that, which contains the scene content
                scene.getNode("lights.subtree",
                    function (subtree) {

                        // Disconnect scene content
                        subtree.disconnect();

                        // Blow away lights node
                        container.removeNodes();

                        // Accumulate enabled light sources in array
                        var _lights = [];
                        var light;
                        var lightId;

                        for (lightId in HumanViewLights.lights) {
                            if (HumanViewLights.lights.hasOwnProperty(lightId)) {

                                light = HumanViewLights.lights[lightId];

                                if (light.enabled) {
                                    if (light.params) {
                                        _lights.push(light.params || {});
                                    }
                                }
                            }
                        }

                        // Rebuild light node

                        var node = container.addNode({
                            type: "lights",
                            lights: _lights.slice(0),
                            nodes: [
                                {
                                    id: "lightsSubTree"
                                }
                            ]
                        });

                        // Link light elements back to the node
                        // to assist with dynamic update

                        var count = 0;

                        for (lightId in HumanViewLights.lights) {
                            if (HumanViewLights.lights.hasOwnProperty(lightId)) {
                                light = HumanViewLights.lights[lightId];
                                light.node = node;
                                light.index = count++;
                            }
                        }


                        scene.getNode("lightsSubTree",
                            function (leaf) {
                                leaf.addNode(subtree);
                            });
                    });
            });

        dirty = false;
    };

})();
;(function() {
    "use strict";

    
    /**
     * @class A rendering post-light within {@link Human.view.lights}
     * @param cfg
     * @constructor
     */
    Human.view.lights.Light = function (cfg) {

        // Call parent class Human.Component init
        this._init();

        /**
         * Display name for this light
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /**
         * Description of this light
         * @type {String}
         */
        this.description = cfg.description;

        /** ID of this light, unique within {@link Human.view.lights}
         * @type {String}
         */
        this.lightId = cfg.lightId;

        /**
         * True when light is enabled
         * @type {boolean}
         */
        this.enabled = !!cfg.enabled;

        /**
         * Light parameters
         * @type {{}}
         */
        this.params = cfg.params || {};

        /**
         * Target scene node for this light, non-null while the light is active.
         * @type {SceneJS.Node}
         */
        this.node = null;

        /**
         * Index of light on the target scene node, valid while light active
         * @type {number}
         */
        this.index = 0;
    };

    Human.utils.extend(Human.view.lights.Light, Human.Component);

    /**
     * Enables or disables this light
     * @memberof Human.view.lights.Light
     */
    Human.view.lights.Light.prototype.setEnabled = function (enabled) {
        this.publish("enabled", this.enabled = enabled);
    };


    /**
     * Configures this light
     * @memberof Human.view.lights.Light
     */
    Human.view.lights.Light.prototype.setParams = function (params) {
        Human.utils.apply(params, this.params);
        if (this.node) {
            // Light is currently enabled, update its scene node
            var p = {};
            p["" + this.index] = params;
            this.node.setLights(p);
        }
    };

})();




;/**

 Post-effect pipeline

 <pre>

 //----------------------------------------------------------------------------
 // Build the pipeline
 //----------------------------------------------------------------------------

 // Add depth-of-field blur
 Human.view.effects.addEffect({
                effectId: "dof",                // Unique ID to assign
                type: "postprocess/dof",        // SceneJS node to use for this effect
                displayName: "Depth-of-field",
                description: "Simulates photographic depth-of-field",
                params: {
                    texelSize: 0.00022,             // Size of one texel (1 / width, 1 / height)
                    blurCoeff: 0.0084,	            // Calculated from the blur equation, b = ( f * ms / N )
                    autofocus: true                 // Automatically synch focusDist to "cameras/pickFlyOrbit"
                }
            });

 // Film grain effect
 Human.view.effects.addEffect({
                effectId: "filmGrain",
                type: "postprocess/filmGrain",
                displayName: "Film Grain",
                description: "Film grain noise"
            });

 // Sepia effect
 Human.view.effects.addEffect({
                effectId: "sepia",
                type: "postprocess/sepia",
                displayName: "Sepia",
                description: "Sepia color filter"
            });

 //----------------------------------------------------------------------------
 // Enable effects
 //----------------------------------------------------------------------------

 // Enable "sepia" and "dof", disable "filmGrain"
 Human.view.effects.setEnabled({
                effectIds: {
                    "sepia": true,
                    "dof": true,
                    "filmGrain": false
                },
                replace: true
        });

 //----------------------------------------------------------------------------
 // Set effect parameters
 //----------------------------------------------------------------------------

 // Set parameters for depth-of-field effect
 Human.view.effects.setParams({
        "dof": {
            "PPM": 100000,
            "blurCoeff" : 0.001
        }
    });
 </pre>
 */
(function () {
    "use strict";

    var HumanViewEffects = Human.view.effects = {};

    /**
     * Effects in the order in which they will be applied
     *
     * @type {[Human.view.effects.Effect]}
     */
    HumanViewEffects.pipeline = [];

    /**
     * Effects mapped to their IDs
     *
     * @type {{String:Human.view.effects.Effect}}
     */
    HumanViewEffects.effects = {};


    // True when effects pipeline in the
    // scene graph needs to be rebuilt
    var dirty = false;

    // Set up the effects pipeline once the engine code has loaded
    Human.events.on("loaded",
        function () {

            // These must be added in the order in which they
            // should be applied with respect to one another

            // Depth-of-field blur
            HumanViewEffects.addEffect({
                effectId: "dof",                // Unique ID to assign
                type: "postprocess/dof",        // SceneJS node to use for this effect
                displayName: "Depth-of-field",
                description: "Simulates photographic depth-of-field",

                // Effect parameters
                params: {
                    texelSize: 0.00022,             // Size of one texel (1 / width, 1 / height)
                    blurCoeff: 0.0084,	            // Calculated from the blur equation, b = ( f * ms / N )
                    ppm: 10000.0,
                    autofocus: true                 // Automatically synch focusDist to "cameras/pickFlyOrbit"
                }
            });

            // Sepia effect
            HumanViewEffects.addEffect({
                effectId: "sepia",
                type: "postprocess/sepia",
                displayName: "Sepia",
                description: "Sepia color filter"
            });

            // Scanlines effect
            HumanViewEffects.addEffect({
                effectId: "scanlines",
                type: "postprocess/scanlines",
                displayName: "Scanlines",
                description: "Scan lines pattern"
            });

            // Film grain effect
            HumanViewEffects.addEffect({
                effectId: "filmGrain",
                type: "postprocess/filmGrain",
                displayName: "Film Grain",
                description: "Film grain noise"
            });

            // Technicolor effect
            HumanViewEffects.addEffect({
                effectId: "technicolor",
                type: "postprocess/technicolor",
                displayName: "Technicolor",
                description: "Technicolor color filter"
            });

            // Oculus Rift
            HumanViewEffects.addEffect({
                effectId: "oculusRift",
                type: "effects/oculusRift",
                displayName: "Oculus Rift",
                description: "View using Oculus Rift",
                params: {
                    eyeSep: 20.6,
                    focalLength: 27
                }
            });

            // Stereo
            HumanViewEffects.addEffect({
                effectId: "stereo",
                type: "effects/stereo",
                displayName: "Stereo",
                description: "View in stereo"
            });

            // Anaglyph
            HumanViewEffects.addEffect({
                effectId: "anaglyph",
                type: "effects/anaglyph",
                displayName: "Anaglyph 3D",
                description: "View in Anaglyph 3D"
            });
        });

    // Lazy-rebuild the effect nodes in the scene graph
    Human.events.on("tick",
        function () {
            HumanViewEffects.compile();
        });

    /**
     * Adds a effect
     * @param params
     * @returns {Human.view.effects.Effect}
     */
    HumanViewEffects.addEffect = function (params) {
        var effect = new Human.view.effects.Effect(params);
        HumanViewEffects.effects[params.effectId] = effect;
        HumanViewEffects.pipeline.unshift(effect);
        effect.on("enabled",
            function () {
                dirty = true;
            });
        dirty = true;
    };

    /**
     * Enables or disables effects
     *
     * <p>Examples:</p>
     *
     * <pre>
     *
     *  Human.view.effects.setEnabled({
     *      effectId: "dof",
     *      enable: true
     *  });
     *
     *  Human.view.effects.setEnabled({
     *      effectIds: {
     *          "dof": true,
     *          "blur": false
     *      }
     *  });
     * </pre>
     * @param params
     */
    HumanViewEffects.setEnabled = function (params) {

        var effectId;

        // Option to replace the set of enabled effects
        if (params.replace) {
            for (var i = 0, len = HumanViewEffects.pipeline.length; i < len; i++) {
                HumanViewEffects.pipeline[i].enabled = false;
            }
        }
        var effect;
        if (params.effectId) {
            effectId = params.effectId;
            effect = HumanViewEffects.effects[effectId];
            if (!effect) {
                Human.log.error("Human.view.effects.setEnabled", "Effect not found: " + effectId);
                return;
            }
            effect.enabled = !!params.enable;
        } else if (params.effectIds) {
            var effectIds = params.effectIds;
            var val;
            for (effectId in effectIds) {
                if (effectIds.hasOwnProperty(effectId)) {
                    effect = HumanViewEffects.effects[effectId];
                    if (!effect) {
                        Human.log.error("Human.view.effects.setEnabled", "Effect not found: " + effectId);
                        continue;
                    }
                    val = effectIds[effectId];
                    effect.enabled = !!val;
                    if (val && typeof val !== "boolean") {
                        // Effect params given
                        effect.setParams(val);
                    }
                }
            }
        }
        dirty = true;
    };

    /**
     * Disables all effects
     */
    HumanViewEffects.clearEnabled = function () {
        for (var i = 0, len = HumanViewEffects.pipeline.length; i < len; i++) {
            HumanViewEffects.pipeline[i].enabled = false;
        }
        dirty = true;
    };

    /**
     * Sets parameters for effects
     * @param params
     */
    HumanViewEffects.setParams = function (params) {
        var effect;
        for (var effectId in params) {
            if (params.hasOwnProperty(effectId)) {
                effect = HumanViewEffects.effects[effectId];
                if (!effect) {
                    Human.log.error("Human.view.effects.setParams", "Effect not found: " + effectId);
                    continue;
                }
                effect.setParams(params[effectId]);
            }
        }
    };

    function createEffectCallback(effect) {
        return function (node) {
            effect.node = node;
        };
    }

    // -------- DEFAULTS -------
    var defaultEffects = {
      anaglyph: false,
      dof: false,
      filmGrain: false,
      oculusRift: false,
      scanlines: false,
      sepia: false,
      stereo: false,
      technicolor: false
    };

    HumanViewEffects.getDefaults = function(){
      return Human.utils.shallowClone(defaultEffects);
    };

    HumanViewEffects.compile = function () {

        if (!dirty) {
            return;
        }

        // Get effects container node
        var scene = Human.renderer.getScene();
        scene.getNode("effect",
            function (container) {
                // Get subtree of that, which contains the scene content
                scene.getNode("effect.subtree",
                    function (subtree) {
                        // Disconnect scene content
                        subtree.disconnect();
                        // Blow away effect nodes
                        container.removeNodes();
                        // Rebuild effect nodes
                        var effect;
                        var json = {
                            nodes: []
                        };
                        var node = json;
                        for (var i = 0, len = HumanViewEffects.pipeline.length; i < len; i++) {
                            effect = HumanViewEffects.pipeline[i];
                            if (effect.enabled) {
                                var child = Human.utils.applyIf(effect.params, {
                                    type: effect.type,
                                    id: "__effects." + effect.effectId,
                                    nodes: []
                                });
                                node.nodes.push(child);
                                node = child;

                                // Save scene node on effect for param updates
                                // See {@link Human.effects.Effect#setParams}
                                scene.getNode("__effects." + effect.effectId,
                                    createEffectCallback(effect));
                            } else {

                                // No scene nodes exist for disabled effects
                                effect.node = null;
                            }
                        }
                        // Append scene content to lowest effect node, thus applying
                        // all the effects to it, in order of each effect on the path
                        // up to the scene root
                        node.nodes.push({ id: "effectsSubTree" });
                        container.addNode(json);
                        scene.getNode("effectsSubTree",
                            function (leaf) {
                                leaf.addNode(subtree);
                            });
                    });
            });
        dirty = false;
    };

})();
;(function() {
    "use strict";


    /**
     * @class A rendering post-effect within {@link Human.view.effects}
     * @param cfg
     * @constructor
     */
    Human.view.effects.Effect = function (cfg) {

        // Call parent class Human.Component init
        this._init();

        /** ID of this effect, unique within {@link Human.view.effects}
         * @type {String}
         */
        this.effectId = cfg.effectId;

        /** Type name of this effect
         * @type {String}
         */
        this.type = cfg.type;

        /**
         * Display name for this effect
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /**
         * Description of this effect
         * @type {String}
         */
        this.description = cfg.description;

        /**
         *
         * @type {boolean}
         */
        this.enabled = false;

        /**
         * Effect parameters
         * @type {{}}
         */
        this.params = cfg.params || {};

        /**
         * Scene node for this effect, non-null while the effect is active.
         * @type {SceneJS.Node}
         */
        this.node = null;
    };

    Human.utils.extend(Human.view.effects.Effect, Human.Component);

    /**
     * Enables or disables this effect
     * @memberof Human.view.effects.Effect
     */
    Human.view.effects.Effect.prototype.setEnabled = function (enabled) {
        this.publish("enabled", this.enabled = enabled);
    };


    /**
     * Configures this effect
     * @memberof Human.view.effects.Effect
     */
    Human.view.effects.Effect.prototype.setParams = function (params) {
        Human.utils.apply(params, this.params);
        if (this.node) {
            // Effect is currently active, update its scene node
            this.node.set(params);
        }
    };

})();
;/**
 * @namespace Manages Highlight mode
 */
(function () {

    "use strict";

    var HumanViewExplode = Human.view.explode = {};

    // How many units each object moves per second when exploding
    var speed = 0.5;

    // Objects currently being exploded
    var objects = [];

    // Map of objects currently being exploded, used to prevent duplicates when building explode list
    var addedObjects = {};

    // Memento of initial transform state for each exploding object
    var origins = [];

    // Memento of initial World-space center of each exploding object
    var centers = [];

    // Vector for each object, indicating direction of movement during explosion
    var vectors = [];

    // Number of objects currently exploding
    var numObjects = 0;

    // World-space center of all exploding objects
    var xCenter = 0;
    var yCenter = 0;
    var zCenter = 0;

    // Current explosion factor
    var xFactor = 0.0;
    var yFactor = 0.0;
    var zFactor = 0.0;

    // Target explosion factor we may be animating towards
    var xFactorTarget;
    var yFactorTarget;
    var zFactorTarget;

    // True when scene objects have been created or destroyed,
    // indicates that we need to add or remove explosion state accordingly, on next animation frame
    var objectsDirty = true;

    // Current explosion status

    var COLLAPSED = 0;      // Objects are at their original positions, ie. explosion is collapsed
    var EXPLODING = 1;      // Objects are at some point between original positions and fully-exploded positions
    var EXPLODED = 2;       // Objects are at fully-exploded positions

    var status = COLLAPSED;

    // True when EXPLODING and we need to recompute
    // the exploding object positions for the next frame
    var explodeDirty = false;


    Human.events.on("scene.objectsShown",
        function () {
            HumanViewExplode.reset();
        });

    // Reset exploding objects back to their initial positions
    // whenever we play or scrub the timeline.

    Human.events.on("timeline.played",
        function () {
            if (status === EXPLODING || status === EXPLODED) {
                HumanViewExplode.reset();
            }
        });

    Human.events.on("timeline.scrubbed",
        function () {
            if (status === EXPLODING || status === EXPLODED) {
                HumanViewExplode.reset();
            }
        });

    Human.events.on("tick",
        function (params) {

            if (explodeDirty) {

                if (objectsDirty) {

                    // Objects were created or destroyed
                    // Add or remove explosion state accordingly

                    getObjects();
                }

                // Update the explosion animation

                var elapsedSecs = (params.timeNow - params.timeLast) * 0.001;

                var delta = elapsedSecs * speed;

                var xSign = (xFactorTarget - xFactor) < 0 ? -1 : 1;
                var ySign = (yFactorTarget - yFactor) < 0 ? -1 : 1;
                var zSign = (zFactorTarget - zFactor) < 0 ? -1 : 1;

                xFactor += delta * xSign;
                yFactor += delta * ySign;
                zFactor += delta * zSign;


                // Clamp explosion factor on each axis

                var maxReached = 0;
                var minReached = 0;

                if (xSign > 0 && xFactor > xFactorTarget) {
                    xFactor = xFactorTarget;
                    maxReached++;

                }

                if (xSign < 0 && xFactor < 0) {
                    xFactor = 0;
                    minReached++;
                }

                if (ySign > 0 && yFactor > yFactorTarget) {
                    yFactor = yFactorTarget;
                    maxReached++;

                }

                if (ySign < 0 && yFactor < 0) {
                    yFactor = 0;
                    minReached++;
                }

                if (zSign > 0 && zFactor > zFactorTarget) {
                    zFactor = zFactorTarget;
                    maxReached++;

                }

                if (zSign < 0 && zFactor < 0) {
                    zFactor = 0;
                    minReached++;
                }

                // Explosion is finished if we just clamped the explosion factors on all three axis,
                // ie. no axis is still animating

                if (maxReached === 3) {
                    status = EXPLODED;
                    explodeDirty = false;

                } else if (minReached === 3) {
                    status = COLLAPSED;
                    explodeDirty = false;
                }

                // Update the positions of the exploding objects
                // Each object is positioned at the end of its
                // explosion vector, multiplied by the explosion factors

                // When COLLAPSED, the explosion vectors will be zero length,
                // which sets the objects back at their initial positions

                var origin;
                var vector;

                for (var i = 0; i < numObjects; i++) {

                    origin = origins[i];
                    vector = vectors[i];

                    objects[i].setTransform({
                        translate: {
                            x: origin.x + (vector[0] * xFactor),
                            y: origin.y + (vector[1] * yFactor),
                            z: origin.z + (vector[2] * zFactor)
                        }
                    });
                }

                // notify of eplode updated
                Human.events.fire("explode.updated", {
                    scale: Math.round((xFactor + yFactor + zFactor) / 3),
                    speed: speed
                });
            }
        });


    // For each visible scene object:
    //
    // - Set up explosion vectors
    // - Save World-space origin
    // - Save initial translation, to apply when resetting the explosion
    //
    function getObjects() {

        clearObjects();

        var objectId;
        var object;
        var origin;
        var center;
        var vector;
        var negatedAxes = {x: false, y: false, z: false};

        xCenter = 0;
        yCenter = 0;
        zCenter = 0;

        for (objectId in Human.scene.enabledObjects) {

            if (Human.scene.enabledObjects.hasOwnProperty(objectId)) {

                object = Human.scene.enabledObjects[objectId];

                if (object.objects.length === 0) {

                    while (object && object.anonymous) {
                        object = object.parent;
                    }

                    if (object && object.parent && !isObjectAdded(object)) {

                        objects[numObjects] = object;
                        addedObjects[object.objectId] = object;

                        origin = origins[numObjects];
                        if (!origin) {
                            origin = origins[numObjects] = {
                                x: object.translate.x,
                                y: object.translate.y,
                                z: object.translate.z
                            };
                        } else {
                            origin.x = object.translate.x;
                            origin.y = object.translate.y;
                            origin.z = object.translate.z;
                        }

                        center = object.getCenter();

                        xCenter += center[0];
                        yCenter += center[1];
                        zCenter += center[2];

                        centers[numObjects] = center;

                        numObjects++;
                    }
                }
            }
        }

        if (numObjects > 1) { // Can't explode one object away from itself

            xCenter /= numObjects;
            yCenter /= numObjects;
            zCenter /= numObjects;

            for (var i = 0; i < numObjects; i++) {

                center = centers[i];
                object = objects[i];

                // The reason we're checking the parent is that negation of the axes
                // will only affect translation if the scale comes after the translation
                // which only occurs for parent transforms.
                object.parent.getNegatedAxes(negatedAxes);

                if (!vectors[i]) {
                    vectors[i] = [0,0,0];
                }

                vector = Human.math.normalizeVec3([center[0] - xCenter, center[1] - yCenter, center[2] - zCenter], vectors[i]);

                if (negatedAxes.x) {
                    vector[0] *= -1;
                }

                if (negatedAxes.y) {
                    vector[1] *= -1;
                }

                if (negatedAxes.z) {
                    vector[2] *= -1;
                }

                vectors[i] = vector;
            }
        }

        objectsDirty = false;
    }

    function isObjectAdded(object) {
        while (object) {
            if (addedObjects[object.objectId]) {
                return true;
            }
            object = object.parent;
        }
        return false;
    }

    function clearObjects() {
        for (var i = 0; i < numObjects; i++) {
            delete addedObjects[objects[i].objectId];
        }
        numObjects = 0;
    }

    /**
     * Explodes the currently visible scene objects
     *
     * @param [params=[]] Explosion parameters
     * @param [params.scale=2.0] Explosion scale - for each object, the initial position will be multiplied by this to find the final position.
     * @param [params.speed=1.0] Explosion speed - how much the explosion scale grows per second.
     */
    HumanViewExplode.explode = function (params) {

        params = params || {};

        var scale = params.scale;

        if (!Human.utils.isArray(scale)) {

            scale = scale || 0.0;

            if (scale < 0.0) {
                scale = 0.0;
            }

            xFactorTarget = scale;
            yFactorTarget = scale;
            zFactorTarget = scale;

        } else {

            xFactorTarget = scale[0];
            yFactorTarget = scale[1];
            zFactorTarget = scale[2];
        }

        if (xFactorTarget < 0.0) {
            xFactorTarget = 0.0;
        }

        if (yFactorTarget < 0.0) {
            yFactorTarget = 0.0;
        }

        if (zFactorTarget < 0.0) {
            zFactorTarget = 0.0;
        }

        speed = params.speed || 1.0;

        if (speed < 0.0) {
            speed = 1.0;
        }

        Human.timeline.stop();

        status = EXPLODING;

        explodeDirty = true;
    };

    /**
     * Resets the explosion back to initial state, with no animation.
     */
    HumanViewExplode.reset = function () {

        // Reset explosion parameters

        xFactor = 0;
        yFactor = 0;
        zFactor = 0;

        xFactorTarget = 0;
        yFactorTarget = 0;
        zFactorTarget = 0;

        // Restore each exploding object to initial position

        if (numObjects) {
            this._resetPositions();
        }

        // Stop explosion

        status = COLLAPSED;

        // Clear the list of exploding objects

        clearObjects();

        // We'll need to rebuild the list
        // next time we do an explode

        objectsDirty = true;

        explodeDirty = false;

        // fire reset statee
        Human.events.fire("explode.reseted", {
            scale: 0,
            speed: speed
        });
    };

    /**
     * Restores initial transform state of each exploding object
     */
    HumanViewExplode._resetPositions = function () {

        var origin;

        for (var i = 0; i < numObjects; i++) {

            origin = origins[i];

            objects[i].setTransform({
                translate: origin
            });
        }
    };

})();
;/**
 * @namespace Skybox libraries
 * @private
 */
(function () {
    "use strict";

    var HumanViewSkyboxes = Human.view.skyboxes = {};

    /** All skyboxes
     */
    var skyboxes = HumanViewSkyboxes.skyboxes = {};

    /** Skyboxes grouped into libraries
     */
    var libraries = HumanViewSkyboxes.libraries = {};

    /** Exported skyboxes
     */
    HumanViewSkyboxes.exportedSkyboxIds = {};

    /** The current active skybox
     */
    var activeSkybox = null;

    /**
     * Contains the active skybox in the scene graph
     */
    var containerNode;
    
    Human.events.on("loaded", function () {

        containerNode = Human.renderer.getNode("skybox-container");

        // The 'skyboxes.activeSkybox' property dynamically selects the
        // currently active skybox. Putting the property listener inside the
        // 'loaded' handler because we want this skybox engine module to
        // actually exist when we get this event, which we get as soon as
        // we subscribe, and then every time the property changes.

        Human.properties.subscribe({
            propId: "skyboxes.activeSkybox",
            callback: function (value) {
                if (value && Human.utils.isString(value)) {
                    var skyboxId = value;
                    HumanViewSkyboxes.activateSkybox(skyboxId);
                } else {
                    HumanViewSkyboxes.deactivateSkybox();
                }
            }
        });
    });


    /** Only once skyboxes are activated and mapped to names can they be used
     * <p>Enable materials to use a particular skybox when they have a "skyboxId" set to "mySkybox":</p>
     * <pre>
     *     #exportSkyboxes({
     *          "mySkybox" : "someState.someSkyboxLib.someSkyboxId"
     *          });
     * </pre>
     *
     * @param mapping
     */
    HumanViewSkyboxes.exportSkyboxes = function (mapping) {
        HumanViewSkyboxes.exportedSkyboxIds = mapping || {};
    };
    
    /** Creates a skybox library
     *
     * @param libraryId Unique library ID
     */
    HumanViewSkyboxes.createLibrary = function (libraryId) {

        if (libraries[libraryId]) {
            Human.log.warn("Human.assets.skyboxes.createLibrary", "Skybox library already exists: " + libraryId);
            return;
        }

        libraries[libraryId] = {
            skyboxes: {}
        };
    };


    /** Creates a skybox within an existing skybox library
     *
     * @param libraryId ID of library
     * @param skyboxId ID for new skybox, globally unique among skyboxes in all libraries
     * @param params Skybox params
     */
    HumanViewSkyboxes.createSkybox = function (libraryId, skyboxId, params) {

        var library = libraries[libraryId];

        if (!library) {
            Human.log.error("Human.assets.skyboxes.createSkybox", "Skybox library not found: " + libraryId);
            return;
        }

        if (skyboxes[skyboxId]) {
            Human.log.warn("Human.assets.skyboxes.createSkybox", "Skybox already exists: " + skyboxId);
            return;
        }

        var skybox = {
            node: {
                type: "skybox",
                src: params.src,
                size: params.size || 5000.0
            }
        };

        skyboxes[skyboxId] = skybox;

        library.skyboxes[skyboxId] = skybox;
    };

    /**
     * Activates a skybox
     * @param {String} skyboxId
     */
    HumanViewSkyboxes.activateSkybox = function (skyboxId) {

        if (!skyboxId) {

            // No skybox ID just means deactivate any current skybox

            this.deactivateSkybox();
            return;
        }

        // Map skybox 'symbolic' ID to real ID
        skyboxId = this.exportedSkyboxIds[skyboxId] || skyboxId;
        
        if (activeSkybox && activeSkybox.skyboxId === skyboxId) {

            // Already active

            return;
        }

        var skybox = this.skyboxes[skyboxId];

        if (!skybox) {

            // Not found

            Human.log.warn("Human.view.skyboxes.activateSkybox", "Skybox not found: " + skyboxId);
            return;
        }

        // Deactivate any current skybox

        this.deactivateSkybox();

        // Activate new skybox

        var node = skybox.node;
        skybox._node = containerNode.addNode(node);

        activeSkybox = skybox;
    };

    /**
     * Deactivates whatever skybox is currently active.
     */
    HumanViewSkyboxes.deactivateSkybox = function () {

        if (activeSkybox) {

            if (activeSkybox._node) {
                activeSkybox._node.destroy();
                activeSkybox._node = null;
            }

            activeSkybox = null;
        }
    };

    /**
     * Destroys a skybox library
     *
     * @param libraryId
     */
    HumanViewSkyboxes.destroyLibrary = function (libraryId) {

        if (!libraryId) {
            HumanViewSkyboxes.reset();
            return;
        }

        var lib = libraries[libraryId];

        if (!lib) {
            Human.log.warn("Human.assets.skyboxes.destroyLibrary", "Skybox library not found: " + libraryId);
            return;
        }

        for (var skyboxId in lib.skyboxes) {
            if (lib.skyboxes.hasOwnProperty(skyboxId)) {

                if (activeSkybox && activeSkybox.skyboxId === skyboxId) {

                    // Destroying the active skybox - deactivate it first
                    HumanViewSkyboxes.deactivateSkybox();
                }

                lib.skyboxes[skyboxId].node.destroy();
            }
        }

        delete libraries[libraryId];
    };


    /** Destroys all skybox libraries
     */
    HumanViewSkyboxes.reset = function () {
        for (var libraryId in libraries) {
            if (libraries.hasOwnProperty(libraryId)) {
                HumanViewSkyboxes.destroyLibrary(libraryId);
            }
        }
    };
})();;/**
 * @namespace
 */
(function () {
    "use strict";

    var HumanInput = Human.input = {};

    var canvas = $("#annotationCanvas");
    var handlers = [];
    var tickSubs = [];
    var keyDownSubs = {};
    var keyUpSubs = {};
    var mouseDownSubs = [];
    var mouseUpSubs = [];
    var mouseClickSubs = [];
    var mouseDoubleClickSubs = [];
    var mouseMoveSubs = [];
    var mouseWheelSubs = [];
    var resetSubs = [];
    var enabled = true;

    // TOUCH
    var touchStartSubs = [];
    var touchMoveSubs = [];
    var touchPinchSubs = [];
    var touchZoomSubs = [];
    var touchPanSubs = [];
    var touchEndSubs = [];
    var touchTapSubs = [];
    var touchDoubleTapSubs = [];
    var TAP_INTERVAL = 250;
    var DBL_TAP_INTERVAL = 325;

    var $document = jQuery(document);

    $document.ready(function () {
        // Disable context menu throughout document.
        $document.bind("contextmenu", function (event) {
            //Well, except for the snapshot image and text fields.
            if (event.target.id !== "snapshotPanelImage" &&
                event.target.type !== "input" &&
                event.target.type !== "email" &&
                event.target.type !== "text" &&
                event.target.type !== "textarea") {
                return false;
            }
        });
    });

    // Context given to each handler
    var ctx = {

        // True when ALT down
        altDown: false,

        // True when CTL down
        ctrlDown: false,

        // Flag for each key currently down
        keyDown: [],

        // Subscribe to periodic engine tick event
        onTick: function (fn) {
            tickSubs.push(fn);
        },

        // Subscribe to key down event
        onKeyDown: function (keys, fn) {
            var key;
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                (keyDownSubs[key] || (keyDownSubs[key] = [])).push(fn);
            }
        },

        // Subscribe to key up event
        onKeyUp: function (keys, fn) {
            var key;
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                (keyUpSubs[key] || (keyUpSubs[key] = [])).push(fn);
            }
        },

        // Subscribe to mouse down event
        onMouseDown: function (fn) {
            mouseDownSubs.push(fn);
        },

        // Subscribe to mouse up event
        onMouseUp: function (fn) {
            mouseUpSubs.push(fn);
        },

        // Subscribe to mouse click event
        onMouseClick: function (fn) {
            mouseClickSubs.push(fn);
        },

        // Subscribe to mouse doubleClick event
        onMouseDoubleClick: function (fn) {
            mouseDoubleClickSubs.push(fn);
        },

        // Subscribe to mouse move event
        onMouseMove: function (fn) {
            mouseMoveSubs.push(fn);
        },

        // Subscribe to mouse wheel event
        onMouseWheel: function (fn) {
            mouseWheelSubs.push(fn);
        },

        // Subscribe to reset
        onReset: function (fn) {
            resetSubs.push(fn);
        },

        // Subscribe to touch start
        onTouchStart: function (fn) {
            touchStartSubs.push(fn);
        },

        // Subscribe to touch move
        onTouchMove: function (fn) {
            touchMoveSubs.push(fn);
        },

        // Subscribe to touch end
        onTouchEnd: function (fn) {
            touchEndSubs.push(fn);
        },

        // Subscribe to touch tap
        onTouchTap: function (fn) {
            touchTapSubs.push(fn);
        },
        onTouchDoubleTap: function (fn) {
            touchDoubleTapSubs.push(fn);
        },
        onTouchPinch: function (fn) {
            touchPinchSubs.push(fn);
        },
        onTouchZoom: function (fn) {
            touchZoomSubs.push(fn);
        },
        onTouchPan: function (fn) {
            touchPanSubs.push(fn);
        }
    };

    var lastTime = null;
    Human.events.on(
        "tick",
        function () {
            if (!enabled) {
                lastTime = null;
                return;
            }
            var time = Date.now() / 1000;
            if (lastTime !== null) {
                var elapsed = time - lastTime;
                for (var i = 0, len = tickSubs.length; i < len; i++) {
                    tickSubs[i](time, elapsed);
                }
            }
            lastTime = time;
        });

    document.addEventListener("keydown",
        function (e) {
            if (!enabled) {
                return;
            }
            if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                ctx.ctrlDown = e.ctrlKey || e.keyCode === 17 || e.metaKey; // !important, treat Windows or Mac Command Key as ctrl
                ctx.altDown = e.altKey || e.keyCode === 18;
                ctx.keyDown[e.keyCode] = true;
                var code = e.keyCode;
                var subs = keyDownSubs[code];
                if (subs) {
                    for (var i = 0, len = subs.length; i < len; i++) {
                        subs[i](code);
                    }
                }
            }
        }, true);

    document.addEventListener("keyup",
        function (e) {
            if (!enabled) {
                return;
            }
            if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                if (e.ctrlKey || e.keyCode === 17) {
                    ctx.ctrlDown = false;
                }
                if (e.altKey || e.keyCode === 18) {
                    ctx.altDown = false;
                }
                ctx.keyDown[e.keyCode] = false;
                var code = e.keyCode;
                var subs = keyUpSubs[code];
                if (subs) {
                    for (var i = 0, len = subs.length; i < len; i++) {
                        subs[i](code);
                    }
                }
            }
        });

    canvas.mousedown(
        function (e) {
            switch (e.which) {
                case 1: // Left button
                    ctx.mouseDownLeft = true;
                    break;
                case 2: // Middle/both buttons
                    ctx.mouseDownMiddle = true;
                    break;
                case 3: // Right button
                    ctx.mouseDownRight = true;
                    break;
                default:
                    break;
            }
            var coords = getClickCoordsWithinElement(e);
            ctx.mouseDownX = coords.x;
            ctx.mouseDownY = coords.y;
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseDownSubs.length; i < len; i++) {
                mouseDownSubs[i](x, y);
            }
        });

    canvas.mouseup(
        function (e) {
            switch (e.which) {
                case 1: // Left button
                    ctx.mouseDownLeft = false;
                    break;
                case 2: // Middle/both buttons
                    ctx.mouseDownMiddle = false;
                    break;
                case 3: // Right button
                    ctx.mouseDownRight = false;
                    break;
                default:
                    break;
            }
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseUpSubs.length; i < len; i++) {
                mouseUpSubs[i](x, y);
            }
        });

    canvas.click(
        function (e) {
            //switch (e.which) {
            //    case 1: // Left button
            //        ctx.mouseDownLeft = false;
            //        ctx.mouseDownRight = false;
            //        break;
            //    case 2: // Middle/both buttons
            //        ctx.mouseDownMiddle = false;
            //        break;
            //    case 3: // Right button
            //        ctx.mouseDownLeft = false;
            //        ctx.mouseDownRight = false;
            //        break;
            //    default:
            //        break;
            //}
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseClickSubs.length; i < len; i++) {
                mouseClickSubs[i](x, y);
            }
        });

    canvas.dblclick(
        function (e) {
            switch (e.which) {
                case 1: // Left button
                    ctx.mouseDownLeft = false;
                    ctx.mouseDownRight = false;
                    break;
                case 2: // Middle/both buttons
                    ctx.mouseDownMiddle = false;
                    break;
                case 3: // Right button
                    ctx.mouseDownLeft = false;
                    ctx.mouseDownRight = false;
                    break;
                default:
                    break;
            }
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseDoubleClickSubs.length; i < len; i++) {
                mouseDoubleClickSubs[i](x, y);
            }
        });

    canvas.mousemove(
        function (e) {
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseMoveSubs.length; i < len; i++) {
                mouseMoveSubs[i](x, y);
            }
        });

    canvas.bind("mousewheel",
        function (event, d) {
            for (var i = 0, len = mouseWheelSubs.length; i < len; i++) {
                mouseWheelSubs[i](event, d);
            }
        });

    Human.properties.subscribe({
        propId: "ui.mouseWheel.capture",
        value: true,
        callback: function (value) {
            // stop mousewheel propagation upwards to any parent windows
            $document[value ? 'on' : 'off']("mousewheel.capture", captureEvent);
        }
    });

    function captureEvent(event) {
        // constrain to canvas elements
        if ($(event.target).is("canvas")) {
            event.stopPropagation();
            event.preventDefault();
        }
    }

    function getClickCoordsWithinElement(event) {
        var coords = { x: 0, y: 0 };
        if (!event) {
            event = window.event;
            coords.x = event.x;
            coords.y = event.y;
        }
        else {
            var element = event.target;
            var totalOffsetLeft = 0;
            var totalOffsetTop = 0;

            while (element.offsetParent) {
                totalOffsetLeft += element.offsetLeft;
                totalOffsetTop += element.offsetTop;
                element = element.offsetParent;
            }
            coords.x = event.pageX - totalOffsetLeft;
            coords.y = event.pageY - totalOffsetTop;
        }
        return coords;
    }

    var blockUI = {
        EVENTS: 'mousedown mouseup keydown keypress',
        handler: function () {
            return false;
        },
        block: function () {
            $('<div class="block-ui"></div>')
                .css({
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: '100%',
                    height: '100%',
                    'z-index': 1000
                })
                .appendTo('body');

            $document.on(this.EVENTS, this.handler);
        },
        unblock: function () {
            $('body > .block-ui').remove();

            $document.off(this.EVENTS, this.handler);
        }
    };

    /**
     * Add a handler
     * @param handler
     */
    HumanInput.addHandler = function (Handler) {
        handlers.push(new Handler(ctx));
    };

    /**
     * Enables or disables user input
     */
    HumanInput.setEnabled = function (enable) {
        if (enabled !== enable) {
            if (enable) {
                // Block/unblock UI
                blockUI.unblock();
            } else {
                // Invisible overlay because our progress bar would be dimmed otherwise
                blockUI.block();
            }
            enabled = enable;
            Human.events.fire(enable ? "inputEnabled" : "inputDisabled", {});
        }
    };

    /* Touch Support */
    var HumanInputTouch = Human.input.touch = {};
    // globals
    var enableTouch = false;
    var TOUCH_EVENT_NAMES = ["touchstart", "touchmove", "touchend"];
    var TOUCH_CONTAINER_ID = "container";
    // pan/pinch toleralce
    //var TOUCH_PAN_ANGLE = 15;
    var tapStartTime;
    var touchStartTime;
    var downTouches = [];
    var currentTouches = [];
    var lastTapTime = null;
    var multiTouchTime = null;
    var startPosition = null;
    var stopPosition = null;
    var multiCoordinates = [];
    var distanceX = 0;
    var distanceY = 0;
    var panning = false;

    HumanInputTouch.isSupported = function () {
        return "ontouchstart" in window;
    };

    HumanInputTouch.setEnabled = function (enabled) {
        if (enabled === true) {
            if (enableTouch !== true) {
                HumanInputTouch._bindHandlers();
            }
        }
        else {
            if (enableTouch === true) {
                HumanInputTouch._unbindHandlers();
            }
        }
        enableTouch = enabled === true;
    };

    HumanInputTouch._getTouchContainer = function () {
        return document.getElementById(TOUCH_CONTAINER_ID);
    };

    var processTap = false;
    function _onTouchEvent(e) {
        // prevent bubble up
        e.preventDefault();
        e.stopPropagation();
        // dispatch messages
        var subs = [];
        var tap = false;
        var dblTap = false;
        var xDelta = 0;
        var yDelta = 0;
        var elapse = 0;
        var xSpeed = 0;
        var ySpeed = 0;

        // normalize touch coordiantes
        var touches = e.touches;
        var changedTouches = e.changedTouches;
        var coordinates = HumanInputTouch.getCoordiantes(touches);
        currentTouches = coordinates;

        // locals
        var currentTime = Date.now();
        var i;

        var getEventParams = function () {
            return {
                touches: coordinates,
                xDelta: xDelta,
                yDelta: yDelta,
                distanceX: distanceX,
                distanceY: distanceY,
                elapse: elapse,
                xSpeed: xSpeed,
                ySpeed: ySpeed
            };
        };

        var dispatch = function (subs, params) {
            params = params || getEventParams();
            for (var i = 0; i < subs.length; i++) {
                subs[i](params);
            }
        };

        // throttle touch move
        if (e.type === "touchmove" && multiTouchTime) {
            var elapsed = currentTime - multiTouchTime;
            if (elapsed <= 25) {
                return;
            }
        }

        switch (e.type) {
            case "touchstart":
                processTap = e.touches.length === 1 && changedTouches.length === 1;
                if (processTap) {
                    tapStartTime = currentTime;
                    multiTouchTime = null;
                }
                else {
                    tapStartTime = null;
                }
                touchStartTime = currentTime;
                //tapStartTime = touches.length === 1 && multiCoordinates.length <= 1 ? touchStartTime : null;
                multiTouchTime = touches.length === 2 ? currentTime : null;

                downTouches.length = 0;
                downTouches = downTouches.concat(coordinates);
                startPosition = coordinates[0];
                stopPosition = coordinates[0];
                // pinch-zoom start
                var multiTouch = coordinates.length > 1;
                if (multiTouch) {
                    multiCoordinates = coordinates;
                }
                else {
                    subs.push(touchStartSubs);
                    multiCoordinates = [];
                }
                break;
            case "touchmove":
                // pinch-zoom active
                var twoFingerAction = coordinates.length === 2 && multiCoordinates.length === 2;
                if (twoFingerAction) {
                    multiTouchTime = currentTime;
                    // compare to prev action
                    var deltaOneX = Math.abs(multiCoordinates[0].x - multiCoordinates[1].x);
                    var deltaOneY = Math.abs(multiCoordinates[0].y - multiCoordinates[1].y);
                    var deltaTwoX = Math.abs(coordinates[0].x - coordinates[1].x);
                    var deltaTwoY = Math.abs(coordinates[0].y - coordinates[1].y);
                    //xDelta = coordinates[0].x - multiCoordinates[0].x;
                    //yDelta = coordinates[0].y - multiCoordinates[0].y;
                    var xDeltaOne = coordinates[0].x - multiCoordinates[0].x;
                    var yDeltaOne = coordinates[0].y - multiCoordinates[0].y;
                    var xDeltaTwo = coordinates[1].x - multiCoordinates[1].x;
                    var yDeltaTwo = coordinates[1].y - multiCoordinates[1].y;
                    xDelta = (xDeltaOne + xDeltaTwo) / 2;
                    yDelta = (yDeltaOne + yDeltaTwo) / 2;
                    //xDelta = deltaOneX - deltaTwoX;
                    //yDelta = deltaOneY - deltaTwoY;
                    distanceX = Math.abs(coordinates[0].x - coordinates[1].x);
                    distanceY = Math.abs(coordinates[0].y - coordinates[1].y);
                    var distanceOne = Math.sqrt(Math.pow(deltaOneX, 2) + Math.pow(deltaOneY, 2));
                    var distanceTwo = Math.sqrt(Math.pow(deltaTwoX, 2) + Math.pow(deltaTwoY, 2));
                    // angle in degrees
                    //var angleDeg = Math.atan2(deltaTwoY, deltaTwoX) * 180 / Math.PI;
                    // determine panning
                    //panning = angleDeg <= TOUCH_PAN_ANGLE || angleDeg >= 90 - TOUCH_PAN_ANGLE;
                    var deltaDistance = Math.abs(distanceOne - distanceTwo);
                    panning = deltaDistance <= 5;
                    // compare finger direction

                    var xChange = xDeltaOne < 0 && xDeltaTwo > 0 || xDeltaOne > 0 && xDeltaTwo < 0;
                    var yChange = yDeltaOne < 0 && yDeltaTwo > 0 || yDeltaOne > 0 && yDeltaTwo < 0;
                    // panning
                    if (panning) { // panning
                        xDelta = (xDeltaOne + xDeltaTwo) / 2;
                        yDelta = (yDeltaOne + yDeltaTwo) / 2;
                        // determine panning/pinch/zoom
                        subs.push(touchPanSubs);

                        // update multi position
                        //  multiCoordinates = coordinates.concat([]);
                    }
                    else if (xChange || yChange) {
                        // pinch
                        if (deltaTwoX < deltaOneX && deltaTwoY < deltaOneY) {
                            subs.push(touchPinchSubs);
                        }
                        // zoom
                        else if (deltaTwoX > deltaOneX && deltaTwoY > deltaOneY) {
                            subs.push(touchZoomSubs);
                        }
                    }
                    // update multi position
                    multiCoordinates = coordinates.concat([]);
                }
                // standard cursor move
                else {
                    xDelta = coordinates[0].x - stopPosition.x;
                    yDelta = coordinates[0].y - stopPosition.y;
                    if (multiTouchTime) {
                        var multiTouchElapsed = currentTime - multiTouchTime;
                        // delay move event
                        if (multiTouchElapsed > 250) {
                            subs.push(touchMoveSubs);
                        }
                    }
                    else {
                        subs.push(touchMoveSubs);
                    }
                    multiCoordinates = [];
                    multiTouchTime = null;
                }
                stopPosition = coordinates[0];
                break;
            case "touchend":
                processTap = processTap && e.touches.length === 0 && changedTouches.length === 1;
                tap = false;
                dblTap = false;
                // process tap
                if (processTap) {
                    tap = (currentTime - tapStartTime) < TAP_INTERVAL;
                    if (tap) {
                        // check for dbl tap
                        if (lastTapTime) {
                            dblTap = (tapStartTime - lastTapTime) < DBL_TAP_INTERVAL;
                        }
                        // update last single tap
                        if (!dblTap) {
                            lastTapTime = currentTime;
                        }
                    }
                }
                else {
                    tap = false;
                    dblTap = false;
                    tapStartTime = null;
                    lastTapTime = null;
                }
                elapse = currentTime - touchStartTime;
                // track touch end
                if (multiCoordinates.length <= 1) {
                    subs.push(touchEndSubs);
                }

                // check speed
                ///if (multiCoordinates.length && multiCoordinates.length !== 2) {
                // update deltas
                xDelta = stopPosition.x - startPosition.x;
                yDelta = stopPosition.y - startPosition.y;
                // s = d/t
                xSpeed = Math.abs(xDelta) / elapse;
                ySpeed = Math.abs(yDelta) / elapse;
                break;
            default:
                break;
        }
        // dispatch std events
        for (i = 0; i < subs.length; i++) {
            var _subs = subs[i];
            // dispatch messages
            for (var j = 0; j < _subs.length; j++) {
                dispatch(_subs);
            }
        }
        // dispatch tap events
        if (tap || dblTap) {
            var tapParams = getEventParams();
            tapParams.touches = downTouches;
            if (tap) {
                dispatch(touchTapSubs, tapParams);
            }
            if (dblTap) {
                dispatch(touchDoubleTapSubs, tapParams);
            }
        }
    }

    HumanInputTouch._bindHandlers = function () {
        var container = HumanInputTouch._getTouchContainer();
        if (container) {
            HumanInputTouch._unbindHandlers();
            for (var i = 0; i < TOUCH_EVENT_NAMES.length; i++) {
                container.addEventListener(TOUCH_EVENT_NAMES[i], _onTouchEvent, false);
            }
        }
    };

    HumanInputTouch._unbindHandlers = function () {
        var container = HumanInputTouch._getTouchContainer();
        if (container) {
            for (var i = 0; i < TOUCH_EVENT_NAMES.length; i++) {
                container.removeEventListener(TOUCH_EVENT_NAMES[i], _onTouchEvent, false);
            }
        }
    };

    HumanInputTouch.getCoordiantes = function (touches) {
        var coordinates = [];
        for (var i = 0, length = touches.length; i < length; i++) {
            var touch = touches[i];
            coordinates.push({ x: touch.pageX, y: touch.pageY });
        }
        return coordinates;
    };

    // initalize touch support
    var addTouchSupport = HumanInputTouch.isSupported();
    HumanInputTouch.setEnabled(addTouchSupport);

    // Key codes

    HumanInput.KEY_BACKSPACE = 8;
    HumanInput.KEY_TAB = 9;
    HumanInput.KEY_ENTER = 13;
    HumanInput.KEY_SHIFT = 16;
    HumanInput.KEY_CTRL = 17;
    HumanInput.KEY_ALT = 18;
    HumanInput.KEY_PAUSE_BREAK = 19;
    HumanInput.KEY_CAPS_LOCK = 20;
    HumanInput.KEY_ESCAPE = 27;
    HumanInput.KEY_PAGE_UP = 33;
    HumanInput.KEY_PAGE_DOWN = 34;
    HumanInput.KEY_END = 35;
    HumanInput.KEY_HOME = 36;
    HumanInput.KEY_LEFT_ARROW = 37;
    HumanInput.KEY_UP_ARROW = 38;
    HumanInput.KEY_RIGHT_ARROW = 39;
    HumanInput.KEY_DOWN_ARROW = 40;
    HumanInput.KEY_INSERT = 45;
    HumanInput.KEY_DELETE = 46;
    HumanInput.KEY_NUM_0 = 48;
    HumanInput.KEY_NUM_1 = 49;
    HumanInput.KEY_NUM_2 = 50;
    HumanInput.KEY_NUM_3 = 51;
    HumanInput.KEY_NUM_4 = 52;
    HumanInput.KEY_NUM_5 = 53;
    HumanInput.KEY_NUM_6 = 54;
    HumanInput.KEY_NUM_7 = 55;
    HumanInput.KEY_NUM_8 = 56;
    HumanInput.KEY_NUM_9 = 57;
    HumanInput.KEY_A = 65;
    HumanInput.KEY_B = 66;
    HumanInput.KEY_C = 67;
    HumanInput.KEY_D = 68;
    HumanInput.KEY_E = 69;
    HumanInput.KEY_F = 70;
    HumanInput.KEY_G = 71;
    HumanInput.KEY_H = 72;
    HumanInput.KEY_I = 73;
    HumanInput.KEY_J = 74;
    HumanInput.KEY_K = 75;
    HumanInput.KEY_L = 76;
    HumanInput.KEY_M = 77;
    HumanInput.KEY_N = 78;
    HumanInput.KEY_O = 79;
    HumanInput.KEY_P = 80;
    HumanInput.KEY_Q = 81;
    HumanInput.KEY_R = 82;
    HumanInput.KEY_S = 83;
    HumanInput.KEY_T = 84;
    HumanInput.KEY_U = 85;
    HumanInput.KEY_V = 86;
    HumanInput.KEY_W = 87;
    HumanInput.KEY_X = 88;
    HumanInput.KEY_Y = 89;
    HumanInput.KEY_Z = 90;
    HumanInput.KEY_LEFT_WINDOW = 91;
    HumanInput.KEY_RIGHT_WINDOW = 92;
    HumanInput.KEY_SELECT_KEY = 93;
    HumanInput.KEY_NUMPAD_0 = 96;
    HumanInput.KEY_NUMPAD_1 = 97;
    HumanInput.KEY_NUMPAD_2 = 98;
    HumanInput.KEY_NUMPAD_3 = 99;
    HumanInput.KEY_NUMPAD_4 = 100;
    HumanInput.KEY_NUMPAD_5 = 101;
    HumanInput.KEY_NUMPAD_6 = 102;
    HumanInput.KEY_NUMPAD_7 = 103;
    HumanInput.KEY_NUMPAD_8 = 104;
    HumanInput.KEY_NUMPAD_9 = 105;
    HumanInput.KEY_MULTIPLY = 106;
    HumanInput.KEY_ADD = 107;   // numeric keypad
    HumanInput.KEY_SUBTRACT = 109;  // numeric keypad
    HumanInput.KEY_DECIMAL_POINT = 110;
    HumanInput.KEY_DIVIDE = 111;
    HumanInput.KEY_F1 = 112;
    HumanInput.KEY_F2 = 113;
    HumanInput.KEY_F3 = 114;
    HumanInput.KEY_F4 = 115;
    HumanInput.KEY_F5 = 116;
    HumanInput.KEY_F6 = 117;
    HumanInput.KEY_F7 = 118;
    HumanInput.KEY_F8 = 119;
    HumanInput.KEY_F9 = 120;
    HumanInput.KEY_F10 = 121;
    HumanInput.KEY_F11 = 122;
    HumanInput.KEY_F12 = 123;
    HumanInput.KEY_NUM_LOCK = 144;
    HumanInput.KEY_SCROLL_LOCK = 145;
    HumanInput.KEY_SEMI_COLON = 186;
    HumanInput.KEY_EQUAL_SIGN = 187;
    HumanInput.KEY_EQUAL_SIGN_FIREFOX = 61;
    HumanInput.KEY_DASH_FIREFOX = 173;
    HumanInput.KEY_COMMA = 188;
    HumanInput.KEY_DASH = 189;
    HumanInput.KEY_PERIOD = 190;
    HumanInput.KEY_FORWARD_SLASH = 191;
    HumanInput.KEY_GRAVE_ACCENT = 192;
    HumanInput.KEY_OPEN_BRACKET = 219;
    HumanInput.KEY_BACK_SLASH = 220;
    HumanInput.KEY_CLOSE_BRAKET = 221;
    HumanInput.KEY_SINGLE_QUOTE = 222;
    HumanInput.KEY_SPACE = 32;

})();
;/**
 * Handles mouse drags
 *
 * On mouse down:
 *
 *      if not in annotation mode
 *          orbit camera
 *
 *      else
 *          if object picked
 *
 *              create an annotation with a "mouseDownPos" attribute,
 *              which signifies to the "draggable" layout manager that
 *              the annotation was just now created by a mousedown event.
 *
 *              The layout manager will then track any subsequent
 *              mousemove events until the next mouseup, to update the
 *              label offset as the user drags the mouse.
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var draggingLabel = false;

        var x1 = null;
        var y1 = null;

        var object, objectId;
        var hit;

        var annotations = Human.view.annotations;

        var canvas;
        var context;

        Human.events.on(
            "loaded",
            function () {

                canvas = document.getElementById("annotationCanvas");

                if (!canvas) {
                    Human.log.warn("mouseDragging.js", "DOM element not found: 'annotationCanvas'");
                    return;
                }

                context = canvas.getContext('2d');

                if (!context) {
                    Human.log.warn("mouseDragging.js", "Failed to get 2D canvas context");
                    return;
                }
            });

        ctx.onMouseClick(function (x, y) {

            if (!draggingLabel) {

                x1 = x;
                y1 = y;

                if (annotations.enabled) {

                    hit = Human.view.pick.queryPick({
                        canvasX: x,
                        canvasY: y,
                        rayPick: true
                    });

                    if (hit) {

                        objectId = hit.name;

                        object = Human.scene.objects[objectId];

                        if (object) {
                            draggingLabel = true;

                            drawLine(x, y, x, y);

                            hit.objectId = objectId;
                            hit.pos = hit.worldPos;

                            Human.events.fire("annotations.pinning", hit);
                        }
                        
                    }
                }

            } else {

                objectId = hit.name;

                object = Human.scene.objects[objectId];

                if (object) {

                    Human.view.annotations.createAnnotation({
                        objectId: objectId,
                        title: "",
                        description: "",
                        pos: hit.worldPos,
                        dir: hit.normal,
                        primitiveIndex: hit.primitiveIndex,
                        barycentric: hit.barycentric,
                        enabled: true,
                        shown: true,
                        labelShown: true,
                        labelOffset: [x - hit.canvasPos[0], y - hit.canvasPos[1] - 30],
                        saved: false
                    });
                }

                context.clearRect(0, 0, canvas.width, canvas.height);

                hit = false;

                draggingLabel = false;
            }
        });

        ctx.onMouseMove(function (x, y) {
            if (draggingLabel) {
                drawLine(x1, y1, x, y);
            }
        });

        var lastx1;
        var lasty1;
        var lastx2;
        var lasty2;

        function drawLine(x1, y1, x2, y2) {

            if (!context) {
                return;
            }

            if (lastx1 !== undefined) {
                context.clearRect(lastx1, lasty1, lastx2, lasty2);
            }

            context.clearRect(0, 0, canvas.width, canvas.height);

            drawCircle(x1, y1, 5.0, 'rgb(255, 255, 255)');
            drawCircle(x1, y1, 2.0, 'rgb(153,0,0)');

            if (x1 !== x2 && y1 !== y2) {

                context.beginPath();
                context.moveTo(x1, y1);
                context.lineTo(x2, y2);
                context.lineWidth = 1;
                context.strokeStyle = '#ffffff';
                context.stroke();

                lastx1 = x1;
                lasty1 = y1;
                lastx2 = x2;
                lasty2 = y2;
            }
        }

        var drawCircle = function (x, y, radius, color) {
            context.fillStyle = color;
            context.beginPath();
            context.arc(x, y, radius, 0, 2 * Math.PI);
            context.fill();
        };
    });;(function () {
    "use strict";

    var cameraRotateX = Human.view.camera.rotateSceneX;
    var cameraRotateY = Human.view.camera.rotateSceneY;

    // First-person mode
    // When true, look rotates about eye, otherwise eye rotates about look
    var firstPerson = false;

    Human.properties.subscribe({
        propId: "input.cameraFirstPerson",
        value: firstPerson,
        callback: function (value) {
            firstPerson = value;
            if (firstPerson) {
                cameraRotateX = Human.view.camera.rotateLookX;
                cameraRotateY = Human.view.camera.rotateLookY;
            }
        }
    });


    // Camera input orbit mode
    // only effective when firstPerson == false
    // When true, orbit input leads to a specialized mode of camera movement: mimicing rotate the scene
    // otherwise eye rotates about look
    var rotateScene = false;

    Human.properties.subscribe({
        propId: "input.cameraRotateScene",
        value: rotateScene,
        callback: function (value) {
            rotateScene = value;
            if (!firstPerson) {
                if (rotateScene) {
                    cameraRotateX = Human.view.camera.rotateSceneX;
                    cameraRotateY = Human.view.camera.rotateSceneY;
                } else {
                    cameraRotateX = Human.view.camera.rotateX;
                    cameraRotateY = Human.view.camera.rotateY;
                }
            }
        }
    });




    // --------Mouse-----------

    /**
     * Pans or orbits camera with mouse drags
     */

    var mouseCameraOrbit = true;

    Human.properties.subscribe({
        propId: "input.mouseOrbitPan",
        value: "orbit",
        callback: function (value) {
            mouseCameraOrbit = value === "orbit";
        }
    });

    Human.input.addHandler(
        function (ctx) {
            var orbitSensitivity = 0.5;
            var panSensitivity = 0.2;

            var lastX;
            var lastY;
            var xDelta = 0;
            var yDelta = 0;
            var down = false;
            var eyeVec = Human.math.vec3();
            var lookVec = Human.math.vec3();
            var tempVec3 = Human.math.vec3();

            ctx.onMouseDown(function (x, y) {
                // Only left mouse down starts pan/orbit
                down = true;
                lastX = x;
                lastY = y;
            });

            ctx.onMouseUp(function () {
                down = (ctx.mouseDownLeft || ctx.mouseDownMiddle || ctx.mouseDownRight);
            });

            ctx.onMouseMove(function (x, y) {
                if (down) {
                    xDelta += (x - lastX) * orbitSensitivity;
                    yDelta += (y - lastY) * orbitSensitivity;
                    lastX = x;
                    lastY = y;
                }
            });

            ctx.onTick(function () {
                if (Math.abs(xDelta) > 0 || Math.abs(yDelta) > 0) {

                    // When in pan mode, shift-drag should orbit, when in orbit mode, shift-drag should pan.
                    var switchMode =  ctx.keyDown[Human.input.KEY_SHIFT] ||
                        ctx.mouseDownMiddle ||
                        (ctx.mouseDownLeft && ctx.mouseDownRight);

                    var mode = switchMode ? !mouseCameraOrbit : mouseCameraOrbit;

                    if (mode) {

                        // Orbiting

                        cameraRotateY(-xDelta * orbitSensitivity);
                        cameraRotateX(yDelta * orbitSensitivity);

                    } else {

                        // Panning (vary based on distance)

                        var camera = Human.view.camera;
                        var eye = camera.eye;
                        var look = camera.look;

                        eyeVec[0] = eye.x;
                        eyeVec[1] = eye.y;
                        eyeVec[2] = eye.z;

                        lookVec[0] = look.x;
                        lookVec[1] = look.y;
                        lookVec[2] = look.z;

                        Human.math.subVec3(eyeVec, lookVec, tempVec3);
                        var lenLook = Math.abs(Human.math.lenVec3(tempVec3));
                        var f = lenLook / 50;

                        f *= panSensitivity;

                        Human.view.camera.pan({
                            x: xDelta * f,
                            y: yDelta * f
                        });
                    }


                    xDelta = 0;
                    yDelta = 0;
                }
            });
        });

    /**
     * Zoom camera with mouse wheel
     */

    var cameraZoomMouseWheelEnabled = true;

    Human.properties.subscribe({
        propId: "ui.zoom.mouseWheel.enabled",
        value: cameraZoomMouseWheelEnabled,
        callback: function (value) {
            cameraZoomMouseWheelEnabled = !!value;
        }
    });

    Human.input.addHandler(
        function (ctx) {
            var delta = 0;
            var target = 0;
            var newTarget = false;
            var targeting = false;
            var progress = 0;
            var sensitivity = 0.2;
            var eyeVec = Human.math.vec3();
            var lookVec = Human.math.vec3();
            var tempVec3 = Human.math.vec3();

            var lastTime;

            var altDown = false;

            ctx.onKeyDown([
                    Human.input.KEY_ALT
                ],
                function () {
                    altDown = true;
                });

            ctx.onKeyUp([
                    Human.input.KEY_ALT
                ],
                function () {
                    altDown = false;
                });

            ctx.onMouseWheel(function (event, d) {

                if (!cameraZoomMouseWheelEnabled) {
                    return;
                }

                if (altDown) { // ALT is used for exploding with mousewheel
                    return;
                }

                delta = -d;
                if (delta === 0) {
                    targeting = false;
                    newTarget = false;
                } else {
                    newTarget = true;
                }
            });

            ctx.onTick(function (time) {

                if (!cameraZoomMouseWheelEnabled) {
                    return;
                }

                var camera = Human.view.camera;
                var eye = camera.eye;
                var look = camera.look;
                eyeVec[0] = eye.x;
                eyeVec[1] = eye.y;
                eyeVec[2] = eye.z;

                lookVec[0] = look.x;
                lookVec[1] = look.y;
                lookVec[2] = look.z;

                Human.math.subVec3(eyeVec, lookVec, tempVec3);
                var lenLook = Math.abs(Human.math.lenVec3(tempVec3));
                var lenLimits = camera.maxZoom - camera.minZoom;
                var f = sensitivity * (2.0 + (lenLook / lenLimits));

                if (newTarget) {
                    target = delta * f;
                    progress = 0;
                    newTarget = false;
                    targeting = true;
                }

                if (targeting) {
                    if (delta > 0) {
                        progress += 0.2 * f;
                        if (progress > target) {
                            targeting = false;
                        }
                    } else if (delta < 0) {
                        progress -= 0.2 * f;
                        if (progress < target) {
                            targeting = false;
                        }
                    }
                    if (targeting) {
                        Human.view.camera.zoom(progress);
                    }
                }

                lastTime = time;
            });
        });







    // ---------Keyboard-----------

    /**
     * Orbits camera with keyboard
     */
    Human.input.addHandler(
        function (ctx) {
            var yawRate = 50;
            var pitchRate = 50;

            ctx.onTick(
                function (time, elapsed) {
                    if (!ctx.ctrlDown && !ctx.altDown) {
                        var left = ctx.keyDown[Human.input.KEY_LEFT_ARROW];
                        var right = ctx.keyDown[Human.input.KEY_RIGHT_ARROW];
                        var up = ctx.keyDown[Human.input.KEY_UP_ARROW];
                        var down = ctx.keyDown[Human.input.KEY_DOWN_ARROW];
                        if (left || right || up || down) {
                            var yaw = 0;
                            var pitch = 0;
                            if (right) {
                                yaw = -elapsed * yawRate;
                            } else if (left) {
                                yaw = (elapsed * yawRate);
                            }
                            if (down) {
                                pitch = -(elapsed * pitchRate);
                            } else if (up) {
                                pitch = (elapsed * pitchRate);
                            }
                            if (Math.abs(yaw) > Math.abs(pitch)) {
                                pitch = null;
                            } else {
                                yaw = null;
                            }

                            cameraRotateY(yaw);
                            cameraRotateX(pitch);
                        }
                    }
                });
        });

    /**
     * Pans camera with keyboard
     */
    Human.input.addHandler(
        function (ctx) {
            var panRate = 10;

            ctx.onTick(
                function (time, elapsed) {
                    if (!ctx.ctrlDown && !ctx.altDown) {
                        var w = ctx.keyDown[Human.input.KEY_W];
                        var s = ctx.keyDown[Human.input.KEY_S];
                        var a = ctx.keyDown[Human.input.KEY_A];
                        var d = ctx.keyDown[Human.input.KEY_D];
                        if (w || s || a || d) {
                            var x = 0;
                            var y = 0;
                            var z = 0;
                            if (s) {
                                y = elapsed * panRate;
                            } else if (w) {
                                y = -elapsed * panRate;
                            }
                            if (d) {
                                x = elapsed * panRate;
                            } else if (a) {
                                x = -elapsed * panRate;
                            }
                            Human.view.camera.pan({x: x, y: y, z: z});
                        }
                    }
                });
        });

    /**
     * Zooms camera with keyboard
     */
    Human.input.addHandler(
        function (ctx) {
            var rate = 3;

            ctx.onTick(
                function (time, elapsed) {
                    if (!ctx.ctrlDown && !ctx.altDown) {
                        var z = ctx.keyDown[Human.input.KEY_ADD] ||
                            ctx.keyDown[Human.input.KEY_EQUAL_SIGN] ||
                            ctx.keyDown[Human.input.KEY_EQUAL_SIGN_FIREFOX];
                        var x = ctx.keyDown[Human.input.KEY_SUBTRACT] ||
                            ctx.keyDown[Human.input.KEY_DASH] ||
                            ctx.keyDown[Human.input.KEY_DASH_FIREFOX];
                        if (z || x) {
                            var delta = z ? -(elapsed * rate) : elapsed * rate;
                            Human.view.camera.zoom(delta);
                        }
                    }
                });
        });

    /**
     * Selects predefined camera with keyboard
     */
    Human.input.addHandler(
        function (ctx) {
            ctx.onKeyDown([
                Human.input.KEY_NUM_1,
                Human.input.KEY_NUM_2,
                Human.input.KEY_NUM_3,
                Human.input.KEY_NUM_4,
                Human.input.KEY_NUM_5,
                Human.input.KEY_NUM_6
            ],
                function (key) {
                    if (!ctx.ctrlDown && !ctx.altDown) {
                        var camera = Human.view.camera;
                        if (key === Human.input.KEY_NUM_1) {
                            camera.viewAnterior();
                        } else if (key === Human.input.KEY_NUM_2) {
                            camera.viewPosterior();
                        } else if (key === Human.input.KEY_NUM_3) {
                            camera.viewRight();
                        } else if (key === Human.input.KEY_NUM_4) {
                            camera.viewLeft();
                        } else if (key === Human.input.KEY_NUM_5) {
                            camera.viewSuperior();
                        } else if (key === Human.input.KEY_NUM_6) {
                            camera.viewInferior();
                        }
                    }
                });
        });




    //-----------Touch-------------

    /**
     * Touch to interact with the camera
     */
    Human.input.addHandler(
        function (ctx) {
            var ROTATE_SENSITIVITY = 0.2;
            var PAN_SENSITIVITY = 0.16;
            var PAN_RATE = 1;
            var PINCH_ZOOM_SENSITIVITY = 0.1;

            // camera util
            var camera = Human.view.camera;
            var eyeVec = Human.math.vec3();
            var lookVec = Human.math.vec3();
            var tempVec3 = Human.math.vec3();

            var getZoom = function (xDelta, yDelta) {
                var distance = Math.sqrt((Math.pow(xDelta, 2)) + (Math.pow(yDelta, 2))); // a^2 * b^ = c^
                return distance * PINCH_ZOOM_SENSITIVITY;
            };

            // zoom in
            ctx.onTouchPinch(function (params) {
                var zoom = getZoom(params.xDelta, params.yDelta);
                camera.zoom(zoom);
            });
            // zoom out
            ctx.onTouchZoom(function (params) {
                var zoom = getZoom(params.xDelta, params.yDelta);
                camera.zoom(-zoom);
            });

            // panning
            ctx.onTouchPan(function (params) {
                var eye = camera.eye;
                var look = camera.look;

                eyeVec[0] = eye.x;
                eyeVec[1] = eye.y;
                eyeVec[2] = eye.z;

                lookVec[0] = look.x;
                lookVec[1] = look.y;
                lookVec[2] = look.z;

                Human.math.subVec3(eyeVec, lookVec, tempVec3);
                var lenLook = Math.abs(Human.math.lenVec3(tempVec3));
                var lenLimits = camera.maxZoom - camera.minZoom;
                var f = PAN_SENSITIVITY * (lenLook / lenLimits);

                var xDelta = params.xDelta * f;
                var yDelta = params.yDelta * f;

                camera.pan({ x: xDelta * PAN_RATE, y: yDelta * PAN_RATE });
            });

            // camera rotation
            ctx.onTouchMove(function (params) {
                var rotateX = params.xDelta * ROTATE_SENSITIVITY;
                var rotateY = params.yDelta * ROTATE_SENSITIVITY;
                var multiTouch = params.touches.length > 1;
                // rotate
                if (!multiTouch) {
                    cameraRotateX(rotateY);
                    cameraRotateY(-rotateX);
                }
            });
        });


})();
;Human.input.addHandler(
    function (ctx) {
        "use strict";

        var lastX = null;
        var lastY = null;
        var tolerance = 4; // Pixels
        var timeout = null;
        var mouseDown = false;

        var hoverTime = 500; // Miliseconds

        // Delay before triggering a hover pick
        Human.properties.subscribe({
            propId: "pick.hover.delay",
            value: hoverTime,
            callback: function (value) {
                hoverTime = value;
            }
        });

        ctx.onReset(function () {
            reset();
        });

        function reset() {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            lastX = null;
            lastY = null;
            Human.view.pick.hoverOff();
        }

        ctx.onMouseMove(function (x, y) {
            if (mouseDown) {
                return;
            }
            if (lastX !== null) {
                if (Math.abs(x - lastX) > tolerance || Math.abs(y - lastY) > tolerance) {
                    reset();
                } else {
                    if (timeout) {
                        clearTimeout(timeout);
                        timeout = null;
                    }
                    Human.view.pick.hoverOff();
                    timeout = setTimeout(
                        function () {
                            Human.view.pick.hoverPick({ canvasX: x, canvasY: y });
                            clearTimeout(timeout);
                            timeout = null;
                            lastX = null;
                            lastY = null;
                        }, hoverTime );
                }
            }
            lastX = x;
            lastY = y;
        });

        ctx.onMouseDown(function () {
            reset();
            mouseDown = true;
        });

        ctx.onMouseUp(function (x, y) {
            lastX = x;
            lastY = y;
            mouseDown = false;
        });
    });;Human.input.addHandler(
    function (ctx) {
        "use strict";

        var lastX = null;
        var lastY = null;
        var tolerance = 4;
        var picked = false;
        var doubleClicked = false;
        var mouseDownLeft = false;
        var mouseDownRight = false;
        var spaceDown = false;
        var ctrlDown = false;
        var rDown = false;
        var pickX;
        var pickY;

        ctx.onKeyDown([
                Human.input.KEY_SHIFT
            ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.CTRL) {
                    switch (key) {
                        case Human.input.KEY_SHIFT:
                            Human.view.pick.setMultiPickEnabled(true);
                            break;
                    }
                }
            });

        ctx.onKeyUp([
                Human.input.KEY_SHIFT
            ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.CTRL) {
                    switch (key) {
                        case Human.input.KEY_SHIFT:
                            Human.view.pick.setSinglePickEnabled(true);
                            break;
                    }
                }
            });

        ctx.onKeyDown([
                Human.input.KEY_SPACE
            ],
            function () {
                spaceDown = true;
            });

        ctx.onKeyUp([
                Human.input.KEY_SPACE
            ],
            function () {
                spaceDown = false;
            });

        ctx.onKeyDown([
                Human.input.KEY_CTRL
            ],
            function () {
                ctrlDown = true;
            });

        ctx.onKeyUp([
                Human.input.KEY_CTRL
            ],
            function () {
                ctrlDown = false;
            });

        ctx.onKeyDown([
                Human.input.KEY_R
            ],
            function () {
                rDown = true;
            });

        ctx.onKeyUp([
                Human.input.KEY_R
            ],
            function () {
                rDown = false;
            });

        ctx.onMouseDown(function (x, y) {
            lastX = x;
            lastY = y;
            mouseDownLeft = ctx.mouseDownLeft;
            mouseDownRight = ctx.mouseDownRight;
        });

        ctx.onMouseUp(function (x, y) {
            if (Math.abs(lastX - x) < tolerance && Math.abs(lastY - y) < tolerance) {
                pickX = x;
                pickY = y;
                picked = true;
            }
        });

        ctx.onMouseDoubleClick(function (x, y) {
            if (Math.abs(lastX - x) < tolerance && Math.abs(lastY - y) < tolerance) {
                pickX = x;
                pickY = y;
                picked = true;
                doubleClicked = true;
                mouseDownLeft = ctx.mouseDownLeft;
                mouseDownRight = ctx.mouseDownRight;
            }
        });

        ctx.onTick(function () {
            if (picked) {
                var params = {
                    canvasX: pickX,
                    canvasY: pickY,
                    mouseDownLeft: mouseDownLeft,
                    mouseDownRight: mouseDownRight,
                    spaceDown: spaceDown,
                    ctrlDown: ctrlDown,
                    regionPick: rDown
                };
                if (doubleClicked) {
                    Human.view.pick.doublePick(params);
                } else {
                    Human.view.pick.pick(params);
                }
                picked = false;
                doubleClicked = false;
                lastX = null;
                lastY = null;
            }
        });
    });
;Human.input.addHandler(
    function (ctx) {
        "use strict";

        // picking
        ctx.onTouchTap(function (params) {
            var touches = params.touches;
            Human.view.pick.pick({ canvasX: touches[0].x, canvasY: touches[0].y });
        });

        // double picking
        ctx.onTouchDoubleTap(function (params) {
            var touches = params.touches;
            Human.view.pick.doublePick({ canvasX: touches[0].x, canvasY: touches[0].y });
        });
    });
;/**
 * Selects view mode with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        ctx.onKeyDown([
            Human.input.KEY_R,
            Human.input.KEY_T,
            Human.input.KEY_I,
            Human.input.KEY_Y,
            Human.input.KEY_Z,
            Human.input.KEY_C
        ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    switch (key) {
                        case  Human.input.KEY_R:
                            Human.rpc.call(null, "highlight.setEnabled", { enable: true });
                            break;
                        case  Human.input.KEY_T:
                            Human.rpc.call(null, "xray.setEnabled", { enable: true });
                            break;
                        case  Human.input.KEY_I:
                            Human.rpc.call(null, "isolate.setEnabled", { enable: true });
                            break;
                    }
                }

                if (ctx.ctrlDown && !ctx.altDown) {
                    switch (key) {
                        case Human.input.KEY_Y:
                            Human.view.dissect.redo();
                            break;

                        case Human.input.KEY_Z:
                            Human.view.dissect.undo();
                            break;

                        case Human.input.KEY_R:
                            Human.init.reset();
                            break;

                        case Human.input.KEY_C:
                            Human.rpc.call(null, "dissect.setEnabled", { enable: true });
                            break;
                    }
                }
            });
    });;/**
 * Moves active cross-section with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var moveRate = 10.0;
        var clipPlaneShownByThis = null;
        var timeLast;

        ctx.onTick(
            function (time) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    var m = ctx.keyDown[Human.input.KEY_M];
                    var n = ctx.keyDown[Human.input.KEY_N];
                    if (m || n) {
                        if (!Human.view.clip.selectedClip) {
                            return;
                        }
                        if (timeLast) {
                            var elapsed = (time - timeLast) / 1000.0; // Scale to seconds
                            var z;
                            if (n) {
                                z = elapsed * moveRate;
                            } else if (m) {
                                z = -elapsed * moveRate;
                            }
                            var clip = Human.view.clip.selectedClip;
                            if (!clip.shown) {
                                clipPlaneShownByThis = clip.clipId;
                            }
                            Human.view.clip.setClip({
                                state: Human.view.clip.Plane.STATE_VISIBLE,
                                progress: clip.progress + z
                            });
                            return true; // Updated
                        }

                        timeLast = time;
                    } else {
                        timeLast = null;
                        if (clipPlaneShownByThis) {
                            Human.view.clip.setClip({
                                clipId: clipPlaneShownByThis,
                                state: Human.view.clip.Plane.STATE_CLIPPING
                            });
                            clipPlaneShownByThis = null;
                        }
                    }
                }
            });
    });;/**
* Toggles the dissect state
*/
Human.input.addHandler(
    function (ctx) {
        "use strict";

        // track keyboard enable state
        var enabledOnKeyPress = false;

        ctx.onKeyDown([
            Human.input.KEY_X
        ],
            function () {
                if (ctx.ctrlDown && !ctx.altDown && !enabledOnKeyPress) {
                    Human.view.dissect.setEnabled(true);
                    enabledOnKeyPress = true;
                }
            });
        ctx.onKeyUp([
            Human.input.KEY_X
        ],
            function () {
                if (enabledOnKeyPress) {
                    Human.view.dissect.setEnabled(false);
                    enabledOnKeyPress = false;
                }
            });
    });;/**
 * Resets engine to the state it was in after it fired "started"
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        ctx.onKeyDown([
            Human.input.KEY_R
        ],
            function () {
                if (ctx.keyDown[Human.input.KEY_SHIFT]) {
                    var confirmText = 'This will reset to the initial view. Are you sure you want to continue?';

                    if(confirm(confirmText)) {
                        ctx.keyDown[Human.input.KEY_SHIFT] = false;
                        Human.init.reset();
                    }
                }
            });
    });;(function () {
    "use strict";

    var enabled = Human.request.getSearchParam("explode") === "true";
    var altDown = false;

    var scale = 0;
    var lastTime = 0;

    Human.input.addHandler(
        function (ctx) {

            ctx.onKeyDown([
                    Human.input.KEY_ALT
                ],
                function () {
                    altDown = true;
                });

            ctx.onKeyUp([
                    Human.input.KEY_ALT
                ],
                function () {
                    altDown = false;
                });


            ctx.onMouseWheel(function (event, d) {

                if (!enabled) {
                    return;
                }

                if (!altDown) {
                    return;
                }

                var t = event.timeStamp * 0.001;

                //var speed = (lastTime > 0) ? (1.0 / (t - lastTime)) * 0.01 : 1.0;

                lastTime = t;

                scale += d * 1.0;

                if (scale < 0.0) {
                    scale = 0.0;
                }

                Human.view.explode.explode({ scale: scale, speed: 10 });
            });

        });

})();;/**
 * @namespace The 3D scene, consisting of a hierarchy of {@link Human.scene.Object}s.
 */
(function () {
    "use strict";

    var HumanScene = Human.scene = {};

    // TODO: What is this doing here!?
    HumanScene.checkTestStarted = false;	//Control variable to enable/disable the label feature.

    /** Array of root objects
     *
     * @type {Array}
     * @memberof Human.scene
     */
    HumanScene.rootObjects = [];

    /**
     * A map of objects by ID for each model that's currently loaded
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.modelObjects = {};

    /** All objects by ID
     *
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.objects = {};

    /** All objects by FMA ID
     *
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.objectsByFMAID = {};

    /**
     * For each distinct object meta tag, a map of object IDs to object instances.
     *
     * Eg.
     *
     * <pre>
     * {
     *     "head": {
     *          "maleAdult_frontal_bone": <object>,
     *          "maleAdult_mandible": <object>
     *     },
     *     "skeleton": {
     *          "maleAdult_frontal_bone": <object>,
     *          "maleAdult_mandible": <object>
     *     },
     *     "digestion": {
     *          "maleAdult_mandible": <object>
     *     }
     * }
     * </pre>
     * @type {{}}
     */
    HumanScene.objectsForTags = {};

    /** Count of all objects in scene
     *
     * @type {number}
     * @memberof Human.scene
     */
    HumanScene.numObjects = 0;

    HumanScene._boundary = null;

    /**
     * @memberof Human.scene
     * @type {Array}
     */
    HumanScene.center = [0, 0, 0];

    /**
     * Map of flags for the currently visible objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
    HumanScene.enabledObjects = {};           // Enabled objects

    /**
     * Map of flags for the currently selected objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
    HumanScene.selectedObjects = {};          // Selected objects, which are not neccessarily enabled

    /**
     * Map of flags for the currently transparent objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
    HumanScene.transparentObjects = {};

    /**
     * Map of flags for pick-through objects, keyed by object ID
     * @memberof Human.scene
     *
     * @type {{}}
     */
    HumanScene.pickThroughObjects = {};

    /**
     * Map of flags for desaturated objects, keyed by object ID
     * @memberof Human.scene
     *
     * @type {{}}
     */
    HumanScene.desaturatedObjects = {};

    /**
     * Map of flags for objects whose backfaces are always shown, keyed by object ID
     * @memberof Human.scene
     *
     * @type {{}}
     */
    HumanScene.backfaceObjects = {};

    /**
     * True when only the currently selected objects are allowed to be visible
     * @memberof Human.scene
     * @type {boolean}
     */
    HumanScene.showSelectedObjects = false;   // When true, only selected objects shown, else all shown

    HumanScene.alwaysEnabledObjects = {};     // Objects that cannot be disabled
    HumanScene._leavesCache = {};

    /**
     * Creates an object
     *
     * <p>Object is not yet enabled or selected</p>
     *<pre>
     * createObject({
     *
     *      // All objects, leaf and branch
     *
     *      moduleId:         "maleAdult",
     *      objectId:         "Left_posterior_auricular_artery_49626",
     *      displayName:    "Left Posterior Auricular Artery"
     *      parentObjectId: "Anatomy",
     *
     *      // Leaf objects only:
     *
     *      materialId:     "bloodsupply01_blinn43SG",
     *      geometryId:     "Left_posterior_auricular_artery_49626Shape",
     *      attachObjectId : "the-scene-root" | undefined,
     *      pickable:       true,
     *      layerName:      "Muscular_System"
     *
     *      flags: {
     *          transparency:       0.2,
     *          pickable:           false,
     *          renderPriority:     0 | null
     *      }
     * });
     * </pre>
     *
     * @memberof Human.scene
     * @private
     */

    HumanScene.__createObject = function (params) {
        //  if (!params.displayName) {
//            throw Human.fatalError("params.displayName expected");
//        }

        if (!params.moduleId) {
            Human.log.error("Scene.__createObject", "Param expected: moduleId");
            return;
        }

        if (!params.objectId) {
            Human.log.error("Scene.__createObject", "Param expected: objectId");
            return;
        }

        // Can't have duplicate object or fmaId's
        if (HumanScene.objects[params.objectId]) {
            Human.log.error("Scene.__createObject", "Param: objectId already in use");
            return;
        }

        var parent = params.parentObjectId ? HumanScene.objects[params.parentObjectId] : null;
        var modelId = params.modelId;

        // Inherit metatags from parent object

        params.tags = params.tags || [];

        var tags = parent ? HumanScene._inheritTags(params.tags, parent) : params.tags;

        params.modelId = modelId;
        params.parent = parent;
        params.attachNodeId = Human.CONTENT_ROOT_ID;
        params.level = parent ? parent.level + 1 : 0;
        params.tags = tags;

        var object = new Human.scene.Object(params);

        HumanScene.objects[params.objectId] = object;
        if (object.fmaId) {
            HumanScene.objectsByFMAID[object.fmaId] = object;
        }
        if (parent) {
            parent.__addObject(object);
        } else {
            HumanScene.rootObjects.push(object); // Register on roots map
        }

        (HumanScene.modelObjects[modelId] = HumanScene.modelObjects[modelId] || {})[params.objectId] = object;

        HumanScene._registerObjectForTags(object);

        HumanScene.numObjects++;

        HumanScene._boundary = null; // Now needs lazy-recompute

        // Publish object creation
        Human.events.fire("scene.objectCreated", {
            moduleId: params.moduleId,
            modelId: modelId,
            objectId: object.objectId,
            name: object.displayName,
            description: object.description,
            displayName: object.displayName,
            fmaId: object.fmaId,
            tags: object.tags,
            parentObjectId: parent ? parent.objectId : null
        });

        return object;
    };

    HumanScene._inheritTags = function(childTags, parentObject) {
        var tags = childTags || [];
        var parentTags = parentObject.tags;
        var tag;
        var parentTag;
        var inheritTags = [];
        if (tags) {
            for (var i = 0, leni = parentTags.length; i < leni; i++) {
                parentTag = parentTags[i];
                var inherit = true;
                for (var j = 0, lenj = tags.length; j < lenj; j++) {
                    tag = tags[j];
                    if (tag === parentTag) {
                        inherit = false;
                    }
                }
                if (inherit) {
                    inheritTags.push(parentTag);
                }
            }
            return tags.concat(inheritTags);
        } else {
            return tags;
        }
    };

    HumanScene._registerObjectForTags = function(object) {
        var tags = object.tags;
        var tag;
        var tagObjects;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagObjects = HumanScene.objectsForTags[tag];
            if (!tagObjects) {
                tagObjects = HumanScene.objectsForTags[tag] = {};
            }
            tagObjects[object.objectId] = object;
        }
    };

    HumanScene._deregisterObjectForTags = function (object) {
        var tags = object.tags;
        var tag;
        var tagObjects;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagObjects = HumanScene.objectsForTags[tag];
            if (tagObjects) {
                delete tagObjects[object.objectId];
            }
        }
    };


//    HumanScene._geometryLoaded = function (object) {
//        HumanScene._expandBoundary(HumanScene._boundary, object.getBoundary());
//        HumanScene.center = [
//            (HumanScene._boundary.xmax + HumanScene._boundary.xmin) * 0.5,
//            (HumanScene._boundary.ymax + HumanScene._boundary.ymin) * 0.5,
//            (HumanScene._boundary.zmax + HumanScene._boundary.zmin) * 0.5
//        ];
//    };
//
//    HumanScene._expandBoundary = function (a, b) {
//        if (a.xmin > b.xmin) {
//            a.xmin = b.xmin;
//        }
//        if (a.ymin > b.ymin) {
//            a.ymin = b.ymin;
//        }
//        if (a.zmin > b.zmin) {
//            a.zmin = b.zmin;
//        }
//        if (a.xmax < b.xmax) {
//            a.xmax = b.xmax;
//        }
//        if (a.ymax < b.ymax) {
//            a.ymax = b.ymax;
//        }
//        if (a.zmax < b.zmax) {
//            a.zmax = b.zmax;
//        }
//    };

    /** Returns the {@link Human.scene.Object} corresponding to the given object ID
     * @memberof Human.scene
     */
    HumanScene.getObject = function (objectId) {
        var object = HumanScene.objects[objectId];
        if (!object) {
            Human.log.error("Human.scene.getObject", "Scene object not found: '" + objectId + "'");
        }
        return object;
    };

    /**
     * Enable or disable some or all objects
     * @memberof Human.scene
     */
    HumanScene.setEnabledObjects = function (params) {

        var objects = params.objects || params.objectIds;
        var objectId;

        var enabledObjectsUpdate = {};
        var selectedObjectsUpdate = {};

        /* Clear all selected objects if replacing the selected set
         */
        if (params.replace) {
            for (objectId in HumanScene.enabledObjects) {
                if (HumanScene.enabledObjects.hasOwnProperty(objectId)) {


                    // TODO ability to override this optimization

                    HumanScene.enabledObjects[objectId]._enabledSubObjects = 0;
                    delete HumanScene.enabledObjects[objectId];

                    enabledObjectsUpdate[objectId] = false;

                    if (HumanScene.selectedObjects.hasOwnProperty(objectId)) {
                        HumanScene.selectedObjects[objectId]._selectedSubObjects = 0;
                        delete HumanScene.selectedObjects[ objectId ];
                        selectedObjectsUpdate[objectId] = false;
                    }

                    HumanScene._updateObjectVisibility(objectId);
                }
            }
        }

        /* Build object ID->flag map for trees rooted by given objects
         */
        HumanScene._getEnabledFlagsinSubtreeForObjectMap(objects, enabledObjectsUpdate);

        /* Enable map of objects
         */
        for (objectId in enabledObjectsUpdate) {
            if (enabledObjectsUpdate.hasOwnProperty(objectId)) {
                if (enabledObjectsUpdate[objectId]) {

                    if (!HumanScene.enabledObjects[objectId]) {
                        HumanScene.enabledObjects[objectId] = HumanScene.objects[objectId];
                        HumanScene._updateObjectVisibility(objectId);

                        enabledObjectsUpdate[objectId] = true;
                    }
                } else {

                    if (HumanScene.enabledObjects[objectId]) {

                        delete HumanScene.enabledObjects[objectId];

                        /* Selection of an object forces enabling of it
                         * if it's currently disabled
                         */
                        if (HumanScene.selectedObjects[objectId]) {
                            if (!selectedObjectsUpdate) {
                                selectedObjectsUpdate = {};
                            }
                            delete HumanScene.selectedObjects[objectId];  // Disabling forces deselection
                            selectedObjectsUpdate[objectId] = false;
                        }

                        HumanScene._updateObjectVisibility(objectId);

                        enabledObjectsUpdate[objectId] = false;
                    }
                }
            }
        }

        Human.events.fire("scene.objectsShown", {    // Post-notify
            enabledObjectsUpdate: enabledObjectsUpdate,
            showSelectedObjects: HumanScene.showSelectedObjects
        });

        if (selectedObjectsUpdate) {
            Human.events.fire("scene.objectsSelected", {
                selectedObjectsUpdate: selectedObjectsUpdate,
                showSelectedObjects: HumanScene.showSelectedObjects
            });
        }
    };

    /** Sets the visibility of objects to true/false without affecting enabled status
    * Only enabled objects can have their visibility status changed.
    *
    * @param.objectIds = {objectid:visibility}
    */
    HumanScene.setVisibleObjects = function(params){
        var objects = params.objects || params.objectIds;
        var deep = params.deep || false;

        var enabledObjects = Human.scene.enabledObjects;

        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId) && enabledObjects[objectId]) {
                var object = enabledObjects[objectId];
                var shown = objects[objectId];
                object.show(shown);

                if (deep) {
                    var childInstructions = {};
                    for (var i = 0, len = object.objects.length; i < len; i++) {
                        var childObjectId = object.objects[i].objectId;
                        childInstructions[childObjectId] = shown;
                    }

                    HumanScene.setVisibleObjects({
                        objectIds: childInstructions,
                        deep: true
                    });
                }
            }
        }
    };

    /**
     * Builds enabled flags for objects in given map of enabled flags,
     * in order of objects' level in anatomy hierarchy
     */
    HumanScene._getEnabledFlagsinSubtreeForObjectMap = function (objects, objectFlags) {
        var buckets = HumanScene._sortObjectIDsIntoLevelBuckets(objects);
        var bucket;
        var objectId;
        // Iterate buckets in order, accumulate enabled flags for each object
        for (var i = 0, len = buckets.length; i < len; i++) {
            bucket = buckets[i];
            if (bucket) {
                for (var j = 0, len2 = bucket.length; j < len2; j++) {
                    objectId = bucket[j];
                    HumanScene._getEnabledFlags(objectId, !!objects[objectId], objectFlags);
                }
            }
        }
    };

    /**
     * Sorts given map of object IDs into buckets ordered by ascending
     * order of object levels in anatomy hierarchy
     */
    HumanScene._sortObjectIDsIntoLevelBuckets = function (objectIds) {
        var objectId;
        var buckets = [];
        var bucket;
        var object;
        var level;
        for (objectId in objectIds) {
            if (objectIds.hasOwnProperty(objectId)) {
                object = HumanScene.objects[objectId];
                if (object) {
                    level = object.level;
                    bucket = buckets[level] || (buckets[level] = []);
                    bucket.push(objectId);
                }
            }
        }
        return buckets;
    };

    HumanScene._getEnabledFlags = function (objectId, flag, objectFlags) {
        // Start at the root then go down to leaves and recursively update flags upwards
        // Won't neeed to worry about updating parents
        objectFlags = objectFlags || {};
        var object = HumanScene.objects[objectId];

        if (!object || object._destroyed) {
            return objectFlags;
        }

        var objFlags = HumanScene._getEnabledFlagsInSubtreeForObject(objectId, flag, objectFlags);

        // Happens when grandchildren and descendents' flags are updated, but not parents'
        for (var parent = object.parent; object, parent; object = object.parent, parent = parent.parent) {
            if (parent && flag) {
                if (parent.parent) {
                    object._enabledSubObjects = object._enabledSubObjects || 0;

                    // Add enabled siblings to count -- see if already have another enabled sibling
                    var enabledSib = 0;
                    for (var i = 0; i < parent.objects.length; i++ ) {
                        if (parent.objects[i].objectId === object.objectId) {
                            continue;
                        }
                        if (objectFlags[parent.objects[i].objectId]) {
                            enabledSib++;
                        }
                    }

                    // Only need to recurse and update ancestors once -- first enabled sibling already took care of that
                    if ((parent._enabledSubObjects + enabledSib) === (object._enabledSubObjects + 1)) {
                        HumanScene._updateAncestorSubObjects(parent.parent, flag);
                    } else {
                        break;
                    }
                }
            } else if (parent && !flag) {
                // Now if disabling parents -- then update their subobj count
                if (parent.parent) {
                    object._enabledSubObjects = object._enabledSubObjects || 0;

                    if (parent._enabledSubObjects === object._enabledSubObjects) {
                        HumanScene._updateAncestorSubObjects(parent.parent, flag, objFlags);
                    }
                }
            }
        }

        return objFlags;
    };

    HumanScene._getEnabledFlagsInSubtreeForObject = function(objectId, flag, objectFlags) {
        var object = HumanScene.objects[objectId];

        if (!object || object._destroyed) {
            return objectFlags;
        }

        objectFlags[objectId] = flag;

        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._getEnabledFlagsInSubtreeForObject(objects[i].objectId, flag, objectFlags);
        }

        // Set flags for parents
        var objectEnabled = HumanScene.enabledObjects[objectId];
        if (object.parent) {
            for (var parent = object.parent; parent; parent = parent.parent) {  // Get flags on path to root
                if (parent._enabledSubObjects === undefined || parent._enabledSubObjects === null) {
                    parent._enabledSubObjects = 0;
                }
                if (flag) {
                    if (!objectEnabled) {
                        if (++parent._enabledSubObjects === 1) {
                            objectFlags[parent.objectId] = true;
                        }
                    }
                } else {
                    if (objectEnabled) {
                        if (--parent._enabledSubObjects === 0) {
                            objectFlags[parent.objectId] = false;
                        }
                    }
                }
            }
        }
        return objectFlags;
    };

    HumanScene._updateAncestorSubObjects = function (ancestor, flag, objectFlags) {
        if (ancestor && flag) {
            ancestor._enabledSubObjects++;
            HumanScene._updateAncestorSubObjects(ancestor.parent, flag, objectFlags);
        } else if (ancestor && !flag) {
            if (HumanScene.enabledObjects[ancestor.objectId]) {
                if (--ancestor._enabledSubObjects === 0) {
                    objectFlags[ancestor.objectId] = false;
                }
            }
            HumanScene._updateAncestorSubObjects(ancestor.parent, flag, objectFlags);
        }
    };

    /**
     * Select or disable some or all objects
     * @memberof Human.scene
     */
    HumanScene.setSelectedObjects = function (params) {
        var objects = params.objects || params.objectIds || {};
        var objectId;
        var object;

        var selectedObjectsUpdate = {};


        if (params.objectId) {

            // Selecting a single object

            // Verify object exists
            object = HumanScene.objects[params.objectId];
            if (!object) {
                Human.log.error("Human.scene.setSelectedObjects", "Scene object not found: '" + params.objectId + "'");
                return;
            }

            var select = !!params.select;

            // Unselect all currently selected objects if replacing the selected set
            if (params.replace) {
                for (objectId in HumanScene.selectedObjects) {
                    if (HumanScene.selectedObjects.hasOwnProperty(objectId)) {

                        object = HumanScene.selectedObjects[objectId];
                        object._selectedSubObjects = 0;
                        delete HumanScene.selectedObjects[ objectId ];

                        // Hide object if selected objects are currently visible
                        if (HumanScene.showSelectedObjects) {
                            if (object.shown) {
                                object.show(false);
                            }
                        }

                        selectedObjectsUpdate[objectId] = false;
                    }
                }
            }

            HumanScene._getObjectSelectedFlagsInSubtree(params.objectId, select, selectedObjectsUpdate);

        } else {

            // Selection/deselecting multiple objects

            // Unselect all currently selected objects if replacing the selected set
            if (params.replace) {
                for (objectId in HumanScene.selectedObjects) {
                    if (HumanScene.selectedObjects.hasOwnProperty(objectId)) {
                        object = HumanScene.selectedObjects[ objectId ];
                        object._selectedSubObjects = 0;
                        if (object.selected) {
                            object.select(false);
                        }
                        delete HumanScene.selectedObjects[ objectId ];
                        selectedObjectsUpdate[objectId] = false;
                        HumanScene._updateObjectVisibility(objectId);
                    }
                }
            }

            // Build object ID->flag map for trees rooted by given objects
            HumanScene._getSelectedFlagsInSubtreeForObjectMap(objects, selectedObjectsUpdate);

        } // Multiple select


        /* Defined as soon as disabled object becomes enabled as it is
         * selected - we'll notify of new enables if this is defined
         */
        var enabledObjectsUpdate;

        /* Enable map of objects
         */
        for (objectId in selectedObjectsUpdate) {
            if (selectedObjectsUpdate.hasOwnProperty(objectId)) {
                object = HumanScene.objects[objectId];
                if (selectedObjectsUpdate[objectId]) {
                    if (!HumanScene.selectedObjects[objectId]) {

                        HumanScene.selectedObjects[objectId] = object;

                        /* Selection of an object forces enabling of it
                         * if it's currently disabled
                         */
                        if (!HumanScene.enabledObjects[objectId]) {
                            if (!enabledObjectsUpdate) {
                                enabledObjectsUpdate = {};
                            }
                            enabledObjectsUpdate[objectId] = true;
                            HumanScene.enabledObjects[objectId] = object;
                        }

                        var show = !!((HumanScene.showSelectedObjects) ?
                            HumanScene.selectedObjects[objectId] :  // Object ID will be an owned property
                            HumanScene.enabledObjects[objectId]);

                        if (object.shown !== show) {
                            object.show(show);
                        }

                        if (!object.selected) {
                            object.select(true);
                        }

                        //HumanScene._updateObjectVisibility(objectId);

                        selectedObjectsUpdate[objectId] = true;


                    }
                } else {

                    if (HumanScene.selectedObjects[objectId]) {

                        delete HumanScene.selectedObjects[objectId];      // Deselection leaves object enabled

                        HumanScene._updateObjectVisibility(objectId);

                        if (object.selected) {
                            object.select(false);
                        }

                        selectedObjectsUpdate[objectId] = false;
                    }
                }
            }
        }


        /* Notify of new object enables/disables
         */
        if (enabledObjectsUpdate) {

            Human.events.fire("scene.objectsShown", {
                enabledObjectsUpdate: enabledObjectsUpdate,
                showSelectedObjects: HumanScene.showSelectedObjects
            });
        }

        /* Notify of new object selections/deselections
         */
        Human.events.fire("scene.objectsSelected", {
            selectedObjectsUpdate: selectedObjectsUpdate,
            showSelectedObjects: HumanScene.showSelectedObjects
        });
    };


    /** Builds selected and enabled flags for object enabled flags in given map in order of objects' level in anatomy hierarchy
     */
    HumanScene._getSelectedFlagsInSubtreeForObjectMap = function (objects, objectFlags) {
        var buckets = HumanScene._sortObjectIDsIntoLevelBuckets(objects);
        var bucket;
        var objectId;
        // Iterate buckets in order, accumulate enabled flags for each object
        for (var i = 0, len = buckets.length; i < len; i++) {
            bucket = buckets[i];
            if (bucket) {
                for (var j = 0, len2 = bucket.length; j < len2; j++) {
                    objectId = bucket[j];
                    HumanScene._getObjectSelectedFlagsInSubtree(objectId, !!objects[objectId], objectFlags);
                }
            }
        }
    };

    HumanScene._getObjectSelectedFlagsInSubtree = function (objectId, flag, objectFlags) {
        objectFlags = objectFlags || {};
        var object = HumanScene.objects[objectId];
        if (!object || object._destroyed) {
            return objectFlags;
        }
        objectFlags[objectId] = flag;
        // Set flags for parents
        var objectSelected = HumanScene.selectedObjects[objectId];
        var objectEnabled = HumanScene.enabledObjects[objectId];
        if (object.parent) {
            for (var parent = object.parent; parent; parent = parent.parent) {  // Get flags on path to root
                if (parent._enabledSubObjects === undefined || parent._enabledSubObjects === null) {
                    parent._enabledSubObjects = 0;
                }
                if (parent._selectedSubObjects === undefined || parent._selectedSubObjects === null) {
                    parent._selectedSubObjects = 0;
                }
                if (flag) {
                    if (!objectSelected) {
                        if (++parent._selectedSubObjects === 1) {
                            objectFlags[parent.objectId] = true;
                        }
                    }
                    if (!objectEnabled) {
                        parent._enabledSubObjects++;
                    }
                } else {
                    if (objectSelected) {
                        if (--parent._selectedSubObjects <= 0) {
                            parent._selectedSubObjects = 0; // Safety?
                            objectFlags[parent.objectId] = false;
                        }
                    }
                }
            }
        }
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._getObjectSelectedFlagsInSubtree(objects[i].objectId, flag, objectFlags);
        }
        return objectFlags;
    };

    HumanScene.anySelected = function (leaves) {
        var object;
        for (var key in HumanScene.selectedObjects) {
            if (HumanScene.selectedObjects.hasOwnProperty(key)) {
                object = HumanScene.selectedObjects[key];
                if (leaves) {
                    if (object.numSubObjects === 0) {
                        return true;
                    }
                } else {
                    return true;
                }
            }
        }
        return false;
    };

    /**
     * Sets whether or not to show only the objects that are selected and enabled
     * @memberof Human.scene
     * @param showSelected
     */
    HumanScene.setShowSelectedObjects = function (showSelected) {
        HumanScene.showSelectedObjects = showSelected;
        var object;
        var show;
        for (var objectId in HumanScene.objects) {
            if (HumanScene.objects.hasOwnProperty(objectId)) {
                object = HumanScene.objects[objectId];
                show = !!((HumanScene.showSelectedObjects) ? HumanScene.selectedObjects[objectId] : HumanScene.enabledObjects[objectId]);
                if (object.shown !== show) {
                    object.show(show);
                }
            }
        }
    };

    HumanScene._updateObjectVisibility = function (objectId) {
        var object = HumanScene.objects[objectId];
        var show = !!((HumanScene.showSelectedObjects) ? HumanScene.selectedObjects[objectId] : HumanScene.enabledObjects[objectId]);
        if (object.shown !== show) {
            object.show(show);
        }
    };

    /**
     * Sets which objects may be picked through
     * @param params
     * @memberof Human.scene
     */
    HumanScene.setPickThroughObjects = function (params) {
        var objects = params.objects || params.objectIds || {};
        var objectId;
        // Clear all unpickable objects if replacing the unpickable set
        if (params.replace) {
            for (objectId in HumanScene.pickThroughObjects) {
                if (HumanScene.pickThroughObjects.hasOwnProperty(objectId)) {
                    if (HumanScene.pickThroughObjects[objectId]) {
                        HumanScene.objects[objectId].setPickable(true);
                        delete HumanScene.pickThroughObjects[ objectId ];
                    }
                }
            }
        }
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId) && objects[objectId] === true) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setPickThroughObjects(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setPickThroughObjects = function (object, pickThrough) {
        HumanScene.pickThroughObjects[object.objectId] = pickThrough;
        object.setPickable(!pickThrough);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setPickThroughObjects(objects[i], pickThrough);
        }
    };

    /**
     * Sets which objects are transparent
     * @param params
     * @memberof Human.scene
     */
    HumanScene.setTransparentObjects = function (params) {
        var objects = params.objectIds || {};
        var objectId;
        // Clear all transparent objects if replacing the transparent set
        if (params.replace) {
            for (objectId in HumanScene.transparentObjects) {
                if (HumanScene.transparentObjects.hasOwnProperty(objectId)) {
                    if (HumanScene.transparentObjects[objectId]) {
                        HumanScene.objects[objectId].setTransparent(false, true, true);
                        delete HumanScene.transparentObjects[ objectId ];
                        //            HumanScene._updateObjectVisibility(objectId);
                    }
                }
            }
        }
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId) && objects[objectId] === true) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setTransparentObjects(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setTransparentObjects = function (object, transparent) {
        HumanScene.transparentObjects[object.objectId] = transparent;
        object.setTransparent(transparent, true);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setTransparentObjects(objects[i], transparent);
        }
    };

    HumanScene.getTransparentObjects = function(){
        var result = {};

        var rootObjects = Human.scene.rootObjects;

        function collectTransparent(object){
            if (object.transparent){
                result[object.objectId] = true;
            }
        }

        for (var i = 0, len = rootObjects.length; i < len; i++) {
            rootObjects[i].traverseDown(collectTransparent);
        }

        return result;
    };

    /**
     * Sets which objects appear desaturated
     * @param params
     * @memberof Human.scene
     */
    HumanScene.setDesaturatedObjects = function (params) {
        var objects = params.objects || params.objectIds || {};
        var objectId;
        if (params.replace) {
            for (objectId in HumanScene.desaturatedObjects) {
                if (HumanScene.desaturatedObjects.hasOwnProperty(objectId)) {
                    if (HumanScene.desaturatedObjects[objectId]) {
                        HumanScene.objects[objectId].setDesaturate(false);
                        delete HumanScene.desaturatedObjects[ objectId ];
                    }
                }
            }
        }
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId) && objects[objectId] === true) {
                if (HumanScene.objects[objectId]) {
                    HumanScene._setDesaturatedObjects(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setDesaturatedObjects = function (object, desaturate) {
        HumanScene.desaturatedObjects[object.objectId] = desaturate;
        object.setDesaturate(desaturate);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setDesaturatedObjects(objects[i], desaturate);
        }
    };

    /**
     * Sets which objects appear backface
     * @param params
     * @memberof Human.scene
     */
    HumanScene.setBackfaceObjects = function (params) {
        var objects = params.objects || params.objectIds || {};
        var objectId;
        if (params.replace) {
            for (objectId in HumanScene.backfaceObjects) {
                if (HumanScene.backfaceObjects.hasOwnProperty(objectId)) {
                    if (HumanScene.backfaceObjects[objectId]) {
                        HumanScene.objects[objectId].setBackfaces(false);
                        delete HumanScene.backfaceObjects[ objectId ];
                    }
                }
            }
        }
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId) && objects[objectId] === true) {
                if (HumanScene.objects[objectId]) {
                    HumanScene._setBackfaceObjects(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setBackfaceObjects = function (object, backface) {
        HumanScene.backfaceObjects[object.objectId] = backface;
        object.setTransparentBackfaces(backface);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setBackfaceObjects(objects[i], backface);
        }
    };


    /** When transparent, this sets the degree of "facing ratio" effect for objects, which is
     * where the object becomes more opaque towards the edges.
     * <p>Values are continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} params Degree of effect, between 0 and 1, for each object we want to update
     * @memberof Human.scene
     */
    HumanScene.setObjectGlassFactors = function (params) {
        var objects = params.objectIds || {};
        var objectId;
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setObjectGlassFactors(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setObjectGlassFactors = function (object, glassFactor) {
        object.setGlassFactor(glassFactor, true);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setObjectGlassFactors(objects[i], glassFactor);
        }
    };

    /** When transparent, this sets the degree of "murkiness" effect for objects.
     * <p>Values are continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} params Degree of effect, between 0 and 1, for each object we want to update
     * @memberof Human.scene
     */
    HumanScene.setObjectMurkiness = function (params) {
        var objects = params.objectIds || {};
        var objectId;
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setObjectMurkiness(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setObjectMurkiness = function (object, murkiness) {
        object.setMurkiness(murkiness, true);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setObjectMurkiness(objects[i], murkiness);
        }
    };


    /** Sets the opacity for objects when they are transparent.
     * <p>Values are continuous, in the range [0.0..1.0], where 0.0 is completely transparent, while 1.0 is full opacity.
     *
     * @param {Number} params Degree of effect, between 0 and 1, for each object we want to update
     * @memberof Human.scene
     */
    HumanScene.setObjectOpacities = function (params) {
        var objects = params.objectIds || {};
        var objectId;
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setObjectOpacities(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setObjectOpacities = function (object, opacity) {
        object.setOpacity(opacity, true);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setObjectOpacities(objects[i], opacity);
        }
    };

    /**
     * Returns the IDs of leaf objects within the given tree
     * @param objectId
     * @memberof Human.scene
     */
    HumanScene.getLeaves = function (objectId) {
        var objectIdList = HumanScene._leavesCache[ objectId ];
        if (!objectIdList) {
            objectIdList = [];
            var object = HumanScene.objects[objectId];
            if (object) {
                HumanScene._getLeaves([object], objectIdList);
            }
            HumanScene._leavesCache[ objectId ] = objectIdList;
        }
        return objectIdList;
    };

    HumanScene._getLeaves = function (objects, objectIdList) {
        var object;
        for (var i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            if (object.objects.length === 0) { // Leaf
                objectIdList.push(object.objectId);
            } else {
                HumanScene._getLeaves(object.objects, objectIdList);
            }
        }
    };

    /**
     * Returns the IDs of visible leaf objects within the given tree
     * @param objectId
     * @memberof Human.scene
     */
    HumanScene.getEnabledLeaves = function (objectId) {
        var objectIdList = [];
        var object = HumanScene.objects[objectId];
        if (object) {
            HumanScene._getEnabledLeaves([object], objectIdList);
        }
        return objectIdList;
    };

    HumanScene._getEnabledLeaves = function (objects, objectIdList) {
        var object;
        for (var i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            if (object.objects.length === 0) { // Leaf
                if (HumanScene.enabledObjects.hasOwnProperty(object.objectId)) {
                    objectIdList.push(object.objectId);
                }
            } else {
                HumanScene._getEnabledLeaves(object.objects, objectIdList);
            }
        }
    };

    HumanScene._getKeys = function (map, val) {
        var keys = {};
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                key[key] = val;
            }
        }
        return keys;
    };

    /** Destroys an object and all sub-objects
     */
    HumanScene.destroyObject = function (objectId) {
        var object = HumanScene.objects[objectId];
        if (!object || object._destroyed) {
            return;
        }
        var o, i, len;
        for (i = 0, len = HumanScene.rootObjects.length; i < len; i++) {
            if (HumanScene.rootObjects[i].objectId === objectId) {
                HumanScene.rootObjects.splice(i, 1);
                break;
            }
        }
        delete HumanScene.objects[objectId];                              // Delete object
        if (object.fmaId) {
            delete HumanScene.objectsByFMAID[object.fmaId];
        }

        // Update enabled object counts at higher objects
        // When a higher object has an enabled object count, and this object is enabled, decrement the count
        if (HumanScene.enabledObjects[objectId]) {
            for (o = object.parent; o; o = o.parent) { // Blow away leaves caches on path to root
                if (o._enabledSubObjects !== undefined && o._enabledSubObjects !== null) {
                    o._enabledSubObjects--;
                }
            }
        }

        // Update selected object counts at higher objects
        // When a higher object has a selected object count, and this object is selected, decrement the count
        if (HumanScene.selectedObjects[objectId]) {
            for (o = object.parent; o; o = o.parent) { // Blow away leaves caches on path to root
                if (o._selectedSubObjects !== undefined && o._selectedSubObjects !== null) {
                    o._selectedSubObjects--;
                }
            }
        }

        delete HumanScene.selectedObjects[objectId];                      // Delete from selected objects
        delete HumanScene.enabledObjects[objectId];                       // Delete from enabled objects
        delete HumanScene.transparentObjects[objectId];
        delete HumanScene.pickThroughObjects[objectId];
        delete HumanScene.desaturatedObjects[objectId];
        delete HumanScene.backfaceObjects[objectId];

        HumanScene.numObjects--;
        if (object.parent) {
            object.parent._removeObject(objectId);
        }
        var children = object.objects.slice(0); // Avoid modification during removals
        for (i = 0, len = children.length; i < len; i++) {
            HumanScene.destroyObject(children[i].objectId);
        }
        object._destroy();
        object._destroyed = true;

        // TODO: check
//        for (var o = object.parent; o; o = o.parent) { // Blow away leaves caches on path to root
//            delete HumanScene._leavesCache[o.objectId];
//        }

        delete HumanScene.modelObjects[object.modelId][object.objectId];

        HumanScene._deregisterObjectForTags(object);

        // Will need to recompute leaf object cache
        HumanScene._leavesCache = {};

        // Will need to lazy-recompute boundary
        HumanScene._boundary = null;

        Human.events.fire("scene.objectDestroyed", { objectId: objectId });
    };


    /**
     *
     * @param [params]
     * @param [params.objectId] ID of single object
     * @param [params.objectIds] Array of object IDs
     * @param [params.objects] Map of IDs to objects
     * @returns {*}
     */
    HumanScene.getBoundary = function (params) {

        params = params || {};

        var object;

        if (params.objectId) {

            // Requesting boundary of single object

            object = Human.scene.objects[params.objectId];

            if (object) {
                return object.getBoundary();

            } else {

                // Object not found, log warning and return boundary of entire scene

                Human.log.warn("Human.scene.getBoundary", "Scene object not found: '" + params.objectId + "'");

                return this.getBoundary();
            }
        }

        // Requesting boundary of either all objects or some specified objects
        // Prepare result boundary

        if (!HumanScene._boundary) {

            // Lazy-create boundary

            HumanScene._boundary = {
                xmin: 100000, ymin: 100000, zmin: 100000, xmax: -100000, ymax: -100000, zmax: -100000
            };

        } else {

            // Reset boundary for expansion

            HumanScene._boundary.xmin = 100000;
            HumanScene._boundary.ymin = 100000;
            HumanScene._boundary.zmin = 100000;
            HumanScene._boundary.xmax = -100000;
            HumanScene._boundary.ymax = -100000;
            HumanScene._boundary.zmax = -100000;
        }

        var objectId;
        var boundary = HumanScene._boundary;
        var gotBoundary = false;
        var b;

        if (params.objectIds) {

            // Requesting boundary of multiple objects given as array of IDs

            var objectIds = params.objectIds;

            for (var i = 0, len = objectIds.length; i < len; i++) {

                object = HumanScene.objects[objectIds[i]];

                if (object && object.objects.length === 0) { // Leaf object

                    b = object.getBoundary();

                    if (b.xmin < boundary.xmin) {
                        boundary.xmin = b.xmin;
                    }
                    if (b.ymin < boundary.ymin) {
                        boundary.ymin = b.ymin;
                    }
                    if (b.zmin < boundary.zmin) {
                        boundary.zmin = b.zmin;
                    }
                    if (b.xmax > boundary.xmax) {
                        boundary.xmax = b.xmax;
                    }
                    if (b.ymax > boundary.ymax) {
                        boundary.ymax = b.ymax;
                    }
                    if (b.zmax > boundary.zmax) {
                        boundary.zmax = b.zmax;
                    }

                    gotBoundary = true;
                }
            }

        } else if (params.objects) {

            // Requesting boundary of an ID-map of objects

            var objects = params.objects;

            for (objectId in objects) {

                if (objects.hasOwnProperty(objectId) && !!HumanScene.objects[objectId]) {

                    object = HumanScene.objects[objectId];

                    if (object.objects.length === 0) { // Leaf object

                        b = object.getBoundary();

                        if (b.xmin < boundary.xmin) {
                            boundary.xmin = b.xmin;
                        }
                        if (b.ymin < boundary.ymin) {
                            boundary.ymin = b.ymin;
                        }
                        if (b.zmin < boundary.zmin) {
                            boundary.zmin = b.zmin;
                        }
                        if (b.xmax > boundary.xmax) {
                            boundary.xmax = b.xmax;
                        }
                        if (b.ymax > boundary.ymax) {
                            boundary.ymax = b.ymax;
                        }
                        if (b.zmax > boundary.zmax) {
                            boundary.zmax = b.zmax;
                        }

                        gotBoundary = true;
                    }
                }
            }

        } else  {

            // Requesting boundary of all objects

            objects = HumanScene.objects;

            for (objectId in objects) {

                if (objects.hasOwnProperty(objectId)) {

                    object = objects[objectId];

                    if (object.objects.length === 0) { // Leaf object

                        b = object.getBoundary();

                        if (b.xmin < boundary.xmin) {
                            boundary.xmin = b.xmin;
                        }
                        if (b.ymin < boundary.ymin) {
                            boundary.ymin = b.ymin;
                        }
                        if (b.zmin < boundary.zmin) {
                            boundary.zmin = b.zmin;
                        }
                        if (b.xmax > boundary.xmax) {
                            boundary.xmax = b.xmax;
                        }
                        if (b.ymax > boundary.ymax) {
                            boundary.ymax = b.ymax;
                        }
                        if (b.zmax > boundary.zmax) {
                            boundary.zmax = b.zmax;
                        }

                        gotBoundary = true;
                    }
                }
            }
        }


        return gotBoundary ? boundary : {
            xmin: -100, ymin: -100, zmin: -100, xmax: 100, ymax: 100, zmax: 100
        };
    };

    // Single scene-graph traversal to set all properties, defaulting to parent properties.
    // Also has to fire event with published changes.
    HumanScene.setObjectProperties = function(instructions){
        instructions = instructions || {};

        var overrides = {};
        var selectedChanges = {};   // objects that have changed shown property value
        var selectedObjects = {};   // objects that have changed selected property value
        var shownChanges = {};      // objects where shown = true
        var shownObjects = {};      // objects where selected = true

        // Perform update on all objects in scene-graph through downward traversal
        var rootObjects = Human.scene.rootObjects;

        function setProperties(object){
            overrides = instructions[object.objectId] || {};

            // merge with inherited properties from parent
            if (object.parent){
                overrides = Human.scene.sets.union(object.parent.getProperties(), overrides);

                // special handling of glass factor, as it is not needed to be inherited
                overrides.glassFactor = object.glassFactor;
                overrides.murkiness = object.murkiness;
            }

            // Register changes to 'selected' property;
            if (object.selected !== overrides.selected){
                // 'selected' property has changed
                selectedChanges[object.objectId] = overrides.selected;
            }

            // Register changes to 'shown' property
            if (object.shown !== overrides.shown){
                shownChanges[object.objectId] = overrides.shown;
            }

            // register shown and selected objects
            if (overrides.shown){
                shownObjects[object.objectId] = object;
            }

            if (overrides.selected){
                selectedObjects[object.objectId] = object;
            }

            // Do the Update
            object.setProperties(overrides);
        }

        for (var i = 0, len = rootObjects.length; i < len; i++) {
            rootObjects[i].traverseDown(setProperties);
        }

        // Update and Publish Selected Objects
        Human.scene.selectedObjects = selectedObjects;

        Human.events.fire("scene.objectsSelected", {
          selectedObjectsUpdate: selectedChanges,
          showSelectedObjects: HumanScene.showSelectedObjects
        });

        //
        Human.events.fire("scene.objectsShown", {
          enabledObjectsUpdate: shownChanges,
          showSelectedObjects: HumanScene.showSelectedObjects
        });

    };

    //TODO: Query the scene graph to produce a set of concise instructions.
    //HumanScene.getObjectProperties(); //explicit
    //HumanScene.createConciseInstructions(); // concise

})();
;(function () {
    "use strict";

    // HACK: Face winding bug hacks
    // Remove when condition meshes with face winding bug are re-exported

    var hackNeverBackfaces;
    var hackAlwaysBackfaces;

    Human.properties.subscribe({
        propId: "hacks.neverBackfaces",
        value: false,
        callback: function (value) {
            hackNeverBackfaces = value;
        }
    });

    Human.properties.subscribe({
        propId: "hacks.alwaysBackfaces",
        value: false,
        callback: function (value) {
            hackAlwaysBackfaces = value;
        }
    });

    /**
     * @class An object within {@link Human.scene}
     * @param cfg
     * @constructor
     */
    Human.scene.Object = function (cfg) {
        this._init();

        /** ID of module that loaded the model that contains this object
         *
         * @type {moduleId|*}
         */
        this.moduleId = cfg.moduleId;

        /** ID of model that contains this object
         *
         * @type {modelId|*}
         */
        this.modelId = cfg.modelId;

        /** Unique ID of this object
         * @type {String}
         */
        this.objectId = cfg.objectId;

        /** True when this object was not explicitly assigned an ID and has one that's internally generated.
         * @type {String}
         */
        this.anonymous = cfg.anonymous;

        /** FMA ID
         * @type {String}
         */
        this.fmaId = cfg.fmaId;

        /** Z-sorting layer
         * @type {*}
         */
        this.layer = cfg.layer;

        /** Long display name
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /** Short display name
         * @deprecated
         * @type {String}
         */
        this.name = cfg.displayName;

        /** Detailed description
         * @type {String}
         */
        this.description = cfg.description;

        /** Parent object
         * @type @link Human.scene.Object
         */
        this.parent = cfg.parent;

        /** True when this object is shown
         * @type {*|Boolean}
         */
        this.shown = false;

        /** True when this object is selected
         * @type {*|Boolean}
         */
        this.selected = false;

        /** Level in anatomy object hierarchy
         * @type {Number}
         */
        this.level = cfg.level;

        /** True when this object may be picked
         *  @type {Boolean}
         */
        this.pickable = true;

        /** True when this object may be clipped
         *  @type {Boolean}
         */
        this.clippable = true;

        /** True when this object is transparent.
         * <p>When transparent but not X-rayed, the object will retain its texture and color.</p>
         *  @type {Boolean}
         */
        this.transparent = false;
        /** True when this object is X-rayed
         *  @type {Boolean}
         */
        this.xray = false;

        // opacity is 1 if completely opaque
        this.opacity = 1.0;

        /** When transparent, this controls the degree of "facing ratio" effect, which is
         * where the object becomes more opaque towards the edges.
         * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
         *  @type {Number}
         */
        this.glassFactor = cfg.glassFactor !== undefined ? cfg.glassFactor : 1.0;
        /** When transparent, this controls the degree of "murkiness" effect.
         * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
         *  @type {Number}
         */
        this.murkiness = cfg.murkiness !== undefined ? cfg.murkiness : 1.0;

        /** True when object color is desaturated
         * @type {boolean}
         */
        this.desaturate = !!cfg.desaturate;

        /** True when this object is highlighted
         *  @type {Boolean}
         */
        this.highlight = false;

        /**
         * Is this object a skybox?
         */
        this.skybox = cfg.skybox;

        /**
         * Is this object billboarded?
         */
        this.billboard = cfg.billboard;

        /** True when this object may show backfaces.
         *  @type {Boolean}
         */
        this.backfaces = hackAlwaysBackfaces;

        /** True when backfaces are shown in X-Ray mode
         *  @type {Boolean}
         */
        this.transparentBackfaces = false;

        /** False to prevent reversal of frontface vertex winding when object is reflected by a negative scaling transform
         *
         * @type {Boolean}
         */
        this.flip = !!cfg.flip;

        /** Anatomy region metatags
         *
         * @type {Array of String}
         */
        this.tags = cfg.tags;

        /** Number of sub-objects
         *  @type {Number}
         */
        this.numSubObjects = 0;

        /** Number of sub-objects that have finished loading
         *  @type {Number}
         */
        this.numSubObjectsLoaded = 0;

        /** Sub-objects
         *  @type {[Human.scene.Object]}
         */
        this.objects = [];

        // Asset to use for boundary rebuild
        this._boundedAsset = null;

        //
        this._boundaryDirty = true;

        this.geometryId  = cfg.geometryId;
        this.materialId  = cfg.materialId;
        this.transformId = cfg.transformId;
        this.morphId     = cfg.morphId;

        this.attachedAssets = {};
        this._pendingAssets = {};

        var node, flags;

        var material = cfg.material;

        // Root of scene subgraph for this object

        // Eventually, we'll not create roots within roots, where the SceneJS subgraphs for Human objects will
        // be flat, ie. not nested within the SceneJS scene graph. Before we do that however, we need to manage the
        // nested coordinate spaces (ie multiplication of nested matrices) within Human, rather than rely on
        // SceneJS' inherited coordinate spaces, as we do currently.
        this._rootNode = node = Human.renderer.graph.createSubtree(cfg.parent ? cfg.parent._childNodeContainer : null, {
            type: "flags",
            flags: flags
        });

        // Modelling transform - both group and leaf objects have these

        this._transformNode = node = node.addNode({
            type: "xform"
        });

        this._childNodeContainer = this._transformNode;

        /** Material attached to this object
         *  @type {**}
         */
        this.material = null;
        this.region = null;



        if (this.geometryId || this.morphId || cfg.geometry || cfg.morph) {

            // Flags

            flags = this.getDefaultFlags();

            this._xrayBackfaces = false;

            flags.enabled = false;
            flags.pickable = true;

            this._flagsNode = Human.renderer.graph.insertNode(this._rootNode, {
                type: "flags",
                flags: flags
            });

            // Only the leaf objects will have assets

            if (material) {
                this.attachAsset("material", material);
            }

            // Region map

            if (cfg.regionMap) {
                this.regionMap = cfg.regionMap;

                Human.renderer.graph.insertNode(this._rootNode, {
                    type: "regionMap",
                    coreId: cfg.regionMap.node.getCoreId()
                });
            }


            // Within the shader, a billboard will zero the rotation
            // (and scale) elements within the modelling and viewing matrices

            if (cfg.billboard) {
                this._billboardNode = Human.renderer.graph.insertNode(this._rootNode, {
                    type: "billboard",
                    spherical: true // Rotates about X,Y and Z to point directly at eye
                });
            }

            // Pick name

            this._nameNode = Human.renderer.graph.insertNode(this._rootNode, {
                type: "name",
                name: cfg.objectId || "noname"
            });

            // Layer

            var layerPriority = 0; // Default layer

            if (cfg.layer) {
                layerPriority = cfg.layer;
            }

            this._layerNode = Human.renderer.graph.insertNode(this._rootNode, {
                type: "layer",
                priority: layerPriority
            });

            // Shader

            this._shaderNode = Human.renderer.graph.insertNode(this._rootNode, { // Default custom shader
                type: "shader",
                coreId: "standard-shaders-xray"
            });

            // Shader params

            this._shaderParamsNode = Human.renderer.graph.insertNode(this._rootNode, {
                type: "shaderParams",
                params: {
                    transparent: false,
                    xray: false,
                    highlight: false,
                    desaturate: this.desaturate, // Color or monochrome transparency
                    opacity: 1.0,
                    glassFactor: this.glassFactor,
                    skybox: this.skybox,
                    murkiness: this.murkiness
                }
            });

            // Append morph

            if (cfg.morph) {
                this.attachAsset("morph", cfg.morph);
            }

            // Append geometry

            if (cfg.geometry) {
                this.attachAsset("geometry", cfg.geometry);
            }

            this._boundedAsset = cfg.morph ? cfg.morph : cfg.geometry;

        } // if (geometry || morph)

        // Bounding volume indicator

        /**
         * @private
         */
        this._bbox = createBBox();

        // Notify parent that child has been added
        if (this.parent) {
            this.parent._subObjectReady(this);
        }

        // Both branch and leaf nodes can have transform assets

        if (cfg.transform) {

            this.attachAsset("transform", cfg.transform);

        } else {

            // Initial transform
            this.pivot = cfg.pivot ? Human.utils.apply(cfg.pivot, {x: 0, y: 0, z: 0}) : {x: 0, y: 0, z: 0};
            this.translate = cfg.translate ? Human.utils.apply(cfg.translate, {x: 0, y: 0, z: 0}) : {x: 0, y: 0, z: 0};
            this.scale = cfg.scale ? Human.utils.apply(cfg.scale, {x: 1, y: 1, z: 1}) : {x: 1, y: 1, z: 1};
            this.rotate = cfg.rotate ? Human.utils.apply(cfg.rotate, {x: 0, y: 0, z: 0}) : {x: 0, y: 0, z: 0};

            this._buildMatrix();
        }

        // Material 'alpha' is being used to set object's transparency
        if (cfg.material) {
            material = cfg.material.material;
            flags = cfg.material.flags;
            if (material && flags) {
                if (flags.getTransparent()) {
                    this.setOpacity(material.getAlpha()); // default to opaque alpha
                    this.setTransparent(true);
                }
            }
        }

        if (cfg.capColor) {

            // Explicit per-object capColor, provided in data.
            // Won't need to lazy-compute it from material.
            this.capColor = cfg.capColor;

        } else {

            // or gray if no material.
            this.capColor = {
                r: 0.7,
                g: 0.7,
                b: 0.7
            };
        }


        if (this._flagsNode) {
            this._flagsNode.setSolidColor(this.capColor);
        }

    };

    Human.utils.extend(Human.scene.Object, Human.Component);

    /////////////////////////////////////////
    // Applying assets to this object
    /////////////////////////////////////////

    var ASSET_HANDLERS = {
        geometry: function(object, asset) {
            object.geometry = Human.renderer.graph.insertNode(object._rootNode, asset.geometry);
            object._boundedAsset = asset;
            object._boundaryDirty = true;
        },
        morph: function(object, asset) {
            // Needs to be original node (not shared core)
            // Otherwise morph annotations don't work
            object.morph = asset.morphGeometry;

            Human.renderer.graph.insertNode(object._rootNode, asset.morphGeometry);

            // Needs to be original node (not shared core)
            // Otherwise event not fired.
            asset.morphGeometry.on("frameUpdate", function () {
                object._boundaryDirty = true;
            });

            object._boundedAsset = asset;
            object._boundaryDirty = true;
        },
        material: function(object, asset) {
            object.material = asset;

            if (asset.textures) {
                var textures = asset.textures;

                var iTexture;
                var lenTextures;
                for (iTexture = 0, lenTextures = textures.length; iTexture < lenTextures; iTexture++) {
                    if (textures[iTexture]) {
                        Human.renderer.graph.insertNode(object._rootNode, {
                            type: "texture",
                            coreId: textures[iTexture].getCoreId()
                        });
                    }
                }
            }

            if (asset.material) {
                Human.renderer.graph.insertNode(object._rootNode, asset.material);
            }

            if (asset.flags) {
                var flags = Human.utils.apply(asset.flags, object._flagsNode.getFlags());

                object._flagsNode.setFlags(flags);

                if (asset.flags.transparent) {
                    object.setTransparent(true);
                }
            }

            if (asset.reflection) {
                Human.renderer.graph.insertNode(object._rootNode, asset.reflection);
            }

            if (asset.fresnels) {
                var fresnels = asset.fresnels;
                for (var type in fresnels) {
                    if (fresnels.hasOwnProperty(type)) {
                        Human.renderer.graph.insertNode(object._rootNode, fresnels[type]);
                    }
                }
            }
        },
        transform: function(object, asset) {
            object._transform = asset;

            // Update transform immediately from transform asset
            updateTransform();

            // Update whenever the asset changes
            asset.on("updated", updateTransform);

            function updateTransform() {
                object.pivot = asset.pivot;
                object.translate = asset.translate;
                object.scale = asset.scale;
                object.rotate = asset.rotate;

                object._buildMatrix();
            }
        }
    };

    var RENDER_ASSETS = {
        geometry: true,
        material: true,
        transform: true
    };

    Human.scene.Object.prototype.attachAsset = function (type, asset) {
        if (RENDER_ASSETS[type] && this.isLeaf()) {
            this._attachRenderAsset(type, asset);
        } else {
            ASSET_HANDLERS[type](this, asset);
            this.attachedAssets[type] = true;
        }
    };

    Human.scene.Object.prototype._attachRenderAsset = function (type, asset) {
        if (this.isRenderable()) {
            ASSET_HANDLERS[type](this, asset);
            this.attachedAssets[type] = true;
            return;
        }

        this.attachedAssets[type] = true;
        this._pendingAssets[type] = asset;

        if (this.isRenderable()) {
            // Just became renderable!

            var pendingAssets = this._pendingAssets;

            for (var pendingType in pendingAssets) {
                if (pendingAssets.hasOwnProperty(pendingType)) {
                    ASSET_HANDLERS[pendingType](this, pendingAssets[pendingType]);
                }
            }

            this._pendingAssets = {};

            Human.events.fire("scene.objectRenderable", {
                objectId: this.objectId
            });
        }
    };

    Human.scene.Object.prototype.isRenderable = function () {
        return !!(this.attachedAssets.geometry && this.attachedAssets.material &&
                    (this.attachedAssets.transform || !this.transformId));
    };

    Human.scene.Object.prototype.isLeaf = function () {
        return !this.objects || this.objects.length === 0;
    };

    // Notifies objects on path to root that geometry sub-object has loaded.
    Human.scene.Object.prototype._subObjectReady = function (object) {
        this.numSubObjectsLoaded++;
        this._boundaryDirty = true;
        if (this.numSubObjects > 0 && this.numSubObjects === this.numSubObjectsLoaded) {
            // This is a group object and all its sub-objects have loaded
            if (this.parent) {
                // Notify parent
                this.parent._subObjectReady(this);
            }
        }
        // Relay notifications from sub-objects
        if (this.parent) {
            // Notify parent
            this.parent._subObjectReady(object);
        }
    };

    /**
     * Sets modelling transformation for this object
     *
     * @param {*} params Transform
     * @param {*} params.pivot Pivot point
     * @param {*} params.translate Translation vector
     * @param {*} params.scale Scaling vector
     * @param {*} params.rotate Rotation vectors
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setTransform = function (params) {

        if (this._transform) {

            // This object has a transform asset, so direct the update to that.

            // The transform asset will then fire an 'updated' event back at this object,
            // triggering the matrix rebuild.

            this._transform.set(params);
            return;
        }

        // Otherwise, update the transform parameters on this object and rebuild the matrix.
        // @deprecated

        if (params.pivot) {
            if (params.pivot.x !== undefined && params.pivot.x !== null) {
                this.pivot.x = params.pivot.x;
            }
            if (params.pivot.y !== undefined && params.pivot.y !== null) {
                this.pivot.y = params.pivot.y;
            }
            if (params.pivot.z !== undefined && params.pivot.z !== null) {
                this.pivot.z = params.pivot.z;
            }
        }

        if (params.translate) {
            if (params.translate.x !== undefined && params.translate.x !== null) {
                this.translate.x = params.translate.x;
            }
            if (params.translate.y !== undefined && params.translate.y !== null) {
                this.translate.y = params.translate.y;
            }
            if (params.translate.z !== undefined && params.translate.z !== null) {
                this.translate.z = params.translate.z;
            }
        }

        if (params.scale) {
            if (params.scale.x !== undefined && params.scale.x !== null) {
                this.scale.x = params.scale.x;
            }
            if (params.scale.y !== undefined && params.scale.y !== null) {
                this.scale.y = params.scale.y;
            }
            if (params.scale.z !== undefined && params.scale.z !== null) {
                this.scale.z = params.scale.z;
            }
        }

        if (params.rotate) {
            if (params.rotate.x !== undefined && params.rotate.x !== null) {
                this.rotate.x = params.rotate.x;
            }
            if (params.rotate.y !== undefined && params.rotate.y !== null) {
                this.rotate.y = params.rotate.y;
            }
            if (params.rotate.z !== undefined && params.rotate.z !== null) {
                this.rotate.z = params.rotate.z;
            }
        }

        this._buildMatrix();
    };



    var pivotMat = Human.math.mat4();
    var scaleMat = Human.math.mat4();
    var translateMat = Human.math.mat4();
    var rotateZMat = Human.math.mat4();
    var rotateYMat = Human.math.mat4();
    var rotateXMat = Human.math.mat4();
    var tempMat = Human.math.mat4();

    Human.scene.Object.prototype._buildMatrix = function () {
        var pivot = this.pivot;
        var translate = this.translate;
        Human.math.translationMat4v([-pivot.x, -pivot.y, -pivot.z], pivotMat);
        var scale = this.scale;
        Human.math.scalingMat4v([scale.x, scale.y, scale.z], scaleMat);
        Human.math.translationMat4v([translate.x + pivot.x, translate.y + pivot.y, translate.z + pivot.z], translateMat);
        var rotate = this.rotate;
        Human.math.rotationMat4v(rotate.z * Math.PI / 180.0, [0, 0, 1], rotateZMat);
        Human.math.rotationMat4v(rotate.y * Math.PI / 180.0, [0, 1, 0], rotateYMat);
        Human.math.rotationMat4v(rotate.x * Math.PI / 180.0, [1, 0, 0], rotateXMat);
        Human.math.identityMat4(tempMat);
        Human.math.mulMat4(pivotMat, tempMat, tempMat);
        Human.math.mulMat4(scaleMat, tempMat, tempMat);
        Human.math.mulMat4(rotateXMat, tempMat, tempMat);
        Human.math.mulMat4(rotateYMat, tempMat, tempMat);
        Human.math.mulMat4(rotateZMat, tempMat, tempMat);
        Human.math.mulMat4(translateMat, tempMat, tempMat);
        this.matrix = tempMat;
        this._transformNode.setElements(this.matrix);

        this._setBoundaryDirty();

        this._updateFaceWinding();
    };

    Human.scene.Object.prototype._setBoundaryDirty = function () {
        this._boundaryDirty = true;
        this._setSubBoundaryDirty();
        this._setAncestorBoundaryDirty();
    };

    // Returns true if this object is in a negatively-scaled coordinate space
    // where the scaling may be done by this object's transform, or a transform
    // on a parent.
    Human.scene.Object.prototype._inNegativeCoordSpace = function (object) {
        if (object.scale && (object.scale.x < 0 || object.scale.y < 0 || object.scale.z < 0)) {
            return true;
        }
        var parent = object.parent;
        if (!parent) {
            return false;
        }
        return this._inNegativeCoordSpace(parent);
    };

    // Returns true if this object is in a negatively-scaled coordinate space
    // where the scaling may be done by this object's transform, or a transform
    // on a parent.

    var negatedAxisCounts = {x: 0, y: 0, z: 0};

    Human.scene.Object.prototype.getNegatedAxes = function (axes) {
        axes = axes || {};

        negatedAxisCounts.x = 0;
        negatedAxisCounts.y = 0;
        negatedAxisCounts.z = 0;

        this._getAxisInversionCounts(negatedAxisCounts);

        axes.x = negatedAxisCounts.x % 2 === 1;
        axes.y = negatedAxisCounts.y % 2 === 1;
        axes.z = negatedAxisCounts.z % 2 === 1;

        return axes;
    };

    Human.scene.Object.prototype._getAxisInversionCounts = function (counts) {
        if (this.scale) {
            if (this.scale.x < 0) {
                counts.x++;
            }
            if (this.scale.y < 0) {
                counts.y++;
            }
            if (this.scale.z < 0) {
                counts.z++;
            }
        }
        var parent = this.parent;
        if (!parent) {
            return;
        }
        parent._getAxisInversionCounts(counts);
    };

    Human.scene.Object.prototype._setAncestorBoundaryDirty = function () {
        for (var parent = this.parent; parent && !parent._boundaryDirty; parent = parent.parent) {
            parent._boundaryDirty = true;
        }
    };

    Human.scene.Object.prototype._setSubBoundaryDirty = function () {
        var child;
        for (var i = 0, len = this.objects.length; i < len; i++) {
            child = this.objects[i];
            if (!child._boundaryDirty) {
                child._boundaryDirty = true;
                child._setSubBoundaryDirty();
            }

        }
    };

    Human.scene.Object.prototype._updateFaceWinding = function () {

        var flipping = this.flip;
        var neg = this._inNegativeCoordSpace(this);

        if (this._flagsNode) {
            this._flagsNode.setFrontface((flipping || neg) ? "cw" : "ccw");
        }

        for (var i = 0, len = this.objects.length; i < len; i++) {
            this.objects[i]._updateFaceWinding2(neg);
        }
    };

    // Returns true if this object is in a negatively-scaled coordinate space
    // where the scaling may be done by this object's transform, or a transform
    // on a parent.
    Human.scene.Object.prototype._inNegativeCoordSpace = function (object) {
        if (object.scale && (object.scale.x < 0 || object.scale.y < 0 || object.scale.z < 0)) {
            return true;
        }
        var parent = object.parent;
        if (!parent) {
            return false;
        }
        return this._inNegativeCoordSpace(parent);
    };

    Human.scene.Object.prototype._updateFaceWinding2 = function (neg) {

        if (this.scale && (this.scale.x < 0 || this.scale.y < 0 || this.scale.z < 0)) {
            neg = true;
        }

        if (this._flagsNode) {
            this._flagsNode.setFrontface((this.flip || neg) ? "cw" : "ccw");
        }

        for (var i = 0, len = this.objects.length; i < len; i++) {
            this.objects[i]._updateFaceWinding2(neg);
        }
    };

    /**
     * Returns this object's World-space boundary
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Object.prototype.getBoundary = function () {
        if (this._boundaryDirty) {
            this._rebuildBoundary();
        }
        return this._boundary;
    };

    /**
     * Returns this object's World-space matrix
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Object.prototype.getWorldMatrix = function () {
        return this._transformNode.getWorldMatrix();
    };

    /**
     * Gets this object's World-space boundary center
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.getCenter = function () {
        if (this._boundaryDirty) {
            this._rebuildBoundary();
        }
        return this._center;
    };

    Human.scene.Object.prototype._rebuildBoundary = function () {
        if (!this._boundaryDirty) {
            return;
        }

        var i, len;

        // Initial inside-out boundary, ready to expand to fit geometry or sub-objects
        this._boundary = {
            xmin: 1000000.0,
            ymin: 1000000.0,
            zmin: 1000000.0,
            xmax: -1000000.0,
            ymax: -1000000.0,
            zmax: -1000000.0
        };
        // Expand boundary to enclose world-space boundaries of any
        // geometry and morph assets that are referenced by this object
        if (this._boundedAsset) {
            var matrix = this.getWorldMatrix();
            var axisBoundary;
            var worldBoundary;
            var boundedAsset = this._boundedAsset;
            if (typeof boundedAsset.updateBoundary === "function") {
                boundedAsset.updateBoundary();
            }
            axisBoundary = boundedAsset.axisBoundary;
            if (axisBoundary) {
                worldBoundary = this._getBoundary(Human.math.transformPoints3(matrix, axisBoundary.verts));
                this._expandBoundary(this._boundary, worldBoundary);
            }
        }
        // Expand boundary to enclose sub-objects
        var object;
        for (i = 0, len = this.objects.length; i < len; i++) {
            object = this.objects[i];
            if (object._boundaryDirty) {
                object._rebuildBoundary();
            }
            this._expandBoundary(this._boundary, object._boundary);
        }
        // Find center of boundary
        this._center = [
            (this._boundary.xmax + this._boundary.xmin) * 0.5,
            (this._boundary.ymax + this._boundary.ymin) * 0.5,
            (this._boundary.zmax + this._boundary.zmin) * 0.5
        ];
        this._boundaryDirty = false;
        // Show boundary
        this._bbox.setBoundary(this._boundary);
    };

    // Get minimal boundary enclosing the given vertex array
    Human.scene.Object.prototype._getBoundary = function (positions) {
        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var x, y, z;
        for (var i = 0, len = positions.length; i < len; i++) {
            x = positions[i][0];
            y = positions[i][1];
            z = positions[i][2];
            if (x === undefined || x === null ||
                y === undefined || y === null ||
                z === undefined || z === null) {
                continue;
            }
            if (x < xmin) {
                xmin = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (z < zmin) {
                zmin = z;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y > ymax) {
                ymax = y;
            }
            if (z > zmax) {
                zmax = z;
            }
        }
        return {xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax};
    };

    Human.scene.Object.prototype._expandBoundary = function (a, b) {
        if (a.xmin > b.xmin) {
            a.xmin = b.xmin;
        }
        if (a.ymin > b.ymin) {
            a.ymin = b.ymin;
        }
        if (a.zmin > b.zmin) {
            a.zmin = b.zmin;
        }
        if (a.xmax < b.xmax) {
            a.xmax = b.xmax;
        }
        if (a.ymax < b.ymax) {
            a.ymax = b.ymax;
        }
        if (a.zmax < b.zmax) {
            a.zmax = b.zmax;
        }
    };

    /** Add a child object and notify super-objects
     */
    Human.scene.Object.prototype.__addObject = function (object) {
        this.objects.push(object);
        this._subObjectAdded(object);
    };

    /**
     * Notitify nodes on path to root that child object created.
     * Each object counts how many geometry sub-objects are created.
     *
     * NOTE - All objects are created before any of them start to load,
     * so there should be no race condition between this method and _subObjectReady.
     */
    Human.scene.Object.prototype._subObjectAdded = function (object) {
        this.numSubObjects++;
        this._boundaryDirty = true;
        if (this.parent) {
            this.parent._subObjectAdded(object);
        }
    };

    /**
     * Show/hide this object
     * Only has effect on leaf objects, ignored on branch objects
     * @param {Boolean} doShow Flag specifying whether or not to show
     * @private
     */
    Human.scene.Object.prototype.show = function (doShow) {
        if (this.shown !== doShow) {
            if (this._flagsNode) {
                this._flagsNode.setEnabled(doShow);
            }
            this.shown = doShow;
            this.publish("shown", this.shown);
        }
    };


    /**
     * Select/deselect this object
     * @param {Boolean} doSelect Flag specifying whether or not to select
     * @private
     */
    Human.scene.Object.prototype.select = function (doSelect) {
        this.selected = doSelect;
    };


    /**
     * Set degree of transparency of this object - sets property, but only does something if this object has scene content
     *
     * @param {Number} opacity Degree of transparency between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setOpacity = function (opacity) {
        if (this._shaderParamsNode) {
            this._shaderParamsNode.setParams({opacity: opacity});
            this.opacity = opacity;
        }

    };

    /**
     * Enables/disables this object's transparency
     * Only has effect on leaf objects, ignored on branch objects
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setTransparent = function (transparent) {
        if (this.transparent !== transparent) {
            if (this._shaderParamsNode) {
                this._shaderParamsNode.setParams({
                    transparent: transparent
                  //  ,
                   //
                  //  // Only desaturate if also in XRay mode or explicitly desaturating, otherwise retain color
                  //  desaturate: this.xray || this.desaturate
                });
                var alpha = (transparent || this.xray);
                this._flagsNode.setTransparent(alpha);
                this._flagsNode.setBackfaces(!alpha && this.backfaces);
            }
            this.transparent = transparent;
        }
    };

    /**
     * Set whether or not object appears X-rayed
     * Only has effect on leaf objects, ignored on branch objects
     * @param {boolean} xray True to make object appear X-rayed
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setXRay = function (xray) {
        if (this.xray !== xray) {
            if (this._shaderParamsNode) {
                this._shaderParamsNode.setParams({xray: xray});
                var alpha = (xray || this.transparent);
                this._flagsNode.setTransparent(alpha);
                this._flagsNode.setBackfaces(!alpha && this.backfaces);

                // Only desaturate if now in XRay mode or explicitly desaturating, otherwise retain color
                this._shaderParamsNode.setParams({desaturate: xray || this.desaturate});
            }
            this.xray = xray;
        }
    };

    /**
     * Switches object's color between gray monochrome or full color.
     * Only has effect on leaf objects, ignored on branch objects
     * @param desaturate
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setDesaturate = function (desaturate) {
        if (this.desaturate !== desaturate) {
            if (this._shaderParamsNode) {

                // Only desaturate if now desaturating or currently in X-ray mode, otherwise retain color
                this._shaderParamsNode.setParams({desaturate: desaturate || this.xray});
            }
            this.desaturate = desaturate;
        }
    };

    /** When transparent, this sets the degree of "facing ratio" effect, which is
     * where the object becomes more opaque towards the edges.
     * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} glassFactor Degree of effect between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setGlassFactor = function (glassFactor) {
        this.glassFactor = glassFactor;
        if (this._shaderParamsNode) {
            this._shaderParamsNode.setParams({glassFactor: glassFactor});
        }
    };

    /** When transparent, this sets the degree of "murkiness" effect.
     * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} murkiness Degree of effect between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setMurkiness = function (murkiness) {
        this.murkiness = murkiness;
        if (this._shaderParamsNode) {
            this._shaderParamsNode.setParams({murkiness: murkiness});
        }
    };

    /**
     * Sets whether or not this object is pickable
     * Only has effect on leaf objects, ignored on branch objects
     * @param pickable
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setPickable = function (pickable) {
        if (this.pickable !== pickable) {
            if (this._flagsNode) {
                this._flagsNode.setPicking(pickable);
            }
            this.pickable = pickable;
        }
    };

    /**
     * Sets whether or not this object is clippable
     * Only has effect on leaf objects, ignored on branch objects
     * @param clippable
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setClippable = function (clippable) {
        if (this.clippable !== clippable) {
            if (this._flagsNode) {
                this._flagsNode.setClipping(clippable);
            }
            this.clippable = clippable;
        }
    };

    /**
     * Sets whether or not this object is highlight - only affects leaf objects
     * @param highlight
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setHighlight = function (highlight) {
        if (this.highlight !== highlight) {
            if (this._shaderParamsNode) {
                this._shaderParamsNode.setParams({highlight: highlight});
            }
            this.highlight = highlight;
        }
    };

    /**
     * Sets whether or not this object shows backfaces whenever transparent.
     * Only has effect on leaf objects, ignored on branch objects
     * @param backfaces
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setTransparentBackfaces = function () {
//        if (this.transparentBackfaces !== backfaces) {
//            if (this._flagsNode) {
//                var alpha = this.xray || this.transparent;
//                this._flagsNode.setBackfaces(!alpha || (alpha && backfaces));
//            }
//            this.transparentBackfaces = backfaces;
//        }
    };


    /**
     * Sets whether or not this object shows backfaces.
     * Only has effect on leaf objects, ignored on branch objects
     * @param backfaces
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setBackfaces = function (backfaces) {
        if (this.backfaces !== backfaces) {
            if (this._flagsNode) {
                var alpha = this.xray || this.transparent;
                this._flagsNode.setBackfaces(!alpha && backfaces);
            }
            this.backfaces = backfaces;
        }
    };

    Human.scene.Object.prototype._destroy = function () {
        if (this._destroyed) {
            return;
        }

        // Implicitly destroys all the render graph nodes created with Human.renderer.graph.insertNode.
        // No effect if subtree node already destroyed.
        Human.renderer.graph.destroySubtree(this._rootNode);

        // Assets are released back to the asset store
        // by the layer that made #attachAsset calls on this Object.

        if (this._bbox) {
            this._bbox.destroy();
        }

        this.publish("destroyed");
    };

    Human.scene.Object.prototype._removeObject = function (objectId) {
        for (var i = 0, len = this.objects.length; i < len; i++) {
            if (this.objects[i].objectId === objectId) {
                this.objects.splice(i, 1);
                // Update subObj count in parent and ancestors
                this._subObjectRemoved();
                return;
            }
            this._setBoundaryDirty();
        }
    };

    Human.scene.Object.prototype._subObjectRemoved = function () {
        this.numSubObjects--;
        // TODO:// LATER -- FIX OTHER BUGS FIRST
        // if (this.parent) {
        //     this.parent._updateAncestorSubObj();
        // }
    };

    // ------------------ EXPLICIT DEFAULTS -----------------------------------
    var defaultProperties = {
        "shown": {setter: Human.scene.Object.prototype.show, value: false, keyable: true, type:"boolean"},
        "selected": {setter: Human.scene.Object.prototype.select, value: false, keyable: false, type:"boolean"},
        "pickable": {setter: Human.scene.Object.prototype.setPickable, value: true, keyable: false, type:"boolean"},
        "transparent": {setter: Human.scene.Object.prototype.setTransparent, value: false, keyable: true, type:"boolean"},
        "desaturate": {setter: Human.scene.Object.prototype.setDesaturate, value: false, keyable: false, type:"boolean"},
        "backfaces": {setter: Human.scene.Object.prototype.setBackfaces, value: false, keyable: false, type:"boolean"},
        "glassFactor": {setter: Human.scene.Object.prototype.setGlassFactor, value: 0.0, keyable: false, type:"number"},
        "murkiness": {setter: Human.scene.Object.prototype.setMurkiness, value: 1.0, keyable: false, type:"number"},
        "opacity": {setter: Human.scene.Object.prototype.setOpacity, value: 1.0, keyable: true, type:"number"}
    };

    var defaultPropertyKeys = Object.keys(defaultProperties);

    Human.scene.Object.prototype.getDefaultFlags = function () {
        return {
            picking: this.pickable,
            enabled: false,
            specular: true,
            backfaces: hackAlwaysBackfaces,
            reflection: true,
            solid: true,
            skybox: !!this.skybox
        };
    };

    Human.scene.Object.prototype.getDefaultProperties = function(){
        var result = {};

        for (var i = 0, len = defaultPropertyKeys.length; i < len; i++) {
            var prop = defaultPropertyKeys[i];
            result[prop] = defaultProperties[prop].value;
        }

        return result;
    };

    Human.scene.Object.prototype.getProperties = function(){
        var self = this;
        var result = {};

        for (var i = 0, len = defaultPropertyKeys.length; i < len; i++) {
            var prop = defaultPropertyKeys[i];
            result[prop] = self[prop];
        }

        return result;
    };

    // Set properties of an individual object ONLY. No traversal.
    Human.scene.Object.prototype.setProperties = function(overrides){
        overrides = overrides || {};
        var self = this;
        var target;
        var pvalue;

        for (var i = 0, len = defaultPropertyKeys.length; i < len; i++) {
            var prop = defaultPropertyKeys[i];
            target = defaultProperties[prop];
            pvalue = overrides[prop] !== undefined ? overrides[prop] : target.value;

            if (self[prop] !== pvalue){
                target.setter.call(self, pvalue);
            }
        }
    };



    // -----------------  QUICK AND DIRTY TRAVERSAL ---------------------------

    Human.scene.Object.prototype.traverseUp = function(callback){
        callback(this);
        if (this.parent) {
            this.parent.traverseUp(callback);
        }
    };

    Human.scene.Object.prototype.traverseDown = function(callback){
        callback(this);
        for (var i = 0, len = this.objects.length; i < len; i++) {
            this.objects[i].traverseDown(callback);
        }
    };

    Human.scene.Object.prototype.getLeafObjects = function(callback){
        var leafObjects = [];

        this.traverseDown(function (child) {
            if(child.isLeaf()) {
                leafObjects.push(child);

                if(callback) {
                    callback(child);
                }
            }
        });

        return leafObjects;
    };

    Human.scene.Object.prototype.getRenderableObjects = function(callback){
        var leafObjects = [];

        this.traverseDown(function (child) {
            if(child.isRenderable()) {
                leafObjects.push(child);

                if(callback) {
                    callback(child);
                }
            }
        });

        return leafObjects;
    };

    function createBBox() {
        var bbox = {};

        var flags = Human.renderer.getContentRootNode().addNode({
            type: "flags",
            flags: {
                enabled: false
            }
        });
        var material = flags.addNode({
            type: "material",
            color: {r: 0, g: 0, b: 1}, // TODO: different colors for levels
            emit: 1
        });
        var geometry = material.addNode({
            type: "geometry",
            source: {
                type: "boundary"
            }
        });
        /**
         * @private
         */
        bbox.setShown = function (shown) {
            flags.setEnabled(shown);
        };
        /**
         * @private
         */
        bbox.setBoundary = function (boundary) {
            geometry.setSource(boundary);
        };
        /**
         * @private
         */
        bbox.destroy = function () {
            flags.destroy();
        };

        return bbox;
    }

})();
;(function () {
    "use strict";


    /**
     * @namespace Loads those createObjects sections in model index files
     * @private
     */
    Human.scene.objectLoader = {

        _countAnonObjects: 0,

        // Remembers some initial object states so that we can apply them in a batch later.
        // Lazy-initialized when items are added, so that we can apply them only if not empty.

        _transparentObjects: null,
        _objectOpacities: null,
        _shownObjects: null,

        // Records what's loaded with _load so it can be unloaded with _unload
        _loaded: {}
    };

    Human.scene.objectLoader.load = function (moduleId, modelId, createObjects) {

        if (!createObjects) {
            return this;
        }

        this._countAnonObjects = 0;

        this._transparentObjects = null;
        this._objectOpacities = null;
        this._shownObjects = null;

        var graft;
        var objects;
        var parentObject;

        // Graft object subtrees to their target parent objects
        for (var i = 0, len = createObjects.length; i < len; i++) {
            graft = createObjects[i];
            //        parentObjectId = graft.parentObjectId;
            //        if (!parentObjectId) {
            //            Human.log.error("parentObjectId expected");
            //            continue;
            //        }
            //        // Get parent object to graft to, assuming the object IDs are globally unique within anatomy
            //        parentObject = Human.scene.objects[parentObjectId];
            //        if (!parentObject) {
            //            Human.log.error("parent object not found: '" + parentObjectId + "'");
            //            continue;
            //        }
            var selection = {};
            parentObject = null;

            // Attach objects to parent
            objects = graft.objects;
            if (!objects) {
                continue;
            }
            var object;
            for (var j = 0, lenj = objects.length; j < lenj; j++) {
                object = objects[j];
                if (!object.objectId) {
                    Human.log.error("Human.scene.objectLoader", "Param expected on object: objectId");
                    continue;
                }
                this._attachObject(moduleId, modelId, parentObject, object);
                selection[object.objectId] = true;
            }
        }

        // Apply initial object states in a batch so that the scene
        // can apply inheritance of those states within the hierarchy

        if (this._transparentObjects) {
            Human.scene.setTransparentObjects({
                objectIds: this._transparentObjects,
                replace: false
            });
        }

        if (this._objectOpacities) {
            Human.scene.setObjectOpacities({
                objectIds: this._objectOpacities,
                replace: false
            });
        }

        if (this._shownObjects) {
            Human.scene.setEnabledObjects({
                objectIds: this._shownObjects,
                replace: false
            });
        }

        // Record what was loaded for this state for _unload
        this._loaded[modelId] = {
            createObjects: createObjects
        };
    };


    // Grafts an object tree onto a parent
    Human.scene.objectLoader._attachObject = function (moduleId, modelId, parentObject, object) {
        if (!object.objectId) {
            if (!parentObject) {
                Human.log.error("Human.scene.objectLoader", "Root object is missing an objectId");
                return;
            }

            // Deterministically-generated IDs for anonymous child objects

            object.objectId = parentObject.objectId  + this._countAnonObjects++;
            object.anonymous = true;
        }
        parentObject = this._createObject(moduleId, modelId, parentObject, object);
        var objects = object.objects;
        if (objects) {
            for (var i = 0, len = objects.length; i < len; i++) {
                this._attachObject(moduleId, modelId, parentObject, objects[i]);
            }
        }
    };

    Human.scene.objectLoader._createObject = function (moduleId, modelId, parentObject, object) {

        var objectId = object.objectId;

        // These global IDs will be prefixed with this condition's ID
        var globalObjectId = modelId + "-" + objectId;
        var globalFMAId = (object.fmaid || object.fmaId) ? modelId + "-" + (object.fmaid || object.fmaId) : null;
        var systemId = parentObject ? parentObject.systemId : null;

        // Render order for transparency sorting
        var layer;
        if (parentObject) {
            if (object.layer !== undefined && object.layer !== null) {
                layer = parentObject.layer + (object.layer * 0.001);
            } else {
                layer = parentObject.layer;
            }
        } else {
            layer = object.layer || 0;
        }

        // Get assets (morphs, geometries etc) in this array, if any.
        // For each asset, set it's pick name and layer priority to those of this object,
        // which effectively mean that those assets will inherit the anatomy identity and
        // transparency sort order as defined by this object.

        var material; // Max one material per object
        var reflection; // Max one reflection per object
        var geometry; // Can have multiple geometries
        var morph; // Max one morph per object
        var transform; // Max one transform per object
        var regionMap;

        if (object.assets) {
            var assetId;
            for (var i = 0, len = object.assets.length; i < len; i++) {
                assetId = object.assets[i]; // Asset ID comes prefixed with the library ID
                var globalAssetId = modelId + "." + assetId;
                var asset;

                // See what the asset ID resolves to

                // Try getting a geometry
                asset = Human.assets.geometries.geometries[globalAssetId];
                if (asset) {
                    geometry = asset;

                    // Try getting material with partial ID
                    // This is a hack until geometries have the correct ID format instead of just
                    // something like "Blinn_SG567"
                    if (asset.materialId) {
                        asset = Human.assets.materials.findMaterial(asset.materialId);
                        if (asset) {
                            material = asset;
                        }
                    }

                } else {

                    // Try getting a material using the correct format, ie. "myState.myLibrary.myMaterial"
                    asset = Human.assets.materials.materials[globalAssetId];
                    if (asset) {
                        material = asset;
                    } else {

                        // Try getting a morph
                        asset = Human.assets.morphs.morphs[globalAssetId];

                        if (asset) {
                            morph = asset;

                            if (asset.materialId) {
                                asset = Human.assets.materials.findMaterial(asset.materialId);
                                if (asset) {
                                    material = asset;
                                }
                            }
                        } else {
                            Human.log.error("Human.scene.objectLoader", "Error in createObjects for '" + modelId + "' object '" + objectId + "': asset '" + assetId + "' not found");
                        }

                        //  asset = Human.timeline.animationsgeometries[globalAssetId];
                        //                        if (asset) {
                        //
                        ////                            material = ;
                        //                        }
                    }
                }
            }
        }

        if (object.geometryId) {
            //   if (typeof object.geometryId === "string") {
            geometry = Human.assets.geometries.geometries[object.geometryId];
            if (!geometry) {
                geometry = Human.assets.geometries.geometries[modelId + "." + object.geometryId];
            }
            if (!geometry) {
                Human.log.error("Human.scene.objectLoader", "Geometry asset not found: " + object.geometryId);
            }
            //    } else {
            //   }
        }

        if (object.morphId) {
            morph = Human.assets.morphs.morphs[object.morphId];
            if (!morph) {
                morph = Human.assets.morphs.morphs[modelId + "." + object.morphId];
            }
            if (!morph) {
                Human.log.error("Human.scene.objectLoader", "Morph asset not found: " + object.morphId);
            }
        }

        if (object.materialId) {
            material = Human.assets.materials.materials[object.materialId];
            if (!material) {
                material = Human.assets.materials.materials[modelId + "." + object.materialId];
            }
            if (!material) {
                Human.log.error("Human.scene.objectLoader", "Material asset not found: " + object.materialId);
            }
        }

        if (object.transformId) {
            transform = Human.assets.transforms.transforms[object.transformId];
            if (!transform) {
                transform = Human.assets.transforms.transforms[modelId + "." + object.transformId];
            }
            if (!transform) {
                Human.log.error("Human.scene.objectLoader", "Transform asset not found: " + object.transformId);
            }
        }

        if (!geometry && !morph && !material && !reflection &&
            (!object.assets || object.assets.length === 0) &&
            (!object.objects || object.objects.length === 0)) {
            // Log object that appears useless
            Human.log.warn("Human.scene.objectLoader", "Scene object with neither assets nor child objects: " + objectId);
        }

        if (object.regionMapId) {
            regionMap = Human.assets.regionMaps.maps[object.regionMapId];
            if (!regionMap) {
                regionMap = Human.assets.regionMaps.maps[modelId + "." + object.regionMapId];
            }
            if (!regionMap) {
                Human.log.error("Human.scene.objectLoader", "Region asset not found: " + object.regionMapId);
            }
        }

        // Create the object
        var newObject = Human.scene.__createObject({
            moduleId: moduleId,
            modelId: modelId,
            objectId: globalObjectId,
            anonymous: !!object.anonymous,
            localObjectId: objectId,
            objectName: objectId,
            fmaId: globalFMAId,
            systemId: systemId,
            displayName: object.displayName,
            description: object.description,
            parentObjectId: parentObject ? parentObject.objectId : null,
            layer: layer,
            shown: true,
            material: material,
            geometry: geometry,
            morph: morph,
            transform: transform,
            translate: object.translate,
            scale: object.scale,
            rotate: object.rotate,
            flip: inherit("flip", object, parentObject),
            desaturate: inherit("desaturate", object, parentObject),
            glassFactor: inherit("glassFactor", object, parentObject),
            tags: object.tags || [],
            capColor: inherit("capColor", object, parentObject),
            regionMap: regionMap,
            skybox: object.skybox,
            billboard: inherit("billboard", object, parentObject)
        });

        function inherit(prop, object, parent) {
            if (parent) {
                if (object[prop] !== undefined && object[prop] !== null) {
                    return object[prop];
                }
                return parent[prop];

            }
            return object[prop];
        }

        // Remember initially object states so that
        // we can apply those in a batch after loading all

        if (object.transparent !== undefined) {
            if (!this._transparentObjects) {
                this._transparentObjects = {};
            }
            this._transparentObjects[globalObjectId] = object.transparent;
        }

        if (object.opacity !== undefined) {
            if (!this._objectOpacities) {
                this._objectOpacities = {};
            }
            this._objectOpacities[globalObjectId] = object.opacity;
        }

        if (object.shown !== undefined) {
            if (!this._shownObjects) {
                this._shownObjects = {};
            }
            this._shownObjects[globalObjectId] = object.shown;
        }

        return newObject;
    };

    Human.scene.objectLoader.unload = function (modelId) {

        var loaded = this._loaded[modelId];
        if (!loaded) {
            return;
        }

        var createObjects = loaded.createObjects;

        delete this._loaded[modelId];

        var graft;
        var objects;
        var objectId;
        var object;

        // Remove subtrees that were attached
        // We only need to remove the roots

        for (var i = 0, len = createObjects.length; i < len; i++) {

            graft = createObjects[i];

            objects = graft.objects;
            for (var j = 0, lenj = objects.length; j < lenj; j++) {
                objectId = modelId + "-" + objects[j].objectId;
                if (!objectId) {
                    continue;
                }
                object = Human.scene.objects[objectId];
                if (!object) {
                    Human.log.error("Human.scene.objectLoader.unload", "Scene object not found: '" + objectId + "'");
                    continue;
                }
                Human.scene.destroyObject(object.objectId);
            }
        }
    };
})();

;/**
 * @namespace Enables backfaces on scene objects only when clip planes are active.
 */
(function () {
    "use strict";

    var hackAlwaysBackfaces = false;

    Human.properties.subscribe({
        propId: "hacks.alwaysBackfaces",
        value: false,
        callback: function (value) {
            hackAlwaysBackfaces = value;
        }
    });

    Human.events.on("clips.activated",
        function () {
            if (hackAlwaysBackfaces) {
                return;
            }
            showBackfacesOnObjects(true);
        });

    Human.events.on("clips.deactivated",
        function () {
            if (hackAlwaysBackfaces) {
                return;
            }
            showBackfacesOnObjects(false);
        });

    function showBackfacesOnObjects(backfaces) {

        var objects = Human.scene.objects;
        var objectId;
        var object;

        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {

                object = objects[objectId];
                object.setBackfaces(backfaces);
            }
        }
    }


})();
;/** Set Operations and Getters on key-value maps
 * Compares membership of keys between two maps.
 * Returns a new map.
 *
 * Membership is determined by map key by defualt.
 * Optional function to return the value associated with member key in final set; if null
 * the key-value pair will be ignored entirely.
 * Function can return 'null' (and only null) to override otherwise matching keys.
 *
 * NOTES:
 *   - If using objectIds as keys, assume that the objectds have been globalized.
 *   - Assumes set arguemnts are hash-maps (objects with no non-native function properties).
 *   - Assumes maps are not hierarchical i.e. each map value is a simple key-value map with native value types.
 *   - No assumption that values have to have the same properties.
 *   - Presrve optional selector functions where appropriate.
 *   - Support values of type "boolean" and of type "objects"
 *
 * TODO: We could consider making the below functions prototypes of a custom Human Object Set class.
 *  That way we could do operation chaining.
 *
 * TODO: Expand "*" placeholders if present.
 *
 * TODO: Make sure the original sets aren't being altered.
*/
(function () {
    "use strict";
    var sets = Human.scene.sets = {};

    // -------------- DEFAULTS ----------------------------------------------
    // Prefer item2 if it exists;
    var defaultSelector = function(item1, item2){
      // Allow for item1, item2 to be of type "booleans" as well as of type "objects".
      var ignoreValues = [null, undefined];
      if (ignoreValues.indexOf(item2) < 0) {
        return item2;
      }
      else if (ignoreValues.indexOf(item1) < 0){
        return item1;
      }
      else {
        return null;
      }
    };

    // Check for item in set keys.
    var defaultSetMembership = function(item, key){
      return (key === item)? true : false;
    };

    // --------------- GETTERS -----------------------------------------------

    /** Get list of all keys.
     * Returns a list of unique keys.
     * Optional Selector to filter keys.
    */
    sets.keys = function(aset, fnSelector){
      fnSelector = fnSelector || false;
      var oKeys = Object.keys(aset);

      var result = [];
      if (!fnSelector){
        result = oKeys; // return all keys
      } else {
        oKeys.forEach(function(key){
          if (fnSelector(key)){
            result.push(key);
          }
        });
      }
      return result;
    };


    /** Get subset of keys containing a regular expression
     * Returns a list of keys satisfying a regular expression.
    */
    sets.filterKeys = function(aset, regexp){
      var pattern;
      var result = [];
      // Ensure regular expression
      if (regexp instanceof RegExp){
        pattern = regexp;
      } else {
        try {
          pattern = new RegExp(regexp);
        }
        catch (err){
          return {};
        }
      }

      var isok = function(key){
        return pattern.test(key);
      };

      result = sets.keys(aset).filter(isok);
      return result;

    };

    /** Get list of keys where value satisfied a condition
     * fnCondition(value) returns true if value satisfies some condition.
    */
    sets.keysWhere = function(aset, fnCondition){
      var result = [];
      for (var key in aset){
        if (aset.hasOwnProperty(key)){
          if (fnCondition(aset[key])){
            result.push(key);
          }
        }
      }
      return result;
    };

    /** Get membership status of key in set.
     * Returns true/false if key is a member of aset.
    */
    sets.hasKey = function(aset, key){
      var keys = sets.keys(aset);
      if (keys.indexOf(key)>=0){
        return true;
      } else {
        return false;
      }
    };

    /** Return Iterator over key,value pairs of set
    */
    sets.getSetIterator = function(set){

      var index = 0, keys = sets.keys(set), length = keys.length;

      return {
        next: function(){
            var item;
            if (!this.hasNext()){ return null;}
            var key = keys[index];
            item = {"key":key,"value":set[key]};
            index ++;
            return item;
        },
        hasNext: function(){ return index < length;},
        rewind: function(){index=0; return set[keys[0]];},
        current: function(){
          return set[keys[index]];
        }
      };
    };

    /** Get list of all values
     * Returns a list of values for each unique key in set.
     * The order of values will match the order of keys.
    */
    sets.values = function(aset){
      var keys = sets.keys(aset);
      var result = [];
      keys.forEach(function(key){
        result.push(aset[key]);
      });
      return result;
    };

    /** Get list of keys in EITHER set1 OR set2
     * NOTE: http://stackoverflow.com/questions/1723168/what-is-the-fastest-or-most-elegant-way-to-compute-a-set-difference-using-javasc
    */
    sets.jointKeys = function(set1, set2){
      var h = {}, f = function (v) { h[v] = true; };
      var keySet1 = sets.keys(set1);
      var keySet2 = sets.keys(set2);
      keySet1.forEach(f);
      keySet2.forEach(f);
      return sets.keys(h);
    };

    /** Get list of intersecting keys in BOTH set1 AND set2
    */
    sets.commonKeys = function(set1, set2){
      var h = {};
      var keySet1 = sets.keys(set1);
      var keySet2 = sets.keys(set2);
      keySet1.forEach(function(v){ h[v] = 1; });
      keySet2.forEach(function(v){ h[v] = (h[v] || 0) + 1; });
      return sets.keysWhere(h, function(v){ return v>1? true : false;});
    };

    /** Get list of keys IN set1 but NOT in set2
    */
    sets.uniqueKeys = function(set1, set2){
      var h = {};
      var f1 = function(v){h[v] = 1;};
      var f2 = function(v){h[v] = 0;};
      var keySet1 = sets.keys(set1);  // order matters
      var keySet2 = sets.keys(set2);  // set 2 comes after set 1!!
      keySet1.forEach(f1);
      keySet2.forEach(f2);
      return sets.keysWhere(h, function(v){return v>0? true: false;});
    };

    //--------------------- SET OPERATIONS -------------------------------------

    /** Get union of key-value pairs
     * Returns new key-value map with keys jointly in set1 and set2
     *
     * Optional Argument: fnSelector() function
     *  - selector = function(itemSet1,itemSet2);
     *  - returns value made from properties of itemSet1 and itemSet2
    */
    sets.union = function(set1, set2, fnSelector){
      var uKeys, union = {};
      var ph = null; // placeholder

      // Setup default selector function.
      if (!fnSelector){
        fnSelector = defaultSelector;
      }

      // Get joint keys and set the desired value to each key.
      uKeys = sets.jointKeys(set1, set2);
      uKeys.forEach(function(key){
        ph = fnSelector(set1[key], set2[key]);
        if (ph !== null){
          union[key] =  ph;
        }
      });
      return union;
    };

    /** Get intersection of key-value pairs
    */
    sets.intersection = function(set1, set2, fnSelector){
      var iKeys, intersection = {}, ph = null;
      if (!fnSelector){
        fnSelector = defaultSelector;
      }

      // Get intersecting keys and the preferred value;
      iKeys = sets.commonKeys(set1, set2);
      iKeys.forEach(function(key){
        ph = fnSelector(set1[key], set2[key]);
        if (ph !== null) {
          intersection[key] = ph;
        }
      });
      return intersection;
    };

    /** Get elements in set1 that are NOT in set 2
    * fnSelector can return null to prohibit key-value pair.
    */
    sets.difference = function(set1, set2, fnSelector){
      var unqKeys = sets.uniqueKeys(set1, set2), ph=null;
      if (!fnSelector){
        fnSelector = defaultSelector;
      }
      var uniqueToSet1 = {};
      unqKeys.forEach(function(key){
        ph = fnSelector(set1[key]);
        if (ph !== null){
          uniqueToSet1[key] = ph;
        }
      });
      return uniqueToSet1;
    };

    /** Ask if item is contained in set
     * fnSatisfy(item, key, value): returns true if item satisfied a condition.
     *   Default tests membership of key in set.
    */
    sets.isin = function(item, set1, fnSatisfy){
      if (!fnSatisfy){
        fnSatisfy = defaultSetMembership;
      }

      var found = false;
      var setIter = sets.getSetIterator(set1);
      var kvp;
      while (setIter.hasNext() && !found){
        kvp = setIter.next();
        found = fnSatisfy(item, kvp.key, kvp.value);
      }
      return found;
    };

    // -------------------- SET OPERATIONS ON Directed Acyclic Graphs ----------
    // TODO: Expand the set operations to consider hierarchical sets in a Directed Acyclic Graph.


  })();
;(function() {
    "use strict";

    var graph = Human.scene.graph = {};

    // For each object, a list of IDs of assets attached to it.
    var objectAssets = {};

    // Store attached assets by type for a given sesssion
    var attachedAssets = {};
    var numRequestedAssets = 0;
    var numAttachedAssets = 0;

    var anonymousObjectCount = 0;

    // Load objects into scene from the scene defintion
    graph.buildSceneGraph = function(scene, stateId) {
        var rootObjects = [];
        anonymousObjectCount = 0;

        buildGraph(scene, null, stateId, rootObjects);
        return rootObjects;
    };

    /* Gather asset ids from a portion of the scene graph
     *
     *  return value format format:
     *      {
     *          "geometry": {
     *              "geometryId1": [target_object_id, ...],
     *              "geometryId2": [target_object_id, ...]
     *              // etc...
     *          }
     *          // etc...
     *      }
     *
     *  Result can be provided to gradually gather asset Ids over several
     *  calls.
     */

    graph.gatherAssetIdsFromObject = function(objects, types, result) {

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        types = types || ["geometry", "material", "transform", "morph"];

        result = result || {};

        for (var i = 0, len = objects.length; i < len; i++) {
            gatherAssetIdsFromObject(objects[i], types, result);
        }

        return result;
    };

    graph.attachAssetsToObject = function(objects, types, ok) {
        if (typeof types === "function") {
            ok = types;
            types = null;
        }

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        types = types || ["geometry", "material", "transform", "morph"];

        var assetsLoading = 0;

        function done() {
            if (--assetsLoading === 0 && ok) {
                ok();
            }
        }

        for (var i = 0, len = objects.length; i < len; i++) {
            var assetIds = graph.gatherAssetIdsFromObject(objects[i], types);
            assetsLoading++;
            graph.attachAssets(assetIds, done);
        }
    };

    /**
    *   This function encapsulates a common loading pattern where
    *   where assets are meant to be loaded in "phases" (e.g.
    *   geometry, transforms, materials first, then morphs later).
    *   By default, the phases will be:
    *   - Phase 1: geometry, materials, transforms
    *   - Phase 2: morphs
    *
    *   It will load subtrees of the argument objects and traverses up
    *   up the scenegraph from those objects to properly load hierarchical
    *   transforms.
    *
    *   Arguments:
    *   [array of objects]  objects     The roots of subtrees to attach assets to.
    *   [array of arrays]   typeSets    Groups of types to load per phase (e.g. [[["geometry", "material", "transform"], ["morph"]])
    *   [function]          ok          Callback function to call after each phase.
    *
    *   Note that the callback function is called after each phase, so
    *   it will be called multiple times. At each phase, the following arguments
    *   are passed to the callback function:
    *   [object]            typesLoaded A map of the asset types that were loaded.
    *   [number]            i           The index of the current phase
    *   [boolean]           done        Is this the last phase?
    */
    graph.attachAssetSetsToSubtree = function(objects, typeSets, ok) {
        if (typeof typeSets === "function") {
            ok = typeSets;
            typeSets = null;
        }

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        typeSets = typeSets || [["geometry", "material", "transform"], ["morph"]];

        var assetObjects = {};
        var orderedAssetObjects = [];
        var leafObjects = {};
        var objectId, object;

        function registerLeaf(leaf) {
            leafObjects[leaf.objectId] = leaf;
        }

        function registerObjectId(object) {
            if(!assetObjects[object.objectId]) {
                orderedAssetObjects.push(object);
                assetObjects[object.objectId] = true;
            }
        }

        for (var i = 0; i < objects.length; i++) {
            objects[i].getLeafObjects(registerLeaf);
        }

        for (objectId in leafObjects) {
            if (leafObjects.hasOwnProperty(objectId)) {

                objectId = Human.modules.convertBaseAnatomyObjectId(objectId);
                object = leafObjects[objectId];

                if (object) {
                    // Traverse up for transforms
                    object.traverseUp(registerObjectId);
                }
            }
        }

        attachTypeSets(orderedAssetObjects, typeSets, 0, ok);
    };

    function attachTypeSets(assetObjects, typeSets, phase, ok) {
        var typeSet = typeSets.shift();

        attachTypeSet(assetObjects, typeSet, function () {
            if(ok) {
                var typesLoaded = {};
                for (var i = 0, len = typeSet.length; i < len; i++) {
                    typesLoaded[typeSet[i]] = true;
                }
                ok(typesLoaded, phase, !typeSets.length);
            }

            if(typeSets.length) {
                attachTypeSets(assetObjects, typeSets, phase + 1, ok);
            }
        });
    }

    function attachTypeSet(assetObjects, typeSet, ok) {
        var numObjects = assetObjects.length;
        var object;

        if (numObjects === 0) {
            if (ok) {
                Human.utils.async(ok);
            }
            return;
        }

        function done() {
            if (--numObjects === 0 && ok) {
                ok();
            }
        }

        for (var i = 0, len = numObjects; i < len; i++) {
            object = assetObjects[i];

            graph.attachAssetsToObject(object, typeSet, done);
        }
    }

    /** This function Loads the asset from Object Server.
    *   Then applies the asset to the Scene Graph
    */
    graph.attachAssets = function(assetIds, ok) {
        var assetsLoading = 0;

        function done() {
            if (--assetsLoading === 0 && ok) {
                ok();
            }
        }

        var keys = Object.keys(assetIds);

        if (keys.length === 0) {
            if (ok) {
                Human.utils.async(ok);
            }
            return;
        }

        for (var i = 0, len = keys.length; i < len; i++) {
            var type = keys[i];
            var typeAssets = assetIds[type];

            if (!typeAssets) {
                return;
            }

            for (var assetId in typeAssets) {
                if (typeAssets.hasOwnProperty(assetId)) {
                    var targetObjects = typeAssets[assetId];

                    assetsLoading++;
                    getAsset(assetId, type, targetObjects, done);
                }
            }
        }
    };

    /**
     * Removes assets from target objects.
     * @param objectIds
     */
    graph.destroySubtree = function(objects) {

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        var i;
        var len;
        var object;
        var assetIds;
        var j;
        var lenj;

        function destroyAssets(child) {
            assetIds = objectAssets[child.objectId];

            if (assetIds) {
                for (j = 0, lenj = assetIds.length; j < lenj; j++) {
                    Human.assets.putAsset(assetIds[j]);
                }
            }

            delete objectAssets[child.objectId];
        }

        for (i = 0, len = objects.length; i < len; i++) {
            object = objects[i];

            object.traverseDown(destroyAssets);

            Human.scene.destroyObject(object.objectId);
        }
    };

    function buildGraph(objects, parent, stateId, rootObjects) {
        if (!objects) {
            return;
        }

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        var humanObject;

        for(var i = 0; i < objects.length; i++) {
            var object = objects[i];

            object.anonymous = false;

            if (!object.objectId) {
                if (!parent) {
                    buildGraph(object.objects, null, stateId, rootObjects);
                    continue;
                }

                object.objectId = parent.objectId + anonymousObjectCount++;
                object.anonymous = true;
            }

            humanObject = createObject(object, parent, stateId);

            if (humanObject === null) {
                continue;
            }

            if (parent === null) {
                rootObjects.push(humanObject);
            }

            buildGraph(object.objects, humanObject, stateId, rootObjects);
        }
    }

    function gatherAssetIdsFromObject(object, types, assetIds) {

        for (var i = 0, len = types.length; i < len; i++) {
            var type = types[i];

            if (!object.attachedAssets[type]) {

                var assetId = object[type + "Id"];
                var assetList;

                if(assetId) {
                    assetIds[type] = assetIds[type] || {};

                    assetList = assetIds[type][assetId] = assetIds[type][assetId] || [];
                    assetList.push(object.objectId);
                }
            }
        }

        return assetIds;
    }

    function assetAttached(objectId, assetId) {
        (objectAssets[objectId] || (objectAssets[objectId] = [])).push(assetId);
    }

    function assetAttachStart() {
        Human.events.fire("graph.assetAttach.start");
    }

    function assetAttachProgress(assetId, type, targetObjects, nullAsset) {
        numAttachedAssets++;

        Human.events.fire("graph.assetAttach.progress", {
            assetId: assetId,
            targetObjects: targetObjects,
            assetType: type,
            nullAsset: nullAsset
        });

        if(!attachedAssets[type]) {
            attachedAssets[type] = [];
        }

        if(!nullAsset) {
            attachedAssets[type].push(assetId);
        }

        if(numRequestedAssets === numAttachedAssets) {
            assetAttachFinish();
        }
    }

    function assetAttachFinish() {
        Human.events.fire("graph.assetAttach.finish", attachedAssets);

        attachedAssets = {};
        numRequestedAssets = 0;
        numAttachedAssets = 0;
    }

    function getAsset(assetId, type, targetObjects, ok) {
        if(numRequestedAssets === 0) {
            assetAttachStart();
        }

        numRequestedAssets++;

        Human.assets.getAsset(assetId, type, function(asset) {

            if (asset) {
                for (var i = 0, len = targetObjects.length; i < len; i++) {
                    var objectId = targetObjects[i];
                    var object = Human.scene.objects[objectId];

                    if(object) {
                        object.attachAsset(type, asset);

                        assetAttached(objectId, assetId);
                    }
                }
            }

            assetAttachProgress(assetId, type, targetObjects, !asset);

            ok(asset);
        });
    }

    function createObject(object, parent, stateId) {

        var objectId = object.objectId;

        var geometryId = object.geometryId || null;
        var morphId = object.morphId || null;
        var materialId = object.materialId || null;
        var transformId = object.transformId || null;
        var regionMapId = object.regionMapId || null;

        // Only add stateId to assets if they are not already prefixed
        if (stateId) {
            var stateIdObjectPrefix = stateId + "-";
            var stateIdAssetPrefix = stateId + "/";

            // UGH! Need to use old-style anonymous objectIds for bookmarks!
            if (objectId.indexOf(stateIdObjectPrefix) !== 0 || object.anonymous) {
                objectId = stateIdObjectPrefix + objectId;
            }
            if (geometryId && geometryId.indexOf(stateIdAssetPrefix) !== 0) {
                geometryId = stateIdAssetPrefix + geometryId;
            }
            if (morphId && morphId.indexOf(stateIdAssetPrefix) !== 0) {
                morphId = stateIdAssetPrefix + morphId;
            }
            if (materialId && materialId.indexOf(stateIdAssetPrefix) !== 0) {
                materialId = stateIdAssetPrefix + materialId;
            }
            if (transformId && transformId.indexOf(stateIdAssetPrefix) !== 0) {
                transformId = stateIdAssetPrefix + transformId;
            }
            if (regionMapId && regionMapId.indexOf(stateIdAssetPrefix) !== 0) {
                regionMapId = stateIdAssetPrefix + regionMapId;
            }
        }

        if (Human.scene.objects[objectId]) {
            return null;
        }

        if (object.layer === undefined) {
            object.layer = parent ? parent.layer : 0;
        }

        object.moduleId = "__SCENE__";
        object.objectId = objectId;
        object.modelId = stateId;
        object.parent = parent;
        object.parentObjectId = parent ? parent.objectId : null;
        object.materialId = materialId;
        object.geometryId = geometryId;
        object.morphId = morphId;
        object.transformId = transformId;
        object.regionMapId = regionMapId;
        object.tags = object.tags || [];
        object.flip = inherit("flip", object, parent);
        object.desaturate = inherit("desaturate", object, parent);
        object.glassFactor = inherit("glassFactor", object, parent);
        object.capColor = inherit("capColor", object, parent);

        var sceneObject = Human.scene.__createObject(object);

        if (object.transparent !== undefined) {
            sceneObject.setTransparent(object.transparent);
        }

        if (object.opacity !== undefined) {
            sceneObject.setOpacity(object.opacity);
        }

        if (object.shown !== undefined) {
            sceneObject.show(object.shown);
        }

        return sceneObject;
    }

    function inherit(prop, object, parent) {
        if (parent) {
            if (object[prop] !== undefined && object[prop] !== null) {
                return object[prop];
            }
            return parent[prop];

        }
        return object[prop];
    }

})();
;/**
  * @namespace Control of the master root timeline
  * This namespace interfaces with the root timeline object.
  *
  * Responsibilities:
  *     - Play chapters/transitions on tick events
  *     - Issue and store play commands by specifying start and end conditions.
  *             -- next chapter, previous chapter
  *             -- start conditions: start time, start chapter id, start chpater index
  *             -- end conditions: end time, end chapter id, end chapter index, number of chapters.
  *
  *     - Play state
  *             -- playing, not playing (paused, stopped)
  *             -- transitioning (dynamic transitions only)
  *     - Scrubbing
  *             -- scrub to specific time in global timeline
  *             -- no dynamic transitions
  *
  * NOTE: Looping
  * Any play block (set of time defined by time1 and time2) can be instructed to loop. The
  * intention to loop is set via the HumanTimeline.play() command arguments. However, for backwards
  * compatibility with some existing apps/widgets/content, single chapters can declare themselves to loop
  * from the chapter definition directly. In this very specific edge case, we will use that loop property.
  *
  *
  *
  *
  * TODO: Eventually animations should be loaded DIRECTLY into the leaf timelines. Now they are added to animations, then from animations
  * into the leaf timeline. This is just easier for the time being.
 */

(function () {
    "use strict";

    //local namespace
    var HumanTimeline = Human.timeline = {};

    // Timelines Library
    HumanTimeline.animations = {};    // original animation assets
    HumanTimeline.leafTimelines = {};
    HumanTimeline.branchTimelines = {};
    HumanTimeline.rootTimelines = {};
    HumanTimeline.activeRoot = null;

    // Play Configuration
    HumanTimeline.FRAME_LENGTH = 0.033;
    HumanTimeline.TIME_CONSTANT = 1/1000;
    HumanTimeline.borderConditions = {
      start: {which: "second", direction: HumanTimeline.direction},
      middle: {which: "both", direction: HumanTimeline.direction},
      end: {which: "first", direction: HumanTimeline.direction}
    };


    // Play State Controls
    HumanTimeline.playing = false;          // true if use wants to play a block of root timeline.
    HumanTimeline.transitioning = false;    // true timeline is in a state of transition between chapters
    HumanTimeline.playfree = true;          // true if user wishes to play free animations
    HumanTimeline._lastWorldTime = 0.0;
    HumanTimeline._dynamicTransition = {};  // Placeholder for any dynamically generated transition branches needed by play manager.
    HumanTimeline._time1 = 0.0;             // time at start of play block
    HumanTimeline._time2 = 0.0;             // time at end of play block
    HumanTimeline._freeTime = 0.0;          // free time
    HumanTimeline.time = 0.0;               // current time; t1 <= t <= t2
    HumanTimeline.playQueue = [];           // Array of play instructions to be played in order.
    HumanTimeline.loop = false;             // Loops over entire t1-t2 play-block if true
    HumanTimeline.scale = 1.0;              // factor by which to advance time with tick (positive or negative).
    HumanTimeline.direction = "forwards";   // forwards if scale > 0 and "backwards" if scale < 0

    // Bookmark parameters
    HumanTimeline._playParams = null;
    HumanTimeline._scrubParams = null;


    // Backwards Comaptibitlity.
    HumanTimeline.chapters = {};      // Generated by root on timeline.updated event
    HumanTimeline.chapterList = [];   // Generated when chapters loaded.

    // TICK variables
    var root, timeNow, diff, dilation, bc;

    // ------------------------  LOADING AND REGISTERING ASSETS ---------------------------------------------------

    /** Registers an animation on the timeline
    * @memberof Human.timeline
    * @private
    */
    HumanTimeline.addAnimation = function (animationId, animation) {
        if (!animation.update) {
            Human.log.error("Human.timeline.addAnimation", "Param expected: update");
            return;
        }
        if (HumanTimeline.animations[animationId]) {
            HumanTimeline.removeAnimation(animationId);
        }
        HumanTimeline.animations[animationId] = animation;
        Human.events.fire("Timeline.Loaded");
    };

    /** Destroy animation(s) - either a specific animation, all animations associated with a given object,
     * or all animations indiscriminately
     * @memberof Human.timeline
     * @private
     */
    HumanTimeline.removeAnimation = function (animationId) {
        var animation = HumanTimeline.animations[animationId];
        if (!animation) {
            Human.log.warn("Human.timeline.removeAnimation", "Animation not found: " + animationId);
            return;
        }
        delete HumanTimeline.animations[animationId];
        if (animation.destroy) {
            animation.destroy(); // Destroy animation
        }

        if (Human.utils.isEmpty(HumanTimeline.animations)){
          Human.events.fire("Timeline.Empty");
        }

    };

    //  ----------------------- CLOCK TICK HANDLING ---------------------------------------------------------------
    // Return True if time is at the end of a play-block, False otherwise
    // Returns global time at which playblock ends.
    var getEndTime = function(){
      return (HumanTimeline.direction === "forwards")? HumanTimeline._time2 : HumanTimeline._time1;
    };

    // Returns global time at which playblock starts.
    var getStartTime = function(){
      return (HumanTimeline.direction === "forwards")? HumanTimeline._time1 : HumanTimeline._time2;
    };

    var playEnded = function(){
      var ref = getEndTime();
      if (HumanTimeline.time === ref){
        return true;
      } else{
        return false;
      }
    };

    // Return True if time is at the start of a play-block, False otherwise
    var playStarted = function(){
      var ref = getStartTime();
      if (HumanTimeline.time === ref){
        return true;
      } else{
        return false;
      }
    };

    /** Rules for root update on border times.
    * This only needs to be changed when the driection is set.
    *
    * "first/second" refers to the left/right branch at a border relative to root timeline.
    * "start/end" refers to time relative to the viewer.
    * "forwards/backwards" refers to left-to-right (and vice versa) relative to the root timeline.
    *
    * Example: first branch from the forwards direction is the same as the
    * second branch from the backwards direction, and vice versa.
    */
    var setBorderConditions = function(direction){
      var result = {};
      var coef = (direction === "backwards")? -1.0: 1.0;
      var validDirections = ["forwards", "backwards"];

      // validation
      if (validDirections.indexOf(direction) < 0){
        Human.log.warn("timeline.setBorderConditions", "invalid direction :" + direction);
        return null;
      }

      result.start = {which:"second", direction: direction};
      result.middle = {which: "both", direction: direction};
      result.end = {which: "first", direction: direction};

      HumanTimeline.direction = direction;
      HumanTimeline.borderConditions = result;
      HumanTimeline.scale = coef * Math.abs(HumanTimeline.scale);
    };

    HumanTimeline.initScene = function() {
        if (HumanTimeline.activeRoot) {
            HumanTimeline.activeRoot.initScene();
        }
    };

    HumanTimeline.initCamera = function(ok) {
        if (HumanTimeline.activeRoot) {
            HumanTimeline.activeRoot.initCamera(ok);
        }
    };

    HumanTimeline.cancelCameraInit = function() {
        if (HumanTimeline.activeRoot) {
            HumanTimeline.activeRoot.cancelCameraInit();
        }
    };

    HumanTimeline.initAnnotations = function() {
        if (HumanTimeline.activeRoot) {
            HumanTimeline.activeRoot.initAnnotations();
        }
    };

    HumanTimeline.cancelAnnotationInit = function() {
        if (HumanTimeline.activeRoot) {
            HumanTimeline.activeRoot.cancelAnnotationInit();
        }
    };

    Human.events.on( "tick", function () {
      // Manage global time --------------------------------------
      root = HumanTimeline.activeRoot;
      if (root === null || root === undefined){
        return;
      }
      timeNow = (new Date()).getTime();
      diff = (timeNow - HumanTimeline._lastWorldTime) * HumanTimeline.TIME_CONSTANT;
      dilation = diff/HumanTimeline.FRAME_LENGTH;
      HumanTimeline._lastWorldTime = timeNow;
      if (HumanTimeline.time > HumanTimeline._time2) {
          HumanTimeline.time = HumanTimeline._time2;
      }
      else if (HumanTimeline.time < HumanTimeline._time1) {
          HumanTimeline.time = HumanTimeline._time1;
      }

      // Free Animations ------------------------------------------
      if (HumanTimeline.playfree){
          root.updateFreeAnimations(HumanTimeline._freeTime);
          HumanTimeline._freeTime += HumanTimeline.scale * dilation * HumanTimeline.FRAME_LENGTH;
      }

      // Dynamic Transitions ---------------------------------------
      /**
      * Dynamic transitions (DTs) are needed handle cases when user wants to
      * jump into a branch timeline (if it requires a transition) from a point in
      * the root time when a transition was not expected and therefore not pre-built.
      *
      * DTs are considered to be in the play-state but do not update the "scrubber".
      *
      * Dts have special handling insructions.
      *
      * DTs are destroyed on completion.
      */
      if (HumanTimeline.transitioning && HumanTimeline.playing){
        var dt = HumanTimeline._dynamicTransition;
        if ((dt._time1 <= dt.time) && (dt.time<= dt._time2)){
            // update
            dt.branch.update(dt.time);
            dt.time += dilation * HumanTimeline.FRAME_LENGTH;
          } else {
            // exit and destroy
            HumanTimeline.transition = null;
            HumanTimeline.transitioning = false;
          }
      }

      // Branch Timelines ----------------------------------------------
      /**
      * Once Dynamic transitions have been played, the engine now plays
      * the rest of the play block (the time between time1 and time2) in specified direction.
      *
      * Dynamic transitions: If the user has moved an untweened camera
      * while chapter is playing, the camera may be out of position
      * for the next transition (if it exists).
      *
      * Boundary conditions: Often a play block is the duration of a chapter.
      * At boundaries, the global time points to end/start times on two consecutive
      * branch timelines. Rules specified in the bounary condition dictate
      * whether both are played or just one and which one.
      *
      */
      if (!HumanTimeline.transitioning && HumanTimeline.playing){

        // Prepare next transition. TODO: Asyncronous preparation of next transition ?
        root.prepareNextTransition(HumanTimeline.time);

        // Boundary conditions and play permissions
        bc = HumanTimeline.borderConditions.middle; //default
        var toPlay = true;
        if (playEnded()){
          if (HumanTimeline.loop === true){
            // loop
            bc = HumanTimeline.borderConditions.start;
            HumanTimeline.time = getStartTime();
          } else {
            // stop playing
            bc = HumanTimeline.borderConditions.end;
            toPlay = false;
          }
        } else if (playStarted()){
          bc = HumanTimeline.borderConditions.start;
        }

        // Play and adjust Play State based on time.
        root.update(HumanTimeline.time, bc);
        if (toPlay){
          HumanTimeline.playing = true;
          Human.events.fire("timeline.playing", {
              time: HumanTimeline.time
          });
          HumanTimeline.time += HumanTimeline.scale * dilation * HumanTimeline.FRAME_LENGTH;
        } else {
          HumanTimeline.playing = false;
          Human.events.fire("timeline.stopped", {
            time: HumanTimeline.time
          });
        }
      } // end handling of branch update

    }); // END TICK EVENT

    // Manage play queue:
    Human.events.on("timeline.stopped",function(){
      HumanTimeline.playQueue.shift();
      if (HumanTimeline.playQueue.length>0){
        var nextPlay = HumanTimeline.playQueue[0];
        HumanTimeline._play(nextPlay);
      } else {
        Human.events.fire("timeline.paused",{time:Human.timeline.time});
      }
    });


    // ------------------------- PLAY COMMANDS ----------------------------------------------------------------------

    /** PLAY QUEUE
    @param {{}} params Play parameters
    @param {Number} [params.prevChapter] True play previous chapter
    @param {Number} [params.nextChapter] True play next chapter
    @param {Number} [params.startTime] Time in seconds to start playing at
    @param {Number} [params.finishTime] Time in seconds to stop playing at
    @param {String} [params.startChapterId] ID of chapter to start playing at
    @param {String} [params.finishChapterId] ID of chapter to stop playing at
    @param {String} [params.numChapters] Number of chapters to play before stopping
    */
    HumanTimeline.play = function(params){
      params = params || {};

      if (params.queue && HumanTimeline.playing) {
          // Flagged to enqueue, currently playing
          HumanTimeline.playQueue.push(params);
      } else {
          // Kill queue, play immediately
          HumanTimeline.playQueue = [params];
          HumanTimeline._play(params);
      }
    };

    // Sets up play block via play state controls
    /**
    * Parameters:
    * @param {Number}  [params.prevChapter] True play previous chapter
    * @param {Number}  [params.nextChapter] True play next chapter
    * @param {boolean} [params.align] True (default) _time1,_time2 align with border times. Otherwise, use passed times.
    * @param {string}  [params.startChapterId]
    * @param {string}  [params.finishChapterId]
    * @param {Number}  [params.startTime]
    * @param {Number}  [params.finishTime]
    * @param {integer} [params.numChapters] number of chapters in forwards direction.
    * @param {boolean} [params.loop]
    *
    * TODO: Consider having both align left and align right.
    *
    * NOTE: This will support playing time backwards, but will not support playing chapters forwrds in
    * reverse order. One should issue use existing play parameters and the playQueue to do that.
    *
    * Backwards Conditions (playing time backwards) when ...
    *   startTime > finishTime (global)
    *   startChapter.idx > finishChapter.idx (root queue order)
    *   startTime > finishChpater.starttime (global)
    *   finishTime < startChapter.startTime (global)
    */
    HumanTimeline._play = function(params){
      params = params || {};
      var root = HumanTimeline.activeRoot;
      var direction = "forwards";              // play direction (relative to root);
      root.getTimeFrame();
      var _startCondition;
      var _endCondition;
      var _firstBranch;           // first branch to be played
      var _firstTime;             // time1 (branch local time)
      var _lastBranch;            // last branch to be played
      var _lastTime;              // time2 (branch local time)
      var _t1 = null;                    // first time of time window
      var _t2 = null;                    // last time of time windo
      var _t = null;                     // first time to play
      var align = (params.hasOwnProperty("align"))? params.align : true;
      var startPriorityQueue = ["nextChapter" ,"prevChapter","startChapterId","startTime"];
      var endPriorityQueue = ["nextChapter","prevChapter", "finishChapterId","finishTime", "numChapters"];
      var temp = null;

      HumanTimeline._playParams = params;

      _startCondition = filterPriority(startPriorityQueue, params)[0] || "default";
      _endCondition = filterPriority(endPriorityQueue, params)[0] || "default";

      // Get branch, time for start and end conditions
      // TODO: Incorporate post-chapter transition (if present) as part of the chapter
      switch(_startCondition){
        case "nextChapter":
          // Play next chapter from start to finish in forwards order
          _firstTime = 0.0;
          _firstBranch = root.getNeighborChapter(root._nowBranch, "next");
          break;
        case "prevChapter":
          // Play the previous chapter from start to finish in forwards order
          _firstTime = 0.0;
          _firstBranch = root.getNeighborChapter(root._nowBranch, "previous");
          break;
        case "startChapterId":
          // play chapter by id and catch invalid ids
          _firstTime = 0.0;
          _firstBranch = root.getBranch({id: params.startChapterId});
          if (Human.utils.isEmpty(_firstBranch)){
            Human.log.warn("timeline.play", "Invalid chapter id: "+ params.startChapterId);
            return;
          }
          break;
        case "startTime":
          // start at specified time (default to 0)
          temp = root.mapGlobalTime(params.startTime, {tie: "later"});
          _firstBranch = temp.branch;
          _firstTime = temp.time;
          break;
        case "default":
          _firstBranch = root._chapters[0];
          _firstTime = 0.0;
      }

      switch(_endCondition){
        case "nextChapter":
          // play to the end of the target branch
          _lastBranch = _firstBranch;
          _lastTime = _lastBranch.getTimeFrame().lastTime;
          break;
        case "prevChapter":
          // play to the end of the target branch
          _lastBranch = _firstBranch;
          _lastTime = _lastBranch.getTimeFrame().lastTime;
          break;
        case "finishChapterId":
          // play chapter by id and catch invalid ids
          _lastBranch = root.getBranch({id: params.finishChapterId});
          if (Human.utils.isEmpty(_lastBranch)){
            Human.log.warn("timeline.play", "Invalid chapter id: "+ params.finishChapterId);
            return;
          }
          _lastTime = _lastBranch.getTimeFrame().lastTime;
          break;
        case "finishTime":
          // start at specified time (default to end). Edge case if finish time is 0.
          if (params.finishTime === 0){
            _lastBranch = root._chapters[0];
            _lastTime = 0.0;
          } else{
            var which = {tie: "earlier"};
            temp = root.mapGlobalTime(params.finishTime, which);
            _lastBranch = temp.branch;
            _lastTime = temp.time;
          }
          break;
        case "numChapters":
          // play up to numChapters or last chapter
          var startIndex = root.whereIsBranch(_firstBranch, {chapters:true});
          var numRemaining = root._chapters.length - startIndex;
          var numChapters = params.numChapters || 1;
          numChapters = Math.min(numChapters, numRemaining);
          _lastBranch = root._chapters[startIndex + numChapters - 1];
          _lastTime = _lastBranch.getTimeFrame().lastTime;
          break;
        case "default":
          _lastBranch = root._chapters[root._chapters.length - 1];
          _lastTime = "end";
      }

      // Convert to world time and check for forwards/backwards direction
      _t1 = root.mapBranchTime(_firstBranch, _firstTime);
      _t2 = root.mapBranchTime(_lastBranch, _lastTime);
      if (_t1 <= _t2){
        // play t1 -> t2 in forwards direction
        direction = "forwards";
        _t = _t1;
      } else {
        // play new t2 -> t1 in backwards direction
        temp = _t1;
        _t1 = _t2;
        _t2 = temp;
        _t = _t2;
        direction = "backwards";
      }

      // Account for alignment to start/end of chapter
      if (align) {
        if (direction === "forwards") {
          _t1 = root.mapBranchTime(_firstBranch, 0);
          _t2 = root.mapBranchTime(_lastBranch, "end");
        } else if (direction === "backwards") {
          _t1 = root.mapBranchTime(_lastBranch, 0);
          _t2 = root.mapBranchTime(_firstBranch, "end");
        }
      }

      /** Looping property
      * Priority goes to params.loop.
      * If not set in params, and only a single whole chapter is meant to be played
      * we will use the chapter's loop property.
      */
      if (params.loop === true){
        HumanTimeline.loop = true;
      } else {
        HumanTimeline.loop = false; // default
        var singleStarts = ["startChapterId","nextChapter","prevChapter"];
        var singleEnds = ["numChapters", "nextChapter", "finishChapterId"];
        if (singleStarts.indexOf(_startCondition) >= 0){
          if (singleEnds.indexOf(_endCondition) >= 0){
            if (_firstBranch.id === _lastBranch.id){
              HumanTimeline.loop = _firstBranch.animation.loop;
            }
          }
        }
      }

      // Update Timeline Play State and Parameters
      HumanTimeline._time1 = _t1;
      HumanTimeline._time2 = _t2;
      HumanTimeline.time = _t;
      setBorderConditions(direction);

      // Prepare for tick event
      HumanTimeline.playing = true;
      HumanTimeline.transitioning = false; //TODO: Handle setting of transitioning state
      HumanTimeline._lastWorldTime = (new Date()).getTime();
      Human.events.fire("timeline.played", {
          time: HumanTimeline.time
      });

    };

    // Filter parameters for start and end conditions
    var filterPriority = function(priorityQue, optionsMap){ // OPTIMIZATION: moved this func out here so it doesn't get redefined each time we play
        var okeys = Object.keys(optionsMap);
        var filterfunc = function(pqItem){
            return okeys.indexOf(pqItem)>=0;
        };
        return priorityQue.filter(filterfunc);
    };

    /** Stop the timeline.
    */
    HumanTimeline.stop = function(){

        // play state variables
        HumanTimeline.playing = false;
        HumanTimeline.transitioning = false;
        HumanTimeline.playQueue = [];

        // Human events
        Human.events.fire("timeline.stopped",{
          time: HumanTimeline.time
        });
    };

    /** Scrub to specific time on global timeline
    * @param.time            : global time to scrub to
    * @param.borderCondition : instructions for handling playing a border.
    * @param.chapterId       : move to the start of the specified chapterId
    * TODO:@params.playAudio     : False (default) to suppress audio publishing while scrubbing
    *
    * This function will also update play block to encompass desired time for
    * proper "unpausing" or resume play. Resets out-of-bounds scrub to play current
    * chapter.
    */
    HumanTimeline.scrub = function(params){
      var root = HumanTimeline.activeRoot;
      var time = 0;
      var bc = {which: "first", direction:"forwards"};
      var target;

      HumanTimeline.playQueue = [];
      HumanTimeline._scrubParams = params; // copy for bookmarks

      // Infer the desired global time based on parameters
      if (params.hasOwnProperty("time")){
        time = params.time;
      } else if (params.hasOwnProperty("chapterId")) {
        var branch = root.getBranch({id:params.chapterId});
        if (!!branch){
          time = root.mapBranchTime(branch, 0);
          bc = {which:"second", direction:"forwards"};
        } else {
          // in case of failure
          time = HumanTimeline.time;
        }

      }
      else {
        time = HumanTimeline.time;
      }
      if (params.hasOwnProperty("borderCondition")){
        var _bc = params.borderCondition;
        var _which = ["first","both","second"];
        var _direction = ["forwards","backwards"];
        if (_which.indexOf(_bc.which) >= 0){
          bc.which = _bc.which;
        }
        if (_direction.indexOf(_bc.direction) >= 0){
          bc.direction = _bc.direction;
        }
      }

      if (time === 0.0){
        bc = {which: "second", direction: "forwards"};
      } else if (time === root.getTimeFrame.lastTime){
        bc = {which: "first", direction:"forwards"};
      }

      // Update play block if scrub time is out of bounds
      if (time < HumanTimeline._time1 || time > HumanTimeline._time2) {
        target = root.mapGlobalTime(time, bc);
        HumanTimeline._time1 = root.mapBranchTime(target.branch, 0.0);
        HumanTimeline._time2 = root.mapBranchTime(target.branch, "end");
      }

      // Manage Play State
      HumanTimeline.playing = false;
      HumanTimeline.transitioning = false;

      // Determine Boundary Condition
      HumanTimeline.time = time;
      root.update(time, bc);
      Human.events.fire("timeline.scrubbed", {
          time: HumanTimeline.time
      });
    };

    /** Go to next chronological chapter, respecting properties.prevNextMode
    *
    * prevNextMode is set per chapter.
    * Needs to play all the way to the end of the proceeding transition (if present).
    * two modes are currently supported:
    * play :
    *     -- play current chapter (and transition) forwards and step into next chapter if next chapter not looping
    *     -- play next chapter and loop, if next chapter is looping
    * scrub :
    *     -- scrub directly to start of next
    *
    * TODO: Override currently looping chapter so that it finishes.
    * TODO: Properly handle border-condition instead of stepping 0.001 seconds into chapter.
    *
    * HACK: The behavior of 'prevNextMode' is not uniquely determined, depends on the property
    * of the next chapter. This is bad, but is needed for backwards compatibility.
    */
    HumanTimeline.next = function(){
        var root = HumanTimeline.activeRoot;
        var prevNextMode = Human.properties.properties["timeline.prevNextMode"];
        var nowBranch = root._nowBranch;
        var nextBranch = root.getNeighborChapter(nowBranch,"next");

        // Cancel if on last chapter.
        if (root.isLast(nowBranch)){
            Human.log.warn("timeline.next", "can't proceed beyond last chapter");
            return;
        }

        // Include proceeding transition if necesary
        var nowIndex = root.whereIsBranch(nowBranch);
        if (root._theQueue[nowIndex + 1].role === "transition"){
            nowBranch = root._theQueue[nowIndex + 1];
        }
        var finishTime = root.mapBranchTime(nowBranch,"end") + 0.001;

        if (prevNextMode === "play"){
            var playParams;
            if (nextBranch.animation.loop){
                playParams = {
                    startTime: root.mapBranchTime(nextBranch,0),
                    align: true,
                    finishTime: root.mapBranchTime(nextBranch, "end"),
                    loop: nextBranch.animation.loop,
                    queue: false
                };
            } else {
                // Play rest of this chapter forwards and just enter into next chapter
                playParams = {
                    startTime : HumanTimeline.time,
                    align: false,
                    finishTime : finishTime,
                    loop: false,
                    queue: true
                };
            }

            HumanTimeline.play(playParams);
        } else {
            // Default is to scrub
            HumanTimeline.scrub({
                time: finishTime
            });
        }

    };

    /** Go to previous chronological chapter, respecting properties.prevNextMode
    *
    * prevNextMode is set per chapter.
    * Needs to play all the way to the end of the proceeding transition (if present).
    * two modes are currently supported:
    * play :
    *     -- play previous chapter (and its transition) backwards
    * scrub :
    *     -- scrub directly to start of previous chapter
    */
    HumanTimeline.prev = function(){
        var root = HumanTimeline.activeRoot;
        var prevNextMode = Human.properties.properties["timeline.prevNextMode"];
        var nowBranch = root._nowBranch;

        // Cancel if on first chapter.
        if (root.isFirst(nowBranch)){
            Human.log.warn("timeline.next", "can't go to chapter before first chapter");
            return;
        }

        // transition (if present) will be included automatically by playing to beginning of previous chapter.
        var prevChapter = root.getNeighborChapter(nowBranch, "previous");
        var finishTime = root.mapBranchTime(prevChapter, "start") + 0.001;
        var playParams;
        if (prevNextMode === "play") {
            if (nowBranch.animation.loop) {
                // When current chapter is looping, go to start of previous chapter
                playParams = {
                    startTime: root.mapBranchTime(prevChapter,"start"),
                    align: true,
                    finishTime: root.mapBranchTime(prevChapter,"end"),
                    loop: prevChapter.animation.loop,
                    queue: false
                };
            } else {
                // play previous chapter backwards
                playParams = {
                    startTime: root.mapBranchTime(prevChapter, "end"),
                    align: false,
                    finishTime: root.mapBranchTime(prevChapter, "start"),
                    loop: false,
                    queue: false
                };
            }
            HumanTimeline.play(playParams);
        } else {
            // Default is to scrub
            HumanTimeline.scrub({
                time: finishTime
            });
        }
    };

    // ------------------------- BOOKMARKING -------------------------------------------------------------------------

    /**
     * Gets a bookmark of the timeline's current playing state. This does not bookmark the content
     * currently loaded within the timeline, so when restoring the bookmark, ensure that all the currently-loaded
     * animations and chapters are loaded first.
     * @memberof Human.timeline
     * @return The bookmark, which may be given to {@link Human.timeline.setBookmark} to restore it
     * @private
     */
    HumanTimeline.getBookmark = function(){
      var bookmarkParams = {};

      // bookmark root timeline if it exists:
      if (!!Human.timeline.activeRoot){
        bookmarkParams.rootName = Human.timeline.activeRoot.id;
      }

      // bookmark play parameters
      if (HumanTimeline.playing){
        bookmarkParams.play = HumanTimeline._playParams;
      } else {
        bookmarkParams.scrub = HumanTimeline._scrubParams;
      }
      return bookmarkParams;
    };

    /**
     * Sets timeline's playing state to given bookmark. Assumes that the animations and chapters
     * that were on the timeline when the bookmark was captured are currently loaded.
     * @memberof Human.timeline
     * @param {*} bookmark The bookmark
     * @private
     */
    HumanTimeline.setBookmark = function(bookmark){
      if (!!bookmark.rootName && HumanTimeline.rootTimelines.hasOwnProperty(bookmark.rootName)){
        HumanTimeline.activeRoot = HumanTimeline.rootTimelines[bookmark.rootName];
      } else if (!!bookmark.modules && !!bookmark.modules.activeModules) {
        // Search for appropriate root timeline form bookmark's active modules.
        var candidateTimelines = bookmark.modules.activeModules;
        candidateTimelines = candidateTimelines.filter(function(item){
            return Human.timeline.rootTimelines.hasOwnProperty(item);
        });
        if (candidateTimelines.length > 1){
            candidateTimelines = candidateTimelines.filter(function(item){
                return !Human.modules.isBaseModule(item);
            });
        }
        var rootName = candidateTimelines[0];
        Human.timeline.activeRoot = Human.timeline.rootTimelines[rootName];
      } else {
        Human.log.warn("Human.timeline.setBookmark: Unable to set appropriate root timeline");
      }
    };

    // ------------------------- BACKWARDS COMPATIBILITY -------------------------------------------------------------

    /** Backwards Compatiiblity: Pause()
    * Same as stop but with different human event.
    */
    HumanTimeline.pause = function(){
      HumanTimeline.playing = false;
      HumanTimeline.transitioning = false;

      // Human events
      Human.events.fire("timeline.paused", {
        time: HumanTimeline.time
      });
    };

    /** Backwards Compatibility: Unpause()
    * Play rest of current chapter (and only current chapter).
    */
    HumanTimeline.unpause = function(){
      var playParams = {
        startTime: HumanTimeline.time,
        numChapters : 1,
        loop: HumanTimeline.activeRoot._nowBranch.animation.loop
      };

      HumanTimeline.play(playParams);

      // Human Events
      Human.events.fire("timeline.unpaused", {
          time: HumanTimeline.time
      });
    };

    HumanTimeline.playFreeAnimations = function(){
      HumanTimeline.playfree = true;
    };

    HumanTimeline.pauseFreeAnimations = function(){
      HumanTimeline.playfree = false;
    };

    HumanTimeline.getTimeFrame = function(){
      if (Human.utils.isEmpty(HumanTimeline.activeRoot)){
        return 0.0;
      } else {
        return HumanTimeline.activeRoot.getTimeFrame();
      }
    };

    //
    HumanTimeline.getCurrentChapterCamera = function(){
      return Human.timeline.activeRoot._nowBranch.getCamera(0.0);
    };

    // Preserve play parameter naming conventions from older versions
    HumanTimeline._convertPlayParams = function(params){
      var result = params;
      if (params.hasOwnProperty("endTime")){
        result.finishTime = result.endTime;
      }
      if (params.hasOwnProperty("endChapterId")){
        result.finishChapterId = params.endChapterId;
      }

      return result;

    };

    // Query State of Timeline
    HumanTimeline.query = function () {

        if (!HumanTimeline.activeRoot){
          return {};
        }
        var chapters = HumanTimeline.activeRoot._assembleQueryChapters();
        return {
            chapters: chapters,
            time: HumanTimeline.time,
            timeFrame: HumanTimeline.getTimeFrame(),
            playing: HumanTimeline.playing,
            paused: !HumanTimeline.playing
        };
    };

    /** Destroy Chapter Sets: chapterSetId = moduleId
    * Don't destroy base anatomy chapter sets unless specifically requested.
    */
    HumanTimeline.destroyChapterSet = function(chapterSetId){
        HumanTimeline.stop();
        HumanTimeline.chapterList = [];
        if (HumanTimeline.rootTimelines.hasOwnProperty(chapterSetId)){
            HumanTimeline.rootTimelines[chapterSetId].destroy();
        } else if (!!chapterSetId){
            // Destroy all root timelines except base anatomy
            // TODO: Scene Reset (default properties)
            for (var rtid in HumanTimeline.rootTimelines){
              if (HumanTimeline.rootTimelines.hasOwnProperty(rtid)){
                  if (!Human.modules.isBaseModule(rtid)){
                      HumanTimeline.rootTimelines[rtid].destroy();
                  }
              }
            }
      } else {
        // invalid chapterset id
        Human.log.warn("timeline.destoryChapterSet","Invalid argument: " + chapterSetId);
      }
    };

    // -------------------------- INITIAL SCENE-GRAPH / ASSET-SERVER FUNCTIONS ---------------------------------------

    HumanTimeline.initTransparencies = function() {
        /* HACK: Only now do we know which objects are meant to be transparent.
        * This information comes from the material, and THEN gets applied to
        * the object's flag. Now that we know which objects are 'transparent'
        * we need to copy that information to all chapters.
        *
        * We should be able to take transparency outside of chapter's syncronization
        * provided that, (a) any transparency tweens that exist in the scene
        * are updated absolutely ... not conditionally, and (b) we aren't really
        * concerned with lack of optimal draw-call times for transparent objects that
        * are drawn fully opaque.
        */
        var transparentObjects = Human.scene.getTransparentObjects();
        var transObjId;
        var branch;
        var branchId;
        var chapters = Human.timeline.activeRoot._chapters;
        for (transObjId in transparentObjects){
            if (transparentObjects.hasOwnProperty(transObjId)){
                for (branchId = 0; branchId < chapters.length; branchId++){
                    branch = chapters[branchId];
                    if (branch.synchronization.hasOwnProperty(transObjId)){
                        branch.synchronization[transObjId].transparent = true;
                    } else {
                        branch.synchronization[transObjId] = {
                            transparent: true
                        };
                    }
                }
            }
        }
    };

    HumanTimeline.addMorphs = function (morphIds) {
        /* NOTE: The following relies on three assumptions
        * (a) If any tweens exist for a scene, they are already loaded at this point.
        * (b) We are loading 'whole' morph assets, not partial ones.
        * (c) There are morphs to be applied.
        *
        * Under these assumptions, after loading morphs we only have to replace
        * references to "dummy" leaf timelines with those of the newly updated
        * state-namespaced leaf timelines to which the morphs have been attached.
        */
        var branch;
        var branchIndex;
        var mapID;
        var leavesMapped;
        var mapData = {};
        var endTime;
        var leafEndTime;
        var rootTimes = Human.timeline.activeRoot._times;
        var rebuild = false;
        var morphNamespaces = {};

        if (morphIds.length === 0){
            return;
        }

        function updateMaps(leafName){
            if (Object.keys(leavesMapped).indexOf(leafName) < 0){
                mapData = {};
                mapData.start = rootTimes[branchIndex];
                mapData.end = rootTimes[branchIndex + 1];
                mapData.timeline = Human.timeline.leafTimelines[leafName]; //Guaranteed to exist
                mapData.fit = false;
                mapData.onEnd = "freeze";

                endTime = mapData.end - mapData.start; // essentially, the 'duration'
                branch.makeMapComponent(leafName,0, endTime, mapData);
            }

            if (branchIndex === Human.timeline.activeRoot._chapters.length -1){
                mapData = {};
                mapData.start = rootTimes[branchIndex];
                mapData.end = rootTimes[branchIndex + 1];
                mapData.timeline = Human.timeline.leafTimelines[leafName]; //Guaranteed to exist
                mapData.fit = false;
                mapData.onEnd = "freeze";

                leafEndTime = Human.timeline.leafTimelines[leafName].getTimeFrame().lastTime;
                if (leafEndTime !== mapData.end){
                    rebuild = true;
                    mapData.end = leafEndTime;
                    endTime = mapData.end - mapData.start; // essentially, the 'duration'
                    branch.makeMapComponent(leafName,0, endTime, mapData);
                }

            }
        }

        morphIds.forEach(function(item){
            morphNamespaces[item.split("/")[0]] = true;
        });

        var updatedLeaves = Object.keys(Human.timeline.leafTimelines).filter(function(leaf){
            return morphNamespaces[leaf];
        });

        // Replace references to dummy leaf, with those of newly changed leaf timelines.
        for (branchIndex = 0; branchIndex < Human.timeline.activeRoot._chapters.length; branchIndex++){
            branch = Human.timeline.activeRoot._chapters[branchIndex];

            // REMOVE maps to "dummy" leaf-timeline
            for (mapID in branch.maps){
                if (branch.maps.hasOwnProperty(mapID)){
                    if (branch.maps[mapID].data.timeline.id === "dummy"){
                        delete branch.maps[mapID];
                    }
                }
            }

            // ADD maps for updated leaves not yet mapped in branch
            leavesMapped = branch.getUniqueLeafTimelines();
            updatedLeaves.forEach(updateMaps);

            // Conditionally update last chapter if new morphs extend beyond

        }

        // Conditionally Rebuild
        if (rebuild){
            Human.timeline.activeRoot.build();
        }
    };

})();
;(function() {
    "use strict";

    Human.timeline.animationLoader = new Human.utils.Loader();

    Human.timeline.animationLoader.configure = function (params) {
        this._embedded = params.embedded;
        return this;
    };

    Human.timeline.animationLoader._animations = {};

    Human.timeline.animationLoader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localAnimationId = libraryId;
        var globalAnimationId = modelId + "." + libraryId;

        var self = this;
        var leaf;
        //Animations from the same state are grouped in the same leaf timeline
        if (!Human.timeline.leafTimelines.hasOwnProperty(modelId)){
          leaf = new Human.timeline.LeafTimeline(modelId);
        }

        Human.assets.server.getAnimationManifest(

            localAnimationId,

            function (manifest) {
                var errMsg;

                if (!manifest.format) {
                    errMsg = "'format' attribute expected in manifest for animation library '" + localAnimationId + "'";
                    Human.log.error("Human.timeline.animationLoader", errMsg);
                    error(errMsg);
                    return;
                }

                var loader;

                switch (manifest.format) {

                    case "binary":

                        // Morph

                        loader = Human.assets.morphs.loader;
                        break;

                    case "tween":

                        // Tween

                        loader = Human.timeline.tweenAnimationLoader;
                        break;

                    default:

                        // Unknown type

                        errMsg = "Unsupported value '" + manifest.format +
                            "' for 'format' in manifest for animation library '" + localAnimationId +
                            "' - supported values are 'binary' and 'tween'";

                        Human.log.error("Human.timeline.animationLoader", errMsg);

                        error(errMsg);

                        return;
                }

                loader.load(modelId, localAnimationId, globalAnimationId, manifest, params,
                    function () {
                        var leaf = Human.timeline.leafTimelines[modelId];
                        leaf.addAnimation(globalAnimationId, Human.timeline.animations[globalAnimationId]); // add to leaf
                        self._animations[globalAnimationId] = {
                            loader:loader
                        };
                        ok();
                    },
                    error);
            },
            function (errMsg) {
                var msg = "Failed to load animation library '" + localAnimationId + "': " + errMsg;
                Human.log.error("Human.timeline.animationLoader", msg);
                error(msg);
        });

    };

    Human.timeline.animationLoader._unload = function (globalLibraryId) {
        var animation = this._animations[globalLibraryId];
        if (animation) {
            animation.loader.unload(globalLibraryId);
            delete this._animations[globalLibraryId];
        }
    };

})();
;(function () {
    "use strict";

    /**
     * Loads a tween animation library
     */

    var TweenLoader = Human.timeline.tweenAnimationLoader = {};

    TweenLoader.load = function (modelId, localAnimationId, globalAnimationId, manifest, params, ok) {

        var tweenDefs = manifest.tweens || {};
        var tweenDef;
        var type;
        var tweenType;
        var controlType;
        var tokens;
        var control;
        var tween;
        var tweens = [];

        for (var tweenName in tweenDefs) {
            if (tweenDefs.hasOwnProperty(tweenName)) {

                tweenDef = tweenDefs[tweenName];

                // Validate tween data

                if (!tweenDef.keys) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'keys'");
                    continue;
                }

                if (!tweenDef.targets) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'targets'");
                    continue;
                }

                if (tweenDef.keys.length < 2 || tweenDef.targets.length < 2) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "tween has insufficient keys or targets - minimum of two required");
                    continue;
                }

                if (tweenDef.keys.length !== tweenDef.targets.length) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "tween has mismatching numbers of keys and targets");
                    continue;
                }

                tweenDef.options = Human.utils.applyIf(this.options, tweenDef.options || {});

                type = tweenDef.type;

                if (!type) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'type'");
                    continue;
                }

                tokens = type.split(":");

                tweenType = tokens[0];
                controlType = tokens[1];

                if (tweenType === "lerp") {
                    tweenType = "tween";
                }

                if (!tweenType || !controlType) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute invalid: 'type'");
                    continue;
                }

                // Create control strategy

                switch (controlType) {

                    // Tween attributes of a scene object

                    case "objectAttr":
                        control = new Human.timeline.ObjectControl({
                            modelId: modelId,
                            objectId: getAbsoluteID(modelId, tweenDef.objectId || tweenDef.targetId)
                        });
                        break;

                    // Tween attributes of a transform via a scene object

                    case "objectXForm":
                        control = new Human.timeline.ObjectTransformControl({
                            modelId: modelId,
                            objectId: getAbsoluteID(modelId, tweenDef.objectId || tweenDef.targetId),
                            initial: tweenDef.targets[0]
                        });
                        break;

                    // Tween attributes of a transform directly

                    case "transform":
                        control = new Human.timeline.TransformControl({
                            modelId: modelId,
                            transformId: getAbsoluteID(modelId, tweenDef.transformId || tweenDef.targetId),
                            initial: tweenDef.targets[0]
                        });
                        break;

                    // Tween attributes of a material

                    case "material":
                        control = new Human.timeline.MaterialControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId || tweenDef.targetId)
                        });
                        break;

                    // Tween attributes of a material's texture

                    case "texture":
                        control = new Human.timeline.TextureControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId || tweenDef.targetId),
                            targetLayer: tweenDef.targetLayer
                        });
                        break;

                    // Tween attributes of an annotation

                    case "annotation":
                        control = new Human.timeline.AnnotationControl({
                            modelId: modelId,
                            //annotationId: getAbsoluteID(modelId, tweenDef.annotationId || tweenDef.targetId)
                            annotationId: tweenDef.targetId
                        });
                        break;

                    // Tween a frenel on a material

                    case "fresnel":
                        control = new Human.timeline.FresnelControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId),
                            fresnelType: tweenDef.fresnelType
                        });
                        break;

                    // Tween camera

                    case "camera":
                        control = new Human.timeline.CameraControl();
                        break;

                    default:
                        Human.log.error("Human.timeline.tweenAnimationLoader", "Unsupported tween type: " + type);
                        continue;
                }

                // Create tween

                switch (tweenType) {

                    case "tween":

                        var options = tweenDef.options || {};

                        // Individual tweens inherit per-manifest 'timeline' flag if set,
                        // and will loop if the flag is false

                        if (manifest.timeline !== undefined) {
                            if (!manifest.timeline) {
                                options.loop = true;
                            }
                        }

                        tween = new Human.timeline.Tween({
                            keys: tweenDef.keys,
                            targets: tweenDef.targets,
                            control: control,
                            options: options
                        });
                        break;

                    case "switch":
                        tween = new Human.timeline.Switch({
                            keys: tweenDef.keys,
                            targets: tweenDef.targets,
                            control: control
                        });
                        break;

                    default:
                        Human.log.error("Human.timeline.tweenAnimationLoader", "Unsupported tween type: " + type);
                        continue;
                }

                tweens.push(tween);
            }
        }

        if (tweens.length > 0) {

            // Create tween animation
            // Only if we have valid tweens

            var animation = new Human.timeline.TweenAnimation({
                tweens: tweens,
                timeline: manifest.timeline // When false, animation runs independently of timeline (default is true)
            });

            // Add to timeline

            Human.timeline.addAnimation(globalAnimationId, animation);
        }

        // Errors will have been logged and absorbed

        ok();
    };

    /**
     * Converts an ID to an absolute ID if necessary.
     *
     * If the element ID has no "." then it is the relative ID of an element
     * within the given model. Otherwise, it will be the absolute ID of element
     * in another model.
     */
    function getAbsoluteID(modelId, elementId) {
        return (elementId.indexOf(".") < 0) ? modelId + "-" + elementId : elementId;
    }

    TweenLoader.unload = function (globalAnimationId) {

        // Remove through any leaf timeline that has globalAnimationId
        for (var ltid in Human.timeline.leafTimelines){
          if (Human.timeline.leafTimelines.hasOwnProperty(ltid)){
            var lt = Human.timeline.leafTimelines[ltid];
            if (lt.animations.hasOwnProperty(globalAnimationId)){
              lt.removeAnimation(globalAnimationId);
            }
          }
        }

        Human.timeline.removeAnimation(globalAnimationId);

    };

})();
;(function () {
    "use strict";

    /**
     * A tween animation on the {@link Human.timeline}.
     *
     * @param cfg {*}
     * @param cfg.tweens {{}}
     */
    Human.timeline.TweenAnimation = function (cfg) {

        this._options = cfg.options || { };

        this._tweens = cfg.tweens;

        this.timeline = cfg.timeline;

        /**
         * First key for this tween animation
         */
        this.firstTime = 1000000;

        /**
         * Last key for this tween animation
         */
        this.lastTime = -1000000;

        // Calculate time frame

        var tween;
        for (var i = 0, len = this._tweens.length; i < len; i++) {

            tween = this._tweens[i];

            if (tween.firstTime < this.firstTime) {
                this.firstTime = tween.firstTime;
            }

            if (tween.lastTime > this.lastTime) {
                this.lastTime = tween.lastTime;
            }
        }
    };

    /**
     * Updates this animation for the given time.
     *
     * @param {{}} ctx The animation context
     * @param {Number} time Current timeline time in seconds
     */
    Human.timeline.TweenAnimation.prototype.update = function (ctx, time) {
        for (var i = 0, len = this._tweens.length; i < len; i++) {
            this._tweens[i].update(ctx, time);
        }
    };

    /**
     * Destroys this animation.
     */
    Human.timeline.TweenAnimation.prototype.destroy = function () {
        var tween;
        for (var i = 0, len = this._tweens.length; i < len; i++) {
            tween = this._tweens[i];
            if (tween.destroy) {
                tween.destroy();
            }
        }
    };

})();
;(function () {
    "use strict";

    /**
     * A Human.timeline.Tween interpolates one or more attributes of some target engine element.
     *
     * A Tween is configured with a "control", which is a strategy object which which feeds the Tween's output
     * into the engine element.
     *
     * We also configure a Tween with "targets", each of which is a set of values to assign to attributes of the
     * engine element, at some instant in time.
     *
     * For each attribute that appears among the targets, the Tween will create within itself a Human.utils.LerpAttr,
     * which will animate that attribute through its target values.
     *
     * Whenever the Tween is updated with the current time, it updates each of its LerpAttr, then feeds the
     * aggregate set of outputs of those LerpAttr into the engine element, via the control strategy.
     *
     * For example:
     *
     * <pre>
     *     var lerp = new Human.timeline.Tween({
     *
     *          // Control the Human.view.Camera
     *
     *          control: new Human.timeline.CameraControl(),
     *
     *          // Sequence of target value sets, in this case each containing values for "eye", "look" and "up"
     *          // attributes to set on the Human.view.Camera. This will create three Human.utils.LerpAttr instances
     *          // within this Human.timeline.Tween, each in charge of interpolating one of these three attributes.
     *
     *          targets: [
     *              {
     *                  eye:  { x: 0, y: 0, z: -100 },
     *                  look: { x: 0, y: 0, z: 0 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              },
     *              {
     *                  eye:  { x: 10, y: 22, z: -10 },
     *                  look: { x: 0, y: 0, z: 20 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              }
     *          ],
     *
     *          // A time for each target
     *
     *          keys: [
     *              0,
     *              15
     *          ]
     *      });
     * </pre>
     *
     *
     *
     * @param cfg
     * @param cfg.keys Time for each target
     * @param cfg.targets Set of attribute values for each target
     * @param cfg.control Strategy to set the animated values on target engine element
     */
    Human.timeline.Tween = function (cfg) {

        // Adapter which controls the thing we're tweening
        // eg. a Human.timeline.CameraControl
        this._control = cfg.control;

        // Array of Human.utils.LerpAttr
        this._tweenList = [];

        var tweenMap = {};
        var target;
        var key;
        var attr;
        var targetAttr;
        var tween;
        var tweenAttr;

        // Create tweens

        for (var i = 0, len = cfg.targets.length; i < len; i++) {

            target = cfg.targets[i];
            key = cfg.keys[i];

            // Nested "attr" issue
            if (Human.utils.isObject(target.attr) && hasNestedObjects(target.attr)) {
                target = target.attr;
            }

            //Create a Tween for each attribute ("translate", "rotate" etc.) in target.
            // Each tween will contain a sub-tween for each of its target's elements ("x", "y" etc.)

            attr = target;

            for (var attrName in attr) {
                if (attr.hasOwnProperty(attrName)) {

                    targetAttr = attr[attrName];
                    tween = tweenMap[attrName];

                    if (!tween) { // Lazy-create

                        tweenAttr = this._control.attr[attrName];
                      //  if (!tweenAttr) {
                      //      Human.log.error("Human.timeline.Tween", "Attribute expected on control strategy: " + attrName);
                      //      continue;
                      //  }
                        tween = new Human.timeline.TweenAttr(tweenAttr, cfg.options);
                        tweenMap[attrName] = tween;
                        this._tweenList.push(tween);
                    }

                    tween.addTarget(key, targetAttr);
                }
            }
        }

        /**
         * First key for this tween
         */
        this.firstTime = cfg.keys[0];

        /**
         * Last key for this tween
         */
        this.lastTime = cfg.keys[cfg.keys.length - 1];
    };

    Human.timeline.Tween.prototype._run = function (ctx, time) {

        var countUpdated = 0;
        var tweenList = this._tweenList;

        // Update each tween
        for (var j = 0, len = tweenList.length; j < len; j++) {
            if (tweenList[j].update(ctx, time)) {
                countUpdated++;
            }
        }

        return countUpdated;
    };

    Human.timeline.Tween.prototype.query = function (ctx, time) {
        this._run(ctx, time);

        return this._control.attr;
    };

    /**
     * Updates this tween for the given time.
     *
     * @param {{}} ctx Animation context
     * @param {Number} time Time in seconds
     */
    Human.timeline.Tween.prototype.update = function (ctx, time) {
        // Update control if any tween was updated
        if (this._run(ctx, time) > 0) {
            this._control.update(ctx);
        }
    };

    function hasNestedObjects(obj) {
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop) && !Human.utils.isObject(obj[prop])) {
                return false;
            }
        }

        return true;
    }

})();
;/**
 * Tweens a set of attributes
 *
 * <p>Usage:</p>
 *
 * <pre>
 *     var lerp = new Human.timeline.TweenAttr({ x: 0, y: 0, z: 0 });
 *
 *     lerp.addTarget(1, { x: 0, y: 10, z: 1 });
 *     lerp.addTarget(2, { x: 5, y: 0, z: 0 });
 *     lerp.addTarget(4, { x: 10, y: 0, z: 1 });
 *
 *     var animationContext = {};
 *
 *     lerp.update(animationContext, 3);
 *
 * </pre>
 *
 * @param {{String:Object}} attr The attribute values to interpolate.
 * @param {{String:Object}} options Interpolation options
 * @param {Boolean} [options.loop] Flag indicating whether interpolation loops within the targets
 * @param {Number} [options.timeOffset] Time offset to add to time at each target given to {@link #addTarget}
 */

(function() {
    "use strict";

    Human.timeline.TweenAttr = function (attr, options) {

        /**
         * The attributes that are interpolated. This is the output of this interpolator.
         */
        this.attr = attr;

        this.attrNames = null;

        options = options || {};

        /**
         * A time in seconds for each target.
         */
        this.keys = [];

        /**
         * The targets - a list of target values for each attribute.
         *
         * <p>For example, if the attributes were {x,y,z}, then it would be this sort of thing:</p>
         *
         * <pre>
         * {
         *     "x": [32, 4, -23],
         *     "y": [-2, 40, 133],
         *     "z": [34, 0, 21]
         * }
         * </pre>
         */
        this.attrTargetLists = {};

        this._tweens = [];

        // Caches indexes of the pair of targets that the enclose the last time value given to #update
        this._key1 = 0;
        this._key2 = 1;

        // Caches the time values at the first and last keys, plus the range between them
        this._firstKey = null;
        this._lastKey = null;
        this._keyDiff = null;

        // True when this interpolator loops
        this._loop = !!options.loop;

        // Optional time offset to add to times given to #addTarget
        this._timeOffset = options.timeOffset || 0;

        // True when we need to re-pad the target lists
        this._paddingDirty = true;
    };

    /**
     * Adds a target to this Tween.
     *
     * <p>Example:</p>
     *
     * <pre>
     *     // Add a target at 4 seconds
     *     addTarget(4, { "x": 0, "y": 0, "z": -10 });
     * </pre>
     *
     * @param {Number} time Time in seconds for the target
     * @param {{String: Object}} attr Attribute values for the target
     */
    Human.timeline.TweenAttr.prototype.addTarget = function (time, attr) {

        time += this._timeOffset;

        // Add key time

        this.keys.push(time);

        var i = this.keys.length - 1;

        var targetList;
        var padded;
        var val;
        var j;
        var prev;

        for (var name in attr) {

            if (attr.hasOwnProperty(name)) {

                targetList = this.attrTargetLists[name];

                if (!targetList) {

                    if (this.keys.length > 1) {
                        throw "First target in tween must contain a value for each animated attribute on target";
                    }

                    targetList = this.attrTargetLists[name] = [];
                }

                val = attr[name];

                targetList[i] = val;
                if (typeof val !== "number") {
                    getCurve(val, time, targetList[i - 1], this.keys[i - 1]);
                }

                if (i > 0) {

                    padded = false;
                    j = i - 1;

                    while (!padded && j >= 0) {

                        prev = targetList[j];

                        // ? never hit ?
                        if (prev === undefined && prev === null) {
                            targetList[j] = val;
                            j--;
                        } else {
                            padded = true;
                        }
                    }
                }
            }
        }

        // Find key range

        if (this._firstKey === null || this._firstKey > time) {
            this._firstKey = time;
        }

        if (this._lastKey === null || this._lastKey < time) {
            this._lastKey = time;
        }

        this._keyDiff = this._lastKey - this._firstKey;

        this._paddingDirty = false;
    };


    Human.timeline.TweenAttr.prototype._padTargets = function () {

        var name;
        var attrTargetLists = this.attrTargetLists;
        var targetList;
        var numKeys = this.keys.length;
        var val;

        for (name in attrTargetLists) {

            if (attrTargetLists.hasOwnProperty(name)) {

                targetList = attrTargetLists[name];

                if (targetList.length === numKeys) {
                    continue;
                }

                val = targetList[targetList.length - 1];

                while (targetList.length < numKeys) {
                    targetList.push(val);
                }
            }
        }

        this._paddingDirty = false;
    };


    /**
     * Drives the interpolation factor on this Tween
     *
     * <p>Example:</p>
     *
     * <pre>
     * update(3.2);
     * </pre>
     *
     * @param {*} ctx Animation context
     * @param {Number} time Current timeline time in seconds
     * @return {Boolean} True if any attribute in {@link #attr} was modified
     */
    Human.timeline.TweenAttr.prototype.update = function (ctx, time) {

        if (this._paddingDirty) {
            this._padTargets();
        }

        var keys = this.keys;

        var names = this.attrNames ? this.attrNames : this.attrNames = Object.keys(this.attrTargetLists);

        if (this._loop) {

            time = this._firstKey + (time % this._keyDiff);

        } else {

            if (time < keys[0]) {
                this._key1 = 0;
                this._key2 = 1;
                this._clampToTarget(names, 0);
                return true;
            }

            if (time > keys[keys.length - 1]) {
                this._key1 = keys.length - 2;
                this._key2 = this._key1 + 1;
                this._clampToTarget(names, this.keys.length - 1);
                return true;
            }
        }

        while (keys[this._key1] > time) {
            this._key1--;
            this._key2--;
        }

        while (keys[this._key2] < time) {
            this._key1++;
            this._key2++;
        }

        var attrTargetLists = this.attrTargetLists;
        var key1 = this._key1;
        var key2 = this._key2;
        var targetList;
        var target1;
        var val;
        var attr = this.attr;
        var updated = false;
        var i, len, name;


        for (i = 0, len = names.length; i < len; i++) {

            name = names[i];
            targetList = attrTargetLists[name];
            target1 = targetList[key1];
            if (typeof target1 !== "number") {
                target1 = target1.value;
            }
            if (typeof targetList[key2] === "number") {
                val = lerp(time, keys[key1], keys[key2], target1, targetList[key2]);
            } else {
                val = bezier(time, targetList[key2]);
            }

            attr[name] = val;
            updated = true;
        }

        return updated;
    };


    // Query the tweened attribute at a specific time
    // Human.timeline.TweenAttr.prototype.query = function (ctx, time) {
    //   var _q_key1, _q_key2, _q_clamp_key = -1;
    //
    //   if (this._paddingDirty) {
    //       this._padTargets();
    //   }
    //
    //   var keys = this.keys;
    //
    //   var names = this.attrNames ? this.attrNames : this.attrNames = Object.keys(this.attrTargetLists);
    //
    //   if (this._loop) {
    //
    //       time = this._firstKey + (time % this._keyDiff);
    //
    //   } else {
    //
    //       if (time <= keys[0]) {
    //           _q_clamp_key = 0;
    //           _q_key1 = 0;
    //           _q_key2 = 1;
    //       }
    //       else if (time >= keys[keys.length - 1]) {
    //           _q_key1 = keys.length - 2;
    //           _q_key2 = _q_key1 + 1;
    //           _q_clamp_key = _q_key2;
    //       }
    //       else {
    //         _q_key1 = keys.length-2;
    //         _q_key2 = _q_key1 + 1;
    //         while (keys[_q_key1] > time) {
    //             _q_key1--;
    //             _q_key2--;
    //         }
    //
    //         while (keys[_q_key2] < time) {
    //             _q_key1++;
    //             _q_key2++;
    //         }
    //       }
    //   }
    //
    //   var attrTargetLists = this.attrTargetLists;
    //   var key1 = _q_key1;
    //   var key2 = _q_key2;
    //   var targetList;
    //   var target1;
    //   var val;
    //   var attr = this.attr;
    //   var i, len, name;
    //
    //   var result = {};
    //   for (i = 0, len = names.length; i < len; i++) {
    //       name = names[i];
    //       targetList = attrTargetLists[name];
    //       if (_q_clamp_key>=0){
    //         result[name] = targetList[_q_clamp_key];
    //       } else {
    //         target1 = targetList[key1];
    //         if (typeof target1 !== "number") {
    //             target1 = target1.value;
    //         }
    //         if (typeof targetList[key2] === "number") {
    //             val = lerp(time, keys[key1], keys[key2], target1, targetList[key2]);
    //         } else {
    //             val = bezier(time, targetList[key2]);
    //         }
    //         result[name] = val;
    //       }
    //   }
    //
    //   return result;
    // };


    /**
     * Sets the output (#attr) to the values of the target at the given index
     */
    Human.timeline.TweenAttr.prototype._clampToTarget = function (names, time) {
        var attr = this.attr;
        var attrTargetLists = this.attrTargetLists;
        var attrVal;
        var i, len, name;

        for (i = 0, len = names.length; i < len; i++) {
            name = names[i];
            attrVal = attrTargetLists[name][time];
            if (typeof attrVal !== "number") {
                attrVal = attrVal.value;
            }
            attr[name] = attrVal;
        }
    };

    function getCurve(target, time, prevTarget, prevTime) {
        if (typeof prevTarget !== "number") {
            prevTarget = prevTarget.value;
        }
        
        // generate bezier class
        var cp = target.controlPoints;
        var steps = Math.floor((time - prevTime) * 50);
        
        // x - t, y - attr value
        target.bezier = new Human.math.bezier(
            prevTime, prevTarget, 
            cp.x[0], cp.y[0], 
            cp.x[1], cp.y[1],
            time, target.value
            );
        target.lookUp = target.bezier.getLUT(steps);
    }

    function lerp(time, key1, key2, target1, target2) {
        var delta = (time - key1) / (key2 - key1);

        var w = target2 - target1;
        var offs = delta * w;

        return target1 + offs;
    }

    // get attr val from bezier curve lookUp
    function bezier(time, target) {
        var lookUp = target.lookUp;
        var low = 0;
        var high = lookUp.length - 1;
        var mid, sample1, sample2;

        if (time <= lookUp[low].x) {
            return lookUp[low].y;
        }

        if (time >= lookUp[high].x) {
            return lookUp[high].y;
        }

        while (low <= high) {
            mid = Math.floor((low + high) / 2);
            sample1 = lookUp[mid];
            sample2 = lookUp[mid + 1];

            if (sample1.x <= time && sample2.x >= time) {
                return lerp(time, sample1.x, sample2.x, sample1.y, sample2.y);
            } else if (sample1.x > time) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
    }

})();
;(function () {
    "use strict";

    var BEFORE = 1;     // Alpha before first key
    var START = 2;      // At first key
    var AFTER = 3;     // Alpha after last key
    var RUNNING = 4;    // Found keys before and after alpha

    /**
     * A Human.timeline.Switch animates one or more attributes of some target engine element along sequences
     * of discrete values.
     *
     * A Switch is configured with a "control", which is a strategy object which which feeds the Switch's output
     * into the engine element.
     *
     * We also configure a Switch with "targets", each of which is a set of values to assign to attributes of the
     * engine element, at some instant in time.
     *
     * Example:
     *
     * <pre>
     *     var tween = new Human.timeline.Switch({
     *
     *          // Control a Human.scene.object
     *
     *          control: new Human.timeline.ObjectControl(),
     *
     *          // Sequence of target value sets, in this case each containing values for "eye", "look" and "up"
     *          // attributes to set on the Human.view.Camera. This will create three Human.utils.LerpAttr instances
     *          // within this Human.timeline.Switch, each in charge of interpolating one of these three attributes.
     *
     *          targets: [
     *              {
     *                  eye:  { x: 0, y: 0, z: -100 },
     *                  look: { x: 0, y: 0, z: 0 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              },
     *              {
     *                  eye:  { x: 10, y: 22, z: -10 },
     *                  look: { x: 0, y: 0, z: 20 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              }
     *          ],
     *
     *          // A time for each target
     *
     *          keys: [
     *              0,
     *              15
     *          ]
     *      });
     * </pre>
     *
     *
     *
     * @param cfg
     * @param cfg.keys Time for each target
     * @param cfg.targets Set of attribute values for each target
     * @param cfg.control Strategy to set the animated values on target engine element
     */
    Human.timeline.Switch = function (cfg) {

        this._keys = cfg.keys;
        this._targets = cfg.targets;
        this._control = cfg.control;
        this._options = cfg.options || {};
        this._key = 0;
        this._lastKey = null;

        /**
         * First key for this tween
         */
        this.firstTime = cfg.keys[0];

        /**
         * Last key for this tween
         */
        this.lastTime = cfg.keys[cfg.keys.length - 1];
    };

    Human.timeline.Switch.prototype.query = function (ctx, time) {
        this._findTarget(time);
        return this._targets[this._key];
    };

    /**
     * Updates this tween for the given time
     *
     * @param {{}} ctx Animation context
     * @param {Number} time Time in seconds
     */
    Human.timeline.Switch.prototype.update = function (ctx, time) {

        var state = this._findTarget(time);

        switch (state) {
            case BEFORE:

                //this._clampToFrame(0);
                return;

            case START:
                break;

            case AFTER:
                break;
        }

        // if (this._lastKey !== this._key) {
        //     this._control.attr = this._targets[this._key];
        //     this._control.update(ctx);
        //     this._lastKey = this._key;
        // }

        // TODO: Check for necessity to change based on attribute comparison NOT on which key fired last
        // last fired key could have been in another chapter, and visibility is reset each chapter. 
        this._control.attr = this._targets[this._key];
        this._control.update(ctx);
        this._lastKey = this._key;
    };

    /**
     * Finds the index of the key/target for the given time value
     * @param time
     * @returns {number}
     * @private
     */
    Human.timeline.Switch.prototype._findTarget = function (time) {

        if (time < this._keys[0]) {
            this._key = 0;
            return BEFORE;
        }

        if (time === this._keys[0]) {
            this._key = 0;
            return START;
        }

        if (time > this._keys[this._keys.length - 1]) {
            this._key = this._keys.length - 1;
            return AFTER;
        }

        while (this._keys[this._key] > time) {
            this._key--;
        }

        while (this._keys[this._key + 1] !== undefined && this._keys[this._key + 1] !== null && this._keys[this._key + 1] < time) {
            this._key++;
        }

        return RUNNING;
    };

})();
;(function () {
    "use strict";

    /**
     * Controls the state of {@link Human.view.camera}.
     */
    Human.timeline.CameraControl = function () {

        /**
         * Camera attribute values.
         * These are set by the tween, which subsequently applies them to the camera with a call to #update()
         */
        this.attr = {
            up: { x: 0, y: 1, z: 0 },
            eye: { x: 0, y: 0, z: 0 },
            look: { x: 0, y: 0, z: 0 }
        };
    };

    /**
     * Sets this control's attribute values on the target camera
     * @returns {Boolean} True if the attribute was updated
     */
    Human.timeline.CameraControl.prototype.update = function (ctx) {

        // Don't update if camera animation is disabled

        if (ctx.cameraEnabled !== false) {
            Human.view.camera.setLookAt(this.attr);
            return true;
        }
    };

})();

;(function () {
    "use strict";

    /**
     * Controls the attributes of a material
     */
    Human.timeline.MaterialControl = function (params) {

        this._materialId = params.modelId + "." + params.materialId;

        /**
         * Material attribute values.
         * These are set by the tween, which subsequently applies them to the material with a call to #update()
         */
        this.attr = {
            baseColor: {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            specularColor: {
                r: 1.0,
                g: 1.0,
                b: 1.0
            }
        };
    };

    /**
     * Sets this control's attribute values on the target material
     * @returns {Boolean} True if the attribute was updated
     */
    Human.timeline.MaterialControl.prototype.update = function () {

        // Lazy-locate the target material
        // This is here so that we're not dependent on the material being loaded in advance

        var material = Human.assets.materials.materials[this._materialId];

        if (!material) {

            // Material not found

            if (!this._targetMissing) {

                // Warn once only

                Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find material: " + this._materialId);
                this._targetMissing = true;
            }

            return;
        }

        if (material.material) {

            var materialNode = material.material;
            var attr = this.attr;

            if (attr.baseColor) {
                materialNode.setBaseColor(attr.baseColor);
            }

            if (attr.specularColor) {
                materialNode.setSpecularColor(attr.specularColor);
            }

            return true;
        }
    };

})();
;(function () {
    "use strict";

    /**
     * Controls the state of a scene object
     */
    Human.timeline.ObjectControl = function (params) {

        var objectId = params.objectId;

        if (objectId.indexOf(".") < 0 && objectId.indexOf("-") < 0) {

            // Relative ID of object within this model
            objectId = params.modelId + "-" + params.objectId;

        } // Otherwise absolute ID of object in another model

        this._objectId = objectId;

        /**
         * Object attribute values.
         * These are set by the tween, which subsequently applies them to the object with a call to #update()
         */
        this.attr = {

            // A "virtual attribute" on the target Object

            attr: {
            }
        };
    };

    /**
     * Sets this control's attribute values on the target object
     */
    Human.timeline.ObjectControl.prototype.update = function () {

        // Lazy-locate the target object
        // This is here so that we're not dependent on the object existing in advance

        var object = Human.scene.objects[this._objectId];

        if (!object) {

            // Object not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.warn("Human.timeline.TweenAnimation", "'lerp:objectAttr' tween can't find object: " + this._objectId);
                this._targetMissing = true;
            }
            return;
        }

        // Don't update the object if there is a currently-active
        // chapter that makes it invisible
        var oinchapter = Human.timeline.activeRoot._nowBranch.synchronization[this._objectId];
        if (!oinchapter){
          updateObject(object, this.attr.attr);
        }
        else if (oinchapter.hasOwnProperty("shown") && oinchapter.shown !== false){
          updateObject(object, this.attr.attr);
        }
        else if (!oinchapter.hasOwnProperty("shown")){
          updateObject(object, this.attr.attr);
        }

        return;


    };

    /**
     * Recursively sets attributes on objects in the given subtree
     */
    function updateObject(object, attr) {

        if (attr.opacity !== undefined && attr.opacity !== null) {
            object.setOpacity(attr.opacity);
        }

        if (attr.pickable !== undefined && attr.pickable !== null) {
            object.setPickable(attr.pickable);
        }

        if (attr.shown !== undefined && attr.shown !== null) {
            object.show(attr.shown);
        }

        if (attr.transparent !== undefined && attr.transparent !== null) {
            object.setTransparent(attr.transparent);
        }

        if (object.objects.length > 0) {
            var objects = object.objects;
            for (var i = 0, len = objects.length; i < len; i++) {
                updateObject(objects[i], attr);
            }
        }
    }

})();
;(function () {
    "use strict";

    /**
     * Controls a scene object's transform
     */
    Human.timeline.ObjectTransformControl = function (params) {

        var objectId = params.objectId;
        var initial = params.initial;

        if (objectId.indexOf(".") < 0 && objectId.indexOf("-") < 0) {

            // Relative ID of object within this model
            objectId = params.modelId + "-" + params.objectId;

        } // Otherwise absolute ID of object in another model

        this._objectId = objectId;

        /**
         * Object's transform attribute values.
         * These are set by the tween, which subsequently applies them to the object's transform with a call to #update()
         */

        var attr = this.attr = {};

        ["translate", "rotate", "scale", "pivot"].forEach(function(xform) {
            var val = xform === "scale" ? 1 : 0;

            if (initial[xform] !== undefined) {
                attr[xform] = {};

                if (initial[xform].x !== undefined) {
                    attr[xform].x = val;
                }

                if (initial[xform].y !== undefined) {
                    attr[xform].y = val;
                }

                if (initial[xform].z !== undefined) {
                    attr[xform].z = val;
                }
            }
        });
    };

    /**
     * Sets this control's attribute values on the target object's transform
     */
    Human.timeline.ObjectTransformControl.prototype.update = function () {

        // Lazy-locate the target object
        // This is here so that we're not dependent on the object existing in advance

        var object = Human.scene.objects[this._objectId];

        if (!object) {

            // Object not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.warn("Human.timeline.ObjectTransformControl", "Can't find object: " + this._objectId);
                this._targetMissing = true;
            }

            return;
        }

        // Don't update the object if there is a currently-active
        // chapter that makes it invisible
        //TODO: Do we need to prevent transform update if object is not shown?
        // var shown = Human.timeline.showObjects[this._objectId];
        var shown = true;
        if (shown !== undefined && shown !== null && shown !== true) {
            return;
        }

        object.setTransform(this.attr);
    };

})();
;(function () {
    "use strict";

    /**
     * Manipulates the texture of a material in a Material Module
     */
    Human.timeline.TextureControl = function (params) {

        this._material = params.modelId + "." + params.materialId;

        // TODO: Temporary properties to deal with scenegraph vs legacy material names.
        this._scenegraphMaterial = params.modelId + "/" + params.materialId;

        if (params.targetLayer === undefined || params.targetLayer === null) {
            Human.log.error("Human.timeline.TweenAnimation", "'texture' tween attribute expected: 'targetLayer'");
            return;
        }

        this._targetLayer = params.targetLayer;

        /**
         * Material texture layer attribute values.
         * These are set by the tween, which subsequently applies them to the texture layer with a call to #update()
         */
        this.attr = {
            rotate: {z: 0},
            translate: {x: 0, y: 0},
            scale: {x: 1, y: 1},
            blend: {factor: 1.0}
        };
    };

    /**
     * Sets this control's attribute values on the target material's texture
     */
    Human.timeline.TextureControl.prototype.update = function () {

        // Lazy-locate the target material
        // This is here so that we're not dependent on the material being loaded in advance

        var material = Human.assets.materials.materials[this._scenegraphMaterial] || Human.assets.materials.materials[this._material];

        if (!material) {

            // Material not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find material: " + this._material);
                this._targetMissing = true;
            }

            return;
        }

        // Update the material texture layer

        var textures = material.textures;

        if (this._targetLayer >= 0 && this._targetLayer < textures.length) {

            var texture = textures[this._targetLayer];
            var attr = this.attr;

            if (attr.scale) {
                texture.setScale(attr.scale);
            }

            if (attr.translate) {
                texture.setTranslate(attr.translate);
            }

            if (attr.rotate !== undefined && attr.rotate !== null) {
                texture.setRotate(attr.rotate.z);
            }

            if (attr.blend !== undefined && attr.blend !== null) {
                texture.setBlendFactor(attr.blend.factor);
            }
        }
    };


})();
;(function () {
    "use strict";

    /**
     * Controls the attributes of a material
     */
    Human.timeline.FresnelControl = function (params) {

        this._materialId = params.modelId + "." + params.materialId;
        this._fresnelType = params.fresnelType;

        // Fresnel attribute values.
        // These are set by the tween, which subsequently applies them to the fresnel with a call to #update()
        //
        this.attr = {
            bias: {
                edge: 0.0,
                center: 0.7,
                power: 1.0
            },
            edge: {
                r: 0.8,
                g: 0.7,
                b: 0.7
            },
            center: {
                r: 0.05,
                g: 0.05,
                b: 0.09
            }
        };
    };

    /**
     * Sets this control's attribute values on the target material
     * @returns {Boolean} True if the attribute was updated
     */
    Human.timeline.FresnelControl.prototype.update = function () {

        if (!this._fresnel) {

            // Lazy-locate the target material
            // This is here so that we're not dependent on the material being loaded in advance

            var material = Human.assets.materials.materials[this._materialId];

            if (!material) {

                // Material not found

                if (!this._materialMissing) {

                    // Warn once only

                    Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find material: " + this._materialId);
                    this._materialMissing = true;
                }

                return;
            }

            // Get color channel, eg "emitFresnel" -> "emit"
            var type = this._fresnelType.length <= 7 ? this._fresnelType : this._fresnelType.substring(0, this._fresnelType.length - 7);

            this._fresnel = material.fresnels[type];

            if (!this._fresnel) {

                // Fresnel not found

                if (!this._fresnelMissing) {

                    // Warn once only

                    Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find fresnel type: " + this._fresnelType);
                    this._fresnelMissing = true;
                }

                return;
            }
        }

        // TODO: Avoid needlessly resetting each attribute?

        var bias = this.attr.bias;

        this._fresnel.setEdgeBias(bias.edge);
        this._fresnel.setCenterBias(bias.center);
        this._fresnel.setPower(bias.power);
        this._fresnel.setEdgeColor(this.attr.edge);
        this._fresnel.setCenterColor(this.attr.center);

        return true;
    };

})();;(function () {
    "use strict";

    /**
     * Manipulates a transformation asset
     */
    Human.timeline.TransformControl = function (params) {

        var initial = params.initial;

        this.transformId = params.modelId + "." + params.transformId;

        /**
         * Transform values.
         * These are set by the tween, which subsequently applies them to the transform with a call to #update()
         */
         
        var attr = this.attr = {};

        ["translate", "rotate", "scale", "pivot"].forEach(function(xform) {
            var val = xform === "scale" ? 1 : 0;

            if (initial[xform] !== undefined) {
                attr[xform] = {};

                if (initial[xform].x !== undefined) {
                    attr[xform].x = val;
                }

                if (initial[xform].y !== undefined) {
                    attr[xform].y = val;
                }

                if (initial[xform].z !== undefined) {
                    attr[xform].z = val;
                }
            }
        });
    };

    /**
     * Sets this control's attribute values on the target transformation
     */
    Human.timeline.TransformControl.prototype.update = function () {

        // Lazy-locate the target transform
        // This is here so that we're not dependent on the transform existing in advance

        var transform = Human.assets.transforms.transforms[this.transformId];

        if (!transform) {

            // Transform not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.error("Human.timeline.TransformControl", "Can't find transform: " + this.transformId);
                this._targetMissing = true;
            }

            return;
        }

        transform.set(this.attr);
    };

})();;(function () {
    "use strict";

    /**
     * Controls the state of an {@link Human.view.annotations.Annotation}.
     */
    Human.timeline.AnnotationControl = function (params) {

        this._annotationId = params.annotationId;

        /**
         * Camera attribute values.
         * These are set by the tween, which subsequently applies them to the camera with a call to #update()
         */
        this.attr = {
            pos: {x: 0, y: 0, z: 0},
            shown: true,
            labelShown: true
        };
    };

    /**
     * Sets this control's attribute values on the target annotation
     * @returns {Boolean} True if the annotation was updated
     */
    Human.timeline.AnnotationControl.prototype.update = function () {

        // Lazy-locate the target annotation
        // This is here so that we're not dependent on the annotation being loaded in advance

        var annotation = Human.view.annotations.annotations[this._annotationId];

        if (!annotation) {

            if (!this._targetMissing) {

                // Annotation not found
                // Warn once only

                Human.log.error("Human.timeline.AnnotationControl", "'annotation' tween can't find annotation: " + this._annotationId);
                this._targetMissing = true;
            }

            return;
        }

        var attr = this.attr;
        var updated = false;

        var pos = attr.pos;
        if (pos !== undefined && pos !== null) {
            annotation.pin.setPos([pos.x, pos.y, pos.z]);
            updated = true;
        }

        var shown = attr.shown;
        if (shown !== undefined && shown !== null) {
            annotation.setShown(shown);
            updated = true;
        }

        var labelShown = attr.labelShown;
        if (labelShown !== undefined && labelShown !== null) {
            annotation.label.setShown(labelShown);
            updated = true;
        }

        return updated;
    };

})();
;/**
 * @namespace Updates the camera as timeline chapters are activated
 */
(function () {
    "use strict";

    var ChapterCameras = Human.timeline.chapterCameras = {};

    /**
     * Camera interpolated along a path when true
     * @type {boolean}
     */
    ChapterCameras.pathMode = false;

    // The timeline chapter list
    var chapters = [];

    // Path of lookats
    var sequence = [];

    // A time value for each lookat on the path
    var timeline = [];

    // The current time on the path
    var time = 0;

    // Enables of disables camera animation
    var enabled = true;

    Human.properties.subscribe({
        propId: "timeline.chapterCamerasEnabled",
        value: enabled,
        callback: function (value) {
            enabled = !!value;
        }
    });

    Human.events.on("timeline.chapters.updated",
        function (chapterList) {
            clear();
            var chapter;
            var camera;
            for (var i = 0, len = chapterList.length; i < len; i++) {
                chapter = chapterList[i];
                camera = chapter.flyTo || chapter.jumpTo;
                if (camera) {
                    camera.time = chapter.time;
                    add(camera);
                }
            }
            chapters = chapterList;
        });

    Human.events.on("timeline.playing",
        function (params) {
            if (!enabled) {
                return;
            }
            if (ChapterCameras.pathMode) {
                setTime(params.time);
            }
        });

    Human.events.on("timeline.scrubbed",
        function (params) {
            if (!enabled) {
                return;
            }
            if (ChapterCameras.pathMode) {
                setTime(params.time);
            }
        });

    Human.events.on("timeline.chapters.activated",
        function (params) {
            if (!enabled) {
                return;
            }
            if (!ChapterCameras.pathMode) {
                var chapter = chapters[params.newChapterIndex];
                if (chapter) {
                    if (chapter.flyTo) {
                        Human.view.camera.fly.flyTo(chapter.flyTo);
                    } else if (chapter.jumpTo) {
                        Human.view.camera.fly.jumpTo(chapter.jumpTo);
                    }
                }
            }
        });

    function clear() {
        sequence = [];
        timeline = [];
        time = 0.0;
    }

    function add(lookat) {
        if (sequence.length === 0) {
            time = 0.0;
        }
        timeline.push(lookat.time);
        sequence.push(lookat);
    }

    function setTime(t) {
        time = t;
        update();
    }

    function getTotalTime() {
        if (timeline.length > 0) {
            return timeline[timeline.length - 1];
        }
        return 0;
    }

    function update() {
        if (sequence.length === 0) {
            return;
        }
        if (time <= timeline[0]) {
            Human.view.camera.setLookAt(sequence[0]);
            return;
        }
        if (time >= getTotalTime() || sequence.length === 1) {
            Human.view.camera.setLookAt(sequence[sequence.length - 1]);
            return;
        }
        var i = 0;
        while (timeline[i] < time) {
            ++i;
        }
        lerp(time, i - 1);
    }

    function lerp(t, i) {
        var t1 = timeline[i];
        var t2 = timeline[i + 1];
        var a = sequence[i];
        var b = sequence[i + 1];
        Human.view.camera.setLookAt( {
            eye: lerpVec(t, t1, t2, a.eye, b.eye),
            look: lerpVec(t, t1, t2, a.look, b.look),
            up: lerpVec(t, t1, t2, a.up, b.up)
        });
    }

    function lerpVec(t, t1, t2, p1, p2) {
        var f2 = (t - t1) / (t2 - t1);
        var f1 = 1.0 - f2;
        return  {
            x: p1.x * f1 + p2.x * f2,
            y: p1.y * f1 + p2.y * f2,
            z: p1.z * f1 + p2.z * f2
        };
    }
})();
;/**
 * @namespace Auto-plays the timeline after a period of user inactivity
 */
(function () {
    "use strict";

    var timeout = null;

    var enabled = false;
    var autoPlaying = false;

    Human.properties.subscribe({
        propId: "timeline.autoPlay.enabled",
        value: enabled,
        callback: function (value) {
            enabled = !!value;

            if(enabled) {
              startCountdown();
            } else {
              autoPlaying = false;
            }
        }
    });

    var timeoutSecs = 10;

    Human.properties.subscribe({
        propId: "timeline.autoPlay.timeoutSecs",
        value: timeoutSecs,
        callback: function (value) {
            timeoutSecs = value;
        }
    });

    var type = "play";

    var types = {

        play: function () {
            Human.timeline.play({
                startTime: Human.timeline.time
            });
        },

        'chapter-rotate': function () {
            var _wait = 5000;

            var _rotate = function () {
                if(!autoPlaying) {
                    return;
                }

                var startX = Human.view.camera.eye.x;
                var i = 0;
                var _interval = 20;

                var rotateInt = setInterval(function () {
                    if(!autoPlaying) {
                        clearInterval(rotateInt);
                    }

                    Human.view.camera.rotateY(0.5);


                    var diff = Math.abs(startX - Human.view.camera.eye.x);

                    if((diff <= 0.005 && i > _interval * 5) || i > _interval * 40) {
                        clearInterval(rotateInt);
                        setTimeout(_play, _wait);
                    }

                    i++;
                }, _interval);
            };

            var _play = function () {
                if(!autoPlaying) {
                    return;
                }

                //go to beginning if at end
                if(Human.timeline.time === Human.timeline.getTimeFrame().lastTime) {
                    Human.timeline.scrub({ time: 0 });
                    setTimeout(_rotate, _wait);
                } else {
                    Human.timeline.next();
                }

                Human.events.once('timeline.stopped', function () {
                    setTimeout(_rotate, _wait);
                });
            };

            _play();

        }

    };

    Human.properties.subscribe({
        propId: "timeline.autoPlay.type",
        value: type,
        callback: function (value) {
            type = value;
        }
    });

    // Start countdown when engine starts

    Human.events.on("started",
        function () {
            startCountdown();
        });

    // Start countdown when timeline stops

    Human.events.on("timeline.stopped",
        function () {
            startCountdown();
        });

    // (Re)start countdown when user interacts with the UI

    var listeners = {};

    listen("mousedown");
    listen("keydown");
    listen('mousewheel');

    function listen(type) {
        $(document).bind(type,
            listeners[type] = function () {
                autoPlaying = false;
                startCountdown();
            });
    }

    function startCountdown() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }

        if (!enabled) {
            return;
        }

        timeout = setTimeout(function () {
            if (enabled && !Human.timeline.playing && !autoPlaying) {
                autoPlaying = true;

                var method = types[type] || types.play;
                method();
            }
        }, timeoutSecs * 1000);
    }

})();
;/**
 * @class Interpolates a {@link Human.view.camera} along a curved path from current position to look at a
 * target region of space.
 * @private
 *
 */
(function () {
    "use strict";

    // var velocity = 1.0; //should make use of this
    // var stopFOV = 55.0; //should make use of this

    //var tempVec = Human.math.vec3(); // should make use of this

    /**

     var fly = new Human.timeline.CameraFlyTo({

        time1: 0,
        time2: 1,

        // Start point
        eye1: { x: 0, y: 0, z: -100 },
        look1: { x: 0, y: 0, z: 0 },
        up1: { x: 0, y: 1, z: 0 },

        // Destination
        eye2: { x: -40, y: 0, z: 0 },
        look2: { x: 0, y: 10, z: 0 },
        up2: { x: 0, y: 1, z: 0 },

        // called whenever the time given to #update is outside time1 and time2
        onComplete: function() {
        }
     });

     */
    Human.timeline.CameraFlyTo = function (cfg) {

        cfg = cfg || {};

        this._time1 = cfg.time1 || 0;
        this._time2 = cfg.time2 || 1;

        var math = Human.math;
        var camera = Human.view.camera;
        this.type = "lerp:camera"; //for registering with timeline
        this.easing = cfg.easing !== false;

        // Starting condition
        this._look1 = math.vec3ObjToArray(cfg.look1 || camera.look);
        this._eye1 = math.vec3ObjToArray(cfg.eye1 || camera.eye);
        this._up1 = math.vec3ObjToArray(cfg.up1 || camera.up);

        // Ending condition
        this._look2 = math.vec3ObjToArray(cfg.look2);
        this._eye2 = math.vec3ObjToArray(cfg.eye2);
        this._up2 = math.vec3ObjToArray(cfg.up2);

        // Starting pan
        this.tweenPan = false;
        if (cfg.hasOwnProperty("pan1")){
          //this._pan1 = math.vec3ObjToArray(camera.getScreenPan());
          this._pan1 = math.vec3ObjToArray(cfg.pan1);
          this._pan2 = math.vec3ObjToArray(cfg.pan2);
          this.tweenPan = true;
        } else if (cfg.hasOwnProperty("pan2")){
          this._pan1 = math.vec3ObjToArray(camera.getScreenPan());
          this._pan2 = math.vec3ObjToArray(cfg.pan2);
          this.tweenPan = true;
        }

        // Completion callback
        this._onComplete = cfg.onComplete;
        this.getTimeFrame = function(){
            return {
                firstTime: this._time1,
                lastTime: this._time2
            };
        };

    };


    /** Update the interpolation to push the next state to the bound {@link Human.view.camera}
     */

    var eyeVec = Human.math.vec3();
    var lookVec = Human.math.vec3();


    Human.timeline.CameraFlyTo.prototype.update = function (time) {

        var math = Human.math;

        if (time < this._time1 || time > this._time2) {
            this._onComplete(this);
            return false;
        }

        var t = (time - this._time1) / (this._time2 - this._time1);

        t = this.easing ? this._ease(t, 0, 1, 1) : t;

        math.lerpVec3(t, 0, 1, this._eye1, this._eye2, eyeVec);
        math.lerpVec3(t, 0, 1, this._look1, this._look2, lookVec);
        var up = math.lerpVec3(t, 0, 1, this._up1, this._up2, []);

        Human.view.camera.setLookAt({
            look: math.vec3ArrayToObj(lookVec),
            eye: math.vec3ArrayToObj(eyeVec),
            up: math.vec3ArrayToObj(up)
        });

        if (this.tweenPan){
          var sp = math.lerpVec3(t,0,1,this._pan1, this._pan2, []);
          sp = math.vec3ArrayToObj(sp);
          Human.view.camera.setScreenPan(sp);
        }


        return true;
    };


    Human.timeline.CameraFlyTo.prototype.query = function (time) {

        var math = Human.math;

        if (time < this._time1 || time > this._time2) {
            this._onComplete(this);
            return false;
        }

        var t = (time - this._time1) / (this._time2 - this._time1);

        t = this.easing ? this._ease(t, 0, 1, 1) : t;

        math.lerpVec3(t, 0, 1, this._eye1, this._eye2, eyeVec);
        math.lerpVec3(t, 0, 1, this._look1, this._look2, lookVec);
        var up = math.lerpVec3(t, 0, 1, this._up1, this._up2, []);

        var sp = math.lerpVec3(t,0,1,this._pan1, this._pan2, []);

        var result = {
            look: math.vec3ArrayToObj(lookVec),
            eye: math.vec3ArrayToObj(eyeVec),
            up: math.vec3ArrayToObj(up),
            screenPan: math.vec3ArrayToObj(sp)
        };

        return result;
    };

    // Quadratic easing out - decelerating to zero velocity
    // http://gizma.com/easing

    Human.timeline.CameraFlyTo.prototype._ease = function (t, b, c, d) {
        t /= d;
        return -c * t * (t - 2) + b;
    };

    Human.timeline.CameraFlyTo.prototype.stop = function () {
    };
})();
;/** Leaf timeline
 * Direct controller of animation assets (morphs and tweens)
 * Animations can come from model (state folder) or tween/morph creator functions.
 * Free Animations will be registered here, but played/updated by root.
 * Options to ignore animated camera.
 */
Human.timeline.LeafTimeline = function (name, params) {
    "use strict";

    var self = this;
    params = params || {};
    self.level = "leaf";			     // Identifies the kind of timeline
    self.id = name;                // use required 'name' arguemnt
    self.animations = {};          // all animations (free and timeline)
    self.timelineAnimations = {};  // controlled by branch timelines
    self.freeAnimations = {};		   // always update on tick.
    self.cameraTween = null;       // Null or first camera tween in animations.

    //Camera Controls
    self.animationCtx = {
        cameraEnabled: true			//Default is to allow animation camera tweens to play if present
    };

    //Register With Timeline Controller
    Human.timeline.leafTimelines[self.id] = self;


    /**
     * Attaches animation to leaf.
     * Animation object is a collection of tween/morph objects
     */
    self.addAnimation = function (animationId, animation) {
        // Validate
        if (!animation) {
            Human.log.error("LeafTimeline.addAnimation", "null or undefined animation object");
            return;
        }

        if (!animation.update) {
            //All animations must come with update() function
            Human.log.error("LeafTimeline.addAnimation", "Param expected: update");
            return;
        }

        // Replace and attach
        if (self.animations[animationId]) {
            self.removeAnimation(animationId);
        }
        self.animations[animationId] = animation;


        // Attach to free or timeline
        if (animation.timeline === false) {
            // Free
            self.freeAnimations[animationId] = animation;

        } else {
            // Controlled
            self.timelineAnimations[animationId] = animation;
        }

        //Look for and register first camera tween object
        if (!self.cameraTween) {

            var found = false;
            var i;
            var len;
            var tweens = animation._tweens || [];
            var tween;
            var CameraControl = Human.timeline.CameraControl;

            for (i = 0, len = tweens.length; i < len && !found; i++) {
                tween = tweens[i];
                if (tween._control) {
                    if (tween._control instanceof CameraControl) {
                        found = true;
                        self.cameraTween = tween;
                    }
                }
            }
        }

        Human.events.fire("Timeline.Loaded");
    };

    /**
     * Destroy animation (all tweens/morphs associated)
     */
    self.removeAnimation = function (animationId) {

        var animation = self.animations[animationId];

        // Validate
        if (!animation) {
            Human.log.warn("Human.timeline.LeafTimeline.removeAnimation", "Animation not found: " + animationId);
            return;
        }


        // Remove from free and controlled collections
        if (animationId in self.freeAnimations) {
            delete self.freeAnimations[animationId];
        } else {
            delete self.timelineAnimations[animationId];
        }
        delete self.animations[animationId];

        // Destroy animaton (tween/morph prototype function)
        if (animation.destroy) {
            animation.destroy();
        }
    };

    /**
     * Returns maximum time frame in the collection of animations.
     */
    self.getTimeFrame = function () {

        var anyAnimations = false;
        var max = 0;
        var timeFrame;
        var lastTime;
        var timelineAnimations = self.timelineAnimations; // OPTIMIZATION: avoid dereference each iteration

        // Count all controlled Animations
        for (var animationId in  timelineAnimations) {
            if (timelineAnimations.hasOwnProperty(animationId)) {

                anyAnimations = true;
                lastTime = timelineAnimations[animationId].lastTime;
                max = Math.max(max, lastTime);
            }
        }

        // Result
        timeFrame = {
            firstTime: 0.0,
            lastTime: max
        };

        return timeFrame;
    };

    /**
     * Calls the update() function on all constituent timelines for the passed time.
     * @param boolean cameraEnabled  Whether to play camera tween or not
     */
    self.update = function (cameraEnabled, time, params) {
        params = params || {};

        // Defaults to play camera tween unless told not to.
        var ctx = {
            cameraEnabled: cameraEnabled === false ? cameraEnabled : self.animationCtx.cameraEnabled
        };

        var timelineAnimations = self.timelineAnimations; // OPTIMIZATION: avoid dereference each iteration
        var animation;

        // Update all timeline Animations to given time
        for (var animationId in timelineAnimations) {
            if (timelineAnimations.hasOwnProperty(animationId)) {

                //TODO: patch to make up for dynamic camera tweens having different update interface
                animation = timelineAnimations[animationId];

                if (animation.type === "lerp:camera") {
                    //tween returned by flyTo() function -- dynamic tween
                    animation.update(time);
                } else {
                    animation.update(ctx, time);
                }
            }
        }
    };

    /** Remove references to Animations
     */
    self.destroy = function () {
        self.animations = {};
        self.freeAnimations = {};
        self.timelineAnimations = {};
        self.cameraTween = null;
    };


    /** hide all objects controlled by constituent animations
     * TODO: Rethink how to temporarily hide timeline objects after finishing playing
     */
    self.hide = function () {
        var objectsToHide = {};
        var referencedObjectIds = self.getReferencedObjectIds(false);
        var objectId;
        for (objectId in referencedObjectIds) {
            if (referencedObjectIds.hasOwnProperty(objectId)) {
                objectsToHide[objectId] = false;
            }
        }
        Human.scene.setVisibleObjects({
            objectIds: objectsToHide
        });
    };

    /** Get camera of timeline at specific time
     * Leaf timelines should only have one or zero cameras
     * Returns camera info at time t if camera exists otherwise null.
     */
    self.getCamera = function (time) {
        if (self.cameraTween === null || self.cameraTween === undefined) {
            return null;
        }
        return self.cameraTween.query(self.cameraTween._control, time);
    };

    //  -----------------------   TWEEN QUERYING AND PARSING ----------------------------

    /** get all tween objects from animations of specified type
     * type: "opacity","shown"
     * returns list of tween objects
     *
     * Note: Attribute tween objects do not have access to the id
     *  of the object to which it applies; that is the propery of the parent
     *  "Tween" class.
     */
    self.getTweensByType = function (animType, result) { // OPTIMIZATION: Avoid GC by passing result in caller-provided array, return new length

        var lenResult = 0;
        var animations = self.animations;
        var animId;


        if (animType === "shown" || animType === "visibility") {
            for (animId in animations) {
                if (animations.hasOwnProperty(animId)) {
                    lenResult = self._visibilityTweens(animations[animId], result, lenResult);
                }
            }
        } else if (animType === "opacity" || animType === "transparency") {
            for (animId in animations) {
                if (animations.hasOwnProperty(animId)) {
                    lenResult = self._opacityTweens(animations[animId], result, lenResult);
                }
            }
        }

        return lenResult;
    };

    /** Get all tweens referenced by leaf
     */
    self.getTweenLibraries = function () {

        var result = [];
        var animations = self.animations;
        var animationLib;

        for (var libId in animations) {
            if (animations.hasOwnProperty(libId)) {

                animationLib = animations[libId];

                if (animationLib._tweens) {
                    result.push(animationLib);
                }
            }
        }

        return result;
    };

    /** Get all referenced object ids
     * Return {id: value}
     * TODO: List all objectIds from animations (and check that they are objects)
     */
    self.getReferencedObjectIds = function () {

        var tweenLibs = self.getTweenLibraries();
        var result = []; // list of objects
        var i;
        var leni;
        var tweenLib;
        var j;
        var lenj;
        var tween;
        var objectId;

        for (i = 0, leni = tweenLibs.length; i < leni; i++) {

            tweenLib = tweenLibs[i];

            for (j = 0, lenj = tweenLib.length; j < lenj; j++) {

                tween = tweenLib[j];
                objectId = tween._control._objectId;

                if (objectId !== null && objectId !== undefined) { // Might be a zero integer
                    if (result.indexOf(objectId) < 0) {
                        result.push(objectId);
                    }
                }
            }
        }

        return result;
    };

    /** Extract from one animation asset any object that keys the visibility asset.
     * Visibility tweens are controlled by Human.timeline.Switch tween objects.
     * animationAsset: packaged group of aniamtion objects, grouped together on export.
     *
     * Accesses switch objects, which have both the query method and the objectId in the same ojb
     */
    self._visibilityTweens = function (animationAsset) {

        var tweens = animationAsset._tweens;

        if (!tweens) {
            return [];
        }

        var switchTweens = tweens.filter(filterSwitch);

        return switchTweens.filter(filterTargets);
    };

    // take only switch asset._tweens[idx] objects
    function filterSwitch(item) { // OPTIMIZATION: Cache callback
        return item instanceof Human.timeline.Switch;
    }

    // keep switch object that has targets acting on "shown" property
    function filterTargets(item) {  // OPTIMIZATION: Cache callback

        var targets = item._targets;

        if (!targets || targets.length === 0) { // OPTIMIZATION: Trivial reject up front
            return false;
        }

        var i;
        var len;

        for (i = 0, len = targets.length; i < len; i++) {
            if (targets[i].attr.hasOwnProperty("shown")) {
                return true; // OPTIMIZATION: Avoid needless iteration
            }
        }

        return false;
    }

    /** Extract from one animation asset any object that keys the opacity asset
     * Opacity/transparency tweens are controlled by Human.timeline.Tween/Human.timeline.Switch tween objects, respectively.
     * animationAsset: packaged group of animation objects, grouped together on export.
     * Assumes, but does not check, that each opacity tween (real number tween 0-to-1) has a corresponding
     *     transparency tween (binary tween on/off)
     *
     * Accesses TweenAttr objects, which has the query method but NOT the objectId.
     */
    self._opacityTweens = function (animationAsset) {

        var tweens = animationAsset._tweens;

        if (!tweens) {
            return [];
        }

        var tweenTweens = tweens.filter(filterTween);

        return tweenTweens.filter(filterOpacity);
    };

    // take only Tween asset._tweens[idx] objects
    var filterTween = function (item) { // OPTIMIZATION: Cache this callback
        return item instanceof Human.timeline.Tween;
    };

    // keep tween objects that apply to opacity attribute, even if other attributes are simultaneously tweened.
    function filterOpacity(item) { // OPTIMIZATION: Cache this callback

        var tList = item._tweenList;

        if (!tList || tList.length === 0) { // OPTIMIZATION: Trivial reject up front
            return false;
        }

        var i;
        var len;
        var tli;
        var TweenAttr = Human.timeline.TweenAttr;
        var atl;

        for (i = 0, len = tList.length; i < len; i++) {
            tli = tList[i];
            if (tli instanceof TweenAttr) {
                atl = tli.attrTargetLists;
                if (atl) {
                    if (atl.hasOwnProperty("opacity")) {
                        return true; // OPTIMIZATION: Avoid needless iteration
                    }
                }
            }
        }

        return false;
    }


    /** query Tween Animations of specific attribute
     * attribute = ["shown","visibility","opacity"]
     *
     * return:
     *  {objectid: {attribute: value}}
     *
     * NOTE: all attributes tweened on any tween object will be reported.
     *    E.G. Querying "shown" (a SWITCH object) may return both "shown" and "transparent" attributes.
     *
     * NOTE: This is a tween-first search. We may want to implement an object-first search also.
     */
    self.queryTweens = function (attribute, time) {

        if (attribute === "visibility") {
            attribute = "shown";
        }

        var result = {}; // TODO: Pass in as arg, reuse this object at RPC level to avoid GC?
        var attrTweens = [];
        var i;
        var numAttrTweens = self.getTweensByType(attribute, attrTweens);
        var tween;
        var q;
        var attr;

        for (i = 0; i < numAttrTweens; i++) {

            tween = attrTweens[i];
            q = tween.query({}, time);
            attr = q.attr;

            if (attr.hasOwnProperty(attribute)) {
                result[tween._control._objectId] = attr[attribute];
            } else {
                result[tween._control._objectId] = attr;
            }
        }

        return result;
    };

};
;
/** Branch timeline
 * Construction modalities:
 *    - chapter: one module and chapter data block
 *    - transition: two branch nodes
 * Branch timelines control updates to leaf timelines.
 * Used for chapters and transitions (built or dynamic).
 * Can reference as many leaf-timelines as desired.
 * Must update all animations in leaf.
 * Should not map to two-different times on the same leaf.
 * Special Handling of First Update to ensure all branches are independent.
 *    - Object Mode Overrides (show, select, pickthrough, etc)
 *    - Synchronize showObjects wtih visibility tween status.
 *      NOTE: This should be unnecessary if tweens update worked properly for visibility.
 *    - Handle Camera position
 * Concerns:
 *    - Camera Animation:
 *      Engine can only handle one camera tween because there is only one Camera
 *      object. Theoretically, however, each branch map can point to one
 *      or more leaftimlines with a camera path. We currently have to stick with
 *      one; arbitrarily chosen to be the first one encountered.
 *      TODO: Tack and Obey "timeline.chapterCameraPath" property.
 *
 * TODO: Make this inherit from "chapter" data object?
*/
Human.timeline.BranchTimeline = function(humanChapter, role) {
    "use strict";
    var self = this;  // self refers to a specific chapter branch timeline object.
    self._onEndOptions = ["loop", "freeze", "hide"]; //options for any constituent timelines after it has ended
    self.id = humanChapter.id;
    self.level = "branch";
    self.role = role;                 //"chapter","transition"
    self.childTimelines = {};
    self.maps = {};                    // Unique map components to map from branch timeline to child timelines - for animations
    self.media = {};
    self.firstUpdate = true;          // on first update we want to force the camera into correct position
    self.sceneInitialized = false;
    self.cameraInitialized = false;
    self.cameraInitCanceled = false;
    self.annotationsInitialized = false;
    self.annotationInitCanceled = false;
    self.animation = {loop: false};    // Whether the whole branch should loop when branch is instructed to play
    self.camera = {};
    self.timeRange = null;
    self.moduleId = null;
    self.vizTweens = {};

    // Optional Information
    self.info = {
        displayName: "",
        description: "",
    };

    // Optional settings
    self.options = {};

    // Per-Chapter Properties
    self.properties = {};

    // Chapter synchronization instructions per-object
    self.synchronization = {};

    // TODO: Overrides require disabling of tweens base on controller type and property type.
    // Optional Overrides of object modes
    //self.overrides = {}

    // Optional Annotations
    self.annotations = [];

    // Transition Information (only if requested by chapter definition)
    self.transition = {};


    self.setRole = function (role) {
        if (role === "chapter") {
            self.role = "chapter";
        } else if (role === "transition") {
            self.role = "transition";
        } else {
            Human.log.error("Failed to set role of branch timeline. Setting to chapter");
            self.role = "chapter";
        }
    };


    self.makeMediaClip = function (clipData) {
        var corrclip = {};
        if (clipData.streamType === "audio") {
            corrclip = Human.media.audio.getClipById(clipData.clipId);
        } else if (clipData.streamType === "video") {
            corrclip = Human.media.videos.getClipById(clipData.clipId);
        }
        clipData = Human.scene.sets.union(corrclip, clipData);
        self.addClip(clipData.streamType + "_" + clipData.clipId, clipData);
    };

    /** make a map component - can have more than one per branch
     * Builds a map component to map between branch timeline and its child timelines, and registers the map
     * with the branch timeline.
     *
     * childTimeline must exist
     *
     * @mapId              : unique id for the map object
     * @startTime          : branch time at which to start mapping to children
     * @endTime            : branch time at which to stop mapping to children
     * @childTimelines    : child timeline to register and map to
     * @mapData            : object containing map information
     * @mapData.timeline  : leaf timeline on which to map
     * @mapData.start     : when on leaf timeline to start
     * @mapData.end       : when on leaf timeline to end
     * @mapData.onEnd     : behavior when end of map is reached
     * @mapData.fit       : whether to stretch/compress leaf to fit duration of chapter.
     */
    self.makeMapComponent = function (mapId, startTime, endTime, mapData, params) {
        params = params || {};
        var map = {};
        map.mapId = mapId;
        map.start = startTime;
        map.end = endTime;
        map.data = {};
        // Assign map details to map object
        map.data = mapData;

        // Create mapping function childTime = f(branchTime) : map.calcChildTime()
        var m;
        var b;
        if (map.data.fit) {
            // y = mx+b;
            var dy = map.data.end - map.data.start;
            var dx = map.end - map.start;
            m = dy / dx;
            b = map.data.start;
            map.calcChildTime = function (branchTime) {
                return m * (branchTime - map.start) + b;
            };
        }
        else {
            //y = mx + b;  x can be offset by where in time the map starts.
            m = 1.0;    //by definition
            b = map.data.start;
            if (map.data.onEnd === "freeze" || map.data.onEnd === "hide") {
                map.calcChildTime = function (branchTime) {
                    var y = m * (branchTime - map.start) + b;
                    return Math.min(y, map.data.end);
                };
            } else if (map.data.onEnd === "loop") {
                map.calcChildTime = function (branchTime) {
                    //SawTooth Function
                    var period = map.data.end - map.data.start;
                    var x = (branchTime - map.start);
                    return x - (period * Math.floor(x / period)) + b;
                };
            } else {
                Human.log.warn("WARNING: invalid onEnd property for branch timeline map data.");
            }
        }

        //Register any new childTimeline and mapObject
        if (!self.childTimelines.hasOwnProperty(mapData.timeline.id)) {
            self.childTimelines[mapData.timeline.id] = mapData.timeline;
        }
        self.maps[mapId] = map;

        self.timeRange = self.getTimeFrame(); // update time range in case new map has changed it.
    };


    /** Add Audio/Video clip and attaches update function.
     Mandatory clip properties
     @clip.alternatives
     @clip.description
     @clip.displayName
     @clip.fullUrl
     @clip.streamType
     @clip.time1
     @clip.time2
     @clip.type
     */
    self.addClip = function (clipMap, clip) {

        if (self.media.hasOwnProperty(clipMap)) {
            delete self.media[clipMap];
        }

        if (!clip.hasOwnProperty("fullUrl")){
            clip.fullUrl = Human.media[clip.streamType].clips[clip.clipId].fullUrl;
        }

        var mclip = {"data": clip, "published": false};

        mclip.publish = function () {
            console.log("publishing " + clip.fullUrl);
            Human.events.fire(clip.streamType + ".suggestedClipInfo", this.data);
            Human.events.fire(clip.streamType + ".suggestedClips", [this.data.clipId], true);
            this.published = true;
        };

        mclip.update = function (time) {
            if (this.data.time1 <= time && time <= this.data.time2) {
                if (!this.published) {
                    this.publish();
                }
            }
        };

        self.media[clipMap] = mclip;

    };

    self._getAudio = function () {
        var audioClips = [];
        for (var clipId in self.media) {
            if (self.media.hasOwnProperty(clipId)) {
                if (self.media[clipId].data.streamType === "audio") {
                    audioClips.push(self.media[clipId].data);
                }
            }
        }
        return audioClips;
    };

    /** Get Branch Time Duration information
     * Returns {firstTime:value, lastTime: value}
     */
    self.getTimeFrame = function () {
        var longestTime = 0.0;
        for (var amapId in self.maps) {
            if (self.maps.hasOwnProperty(amapId) && self.maps[amapId].end > longestTime) {
                longestTime = self.maps[amapId].end;
            }
        }
        if (longestTime === 0.0) {
            longestTime = 2.0;//Default time frame.
        }
        var _timeFrame = {
            firstTime: 0.0,
            lastTime: longestTime
        };
        return _timeFrame;
    };

    // Return time if in between timeline.getTimeFrame() else return first or last time in range.
    self.checkChildTime = function (timeline, time) {
        var timeLimits = timeline.getTimeFrame();
        var okTime = time;
        if (time > timeLimits._lastTime) {
            okTime = timeLimits._lastTime;
        } else if (time < timeLimits._firstTime) {
            okTime = timeLimits._firstTime;
        }
        return okTime;
    };

    // Returns a valid option for onEnd in timeline-map objects
    self.checkOnEnd = function (onEnd) {
        if (self._onEndOptions.indexOf(onEnd) >= 0) {
            return onEnd;
        } else {
            return "freeze";
        }
    };

    //Returns true if the branch requires an animated transition on activation
    self.needsAnimatedTransition = function () {
        if (!Human.utils.isEmpty(self.transition)) {
            return true;
        }
        else {
            return false;
        }
    };

    /** Returns where the camera should be
     *
     * Returns camera eye/look/up of the whole branch at time
     * TODO: ensure we have Human.view.camera.fly.calcEyeLookUp() defined
     * Order = Camera Tween, Transition, Camera, Default
     */
    self.getCamera = function (time) {

        if (time === "end") {
            time = self.getTimeFrame().lastTime;
        } else if (time === "start") {
            time = 0.0;
        }

        // If camera is tweened query the camera tween: Return eye/look/up
        var cameraLocation = self.getAnimatedCamera(time);
        if (cameraLocation) {
            cameraLocation.screenPan = cameraLocation.screenPan || self.options.screenPan;
            return cameraLocation;
        }

        // If transition, use transition target. Must return eye/look/up
        // if (!Human.utils.isEmpty(self.transition)) {
        //     // var ttarget = self.transition.camera.target;
        //     // var validTransition = false;
        //     // if (ttarget === "enabledObjects") {
        //     //     var enabled = self.overrides.showObjects;
        //     //     var _target = {boundary: Human.scene.getBoundary(enabled)};
        //     //     cameraLocation = Human.view.camera.fly.calcEyeLookUp({target: _target});
        //     //     validTransition = true;
        //     // }
        //     // else if (ttarget.hasOwnProperty("eye") && ttarget.hasOwnProperty("look")) {
        //     //     cameraLocation = ttarget;
        //     //     validTransition = true;
        //     // }
        //     //
        //     // if (validTransition) {
        //     //     cameraLocation.screenPan = self.options.screenPan;
        //     //     return cameraLocation;
        //     // }
        // }

        // If chapter has camera property
        if (!Human.utils.isEmpty(self.camera)) {
            cameraLocation = self.camera.location;
            cameraLocation.screenPan = self.options.screenPan;
            return cameraLocation;
        }

        // Otherwise Use Default
        var defaultCamera = Human.view.camera._startcamera; //Fallback if no other methods found
        defaultCamera.screenPan = self.options.screenPan;
        return defaultCamera;
    };


    // Returns camera eye/look/up for first animated camera tween in branch
    self.getAnimatedCamera = function (time) {
        var timeRange = self.getTimeFrame();

        //cast time
        if (time === "start" || time < timeRange.startTime) {
            time = timeRange.startTime;
        } else if (time === "end" || time === "last" || time > timeRange.lastTime) {
            time = timeRange.lastTime;
        }

        var cameraMap = self.whichCameraMap(0);

        if (cameraMap === null || cameraMap === undefined) {
            return null;
        } else if (time >= cameraMap.start && time <= cameraMap.end) {
            var childTimeline = cameraMap.data.timeline;
            var childtime = cameraMap.calcChildTime(time);
            var camera = childTimeline.getCamera(childtime);
            if (camera !== null && camera !== undefined) {
                return camera;
            }
        } else {
            return null;
        }
    };

    /** camera preference -
     * Returns the map object with the camera tween to be played or Null
     */
    self.whichCameraMap = function (time) {
        if (self.role === "transition") {
            return self.maps.transitionCamera;
        } else if (self.role === "chapter") {
            var targetMaps = self.whichMaps(time);
            var idx;
            for (idx=0; idx<targetMaps.length; idx++){
                if (!!targetMaps[idx].map.data.timeline.cameraTween){
                    return targetMaps[idx].map;
                }
            }

        }
        //return null if current branch does not have an animated camera tween in its data
        return null;
    };

    // Set Synchronization
    self._handleSynchronization = function () {

        // Single-traversal object property setting procedure
        Human.scene.setObjectProperties(self.synchronization);
    };

    /** On activation properties per chapter
     */
    self._handleProperties = function () {

        //xray mode - option
        if (self.options.xray === true) {
            Human.rpc.call(null, "xray.setEnabled", {enable: true});
        } else {
            Human.rpc.call(null, "highlight.setEnabled", {enable: true});
        }

        //screen pan - option
        var spo = Human.view.camera.getScreenPan();
        var spn = self.options.screenPan;
        if (spo.x !== spn.x || spo.y !== spn.y || spo.z !== spn.z) {
            Human.view.camera.setScreenPan(spn);
        }

        //All other properties
        Human.properties.set(self.properties);

        //Effects
        Human.view.effects.setEnabled({effectIds: self.effects, replace: true});
    };

    //On activation create annotations
    self._handleAnnotations = function () {
        //clear all annotations
        Human.view.annotations.clearAnnotations();

        //add ones defined in chapter
        self.annotations.every(function (annotation, i) {
            var annotationId = "___" + self.id + "." + i;
            var pos;
            if (!annotation.pos && annotation.objectId) {
                var object = Human.scene.objects[annotation.objectId];
                pos = object.getCenter();
            }
            Human.view.annotations.createAnnotation({
                annotationId: annotationId,
                objectId: annotation.objectId,
                title: annotation.title || "",
                description: annotation.description || "",
                pos: annotation.pos || pos,
                dir: annotation.pinVec || annotation.dir,
                type: annotation.type || "default",
                enabled: (annotation.type === "secondary")? false: true,
                shown: (annotation.type === "secondary")? false: true,
                labelShown: (annotation.type === "secondary")? false: true,
                labelOffset: annotation.labelOffset || null,
                saved: true,
                occludable: annotation.occludable,
                followsObject: annotation.followsObject
            });
            return true;
        });
    };

    //Reset
    self.reset = function () {
        self.firstUpdate = true;
        self.sceneInitialized = false;
        self.cameraInitialized = false;
        self.annotationsInitialized = false;
        if (self.maps.hasOwnProperty("transitionCamera")) {
            delete self.maps.transitionCamera;
        }

        // Reset media objects
        var media = self.media;
        var key;
        var mediaObj;

        // VERIFY: I'm assuming that each item in self.media is an object with a 'published' property
        for (key in media) {
            if (media.hasOwnProperty(key)) {
                mediaObj = media[key];
                mediaObj.published = false;
            }
        }
    };

    /** returns all maps to play and whether to use their camera
     * TODO: clean up logic of whichMaps()
     */
    self.whichMaps = function (time) {
        var theMapIds = [];
        var result = [];

        if (time === "start") {
            time = 0.0;
        } else if (time === "end") {
            time = self.getTimeFrame().lastTime;
        }


        for (var mapId in self.maps) {
            if (self.maps.hasOwnProperty(mapId)) {
                var map = self.maps[mapId];
                if (time >= map.start && time <= map.end) {
                    theMapIds.push(mapId);
                }
            }
        }

        //Prefer "keepCamera" over "camera"
        if (theMapIds.indexOf("transitionCamera") >= 0) {
            var ci = theMapIds.indexOf("camera");
            if (ci !== null && ci !== undefined) {
                theMapIds.splice(ci, 1);
            }
        }

        theMapIds.every(function (mapId) {
            var map = self.maps[mapId];
            var o = {map: map};
            if (map.data.timeline.level === "leaf") {
                o.camera = Human.properties.properties['timeline.cameraAnimationEnabled'];
                result.push(o);
            } else {
                o.camera = false;
                result.unshift(o);
            }
            return true;
        });

        return result;

    };

    /** Gets leaf timeline ids and their times to be played at time
     * Returns {name:timeline}
     */
    self.getChildLeafTimelines = function (time) {
        var maps = self.whichMaps(time);
        var result = {};
        maps.every(function (d) {
            var leaf = d.map.data.timeline.id;
            var leafTime = d.map.calcChildTime(time);
            result[leaf] = leafTime;
            return true;
        });
        return result;
    };

    // Get unique child timelines
    self.getUniqueLeafTimelines = function () {
        var result = {};
        for (var mapid in self.maps) {
            if (self.maps.hasOwnProperty(mapid)) {
                var map = self.maps[mapid];
                result[map.data.timeline.id] = map.data.timeline;
            }
        }
        return result;
    };

    /** Query tween attribute of all objects controlled by branch
     * attribute: "visibility", "shown", "opacity"
     */
    self.query = function (attribute, time) {
        var result = {};
        var leafTimes = self.getChildLeafTimelines(time);
        for (var leafId in leafTimes) {
            if (leafTimes.hasOwnProperty(leafId)) {
                var ltime = leafTimes[leafId];
                var objAttrs = Human.timeline.leafTimelines[leafId].queryTweens(attribute, ltime);
                result = Human.scene.sets.union(result, objAttrs);
            }
        }
        return result;
    };

    self.initScene = function() {
        if (self.sceneInitialized) {
            return;
        }

        self.sceneInitialized = true;

        if (self.role === "chapter") {
            Human.events.fire("timeline.chapters.activating", {
                chapterId: self.id
            });
        }
        self._handleProperties();
        self._handleSynchronization();
        Human.view.annotations.clearAnnotations();
    };

    self.initCamera = function(time, ok) {
        if (typeof time === "function") {
            ok = time;
            time = 0;
        }

        if (self.cameraInitialized) {
            if (ok) {
                ok();
            }
            return;
        }

        self.cameraInitialized = true;
        self.cameraInitCanceled = false;

        /**
         * Update camera if:
         * (a) does not need animated transition,
         * and
         * (b) does not have a camera tween
         */
        if (!self.needsAnimatedTransition() && !self.whichCameraMap(time)) {
            if (self.camera.action === "flyTo") {
                Human.view.camera.fly.flyTo(self.camera.location, ok);
            }
            else {
                Human.view.camera.fly.jumpTo(self.camera.location, ok);
            }

            if (self.camera.location.screenPan) {
                Human.view.camera.setScreenPan(self.camera.location.screenPan);
            }
        } else if (ok) {
            ok();
        }
    };

    self.initAnnotations = function() {
        if (self.annotationsInitialized) {
            return;
        }

        self.annotationsInitialized = true;
        self._handleAnnotations();
    };

    /** update branch - all applicable maps encompossing time.
     * params.playAudio = true/false
     *
     */
    self.update = function (time, params) {
        params = params || {};

        // Handle first update
        if (self.firstUpdate) {
            self.firstUpdate = false;

            self.timeRange = self.getTimeFrame();

            if (!self.sceneInitialized) {
                self.initScene();
                Human.renderer.compile();
            }

            if (self.cameraInitCanceled) {
                if (!self.annotationInitCanceled) {
                    self.initAnnotations();
                }
                self._update2(time);
            } else {
                self.initCamera(time, function() {
                    if (!self.annotationInitCanceled) {
                        self.initAnnotations();
                    }
                    self._update2(time);
                });
            }
            return;
        }

        self._update2(time);

    };

    self._update2 = function (time) {
        if (self.timeRange === null || self.timeRange === undefined) {
            self.timeRange = self.getTimeFrame();
        }

        var timeRange = self.timeRange;

        if (time === "start" || time < timeRange.startTime) {
            time = timeRange.startTime;
        } else if (time === "end" || time === "last" || time > timeRange.lastTime) {
            time = timeRange.lastTime;
        }


        //update timeline maps
        var mapsData = self.whichMaps(time);

        mapsData.forEach(function (d) {
            var map = d.map;
            var cam = d.camera;
            var childTimeline = map.data.timeline;
            var childTime = map.calcChildTime(time);
            childTimeline.update(cam, childTime);

            // TODO: Rethink how to temporarily hide timeline objects after finishing playing
            if (childTime === map.data.end && map.data.onEnd === "hide") {
                childTimeline.hide();
            }
            return true;
        });

        //update media clips
        for (var mediaId in self.media) {
            if (self.media.hasOwnProperty(mediaId)) {
                self.media[mediaId].update(time);
            }
        }
    };


    self.destroy = function(){
      // Destroys leaf timelines
      var utl = self.getUniqueLeafTimelines();
      for (var ltid in utl){
        if (utl.hasOwnProperty(ltid) && ltid !=="dummy"){
          utl[ltid].destroy();
          delete Human.timeline.leafTimelines[ltid];
        }
      }
      Human.view.annotations.clearAnnotations();
  };

  // Initialization from humnaChapter object;
  var clipMap, timelineId;
  self.info.displayName = humanChapter.displayName;
  self.info.description = humanChapter.description;
  self.synchronization = humanChapter.createInstructions();
  self.properties = humanChapter.properties;
  self.annotations = humanChapter.annotations;
  self.transition = humanChapter.transition;
  self.options = humanChapter.options;
  self.camera = humanChapter.camera;
  self.animation = humanChapter.animation;
  self.effects= humanChapter.effects;
  self.reflections = humanChapter.reflections;

  // branch media objects.
  for (clipMap in humanChapter.media){
      if (humanChapter.media.hasOwnProperty(clipMap)){
          self.addClip(clipMap, humanChapter.media[clipMap]);
      }
  }

  // branch timeline maps
  var mapid;
  humanChapter.timelineMap.forEach(function(map, idx){

    // Get Child Timeline Object Or Exit
    timelineId = map.data.timeline;
    if (Human.timeline.leafTimelines.hasOwnProperty(timelineId)){
      map.data.timeline = Human.timeline.leafTimelines[timelineId];
    } else {
      Human.log.warn("Unknown leaf timeline: " + timelineId);
      map.data.timeline = Human.timeline.leafTimelines.dummy;
    }
    mapid = timelineId + "_" + idx;

    // Make Map Component
    self.makeMapComponent(mapid, map.start, map.end, map.data);
  });

  //Register with Modified Timeline
  Human.timeline.branchTimelines[self.id] = self;


};
;/** Root timeline
 * Construction modalities:
 *    - by chapter loader: all chapters converted to branches. all branches added to root.
 *    - by module loader: if no chapters, module is cast as chapter, converted to branch, and added to root.
 *    - potentially by a user in a timeline editor:
 *
 * Responsibilities:
 *     - manage global time and playing of chapters
 *     - building a global timeline from branches (building transitions)
 *             -- build chapters
 *             -- build media (for backwards compatibility)
 *             -- build the master queue
 *     - building temporary dynamic transitions
 *     - managing play status at borders between chapters
 *             -- chapter | chapter boundary
 *             -- chapter | transition boundary
 *             -- transition | chapter boundary
 *     - mapping global (root) to local (branch) times and back
 *     - editing queue
 *             -- add chapters
 *             -- delete chapters
 *             -- reorder chapters
 *
 * Special Handling of Crossing borders between branches. UI and data determine which branches to
 * step into when one time on global timeline maps to two branch times (end time of branch 1, and the
 * start time of branch 2).
 *
 * First and last branch MUST have role of "chapter" (not "transition")
 *
 * No more than 1 "transition" consecutive "transition" branch.
 *
 * Chapter Ids reflect their ids at the point of loading and thus cannot be confidently
 * taken to indicate the chapter index after rearrangement.
 *
 * Concerns:
 *    - Memory management of dynamically generated transitions
 *    - Intuitive control of camera.
 *    - Media assets should be attached to the timeline through chapters, not in this roundabout way.
 *
 */

Human.timeline.RootTimeline = function (moduleId, params) {
    "use strict";
    params = params || {};
    var self = this;

    // Variables
    self.id = moduleId;
    self.level = 'root';
    self.animationOptions = {}; // loop:true/false
    self._theQueue = [];      //Master Sequence of All Branch Timelines in the scene registered to be played; can NOT contain empty timelines.
    self._chapters = [];      //Only chapter branches in order
    self._transitions = [];   //transition branches in order; to be syncronized with chapters; can contain empty objects
    self._times = [];         // the times corresponding to starts of constituent branch timelines.
    self._timeFrame = null;
    self.freeAnimations = {};

    // Variables: For Update
    self._firstUpdate = true;
    self._prevBranch = null;
    self._prevTime = null;
    self._nowBranch = null;
    self._nowTime = null;

    /** Global Animation Options
     * Set and validate animation options from the 'data' object.
     * Replaces existing animation options.
     * Options that are only referenced at the start and end of global timeline.
     * Note, that rebuilding the root will force a start.
     */
    self.setAnimationOptions = function (data, params) {
        params = params || {};

        // Backwards Compatibility: animation property from module
        if (data.animation) {
            self.animationOptions = data.animation;
        }

        // TODO: Unspecified other options
    };

    /** Add Chapter Branch
     * Add a chapter to the chapters array.
     * @branch: a valid branch timeline object
     * @params.position : (integer) position in the queue.
     * @params.rebuild :  (boolean) specifying wheter to rebuild root after adding chapter.
     *
     * Generally, params.rebuild=false while loader is adding chapters to root and only true on the last chapter.
     */
    self.addChapter = function (branch, params) {
        params = params || {};
        var rebuild = (params.hasOwnProperty("rebuild")) ? params.rebuild : true;
        var position = params.position || self._chapters.length;

        // branch must be a valid chapter and not a transitions
        if (branch.role !== "chapter") {
            Human.log.warn("RootTimeline.addChapter(): The branch timeline with id " + branch.id + "is not a chapter. Root will not be updated");
            return;
        }
        if (position < 0 || position > self._chapters.length) {
            Human.log.warn("RootTimeline.addChapter(): Invalid index " + position + "position");
        }

        // Add to array
        self._chapters.splice(position, 0, branch);
        if (rebuild) {
            self.build();
        }
    };

    /** --------------------------- HELPER AND QUERY FUNCTIONS ------------------------------
     */

    /** Get unique descendent leaf timeline
     * Return : {leafId: leafTimeline}
     */
    self.getDescendentLeaves = function () {
        var result = {};
        self._chapters.forEach(function (chapter) {
            var leafReferences = chapter.getChildLeafTimelines(0);
            for (var leafid in leafReferences) {
                if (leafReferences.hasOwnProperty(leafid)) {
                    if (!result.hasOwnProperty(leafid)) {
                        result[leafid] = Human.timeline.leafTimelines[leafid];
                    }
                }
            }
        });

        return result;
    };

    /** Get time frame (duration) of the root Timeline
     * @params.transitions : (boolean) True (default) if transition times are to be included.
     * TODO: Consider removing option to exclude transitions. After all, they are part of the timeline
     */
    self.getTimeFrame = function (params) {
        params = params || {};
        var end = 0.0;
        var sequence = (params.transitions === false) ? self._chapters : self._theQueue;


        // Sum up time of all branches in sequence
        sequence.forEach(function (branch) {
            end += branch.getTimeFrame().lastTime;
        });

        return {
            firstTime: 0.0,
            lastTime: end
        };
    };

    /** Get the index of branch.id in the root queue or optionally the chapters list.
     * Return null if not found
     */
    self.whereIsBranch = function (branch, params) {
        params = params || {};

        var idx = 0, found = false;
        var branchIndex = null;
        var sequence = [];
        if (params.chapters === true) {
            sequence = self._chapters;
        } else {
            // search whole timeline by default
            sequence = self._theQueue;
        }
        while (!found && idx < sequence.length) {
            found = (sequence[idx].id === branch.id) ? true : false;
            if (!found) {
                idx++;
            } else {
                branchIndex = idx;
            }
        }
        return branchIndex;
    };

    /** Get Branch from Que based on one property
     * @param.id : default, retrieve branch with specific id
     */
    self.getBranch = function (params) {
        params = params || {};
        var key, value, found = false, i = 0, branch = {};

        if (Human.utils.isEmpty(params)) {
            return null;
        } else if (Object.keys(params).length > 1) {
            Human.log.warn("timeline.RootTimeline.getBranch", "too many parameters, using only the first.");
        }

        // Search information
        key = Object.keys(params)[0];
        value = params[key];

        while (!found && i < (self._theQueue.length)) {
            branch = self._theQueue[i];
            if (self._theQueue[i][key] === value) {
                found = true;
            }
            i++;
        }

        var result;
        if (found) {
            result = branch;
        } else {
            result = null;
        }
        return result;
    };

    /** map global time TO local time on branch.
     * Returns object : {
        branch: branchTimeline,   # reference to corresponding branch timeline
        time: float,              # corresponding local time on branch
        index: integer            # the index of the branch in the reference sequence
     }
     *
     * @params.tie = "earlier"/"later" if take earlier/later branch in a border case
     * @params.which = "first/second"
     * @params.direction = "forwards/backwards"
     *
     * In the event of a tie, this function references either (a) the tie parameter, or
     * (b) the border condition which/direction parameters to pick the right target branch.
     *
     * Border cases include any time that can point to two branches.
     * By convention, the first and last branches border eachother. Therefore,
     * time 0 will point to lastBranch (as the "earlier" branch), and the first
     * branch (as the "later" branch).
     */
    self.mapGlobalTime = function (time, params) {
        params = params || {};

        // parameter checking
        if (time === "end") {
            time = self.getTimeFrame().lastTime;
        } else if (time === "start") {
            time = 0.0;
        }

        // parameter constraining
        if (time < 0) {
            time = 0;
        } else if (time > self.getTimeFrame().lastTime) {
            time = self.getTimeFrame().lastTime;
        }

        // tie handling and border conditions
        var tie = "earlier"; // default
        if (params.tie){
            tie = params.tie;
        } else if (params.which && params.direction){
            if (params.direction === "forwards"){
                if (params.which === "second"){
                    tie = "later";
                } else {
                    tie = "earlier";
                }
            } else if (params.direction === "backwards") {
                if (params.which === "first"){
                    tie = "later";
                } else {
                    tie = "earlier";
                }
            }
        }



        var result = {
            branch: null,
            time: null,
            index: null
        };

        var borderIndex = self._times.indexOf(time);
        if (borderIndex >= 0) {
            // Border Case: Use tie-breaker option
            var branchIndex = (tie !== "later") ? (borderIndex - 1) : borderIndex;
            branchIndex = (branchIndex < 0) ? self._theQueue.length - 1 : branchIndex;      // use last as "before first"
            branchIndex = (branchIndex >= self._times.length - 1) ? 0 : branchIndex;      // use first as "after last"

            result.branch = self._theQueue[branchIndex];
            result.time = (tie !== "later") ? (time - self._times[branchIndex]) : 0.0;
            result.index = branchIndex;
        }
        else {
            var neighbors = Human.utils.binarySearch(self._times, time);
            result.branch = self._theQueue[neighbors.index1]; // branch corresponding to left hand neighbor
            result.time = time - neighbors.value1;
            result.index = neighbors.index1;
        }
        return result;
    };

    /** map branch local time TO global time
     */
    self.mapBranchTime = function (branch, branchTime, params) {
        params = params || {};
        var worldTime = 0.0;
        var branchIndex = self.whereIsBranch(branch);
        if (branchTime === "end") {
            branchTime = branch.getTimeFrame().lastTime;
        }
        else if (branchTime === "start") {
            branchTime = 0.0;
        }

        if (branchIndex === null) {
            worldTime = null;
        } else {
            worldTime = self._times[branchIndex] + branchTime;
        }
        return worldTime;
    };

    /** Get the chapter-branch of the neighboring branch at specified time
     * @which = "next"/"previous" chapter in sequence
     *
     * @param {now} [branch object, or time float]
     * @param {params.tie} Which branch to use as current branch on border case.
     * Return null if no valid chapter exists;
     */
    self.getNeighborChapter = function (now, which, params) {
        params = params || {};

        var currentBranch = null;
        var currentIndex = null;
        which = (which === "previous") ? "previous" : "next";
        if (now instanceof Human.timeline.BranchTimeline) {
            currentBranch = now;
        } else if (typeof(now) === "number") {
            var tie = (params.tie === "later") ? "later" : "earlier";
            currentBranch = self.mapGlobalTime(now, {tie: tie});
        } else {
            Human.log.warn("timeline.root.getNeighborChapter", "invalid 'now' argument :" + JSON.stringify(now));
            return null;
        }

        currentIndex = self.whereIsBranch(currentBranch);


        // Edge Cases
        if (currentIndex === 0 && which === "previous") {
            return null;
        } else if (currentIndex === self._theQueue.length - 1 && which === "next") {
            return null;
        }

        // search up/down (maximum of two branches away in any direction)
        var idx = currentIndex;
        if (which === "next") {
            idx++;
            if (self._theQueue[idx].role !== "chapter") {
                idx++;
            }
        } else {
            idx--;
            if (self._theQueue[idx].role !== "chapter") {
                idx--;
            }
        }

        // make sure it's a chapter
        var candidate = self._theQueue[idx];
        if (candidate.role === "chapter") {
            return candidate;
        } else {
            Human.log.warn("timeline.root.getNeighborChapter", "could not find a valid chapter, returning null.");
            return null;
        }
    };

    /** Return True if branch is first chapter
     */
    self.isFirst = function (branch) {
        if (branch.id === self._theQueue[0].id) {
            return true;
        } else {
            return false;
        }
    };

    /** Return True if chapter is last chapter
     */
    self.isLast = function (branch) {
        var idx = self._theQueue.length - 1;
        if (branch.id === self._theQueue[idx].id) {
            return true;
        } else {
            return false;
        }
    };
    //-----------------------------  BUILD FUNCTIONS ----------------------------------------
    /**
     * Build process will happen (by default) when chapters are added or on demand.
     * Although this is potentially slow during the building of many transitions, it only has to be done
     * after creation or an edit to the timeline.
     */

    /** Dynamically build transitio Branch
     * Build ALL transition branches for all chapters that require a transition.
     * Some chapters require transitions (preceeding animation into any point on chapter branch).
     * This function will create the transition animation and add it as a transition to the root timeline.
     * These pre-build transitions exist for scrubbing through the global timeline.
     * The duration of the transition will be counted as part of the preceeding chapter.
     *
     * @params
     */
    self.buildTransitions = function (params) {
        params = params || {};
        self._transitions = []; // clean slate

        var _t = {}; // transition object place holder
        self._chapters.forEach(function (chapter, idx) {
            if (!Human.utils.isEmpty(chapter.transition) && idx > 0) {
                var _endChapter = self._chapters[idx - 1];
                var _startChapter = self._chapters[idx];
                _t = new Human.timeline._buildTransition(_endChapter, "end", _startChapter, 0.0, {});
            } else {
                _t = {};
            }

            // Add to list of transitions
            self._transitions.push(_t);
        });
    };

    /** Add Free Animations to Global Timeline
     * Animations tagged to be not on the timeline will be added to
     * the global timeline and will not respond to play/stop status.
     *
     * This function will add all free animations in any descendent leaf timelines
     */
    self.buildFreeAnimations = function (params) {
        params = params || {};
        var leaves = self.getDescendentLeaves();
        for (var leafId in leaves) {
            if (leaves.hasOwnProperty(leafId)) {
                var _fa = leaves[leafId].freeAnimations;
                for (var _fai in _fa) {
                    if (_fa.hasOwnProperty(_fai) && !self.freeAnimations.hasOwnProperty(_fai)) {
                        self.freeAnimations[_fai] = _fa[_fai];
                    }
                }
            }
        }
    };

    /** Build queue
     * The Queue is the ordered list of all non-empty chapters and transitions that
     * collectively constitue the global timeline.
     *
     * Also populate time (and border times)
     */
    self.buildQueue = function (params) {
        params = params || {};
        self._theQueue = [];
        var cumTime = 0.0; // keep track of cumulative time
        self._times = [cumTime];

        self._chapters.forEach(function (chapter, idx) {
            cumTime += chapter.getTimeFrame().lastTime;
            self._theQueue.push(chapter);
            self._times.push(cumTime);
            var transition = self._transitions[idx];
            if (!Human.utils.isEmpty(transition)) {
                cumTime += transition.getTimeFrame();
                self._theQueue.push(transition);
                self._times.push(cumTime);
            }
        });
    };

    /** Attach media to appropriate chapters
     * Must be used after buildQueue.
     * This is only for backwards compatibility.
     * TODO: Refactor media content to be defined in chapters. Remove and
     * root.buildMedia() from build process
     */
    self.buildMedia = function () {

        var createUrl = function (clip) {
            if (clip.type === "local") {
                return [clip.modelId, clip.streamType, clip.subasset, clip.src].join("/");
            } else if (clip.type === "youtube") {
                return clip.src;
            }
        };

        var attachMedia = function (streamtype, mclip, branch) {
            mclip = Human.utils.shallowClone(mclip);
            mclip.fullUrl = createUrl(mclip);
            var t = self.mapBranchTime(branch, 0);
            mclip.time1 -= t;
            var t2 = mclip.time2 - t;
            mclip.time2 = Math.min(t2, branch.getTimeFrame().lastTime);
            ["length", "suggested", "status"].forEach(function (prop) {
                delete mclip[prop];
            });
            var name = streamtype + "_" + mclip.clipId;
            branch.addClip(name, mclip);
        };


        var audioclips = Human.media.audio.clips;
        var videoclips = Human.media.videos.clips;
        var ac; //audio-clip
        var vc; //video-clip
        var targetStart;
        var targetEnd;
        var target;

        var i;

        // We only want to add clips that were not registered with chapters
        for (var audioId in audioclips) {
            if (audioclips.hasOwnProperty(audioId)) {
                ac = audioclips[audioId];
                if (typeof(ac.time1) === "number") {
                    if (typeof(ac.time2) === "number") {
                        targetStart = self.mapGlobalTime(ac.time1, {tie: "later"});
                        targetEnd = self.mapGlobalTime(ac.time2, {tie: "earlier"});
                        for (i = targetStart.index; i <= targetEnd.index; i++) {
                            target = self._theQueue[i];
                            attachMedia("audio", ac, target);
                        }
                    }
                }

            }
        }

        for (var videoId in videoclips) {
            if (videoclips.hasOwnProperty(videoId)) {
                vc = videoclips[videoId];
                if (typeof(ac.time1) === "number") {
                    if (typeof(ac.time2) === "number") {
                        targetStart = self.mapGlobalTime(vc.time1, {tie: "later"});
                        targetEnd = self.mapGlobalTime(vc.time2, {tie: "earlier"});
                        for (i = targetStart.index; i <= targetEnd.index; i++) {
                            target = self._theQueue[i];
                            attachMedia("video", vc, target);
                        }
                    }
                }

            }
        }
    };

    /** Build Root Timeline
     */
    self.build = function (params) {
        params = params || {};
        self._theQueue = [];
        self._times = [];
        self.buildTransitions();
        self.buildFreeAnimations();
        self.buildQueue();
        self.buildMedia();

        // Register with replacement
        if (Human.timeline.rootTimelines[self.id]) {
            delete Human.timeline.rootTimelines[self.id];
        }
        Human.timeline.rootTimelines[self.id] = self;

        self._timeFrame = self.getTimeFrame();


        // (Re Set current now-branch and now-time
        if (self._nowBranch === null) {
            self._nowBranch = self._theQueue[0];
            self._nowTime = 0.0;
            self._prevBranch = self._nowBranch;
            self._prevTime = 0.0;
        } else if (self.whereIsBranch(self._nowBranch) === null) {
            self._nowBranch = self._theQueue[0];
            self._nowTime = 0.0;
            if (self._prevBranch === null) {
                self._prevBranch = self._nowBranch;
                self._prevTime = self._nowTime;
            } else if (self.whereIsBranch(self._prevBranch) === null) {
                self._prevBranch = self._nowBranch;
                self._prevTime = self._nowTime;
            }
        }


        // Fire Event and Inform Listeners
        Human.events.fire("timeline.chapters.updated", self._assembleChaptersUpdated());

        Human.events.fire("timeline.timeFrame.updated", {
            firstTime: self._timeFrame.firstTime,
            lastTime: self._timeFrame.lastTime
        });

    };

    /** Replace next transition with new camera tween if necessary
     *
     */
    self.prepareNextTransition = function (time, params) {
        params = params || {};
        var info = {};
        var diffThresh = 0.033;
        Human.utils.binarySearch(self._times, time, null, info);
        if ((info.value2 - time) < diffThresh) {
            // check if next branch is transition .
            // check if camera is different.
            // make sure it doesn't already have one.
            //console.log("Adding temporary camera tween to next transition");
        }
    };

    /** Destroy
     * Soft Deletions of branch timelines
     */
    self.destroy = function () {
        // Remove branches
        self._theQueue.forEach(function (branch) {
            if (Human.timeline.branchTimelines.hasOwnProperty(branch.id)) {
                branch.destroy();
                delete Human.timeline.branchTimelines[branch.id];
            }
            branch = null;
        });

        self._theQueue = [];
        self._chapters = [];
        self._transitions = [];
        self._times = [];
        self._timeFrame = null;
        self.freeAnimations = {};

        // Variables: For Update
        self._firstUpdate = true;
        self._prevBranch = null;
        self._prevTime = null;
        self._nowBranch = null;
        self._nowTime = null;

        // Remove from roots and as active root
        if (Human.timeline.rootTimelines.hasOwnProperty(self.id)) {
            delete Human.timeline.rootTimelines[self.id];
            if (!!Human.timeline.activeRoot && Human.timeline.activeRoot.id === self.id) {
                Human.timeline.activeRoot = null;
                var annotations = Human.view.annotations.annotations;
                for (var aid in annotations) {
                    if (annotations.hasOwnProperty(aid)) {
                        annotations[aid].destroy();
                    }
                }
                annotations = null;
            }
        }

        // Fire Event and Inform Listeners
        self._timeFrame = self.getTimeFrame();
        Human.events.fire("timeline.chapters.updated", self._assembleChaptersUpdated());
        Human.events.fire("timeline.timeFrame.updated", {
            firstTime: self._timeFrame.firstTime,
            lastTime: self._timeFrame.lastTime
        });

    };

    //------------------------------  ACTION FUNCTIONS -----------------------------------------
    self.updateFreeAnimations = function (time) {
        for (var fid in self.freeAnimations) {
            if (self.freeAnimations.hasOwnProperty(fid)) {
                self.freeAnimations[fid].update({cameraEnabled: false}, time);
            }
        }
    };

    self.initScene = function() {
        self._nowBranch.initScene();
    };

    self.initCamera = function(ok) {
        self._nowBranch.initCamera(ok);
    };

    self.cancelCameraInit = function() {
        self._nowBranch.cameraInitCanceled = true;
    };

    self.initAnnotations = function() {
        self._nowBranch.initAnnotations();
    };

    self.cancelAnnotationInit = function() {
        self._nowBranch.annotationInitCanceled = true;
    };

    // update the root timeline at the specified global time.
    self.update = function (time, params) {
        params = params || {};
        var borderCondition = {}, toUpdate = [];

        // Default parameter handling
        borderCondition = {which: "both", direction: "forwards"};
        if (params.hasOwnProperty("which")) {
            borderCondition.which = params.which;
        }
        if (params.hasOwnProperty("direction")) {
            borderCondition.direction = params.direction;
        }

        // Check for valid time
        if (time < 0) {
            time = 0;
            Human.log.warn("Time violates lower bound. Updating to time = 0.0");
        }
        else if (time > self._timeFrame.lastTime) {
            time = self._timeFrame.lastTime;
            Human.log.warn("Time violates upper bound. Updating to time = " + time);
        }

        // get list of mapped branches and their local times to update.
        toUpdate = self._getBranchesToUpdate(time, borderCondition);

        // Check for first update
        if (self._firstUpdate) {
            self._nowBranch = toUpdate[0].branch;
            self._nowTime = toUpdate[0].time;
            self._firstUpdate = false;
        }

        // udpate mapped branches in order
        var chaptersFirstUpdate = false;
        toUpdate.forEach(function (item) {
            self._prevBranch = self._nowBranch;
            self._prevTime = self._nowTime;
            chaptersFirstUpdate = item.branch.firstUpdate;
            self._nowBranch = item.branch;
            self._nowTime = item.time;
            item.branch.update(item.time);

            /** Notify that new chapter has been entered the first time
             * Ideally, the chapter-branch itself could do the notification,
             * but for backwards compatibility the UI wants to know which chapter
             * in the context of the whole root timeline has fired.
             */
            if (chaptersFirstUpdate) {
                Human.events.fire("timeline.chapters.activated", self._assembleChaptersActivated());
            }

        });

        // reset previous branch if necessary.
        if (self._prevBranch.id !== self._nowBranch.id) {
            self._prevBranch.reset();
        }

    };

    /** Return an array of the local information (branch, timeline) to be updated
     *   based on global time and border Condition.
     */
    self._getBranchesToUpdate = function (time, borderCondition) {
        if (self._times.indexOf(time) >= 0) {
            return self._getBorderBranches(time, borderCondition);
        } else {
            return [self.mapGlobalTime(time, {tie: "earlier"})];
        }
    };

    /** Return one or more of the branches at specified boder time.
     */
    self._getBorderBranches = function (time, borderCondition) {
        var _left = self.mapGlobalTime(time, {tie: "earlier"});
        var _right = self.mapGlobalTime(time, {tie: "later"});
        var order = [_left, _right]; // default is to play in forwards order

        // Modify the "order" based on border Condition
        if (borderCondition.direction === "backwards") {
            order = [_right, _left];
        }
        if (borderCondition.which === "first") {
            order.splice(1, 1);
        } else if (borderCondition.which === "second") {
            order.splice(0, 1);
        }
        return order;
    };

    // ------------------------------ EVENT INFORMATION ----------------------------------------

    /** This function returns the object to be sent with timeline.chapters.updated
     * The result is a list of chapter blocks, each of which contains
     * the chapter's global start time, duration, displayName, description, and index.
     */
    self._assembleChaptersUpdated = function () {

        Human.timeline.chapters = {}; // Backwards Compatibility

        var result = [];
        var i;
        var len;
        var chapters = self._chapters;
        var branch;
        var block;

        for (i = 0, len = chapters.length; i < len; i++) {  // OPTIMIZATION: Don't use GC-collected callback
            branch = chapters[i];
            block = {
                chapterId: branch.id,
                time: self.mapBranchTime(branch, 0.0),
                duration: branch.getTimeFrame().lastTime,
                displayName: branch.info.displayName,
                description: branch.info.description,
                loop: branch.animation.loop,
                index: i
            };
            result.push(block);
            Human.timeline.chapters[branch.id] = block;
        }

        return result;
    };

    /** This function returns the object to be sent with timeline.chapters.activated
     * events, which are fired on every update.
     *
     */
    self._assembleChaptersActivated = function () {
        var result = {};
        result.oldChapterIndex = self.whereIsBranch(self._prevBranch, {chapters: true}); // index of old chapter in sequence of chapters
        result.newChapterIndex = self.whereIsBranch(self._nowBranch, {chapters: true}); // index of new chapter in sequence of chapters
        result.time = self.mapBranchTime(self._nowBranch, self._nowTime);
        result.loop = self._nowBranch.animation.loop || false;
        return result;
    };

    /** This function returns per-chapter information for all chapters needed by timeline.query
     */
    self._assembleQueryChapters = function () {

        var result = [];
        var i;
        var len;
        var chapters = self._chapters;
        var branch;

        for (i = 0, len = chapters.length; i < len; i++) { // OPTIMIZATION: Don't use GC-collected callback
            branch = chapters[i];

            result.push({
                chapterId: branch.id,
                time: self.mapBranchTime(branch, 0.0),
                displayName: branch.info.displayName,
                description: branch.info.description,
                type: "branch",
                tags: branch.tags || [],
                annotations: branch.annotations,
                hotspots: null,
                flyTo: branch.camera.location,
                active: (self._nowBranch.id === branch.id), // OPTIMIZATION: Remove redundant conditional
                sounds: branch._getAudio(),
                translations: branch.translations || null
            });
        }

        return result;
    };

};
;(function () {
    "use strict";

    //Returns Timeline tween animations to turn all objects in set on or off
    var _visibilityAnimation = function (set1, startTime, startVal, endTime, endVal) {
        var toSwitch = Human.scene.objectSets._groupSetByModelId(set1);
        var _tween = {};
        var visibilityAnimations = {};

        //loop through model and its objects
        for (var modelId in toSwitch) {
            if (toSwitch.hasOwnProperty(modelId)) {
                //prepare tween animation object
                var cfg = {};
                cfg.displayName = "";
                cfg.options = {};
                cfg.onComplete = function () {
                };
                cfg.timeline = {};
                cfg.tweens = [];

                for (var objectId in toSwitch[modelId]) {
                    if (toSwitch.hasOwnProperty(objectId)) {
                        //For now, just turn object off immediately
                        _tween = {
                            keys: [startTime, endTime],
                            type: "switch:objectAttr",
                            objectId: objectId,
                            targets: [{attr: {shown: startVal}}, {attr: {shown: endVal}}]
                        };
                        cfg.tweens.push(_tween);
                    }
                }

                var vizAnimation = new Human.timeline.Tween({modelId: modelId}, cfg);
                visibilityAnimations[modelId] = vizAnimation;
            }
        }

        return visibilityAnimations;
    };

//Build a transition from source to target
    Human.timeline._buildTransition = function (sourceBranch, sourceTime, targetBranch, targetTime, params) {
        params = params || {};
        var transitionBranch = {};
        var _cameraTween = {};
        var id = params.id || sourceBranch.id + "-" + targetBranch.id; //id for new branch
        var duration = targetBranch.activation.getTimeFrame().lastTime; //target specifies how to be transitioned INTO

        var i;
        var len;
        var vizLeaf;

        //Target must actually need a transition
        if (!targetBranch.needsAnimatedTransition()) {
            return transitionBranch;
        }

        //Get camera tween if needed
        var sCamera = params.camera || sourceBranch.getCamera(sourceTime);
        var tCamera = targetBranch.getCamera(targetTime);
        _cameraTween = Human.timeline._buildCameraTween(sCamera, tCamera, duration);
        var cameraLeaf = {};
        if (_cameraTween !== null) {
            cameraLeaf = new Human.timeline.LeafTimeline(id); //leaf timeline containing animations
            cameraLeaf.addAnimation("camera-" + id, _cameraTween);
        }

        //Get Vizibility/Opacity tweens for previousChapter;
        var vizAnimations = Human.timeline._buildVizOpacityTweens(sourceBranch, sourceTime, targetBranch, targetTime, duration);
        var vizLeafTimelines = [];
        for (var modelId in vizAnimations) {
            if (vizAnimations.hasOwnProperty(modelId)) {
                vizLeaf = new Human.timeline.LeafTimeline(modelId, {id: "viz-" + id + "-" + modelId});
                vizLeaf.addAnimation("viz-" + id, vizAnimations[modelId]);
                vizLeafTimelines.push(vizLeaf);
            }
        }

        if (Human.utils.isEmpty(cameraLeaf) && Human.utils.isEmpty(vizLeafTimelines)) {
            return {};
        }

        //Initialize Transition branch
        transitionBranch = new Human.timeline.BranchTimeline(id);
        transitionBranch.setRole("transition");

        //Create maps for all leaf timelines (camera + model-visibility)
        if (!Human.utils.isEmpty(cameraLeaf)) {
            transitionBranch.makeMapComponent("camera", 0.0, duration, cameraLeaf);
        }

        for (i = 0, len = vizLeafTimelines.length; i < len; i++) {  // OPTIMIZATION: Remove 'every' in favour of inline loop
            vizLeaf = vizLeafTimelines[i];
            transitionBranch.makeMapComponent("viz-" + i, 0.0, duration, vizLeaf);
        }

        //Union of all objects (source and target) to show
        var _set1 = {"show": targetBranch.overrides.show};
        var _set2 = {"show": sourceBranch.overrides.show};
        transitionBranch.overrides.show = Human.timeline._reconcileObjectSets(_set1, _set2, "show");

        _set1 = {"show": sourceBranch.vizTweens};
        _set2 = {"show": Human.timeline._queryVizTweens(sourceBranch, "end")};
        transitionBranch.vizTweens = Human.timeline._reconcileObjectSets(_set1, _set2, "show");
        transitionBranch.info = sourceBranch.info;

        //Return the branch
        return transitionBranch;
    };

//Make a Visibility/Opacity Tweens (on and off) from two sets of objectSets
    Human.timeline._buildVizOpacityTweens = function (sourceBranch, sourceTime, targetBranch, targetTime, duration) {
        /**
         Critical: Tween objects assume to operate on exactly one model by combining model with object id.
         We must therefore separate our tween data by model
         */
        var x = 0.01;  //time to turn off/on

        //Query source branch
        var prevEffects = targetBranch.activation.effects.visibility[0];
        var targEffects = targetBranch.activation.effects.visibility[1];
        var i;
        var len;

        //Tweens on Source Objects: Turning things off
        var offAnimations = {}, visibilities;
        if (prevEffects === "switch") {
            //collect visibility information from source and target
            visibilities = Human.timeline._getVisibility(sourceBranch, sourceTime);
            var visibleInSource = Human.scene.objectSets.getSetByValue(visibilities, true); //only objects with shown:true
            visibilities = Human.timeline._getVisibility(targetBranch, targetTime);
            var hiddenInTarget = Human.scene.objectSets.getSetByValue(visibilities, false); //only those with shown:false

            //Objects shown in source but hidden in target
            var turnOff = Human.scene.objectSets.intersection(visibleInSource, hiddenInTarget, {
                useMembership: true,
                useValue: false
            });
            turnOff = Human.scene.objectSets.getSetByValue(turnOff, true);

            //Create Animations
            offAnimations = _visibilityAnimation(turnOff, 0, true, x, false); //turn objects by modelId from shown true to false
        } else if (prevEffects === "fade") {
            console.log("not implemented fade on/off during transition");
        }


        //Tweens on Target Objects: Turning things on
        var onAnimations = {}; //visibility OR opacity
        if (targEffects === "switch") {
            visibilities = Human.timeline._getVisibility(targetBranch, targetTime);
            var visibleInTarget = Human.scene.objectSets.getSetByValue(visibilities, true); //only objects with shown:true


            visibilities = Human.timeline._getVisibility(sourceBranch, sourceTime);
            var hiddenInSource = Human.scene.objectSets.getSetByValue(visibilities, false); //only those with shown:false

            //Objects shown in target but hidden in source
            var turnOn = Human.scene.objectSets.intersection(hiddenInSource, visibleInTarget, {
                useMembership: true,
                useValue: false
            });
            turnOn = Human.scene.objectSets.getSetByValue(turnOn, true);

            //Create Animations
            onAnimations = _visibilityAnimation(turnOn, x, true, duration, false); //turn objects by modelId from shown true to false
        } else {
            console.log("effect mode not yet implemented");
        }

        //Combine Animations by ModelId so that they can combined in the same animation/leaf timeline
        var result = offAnimations;
        var tweens;

        for (var modelId in onAnimations) {
            if (onAnimations.hasOwnProperty(modelId)) {

                //extend or add to result
                if (result.hasOwnProperty(modelId)) {

                    //extend
                    tweens = onAnimations[modelId].tweens;
                    for (i = 0, len = tweens.length; i < len; i++) {
                        result[modelId].tweens.push(tweens[i]);
                    }
                } else {
                    result[modelId] = [onAnimations];
                }
            }
        }


        return result; //Map of {modelId:[animation]}
    };

    //Return the visibility status of branch at time time: showObjects + queryVizTweens
    Human.timeline._getVisibility = function (branch, time) {

        //Start with overrides
        var show = {visibility: branch.overrides.show};

        //Query visibility tweens of branch at time
        var vizTweens1 = {visibility: branch.vizTweens};
        var vizTweens2 = {visibility: Human.timeline._queryVizTweens(branch, time)};
        var vizTweens = {visibility: Human.timeline._reconcileObjectSets(vizTweens1, vizTweens2, "visibility")};

        //Reconcile differences in favor of vizTweens
        var result = Human.timeline._reconcileObjectSets(show, vizTweens, "visibility");

        return result;
    };

    //Returns the visibility status of objects in branch at time t
    Human.timeline._queryVizTweens = function (branch, time) {

        var result = {}; // {object: boolean}

        if (time === "start") {
            time = 0.0;
        } else if (time === "end") {
            time = branch.getTimeFrame().lastTime;
        }

        var maps = branch.whichMaps(time);

        var i;
        var len;
        var md;
        var map;
        var timeline;
        var t;
        var animations;
        var animKey;
        var animation;
        var tweens;
        var j;
        var lenj;
        var tween;
        var tweenQueryResult;
        var objectId;
        var targets;
        var k;
        var lenk;
        var target;

        for (i = 0, len = maps.length; i < len; i++) {

            md = maps[i];
            map = md.map;
            timeline = map.data.timeline;
            t = map.calcChildTime(time);
            animations = timeline.animations;

            for (animKey in animations) {
                if (animations.hasOwnProperty(animKey)) {

                    animation = animations[animKey];

                    if (!animation.hasOwnProperty("tweens")) {

                        // Animation contains tweens

                        tweens = animation.tweens;

                        for (j = 0, lenj = tweens.length; j < lenj; j++) {

                            tween = tweens[j];

                            if (tween.type === "switch:objectAttr") {

                                // Tween discretely switches attributes on an object

                                targets = tween.targets;

                                for (k = 0, lenk = targets.length; k < lenk; k++) {

                                    target = targets[k];

                                    if (target.attr.hasOwnProperty("shown")) {

                                        // Tween switches object's visibility

                                        tweenQueryResult = tween.query(t); // Query at proper time
                                        objectId = tween._manipulator.objectId;

                                        result[objectId] = tweenQueryResult.attr.shown;

                                        break; // Dijkstra be damned
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    };

    //Make a FlyTo Tween object for the camera
    Human.timeline._buildCameraTween = function (camera1, camera2, duration) {

        //Get camera tween if needed
        if (!Human.timeline.camerasEqual(camera1, camera2)) {
            //nees a camera tween
            var _cTween = new Human.timeline.CameraFlyTo({
                time1: 0.0,
                time2: duration,
                eye1: camera1.eye,
                look1: camera1.look,
                up1: camera1.up,
                pan1: camera1.screenPan,
                eye2: camera2.eye,
                look2: camera2.look,
                up2: camera2.up,
                pan2: camera2.screenPan,
                onComplete: function () {
                }
            });

            return _cTween;
        } else {
            return null;
        }
    };
})();;(function () {
    "use strict";
    // --------------- CHAPTER DEFAULTS -----------------------------------------


    var camera = {
        action: "jumpTo",
        location: {
            eye: {x: 0, y: 0, z: 0},
            look: {x: 0, y: 0, z: 0},
            up: {x: 0, y: 1, z: 0}
        }
    };


    var animation = {
        loop: false
    };

    var options = {
        xray: false,
        screenPan: {x: 0, y: 0, z: 0}
    };

    var dummyLeaf = new Human.timeline.LeafTimeline("dummy");
    var dummyMap = {
        start: 0,
        end: 2.0,
        data: {
            timeline: dummyLeaf.id,
            start: 0,
            end: dummyLeaf.getTimeFrame().lastTime,
            onEnd: "freeze",
            fit: false
        }
    };

    var objectSetsMap = {
        showObjects: "shown",
        selectObjects: "selected",
        pickThroughObjects: "pickable",
        transparentObjects: "transparent",
        desaturatedObjects: "desaturated",
        backfaceObjects: "backfaces",
        objectGlassFactors: "glassFactor",
        objectMurkiness: "murkiness",
        objectOpacities: "opacity"
    };


    // ------------------- END DEFAULTS --------------------------------------


    /** Chapter Definition Objects
     * Complete instructions to create branch timelines.
     * Stores defaults for all required chapter properties, which can be overriden
     * by user-created chapter definitions.
     *
     *
     * Requirements: Scene graph (object hierarchy) is in memory, but there is
     * no requirement that the assets are loaded.
     */
    var Chapter = Human.timeline.chapter = function (id, chapterDef) {
        chapterDef = chapterDef || {};
        var self = this;

        // Essential properties and defaults
        self.id = id;
        self.showObjects = {};
        self.selectObjects = {};
        self.pickThroughObjects = {};
        self.transparentObjects = {};
        self.desaturatedObjects = {};
        self.backfaceObjects = {};
        self.objectGlassFactors = {};
        self.objectMurkiness = {};
        self.objectOpacities = {};
        self.transition = {};
        self.annotations = [];
        self.timelineMap = [];
        self.displayName = "";
        self.description = "";
        self.media = {};
        self.reflections = {};
        self.effects = Human.view.effects.getDefaults();
        self.properties = Human.properties.getDefaults();
        self.camera = Human.utils.shallowClone(camera);
        self.animation = Human.utils.shallowClone(animation);
        self.options = Human.utils.shallowClone(options);
        self.objectSetsMap = Human.utils.shallowClone(objectSetsMap);
        self.timelineMap = [dummyMap];
        self._type = "module"; // "module" or "chapter"

        if (!Human.utils.isEmpty(chapterDef)) {
            self.merge(chapterDef);
        }
    };

    /* Merge policies for object Sets (showObjects, etc):
     * showObjects is replaced.
     * This is almost exclusively needed for target modules being merged with content
     * loaded by base anatomy modules.
     */
    Chapter.prototype._mergeModule = function (moduleDef) {
        var self = this;
        var objectSetsMap = self.objectSetsMap;
        var key;
        var set2;

        var rootObjects = Human.scene.rootObjects; // // OPTIMIZATION: caching this var so we don't dereference it each time in the loops below
        var key2;
        var root;
        var rootBase;

        // OPTIMIZATION: Object.keys created temp array of keys, forEach required function to be defined for iteration
        // OPTIMIZATION: Don't redefine functions within these loops - caused churn when they were garbage-collected
        // OPTIMIZATION: Don't redefine vars inside loops (and for style, note that the defs, above, are in the same order as where they are used

        for (key in objectSetsMap) {
            if (objectSetsMap.hasOwnProperty(key)) {



                if (moduleDef.hasOwnProperty(key)) {

                    set2 = moduleDef[key] || {}; // ensure it is an object

                    // interpret '*' to be non base anatomy objects loaded by moduleDef
                    if (set2.hasOwnProperty("*")) {

                        for (key2 in rootObjects) {
                            if (rootObjects.hasOwnProperty(key2)) {

                                root = rootObjects[key2];
                                rootBase = root.modelId;

                                if (moduleDef.modelIds.indexOf(rootBase) >= 0 && !Human.modules.isBase(rootBase)) {
                                    set2[root.objectId] = moduleDef[key]['*'];
                                }
                            }
                        }

                        delete moduleDef[key]['*'];
                    }

                    // merge
                    if (key === "showObjects") {
                        self[key] = set2;
                    } else {
                        self[key] = Human.scene.sets.union(self[key], set2);
                    }

                    // HACK: Redirect base anatomy to specific base anatomy folder
                    self[key] = redirectBaseAnatomy(self[key]);
                }
            }
        }
    };

    // Merge policies for object Sets (showObjects, etc):
    Chapter.prototype._mergeChapter = function (chapterDef) {

        var objectSetKey;
        var objectSetsMap = this.objectSetsMap;
        var utils = Human.utils;
        var set2;
        var key2;
        var rootObjects = Human.scene.rootObjects; // // OPTIMIZATION: caching this var so we don't dereference it each time in the loops below
        var root;

        chapterDef.showObjects = chapterDef.showObjects || {}; // insurance

        for (objectSetKey in objectSetsMap) {
            if (objectSetsMap.hasOwnProperty(objectSetKey)) {

                if (chapterDef.hasOwnProperty(objectSetKey)) {

                    // HACK: Redirect any references to old maleAdult/femaleAdult
                    chapterDef[objectSetKey] = redirectBaseAnatomy(chapterDef[objectSetKey]);

                    if (!utils.isEmpty(chapterDef[objectSetKey])) {

                    //    objectSet = objectSetsMap[objectSetKey];

                        set2 = chapterDef[objectSetKey] || {}; // ensure it is an object

                        if (set2.hasOwnProperty("*")) {

                            for (key2 in rootObjects) {
                                if (rootObjects.hasOwnProperty(key2)) {

                                    root = rootObjects[key2];
                                    set2[root.objectId] = set2["*"];
                                }
                            }
                            delete set2['*'];
                        }

                        this[objectSetKey] = set2;

                    } else {

                        // Handle Empty object sets explicitly
                        if (objectSetKey === "showObjects") {
                            this[objectSetKey] = {};
                        }
                    }
                }
            }
        }
    };


    // Incorporate data from chapterDef into existing chapter.
    Chapter.prototype.merge = function (chapterDef) {
        var self = this;
        var prop;
        var draggable = true;

        // Rename and merge based on definition type. Chapters and Modules are merged differently.
        if (chapterDef.hasOwnProperty("chapterId")) {
            self.id = chapterDef.chapterId;
            self._type = "chapter";
        } else if (chapterDef.hasOwnProperty("moduleId")) {
            self.id = chapterDef.moduleId;
            self._type = "module";
        } else if (chapterDef.hasOwnProperty("_type")) {
            self._type = chapterDef._type;
        }

        // merge object-set instructions based on type of chapterDef
        if (self._type === "module") {
            self._mergeModule(chapterDef);
        } else if (self._type === "chapter") {
            self._mergeChapter(chapterDef);
        } else {
            console.log("unknown type for merge");
        }

        // use new timelinemaps if present.
        if (chapterDef.hasOwnProperty("timelineMap")) {
            self.timelineMap = chapterDef.timelineMap;
        } else if (chapterDef.hasOwnProperty("modelIds")) {
            /** chapterDef is coming from module.
             * Try and register leaf-timelines for each state.
             * This is for backwards compatibility where moduls don't have explicit knowledge of their time.
             * Assumes leaf-timeline is already created and registered.
             */
            self.timelineMap = [];
            chapterDef.modelIds.forEach(function (state) {
                if (Human.timeline.leafTimelines.hasOwnProperty(state)) {
                    var lt = Human.timeline.leafTimelines[state];
                    var mapinfo = {};
                    mapinfo.start = 0;
                    mapinfo.end = lt.getTimeFrame().lastTime;
                    mapinfo.data = {
                        timeline: lt.id,
                        start: 0,
                        end: lt.getTimeFrame().lastTime,
                        onEnd: "freeze",
                        fit: false
                    };
                    self.timelineMap.push(mapinfo);
                }
            });
        }

        // use media if present
        if (chapterDef.hasOwnProperty("media")){
            self.media = chapterDef.media;
        }

        // use new annotations if present
        if (chapterDef.hasOwnProperty("annotations")) {
            self.annotations = chapterDef.annotations || [];
        }

        // use new displayName and description if present
        if (chapterDef.hasOwnProperty("displayName")) {
            self.displayName = chapterDef.displayName;
        }
        if (chapterDef.hasOwnProperty("description")) {
            self.description = chapterDef.description;
        }

        // use new camera if present
        if (chapterDef.hasOwnProperty("camera") && !!chapterDef.camera) {
            self.camera = {};
            if (chapterDef.camera.hasOwnProperty("action")) {
                self.camera = chapterDef.camera;
            } else {
                self.camera.action = "flyTo";
                self.camera.location = chapterDef.camera;
            }

        } else if (chapterDef.hasOwnProperty("flyTo") && !!chapterDef.flyTo) {
            self.camera = {};
            self.camera.action = "flyTo";
            self.camera.location = chapterDef.flyTo;
        } else if (chapterDef.hasOwnProperty("jumpTo") && !!chapterDef.jumpTo) {
            self.camera = {};
            self.camera.action = "jumpTo";
            self.camera.location = chapterDef.jumpTo;
        }

        // use per-chapter properties if present.
        if (chapterDef.hasOwnProperty("properties")) {
            chapterDef.properties = chapterDef.properties || [];
            for (prop in chapterDef.properties) {
                if (chapterDef.properties.hasOwnProperty(prop)) {
                    if (!self.properties.hasOwnProperty(prop)) {
                        Human.log.warn("scene.chapter.merge", "Invalid per-chapter property : " + prop);
                    } else {
                        self.properties[prop] = chapterDef.properties[prop];
                    }
                }
            }
        }


        // Get x-ray and screenPan options
        if (chapterDef.hasOwnProperty("xray")) {
            self.options.xray = chapterDef.xray;
        } else if (chapterDef.hasOwnProperty("options")) {
            self.options.xray = chapterDef.options.xray;
            self.options.screenPan = chapterDef.options.screenPan;
        }
        if (chapterDef.hasOwnProperty("screenPan")) {
            self.options.screenPan = chapterDef.screenPan;
        } else {
            if (chapterDef.hasOwnProperty("camera")) {
                var cam = chapterDef.camera;
                if (cam && cam.hasOwnProperty("screenPan")) {
                    self.options.screenPan = cam.screenPan;
                }
            }
        }


        // per-chapter animation properties
        if (chapterDef.hasOwnProperty("animation") && !Human.utils.isEmpty(chapterDef.animation)) {
            if (chapterDef.animation.hasOwnProperty("loop")) {
                self.animation.loop = chapterDef.animation.loop;
            }
        }
        else if (chapterDef.hasOwnProperty("loop")) {
            self.animation.loop = chapterDef.loop || false;
            delete chapterDef.loop;
        }

        // Catch degenerate properties
        if (chapterDef.hasOwnProperty("annotationsLayout") && !!chapterDef.annotationsLayout) {
            self.properties['annotations.layout.type'] = chapterDef.annotationsLayout;
        }

        // use new reflections if present (reflectionId : reflection_asset_path)
        if (chapterDef.hasOwnProperty("reflections") && !!chapterDef.reflections) {
            self.reflections = chapterDef.reflections;
        }


        /* HACK FOR BACKWARDS COMPATIBILITY:
         Set to columns if annotations cannot be "draggable"
        */
        for (var i=0;i<self.annotations.length; i++){
            if (!self.annotations[i].hasOwnProperty("labelOffset")){
                draggable = false;
            }
        }
        if (!draggable){
            self.properties['annotations.layout.type'] = "columns";
        }
    };


    //Returns true if chapter includes base references to base anatomy objects
    Chapter.prototype.requiresBase = function () {
        var self = this;
        var objects = Object.keys(self.createInstructions());

        return Human.modules.requiresBase(objects);
    };


    Chapter.prototype.transitionTypes = {};


    /** Convert objectSets into Instructions to be applied once per-object
     * in the scene graph.
     *
     * NOTE: Special handling of "transparentObjects" and "objectOpacities" because
     * historically, these have not always been reliably declared in the data. This
     * requires having the objects and their material assets already loaded.
     *
     * NOTE: Special handling of pickable because pickThrough=true is the same as
     * pickable=false.
     */
    /** Convert objectSets into Instructions to be applied once per-object
     * in the scene graph.
     *
     * NOTE: Special handling of "transparentObjects" and "objectOpacities" because
     * historically, these have not always been reliably declared in the data. This
     * requires having the objects and their material assets already loaded.
     *
     * NOTE: Special handling of pickable because pickThrough=true is the same as
     * pickable=false.
     */
    Chapter.prototype.createInstructions = function () {
        var self = this;
        var result = {}; //objectId:{propery:value}
        var oset, oprop;

        for (oset in self.objectSetsMap) {
            if (self.objectSetsMap.hasOwnProperty(oset)) {
                oprop = self.objectSetsMap[oset];
                extractObjectProperties(self[oset], oprop, result);
            }
        }

        return result;
    };

    var extractObjectProperties = function (objectSet, property, instructions) { // OPTIMIZATION: don't redefine func inside other func or loop
        var oid;
        var propval;
        for (oid in objectSet) {
            if (objectSet.hasOwnProperty(oid)) {

                if (property === "pickable") {
                    propval = !objectSet[oid];
                } else {
                    propval = objectSet[oid];
                }

                if (!instructions.hasOwnProperty(oid)) {
                    instructions[oid] = {};
                }
                instructions[oid][property] = propval;
            }
        }
    };


    // ------------------------- STATIC METHODS -------------------------------
    Chapter.getObjectSets = function () {
        return Object.keys(objectSetsMap);
    };


    // -----------------------  CREATION/EDITING FUNCTIONS ---------------------

    // HACK: For Scene-Graph Loading
    function redirectBaseAnatomy(objSet){
        var key;
        var newKey;
        for (key in objSet){
            if (objSet.hasOwnProperty(key)){

                if(Human.modules.isBase(key)) {
                    newKey = Human.modules.convertBaseAnatomyObjectId(key);

                    if(key !== newKey) {
                        objSet[newKey] = objSet[key];
                        delete objSet[key];
                    }
                }

            }
        }
        return objSet;
    }

})();
;/**
 * @namespace Engine media (videos, audio etc).
 */
Human.media = Human.media || {};;/**
 * @namespace Generic container for streaming media clips
 *
 * NOTE: Clips are now registered by the chapter that wants to play clips.
 * Clip data is still stored with the state folder, but the chapter publishes the clip by id
 *
 */
Human.media.Clips = function (streamType) {
    "use strict";

    var self = this;

    this._streamType = streamType;

    /** Clips mapped to IDs
     */
    this.clips = {};

    /** Clips ordered by their timeline times
     *
     * @type {Array}
     */
    this.clipsList = [];

    /** Clips grouped into libraries
     */
    this.libraries = {};

    /**
     * IDs of clips that are currently "suggested", where those clips have time1 and time2 properties
     * that interesect the current timeline scrubber.
     * @type {Array}
     */
    this.suggestedClips = [];

    Human.events.fire(this._streamType + ".clips", self.clipsList, true);

    //get clip by id
    self.getClipById = function(clipid){
      var result = null;
      this.clipsList.forEach(function(clip){
        if (clip.clipId === clipid){
          result = clip;
        }
      });
      return result;
    };

    /**
     * Creates a clips library
     * NOTE: from state folder
     *
     * @param {String} libraryId Unique library ID
     * @param {[{}]} clips Clips within the library
     */
    this.createLibrary = function (libraryId, clips) {

        if (this.libraries[libraryId]) {

            // Tolerate reload of same library
            Human.log.warn("Human.media." + this._streamType + ".createLibrary", "Library already loaded: " + libraryId);
            return;
        }

        var parts = libraryId.split("/");
        var modelId = parts[0];
        var subasset = parts[1];

        var library = this.libraries[libraryId] = {
            libraryId: libraryId,
            clips: {}
        };

        var p;
        var clip;

        // Create clips
        for (var i = 0, len = clips.length; i < len; i++) {
            p = clips[i];

            // Validate each clip
            if (!p.clipId) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: clipId");
                continue;
            }
            // if (!p.displayName) {
            //     Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: displayName");
            //     continue;
            // }
            if (!p.type) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: type");
                continue;
            }
            if (!p.src) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: src");
                continue;
            }
            if (p.time1 === undefined || p.time1 === null) {
                //Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: time1 - defaulting to 0 seconds");
                p.time1 = null;
            }
            if (p.time2 === undefined || p.time2 === null) {
                //Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: time2 - defaulting to 0 seconds");
                p.time2 = null;
            }
            if (this.clips[p.clipId]) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip 'clipId' clashes with another clip: '" + p.clipId + "' - replacing existing clip");
            }

            var fullURL = [modelId, this._streamType, subasset, p.src].join("/");

            clip = {
                clipId: p.clipId,
                modelId: modelId,
                streamType: this._streamType,
                subasset: subasset,
                displayName: p.displayName,
                description: p.description || "",
                time1: p.time1,
                time2: p.time2,
                type: p.type || "",
                src: p.src,
                fullUrl: fullURL,
                alternatives: p.alternatives || [],
                length: p.length || 0,
                suggested: false,
                status: "closed"
            };

            // Register clip against library
            library.clips[p.clipId] = clip;

            // Add clip to ID map
            this.clips[p.clipId] = clip;
        }

        // Rebuild time-ordered clip list from ID map
        this._rebuildClipList();
    };

    /** Rebuilds time-ordered clip list and exports it via event
     * @private
     */
    this._rebuildClipList = function () {
        this.clipsList = [];
        for (var clipId in this.clips) {
            if (this.clips.hasOwnProperty(clipId)) {
                this._insertClipIntoList(this.clipsList, this.clips[clipId]);
            }
        }
        // Publish new clip list
        Human.events.fire(this._streamType + ".clips", this.clipsList, true);
    };

    /**
     * Inserts a clip into list of clips ordered by time
     * @private
     */
    this._insertClipIntoList = function (list, clip) {
        if (list.length === 0) {
            // First clip in list
            list.push(clip);
        } else {
            // Find place and insert
            var v;
            for (var j = list.length - 1; j >= 0; j--) {
                v = list[j];
                if (v.time1 < clip.time1) {
                    list.splice(j + 1, 0, clip);
                    return;
                }
            }
            // Clip is earliest - insert at front of list
            list.splice(0, 0, clip);
        }
    };

    /**
     * Destroys a clips library
     * @param libraryId
     */
    this.destroyLibrary = function (libraryId) {
        var lib = this.libraries[libraryId];
        if (!lib) {
            // Tolerate missing library
            Human.log.warn("Human.media." + this._streamType + ".destroyLibrary", "Library not found: " + libraryId);
            return;
        }
        for (var clipId in lib.clips) {
            if (lib.clips.hasOwnProperty(clipId)) {
                delete this.clips[clipId];
                Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "destroyed" });
            }
        }
        delete this.libraries[libraryId];

        // Rebuild time-ordered clip list from remaining clips in ID map
        this._rebuildClipList();
    };

    /**
     * Opens a clip
     * @param clipId
     */
    this.open = function (clipId, ok) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "open" }, true);
        ok();
    };

    /**
     * Plays a clip
     * @param clipId
     */
    this.play = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "playing" }, true);
    };

    /**
     * Scrubs a clip to the given time
     * @param clipId
     * @param time
     */
    this.scrub = function (clipId, time) {
        Human.events.fire(this._streamType + ".scrubbed", { clipId: clipId, time: time });
    };

    /**
     * Pauses a clip
     * @param clipId
     */
    this.pause = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "paused" }, true);
    };

    /**
     * Stops a clip
     * @param clipId
     */
    this.stop = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "stopped" }, true);
    };

    /**
     * Closes a clip
     * @param clipId
     */
    this.close = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "closed" }, true);
    };

    /**
     * Destroys all clip libraries
     */
    this.reset = function () {
        for (var libraryId in this.libraries) {
            if (this.libraries.hasOwnProperty(libraryId)) {
                this.destroyLibrary(libraryId);
            }
        }
    };
};
;/**
 * @namespace Audio clips
 */
Human.media.audio= new Human.media.Clips("audio");;/**
 * @namespace Video clips
 */
Human.media.videos = new Human.media.Clips("videos");;
(function () {
    "use strict";

    var HumanActions = Human.actions = {};
    
    HumanActions._actions = {};

    Human.events.on("loaded",
        function () {

            // Alternative entry point for Human.actions._doAction via data-human-action attribute

            $(document).on('click', '[data-human-action]', function () {
                var $el = $(this);
                var action = $el.attr('data-human-action');
                var args = $el.attr('data-arguments');

                if (action) {
                    HumanActions._doAction([action, args]);
                }
            });
        });
    
    /** Registers an action handler.
     *
     * @param actionId
     * @param callback
     */
    HumanActions.addAction = function (actionId, callback) {
        HumanActions._actions[actionId] = callback;
    };

    /** Fires an action handler
     *
     * @param actionStr
     * @private
     */
    HumanActions._doAction = function (data) {
        var tokens;
        
        if(typeof data === 'string') {
            tokens = data.split("?");
            
            if (tokens.length === 0) {
                Human.log.error("Human.actions._parse", "Parsed invalid action link: " + data + "(ignoring)");
                return;
            }
        } else {
            tokens = data;
        }

        var actionId = tokens[0];

        var action = HumanActions._actions[actionId];

        if (!action) {
            Human.log.error("Human.actions._doAction", "Parsed invalid action link - action not found: " + actionId + " (ignoring)");
            return;
        }

        var actionParams = {};

        // Parse params
        var p = tokens[1];
        if (p) {
            var keyVals = p.split("&");
            var keyVal;
            for (var i = 0, len = keyVals.length; i < len; i++) {
                keyVal = keyVals[i].split("=");
                actionParams[keyVal[0]] = keyVal[1];
            }
        }

        // When action callbacks fail, they can just throw exceptions rather than go to the trouble
        // of logging and recovering. Then we can nicely log those in context of the action and recover.
        try {
            action(actionParams);
        } catch (e) {
            Human.log.error("Human.actions._doAction", "Action '" + actionId + "' threw an exception: " + e);
        }
    };

    /** Parses markdown into HREFs that fire action handlers that were registered with {@link #addAction}.
     *
     * @param markdown
     * @returns {*}
     */
    HumanActions.parse = function (markdown) {
        return markdown.replace(/\[\[([^|]*?)\|(.*?)\]\]/g, '<a href="javascript:Human.actions._doAction(\'$1\')">$2</a>');
    };

})();;/**
 * @namespace Engine asset libraries.
 * @private
 */

(function() {
    "use strict";

    var assets = Human.assets = {
        loadedAssets: {},
        nullAssets: {}
    };

    // Defaults to adding an "s" to type
    var ASSET_MODULES = {
        geometry: "geometries",
        skybox: "skyboxes",
        audio: "audio",
        videos: "video"
    };

    var assetUseCounts = {};
    var libUseCounts = {};
    var libModules = {}; // For each library remembers the module that loaded it, so the module can unload again
    var nullLibs = {};

    var assetCallbacks = {};

    var requestedAssets = 0;
    var receivedAssets = 0;

    assets.getAsset = function (assetId, type, ok) {
        if (assets.nullAssets[assetId]) {

            if (ok) {
                Human.utils.async(function () {
                    ok(null);
                });
            }

            return;
        }

        if (assets.loadedAssets[assetId] === "LOADING") {

            if (ok) {
                assetCallbacks[assetId].push(ok);
            }

            return;
        }

        if (assets.loadedAssets[assetId]) {

            assetAcquired(assetId);

            if (ok) {
                Human.utils.async(function () {
                    ok(assets.loadedAssets[assetId]);
                });
            }

            return;
        }

        if (requestedAssets === 0) {
            assetLoadStart();
        }

        requestedAssets++;

        assets.server.getAsset(type, assetId, function (asset) {
            assetLoadProgress(assetId, type);

            if (!asset || asset === assets.server.TIMEOUT) {
                if (!asset) {
                    assets.nullAssets[assetId] = true;
                }
                if (ok) {
                    ok(null);
                }
                return;
            }

            if (assets.loadedAssets[assetId] === "LOADING") {

                if (ok) {
                    assetCallbacks[assetId].push(ok);
                }

                return;
            }

            if (assets.loadedAssets[assetId]) {
                assetAcquired(assetId);
                if (ok) {
                    ok(assets.loadedAssets[assetId]);
                }
                return;
            }

            var module = Human.assets[getModuleName(type)];

            try {
                assets.loadedAssets[assetId] = "LOADING";

                assetCallbacks[assetId] = [];

                if (ok) {
                    assetCallbacks[assetId].push(ok);
                }

                module.parseAsset(assetId, asset, function(asset) {
                    assets.loadedAssets[assetId] = asset;
                    assetAcquired(assetId);

                    var callbacks = assetCallbacks[assetId];

                    for (var i = 0, len = callbacks.length; i < len; i++) {
                        callbacks[i](asset);
                    }

                    delete assetCallbacks[assetId];
                });
            } catch (e) {
                Human.log.error("Error parsing asset: " + assetId + " - " + e.message);
                assets.loadedAssets[assetId] = null;
                assets.nullAssets[assetId] = true;

                var callbacks = assetCallbacks[assetId];

                for (var i = 0, len = callbacks.length; i < len; i++) {
                    callbacks[i](null);
                }

                delete assetCallbacks[assetId];
            }
        });
    };

    function assetLoadStart() {
        Human.events.fire("assets.load.start");
    }

    function assetLoadProgress(assetId, type) {
        receivedAssets++;

        Human.events.fire("assets.load.progress", {
            assetId: assetId,
            assetType: type,
            requestedAssets: requestedAssets,
            receivedAssets: receivedAssets
        });

        if(receivedAssets === requestedAssets) {
            assetLoadFinish();
        }
    }

    function assetLoadFinish() {
        Human.events.fire("assets.load.finish");

        requestedAssets = 0;
        receivedAssets = 0;
    }

    assets.getAssetLibrary = function (type, dir, libId, fileName, params, ok) {

        if (nullLibs[libId]) {
            Human.utils.async(ok);
            return;
        }

        if (libUseCounts[libId]) {

            libAcquired(libId);
            Human.utils.async(ok);

            return;
        }

        assets.server.getAssetLibrary(dir, libId, fileName, function(data) {
            var module;

            if (!data) {
                nullLibs[libId] = true;

                if (ok) {
                    ok();
                }

                return;
            }


            if (libUseCounts[libId]) {

                libAcquired(libId);

                if (ok) {
                    ok();
                }
                return;
            }

            if (type === "animation") {
                if (data.format === "binary") {
                    if (ok) {
                        ok();
                    }
                    return;
                }
                module = Human.assets.tweens;
            } else {
                module = Human.assets[getModuleName(type)];
            }


            if (module) {
                // TODO: Do we need a semaphore to prevent concurrent asynch load of same library?

                module.parseLibrary(libId, data, params, function() {

                    libAcquired(libId);

                    libModules[libId] = module;

                    if (ok) {
                        ok();
                    }
                });

            } else {
                Human.log.error("Unknown asset library type: " + type);
                if (ok) {
                    ok();
                }
            }
        });
    };

    /**
     * Release an asset library that was acquired previously by #getAssetLibrary.
     * Deletes the lib when its use count count has then become zero.
     * Assumes that the library has completely loaded; don't call this while library is still loading.
     *
     * @param {String} libId ID of the asset library to release.
     */
    assets.putAssetLibrary = function(libId) {

        if (libUseCounts[libId] === undefined) { // Not currently loaded
            return;
        }

        if (--libUseCounts[libId] <= 0) {

            // Last reference released, destroy lib and use count

            delete assetUseCounts[libId];

            // Delegate asset unloading to module

            var module = libModules[libId];

            if (module && module.unloadLibrary) {
                module.unloadLibrary(libId);
            }

            delete libModules[libId];
        }
    };

    /**
     * Release an assets that was acquired previously by #getAsset.
     *
     * Deletes the asset when its use count count has then become zero.
     *
     * @param {String} assetId ID of the asset to release.
     */
    assets.putAsset = function (assetId) {

        if (assetUseCounts[assetId] === undefined) {
            return;
        }

        if (--assetUseCounts[assetId] <= 0) {

            // Last reference released, destroy asset and use count
            var asset = assets.loadedAssets[assetId];
            var module = Human.assets[getModuleName(asset.type)];
            module.destroyAsset(assetId);

            delete assets.loadedAssets[assetId];
            delete assetUseCounts[assetId];
        }
    };

    // Indicates that an asset library has been acquired, incrementing its use count.
    //
    function libAcquired(libId) {
        if (libUseCounts[libId] === undefined) {
            libUseCounts[libId] = 1;
            return;
        }
        libUseCounts[libId]++;
    }

    // Indicates that an asset has been acquired, incrementing its use count.
    //
    function assetAcquired(assetId) {
        if (assetUseCounts[assetId] === undefined) {
            assetUseCounts[assetId] = 1;
            return;
        }
        assetUseCounts[assetId]++;
    }

    function getModuleName(type) {
        return ASSET_MODULES[type] || type + "s";
    }

})();
;(function() {
    "use strict";

    var assetServer = Human.assets.server = {
        TIMEOUT: 1
    };

    var socketProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";
    var socketURL = socketProtocol + "//assets-" + window.location.host + "/assets/ws2";

    var socket = createSocket();

    var TIMEOUT = 120000; //ms

    // Callbacks to be run when the socket opens.
    var openCallbacks = [];

    // Callbacks to be run when a message is received.
    // Organized by asset ID.
    var messageCallbacks = {};

    var requestQueue = [];

    // Defaults to adding an "s" to type
    var URL_BASE = {
        geometry: "geometry"
    };

    var moduleDefinitions = {};
    var stateIndexes = {};

    var lastNetworkTime;

    assetServer.cacheModuleDefinition = function(moduleId, moduleDefinition) {
        if (moduleDefinitions[moduleId]) {
            return;
        }

        if (moduleDefinition) {
            moduleDefinitions[moduleId] = JSON.stringify(moduleDefinition);
            return;
        }

        assetServer.getModuleDefinition(moduleId);
    };

    assetServer.getModuleDefinition = function (moduleName, ok, error) {
        if (moduleDefinitions[moduleName]) {
            if (ok) {
                ok(JSON.parse(moduleDefinitions[moduleName]));
            }
            return;
        }

        $.ajax({
            dataType: "text",
            url: "content/modules/" + moduleName,
            success: function (moduleDefinition) {
                moduleDefinitions[moduleName] = moduleDefinition;
                if (ok) {
                    ok(JSON.parse(moduleDefinition));
                }
            },
            error: function (xhr, textStatus, errorThrown) {
                Human.events.fire("net.error", {
                    id: moduleName,
                    type: "modules",
                    status: xhr.status,
                    statusText: xhr.statusText
                });

                if (error) {
                    error(errorThrown);
                }
            }
        });
    };

    assetServer.cacheStateIndex = function(stateId, index) {
        if (stateIndexes[stateId]) {
            return;
        }

        if (index) {
            stateIndexes[stateId] = JSON.stringify(index);
            return;
        }

        $.ajax({
            dataType: "text",
            url: "content/states/" + stateId + "/index?v=" + Human.VERSION,
            success: function (index) {
                stateIndexes[stateId] = index;
            }
        });
    };

    assetServer.getStateIndex = function(stateId, ok, error) {
        if (stateIndexes[stateId]) {
            if (ok) {
                ok(JSON.parse(stateIndexes[stateId]));
            }
            return;
        }

        $.ajax({
            dataType: "json",
            url: "content/states/" + stateId + "/index?v=" + Human.VERSION,
            // NOTE: state index not cached here because it caused GC issues in Chrome.
            success: ok,
            error: error
        });
    };

    assetServer.getAnimationManifest = function(libId, ok, error) {
        var parts = libId.split("/");

        $.ajax({
            dataType: "json",
            url: "content/states/" + parts[0] + "/animations/" + parts[1] + "/manifest",
            success: ok,
            error: error
        });
    };

    assetServer.getAsset = function(type, id, ok) {
        var parts = id.split("/");
        var stateId = parts[0];
        var assetId = parts[1];
        var key = parts[2];
        var assetURI = stateId + "/" + (URL_BASE[type] || type + "s") + "/" + assetId;
        if (key) {
            assetURI += "/" + key;
        }

        if (messageCallbacks[assetURI]) {
            messageCallbacks[assetURI].push(ok);
            return;
        }

        messageCallbacks[assetURI] = [ok];

        requestQueue.push(assetURI);
    };

    assetServer.getAssetLibrary = function (dir, libId, fileName, ok) {
        var parts = libId.split("/");

        $.ajax({
            dataType: "json",
            url: "content/states/" + parts[0] + "/" + dir + "/" + parts[1] + "/" + fileName,
            success: ok,
            error: function() {
                Human.log.error("Asset library not found: " + libId);
                ok(null);
            }
        });
    };

    function createSocket() {
        var socket = new WebSocket(socketURL);

        socket.binaryType = "arraybuffer";

        socket.addEventListener("open", function() {
            socket.send(JSON.stringify({ open: "sesame!" }));

            for (var i = 0, len = openCallbacks.length; i < len; i++) {
                openCallbacks[i]();
            }

            openCallbacks.length = 0;
        });

        socket.addEventListener("close", function(event) {
            Human.log.log("Socket closed", event.code, event.reason);
        });

        socket.addEventListener("error", function() {
            Human.log.error("Socket error");
        });

        socket.addEventListener("message", function(response) {

            var data = response.data;
            var asset;
            var assetId;

            lastNetworkTime = Date.now();

            if (typeof data === "string") {

                // Non-data "message received" signal
                if (data === "\uD83C\uDF7A") {
                    return;
                }

                var json = JSON.parse(data);
                assetId = json.id;

                if (json.error) {
                    Human.log.error("Asset not found: " + assetId);
                    asset = null;
                } else {
                    asset = json.asset;
                }


            } else {

                /*
                 Geometry or morph

                 bytes   : info
                 [0.. 3]: uint32; file type identifer (= 0x11)
                 [4.. 7]: uint32; byte-length of padded asset id
                 [8..11]: uint32; byte-length of padded morph keys JSON
                 [12..15]: uint32; byte-length of positions array
                 [16..19]: uint32; byte-length of normals array
                 [20..23]: uint32; byte-length of indices array
                 [24..27]: uint32; byte-length of uv array
                 [28..43]: unit32[4]; unused, reserved for future use
                 [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
                 [  ..  ]: text; morph key JSON (tail-padded with 0x20)
                 [  ..  ]: float32[]; positions array
                 [  ..  ]: float32[]; normals array
                 [  ..  ]: int32[];   indices array
                 [  ..  ]: float32[]; uv array
                 */

                asset = data;

                // Peek at data to get asset ID

                var assetIdStart = 11 * Uint32Array.BYTES_PER_ELEMENT;
                var assetIdSize = new Uint32Array(asset, 0, 2)[1];

                assetId = Human.utils.atos(asset, assetIdStart, assetIdSize).trim();
            }

            var callbacks = messageCallbacks[assetId];

            if (callbacks) {
                for (var i = 0, len = callbacks.length; i < len; i++) {
                    callbacks[i](asset);
                }
                delete messageCallbacks[assetId];
            }
        });

        return socket;
    }

    function socketSend() {

        if (requestQueue.length === 0) {
            return;
        }

        lastNetworkTime = Date.now();

        if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                assets: requestQueue
            }));
            requestQueue.length = 0;
            return;
        }

        openCallbacks.push(function() {
            socket.send(JSON.stringify({
                assets: requestQueue
            }));
            requestQueue.length = 0;
        });

        if (socket.readyState === WebSocket.CLOSING || socket.readyState === WebSocket.CLOSED) {
            socket = createSocket();
        }
    }

    setInterval(function() {

        socketSend();

        var now = Date.now();

        if (now - lastNetworkTime > TIMEOUT) {
            for (var assetId in messageCallbacks) {
                if (messageCallbacks.hasOwnProperty(assetId)) {
                    Human.log.error("Server timeout on asset: " + assetId);
                    var callbacks = messageCallbacks[assetId];

                    for (var i = 0, len = callbacks.length; i < len; i++) {
                        callbacks[i](assetServer.TIMEOUT);
                    }
                    delete messageCallbacks[assetId];
                }
            }
        }

    }, 100);

})();
;/**
 * @namespace Geometry libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsGeometries = Human.assets.geometries = {};

    /** All geometries
     */
    HumanAssetsGeometries.geometries = {};

    // Holds all SceneJS nodes for geometries
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Geometry library"
            });
        });

    HumanAssetsGeometries.parseAsset = function(geometryId, asset, ok) {

        /*

         Geometry format

         bytes   : info
         [0.. 3]: uint32; file type identifer (= 0x11)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph keys JSON
         [12..15]: uint32; byte-length of positions array
         [16..19]: uint32; byte-length of normals array
         [20..23]: uint32; byte-length of indices array
         [24..27]: uint32; byte-length of uv array
         [28..43]: unit32[4]; unused, reserved for future use
         [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
         [  ..  ]: text; morph key JSON (tail-padded with 0x20)
         [  ..  ]: float32[]; positions array
         [  ..  ]: float32[]; normals array
         [  ..  ]: int32[];   indices array
         [  ..  ]: float32[]; uv array
         */

        var index = new Uint32Array(asset, 0, 11);

        // var unusedFileType = index[0];
        var assetIdSize = index[1];
        var keysSize = index[2];
        var positionsSize = index[3];
        var normalsSize = index[4];
        var indicesSize = index[5];
        var uvsSize = index[6];
        // var unused = index[7 ... 10];

        var assetIdStart = 11  * Uint32Array.BYTES_PER_ELEMENT;
        var keysStart = assetIdStart + assetIdSize;
        var positionsStart = keysStart + keysSize;
        var normalsStart = positionsStart + positionsSize;
        var indicesStart = normalsStart + normalsSize;
        var uvsStart = indicesStart + indicesSize;

        var cfg = {
            geometry: {
                primitive: 'triangles'
            }
        };

        var numVertices = 0;

        if (positionsSize > 0) {
            cfg.geometry.positions = new Float32Array(asset, positionsStart, positionsSize / Float32Array.BYTES_PER_ELEMENT);
            cfg.boundary = getBoundary(cfg.geometry.positions);
            numVertices = cfg.geometry.positions.length / 3;
        }

        if (normalsSize > 0) {
            cfg.geometry.normals = new Float32Array(asset, normalsStart, normalsSize / Float32Array.BYTES_PER_ELEMENT);
        }

        if (uvsSize > 0) {
            cfg.geometry.uv = new Float32Array(asset, uvsStart, uvsSize / Float32Array.BYTES_PER_ELEMENT);
        }

        if (indicesSize > 0) {
            cfg.geometry.indices = new Uint32Array(asset, indicesStart, indicesSize / Uint32Array.BYTES_PER_ELEMENT);
            if (numVertices <= 256) {
                cfg.geometry.indices = new Uint8Array(cfg.geometry.indices);
            } else if (numVertices <= 65536) {
                cfg.geometry.indices = new Uint16Array(cfg.geometry.indices);
            }
        }

        ok(HumanAssetsGeometries.createGeometry(geometryId, cfg));
    };

    /** Creates a geometry within an existing geometries library
     * @param libraryId ID of library
     * @param geometryId ID for new geometry, globally unique among geometries in all libraries
     * @param params Geometry params - geometry, texture, flags
     */
    HumanAssetsGeometries.createGeometry = function (geometryId, params) {
        if (HumanAssetsGeometries.geometries[geometryId]) {
            Human.log.error("Human.assets.geometries.createGeometry", "Geometry already loaded: " + geometryId);
            return;
        }
        if (!params.geometry) {
            Human.log.error("Human.assets.geometries.createGeometry", "Mandatory attribute 'geometryId' expected on geometry: " + geometryId);
            return;
        }
        params.geometry.type = "geometry";
        var geometry = {
            //   materialId: params.materialId, // HACK while materialId can be on geometries
            geometry: libRoot.addNode(params.geometry),
            type: "geometry"
        };
        // Boundary and center
        if (params.boundary) {
            var boundary = params.boundary;
            geometry.boundary = boundary;
            geometry.center = [
                (boundary.xmax + boundary.xmin) * 0.5,
                (boundary.ymax + boundary.ymin) * 0.5,
                (boundary.zmax + boundary.zmin) * 0.5
            ];
            geometry.axisBoundary = new Human.math.AxisBox3(
                [boundary.xmin, boundary.ymin, boundary.zmin],
                [boundary.xmax, boundary.ymax, boundary.zmax]);
        }
        HumanAssetsGeometries.geometries[geometryId] = geometry;

        return geometry;
    };

    /**
     * Destroys a geometries library
     * @param libraryId
     */
    HumanAssetsGeometries.destroyAsset = function (geometryId) {
        if (geometryId) {
            var geometry = HumanAssetsGeometries.geometries[geometryId];
            geometry.geometry.destroy();
            delete HumanAssetsGeometries.geometries[geometryId];
        } else {
            HumanAssetsGeometries.reset();
        }
    };

    /** Destroys all geometry libraries
     */
    HumanAssetsGeometries.reset = function () {
        for (var geometryId in HumanAssetsGeometries.geometries) {
            if (HumanAssetsGeometries.geometries.hasOwnProperty(geometryId)) {
                HumanAssetsGeometries.destroyAsset(geometryId);
            }
        }
    };

    // Get minimal boundary enclosing the given array
    function getBoundary(positions) {
        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var x, y, z;
        for (var i = 0, len = positions.length - 2; i < len; i += 3) {
            x = positions[i];
            y = positions[i + 1];
            z = positions[i + 2];
            if (x === undefined || x === null ||
                y === undefined || y === null ||
                z === undefined || z === null) {
                continue;
            }
            if (x < xmin) {
                xmin = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (z < zmin) {
                zmin = z;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y > ymax) {
                ymax = y;
            }
            if (z > zmax) {
                zmax = z;
            }
        }
        return { xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax };
    }
})();
;
/**
 * @namespace Material libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsMaterials = Human.assets.materials = {};

    /** All materials
     */
    HumanAssetsMaterials.materials = {};

    // Holds all SceneJS nodes for materials
    var libRoot;

    var EMBEDDED = false;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type:"library",
                data: "Materials library"
            });
        });

    HumanAssetsMaterials.parseAsset = function(materialId, asset, ok) {
        var parts = materialId.split("/");
        var libId = parts[1].split(".")[0];
        var imagePath = "content/states/" + parts[0] + "/materials/" + libId + "/";

        HumanAssetsMaterials.createMaterial(materialId, parseManifest(asset, imagePath), ok);
    };

    /** Given a state ID and a relative material ID, attempts to find the material within the libraries
     * @param materialId Relative material ID, ie. not prefixed by libraryId
     */
    HumanAssetsMaterials.findMaterial = function (materialId) {
        var material = HumanAssetsMaterials.materials[materialId];

        if (material) {
            return material;
        } else {
            return null;
        }
    };

    /** Creates a material within an existing materials library
     * @param libraryId ID of library
     * @param materialId ID for new material, globally unique among materials in all libraries
     * @param params Material params - material, reflection, texture, flags
     */
    HumanAssetsMaterials.createMaterial = function (materialId, params, ok) {
        if (HumanAssetsMaterials.materials[materialId]) {
            Human.log.warn("Human.assets.materials.createMaterial", "Material already loaded: " + materialId);
            return;
        }
        var material = {
            type: "material"
        };
        if (params.material) {
            material.material = libRoot.addNode(params.material);
            material.glassFactor = params.material.glassFactor !== undefined && params.material.glassFactor !== null ? params.material.glassFactor : 1.0;
            material.murkiness = params.material.murkiness !== undefined && params.material.murkiness !== null ? params.material.murkiness : 1.0;

            // Fresnels

            var fresnel;
            var edge;
            var center;

            // Base color Fresnel

            if (params.material.baseFresnel) {

                fresnel = params.material.baseFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge : {r: 1, g: 1, b: 1};
                center = fresnel.center !== undefined ? fresnel.center : {r: 0, g: 0, b: 0};

                material.fresnels.color = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "color",
                    edgeBias: fresnel.biasEdge,
                    centerBias: fresnel.biasCenter,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center
                });
            }

            // Alpha Fresnel

            if (params.material.alphaFresnel) {

                fresnel = params.material.alphaFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge : 0;
                center = fresnel.center !== undefined ? fresnel.center  : 1;

                material.fresnels.alpha = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "alpha",
                    edgeBias: fresnel.biasEdge,
                    centerBias: fresnel.biasCenter,
                    power: fresnel.power || 1,
                    edgeColor: {
                        r: edge,
                        g: edge,
                        b: edge
                    },
                    centerColor: {
                        r: center,
                        g: center,
                        b: center
                    }
                });
            }

            // Reflection Fresnel

            if (params.material.reflectionFresnel) {

                fresnel = params.material.reflectionFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge : 1;
                center = fresnel.center !== undefined ? fresnel.center  : 0;

                material.fresnels.reflect = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "reflect",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: {
                        r: edge,
                        g: edge,
                        b: edge
                    },
                    centerColor: {
                        r: center,
                        g: center,
                        b: center
                    }
                });
            }

            // Specular Fresnel

            if (params.material.specularFresnel) {

                fresnel = params.material.specularFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge  : {r: 0, g: 0, b: 0};
                center = fresnel.center !== undefined ? fresnel.center : {r: 1, g: 1, b: 1};

                material.fresnels.specular = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "specular",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center
                });
            }

            // Emit Fresnel

            if (params.material.emitFresnel) {

                fresnel = params.material.emitFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge  : {r: 0, g: 0, b: 0};
                center = fresnel.center !== undefined ? fresnel.center : {r: 1, g: 1, b: 1};

                material.fresnels.emit = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "emit",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center
                });
            }

            // Fragment Fresnel

            if (params.material.fragmentFresnel) {

                fresnel = params.material.fragmentFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge  : {r: 0, g: 0, b: 0};
                center = fresnel.center !== undefined ? fresnel.center : {r: 1, g: 1, b: 1};

                material.fresnels.fragment = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "fragment",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center
                });
            }

        } else {
            material.glassFactor = 1.0;
            material.murkiness = 1.0;
        }

        if (params.reflection) { // Reflection asset
            material.reflection = libRoot.addNode({
                type: "reflect",
                coreId: params.reflection.getCoreId() // Share core with reflection scene node
            });
        }

        if (params.flags) {
            material.flags = params.flags.flags;
        }

        loadTextures(material, params, function() {
            HumanAssetsMaterials.materials[materialId] = material;

            ok(material);
        });
    };

    function loadTextures(material, params, ok) {
        if (!params.texture) {
            ok();
            return;
        }

        var texture = params.texture;
        var layers = texture.layers;
        var layer;

        var numTextures = layers.length;

        material.textures = new Array(numTextures);

        function done() {
            if (--numTextures === 0) {
                ok();
            }
        }

        for (var i = 0, len = numTextures; i < len; i++) {
            layer = layers[i];
            var img = new Image();
            img.onload = getImageCallback(img, layer, material, i, done);
            img.onerror = getImageErrorCallback(layer.uri, done);
            img.src = layer.uri;
            layer.uri = null;
            layer.src = null;
        }
    }

    function getImageCallback(img, layer, material, index, ok) {
        return function() {
            layer.type = "texture";
            layer.image = img;
            material.textures[index] = libRoot.addNode(layer);
            ok();
        };
    }

    function getImageErrorCallback(uri, ok) {
        return function() {
            Human.log.error("Texture image not found: " + uri);
            ok();
        };
    }

    /**
     * Destroys a materials library
     * @param libraryId
     */
    HumanAssetsMaterials.destroyAsset = function (materialId) {
        // Also check for "" libraries, otherwise will run into circular dependency with reset
        if (materialId) {
            var material = HumanAssetsMaterials.materials[materialId];

            for (var type in material) {
                if (material.hasOwnProperty(type) && typeof material[type].destroy === "function") {
                    material[type].destroy();
                }
            }

            delete HumanAssetsMaterials.materials[materialId];
        } else {
            HumanAssetsMaterials.reset();
        }
    };

    /** Destroys all material libraries
     */
    HumanAssetsMaterials.reset = function () {
        for (var materialId in HumanAssetsMaterials.materials) {
            if (HumanAssetsMaterials.materials.hasOwnProperty(materialId)) {
                HumanAssetsMaterials.destroyAsset(materialId);
            }
        }
    };

    function parseManifest(node, path, material) {
        material = material || {};
        var i, len;

        if (node.id) {
            node.id = null; // Don't let SceneJS create a node with this ID - would cause ID clash
        }
        switch (node.type) {
            case  "texture":
                var layer;
                for (i = 0, len = node.layers.length; i < len; i++) {
                    layer = node.layers[i];
                    layer.uri = layer.uri || layer.src;
                    if (!layer.uri) {
                        layer.uri = ".";
                        Human.log.error("Human.assets.materials.parseManifest", "Texture layer with no 'uri' or 'src' property");
                    } else {
                        if (EMBEDDED) {
                            // (bas) these were changed to absolute uris
                            layer.uri += "?v=" + Human.VERSION;
                        } else {
                            layer.uri = path + layer.uri + "?v=" + Human.VERSION;
                        }
                    }

                    layer.preloadURI = layer.preloadURI || layer.preloadSrc;
                    if (layer.preloadURI) {
                        if (EMBEDDED) {
                            // (bas) these were changed to absolute uris
                            layer.preloadURI += "?v=" + Human.VERSION;
                        } else {
                            layer.preloadURI = path + layer.preloadURI + "?v=" + Human.VERSION;
                        }
                    }

                    // In SceneJS V3.0, texture blendMode has changed from "add" to "multiply".
                    // Some of our materials for texture have black base color, which worked fine with "add",
                    // but not with "multiply", so we'll default to "add" here.
                    layer.blendMode = layer.blendMode || "add";
                }
                if (material) {
                    material.texture = node;
                }
                break;

            case "material":
                if (material) {
                    material.material = node;
                    if (node.reflectionId) {
                        var reflectionId = node.reflectionId;
                        var reflections = Human.assets.reflections;
                        var assetId = reflections.exportedReflectionIds[reflectionId];
                        if (!assetId) {
                            Human.log.error("Human.assets.materials.parseManifest", "Reflection not found: " + reflectionId);
                        } else {
                            var reflection = Human.assets.reflections.reflections[assetId];
                            if (reflection) {
                                material.reflection = reflection.node;
                            } else {
                                Human.log.error("Human.assets.materials.parseManifest", "Reflection not found: " + reflectionId);
                            }
                        }
                    }
                }
                break;

            case "flags":
                if (material) {
                    material.flags = node;
                }
                break;
        }
        if (node.nodes) {
            for (i = 0, len = node.nodes.length; i < len; i++) {
                parseManifest(node.nodes[i], path, material);
            }
        }
        return material;
    }
})();
;/**
 * @namespace Region libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsRegionMaps = Human.assets.regionMaps = {};

    /** All region maps
     */
    HumanAssetsRegionMaps.maps = {};

    /** Region maps grouped into libraries
     */
    HumanAssetsRegionMaps.libraries = {};

    // Holds all SceneJS nodes for regions
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Region Map library" // For debugging
            });
        });

    /** Creates a regions library
     * @param libraryId Unique library ID
     */
    HumanAssetsRegionMaps.createLibrary = function (libraryId) {
        if (HumanAssetsRegionMaps.libraries[libraryId]) {
            Human.log.warn("Human.assets.regionMaps.createLibrary", "Region map library already loaded: " + libraryId);
            return;
        }
        HumanAssetsRegionMaps.libraries[libraryId] = {
            // Root scene node for each library means we can blow away scene nodes
            // for a library in one shot by destroying the root
            node: libRoot.addNode({
                type: "library",
                data: "libraryId = " + libraryId // For debugging
            }),
            libraryId: libraryId,
            maps: {}
        };
    };

    /** Creates a region within an existing regions library
     * @param libraryId ID of library
     * @param regionId ID for new region, globally unique among regions in all libraries
     * @param params Region params - region, texture, flags
     */
    HumanAssetsRegionMaps.createRegion = function (libraryId, regionMapId, params) {
        var library = HumanAssetsRegionMaps.libraries[libraryId];
        if (!library) {
            Human.log.error("Human.assets.regions.createRegion", "Region library not found: " + libraryId);
            return;
        }
        if (HumanAssetsRegionMaps.maps[regionMapId]) {
            Human.log.warn("Human.assets.regions.createRegion", "Region already loaded: " + regionMapId);
            return;
        }
        var regionMap = {
            node: library.node.addNode({
                type: "regionMap",
                src: params.src,
                mode: params.mode || "highlight",
                regionData: params.regions,
                highlightFactor: params.highlightFactor || { r: 1.2, g: 1.2, b: 1.2 },
                hideAlpha: params.hideAlpha || 0.0
            }),
            regionMapId: regionMapId
        };
        HumanAssetsRegionMaps.maps[regionMapId] = regionMap;
        library.maps[regionMapId] = regionMap;
    };

    /**

     @param color Color to look for
     @param [regionId=null] Optional region ID - searches all regions when omitted
     @param highlight Boolean flag to highlight or unhighlight
     @returns {*}
     */
    HumanAssetsRegionMaps.highlightRegion = function (params) {
        params = params || {};
        
        var regionColor = params.regionColor;
        var regionMapId = params.regionMapId;
        var highlight = params.highlight;
        var regionMap;

        var regionMaps = HumanAssetsRegionMaps.maps;
        if (!regionMapId) {
            for (regionMapId in regionMaps) {
                if (regionMaps.hasOwnProperty(regionMapId)) {
                    regionMap = regionMaps[regionMapId];
                    if (highlight) {
                        regionMap.node.setRegionColor(regionColor);
                    } else {
                        regionMap.node.setRegionColor({ r: -1, g: -1, b: -1 });
                    }
                }
            }
            return;
        }

        regionMap = regionMaps[regionMapId];
        if (highlight) {
            regionMap.node.setRegionColor(regionColor);
        } else {
            regionMap.node.setRegionColor({ r: -1, g: -1, b: -1 });
        }
    };

    /**
     * Destroys a regions library
     * @param libraryId
     */
    HumanAssetsRegionMaps.destroyLibrary = function (libraryId) {
        if (libraryId || libraryId === "") {
            var lib = HumanAssetsRegionMaps.libraries[libraryId];
            if (!lib) {
                Human.log.warn("Human.assets.regions.destroyLibrary", "Region library not found: " + libraryId);
                return;
            }
            lib.node.destroy(); // Blow away scene subgraph
            for (var regionMapId in lib.maps) {
                if (lib.maps.hasOwnProperty(regionMapId)) {
                    delete HumanAssetsRegionMaps.maps[regionMapId];
                }
            }
            delete HumanAssetsRegionMaps.libraries[libraryId];
        } else {
            HumanAssetsRegionMaps.reset();
        }
    };

    /** Destroys all region libraries
     */
    HumanAssetsRegionMaps.reset = function () {
        for (var libraryId in HumanAssetsRegionMaps.libraries) {
            if (HumanAssetsRegionMaps.libraries.hasOwnProperty(libraryId)) {
                HumanAssetsRegionMaps.destroyLibrary(libraryId);
            }
        }
    };
})();;(function() {
    "use strict";


    /**
     * @namespace Loads regions into {@link Human.view.regions}
     * @private
     * @type {Loader}
     */
    Human.assets.regionMaps.loader = new Human.utils.Loader();

    Human.assets.regionMaps.loader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localLibraryId = libraryId;
        var globalLibraryId = modelId + "." + libraryId;

        Human.net.getRegionsLibrary(
            localLibraryId,
            function (manifest) {
                Human.assets.regionMaps.createLibrary(globalLibraryId);
                var imagesPath = Human.net.getRegionsDir(localLibraryId);
                var region;
                var src;
                for (var regionId in manifest) {
                    if (manifest.hasOwnProperty(regionId)) {
                        region = manifest[regionId];
                        src = region.src;
                        if (!src) {
                            Human.log.error("Human.assets.regionMaps.loader", "Region property missing: src");
                            continue;
                        }
                        region.src = imagesPath + src.substring(src.lastIndexOf("/") + 1) + "?v=" + Human.VERSION;
                        Human.assets.regionMaps.createRegion(globalLibraryId, globalLibraryId + "." + regionId, region);
                    }
                }
                // Subsequently-loaded materials will need our regions to exist, so render a frame
                // to force the creation of the regions' nodes in the scene graph
                Human.renderer.compile();
                ok();
            },
            function (errMsg) {
                error("failed to load manifest file for regions library '" + localLibraryId + "': " + errMsg);
            });
    };


    Human.assets.regionMaps.loader._unload = function (globalLibraryId) {
        Human.assets.regionMaps.destroyLibrary(globalLibraryId);
    };
})();
;/**
 * @namespace Transform libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsTransforms = Human.assets.transforms = {};

    /** All transforms
     */
    HumanAssetsTransforms.transforms = {};


    /** Creates a transform within an existing transforms library
     * @param libraryId ID of library
     * @param transformId ID for new transform, globally unique among transforms in all libraries
     * @param params Transform params
     */
    HumanAssetsTransforms.parseAsset = function (transformId, asset, ok) {
        if (HumanAssetsTransforms.transforms[transformId]) {
            Human.log.warn("Human.assets.transforms.createTransform", "Transform already loaded, not reloading: " + transformId);
            return;
        }
        var transform = new Human.assets.transforms.Transform(asset);
        HumanAssetsTransforms.transforms[transformId] = transform;

        ok(transform);
    };

    /** Given a relative transform ID, attempts to find the transform within the libraries
     * @param transformId Relative transform ID, ie. not prefixed by libraryId
     */
    HumanAssetsTransforms.findTransform = function (transformId) {
        var transform = HumanAssetsTransforms.transforms[transformId];
        if (transform) {
            return transform;
        } else {
            return null;
        }
    };

    /**
     * Destroys a transforms library
     * @param libraryId
     */
    HumanAssetsTransforms.destroyAsset = function (transformId) {
        if (transformId) {
            delete HumanAssetsTransforms.transforms[transformId];
        } else {
            HumanAssetsTransforms.reset();
        }
    };

    /** Destroys all transform libraries
     */
    HumanAssetsTransforms.reset = function () {
        for (var transformId in HumanAssetsTransforms.transforms) {
            if (HumanAssetsTransforms.transforms.hasOwnProperty(transformId)) {
                HumanAssetsTransforms.destroyAsset(transformId);
            }
        }
    };
})();
;(function() {
    "use strict";

    /**
     * A transformation asset with a {@link Human.assets.transforms}.
     * @param cfg
     * @constructor
     */
    Human.assets.transforms.Transform = function (cfg) {

        this.type = "transform";

        // Call parent class Human.Component init
        this._init();

        // Defaults
        this.pivot = { x: 0, y: 0, z: 0 };
        this.translate = { x: 0, y: 0, z: 0 };
        this.scale = { x: 1, y: 1, z: 1 };
        this.rotate = { x: 0, y: 0, z: 0 };

        // Initialize
        this.set(cfg);
    };

    Human.utils.extend(Human.assets.transforms.Transform, Human.Component);

    /**
     * Sets the transforms.
     */
    Human.assets.transforms.Transform.prototype.set = function (params) {

        if (params.pivot) {
            if (params.pivot.x !== undefined) {
                this.pivot.x = params.pivot.x;
            }
            if (params.pivot.y !== undefined) {
                this.pivot.y = params.pivot.y;
            }
            if (params.pivot.z !== undefined) {
                this.pivot.z = params.pivot.z;
            }
        }

        if (params.translate) {
            if (params.translate.x !== undefined) {
                this.translate.x = params.translate.x;
            }
            if (params.translate.y !== undefined) {
                this.translate.y = params.translate.y;
            }
            if (params.translate.z !== undefined) {
                this.translate.z = params.translate.z;
            }
        }

        if (params.scale) {
            if (params.scale.x !== undefined) {
                this.scale.x = params.scale.x;
            }
            if (params.scale.y !== undefined) {
                this.scale.y = params.scale.y;
            }
            if (params.scale.z !== undefined) {
                this.scale.z = params.scale.z;
            }
        }

        if (params.rotate) {
            if (params.rotate.x !== undefined) {
                this.rotate.x = params.rotate.x;
            }
            if (params.rotate.y !== undefined) {
                this.rotate.y = params.rotate.y;
            }
            if (params.rotate.z !== undefined) {
                this.rotate.z = params.rotate.z;
            }
        }

        this.publish("updated");
    };

})();

;/**
 * @namespace Morph libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsMorphs = Human.assets.morphs = {};

    /** All morphs
     */
    HumanAssetsMorphs.morphs = {};


    // Holds all SceneJS nodes for morphs
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Morphs library"
            });
        });

    HumanAssetsMorphs.parseAsset = function(morphId, asset, ok) {

        /*

         Morph format

         bytes   : info
         [0.. 3]: uint32; file type identifer (= 0x11)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph keys JSON
         [12..15]: uint32; byte-length of positions array
         [16..19]: uint32; byte-length of normals array
         [20..23]: uint32; byte-length of indices array
         [24..27]: uint32; byte-length of uv array
         [28..43]: unit32[4]; unused, reserved for future use
         [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
         [  ..  ]: text; morph key JSON (tail-padded with 0x20)
         [  ..  ]: float32[]; positions array
         [  ..  ]: float32[]; normals array
         [  ..  ]: int32[];   indices array
         [  ..  ]: float32[]; uv array
         */

        var index = new Uint32Array(asset, 0, 11);

        // var unusedFileType = index[0];
        var assetIdSize = index[1];
        var keysSize = index[2];
        var positionsSize = index[3];
        var normalsSize = index[4];
        var indicesSize = index[5];
        var uvsSize = index[6];
        // var unused = index[7 ... 10];

        var assetIdStart = 11  * Uint32Array.BYTES_PER_ELEMENT;
        var keysStart = assetIdStart + assetIdSize;
        var positionsStart = keysStart + keysSize;
        var normalsStart = positionsStart + positionsSize;
        var indicesStart = normalsStart + normalsSize;
        var uvsStart = indicesStart + indicesSize;

        var keys = Human.utils.atoj(asset, keysStart, keysSize);

        var numKeys = keys.length;

        var target;
        var targets = [];

        var targetPositionsSize = positionsSize / numKeys;
        var targetPositionsLength = targetPositionsSize / Float32Array.BYTES_PER_ELEMENT;

        var targetNormalSize = normalsSize / numKeys;
        var targetNormalLength = targetNormalSize / Float32Array.BYTES_PER_ELEMENT;

        var targetUVsSize = uvsSize / numKeys;
        var targetUVsLength = uvsSize / Float32Array.BYTES_PER_ELEMENT;

        for (var i = 0; i < numKeys; i++) {

            target = {};

            if (positionsSize > 0) {
                target.positions = new Float32Array(asset, positionsStart + (i * targetPositionsSize), targetPositionsLength);
            }

            if (normalsSize > 0) {
                target.normals = new Float32Array(asset, normalsStart + (i * targetNormalSize), targetNormalLength);
            }

            if (uvsSize > 0) {
                target.uvs = new Float32Array(asset, uvsStart + (i * targetUVsSize), targetUVsLength);
            }

            targets.push(target);
        }

        ok(
            Human.assets.morphs.createMorph(morphId, {
                morphGeometry: {
                    targets: targets,
                    keys: keys
                }
            })
        );
    };

    /** Given a relative morph ID, attempts to find the morph within the libraries
     * @param morphId Relative morph ID, ie. not prefixed by libraryId
     */
    HumanAssetsMorphs.findMorph = function (morphId) {
        var morph = HumanAssetsMorphs.morphs[morphId];

        if (morph) {
            return morph;
        } else {
            return null;
        }
    };

    /** Creates a material within an existing morphs library
     * @param libraryId ID of library
     * @param morphId ID for new material, globally unique among morphs in all libraries
     * @param params Material params - material, texture, flags

     */
    HumanAssetsMorphs.createMorph = function (morphId, params) {

        var morph = HumanAssetsMorphs.morphs[morphId];

        if (morph) {
            Human.log.warn("Human.assets.morphs.createMorph", "Morph already loaded: " + morphId);
            return morph;
        }

        morph = {
            type: "morph",
            boundary: null,
            center: null,
            axisBoundary: null,
            _frameDirty: true,
            updateBoundary: function getBoundary() {
                if (!this._frameDirty) {
                    return;
                }

                var boundary = {
                    xmin: 100000,
                    ymin: 100000,
                    zmin: 100000,
                    xmax: -100000,
                    ymax: -100000,
                    zmax: -100000
                };

                var currentFrame = this.morphGeometry.getCurrentFrame();
                var positions1 = currentFrame.target1.positions;
                var positions2 = currentFrame.target2.positions;
                var factor = currentFrame.factor;

                var x1, y1, z1;
                var x2, y2, z2;
                var x, y, z;
                for (var i = 0, len = positions1.length - 2; i < len; i += 3) {
                    x1 = positions1[i];
                    y1 = positions1[i + 1];
                    z1 = positions1[i + 2];
                    x2 = positions2[i];
                    y2 = positions2[i + 1];
                    z2 = positions2[i + 2];

                    if (typeof x1 === "number" && typeof y1 === "number" && typeof z1 === "number" &&
                        typeof x2 === "number" && typeof y2 === "number" && typeof z2 === "number") {
                        x = x1 + factor * (x2 - x1);
                        y = y1 + factor * (y2 - y1);
                        z = z1 + factor * (z2 - z1);

                        boundary.xmin = Math.min(boundary.xmin, x);
                        boundary.ymin = Math.min(boundary.ymin, y);
                        boundary.zmin = Math.min(boundary.zmin, z);
                        boundary.xmax = Math.max(boundary.xmax, x);
                        boundary.ymax = Math.max(boundary.ymax, y);
                        boundary.zmax = Math.max(boundary.zmax, z);
                    }

                }

                this.boundary = boundary;
                this.axisBoundary = new Human.math.AxisBox3(
                    [boundary.xmin, boundary.ymin, boundary.zmin],
                    [boundary.xmax, boundary.ymax, boundary.zmax]
                );
                this.center = [
                    (boundary.xmax + boundary.xmin) * 0.5,
                    (boundary.ymax + boundary.ymin) * 0.5,
                    (boundary.zmax + boundary.zmin) * 0.5
                ];

                this._frameDirty = false;
            }
        };
        if (params.morphGeometry) {
            params.morphGeometry.type = "morphGeometry";
            morph.morphGeometry = libRoot.addNode(params.morphGeometry);
            morph.morphGeometry.on("update", function() {
                morph._frameDirty = true;
            });
        }

        morph.updateBoundary();

        var animation = new Human.assets.morphs.Animation();
        var keys = params.morphGeometry.keys;

        animation.addMorph(keys[0], keys[keys.length - 1],
            function (factor) {
                morph.morphGeometry.setFactor(factor);
            });

        animation.calculateTimeFrame();

        Human.timeline.addAnimation(morphId, animation);

        var stateId = morphId.split("/")[0];
        var leaf = Human.timeline.leafTimelines[stateId] || new Human.timeline.LeafTimeline(stateId);

        leaf.addAnimation(morphId, animation); // add to leaf

        HumanAssetsMorphs.morphs[morphId] = morph;
        return morph;
    };

    /**
     * Destroys a morph library
     * @param libraryId
     */
    HumanAssetsMorphs.destroyAsset = function (morphId) {
        if (morphId) {
            var morph = HumanAssetsMorphs.morphs[morphId];
            if (!morph) {
                Human.log.warn("Human.assets.morphs.destroyMorph", "Morph not found: " + morphId);
                return;
            }
            morph.morphGeometry.destroy(); // Blow away scene subgraph

            delete HumanAssetsMorphs.morphs[morphId];
        } else {
            HumanAssetsMorphs.reset();
        }
    };

    /** Destroys all morph libraries
     */
    HumanAssetsMorphs.reset = function () {
        for (var morphId in HumanAssetsMorphs.morphs) {
            if (HumanAssetsMorphs.morphs.hasOwnProperty(morphId)) {
                HumanAssetsMorphs.destroyAsset(morphId);
            }
        }
    };

})();
;(function() {
    "use strict";

    /**
     * An animation comprised of a set of morphs, which may be installed into the {@link Human.timeline}.
     * Like all such animations, it has an {@link #update} method through which the timeline updates the
     * progress of the morphs. The morphs each contain a {@link SceneJS.MorphGeometry} and possibly
     * a {@link SceneJS.Geometry}, which are kept externally in a {@link Human.assets.morphs}.
     *
     * @class
     * @constructor
     * @private
     */
    Human.assets.morphs.Animation = function (cfg) {
        cfg = cfg || {};

        this.type = "morph-animation";
        this._loop = (cfg.loop !== false);
        this._morphList = [];
        this.timeline = cfg.timeline;
        this.firstTime = null;
        this.lastTime = null;
    };

    /**
     * Adds a morph to this animation
     * @param firstTime First time key
     * @param lastTime Last time key
     * @param update Callback to update the morph progress
     */
    Human.assets.morphs.Animation.prototype.addMorph = function (firstTime, lastTime, update) {
        this._morphList.push({ firstTime:firstTime, lastTime:lastTime, update:update  });
    };

    /**
     * Calculates time frame enclosing keys of all contained morphs
     * @return {*}
     */
    Human.assets.morphs.Animation.prototype.calculateTimeFrame = function () {
        var min = 1000000;
        var max = -1000000;
        var morph;
        var morphList = this._morphList;
        for (var i = 0, len = this._morphList.length; i < len; i++) {
            morph = morphList[i];
            if (morph.firstTime < min) {
                min = morph.firstTime;
            }
            if (morph.lastTime > max) {
                max = morph.lastTime;
            }
        }

        this.firstTime = min;
        this.lastTime = max;
    };

    /**
     * Updates progress of morphs
     * @param ctx
     * @param time
     */
    Human.assets.morphs.Animation.prototype.update = function (ctx, time) {
        var morph;
        var time2;
        for (var i = 0, len = this._morphList.length; i < len; i++) {
            morph = this._morphList[i];
            if (this._loop) {
                // Dont wrap when time is right on the last key
                time2 = (time === morph.lastTime) ? time : (morph.firstTime + time % (morph.lastTime - morph.firstTime));
            } else {
                if (time2 < morph.firstTime) {
                    time2 = morph.firstTime;
                }
                if (time2 > morph.lastTime) {
                    time2 = morph.lastTime;
                }
            }
            morph.update(time2);
        }
    };

    /**
     * Destroys this module
     */
    Human.assets.morphs.Animation.prototype.destroy = function () {
        this.destroyed = true;
    };
})();

;(function () {
    "use strict";

    /**
     * @namespace Loads and unloads lights to and from {@link Human.view.lights}.
     *
     * Loads lights in batches for models (states). When loading a batch, will immediately enable those lights, then
     * push a record of those lights onto a stack.
     *
     * After unloading a batch of lights for a model, will remove that batch from the stack, then
     * enable the batch (if any) that remains on the top of the stack.
     *
     * @private
     */
    var lightAssets = Human.assets.lights = {};

    // Array of light IDs for each library, used for unloading
    var libLightIds = {};

    /**
     * Loads a library of light sources
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    lightAssets.parseLibrary = function (libId, manifest, params, ok) {

        var lightIds = libLightIds[libId];

        if (lightIds) {
            // Should have hit cache at higher level
            Human.log.warn("Human.assets.lights.parseLibrary", "library already loaded");
            ok();
            return;
        }

        var lights = manifest.lights;

        if (!lights) {
            Human.log.error("Human.assets.lights.parseLibrary", "'lights' section expected in lights library");
            ok();
            return;
        }

        lightIds =  [];
        libLightIds[libId] = lightIds;

        // Disable any lights already enabled
        Human.view.lights.clearEnabled();

        var light;
        var lightId;

        for (var i = 0, len = lights.length; i < len; i++) {

            light = lights[i];

            if (!light.lightId) {

                // Skip invalid light
                Human.log.error("Human.assets.lights.load", "'lightId' missing on light");
                ok();
                continue;
            }

            lightId = libId + "." + light.lightId;

            light.lightId = lightId;
            light.enabled = true;

            Human.view.lights.addLight(light);

            lightIds.push(lightId);
        }

        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a lights library.
     *
     * @param libId ID of lights library to unload.
     */
    lightAssets.unloadLibrary = function (libId) {

        var lightIds = libLightIds[libId];

        if (!lightIds) {
            Human.log.warn("Human.assets.lights.unloadLibrary", "library not loaded");
            return;
        }

        var i;
        var len;
        var lights = Human.view.lights;

        for (i = 0, len = lightIds.length; i < len; i++) {
            lights.removeLight(lightIds[i]);
        }

        delete libLightIds[libId];
    };
})();
;(function() {
    "use strict";

    var tweenAssets = Human.assets.tweens = {};

    /**
     * Loads a tweens library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    tweenAssets.parseLibrary = function (libId, manifest, params, ok) {
        var tweenDefs = manifest.tweens || {};
        var tweenDef;
        var type;
        var tweenType;
        var controlType;
        var tokens;
        var control;
        var tween;
        var tweens = [];

        var modelId = libId.split("/")[0];
        var leaf;

        if (!Human.timeline.leafTimelines.hasOwnProperty(modelId)){
            leaf = new Human.timeline.LeafTimeline(modelId);
        }

        for (var tweenName in tweenDefs) {
            if (tweenDefs.hasOwnProperty(tweenName)) {

                tweenDef = tweenDefs[tweenName];

                // Validate tween data

                if (!tweenDef.keys) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'keys'");
                    continue;
                }

                if (!tweenDef.targets) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'targets'");
                    continue;
                }

                if (tweenDef.keys.length < 2 || tweenDef.targets.length < 2) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "tween has insufficient keys or targets - minimum of two required");
                    continue;
                }

                if (tweenDef.keys.length !== tweenDef.targets.length) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "tween has mismatching numbers of keys and targets");
                    continue;
                }

                tweenDef.options = Human.utils.applyIf(this.options, tweenDef.options || {});

                type = tweenDef.type;

                if (!type) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'type'");
                    continue;
                }

                tokens = type.split(":");

                tweenType = tokens[0];
                controlType = tokens[1];

                if (tweenType === "lerp") {
                    tweenType = "tween";
                }

                if (!tweenType || !controlType) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute invalid: 'type'");
                    continue;
                }

                // Create control strategy

                switch (controlType) {

                    // Tween attributes of a scene object

                    case "objectAttr":
                        control = new Human.timeline.ObjectControl({
                            modelId: modelId,
                            objectId: getAbsoluteID(modelId, tweenDef.objectId || tweenDef.targetId)
                        });
                        break;

                    // Tween attributes of a transform via a scene object

                    case "objectXForm":
                        control = new Human.timeline.ObjectTransformControl({
                            modelId: modelId,
                            objectId: getAbsoluteID(modelId, tweenDef.objectId || tweenDef.targetId),
                            initial: tweenDef.targets[0]
                        });
                        break;

                    // Tween attributes of a transform directly

                    case "transform":
                        control = new Human.timeline.TransformControl({
                            modelId: modelId,
                            transformId: getAbsoluteID(modelId, tweenDef.transformId || tweenDef.targetId),
                            initial: tweenDef.targets[0]
                        });
                        break;

                    // Tween attributes of a material

                    case "material":
                        control = new Human.timeline.MaterialControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId || tweenDef.targetId)
                        });
                        break;

                    // Tween attributes of a material's texture

                    case "texture":
                        control = new Human.timeline.TextureControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId || tweenDef.targetId),
                            targetLayer: tweenDef.targetLayer
                        });
                        break;

                    // Tween camera

                    case "camera":
                        control = new Human.timeline.CameraControl();
                        break;

                    default:
                        Human.log.error("Human.timeline.tweenAnimationLoader", "Unsupported tween type: " + type);
                        continue;
                }

                // Create tween

                switch (tweenType) {

                    case "tween":
                        tween = new Human.timeline.Tween({
                            keys: tweenDef.keys,
                            targets: tweenDef.targets,
                            control: control
                        });
                        break;

                    case "switch":
                        tween = new Human.timeline.Switch({
                            keys: tweenDef.keys,
                            targets: tweenDef.targets,
                            control: control
                        });
                        break;

                    default:
                        Human.log.error("Human.timeline.tweenAnimationLoader", "Unsupported tween type: " + type);
                        continue;
                }

                tweens.push(tween);
            }
        }

        if (tweens.length > 0) {

            // Create tween animation
            // Only if we have valid tweens

            var animation = new Human.timeline.TweenAnimation({
                tweens: tweens
            });

            // Add to timeline

            Human.timeline.addAnimation(libId, animation);
        }

        leaf = Human.timeline.leafTimelines[modelId];
        leaf.addAnimation(libId, Human.timeline.animations[libId]); // add to leaf

        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a tweens library.
     *
     * @param libId ID of library to unload.
     */
    tweenAssets.unloadLibrary = function() {
        // No-op
    };

    /**
     * Converts an ID to an absolute ID if necessary.
     *
     * If the element ID has no "." then it is the relative ID of an element
     * within the given model. Otherwise, it will be the absolute ID of element
     * in another model.
     */
    function getAbsoluteID(modelId, elementId) {
        return (elementId.indexOf(".") < 0) ? modelId + "-" + elementId : elementId;
    }

})();
;/**
 * @namespace Reflection libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsReflections = Human.assets.reflections = {};

    // Array of reflection IDs for each library, used for unloading
    var libReflectionIds = {};

    /**
     * All reflections
     */
    HumanAssetsReflections.reflections = {};

    /**
     * Reflection IDs exported by #exportReflectionIds; a map of exported IDs to real asset IDs
     *
     * @type {{String:String}}
     * @deprecated
     */
    HumanAssetsReflections.exportedReflectionIds = {};

    // Holds all SceneJS nodes for reflections
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Reflections library" // For debugging
            });
        });

    /**
     * Loads a reflections library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    HumanAssetsReflections.parseLibrary = function (libId, manifest, params, ok) {

        var reflectionIds = libReflectionIds[libId];

        if (reflectionIds) {

            // Should have hit cache at higher level
            Human.log.warn("Human.assets.reflections.parseLibrary", "library already loaded");

            ok();
            return;
        }

        reflectionIds = [];
        libReflectionIds[libId] = reflectionIds;

        var parts = libId.split("/");
        var imagePath = "content/states/" + parts[0] + "/reflections/" + parts[1] + "/";
        var reflectionParams;
        var srcList;
        var reflectionId;
        var reflection;

        var graph = Human.renderer.graph;

        for (var key in manifest) {
            if (manifest.hasOwnProperty(key)) {

                reflectionParams = manifest[key];

                reflectionParams.type = "reflect";
                reflectionParams.blendMode = reflectionParams.blendMode || "add";

                srcList = reflectionParams.src;

                if (!srcList) {
                    Human.log.error("Human.assets.reflections.loader", "Reflection property missing: src");
                    continue;
                }

                if (!Human.utils.isArray(srcList)) {
                    Human.log.error("Human.assets.reflections.loader", "Reflection property should be array: src");
                    continue;
                }

                for (var i = 0, len = srcList.length; i < len; i++) {
                    srcList[i] = imagePath + srcList[i] + "?v=" + Human.VERSION;
                }

                reflectionId = libId + "." + key;

                reflection = {
                    node: graph.insertNode(graph.rootNodes.library, reflectionParams)
                };

                HumanAssetsReflections.reflections[reflectionId] = reflection;

                reflectionIds.push(reflectionId);
            }
        }

        // Subsequently-loaded materials will need our reflections to exist, so render a frame
        // to force the creation of the reflections' nodes in the scene graph
        Human.renderer.compile();

        if (ok) {
            ok();
        }
    };

    /** Only once reflections are activated and mapped to names can they be used
     * <p>Enable materials to use a particular reflection when they have a "reflectionId" set to "myReflection":</p>
     * <pre>
     *     #exportReflections({
     *          "myReflection" : "someState.someReflectionLib.someReflectionId"
     *          });
     * </pre>
     *
     * @param mapping
     */
    HumanAssetsReflections.exportReflections = function (mapping) {
        mapping = mapping || {};

        for (var key in mapping) {
            if (mapping.hasOwnProperty(key)) {
                var value = mapping[key];
                if (value.indexOf("/") === -1) {
                    mapping[key] = value.replace(/^([^\.]+)\./, "$1/");
                }
            }
        }

        HumanAssetsReflections.exportedReflectionIds = mapping || {};
    };

    /**
     * Unloads a reflections library.
     *
     * @param libId ID of reflections library to unload.
     */
    HumanAssetsReflections.unloadLibrary = function (libId) {

        var reflectionIds = libReflectionIds[libId];

        if (!reflectionIds) {
            Human.log.warn("Human.assets.reflections.unloadLibrary", "library not loaded");
            return;
        }

        var i;
        var len;
        var reflectionId;
        var reflection;

        for (i = 0, len = reflectionIds.length; i < len; i++) {
            reflectionId = reflectionIds[i];
            reflection = HumanAssetsReflections.reflections[reflectionId];
            reflection.node.destroy();
        }

        delete libReflectionIds[libId];
    };
})();
;(function () {

    "use strict";

    /**
     * @namespace Loads and unloads skyboxes, manages their activation and deactivation.
     *
     * @private
     */
    var skyboxAssets = Human.assets.skyboxes = {};

    /**
     * Reflection IDs exported by #exportSkyboxIds; a map of exported IDs to real asset IDs
     *
     * @type {{String:String}}
     * @deprecated
     */
    skyboxAssets.exportedSkyboxIds = {};

    /**
     * ID of the currently active skybox.
     *
     * @type {String}
     */
    skyboxAssets.activeSkyboxId = null;


    // Loaded skyboxes - these are params objects, not SceneJS nodes
    var skyboxes = {};

    // SceneJS.Skybox node for the currently active skybox
    var activeSkyboxNode = null;

    // A list of skybox IDs for each library, for unloading libraries
    var libSkyboxIds = {};


    Human.events.on("loaded", function () {

        // The 'skyboxes.activeSkybox' property dynamically selects the
        // currently active skybox.

        // A chapters can activate a skybox by setting this property.

        Human.properties.subscribe({
            propId: "skyboxes.activeSkybox",
            callback: function (value) {

                if (value && Human.utils.isString(value)) {

                    var skyboxId = value;

                    skyboxAssets.activateSkybox(skyboxId);
                } else {
                    skyboxAssets.deactivateSkybox();
                }
            }
        });
    });

    /**
     * Loads a skyboxes library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    skyboxAssets.parseLibrary = function (libId, manifest, params, ok) {

        var skyboxIds = libSkyboxIds[libId];

        if (skyboxIds) {
            Human.log.warn("Human.assets.skyboxes.parseLibrary", "Skybox library already loaded: " + libId);
            ok();
            return;
        }

        skyboxIds = [];
        libSkyboxIds[libId] = skyboxIds;

        var parts = libId.split("/");
        var imagePath = "content/states/" + parts[0] + "/skyboxes/" + parts[1] + "/";

        var cfg;
        var skybox;
        var skyboxId;

        var preloads = [];

        for (var id in manifest) {
            if (manifest.hasOwnProperty(id)) {

                cfg = manifest[id];

                if (!cfg.src) {
                    Human.log.error("Human.assets.skyboxes.parseLibrary", "'src' missing on skybox");
                    ok();
                    continue;
                }

                skyboxId = libId + "." + id;

                skybox = {
                    cfg: {
                        type: "skybox",
                        src: imagePath + cfg.src + "?v=" + Human.VERSION,
                    },
                    image: null // Preloaded image
                };

                preloads.push(skybox);

                skyboxes[skyboxId] = skybox;

                skyboxIds.push(skyboxId);
            }
        }

        // Preload skybox images

        var numToLoad = 0;

        function loaded() {
            if (--numToLoad === 0) {
                ok();
            }
        }

        for (var i = 0, len = preloads.length; i < len; i++) {
            numToLoad++;
            skybox = preloads[i];
            skybox.image = new Image();
            skybox.image.onload = loaded;
            skybox.image.src = skybox.cfg.src;
        }

        if (numToLoad === 0 && ok) {
            ok();
        }
    };

    /**
     * Creates a mapping of "symbolic" IDs to real skybox asset IDs.
     *
     * <pre>
     *
     *     // Export some IDs:
     *
     *     #exportSkyboxes({
     *              "foo" : "someState.someSkyboxLib.someSkyboxId1",
     *              "bar" : "someState.someSkyboxLib.someSkyboxId2"
     *          });
     *
     *     // Then we can activate a skybox using its exported ID:
     *
     *     #activateSkybox( #exportedSkyboxIds["foo"] );
     *
     * </pre>
     *
     * @param {{String: String}} mapping Map of exported IDs to real IDs
     * @deprecated
     */
    skyboxAssets.exportSkyboxes = function (mapping) {

        skyboxAssets.exportedSkyboxIds = {}; // Assume only one set of exports at a time

        mapping = mapping || {};
        var skyboxId;

        for (var exportedId in mapping) {
            if (mapping.hasOwnProperty(exportedId)) {

                skyboxId = mapping[exportedId];

                if (skyboxId.indexOf("/") === -1) {
                    skyboxAssets.exportedSkyboxIds[exportedId] = skyboxId.replace(/^([^\.]+)\./, "$1/");
                }
            }
        }
    };

    /**
     * Activates a skybox.
     *
     * You can activate a skybox by its exported ID like this:
     *
     * <pre>
     *     #activateSkybox( #exportedSkyboxIds["foo"] );
     * </pre>
     *
     * @param {String} skyboxId ID of skybox to activate
     */
    skyboxAssets.activateSkybox = function (skyboxId) {

        if (!skyboxId) {

            // No ID means deactivate current skybox

            this.deactivateSkybox();
            return;
        }

        var skybox = skyboxes[skyboxId];

        if (!skybox) {
            Human.log.warn("Human.assets.skyboxes.activateSkybox", "Skybox not found: " + skyboxId);
            return;
        }

        // Deactivate current skybox

        this.deactivateSkybox();

        // Activate new skybox by creating its node in the scene graph

        activeSkyboxNode = Human.renderer.graph.insertNode(Human.renderer.graph.rootNodes.skybox, skybox.cfg);

        skyboxAssets.activeSkyboxId = skyboxId;
    };

    /**
     * Deactivates whatever skybox is currently active.
     */
    skyboxAssets.deactivateSkybox = function () {

        if (activeSkyboxNode) {

            // Extract node from scene graph and destroy it

            activeSkyboxNode.splice(); // Attaches children to parent
            activeSkyboxNode.destroy();

            activeSkyboxNode = null;

            skyboxAssets.activeSkyboxId = null;
        }
    };

    /**
     * Destroys a skybox library.
     * If one of the skyboxes in the library is active, deactivates it.
     */
    skyboxAssets.unloadLibrary = function (libId) {

        var skyboxIds = libSkyboxIds[libId];

        if (!skyboxIds) {
            Human.log.warn("Human.assets.skyboxes.unloadLibrary", "Skybox library not found: " + libId);
            return;
        }

        var i;
        var len;
        var skyboxId;
        var activeSkyboxId = skyboxAssets.activeSkyboxId;

        for (i = 0, len = skyboxIds.length; i < len; i++) {

            skyboxId = skyboxIds[i];

            if (activeSkyboxId === skyboxId) {
                skyboxAssets.deactivateSkybox();
            }

            delete skyboxes[skyboxId];
        }

        delete libSkyboxIds[libId];
    };

})();
;(function() {
    "use strict";

    var objectSets = [
        "showObjects",
        "selectObjects",
        "pickThroughObjects",
        "transparentObjects",
        "desaturatedObjects",
        "backfaceObjects",
        "objectGlassFactors",
        "objectMurkiness"
    ];

    /**

     *
     * @private
     */
    var chapterAssets = Human.assets.chapters = {};

    /**
     * Loads a chapters library
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    chapterAssets.parseLibrary = function(libId, manifest, params, ok) {
        var moduleId = params.moduleId;
        var modelId = libId.split("/")[0];
        var chapters = manifest.chapters;
        var chapterList = [];
        var chapter;
        var i;

        // Ensure chapters are in a list
        if (Human.utils.isArray(chapters)) {
            chapterList = chapters;
        } else {
            i = 0;
            for (var chapterId in chapters) {
                if (chapters.hasOwnProperty(chapterId)) {
                    chapter = chapters[chapterId];
                    chapterList.push(chapter);
                }
            }
        }

        /** Timing and Ordering Policy:
         * 1: If all chapter blocks have a "timelineMap" attribute, chapters
         *   are assumed to be in order.
         * 2: If not, all chapters must have a time attribute, with which to sort
         *   and create timelineMaps.
         * 3: Invalid chapter manifests will be rejected.
         */

        // Policy 1: Prefer use of timelineMaps
        var allHaveMaps = true;
        i = 0;
        while (allHaveMaps && i < chapterList.length) {
            chapter = chapterList[i];
            if (!chapter.hasOwnProperty("timelineMap")) {
                allHaveMaps = false;
            }
            i++;
        }

        // Policy 2: Use chapter times to sort.
        if (!allHaveMaps) {
            var allHaveTimes = true;
            i = 0;
            while (allHaveTimes && i < chapterList.length) {
                chapter = chapterList[i];
                if (!chapter.hasOwnProperty("time")) {
                    allHaveTimes = false;
                    Human.log.error("Human.timeline.chapterLoader", "all chapters must either have all 'time' attributes or 'timelineMap' attributes.");
                }
                i++;
            }

            // Order chapters based on time
            var compare = function(a, b) {
                if (a.time < b.time) {
                    return -1;
                }
                if (a.time > b.time) {
                    return 1;
                }
                return 0;
            };
            chapterList = chapterList.sort(compare);

            // Append time2 to each chapter and make timelineMap
            var time2;
            chapterList.forEach(function(chapter, idx) {
                // find time 2.
                if (idx < chapterList.length - 1) {
                    time2 = chapterList[idx + 1].time;
                } else {
                    var duration = chapter.duration;
                    if (!!duration) {
                        time2 = chapter.time + duration;
                    } else {
                        time2 = undefined;
                    }
                }

                // One timelinemap for all models required by module (even if model may not have any animations)
                chapter.timelineMap = [];
                Human.modules.modules[moduleId].modelIds.forEach(function(stateName) {
                    var tlm = {};
                    tlm.start = 0.0;
                    tlm.end = time2 - chapter.time;
                    tlm.data = {
                        "timeline": stateName,
                        "start": chapter.time,
                        "end": time2,
                        "fit": false,
                        "onEnd": "freeze"
                    };
                    chapter.timelineMap.push(tlm);
                });
            });

        }

        /** Backwards Compatibility:
         * Objects should be prefixed by the modelId.
         * If not prefixed, we assume they need current modelId as the prefix.
         */
        function ensureObjectIds(chapter, modelId) {
            objectSets.forEach(function(setid) {
                if (chapter.hasOwnProperty(setid)) {
                    for (var oid in chapter[setid]) {
                        if (chapter[setid].hasOwnProperty(oid)) {
                            if (oid.indexOf("-") < 0) {
                                var nid = modelId + "-" + oid;
                                chapter[setid][nid] = chapter[setid][oid];
                                delete chapter[setid][oid];
                            }

                        }
                    }
                }

            });
        }

        /** Backwards Compatibility:
         * also add state prefix to unprefixed objectIds in annotation block
         */
        function ensureObjectAnnotations(chapter, modelId) {
            if (chapter.hasOwnProperty("annotations")) {
                chapter.annotations.forEach(function(annotation) {
                    if (annotation.hasOwnProperty("objectId")) {
                        if (annotation.objectId.indexOf("-") < 0) {
                            annotation.objectId = modelId + "-" + annotation.objectId;
                        }
                    }
                });
            }
        }

        // Create Chapter ID and ensure chapter object-sets (overrides)
        chapterList.forEach(function(chapter, idx) {
            chapter.chapterId = libId + "_" + idx;
            ensureObjectIds(chapter, modelId);
            ensureObjectAnnotations(chapter, modelId);
        });

        Human.timeline.chapterList = chapterList;

        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a chapters library.
     *
     * @param libId ID of library to unload.
     */
    chapterAssets.unloadLibrary = function() {
        // No-op
    };

})();
;(function() {
    "use strict";

    /**
     * @namespace Loads and unloads audio to and from {@link Human.media.audio}.
     *
     * @private
     */
    var audioAssets = Human.assets.audio = {};

    /**
     * Loads an audio clips library
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    audioAssets.parseLibrary = function (libId, manifest, params, ok) {
        Human.media.audio.createLibrary(libId, manifest);
        if (ok) {
            ok();
        }
    };

    /**
     * Unloads an audio clips library
     * @param libId Library ID
     */
    audioAssets.unloadLibrary = function (libId) {
        Human.media.audio.destroyLibrary(libId);
    };

})();
;(function() {
    "use strict";

    /**
     * @namespace Loads and unloads video to and from {@link Human.media.video}.
     *
     * @private
     */
    var videoAssets = Human.assets.video = {};

    /**
     * Loads a video clips library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    videoAssets.parseLibrary = function (libId, manifest, params, ok) {
        Human.media.videos.createLibrary(libId, manifest);
        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a video clips library
     * @param libId Library ID
     */
    videoAssets.unloadLibrary = function (libId) {
        Human.media.videos.destroyLibrary(libId);
    };

})();
;/**
 @namespace Captures and restores engine state to and from JSON bookmark objects.

 */
(function () {
    "use strict";

    var HumanBookmarks = Human.bookmarks = {};

    var cameraProps = ['camera', 'flyTo', 'jumpTo'];

    /**
     * Captures the current engine state to a JSON bookmark object
     * <h4>Examples</h4>
     * <p>Capture everything:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture();
     * </pre>
     * <p>Capture just camera and view modes:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture({
     *         camera: true,
     *         view: true
     *     });
     * </pre>
     * <p>Capture everything but view modes:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture({
     *         view: false
     *     });
     * </pre>
     * @memberof Human.bookmarks
     * @param {{String: Boolean}} mask Mask which specifies what to capture in the bookmark
     * @param {Boolean} mask.modules Capture what modules are loaded?
     * @param {Boolean} mask.camera Capture camera state?
     * @param {Boolean} mask.modes Capture view modes?
     * @param {Boolean} mask.objects Capture scene object states?
     * @param {Boolean} mask.annotations Capture annotations?
     * @returns {{}} The JSON bookmark object
     */
    HumanBookmarks.capture = function (mask) {
        var bm = {
            engineVersion: Human.VERSION
        };
        if (masked(mask, "modules")) {
            bm.modules = {
                moduleLibs: captureModuleLibs(),
                activeModules: captureActiveModules()
            };
        }
        if (masked(mask, "camera")) {
            bm.camera = captureCamera();
        }
        if (masked(mask, "modes")) {
            bm.modes = captureViewModes();
        }
        if (masked(mask, "clips")) {
            bm.clips = captureCrossSections();
        }
        if (masked(mask, "objects")) {
            bm.objects = captureObjectStates();
        }
        if (masked(mask, "annotations")) {
            bm.annotations = captureAnnotations();
        }
        if (masked(mask, "timeline")) {
            bm.timeline = Human.timeline.getBookmark();
        }
        return bm;
    };

    function masked(mask, key) {
        if (!mask) {
            return true;
        }
        if (mask[key] === true) {
            return true;
        }
        if (mask[key] === false) {
            return false;
        }
        return false;
    }

    /**
     * Bookmarks which module libraries are currently loaded
     */
    function captureModuleLibs() {
        var obj = Human.modules.moduleLibs;
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    }

    /**
     * Bookmarks which modules are currently active
     */
    function captureActiveModules() {
        var modules = [];
        if (Human.modules.numActiveModules > 0) {
            var activeModules = Human.modules.activeModules;
            for (var moduleId in activeModules) {
                if (activeModules.hasOwnProperty(moduleId)) {
                    modules.push(moduleId);
                }
            }
        }
        return modules;
    }

    /**
     * Bookmarks current state of the camera
     * @return {Object}
     */
    function captureCamera() {
        return Human.view.camera.getLookAt();
    }

    /**
     * Bookmarks current view modes
     * @return {Object} Flag for each view mode, indicating whether or not its enabled
     */
    function captureViewModes() {
        return {
            dissect: Human.view.dissect.getEnabled(),
            highlight: Human.view.highlight.getEnabled(),
            isolate: Human.view.isolate.getEnabled(),
            labels: Human.view.labels.getEnabled(),
            xray: Human.view.xray.getEnabled(),
            singlePick: Human.view.pick.getSinglePickEnabled(),
            multiPick: Human.view.pick.getMultiPickEnabled()
        };
    }

    /**
     * Bookmarks current state of cross-section planes
     * @return {Object} Map containing state of each clip plane, mapped to the plane IDs
     */
    function captureCrossSections() {
        var clips = Human.view.clip.clips;
        var clip;
        var map = {};
        for (var clipId in clips) {
            if (clips.hasOwnProperty(clipId)) {
                clip = clips[clipId];
                map[clipId] = {
                    clipId: clip.clipId,
                    type: clip.type,
                    progress: clip.progress,
                    state: clip.state
                };
            }
        }
        return map;
    }

    /**
     * Bookmarks current visibility, selection and transparency states of scene objects
     * @return {Object} Map containing set of flags for each object
     */
    function captureObjectStates() {
        var map = {};
        var anatomy = Human.scene;
        var objects = anatomy.objects;
        var object, transform;
        var enabledObjects = anatomy.enabledObjects;
        var selectedObjects = anatomy.selectedObjects;
        var mapData;
        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                object = objects[objectId];
                mapData = null;

                // Only capture enabled leaf objects
                if (object.objects.length === 0 && enabledObjects[objectId]) {
                    mapData = mapData || {};

                    mapData.enabled = true;
                    mapData.selected = !!selectedObjects[objectId];

                    transform = captureTransformData(object);
                    if (transform) {
                        mapData.transform = transform;
                    }
                }
                if (mapData) {
                    map[objectId] = mapData;
                }
            }
        }
        return map;
    }

    function captureTransformData(object) {
        var mapTransform = {};

        if (object.pivot.x !== 0) {
            mapTransform.pivot = mapTransform.pivot || {};
            mapTransform.pivot.x = object.pivot.x;
        }
        if (object.pivot.y !== 0) {
            mapTransform.pivot = mapTransform.pivot || {};
            mapTransform.pivot.y = object.pivot.y;
        }
        if (object.pivot.z !== 0) {
            mapTransform.pivot = mapTransform.pivot || {};
            mapTransform.pivot.z = object.pivot.z;
        }

        if (object.translate.x !== 0) {
            mapTransform.translate = mapTransform.translate || {};
            mapTransform.translate.x = object.translate.x;
        }
        if (object.translate.y !== 0) {
            mapTransform.translate = mapTransform.translate || {};
            mapTransform.translate.y = object.translate.y;
        }
        if (object.translate.z !== 0) {
            mapTransform.translate = mapTransform.translate || {};
            mapTransform.translate.z = object.translate.z;
        }

        if (object.scale.x !== 1) {
            mapTransform.scale = mapTransform.scale || {};
            mapTransform.scale.x = object.scale.x;
        }
        if (object.scale.y !== 1) {
            mapTransform.scale = mapTransform.scale || {};
            mapTransform.scale.y = object.scale.y;
        }
        if (object.scale.z !== 1) {
            mapTransform.scale = mapTransform.scale || {};
            mapTransform.scale.z = object.scale.z;
        }

        if (object.rotate.x !== 0) {
            mapTransform.rotate = mapTransform.rotate || {};
            mapTransform.rotate.x = object.rotate.x;
        }
        if (object.rotate.y !== 0) {
            mapTransform.rotate = mapTransform.rotate || {};
            mapTransform.rotate.y = object.rotate.y;
        }
        if (object.rotate.z !== 0) {
            mapTransform.rotate = mapTransform.rotate || {};
            mapTransform.rotate.z = object.rotate.z;
        }

        if (Object.keys(mapTransform).length > 0) {
            return mapTransform;
        } else {
            return null;
        }
    }

    /** Bookmarks current annotations
     * @return {Array} List containing a set of properties for each annotation
     */
    function captureAnnotations() {
        var list = [];
        var annotations = Human.view.annotations.annotations;
        var annotation;
        var item;
        var slice = Array.prototype.slice;
        for (var annotationId in annotations) {
            if (annotations.hasOwnProperty(annotationId)) {
                annotation = annotations[annotationId];
                if (annotation.saved) {
                    item = {
                        annotationId: annotationId,
                        title: annotation.label.title,
                        description: annotation.label.description,
                        pos: slice.call(annotation.pin.pos),
                        pinVec: slice.call(annotation.pin.dir),
                        shown: annotation.pin.shown,
                        labelShown: annotation.label.shown,
                        labelOffset: slice.call(annotation.label.offset),
                        occludable: annotation.occludable,
                        primitiveIndex: annotation.pin.primitiveIndex,
                        barycentric: annotation.pin.barycentric
                    };
                    if (annotation.object) {
                        item.objectId = annotation.object.objectId;
                    }
                    list.push(item);
                }
            }
        }
        return list;
    }

    HumanBookmarks.restore = function(bookmark, ok) {
        Human.events.fire("bookmarks.restoring");

        // We have an oldie
        if(!Human.utils.isObject(bookmark.modules)) {
            normalizeLegacy(bookmark);
        }

        Human.view.annotations.clearAnnotations();

        var activeModules = bookmark.modules.activeModules;
        var multipleModules = activeModules.length > 1;

        var showObjects = buildShowObjects(bookmark.objects);

        var activeModulesClone = [];

        for (var i = 0, len = activeModules.length; i < len; i++) {
            activeModulesClone[i] = Human.modules.convertBaseAnatomyModuleId(activeModules[i]);
        }

        Human.utils.filterInPlace(activeModulesClone, function(moduleId) {
            if (Human.modules.activeModules[moduleId]) {
                return false;
            }

            if (multipleModules && Human.modules.isBaseModule(moduleId)) {
                return false;
            }

            return true;
        });

        Human.renderer.pushPause();
        Human.renderer.pauseCompilation();

        activateModules(activeModulesClone, showObjects, function() {
            var objects = [];
            var objectId;

            for (objectId in showObjects) {
                if(showObjects.hasOwnProperty(objectId) && Human.scene.objects[objectId]) {
                    objects.push(Human.scene.objects[objectId]);
                } else {
                    Human.log.error("Bookmark showObject not found: " + objectId);
                }
            }

            Human.timeline.cancelCameraInit();
            Human.timeline.cancelAnnotationInit();

            Human.scene.graph.attachAssetSetsToSubtree(objects, function (typesLoaded, i, done) {
                try {

                    if(typesLoaded.material) {
                        Human.timeline.initTransparencies();
                    }

                    if (i === 0) {
                        Human.timeline.initScene();
                        Human.view.lights.compile();
                        Human.view.effects.compile();
                        Human.renderer.resumeCompilation();
                        Human.renderer.compile();
                        restoreUserState(bookmark);
                        restoreCamera(bookmark, function() {
                            // jshint camelcase: false
                            if (bookmark.annotations) {
                                restoreAnnotations(bookmark.annotations, bookmark.is_owner);
                            }
                        });
                        Human.renderer.popPause();
                    }

                    // This needs to happen after geometry loads so the boundary
                    // box can be properly calculated.

                    if (typesLoaded.geometry && bookmark.clips) {
                        restoreCrossSections(bookmark.clips);
                    }

                    if(typesLoaded.morph) {
                        Human.timeline.addMorphs(
                            Object.keys(
                                Human.assets.morphs.morphs
                            )
                        );
                    }

                    if (done) {
                        playTimeline(bookmark);
                        Human.events.fire("bookmarks.restored", bookmark);
                        if(ok) {
                            ok();
                        }
                    }
                } catch (e) {
                    Human.log.error("Bookmark restore scene initialization error: " + e.message);
                    Human.renderer.resumeCompilation();
                    Human.renderer.popPause();
                }
            }, function() {
                // Module activation error
                Human.renderer.resumeCompilation();
                Human.renderer.popPause();
            });
        });
    };

    //////////////////////////////////////////////////////
    // HANDLE LEGACY BOOKMARKS
    //////////////////////////////////////////////////////

    function normalizeLegacy(bookmark) {
        bookmark.modules = {};
        bookmark.modules.activeModules = [];
        bookmark.modules.moduleLibs = [];

        if(!Human.utils.isObject(bookmark.objects)) {
            bookmark.objects = {};
        }

        var genderModuleId = getGenderModule(bookmark.objects);

        if(genderModuleId) {
            bookmark.modules.activeModules.unshift(genderModuleId);
        }
    }

    function getGenderModule(objects) {
        var genderModuleId = null;
        var match;

        for (var id in objects) {
            if(objects.hasOwnProperty(id)) {
                match = id.match(/^(fe)?maleAdult/);
                if(match) {
                    genderModuleId = ['production', match[0], match[0] + '.json']
                    .join('/');

                    break;
                }
            }
        }

        return genderModuleId;
    }

    //////////////////////////////////////////////////////

    function buildShowObjects(objectIds) {
        var showObjects = {};
        var objectId, object;

        for (objectId in objectIds) {
            if(objectIds.hasOwnProperty(objectId)) {
                object = objectIds[objectId];

                if(object.enabled) {
                    objectId = Human.modules.convertBaseAnatomyObjectId(objectId);

                    showObjects[objectId] = true;
                }
            }
        }

        return showObjects;
    }

    function activateModules(moduleIds, showObjects, ok, error) {

        var numModules = moduleIds.length;

        if (numModules === 0) {
            ok();
            return;
        }

        function done() {
            if (--numModules === 0) {
                ok();
            }
        }

        // Expecting only one module here
        for(var i = 0, len = numModules; i < len; i++) {
            var moduleId = moduleIds[i];
            var requiredBase = null;

            // Ensure base state gets loaded if required
            if(!Human.modules.isBaseModule(moduleId)) {
                requiredBase = Human.modules.requiresBase(Object.keys(showObjects));
            }

            Human.modules.activateModules({
                moduleId: moduleId,
                extensions: requiredBase && { showObjects: showObjects }
            }, done, error);
        }
    }

    function restoreUserState(index, legacy) {

        if (index.objects) {
            restoreObjectStates(index.objects, legacy);
        }

        if (index.modes) {
            restoreModes(index.modes);
        }
    }

    function playTimeline(bookmark) {
        if (!bookmark.timeline) {
            Human.timeline.stop();
            return;
        }
        if (bookmark.timeline.scrub) {
            Human.timeline.scrub(bookmark.timeline.scrub);
        } else if (bookmark.timeline.play) {
            Human.timeline.play(bookmark.timeline.play);
        }
    }

    /**
     * Loads camera position as given in bookmark
     * @param camera
     */
    function restoreCamera(index, ok) {
        var camera, cameraProp, action;

        for (var i = 0; i < cameraProps.length; i++) {
            cameraProp = cameraProps[i];

            if(Human.utils.isObject(index[cameraProp])) {
                action = cameraProp;

                if(action === 'camera') {
                    action = 'jumpTo';
                }

                camera = index[cameraProp];
                break;
            }
        }

        if(action && camera) {
            Human.view.camera.fly[action]({
                up: Human.utils.apply(camera.up, { x: 0, y: 1, z: 0 }),
                eye: Human.utils.apply(camera.eye, { x: 0, y: 0, z: -100 }),
                look: Human.utils.apply(camera.look, { x: 0, y: 0, z: 0 })
            }, ok);
        } else if (ok) {
            ok();
        }
    }

    /**
     * Loads viewing modes as given in bookmark
     * @param modes Flag for each view mode, indicating enable or disable
     */
    function restoreModes(modes) {
        // Activate view modes via commands because those
        // handle all the mutual exclusivity of the various modes
        if (modes.dissect !== undefined && modes.dissect !== null) {
            //   Human.rpc.call(null, "dissect.setEnabled", { enable: modes.dissect });
        }
        if (modes.highlight !== undefined && modes.highlight !== null) {
            Human.rpc.call(null, "highlight.setEnabled", { enable: modes.highlight });
        }
        // Only enable isolate if objects are selected
        if (Human.scene.anySelected() && modes.isolate) {
            if (modes.isolate !== undefined && modes.isolate !== null) {
                Human.rpc.call(null, "isolate.setEnabled", { enable: modes.isolate  });
            }
        } else {
            if (modes.isolate !== undefined && modes.isolate !== null) {
                Human.rpc.call(null, "isolate.setEnabled", { enable: false  });
            }
        }
        if (modes.labels !== undefined && modes.labels !== null) {
            Human.rpc.call(null, "labels.setEnabled", { enable: modes.labels });
        }
        if (modes.singlePick !== undefined && modes.singlePick !== null) {
            Human.rpc.call(null, "pick.single.setEnabled", { enable: modes.singlePick });
        }
        if (modes.multiPick !== undefined && modes.multiPick !== null) {
            Human.rpc.call(null, "pick.multi.setEnabled", { enable: modes.multiPick });
        }
        if (modes.xray !== undefined && modes.xray !== null) {
            Human.rpc.call(null, "xray.setEnabled", { enable: modes.xray });
        }
    }

    /**
     * Loads cross-section clip plane states as given in bookmark
     * @param clips Clip plane states, mapped to IDs of the planes
     */
    function restoreCrossSections(clips) {
        Human.view.clip.reset();
        for (var clipId in clips) {
            if (clips.hasOwnProperty(clipId)) {
                Human.view.clip.setClip(clips[clipId]);
            }
        }
    }

    /**
     * Loads states of scene objects as given in bookmark
     * @param objects
     * @param legacy
     */
    function restoreObjectStates(objects, legacy) {
        // We only need to restore those states that can be modified through
        // user interaction. The modules themselves will take care of the other
        // types of object states on module activation, and those state types
        // can't be subsequently modified by the user.
        restoreObjectVisibilities(objects, legacy);
        restoreObjectSelection(objects, legacy);
        restoreObjectTransforms(objects);
    }

    /**
     * Loads visibility states of scene objects as given in bookmark
     * @param objects
     * @param legacy Replaces set of visible objects when true
     */
    function restoreObjectVisibilities(objects, legacy) {
        Human.scene.setEnabledObjects({ objectIds: getObjectFlags(objects, "enabled"), replace: !legacy });
    }

    /**
     * Loads selection states of scene objects as given in bookmark
     * @param objects
     * @param legacy Replaces set of selected objects when true
     */
    function restoreObjectSelection(objects, legacy) {
        Human.scene.setSelectedObjects({ objectIds: getObjectFlags(objects, "selected"), replace: !legacy });
    }

    function restoreObjectTransforms(objectData) {
        objectData = objectData || {};
        var object, objectId, transform;

        for (objectId in objectData) {
            if (objectData.hasOwnProperty(objectId)) {
                object = Human.scene.objects[objectId];
                transform = objectData[objectId].transform;
                if (object && transform) {
                    object.setTransform(restoreTransform(object, transform));
                }
            }
        }
    }

    function restoreTransform(object, transform) {
        transform.pivot = transform.pivot || {};
        transform.translate = transform.translate || {};
        transform.scale = transform.scale || {};
        transform.rotate = transform.rotate || {};

        transform.pivot.x = transform.pivot.x === undefined ? object.pivot.x : transform.pivot.x;
        transform.pivot.y = transform.pivot.y === undefined ? object.pivot.y : transform.pivot.y;
        transform.pivot.z = transform.pivot.z === undefined ? object.pivot.z : transform.pivot.z;

        transform.translate.x = transform.translate.x === undefined ? object.translate.x : transform.translate.x;
        transform.translate.y = transform.translate.y === undefined ? object.translate.y : transform.translate.y;
        transform.translate.z = transform.translate.z === undefined ? object.translate.z : transform.translate.z;

        transform.scale.x = transform.scale.x === undefined ? object.scale.x : transform.scale.x;
        transform.scale.y = transform.scale.y === undefined ? object.scale.y : transform.scale.y;
        transform.scale.z = transform.scale.z === undefined ? object.scale.z : transform.scale.z;

        transform.rotate.x = transform.rotate.x === undefined ? object.rotate.x : transform.rotate.x;
        transform.rotate.y = transform.rotate.y === undefined ? object.rotate.y : transform.rotate.y;
        transform.rotate.z = transform.rotate.z === undefined ? object.rotate.z : transform.rotate.z;

        return transform;
    }

    function getObjectFlags(objects, flagName) {
        var flags = {};
        var value;
        objects = objects || {};
        var object;
        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                object = Human.scene.objects[Human.modules.convertBaseAnatomyObjectId(objectId)];
                if (!object) {
                    // Objects in bookmark will not exist if they were
                    // skipped in the stream data, which is OK.
                    continue;
                }
                value = objects[objectId][flagName];
                if (value === true || value === false) {
                    flags[object.objectId] = value;
                }
            }
        }
        return flags;
    }

    /**
     * Loads annotations as given in bookmark
     * @param annotations List of property sets, one for each annotation
     */
    function restoreAnnotations(annotations, isOwner) {
        var a;

        isOwner = (typeof isOwner === 'undefined') ? false : isOwner;

        for (var i = 0, len = annotations.length; i < len; i++) {
            a = annotations[i];
            Human.view.annotations.createAnnotation({
                annotationId: a.annotationId,
                objectId: a.objectId,
                title: a.title || "",
                description: a.description || "",
                pos: a.offset || a.pos,
                dir: a.pinVec,
                shown: a.shown,
                type: a.type,
                labelShown: a.labelShown,
                labelOffset: a.labelOffset,
                saved: true,
                isOwner: isOwner,
                occludable: a.occludable,
                primitiveIndex: a.primitiveIndex,
                barycentric: a.barycentric
            });
        }
    }

})();
;/**
 @namespace Handles module creation, activation, deactivation, destruction and query.

 <p>Modules are the engine's abstract unit of content. These are extensible and can be all sorts things, such as anatomies,
 disease conditions, guided tours, bookmarks, medline conditions etc.</p>
 */
(function () {
    "use strict";

    var HumanModules = Human.modules = {};

    var MALE_STATE_ID = HumanModules.MALE_STATE_ID = 'maleAdult_standard';
    var FEMALE_STATE_ID = HumanModules.FEMALE_STATE_ID = 'femaleAdult_standard';

    // True once Human loaded
    var loaded;

    // Module IDs are internally generated from this pool
    var idPool = new Human.utils.IDPool();

    // Existing modules
    HumanModules.modules = {};

    HumanModules.moduleLibs = {};

    // Supports query for modules by tag matches
    // This just stores records of module IDs and tags
    var queryTagMap = new Human.utils.TagMapList();

    // Currently active modules
    HumanModules.activeModules = {};
    HumanModules.numActiveModules = 0;

    // Queues module activations so they don't happen on top of each other
    var activationQueue = [];

    // moduleIds assoicated by Display Names
    HumanModules.namesToModuleIds = {};

    // Semaphore true when module is activating
    var moduleActivating = false;

    // Make sure we don't try to create, activate or deactivate
    // modules until Human has loaded
    Human.events.on("loaded",
        function () {
            loaded = true;
        });

    /**
     Creates a module.

     <pre>
     Human.modules.createModule({
           moduleId: "myModule",
           displayName: "Example Module",
           description: "An example module",
           tags: ["alpha", "beta"],

           // Followed by type-specific properties
           fooParam: "foo",
           barParam: 6
      });
     </pre>

     <p>That just registers a module in memory. It doesn't actually load anything into the engine until
     you activate it with {@link Human.modules.activateModules}.</p>

     @memberof Human.modules
     @param params
     @param {String} [params.moduleId] Optional unique module ID, internally generated if omitted
     @param {[String]} [params.tags] Optional meta tags to classify the new module
     @param {String} [params.description] Optional module description text
     @param {String} [params.displayName] Optional module display name
     @return {String} Module ID
     */
    HumanModules.createModule = function (params) {

        var moduleId;
        // Create the module
        if (params.moduleId) {
            moduleId = params.moduleId;
            if (HumanModules.modules[moduleId]) {
                Human.log.warn("Human.modules.createModule", "Module already created, won't create again: + " + moduleId);
                return;
            }
        } else {
            moduleId = idPool.getId();
        }
        params.moduleId = moduleId;
        params.displayName = params.displayName || "";
        params.description = params.description || "";
        params.translations = params.translations;
        params.tags = params.tags || [];
        params.active = false;
        params.timeActivated = -1;

        var module = new HumanModules.Module(params);
        HumanModules.modules[moduleId] = module;

        queryTagMap.addItem(moduleId, params.tags || ["untagged"], module);
        // add name map
        HumanModules.namesToModuleIds[params.displayName] = HumanModules.namesToModuleIds[params.displayName] || [];
        HumanModules.namesToModuleIds[params.displayName].push(moduleId);

        Human.events.fire("modules.created", params);

        return moduleId;
    };

    /**
     Activates selected modules.

     <p>Once we've created some modules with {@link Human.modules.createModule}, we can then activate them. We can select
     which modules to activate either by IDs or meta tags.</p>
     <p><b>Activate a module by ID:</b></p>

     <pre>
     Human.modules.activateModules({ moduleId: "myModule" },
     function() {
        // Success
    },
     function (errMsg) {
        // Error
    });
     </pre>

     <p><b>Activate a list of modules by ID, synchronously in given order:</b></p>

     <pre>
     Human.modules.activateModules({ moduleIds: ["myModule", "myOtherModule"] },
     function() {
        // Success
    },
     function (errMsg) {
        // Error
    });
     </pre>

     <p><b>Activate first module found that has the given tags:</b></p>

     <pre>
     Human.modules.activateModules({ tags: ["alpha"] },
     function() {
        // Success
    },
     function (errMsg) {
        // Error
    });
     </pre>

     @memberof Human.modules
     @param {*} params
     @param {[String]} [params.tags] Module meta tags
     @param {String} [params.moduleId] Module ID
     @param {[String]} [params.moduleIds] Array of module IDs, to activate in sequence
    @param {[Object|Function]} [params.extensions] Object of properties to extend the default. Optionally a function that returns that object
     @param {Function} ok Completion callback - also called even on error, which will be logged
     */
    HumanModules.activateModules = function (params, ok, error) {

        if (!loaded) {
            Human.log.error("Human.modules.activateModules", "Human not loaded - modules can only be activated when Human loaded");
            if (ok) {
                ok();
            }
            return;
        }

        var temp = ok;
        ok = function () {
            if (temp) {
                temp();
            }
        };

        var options = params;

        if (params.moduleId) {

            // Activate a single module
            var moduleId = params.moduleId;
            if (!HumanModules.modules[moduleId]) {

                // Module not defined

                Human.log.info("Human.modules.activateModules", "Module not found: '" + moduleId + "' - attempting to load definition");

                // Load module definition
                Human.assets.server.getModuleDefinition(
                    moduleId,
                    function (module) {
                        // Create module
                        module.moduleId = moduleId;

                        HumanModules.createModule(module);

                        // Activate module
                        activateModule(moduleId, options, ok);
                    },
                function(e) {
                    Human.log.info("Human.modules.activateModules", "Failed to activate module: '" + moduleId + "' - " + e);
                    if (error) {
                        error(e);
                    }
                });

                return;
            }

            activateModule(moduleId, options, ok);

        } else if (params.moduleIds) {
            activateModules(params.moduleIds.slice(0), options, ok);

        } else if (params.tags) {

            // Activate modules whose tag sets contain all of the given tags
            activateFirstModuleWithTags(params.tags, options, ok);
        }
    };

    HumanModules.activateModuleWithAssets = function (moduleId, ok, error) {
        Human.renderer.pushPause();
        Human.renderer.pauseCompilation();

        HumanModules.activateModules({ moduleId: moduleId },
            function () {
                var module = Human.modules.activeModules[moduleId];

                Human.scene.graph.attachAssetSetsToSubtree(module.assetObjects,
                    function (types, i, done) {

                        if(types.material) {
                            Human.timeline.initTransparencies();
                        }

                        if (i === 0) {
                            Human.timeline.initScene();
                            Human.view.lights.compile();
                            Human.view.effects.compile();
                            Human.renderer.resumeCompilation();
                            Human.renderer.compile();
                            Human.timeline.initCamera();
                            Human.renderer.popPause();
                        }

                        if(types.morph) {
                            Human.timeline.addMorphs(
                                Object.keys(
                                    Human.assets.morphs.morphs
                                )
                            );
                        }

                        if(done) {
                            Human.modules.activateTimeline(moduleId);
                            if (ok) {
                                ok();
                            }
                        }

                    });
            }, function() {
                Human.renderer.resumeCompilation();
                Human.renderer.popPause();
                if (error) {
                    error();
                }
            });
    };

    function extendModule(module, extensions) {

        if(typeof extensions === 'function') {
            extensions = extensions(module);
        }

        if(Human.utils.isObject(extensions)) {

            for(var prop in extensions) {
                if(extensions.hasOwnProperty(prop)) {
                    // Store overwritten props for reference
                    if(module.hasOwnProperty(prop)) {
                        if(!module._overwritten) {
                            module._overwritten = {};
                        }

                        module._overwritten[prop] = module[prop];
                    }

                    module[prop] = extensions[prop];
                }
            }
        }
    }

    function revertModule(module) {
        var overwritten = module._overwritten;

        if (!overwritten) {
            return;
        }

        for(var prop in overwritten) {
            if(overwritten.hasOwnProperty(prop)) {
                module[prop] = overwritten[prop];
            }
        }

        delete module._overwritten;
    }

    HumanModules.activateTimeline = function(moduleId, options) {
        var module = HumanModules.modules[moduleId];
        options = options || {};

        if (module && Human.timeline.activeRoot !== null && options.play !== false){
            var bc = { which: "second", direction: "forwards" };

            if (!Human.utils.isEmpty(module.animation)) {
                Human.timeline.play(module.animation || {});
            } else {
                //Play the first frame of first chapter.
                Human.timeline.scrub({ time: 0.0 }, { boundaryCondition: bc });
            }
        }
    };

    /**
     * Activates the module of the given ID
     *
     * Queues the request if another module is already in the process of activation
     *
     * @param moduleId
     * @param options
     * @param ok
     */
    function activateModule(moduleId, options, ok) {
        if (moduleActivating) {
            activationQueue.unshift({ moduleId: moduleId, options: options, ok: ok });
            return;
        }
        _activateModule(moduleId, options,
            function () {
                if (ok) {
                    ok();
                }
                nextActivation();
            });
    }

    function _activateModule(moduleId, options, ok) {
        var module = HumanModules.modules[moduleId];

        if (!module) {
            Human.log.error("Human.modules.activateModules", "Module not found: " + moduleId);
            ok();
            return;
        }

        // Activate the module
        moduleActivating = true;
        Human.events.fire("modules.activating", { moduleId: moduleId });

        if (options.extensions) {
            extendModule(module, options.extensions);
        }

        module.activate(options,
            function () {

                // Register active module
                module.active = true;
                module.timeActivated = Date.now();
                HumanModules.activeModules[moduleId] = module;
                HumanModules.numActiveModules++;

                Human.events.fire("modules.activated", { moduleId: moduleId, timeActivated: module.timeActivated });

                moduleActivating = false;
                ok();
            });
    }

    function nextActivation() {
        if (activationQueue.length > 0) {
            var activation = activationQueue.pop();
            _activateModule(activation.moduleId, activation.options,
                function () {
                    activation.ok();
                    nextActivation();
                });
        }
    }

    function activateModules(moduleIds, options, ok) {
        _activateModules(moduleIds.slice(0), moduleIds.length, options, function () {
            ok();
        });
    }

    function _activateModules(moduleIds, numModules, options, ok) {
        if (moduleIds.length === 0) {
            ok();
            return;
        }
        var moduleId = moduleIds.shift();
        activateModule(moduleId, options,
            function () {
                _activateModules(moduleIds, numModules, options, ok);
            });
    }

    /**
     * Activates the first module found with tags that contain the given set
     *
     * @param {[String]} tags Tags to match on
     * @params {Object} options
     * @param {Function} ok Success callback
     * @param {Function} error Error callback
     */
    function activateFirstModuleWithTags(tags, options, ok) {
        var modules = queryTagMap.findItems({ matching: "atLeast", tags: tags });
        for (var i = 0, len = modules.length; i < len; i++) {
            activateModule(modules[i].moduleId, options, ok);
            return;
        }
        Human.log.warn("Human.modules.activateModules", "Failed to activate module - no module found with these tags: " + JSON.stringify(tags));
        ok();
    }


    /**
     Deactivates selected modules.

     <p>If we've previously activated some modules with {@link Human.modules.activateModules}, we can deactivate them again. We can
     select which modules to deactivate either by IDs or meta tags. We can also just indiscriminately deactivate all modules.</p>

     <p><b>Deactivate a module by ID:</b></p>
     <pre>
     Human.modules.deactivateModules({ moduleId: "myModule" });
     </pre>

     <p><b>Deactivate a list of modules by ID:</b></p>
     <pre>
     Human.modules.deactivateModules({ moduleIds: ["myModule", "myOtherModule"] });
     </pre>

     <p><b>Deactivate first module found that has the given tags:</b></p>
     <pre>
     Human.modules.deactivateModules({ tags: ["alpha"] });
     </pre>

     <p><b>Deactivate all modules:</b></p>
     <pre>
     Human.modules.deactivateModules();
     </pre>


     @memberof Human.modules
     @param {*} params
     @param {[String]} [params.tags] Tags of modules to deactivate
     @param {String} [params.moduleId] Module to NOT deactivate
     */
    HumanModules.deactivateModules = function (params) {
        params = params || {};

        if (params.tags) {

            // Deactivate modules matching given tags
            deactivateModulesWithTags(params);
        } else if (params.moduleId) {

            // Deactivate a given module
            deactivateModule(params.moduleId);
        } else {

            // Deactivate all modules
            deactivateModule();
        }
    };

    /**
     * Deactivates modules whose tag set contains the given tags
     */
    function deactivateModulesWithTags(params) {
        var modules = queryTagMap.findItems({ matching: params.matching || "atLeast", tags: params.tags});
        for (var i = 0, len = modules.length; i < len; i++) {
            deactivateModule(modules[i].moduleId);
        }
    }

    /**
     * Deactivates the module with the given ID
     * @param moduleId
     */
    function deactivateModule(moduleId, destroyObjects) {
        if (moduleActivating) {
            return;
        }
        if (!moduleId) {
            // Deactivate all modules if none specified
            for (moduleId in HumanModules.modules) {
                if (HumanModules.modules.hasOwnProperty(moduleId) && HumanModules.activeModules[moduleId]) {
                    deactivateModule(moduleId, destroyObjects);
                }
            }
            return;
        }
        var module = HumanModules.activeModules[moduleId];
        if (!module) { // Module is not active
            return;
        }
        Human.events.fire("modules.deactivating", { moduleId: moduleId });
        module.deactivate(destroyObjects);
        module.active = false;
        module.timeActivated = -1;
        revertModule(module);
        delete HumanModules.activeModules[moduleId];
        HumanModules.numActiveModules--;
        Human.events.fire("modules.deactivated", moduleId);
    }

    /**
     Destroys selected modules.

     <p>If we've previously created some modules with {@link Human.modules.createModule}, we can destroy them again. We can
     select which modules to destroy either by IDs or meta tags. We can also just indiscriminately destroy all modules.</p>
     <p>Note that destroying a module will implicitly deactivate it first.</p>

     <p><b>Destroy a module by ID:</b></p>
     <pre>
     Human.modules.destroyModules({ moduleId: "myModule" });
     </pre>

     <p><b>Destroy a list of modules by ID:</b></p>
     <pre>
     Human.modules.destroyModules({ moduleIds: ["myModule", "myOtherModule"] });
     </pre>

     <p><b>Destroy first module found that has the given tags:</b></p>
     <pre>
     Human.modules.destroyModules({ tags: ["alpha"] });
     </pre>

     <p><b>Destroy all modules:</b></p>
     <pre>
     Human.modules.destroyModules();
     </pre>


     @memberof Human.modules
     @param {*} params
     @param {[String]} [params.tags] Module meta tags
     @param {String} [params.moduleId] Module ID
     */
    HumanModules.destroyModules = function (params) {
        params = params || {};

        if (params.tags) {
            destroyModulesWithTags(params.tags);
        } else {
            destroyModule(params.moduleId);
        }
    };

    /**
     * Destroys modules whose tag set contains the given tags
     * @param tags
     */
    function destroyModulesWithTags(tags) {
        var modules = queryTagMap.findItems({ matching: "atLeast", tags: tags });
        for (var i = 0, len = modules.length; i < len; i++) {
            destroyModule(modules[i].moduleId);
        }
    }

    /**
     * Destroys the module with the given ID
     * @param moduleId
     */
    function destroyModule(moduleId) {
        if (moduleId) {
            // Destroy the specified module
            var module = HumanModules.modules[moduleId];
            if (!module) {
                Human.log.warn("Human.modules.destroyModules", "Failed to destroy module - module not found: + " + moduleId);
                return;
            }
            deactivateModule(moduleId, true);
            delete HumanModules.modules[moduleId];
            queryTagMap.removeItem(moduleId);
            // remove named entry
            if (HumanModules.namesToModuleIds.hasOwnProperty(module.displayName)) {
                var moduleIdIndex = HumanModules.namesToModuleIds[module.displayName].indexOf(moduleId);
                if (moduleIdIndex) {
                    HumanModules.namesToModuleIds[module.displayName].splice(moduleIdIndex, 1);
                }
            }
            idPool.putId(moduleId);
            Human.events.fire("modules.destroyed", moduleId);
            return;
        }
        // Destroy all modules
        for (moduleId in HumanModules.modules) {
            if (HumanModules.modules.hasOwnProperty(moduleId)) {
                destroyModule(moduleId);
            }
        }
    }

    /**
     Queries metadata on selected modules.

     <p>If we have some modules created, we can query what they are. We can select which modules to query either by IDs or
     meta tags. We can also just indiscriminately query all modules.</p>
     <p><b>Query modules matching tags:</b></p>
     <pre>
     var list = query({
       matching: "atLeast" | "any" | "most",
       tags: ["foo", "bar", "baz"]
 });
     </pre>

     Result:
     <pre>
     [
     {
         "moduleId": "foo",
         "displayName": "name1",
         "description": "bar",
         "tags": ["baz", "qux"]
     },
     {
         "moduleId": "foo2",
         "displayName": "name2",
         "description": "bar2",
         "tags": ["baz2", "qux2"]
     }
     //..
     ]
     </pre>

     <p><b>Query all modules:</b></p>
     <pre>
     var list = query();
     </pre>

     @param {{}} params Query params
     @param {[String]} params.tags Meta tags to match on
     @memberof Human.modules
     */
    HumanModules.query = function (params) {
        var module, moduleId, list;

        if (params) {
            if (params.tags) {
                // Query modules matching tags
                return queryTagMap.findItems(params);
            }
            if (params.moduleId) {
                // Query a specific module
                module = HumanModules.modules[params.moduleId];
                return module ? [module.module] : [];
            }
            if (params.names) {
                var modules = [];
                // for each name get assoicated modules
                for (var i in params.names) {
                    if (params.names.hasOwnProperty(i)) {
                        var name = params.names[i];
                        if (HumanModules.namesToModuleIds.hasOwnProperty(name)) {
                            var moduleIds = HumanModules.namesToModuleIds[name];
                            for (var j in moduleIds) {
                                if (moduleIds.hasOwnProperty(j)) {
                                    moduleId = moduleIds[j];
                                    if (HumanModules.modules.hasOwnProperty(moduleId)) {
                                        module = HumanModules.modules[moduleId];
                                        modules.push({
                                            moduleId: moduleId,
                                            displayName: module.displayName,
                                            description: module.description,
                                            translations: module.translations,
                                            tags: module.tags,
                                            animation: module.animation,
                                            active: module.active,
                                            timeActivated: module.timeActivated
                                        });
                                    }
                                }
                            }
                        }
                    }

                }
                return modules;
            }
            if (params.active) {
                // Query active modules
                list = [];
                for (moduleId in HumanModules.activeModules) {
                    if (HumanModules.activeModules.hasOwnProperty(moduleId)) {
                        module = HumanModules.activeModules[moduleId];
                        list.push({
                            moduleId: moduleId,
                            displayName: module.displayName,
                            description: module.description,
                            translations: module.translations,
                            tags: module.tags,
                            animation: module.animation,
                            active: module.active,
                            timeActivated: module.timeActivated
                        });
                    }
                }
                return list;
            }
        }
        // Query all modules
        list = [];
        for (moduleId in HumanModules.modules) {
            if (HumanModules.modules.hasOwnProperty(moduleId)) {
                module = HumanModules.modules[moduleId];
                list.push({
                    moduleId: moduleId,
                    displayName: module.displayName,
                    description: module.description,
                    translations: module.translations,
                    tags: module.tags,
                    animation: module.animation,
                    active: module.active,
                    timeActivated: module.timeActivated
                });
            }
        }
        return list;
    };


    /* BASE ANATOMY UTILITY METHODS */

    HumanModules.isBase = function (input) {
        var match = input.match(/^(femaleAdult|maleAdult)/);
        return match && match[0];
    };

    HumanModules.isBaseModule = function (input) {
        var parts = input.split('/');
        return HumanModules.isBase(parts[parts.length - 1]) ? input : false;
    };

    HumanModules.requiresBase = function (objectIds) {
        var baseFound = false;

        for (var i = 0; i < objectIds.length; i++) {
            baseFound = HumanModules.isBase(objectIds[i]);

            if(baseFound) {
                break;
            }
        }

        return baseFound;
    };


    /* STATE CONVERSION METHODS */

    var MODULE_ID_CONVERSIONS = {
        "production/maleAdult/maleAdult.json": "production/maleAdult/maleAdult_standard.json",
        "production/maleAdult/femaleAdult.json": "production/maleAdult/femaleAdult_standard.json"
    };

    HumanModules.convertBaseAnatomyModuleId = function (moduleId) {
        return MODULE_ID_CONVERSIONS[moduleId] || moduleId;
    };

    HumanModules.convertBaseAnatomyStateId = function (stateId) {
        return stateId.replace(/^femaleAdult$/, FEMALE_STATE_ID)
            .replace(/^maleAdult$/, MALE_STATE_ID);
    };

    HumanModules.convertBaseAnatomyObjectId = function (objectId) {
        if(HumanModules.isBase(objectId)) {
            var parts = objectId.split('-');
            var stateId = HumanModules.convertBaseAnatomyStateId(parts[0]);

            objectId = [stateId, parts[1]].join('-');

            if(!/_ID$/.test(objectId)) {
                objectId += "_ID";
            }
        }

        return objectId;
    };

})();
;(function () {
    "use strict";

    var Module = Human.modules.Module = function (cfg) {

        // Metadata

        this.moduleId = cfg.moduleId;
        this.displayName = cfg.displayName || "";
        this.description = cfg.description || "";
        this.translations = cfg.translations || {};
        this.tags = cfg.tags || [];
        this.ui = cfg.ui || {};
        this.active = false;

        // Collects IDs of loaded libraries in #activate for unloading in #deactivate
        this._loadedLibs = [];

        // List of objectIds of objects created by this module
        this.rootObjects = [];

        // Objects or subtrees that needs assets attached.
        this.assetObjects = [];

        // Flags for hacking around content bugs

        this.hacks = cfg.hacks;

        // Specific to this module type

        this.animation = cfg.animation;
        this.camera = cfg.camera;
        this.jumpTo = cfg.jumpTo;
        this.flyTo = cfg.flyTo;
        var p = cfg.modelIds || cfg.stateId;
        this.modelIds = p ? (Human.utils.isArray(p) ? p : [p]) : [];
        this.hasBaseAnatomy = false;

        for (var i = 0; i < this.modelIds.length; i++) {
            if (Human.modules.isBase(this.modelIds[i])) {
                this.modelIds[i] = Human.modules.convertBaseAnatomyStateId(this.modelIds[i]);
                this.hasBaseAnatomy = true;
            }
        }

        this.showObjects = cfg.showObjects;
        this.selectObjects = cfg.selectObjects;
        this.pickThroughObjects = cfg.pickThroughObjects;
        this.transparentObjects = cfg.transparentObjects;
        this.desaturatedObjects = cfg.desaturatedObjects;
        this.backfaceObjects = cfg.backfaceObjects;
        this.objectGlassFactors = cfg.objectGlassFactors;
        this.objectOpacities = cfg.objectOpacities;
        this.animation = cfg.animation;
        this.xray = cfg.xray;
        this.annotations = cfg.annotations;
        this.annotationsLayout = cfg.annotationsLayout;
        this.environment = cfg.environment;
        this.chapterCameraPath = !!cfg.chapterCameraPath;
        this.effects = cfg.effects;
        this.properties = cfg.properties;
        this.reflections = cfg.reflections;
        this.skyboxes = cfg.skyboxes;
        this.chapters = cfg.chapters || null;
        this.swapped = false;
        this.swappedObjectId = null;

        this.cache = false;

    };


    /**
     Activates this module.

     @param {Object} options Activation options
     @param {Boolean} options.swap When true, will activate module in "swap" mode
     @param {Boolean} options.camera When false (default == true), will prevent module from loading camera state
     @param {Boolean} options.cache When true (default == false), will cache models (states) in memory when deactivated
     @param ok
     */
    Module.prototype.activate = function (options, ok) {

        // Load models, then load app states like camera, viewing modes, cross-sections
        // and scene object visibility/selection/transparency.
        // Models are loaded synchronously in strict sequence because each model may have
        // things like animations that reference objects loaded by the models preceeding it.

        var self = this;

        // In "swap" mode we're swapping a scene object for a module. In this mode, the module
        // is constrained so that as it activates, it's not able to change the state of objects
        // that are already in the scene, nor is able to update the camera.

        // The swap effect requires that we don't change the viewpoint or destroy structures
        // that are not being swapped out.

        // A module in "swap' mode can however set view modes, engine properties, activate post-effects,
        // create light sources, etc.

        // A swapped module optionally remembers the object it was swapped for, so that it can
        // restore the visibility of that object when deactivated.

        var swap = !!options.swap;

        this.swapped = swap;

        if (swap) {
            this.swappedObjectId = options.objectId;
        }

        // Option to prevent module from loading camera state, useful when we want to
        // load our own camera state

        //var enableCamera = (options.camera !== false);

        // Option to cache the module's models in memory, ie. to never unload them

        this.cache = !!options.cache;

        // HACK: Face winding bug hacks
        // Remove when condition meshes with face winding bug are re-exported
        if (self.hacks) {
            Human.properties.set({ "hacks.neverBackfaces": !!self.hacks.neverBackfaces });
            Human.properties.set({ "hacks.alwaysBackfaces": !!self.hacks.alwaysBackfaces });
        }

        if (this.reflections) {
            this.restoreReflections = Human.assets.reflections.active;
            Human.assets.reflections.exportReflections(this.reflections);
        }

        if (this.skyboxes) {
            this.restoreSkyboxes = Human.view.skyboxes.active;
            Human.assets.skyboxes.exportSkyboxes(this.skyboxes);
        }

        // Patch in base anatomy to modelIds

        // Will give us (male|female)Adult without any suffixes
        var requiredBase = this.showObjects ? Human.modules.requiresBase(Object.keys(this.showObjects)) : false;
        var baseAnatomyId;

        if(requiredBase) {
            // Add suffix here, the engine is relying on a 1:1 relationship
            // between state id and module id.
            baseAnatomyId = Human.modules.convertBaseAnatomyStateId(requiredBase);

            if(this.modelIds.indexOf(baseAnatomyId) === -1) {
                this.modelIds.push(baseAnatomyId);
            }
        }

        this._loadScene(
            this.modelIds.slice(),
            function () {
                /* NOTE: Scene-Graph Asset loading no longer redirects loading a target-module
                * that contains base-anatomy to the base-anatomy module. Consequently, we don't
                * need any logic to disambiguate whether a base-anatomy module is being loaded
                * for its own sake or for the sake of a different target module.
                */

                /* Use chapters from module file if present. */

                if (self.chapters!== null){
                     var _id = '';
                     var _chapterIndex = 0;
                     for (_chapterIndex=0; _chapterIndex < self.chapters.length; _chapterIndex++){
                         _id = self.moduleId + _chapterIndex;
                         self.chapters[_chapterIndex].id = _id;
                     }
                     Human.timeline.chapterList = self.chapters;
                }
                // reset chapterList if module is a bookmark or a single-chapter state with only base anatomy
                // TODO: Shouldn't we always reset the chapterList?
                if (self.modelIds.indexOf("bookmark") !== -1){
                    Human.timeline.chapterList = [];
                } else if (Human.modules.isBaseModule(self.moduleId) && Human.timeline.chapterList.length === 1){
                    var chapterId = Human.timeline.chapterList[0].id;
                    if (Human.modules.isBaseModule(chapterId)) {
                        Human.timeline.chapterList = [];
                    }
                }

                // Prepare module as a human-chapter
                var modaschapter = new Human.timeline.chapter(self.moduleId, self); // this module is now in chapter data format.

                // This is here because the chapter will have "*" expanded
                // from showObjects
                for (var objectId in modaschapter.showObjects) {
                    if (modaschapter.showObjects.hasOwnProperty(objectId) && Human.scene.objects[objectId]) {
                        self.assetObjects.push(Human.scene.objects[objectId]);
                    }
                }

                if (requiredBase && !self.hasBaseAnatomy){
                    self._mergeBaseModule(requiredBase, baseAnatomyId, function (mergedMod) {
                        createRoot(mergedMod, ok);
                    });
                } else {
                    createRoot(modaschapter, ok);
                }

            });

    };

    /**
    * We still need to perform this merge to obtain properties that are only
    * set in the base anatomy module definition
    */

    Module.prototype._mergeBaseModule = function(requiredBase, baseAnatomyId, ok) {
        var self = this;

        var baseModuleAddress = "production/" + requiredBase + "/" + baseAnatomyId + ".json";

        Human.assets.server.getModuleDefinition(baseModuleAddress, function(baseManifest){
            var modaschapter = new Human.timeline.chapter(baseModuleAddress, baseManifest);
            modaschapter.merge(self);

            if(ok) {
                ok(modaschapter);
            }
        });
    };

    /** Builds Root Timeline once Chapters have been created
    * from Chapters in chapterList
    * and the module as a human-chapter
    *
    * NOTE: Because we can't assume we have materails at this point,
    * we don't know which objects to make transparent and we can't ask them.
    * Therefore, object transparencies are not attached to chapter synchronization
    * here.
    *
    * NOTE: There is no guarantee that any leaf timelines will exist, except
    * for the dummy timeline.
    */
    function createRoot(modaschapter,ok){

        // Enable all objects
        Human.scene.setEnabledObjects({
            objectIds: modaschapter.showObjects,
            replace: true
        });



        // Ensure Human.timeline.chapterList
        if (Human.timeline.chapterList.length === 0){
            Human.timeline.chapterList = [modaschapter];
        } else {
            var chapters = [];
            var humanChapter;
            Human.timeline.chapterList.forEach(function(chapterData){
                humanChapter = new Human.timeline.chapter(chapterData.id);
                humanChapter.merge(modaschapter);
                humanChapter.merge(chapterData);
                chapters.push(humanChapter);
            });
            Human.timeline.chapterList = chapters;
        }

        // Build Branch timelines and add to Root
        var root = new Human.timeline.RootTimeline(modaschapter.id);
        var branch;
        Human.timeline.chapterList.forEach(function(humanChapter){
            branch = new Human.timeline.BranchTimeline(humanChapter, "chapter");
            root.addChapter(branch, { rebuild: false });
        });
        root.build();
        Human.timeline.activeRoot = root;

        Human.view.clip.reset();
        ok();

    }

    function unloadAnnotations(annotations) {
        var a;
        var b;
        for (var i = 0, len = annotations.length; i < len; i++) {
            a = annotations[i];
            b = Human.view.annotations.annotations[a.annotationId];
            if (b) {
                b.destroy();
            }
        }
    }

    Module.prototype.deactivate = function (destroyObjects) {

        Human.timeline.stop();

        if (this.annotations) {
            unloadAnnotations(this.annotations);
        }
        Human.view.annotations.clearAnnotations();

        // Only unload models if this module is not cached in memory
        if (!this.cache && this.modelIds) {

            if (destroyObjects) {
                this._destroyObjects();
            } else {
                this._hideObjects();
            }

            Human.timeline.destroyChapterSet(this.moduleId);

            // Destroy libraries using IDs we collected while loading them in #activate
            for (var i = 0, len = this._loadedLibs.length; i < len; i++) {
                Human.assets.putAssetLibrary(this._loadedLibs[i]);
            }

            this._loadedLibs.length = 0;
        }

    };

    /**
     * Destroys all objects belonging to this module
     */
    Module.prototype._destroyObjects = function() {
        Human.scene.graph.destroySubtree(this.rootObjects);
        this.rootObjects.length = 0;
    };

    /**
     * Hides all objects belonging to this module
     */
    Module.prototype._hideObjects = function() {

        // Get a map containing a 'false' for
        // each object that belongs to this module

        var objectIds = {};
        var modelIds = this.modelIds;
        var modelObjects;
        for (var i = 0, len = modelIds.length; i < len; i++) {
            modelObjects = Human.scene.modelObjects[modelIds[i]];
            for (var objectId in modelObjects) {
                if (modelObjects.hasOwnProperty(objectId)) {
                    objectIds[objectId] = false;
                }
            }
        }

        // Hide those objects, as specified by the map

        Human.scene.setEnabledObjects({
            objects: objectIds,
            replace: false // Don't change visibility of other objects
        });
    };


    // Loads models in synchronous sequence. Each model may have things like
    // animations that reference objects loaded by the models preceding it.
    Module.prototype._loadScene = function (modelIds, ok) {
        var moduleId = this.moduleId;

        var numStates = modelIds.length;

        var self = this;
        var hasLights = false;

        var moduleHasChapters = (this.chapters !==null)? true: false;

        function doneState() {
            if (--numStates === 0 && ok) {
                if (!hasLights){
                    Human.view.lights.restoreDefaults();
                }
                ok();
            }
        }

        modelIds.forEach(function(modelId){
            Human.assets.server.getStateIndex(modelId, function(index) {

                var data = index.data;

                var numLibs = 0;


                function doneLib() {
                    if (--numLibs === 0) {
                        doneState();
                    }
                }

                if (index.data && index.data.createObjects) {
                    var newRootObjects = Human.scene.graph.buildSceneGraph(index.data.createObjects, modelId);
                    self.rootObjects = self.rootObjects.concat(newRootObjects);
                }

                function loadLibs(libs, type, dir, fileName, params) {
                    if (!libs) {
                        return;
                    }
                    params = params || {};
                    for (var key in libs) {
                        if (libs.hasOwnProperty(key)) {
                            numLibs++;
                            var libId = modelId + "/" + key;
                            Human.assets.getAssetLibrary(type, dir, libId, fileName, params, doneLib);
                            self._loadedLibs.push(libId);
                        }
                    }
                }
                if (data.lights) {
                    loadLibs(data.lights, "light", "lights", "outline");
                    hasLights = true;
                }

                if (data.animations && Object.keys(data.animations).length > 0){
                    // HACK: This registers an empty leaf timeline for the incoming morph or tween animations
                    Human.timeline.leafTimelines[modelId] = new Human.timeline.LeafTimeline(modelId);
                }
                loadLibs(data.animations, "animation", "animations", "manifest");
                loadLibs(data.reflections, "reflection", "reflections", "outline");
                loadLibs(data.skyboxes, "skybox", "skyboxes", "outline");

                if (!moduleHasChapters){
                    loadLibs(data.chapters, "chapter", "chapters", "manifest", { moduleId: moduleId });
                }
                loadLibs(data.audio, "audio", "audio", "manifest");
                loadLibs(data.videos, "videos", "videos", "manifest");

                if (numLibs === 0) {
                    Human.utils.async(doneState);
                }
            });
        });
    };

    /**
     * Given a map of booleans for object IDs, if the map has a "*" entry, then insert
     * a "true" for the ID of each object that was loaded by this module.
     *
     * When in swapping mode, strip out entries for objects that are not within those
     * that were loaded by this module.
     */
    Module.prototype._parseObjectIds = function (objectIds, swap) {
        var objectId;

        if (!objectIds) {
            return {};
        }

        if (swap) {

            // Swap mode;
            // discard flags for objects not loaded by this module

            var temp = {};

            for (objectId in objectIds) {
                if (objectIds.hasOwnProperty(objectId)) {
                    if (this._hasObject(objectId)) {
                        temp[objectId] = objectIds[objectId];
                    }
                }
            }

            if (objectIds["*"] !== undefined && objectIds["*"] !== null) {
                temp["*"] = objectIds["*"];
            }

            objectIds = temp;
        }

        var wildcard = objectIds["*"];

        if (wildcard === undefined || wildcard === null) {
            return objectIds;
        }

        // Expand wildcard into flags for object IDs

        var modelIds = this.modelIds;

        if (modelIds) {
            for (var i = 0, len = modelIds.length; i < len; i++) {
                var objects = Human.scene.modelObjects[modelIds[i]];
                for (objectId in objects) {
                    if (objects.hasOwnProperty(objectId)) {
                        objectIds[objectId] = wildcard;
                    }
                }
            }
        }

        return objectIds;
    };

    /**
     * Returns true if the given scene object ID matches one
     * of the objects loaded by this module
     */
    Module.prototype._hasObject = function (objectId) {

        var modelIds = this.modelIds;

        if (!modelIds) {

            // Not loading any objects, so cannot own the given object
            return false;
        }

        for (var i = 0, len = this.modelIds.length; i < len; i++) {
            if (objectId.indexOf(this.modelIds[i]) === 0) {
                return true;
            }
        }

        return false;
    };

})();
