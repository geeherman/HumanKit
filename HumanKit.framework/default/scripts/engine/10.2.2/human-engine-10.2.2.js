/*
 * SceneJS V4.2.2
 *
 * A WebGL-based 3D scene graph from xeoLabs
 * http://scenejs.org/
 *
 * Built on 2017-12-04
 *
 * MIT License
 * Copyright 2017, Lindsay Kay
 * http://xeolabs.com/
 *
 */

/*
 * SceneJS Latest
 *
 * A WebGL-based 3D scene graph from xeoLabs
 * http://scenejs.org/
 *
 * MIT License
 * Copyright 2015, Lindsay Kay
 * http://xeolabs.com/
 *
 */

;/**
 * @fileoverview gl-matrix - High performance matrix and vector operations
 * @author Brandon Jones
 * @author Colin MacKenzie IV
 * @version 2.3.2
 */

/* Copyright (c) 2015, Brandon Jones, Colin MacKenzie IV.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE. */
var glMatrix = {};

// Configuration Constants
glMatrix.EPSILON = 0.000001;
glMatrix.ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;
glMatrix.RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
glMatrix.setMatrixArrayType = function(type) {
    glMatrix.ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
* Convert Degree To Radian
*
* @param {Number} a Angle in Degrees
*/
glMatrix.toRadian = function(a){
     return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less 
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 * 
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
glMatrix.equals = function(a, b) {
	return Math.abs(a - b) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a), Math.abs(b));
}

/**
 * @class 4x4 Matrix
 * @name mat4
 */
var mat4 = {};

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
mat4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
mat4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
mat4.fromValues = function(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    var out = new glMatrix.ARRAY_TYPE(16);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
mat4.set = function(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m03;
    out[4] = m10;
    out[5] = m11;
    out[6] = m12;
    out[7] = m13;
    out[8] = m20;
    out[9] = m21;
    out[10] = m22;
    out[11] = m23;
    out[12] = m30;
    out[13] = m31;
    out[14] = m32;
    out[15] = m33;
    return out;
};


/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
mat4.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};

/**
 * Transpose the values of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }

    return out;
};

/**
 * Inverts a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};

/**
 * Calculates the adjugate of a mat4 not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
mat4.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
mat4.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};

/**
 * Multiplies two mat4's explicitly not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
mat4.mul = mat4.multiply;

/**
 * Translate a mat4 by the given vector not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
mat4.translate = function (out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
mat4.scale = function(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.rotate = function (out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};

/**
 * Rotates a matrix by the given angle around the X axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateX = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Y axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateY = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};

/**
 * Rotates a matrix by the given angle around the Z axis not using SIMD
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.rotateZ = function (out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
mat4.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
mat4.fromRotation = function(out, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t;

    if (Math.abs(len) < glMatrix.EPSILON) { return null; }

    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    // Perform rotation-specific matrix multiplication
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromXRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = 1;
    out[1]  = 0;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromYRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = 0;
    out[2]  = -s;
    out[3]  = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
mat4.fromZRotation = function(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad);

    // Perform axis-specific matrix multiplication
    out[0]  = c;
    out[1]  = s;
    out[2]  = 0;
    out[3]  = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslation = function (out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getTranslation = function (out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
};

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be 
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
mat4.getScaling = function (out, mat) {
  var m11 = mat[0],
      m12 = mat[1],
      m13 = mat[2],
      m21 = mat[4],
      m22 = mat[5],
      m23 = mat[6],
      m31 = mat[8],
      m32 = mat[9],
      m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
};

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
mat4.getRotation = function (out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) { 
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S; 
    out[2] = (mat[1] - mat[4]) / S; 
  } else if ((mat[0] > mat[5])&(mat[0] > mat[10])) { 
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S; 
    out[2] = (mat[8] + mat[2]) / S; 
  } else if (mat[5] > mat[10]) { 
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S; 
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S; 
  } else { 
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScale = function (out, q, v, s) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2,
        sx = s[0],
        sy = s[1],
        sz = s[2];

    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;

    return out;
};

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
mat4.fromRotationTranslationScaleOrigin = function (out, q, v, s, o) {
  // Quaternion math
  var x = q[0], y = q[1], z = q[2], w = q[3],
      x2 = x + x,
      y2 = y + y,
      z2 = z + z,

      xx = x * x2,
      xy = x * y2,
      xz = x * z2,
      yy = y * y2,
      yz = y * z2,
      zz = z * z2,
      wx = w * x2,
      wy = w * y2,
      wz = w * z2,

      sx = s[0],
      sy = s[1],
      sz = s[2],

      ox = o[0],
      oy = o[1],
      oz = o[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0] + ox - (out[0] * ox + out[4] * oy + out[8] * oz);
  out[13] = v[1] + oy - (out[1] * ox + out[5] * oy + out[9] * oz);
  out[14] = v[2] + oz - (out[2] * ox + out[6] * oy + out[10] * oz);
  out[15] = 1;

  return out;
};

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
mat4.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.frustum = function (out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspective = function (out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.perspectiveFromFieldOfView = function (out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
mat4.ortho = function (out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
mat4.lookAt = function (out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < glMatrix.EPSILON &&
        Math.abs(eyey - centery) < glMatrix.EPSILON &&
        Math.abs(eyez - centerz) < glMatrix.EPSILON) {
        return mat4.identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat4.str = function (a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat4.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2) ))
};

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
mat4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
};

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
mat4.sub = mat4.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
mat4.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
};

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
mat4.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    out[9] = a[9] + (b[9] * scale);
    out[10] = a[10] + (b[10] * scale);
    out[11] = a[11] + (b[11] * scale);
    out[12] = a[12] + (b[12] * scale);
    out[13] = a[13] + (b[13] * scale);
    out[14] = a[14] + (b[14] * scale);
    out[15] = a[15] + (b[15] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && 
           a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && 
           a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] &&
           a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat4.equals = function (a, b) {
    var a0  = a[0],  a1  = a[1],  a2  = a[2],  a3  = a[3],
        a4  = a[4],  a5  = a[5],  a6  = a[6],  a7  = a[7], 
        a8  = a[8],  a9  = a[9],  a10 = a[10], a11 = a[11], 
        a12 = a[12], a13 = a[13], a14 = a[14], a15 = a[15];

    var b0  = b[0],  b1  = b[1],  b2  = b[2],  b3  = b[3],
        b4  = b[4],  b5  = b[5],  b6  = b[6],  b7  = b[7], 
        b8  = b[8],  b9  = b[9],  b10 = b[10], b11 = b[11], 
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)) &&
            Math.abs(a9 - b9) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a9), Math.abs(b9)) &&
            Math.abs(a10 - b10) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a10), Math.abs(b10)) &&
            Math.abs(a11 - b11) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a11), Math.abs(b11)) &&
            Math.abs(a12 - b12) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a12), Math.abs(b12)) &&
            Math.abs(a13 - b13) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a13), Math.abs(b13)) &&
            Math.abs(a14 - b14) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a14), Math.abs(b14)) &&
            Math.abs(a15 - b15) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a15), Math.abs(b15)));
};

var mat3 = {};

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
mat3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
mat3.fromMat4 = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[4];
    out[4] = a[5];
    out[5] = a[6];
    out[6] = a[8];
    out[7] = a[9];
    out[8] = a[10];
    return out;
};

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
mat3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
mat3.fromValues = function(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    var out = new glMatrix.ARRAY_TYPE(9);
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
mat3.set = function(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
    out[0] = m00;
    out[1] = m01;
    out[2] = m02;
    out[3] = m10;
    out[4] = m11;
    out[5] = m12;
    out[6] = m20;
    out[7] = m21;
    out[8] = m22;
    return out;
};

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
mat3.identity = function(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
};

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.transpose = function(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a12 = a[5];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a01;
        out[5] = a[7];
        out[6] = a02;
        out[7] = a12;
    } else {
        out[0] = a[0];
        out[1] = a[3];
        out[2] = a[6];
        out[3] = a[1];
        out[4] = a[4];
        out[5] = a[7];
        out[6] = a[2];
        out[7] = a[5];
        out[8] = a[8];
    }

    return out;
};

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.invert = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b01 = a22 * a11 - a12 * a21,
        b11 = -a22 * a10 + a12 * a20,
        b21 = a21 * a10 - a11 * a20,

        // Calculate the determinant
        det = a00 * b01 + a01 * b11 + a02 * b21;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = b01 * det;
    out[1] = (-a22 * a01 + a02 * a21) * det;
    out[2] = (a12 * a01 - a02 * a11) * det;
    out[3] = b11 * det;
    out[4] = (a22 * a00 - a02 * a20) * det;
    out[5] = (-a12 * a00 + a02 * a10) * det;
    out[6] = b21 * det;
    out[7] = (-a21 * a00 + a01 * a20) * det;
    out[8] = (a11 * a00 - a01 * a10) * det;
    return out;
};

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
mat3.adjoint = function(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    out[0] = (a11 * a22 - a12 * a21);
    out[1] = (a02 * a21 - a01 * a22);
    out[2] = (a01 * a12 - a02 * a11);
    out[3] = (a12 * a20 - a10 * a22);
    out[4] = (a00 * a22 - a02 * a20);
    out[5] = (a02 * a10 - a00 * a12);
    out[6] = (a10 * a21 - a11 * a20);
    out[7] = (a01 * a20 - a00 * a21);
    out[8] = (a00 * a11 - a01 * a10);
    return out;
};

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
mat3.determinant = function (a) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8];

    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
};

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.multiply = function (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        b00 = b[0], b01 = b[1], b02 = b[2],
        b10 = b[3], b11 = b[4], b12 = b[5],
        b20 = b[6], b21 = b[7], b22 = b[8];

    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
    return out;
};

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
mat3.mul = mat3.multiply;

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
mat3.translate = function(out, a, v) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],
        x = v[0], y = v[1];

    out[0] = a00;
    out[1] = a01;
    out[2] = a02;

    out[3] = a10;
    out[4] = a11;
    out[5] = a12;

    out[6] = x * a00 + y * a10 + a20;
    out[7] = x * a01 + y * a11 + a21;
    out[8] = x * a02 + y * a12 + a22;
    return out;
};

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.rotate = function (out, a, rad) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[3], a11 = a[4], a12 = a[5],
        a20 = a[6], a21 = a[7], a22 = a[8],

        s = Math.sin(rad),
        c = Math.cos(rad);

    out[0] = c * a00 + s * a10;
    out[1] = c * a01 + s * a11;
    out[2] = c * a02 + s * a12;

    out[3] = c * a10 - s * a00;
    out[4] = c * a11 - s * a01;
    out[5] = c * a12 - s * a02;

    out[6] = a20;
    out[7] = a21;
    out[8] = a22;
    return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
mat3.scale = function(out, a, v) {
    var x = v[0], y = v[1];

    out[0] = x * a[0];
    out[1] = x * a[1];
    out[2] = x * a[2];

    out[3] = y * a[3];
    out[4] = y * a[4];
    out[5] = y * a[5];

    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    return out;
};

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
mat3.fromTranslation = function(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 1;
    out[5] = 0;
    out[6] = v[0];
    out[7] = v[1];
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
mat3.fromRotation = function(out, rad) {
    var s = Math.sin(rad), c = Math.cos(rad);

    out[0] = c;
    out[1] = s;
    out[2] = 0;

    out[3] = -s;
    out[4] = c;
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
mat3.fromScaling = function(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;

    out[3] = 0;
    out[4] = v[1];
    out[5] = 0;

    out[6] = 0;
    out[7] = 0;
    out[8] = 1;
    return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
mat3.fromMat2d = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = 0;

    out[3] = a[2];
    out[4] = a[3];
    out[5] = 0;

    out[6] = a[4];
    out[7] = a[5];
    out[8] = 1;
    return out;
};

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
mat3.fromQuat = function (out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[3] = yx - wz;
    out[6] = zx + wy;

    out[1] = yx + wz;
    out[4] = 1 - xx - zz;
    out[7] = zy - wx;

    out[2] = zx - wy;
    out[5] = zy + wx;
    out[8] = 1 - xx - yy;

    return out;
};

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
mat3.normalFromMat4 = function (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

    return out;
};

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
mat3.str = function (a) {
    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
};

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
mat3.frob = function (a) {
    return(Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))
};

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    return out;
};

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
mat3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    return out;
};

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
mat3.sub = mat3.subtract;

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
mat3.multiplyScalar = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    return out;
};

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
mat3.multiplyScalarAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    out[4] = a[4] + (b[4] * scale);
    out[5] = a[5] + (b[5] * scale);
    out[6] = a[6] + (b[6] * scale);
    out[7] = a[7] + (b[7] * scale);
    out[8] = a[8] + (b[8] * scale);
    return out;
};

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] &&
           a[3] === b[3] && a[4] === b[4] && a[5] === b[5] &&
           a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
};

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
mat3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5], a6 = a[6], a7 = a[7], a8 = a[8];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)) &&
            Math.abs(a4 - b4) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a4), Math.abs(b4)) &&
            Math.abs(a5 - b5) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a5), Math.abs(b5)) &&
            Math.abs(a6 - b6) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a6), Math.abs(b6)) &&
            Math.abs(a7 - b7) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a7), Math.abs(b7)) &&
            Math.abs(a8 - b8) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a8), Math.abs(b8)));
};


var vec2 = {};

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
vec2.create = function() {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = 0;
    out[1] = 0;
    return out;
};

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
vec2.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
vec2.fromValues = function(x, y) {
    var out = new glMatrix.ARRAY_TYPE(2);
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
vec2.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    return out;
};

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
vec2.set = function(out, x, y) {
    out[0] = x;
    out[1] = y;
    return out;
};

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    return out;
};

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
vec2.sub = vec2.subtract;

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    return out;
};

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
vec2.mul = vec2.multiply;

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    return out;
};

/**
 * Alias for {@link vec2.divide}
 * @function
 */
vec2.div = vec2.divide;

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
vec2.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    return out;
};

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
vec2.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    return out;
};

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    return out;
};

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
vec2.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    return out;
};

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
vec2.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    return out;
};

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
vec2.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    return out;
};

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
vec2.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
vec2.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.distance}
 * @function
 */
vec2.dist = vec2.distance;

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec2.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
vec2.sqrDist = vec2.squaredDistance;

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
vec2.length = function (a) {
    var x = a[0],
        y = a[1];
    return Math.sqrt(x*x + y*y);
};

/**
 * Alias for {@link vec2.length}
 * @function
 */
vec2.len = vec2.length;

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec2.squaredLength = function (a) {
    var x = a[0],
        y = a[1];
    return x*x + y*y;
};

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
vec2.sqrLen = vec2.squaredLength;

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
vec2.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    return out;
};

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
vec2.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
};

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
vec2.normalize = function(out, a) {
    var x = a[0],
        y = a[1];
    var len = x*x + y*y;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
vec2.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1];
};

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
vec2.cross = function(out, a, b) {
    var z = a[0] * b[1] - a[1] * b[0];
    out[0] = out[1] = 0;
    out[2] = z;
    return out;
};

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec2} out
 */
vec2.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
vec2.random = function (out, scale) {
    scale = scale || 1.0;
    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    out[0] = Math.cos(r) * scale;
    out[1] = Math.sin(r) * scale;
    return out;
};

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y;
    out[1] = m[1] * x + m[3] * y;
    return out;
};

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat2d = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[2] * y + m[4];
    out[1] = m[1] * x + m[3] * y + m[5];
    return out;
};

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat3 = function(out, a, m) {
    var x = a[0],
        y = a[1];
    out[0] = m[0] * x + m[3] * y + m[6];
    out[1] = m[1] * x + m[4] * y + m[7];
    return out;
};

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
vec2.transformMat4 = function(out, a, m) {
    var x = a[0], 
        y = a[1];
    out[0] = m[0] * x + m[4] * y + m[12];
    out[1] = m[1] * x + m[5] * y + m[13];
    return out;
};

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec2.forEach = (function() {
    var vec = vec2.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 2;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec2.str = function (a) {
    return 'vec2(' + a[0] + ', ' + a[1] + ')';
};

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec2.equals = function (a, b) {
    var a0 = a[0], a1 = a[1];
    var b0 = b[0], b1 = b[1];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)));
};

/**
 * @class 3 Dimensional Vector
 * @name vec3
 */
var vec3 = {};

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
vec3.create = function() {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
};

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
vec3.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
vec3.fromValues = function(x, y, z) {
    var out = new glMatrix.ARRAY_TYPE(3);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
vec3.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
};

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
vec3.set = function(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
};

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
};

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
vec3.sub = vec3.subtract;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
};

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
vec3.mul = vec3.multiply;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
};

/**
 * Alias for {@link vec3.divide}
 * @function
 */
vec3.div = vec3.divide;

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
vec3.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
};

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
vec3.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
};

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
};

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
};

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
vec3.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    return out;
};

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
vec3.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    return out;
};

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
vec3.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
vec3.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.distance}
 * @function
 */
vec3.dist = vec3.distance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec3.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
vec3.sqrDist = vec3.squaredDistance;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
vec3.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return Math.sqrt(x*x + y*y + z*z);
};

/**
 * Alias for {@link vec3.length}
 * @function
 */
vec3.len = vec3.length;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec3.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    return x*x + y*y + z*z;
};

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
vec3.sqrLen = vec3.squaredLength;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
vec3.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
};

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
vec3.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
};

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
vec3.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2];
    var len = x*x + y*y + z*z;
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len);
        out[0] = a[0] * len;
        out[1] = a[1] * len;
        out[2] = a[2] * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
vec3.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
};

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
vec3.cross = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2];

    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
};

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
};

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.hermite = function (out, a, b, c, d, t) {
  var factorTimes2 = t * t,
      factor1 = factorTimes2 * (2 * t - 3) + 1,
      factor2 = factorTimes2 * (t - 2) + t,
      factor3 = factorTimes2 * (t - 1),
      factor4 = factorTimes2 * (3 - 2 * t);
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
vec3.bezier = function (out, a, b, c, d, t) {
  var inverseFactor = 1 - t,
      inverseFactorTimesTwo = inverseFactor * inverseFactor,
      factorTimes2 = t * t,
      factor1 = inverseFactorTimesTwo * inverseFactor,
      factor2 = 3 * t * inverseFactorTimesTwo,
      factor3 = 3 * factorTimes2 * inverseFactor,
      factor4 = factorTimes2 * t;
  
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  
  return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
vec3.random = function (out, scale) {
    scale = scale || 1.0;

    var r = glMatrix.RANDOM() * 2.0 * Math.PI;
    var z = (glMatrix.RANDOM() * 2.0) - 1.0;
    var zScale = Math.sqrt(1.0-z*z) * scale;

    out[0] = Math.cos(r) * zScale;
    out[1] = Math.sin(r) * zScale;
    out[2] = z * scale;
    return out;
};

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15];
    w = w || 1.0;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
};

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
vec3.transformMat3 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
};

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
vec3.transformQuat = function(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    return out;
};

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateX = function(out, a, b, c){
   var p = [], r=[];
	  //Translate point to the origin
	  p[0] = a[0] - b[0];
	  p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];

	  //perform rotation
	  r[0] = p[0];
	  r[1] = p[1]*Math.cos(c) - p[2]*Math.sin(c);
	  r[2] = p[1]*Math.sin(c) + p[2]*Math.cos(c);

	  //translate to correct position
	  out[0] = r[0] + b[0];
	  out[1] = r[1] + b[1];
	  out[2] = r[2] + b[2];

  	return out;
};

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateY = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[2]*Math.sin(c) + p[0]*Math.cos(c);
  	r[1] = p[1];
  	r[2] = p[2]*Math.cos(c) - p[0]*Math.sin(c);
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
vec3.rotateZ = function(out, a, b, c){
  	var p = [], r=[];
  	//Translate point to the origin
  	p[0] = a[0] - b[0];
  	p[1] = a[1] - b[1];
  	p[2] = a[2] - b[2];
  
  	//perform rotation
  	r[0] = p[0]*Math.cos(c) - p[1]*Math.sin(c);
  	r[1] = p[0]*Math.sin(c) + p[1]*Math.cos(c);
  	r[2] = p[2];
  
  	//translate to correct position
  	out[0] = r[0] + b[0];
  	out[1] = r[1] + b[1];
  	out[2] = r[2] + b[2];
  
  	return out;
};

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec3.forEach = (function() {
    var vec = vec3.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 3;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
        }
        
        return a;
    };
})();

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
vec3.angle = function(a, b) {
   
    var tempA = vec3.fromValues(a[0], a[1], a[2]);
    var tempB = vec3.fromValues(b[0], b[1], b[2]);
 
    vec3.normalize(tempA, tempA);
    vec3.normalize(tempB, tempB);
 
    var cosine = vec3.dot(tempA, tempB);

    if(cosine > 1.0) {
        return 0;
    }
    else if(cosine < -1.0) {
        return Math.PI;
    } else {
        return Math.acos(cosine);
    }     
};

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec3.str = function (a) {
    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec3.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2];
    var b0 = b[0], b1 = b[1], b2 = b[2];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)));
};

var vec4 = {};

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
vec4.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    return out;
};

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
vec4.clone = function(a) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
vec4.fromValues = function(x, y, z, w) {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
vec4.copy = function(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    return out;
};

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
vec4.set = function(out, x, y, z, w) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = w;
    return out;
};

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.add = function(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    return out;
};

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.subtract = function(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    return out;
};

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
vec4.sub = vec4.subtract;

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.multiply = function(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    out[3] = a[3] * b[3];
    return out;
};

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
vec4.mul = vec4.multiply;

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.divide = function(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    out[3] = a[3] / b[3];
    return out;
};

/**
 * Alias for {@link vec4.divide}
 * @function
 */
vec4.div = vec4.divide;

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
vec4.ceil = function (out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    out[3] = Math.ceil(a[3]);
    return out;
};

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
vec4.floor = function (out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    out[3] = Math.floor(a[3]);
    return out;
};

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.min = function(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    out[3] = Math.min(a[3], b[3]);
    return out;
};

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
vec4.max = function(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    out[3] = Math.max(a[3], b[3]);
    return out;
};

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
vec4.round = function (out, a) {
    out[0] = Math.round(a[0]);
    out[1] = Math.round(a[1]);
    out[2] = Math.round(a[2]);
    out[3] = Math.round(a[3]);
    return out;
};

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
vec4.scale = function(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    return out;
};

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
vec4.scaleAndAdd = function(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale);
    out[1] = a[1] + (b[1] * scale);
    out[2] = a[2] + (b[2] * scale);
    out[3] = a[3] + (b[3] * scale);
    return out;
};

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
vec4.distance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.distance}
 * @function
 */
vec4.dist = vec4.distance;

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
vec4.squaredDistance = function(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2],
        w = b[3] - a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
vec4.sqrDist = vec4.squaredDistance;

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
vec4.length = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return Math.sqrt(x*x + y*y + z*z + w*w);
};

/**
 * Alias for {@link vec4.length}
 * @function
 */
vec4.len = vec4.length;

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
vec4.squaredLength = function (a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    return x*x + y*y + z*z + w*w;
};

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
vec4.sqrLen = vec4.squaredLength;

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
vec4.negate = function(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = -a[3];
    return out;
};

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
vec4.inverse = function(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
};

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
vec4.normalize = function(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2],
        w = a[3];
    var len = x*x + y*y + z*z + w*w;
    if (len > 0) {
        len = 1 / Math.sqrt(len);
        out[0] = x * len;
        out[1] = y * len;
        out[2] = z * len;
        out[3] = w * len;
    }
    return out;
};

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
vec4.dot = function (a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
};

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec4} out
 */
vec4.lerp = function (out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2],
        aw = a[3];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    out[3] = aw + t * (b[3] - aw);
    return out;
};

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
vec4.random = function (out, scale) {
    scale = scale || 1.0;

    //TODO: This is a pretty awful way of doing this. Find something better.
    out[0] = glMatrix.RANDOM();
    out[1] = glMatrix.RANDOM();
    out[2] = glMatrix.RANDOM();
    out[3] = glMatrix.RANDOM();
    vec4.normalize(out, out);
    vec4.scale(out, out, scale);
    return out;
};

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
vec4.transformMat4 = function(out, a, m) {
    var x = a[0], y = a[1], z = a[2], w = a[3];
    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
    return out;
};

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
vec4.transformQuat = function(out, a, q) {
    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z;

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    out[3] = a[3];
    return out;
};

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
vec4.forEach = (function() {
    var vec = vec4.create();

    return function(a, stride, offset, count, fn, arg) {
        var i, l;
        if(!stride) {
            stride = 4;
        }

        if(!offset) {
            offset = 0;
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length);
        } else {
            l = a.length;
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
            fn(vec, vec, arg);
            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
        }
        
        return a;
    };
})();

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
vec4.str = function (a) {
    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.exactEquals = function (a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
};

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
vec4.equals = function (a, b) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
    return (Math.abs(a0 - b0) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
            Math.abs(a1 - b1) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
            Math.abs(a2 - b2) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a2), Math.abs(b2)) &&
            Math.abs(a3 - b3) <= glMatrix.EPSILON*Math.max(1.0, Math.abs(a3), Math.abs(b3)));
};

/**
 * @class Quaternion
 * @name quat
 */
var quat = {};

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
quat.create = function() {
    var out = new glMatrix.ARRAY_TYPE(4);
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
quat.rotationTo = (function() {
    var tmpvec3 = vec3.create();
    var xUnitVec3 = vec3.fromValues(1,0,0);
    var yUnitVec3 = vec3.fromValues(0,1,0);

    return function(out, a, b) {
        var dot = vec3.dot(a, b);
        if (dot < -0.999999) {
            vec3.cross(tmpvec3, xUnitVec3, a);
            if (vec3.length(tmpvec3) < 0.000001)
                vec3.cross(tmpvec3, yUnitVec3, a);
            vec3.normalize(tmpvec3, tmpvec3);
            quat.setAxisAngle(out, tmpvec3, Math.PI);
            return out;
        } else if (dot > 0.999999) {
            out[0] = 0;
            out[1] = 0;
            out[2] = 0;
            out[3] = 1;
            return out;
        } else {
            vec3.cross(tmpvec3, a, b);
            out[0] = tmpvec3[0];
            out[1] = tmpvec3[1];
            out[2] = tmpvec3[2];
            out[3] = 1 + dot;
            return quat.normalize(out, out);
        }
    };
})();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
quat.setAxes = (function() {
    var matr = mat3.create();

    return function(out, view, right, up) {
        matr[0] = right[0];
        matr[3] = right[1];
        matr[6] = right[2];

        matr[1] = up[0];
        matr[4] = up[1];
        matr[7] = up[2];

        matr[2] = -view[0];
        matr[5] = -view[1];
        matr[8] = -view[2];

        return quat.normalize(out, quat.fromMat3(out, matr));
    };
})();

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
quat.clone = vec4.clone;

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
quat.fromValues = vec4.fromValues;

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
quat.copy = vec4.copy;

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
quat.set = vec4.set;

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
quat.identity = function(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 1;
    return out;
};

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
quat.setAxisAngle = function(out, axis, rad) {
    rad = rad * 0.5;
    var s = Math.sin(rad);
    out[0] = s * axis[0];
    out[1] = s * axis[1];
    out[2] = s * axis[2];
    out[3] = Math.cos(rad);
    return out;
};

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
quat.getAxisAngle = function(out_axis, q) {
    var rad = Math.acos(q[3]) * 2.0;
    var s = Math.sin(rad / 2.0);
    if (s != 0.0) {
        out_axis[0] = q[0] / s;
        out_axis[1] = q[1] / s;
        out_axis[2] = q[2] / s;
    } else {
        // If s is zero, return any axis (no rotation - axis does not matter)
        out_axis[0] = 1;
        out_axis[1] = 0;
        out_axis[2] = 0;
    }
    return rad;
};

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
quat.add = vec4.add;

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
quat.multiply = function(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    out[0] = ax * bw + aw * bx + ay * bz - az * by;
    out[1] = ay * bw + aw * by + az * bx - ax * bz;
    out[2] = az * bw + aw * bz + ax * by - ay * bx;
    out[3] = aw * bw - ax * bx - ay * by - az * bz;
    return out;
};

/**
 * Alias for {@link quat.multiply}
 * @function
 */
quat.mul = quat.multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
quat.scale = vec4.scale;

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateX = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + aw * bx;
    out[1] = ay * bw + az * bx;
    out[2] = az * bw - ay * bx;
    out[3] = aw * bw - ax * bx;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateY = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        by = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw - az * by;
    out[1] = ay * bw + aw * by;
    out[2] = az * bw + ax * by;
    out[3] = aw * bw - ay * by;
    return out;
};

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
quat.rotateZ = function (out, a, rad) {
    rad *= 0.5; 

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bz = Math.sin(rad), bw = Math.cos(rad);

    out[0] = ax * bw + ay * bz;
    out[1] = ay * bw - ax * bz;
    out[2] = az * bw + aw * bz;
    out[3] = aw * bw - az * bz;
    return out;
};

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
quat.calculateW = function (out, a) {
    var x = a[0], y = a[1], z = a[2];

    out[0] = x;
    out[1] = y;
    out[2] = z;
    out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
    return out;
};

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
quat.dot = vec4.dot;

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 * @function
 */
quat.lerp = vec4.lerp;

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {quat} out
 */
quat.slerp = function (out, a, b, t) {
    // benchmarks:
    //    http://jsperf.com/quaternion-slerp-implementations

    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
        bx = b[0], by = b[1], bz = b[2], bw = b[3];

    var        omega, cosom, sinom, scale0, scale1;

    // calc cosine
    cosom = ax * bx + ay * by + az * bz + aw * bw;
    // adjust signs (if necessary)
    if ( cosom < 0.0 ) {
        cosom = -cosom;
        bx = - bx;
        by = - by;
        bz = - bz;
        bw = - bw;
    }
    // calculate coefficients
    if ( (1.0 - cosom) > 0.000001 ) {
        // standard case (slerp)
        omega  = Math.acos(cosom);
        sinom  = Math.sin(omega);
        scale0 = Math.sin((1.0 - t) * omega) / sinom;
        scale1 = Math.sin(t * omega) / sinom;
    } else {        
        // "from" and "to" quaternions are very close 
        //  ... so we can do a linear interpolation
        scale0 = 1.0 - t;
        scale1 = t;
    }
    // calculate final values
    out[0] = scale0 * ax + scale1 * bx;
    out[1] = scale0 * ay + scale1 * by;
    out[2] = scale0 * az + scale1 * bz;
    out[3] = scale0 * aw + scale1 * bw;
    
    return out;
};

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount
 * @returns {quat} out
 */
quat.sqlerp = (function () {
  var temp1 = quat.create();
  var temp2 = quat.create();
  
  return function (out, a, b, c, d, t) {
    quat.slerp(temp1, a, d, t);
    quat.slerp(temp2, b, c, t);
    quat.slerp(out, temp1, temp2, 2 * t * (1 - t));
    
    return out;
  };
}());

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
quat.invert = function(out, a) {
    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
        invDot = dot ? 1.0/dot : 0;
    
    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

    out[0] = -a0*invDot;
    out[1] = -a1*invDot;
    out[2] = -a2*invDot;
    out[3] = a3*invDot;
    return out;
};

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
quat.conjugate = function (out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    out[3] = a[3];
    return out;
};

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 * @function
 */
quat.length = vec4.length;

/**
 * Alias for {@link quat.length}
 * @function
 */
quat.len = quat.length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
quat.squaredLength = vec4.squaredLength;

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
quat.sqrLen = quat.squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
quat.normalize = vec4.normalize;

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
quat.fromMat3 = function(out, m) {
    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
    // article "Quaternion Calculus and Fast Animation".
    var fTrace = m[0] + m[4] + m[8];
    var fRoot;

    if ( fTrace > 0.0 ) {
        // |w| > 1/2, may as well choose w > 1/2
        fRoot = Math.sqrt(fTrace + 1.0);  // 2w
        out[3] = 0.5 * fRoot;
        fRoot = 0.5/fRoot;  // 1/(4w)
        out[0] = (m[5]-m[7])*fRoot;
        out[1] = (m[6]-m[2])*fRoot;
        out[2] = (m[1]-m[3])*fRoot;
    } else {
        // |w| <= 1/2
        var i = 0;
        if ( m[4] > m[0] )
          i = 1;
        if ( m[8] > m[i*3+i] )
          i = 2;
        var j = (i+1)%3;
        var k = (i+2)%3;
        
        fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
        out[i] = 0.5 * fRoot;
        fRoot = 0.5 / fRoot;
        out[3] = (m[j*3+k] - m[k*3+j]) * fRoot;
        out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
        out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
    }
    
    return out;
};

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
quat.str = function (a) {
    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
};

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.exactEquals = vec4.exactEquals;

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
quat.equals = vec4.equals;;/**
 * @class Generic map of IDs to items - can generate own IDs or accept given IDs. IDs should be strings in order to not
 * clash with internally generated IDs, which are numbers.
 * @private
 */
var SceneJS_Map = function(items, _baseId) {

    /**
     * @property Items in this map
     */
    this.items = items || [];


    var baseId = _baseId || 0;
    var lastUniqueId = baseId + 1;

    /**
     * Adds an item to the map and returns the ID of the item in the map. If an ID is given, the item is
     * mapped to that ID. Otherwise, the map automatically generates the ID and maps to that.
     *
     * id = myMap.addItem("foo") // ID internally generated
     *
     * id = myMap.addItem("foo", "bar") // ID is "foo"
     *
     */
    this.addItem = function() {

        var item;

        if (arguments.length == 2) {

            var id = arguments[0];

            item = arguments[1];

            if (this.items[id]) { // Won't happen if given ID is string
                throw SceneJS_error.fatalError(SceneJS.errors.ID_CLASH, "ID clash: '" + id + "'");
            }

            this.items[id] = item;

            return id;

        } else {

            while (true) {

                item = arguments[0];
                var findId = lastUniqueId++;

                if (!this.items[findId]) {
                    this.items[findId] = item;
                    return findId;
                }
            }
        }
    };

    /**
     * Removes the item of the given ID from the map
     */
    this.removeItem = function(id) {
        delete this.items[id];
    };
};;/**
 * The SceneJS object.
 */
var SceneJS = new (function () {

    /**
     * This SceneJS version
     */
    this.VERSION = '3.2';

    this._baseStateId = 0;

    // Pub/sub support
    this._handleMap = new SceneJS_Map(); // Subscription handle pool
    this._topicSubs = {}; // A [handle -> callback] map for each topic name
    this._handleTopics = {}; // Maps handles to topic names
    this._topicPubs = {}; // Maps topics to publications

    /**
     * @property {SceneJS_Engine} Engines currently in existance
     */
    this._engines = {};

    this._engineIds = new SceneJS_Map();

    this.timer = window.performance || window.Date;

    this.WEBGL_INFO = (function() {
        var info = {
            WEBGL: false
        };

        var canvas = document.createElement("canvas");

        if (!canvas) {
            return info;
        }

        var gl = canvas.getContext("webgl", { stencil:true, antialias: true }) || canvas.getContext("experimental-webgl", { antialias: true });

        info.WEBGL = !!gl;

        if (!info.WEBGL) {
            return info;
        }

        info.ANTIALIAS = gl.getContextAttributes().antialias;

        if (gl.getShaderPrecisionFormat) {
            if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                info.FS_MAX_FLOAT_PRECISION = "highp";
            } else if (gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                info.FS_MAX_FLOAT_PRECISION = "mediump";
            } else {
                info.FS_MAX_FLOAT_PRECISION = "lowp";
            }
        } else {
            info.FS_MAX_FLOAT_PRECISION = "mediump";
        }

        info.DEPTH_BUFFER_BITS = gl.getParameter(gl.DEPTH_BITS);
        info.MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        info.MAX_CUBE_MAP_SIZE = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
        info.MAX_RENDERBUFFER_SIZE = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
        info.MAX_TEXTURE_UNITS =  gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        info.MAX_VERTEX_ATTRIBS = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        info.MAX_VERTEX_UNIFORM_VECTORS = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        info.MAX_FRAGMENT_UNIFORM_VECTORS = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        info.MAX_VARYING_VECTORS = gl.getParameter(gl.MAX_VARYING_VECTORS);

        info.SUPPORTED_EXTENSIONS = {};

        gl.getSupportedExtensions().forEach(function(ext) {
            info.SUPPORTED_EXTENSIONS[ext] = true;
        });

        return info;
    })();

    this.DISPLAY_FLAGS = {
        FOG_LINEAR: 1,
        FOG_EXP:    2,
        FOG_EXP2:   3
    };

    this.TEXTURE_FLAGS = {
        baseColor: 1,
        specular:  1 << 1,
        emit:      1 << 2,
        alpha:     1 << 3,
        normals:   1 << 4,
        shine:     1 << 5,
        add:       1 << 6,
        multiply:  1 << 7,
        over:      1 << 8
    };

    this.PROPERTY_FLAGS = {
        PICKING:            1,
        ENABLED:            1 << 1,
        BACKFACES:          1 << 2,
        REFLECTIVE:         1 << 3,
        SOLID:              1 << 4,
        SKYBOX:             1 << 5,
        XRAY:               1 << 6,
        CCW:                1 << 7,
        XRAY_ENABLED:       1 << 8,
        DEPTH_MASK:         1 << 9,
        ROUND_POINTS:       1 << 10,
        BILLBOARD:          1 << 11
    };

    this.KD_TREE_MAX_DEPTH = 10;
    this.KD_TREE_MIN_TRIANGLES = 20;

    /**
     * Publishes to a topic.
     *
     * Immediately notifies existing subscriptions to that topic, retains the publication to give to
     * any subsequent notifications on that topic as they are made.
     *
     * @param {String} topic Publication topic
     * @param {Object} pub The publication
     * @param {Boolean} [forget] When true, the publication will be sent to subscribers then forgotten, so that any
     * subsequent subscribers will not receive it
     * @private
     */
    this.publish = function (topic, pub, forget) {
        if (!forget) {
            this._topicPubs[topic] = pub; // Save notification
        }
        var subsForTopic = this._topicSubs[topic];
        if (subsForTopic) { // Notify subscriptions
            for (var handle in subsForTopic) {
                if (subsForTopic.hasOwnProperty(handle)) {
                    subsForTopic[handle].call(this, pub);
                }
            }
        }
    };

    /**
     * Removes a topic publication
     *
     * Immediately notifies existing subscriptions to that topic, sending them each a null publication.
     *
     * @param topic Publication topic
     * @private
     */
    this.unpublish = function (topic) {
        var subsForTopic = this._topicSubs[topic];
        if (subsForTopic) { // Notify subscriptions
            for (var handle in subsForTopic) {
                if (subsForTopic.hasOwnProperty(handle)) {
                    subsForTopic[handle].call(this, null);
                }
            }
        }
        delete this._topicPubs[topic];
    };


    /**
     * Listen for data changes at a particular location
     *
     * <p>Your callback will be triggered for
     * the initial data and again whenever the data changes. Use {@link #off} to stop receiving updates.</p>
     *
     * <p>The callback is be called with SceneJS as scope.</p>
     *
     * @param {String} location Publication location
     * @param {Function(data)} callback Called when fresh data is available at the location
     * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
     */
    this.on = function (topic, callback) {
        var subsForTopic = this._topicSubs[topic];
        if (!subsForTopic) {
            subsForTopic = {};
            this._topicSubs[topic] = subsForTopic;
        }
        var handle = this._handleMap.addItem(); // Create unique handle
        subsForTopic[handle] = callback;
        this._handleTopics[handle] = topic;
        var pub = this._topicPubs[topic];
        if (pub) { // A publication exists, notify callback immediately
            callback.call(this, pub);
        }
        return handle;
    };

    /**
     * Unsubscribes from a publication that was previously made with {@link #on}.
     * @param handle Publication handle
     */
    this.off = function (handle) {
        var topic = this._handleTopics[handle];
        if (topic) {
            delete this._handleTopics[handle];
            var topicSubs = this._topicSubs[topic];
            if (topicSubs) {
                delete topicSubs[handle];
            }
            this._handleMap.removeItem(handle); // Release handle
            if (topic == "rendered") {
                this._engine.branchDirty(this);
            }
        }
    };

    /**
     * Listens for exactly one data update at the specified location, and then stops listening.
     * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
     * @param {String} location Data location to listen to
     * @param {Function(data)} callback Called when fresh data is available at the location
     */
    this.once = function (topic, callback) {
        var self = this;
        var sub = this.on(topic,
            function (pub) {
                self.off(sub);
                callback(pub);
            });
    };

    /**
     * Creates a new scene from the given JSON description and begins rendering it
     *
     * @param {String} json JSON scene description
     * @param {*} options Optional options
     * @param {Boolean} options.simulateWebGLContextLost Set true to enable simulation of lost WebGL context (has performance impact)
     * @returns {SceneJS.Scene} New scene
     */
    this.createScene = function (json, options) {

       json = json || {};

        if (json.id) {
            if (this._engines[json.id]) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "Scene already exists with this ID: '" + json.id + "'");
            }
            this._engineIds.addItem(json.id, {});
        } else {
            json.id = this._engineIds.addItem({});
        }

        var engine = new SceneJS_Engine(json, options);

        this._engines[json.id] = engine;

        engine.scene.start(options);

        return engine.scene;
    };

    /**
     * Gets an existing scene
     *
     * @param {String} sceneId ID of target scene
     * @deprecated
     * @returns {SceneJS.Scene} The selected scene
     */
    this.scene = function (sceneId) {

        var engine = this._engines[sceneId];

        return engine ? engine.scene : null;
    };

    /**
     * Gets an existing scene.
     *
     * When no scene ID is given, the first scene found is returned. This is a shorthand convenience for
     * easy scripting when only one scene is defined.
     *
     * @param {String} [sceneId] ID of target scene
     * @returns {SceneJS.Scene} The selected scene
     */
    this.getScene = function (sceneId) {

        if (!sceneId) {
            for (var sceneId in this._engines) {
                if (this._engines.hasOwnProperty(sceneId)) {
                    return this._engines[sceneId].scene;
                }
            }
        }

        var engine = this._engines[sceneId];

        return engine ? engine.scene : null;
    };

    /**
     * Gets existing scenes
     *
     * @returns  Existing scenes, mapped to their IDs
     */
    this.getScenes = function () {

        var scenes = {};

        for (var sceneId in this._engines) {
            if (this._engines.hasOwnProperty(sceneId)) {
                scenes[sceneId] = this._engines[sceneId].scene;
            }
        }

        return scenes;
    };

    /**
     * Tests if the given object is an array
     * @private
     */
    this._isArray = function (testObject) {
        return testObject && !(testObject.propertyIsEnumerable('length'))
            && typeof testObject === 'object' && typeof testObject.length === 'number';
    };

    /**
     *
     */
    this._shallowClone = function (o) {
        var o2 = {};
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /**
     * Add properties of o to o2 where undefined or null on o2
     * @private
     */
    this._applyIf = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                if (o2[name] == undefined || o2[name] == null) {
                    o2[name] = o[name];
                }
            }
        }
        return o2;
    };

    /**
     * Add properties of o to o2, overwriting them on o2 if already there.
     * The optional clear flag causes properties on o2 to be cleared first
     * @private
     */
    this._apply = function (o, o2, clear) {
        var name;
        if (clear) {
            for (name in o2) {
                if (o2.hasOwnProperty(name)) {
                    delete o2[name];
                }
            }
        }
        for (name in o) {
            if (o.hasOwnProperty(name) && o[name] != undefined) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    /**
     * Tests is an object is empty
     * @param obj
     * @returns {boolean}
     * @private
     */
    this._isEmpty =function(obj) {
        // null and undefined are "empty"
        if (obj == null) return true;
        // Assume if it has a length property with a non-zero value
        // that that property is correct.
        if (obj.length > 0)    return false;
        if (obj.length === 0)  return true;
        // Otherwise, does it have any properties of its own?
        // Note that this doesn't handle
        // toString and valueOf enumeration bugs in IE < 9
        for (var key in obj) {
            if (hasOwnProperty.call(obj, key)) return false;
        }
        return true;
    };

    /**
     * Tests if the given value is a number
     * @param value
     * @returns {boolean}
     * @private
     */
    this._isNumeric = function (value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
    };

    /**
    * Shim for slicing arrays regardless of the array type.
    * (Primarily because TypedArray.prototype.slice is
    * not supported on all platforms)
    */
    this._sliceArray = function(array, start, end) {
        if (array.slice) {
            return array.slice(start, end);
        }

        start = start || 0;
        end = end || array.length;

        var length = end - start;
        var newArray = new array.constructor(length);

        for (var i = 0; i < length; i++) {
            newArray[i] = array[start + i];
        }

        return newArray;
    };

    /**
        Load binary data.
    */
    this._loadBinary = function (src, callback) {
        var request = new XMLHttpRequest();
        request.responseType = "arraybuffer";
        request.open("GET", src);

        request.onload = function() {
            callback(request.response);
        };

        request.send(null);
    };

    /**
        Get a WebGL extension, including if prefixed.
    */
    var extensionPrefixes = ["", "MOZ_", "WEBKIT_"];

    this.checkExtension = function(extension) {
        for (var i = 0, len = extensionPrefixes.length; i < len; i++) {
            if (this.WEBGL_INFO.SUPPORTED_EXTENSIONS[extensionPrefixes[i] + extension]) {
                return true;
            }
        }

        return false;
    };

    this._getExtension = function(gl, extension) {
        for (var i = 0, len = extensionPrefixes.length; i < len; i++) {
            var ext = gl.getExtension(extensionPrefixes[i] + extension);
            if (ext) {
                return ext;
            }
        }

        return null;
    };

    this.printGraph = function(node) {
        printGraph(node, 0);
    }

    /**
     * Resets SceneJS, destroying all existing scenes
     */
    this.reset = function () {

        var temp = [];

        for (var id in this._engines) { // Collect engines to destroy
            if (this._engines.hasOwnProperty(id)) {

                temp.push(this._engines[id]);

                delete this._engines[id];

                this._engineIds.removeItem(id);
            }
        }

        while (temp.length > 0) { // Destroy the engines
            temp.pop().destroy();
        }

        SceneJS_events.fireEvent(SceneJS_events.RESET);
    };

    function printGraph(node, level) {
        var padding = "";
        var i;

        for (i = 0; i < level; i++) {
            padding += " ";
        }
        padding += "-- "
        console.log(padding + node.type + " (id: " + node.id + ", coreId: " + node.coreId + ")");

        for (i = 0; i < node.nodes.length; i++) {
            printGraph(node.nodes[i], level + 1);
        }
    }


})();
;/**
 *  @private
 */
var SceneJS_eventManager = function () {

    this._handlerIds = new SceneJS_Map();

    this.typeHandlers = {};
};

/**
 *
 */
SceneJS_eventManager.prototype.createEvent = function (type) {

    if (this.typeHandlers[type]) {
        return;
    }

    this.typeHandlers[type] = {
        handlers:{},
        numSubs:0
    };
};

/**
 * Subscribes to an event defined on this event manager
 *
 * @param {String} type Event type one of the values in SceneJS_events
 * @param {Function} callback Handler function that will accept whatever parameter object accompanies the event
 * @return {String} handle Handle to the event binding
 */
SceneJS_eventManager.prototype.onEvent = function (type, callback) {

    var handlersForType = this.typeHandlers[type] || (this.typeHandlers[type] = {
        handlers:{},
        numSubs:0
    });

    var handlerId = this._handlerIds.addItem(type);

    var handlers = handlersForType.handlers;
    handlers[handlerId] = callback;
    handlersForType.numSubs++;

    return handlerId;
};

/**
 *
 */
SceneJS_eventManager.prototype.fireEvent = function (type, params) {

    var handlersForType = this.typeHandlers[type] || (this.typeHandlers[type] = {
        handlers:{},
        numSubs:0
    });

    if (handlersForType.numSubs > 0) {

        var handlers = handlersForType.handlers;

        for (var handlerId in handlers) {
            if (handlers.hasOwnProperty(handlerId)) {
                handlers[handlerId](params);
            }
        }
    }
};

/**
 * Unsubscribes to an event previously subscribed to on this manager
 *
 * @param {String} handlerId Subscription handle
 */
SceneJS_eventManager.prototype.unEvent = function (handlerId) {

    var type = this._handlerIds.items[handlerId];
    if (!type) {
        return;
    }

    this._handlerIds.removeItem(handlerId);

    var handlers = this.typeHandlers[type];

    if (!handlers) {
        return;
    }

    delete handlers[handlerId];
    this.typeHandlers[type].numSubs--;
};
;/**
 *  @private
 */
var SceneJS_events = new (function () {

    this.ERROR = 0;
    this.RESET = 1;                         // SceneJS framework reset
    this.NODE_CREATED = 2;                 // Scene has just been created
    this.SCENE_CREATED = 3;                 // Scene has just been created
    this.SCENE_COMPILING = 4;               // Scene about to be compiled and drawn
    this.SCENE_DESTROYED = 5;               // Scene just been destroyed
    this.OBJECT_COMPILING = 6;
    this.WEBGL_CONTEXT_LOST = 7;
    this.WEBGL_CONTEXT_RESTORED = 8;
    this.RENDER = 9;

    /* Priority queue for each type of event
     */
    var events = [];

    /**
     * Registers a handler for the given event and returns a subscription handle
     *
     * The handler can be registered with an optional priority number which specifies the order it is
     * called among the other handler already registered for the event.
     *
     * So, with n being the number of commands registered for the given event:
     *
     * (priority <= 0)      - command will be the first called
     * (priority >= n)      - command will be the last called
     * (0 < priority < n)   - command will be called at the order given by the priority
     * @private
     * @param type Event type - one of the values in SceneJS_events
     * @param command - Handler function that will accept whatever parameter object accompanies the event
     * @param priority - Optional priority number (see above)
     * @return {String} - Subscription handle
     */
    this.addListener = function (type, command, priority) {

        var list = events[type];

        if (!list) {
            list = [];
            events[type] = list;
        }

        var handler = {
            command:command,
            priority:(priority == undefined) ? list.length : priority
        };

        var index = -1;

        for (var i = 0, len = list.length; i < len; i++) {
            if (!list[i]) {
                index = i;
                break;
            }
        }

        if (index < 0) {
            list.push(handler);
            index = list.length - 1;
        }

//
//        for (var i = 0; i < list.length; i++) {
//            if (list[i].priority > handler.priority) {
//                list.splice(i, 0, handler);
//                return i;
//            }
//        }


        var handle = type + "." + index;

        return handle;
    };

    /**
     * Removes a listener
     * @param handle Subscription handle
     */
    this.removeListener = function (handle) {

        var lastIdx = handle.lastIndexOf(".");

        var type = parseInt(handle.substr(0, lastIdx));
        var index = parseInt(handle.substr(lastIdx + 1));

        var list = events[type];

        if (!list) {
            return;
        }

        delete list[index];
    };

    /**
     * @private
     */
    this.fireEvent = function (type, params) {

        var list = events[type];

        if (list) {
            params = params || {};
            for (var i = 0; i < list.length; i++) {
                if (list[i]) {
                    list[i].command(params);
                }
            }
        }
    };

})();


/**
 * Subscribe to SceneJS events
 * @deprecated
 */
SceneJS.bind = function (name, func) {
    switch (name) {

        case "error" :

            return SceneJS_events.addListener(SceneJS_events.ERROR, func);
            break;

        case "reset" :

            return SceneJS_events.addListener(
                SceneJS_events.RESET,
                function () {
                    func();
                });
            break;

        case "webglcontextlost" :

            return SceneJS_events.addListener(
                SceneJS_events.WEBGL_CONTEXT_LOST,
                function (params) {
                    func(params);
                });
            break;

        case "webglcontextrestored" :

            return SceneJS_events.addListener(
                SceneJS_events.WEBGL_CONTEXT_RESTORED,
                function (params) {
                    func(params);
                });
            break;

        default:
            throw SceneJS_error.fatalError("SceneJS.bind - this event type not supported: '" + name + "'");
    }
};

/* Subscribe to SceneJS events
 * @deprecated
 */
SceneJS.onEvent = SceneJS.bind;

/* Unsubscribe from event
 */
SceneJS.unEvent = function (handle) {
    return SceneJS_events.removeListener(handle);
};

SceneJS.subscribe = SceneJS.addListener = SceneJS.onEvent = SceneJS.bind;

SceneJS.unsubscribe = SceneJS.unEvent;


SceneJS.on = SceneJS.onEvent;
SceneJS.off = SceneJS.unEvent;



;/**
 *
 */
var SceneJS_Canvas = function (id, canvasId, contextAttr, options) {

    /**
     * ID of this canvas
     */
    this.canvasId;

    if (!canvasId) {
        // Automatic default canvas
        canvasId = "canvas-" + id;
        var body = document.getElementsByTagName("body")[0];
        var div = document.createElement('div');
        var style = div.style;
        style.height = "100%";
        style.width = "100%";
        style.padding = "0";
        style.margin = "0";
        style.left = "0";
        style.top = "0";
        style.position = "absolute";
        // style["z-index"] = "10000";
        div.innerHTML += '<canvas id="' + canvasId + '" style="width: 100%; height: 100%; margin: 0; padding: 0;"></canvas>';
        body.appendChild(div);
    }

    // Bind to canvas
    var canvas = document.getElementById(canvasId);
    if (!canvas) {
        throw SceneJS_error.fatalError(SceneJS.errors.CANVAS_NOT_FOUND,
            "SceneJS.Scene attribute 'canvasId' does not match any elements in the page");
    }
    this.canvasId = canvasId;

    /**
     * WebGL context options
     */
    this.options = options || {};

    this.canvas = canvas;

    if (this.options.simulateWebGLContextLost) {
        if (window.WebGLDebugUtils) {
            this.canvas = WebGLDebugUtils.makeLostContextSimulatingCanvas(this.canvas)
        } else {
            console.error("To simulate context loss, please include WebGLDebugUtils");
        }
    }

    this.resolutionScaling = this.options.resolutionScaling || 1;

    // If the canvas uses css styles to specify the sizes make sure the basic
    // width and height attributes match or the WebGL context will use 300 x 150

    this.canvas.width = this.canvas.clientWidth * this.resolutionScaling;
    this.canvas.height = this.canvas.clientHeight * this.resolutionScaling;

    /**
     * Attributes given when initialising the WebGL context
     */
    this.contextAttr = contextAttr || {};
    this.contextAttr.alpha = true;

    this.contextAttr["stencil"] = true;

    /**
     * The WebGL context
     */
    this.gl = null;

    /**
     * True when WebGL 2 support is enabled.
     *
     * @property webgl2
     * @type {Boolean}
     * @final
     */
    this.webgl2 = false; // Will set true in _initWebGL if WebGL is requested and we succeed in getting it.

    this.initWebGL();
};

/**
 * Names of recognised WebGL contexts
 */
SceneJS_Canvas.prototype._WEBGL_CONTEXT_NAMES = [
    "webgl",
    "experimental-webgl",
    "webkit-3d",
    "moz-webgl",
    "moz-glweb20"
];

/**
 * Initialise the WebGL context

 */
SceneJS_Canvas.prototype.initWebGL = function () {

    if (this.options.webgl2 === true) {
        try {
            this.gl = this.canvas.getContext("webgl2", this.contextAttr);
        } catch (e) { // Try with next context name
        }
        if (!this.gl) {
            console.log('Failed to get a WebGL 2 context - defaulting to WebGL 1.');
        } else {
            this.webgl2 = true;
        }
    }

    if (!this.gl) {
        for (var i = 0; !this.gl && i < this._WEBGL_CONTEXT_NAMES.length; i++) {
            try {
                this.gl = this.canvas.getContext(this._WEBGL_CONTEXT_NAMES[i], this.contextAttr);
            } catch (e) { // Try with next context name
            }
        }
    }

    if (!this.gl) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.WEBGL_NOT_SUPPORTED,
            'Failed to get a WebGL context');
    }
};


/**
 * Simulate a lost WebGL context.
 * Only works if the simulateWebGLContextLost was given as an option to the canvas' constructor.
 */
SceneJS_Canvas.prototype.loseWebGLContext = function () {
    if (this.options.simulateWebGLContextLost) {
        this.canvas.loseContext();
    }
};

/**
 * Set canvas size multiplier for supersample anti-aliasing
 */
SceneJS_Canvas.prototype.setResolutionScaling = function (resolutionScaling) {
    this.resolutionScaling = resolutionScaling;
    this.canvas.width = this.canvas.clientWidth * resolutionScaling;
    this.canvas.height = this.canvas.clientHeight * resolutionScaling;
};


;/**
 * @class A container for a scene graph and its display
 *
 *
 * @private
 */
var SceneJS_Engine = function (json, options) {
    options = options || {};

    json.type = "scene"; // The type property supplied by user on the root JSON node is ignored - would always be 'scene'

    /**
     * ID of this engine, also the ID of this engine's {@link SceneJS.Scene}
     * @type String
     */
    this.id = json.id;


    /**
     * Number of times the scene is drawn each time it's rendered.
     * <p>This is useful for when we need to do things like render for left and right eyes.
     * @type {*|number}
     */
    this._numPasses = json.numPasses || 1;

    /**
     * When doing multiple passes per frame, specifies whether to clear the
     * canvas before each pass (true) or just before the first pass (false, default).
     * @type Boolean
     */
    this._clearEachPass = !!json.clearEachPass;

    /**
     * Canvas and GL context for this engine
     */
    this.canvas = new SceneJS_Canvas(this.id, json.canvasId, json.contextAttr, options);

    /**
     * Manages firing of and subscription to events
     */
    this.events = new SceneJS_eventManager();

    /**
     * State core factory - creates, stores, shares and destroys cores
     */
    this._coreFactory = new SceneJS_CoreFactory();

    /**
     * Manages creation, recycle and destruction of {@link SceneJS.Node} instances for this engine's scene graph
     */
    this._nodeFactory = new SceneJS_NodeFactory();

    /**
     * Tracks statistics within this engine, such as numbers of
     * scenes, textures, geometries etc.
     *
     * @property stats
     * @type {*}
     * @final
     */
    this.stats = {
        build: {
            version: SceneJS.VERSION
        },
        client: {
            browser: (navigator && navigator.userAgent) ? navigator.userAgent : "n/a"
        },
        components: {},
        state: {
            programs: 0,
        },
        geometry: {
            meshes: 0,
            vertices: 0,
            triangles: 0,
        },
        textures: {},
        load: {
            sceneGraphCompilation: 0,
            shaderCompilation: 0,
            programCompilation: 0
        },
        memory: {
            positions: 0,
            colors: 0,
            normals: 0,
            uvs: 0,
            indices: 0,
            morphPositions: 0,
            morphNormals: 0,
            textures: 0,
            tangents: 0,
            pickPositions: 0,
            pickColors: 0
        },
        frame: {
            frameCount: 0,
            cpuTime: 0,
            gpuTime: 0,
            useProgram: 0,
            bindTexture: 0,
            bindArray: 0,
            drawElements: 0,
            drawArrays: 0,
            drawChunks: 0
        }
    };

    /**
     * The engine's scene renderer
     * @type SceneJS_Display
     */
    this.display = new SceneJS_Display(this.stats, {
        canvas: this.canvas,
        transparent: json.transparent,
        dof: json.dof,
        depthSort: options.depthSort
    });

    /**
     * Flags the entirety of the scene graph as needing to be (re)compiled into the display
     */
    this.sceneDirty = false;

    /**
     * Flag set when at least one branch of the scene graph needs recompilation
     */
    this._sceneBranchesDirty = false;

    /**
     * Flag to prevent engine from re-compiling the scene graph
     */
    this._compilationPaused = false;

    /**
     * List of nodes scheduled for destruction by #destroyNode
     * Destructions are done in a batch at the end of each render so as not to disrupt the render.
     */
    this._nodesToDestroy = [];

    /**
     * Number of nodes in destruction list
     */
    this._numNodesToDestroy = 0;

    /**
     * Number of to wait before rendering each frame.
     */
    this.ticksPerRender = Math.max(options.ticksPerRender || 1, 1);

    /**
     * Flag which is set while this engine is running - set after call to #start, unset after #stop or #pause
     */
    this.running = false;

    /**
     * Flag which is set while this engine is paused - set after call to #pause, unset after #stop or #start
     */
    this.paused = false;

    /**
     * Flag set once this engine has been destroyed
     */
    this.destroyed = false;

    this.cpuTimer = SceneJS.timer;

    this.gpuTimer = this.canvas.gl.getExtension("EXT_disjoint_timer_query") || null;

    if (this.gpuTimer) {
        this.gpuTimerQuery = this.gpuTimer.createQueryEXT(this.gpuTimer.TIME_ELAPSED_EXT);
    }

    /**
     * The current scene graph status
     */
    this.sceneStatus = {
        nodes: {}, // Status for each node
        numTasks: 0  // Number of loads currently in progress
    };

    var self = this;


    // Create scene root first, then create its subnodes
    // This way nodes can access the scene in their constructors
    var nodes = json.nodes;
    json.nodes = [];
    this.scene = this.createNode(json); // Create scene root

    if (nodes) {
        json.nodes = nodes;
        this.scene.addNodes(nodes); // then create sub-nodes
    }

    SceneJS_events.addListener(SceneJS_events.RENDER, function (event) {
        self.scene.publish("render", event);
    });

    this.canvas.canvas.addEventListener(// WebGL context lost
        "webglcontextlost",
        function (event) {
            event.preventDefault();
            self.stop();
            SceneJS_events.fireEvent(SceneJS_events.WEBGL_CONTEXT_LOST, {scene: self.scene});
        },
        false);

    this.canvas.canvas.addEventListener(// WebGL context recovered
        "webglcontextrestored",
        function (event) {
            self.canvas.initWebGL();
            self.gpuTimer = self.canvas.gl.getExtension("EXT_disjoint_timer_query");
            if (self.gpuTimer) {
                self.gpuTimerQuery = self.gpuTimer.createQueryEXT(self.gpuTimer.TIME_ELAPSED_EXT);
            }
            self._coreFactory.webglRestored();  // Reallocate WebGL resources for node state cores
            self.display.webglRestored(); // Reallocate shaders and re-cache shader var locations for display state chunks
            SceneJS_events.fireEvent(SceneJS_events.WEBGL_CONTEXT_RESTORED, {scene: self.scene});
            self.start();
        },
        false);
};

/**
 * Sets the number of times the scene is drawn on each render.
 * <p>This is useful for when we need to do things like render for left and right eyes.
 * @param {Number} numPasses The number of times the scene is drawn on each frame.
 */
SceneJS_Engine.prototype.setNumPasses = function (numPasses) {
    this._numPasses = numPasses;
};

/**
 *  When doing multiple passes per frame, specifies whether to clear the
 * canvas before each pass (true) or just before the first pass (false).
 *
 * <p>This is useful for when we need to do things like render a separate pass to a stereo framebuffer for left and right eyes,
 * where we want to clear the buffer before each pass.</p>
 *
 * @param {Boolean} clearEachPass True to clear before each pass (default is false).
 */
SceneJS_Engine.prototype.setClearEachPass = function (clearEachPass) {
    this._clearEachPass = clearEachPass;
};

/**
 * Simulate a lost WebGL context.
 * Only works if the simulateWebGLContextLost was given as an option to the engine's constructor.
 */
SceneJS_Engine.prototype.loseWebGLContext = function () {
    this.canvas.loseWebGLContext();
};

/**
 * Returns true if the given node type is currently loaded (ie. load not required)
 * @param type
 */
SceneJS_Engine.prototype.hasNodeType = function (type) {
    return !!SceneJS_NodeFactory.nodeTypes[type];
};

/**
 * Creates a node subtree from JSON. The root node will an orphan.
 */
SceneJS_Engine.prototype.createNode = function (json) {

    this._doDestroyNodes(); // Do buffered destroys now to avoid potential ID clashes

    json.type = json.type || "node";

    var core = this._coreFactory.getCore(json.type, json.coreId); // Create or share a core
    var node = this._nodeFactory.getNode(this, json, core);
    var nodes = json.nodes;

    if (nodes) {
        var nodeType = SceneJS_NodeFactory.nodeTypes[node.type];
        var fromPlugin = (!!nodeType && !!nodeType.prototype._fromPlugin);
        if (!fromPlugin) {
            for (var i = 0, len = nodes.length; i < len; i++) {
                var childNode = this.createNode(nodes[i]);
                node.addNode(childNode);
            }
        }
    }

    return node;
};

/**
 * Performs pending node destructions. When destroyed, each node and its core is released back to the
 * node and core pools for reuse, respectively.
 */
SceneJS_Engine.prototype._doDestroyNodes = function () {
    var node;
    while (this._numNodesToDestroy > 0) {
        --this._numNodesToDestroy;
        node = this._nodesToDestroy[this._numNodesToDestroy];
        this._nodesToDestroy[this._numNodesToDestroy] = null; // Don't retain the node
        node._doDestroy();
        this._coreFactory.putCore(node._core);    // Release state core for reuse
        this._nodeFactory.putNode(node);         // Release node for reuse
    }
};

/**
 * Finds the node with the given ID in this engine's scene graph
 * @return {SceneJS.Node} The node if found, else null
 */
SceneJS_Engine.prototype.findNode = function (nodeId) {
    return this._nodeFactory.nodes.items[nodeId];
};

/** Finds nodes in this engine's scene graph that have nodes IDs matching the given regular expression
 * @param {String} nodeIdRegex Regular expression to match on node IDs
 * @return {[SceneJS.Node]} Array of nodes whose IDs match the given regex
 */
SceneJS_Engine.prototype.findNodes = function (nodeIdRegex) {

    var regex = new RegExp(nodeIdRegex);
    var nodes = [];
    var nodeMap = this._nodeFactory.nodes.items;

    for (var nodeId in nodeMap) {
        if (nodeMap.hasOwnProperty(nodeId)) {

            if (regex.test(nodeId)) {
                nodes.push(nodeMap[nodeId]);
            }
        }
    }

    return nodes;
};

/**
 * Tests whether a core of the given ID exists for the given node type
 * @param {String} type Node type
 * @param {String} coreId
 * @returns Boolean
 */
SceneJS_Engine.prototype.hasCore = function (type, coreId) {
    return this._coreFactory.hasCore(type, coreId);
};

/**
 * Schedules the given subtree of this engine's {@link SceneJS.Scene} for recompilation
 *
 * @param {SceneJS.Node} node Root node of the subtree to recompile
 */
SceneJS_Engine.prototype.branchDirty = function (node) {

    if (this.sceneDirty) {
        return; // Whole scene will recompile anyway
    }

    /* Dealing with some weirdness with the embedded window and iframe / window fascism.
     */
    if (node == window) {
        return;
    }

    node.branchDirty = true;
    node.dirty = true;

    for (var n = node.parent; n && !(n.dirty || n.branchDirty); n = n.parent) { // Flag path down to this node
        n.dirty = true;
    }

    this._sceneBranchesDirty = true;
};

/**
 * Renders a single frame. Does any pending scene compilations or draw graph updates first.
 * Ordinarily the frame is rendered only if compilations or draw graph updates were performed,
 * but may be forced to render the frame regardless.
 *
 * @param {*} params Rendering parameters
 * @param {Boolean} params.clear True to clear the display first (default)
 */
SceneJS_Engine.prototype.renderFrame = function (params) {

    var rendered = false;

    if (this._willRender() || (params && params.force)) {

        var time = Date.now();

        var force = params && params.force;

        // Render the scene once for each pass
        for (var i = 0; i < this._numPasses; i++) {

            // Notify that render is upcoming
            this.scene.publish("rendering", {
                pass: i
            });

            // Compile scene graph to display graph, if necessary
            this.compile();

            // Render display graph
            // Clear buffers only on first frame
            this.display.prepareScene();
            this.display.render({
                pass: i,
                clear: this._clearEachPass || i == 0,
                force: force,
                opaqueOnly: params && params.opaqueOnly
            });

            // Notify that render completed
            this.scene.publish("rendered", {
                sceneId: this.id,
                time: time,
                pass: i
            });

            rendered = true;
        }
    }

    return rendered;
};

/**
 * Starts the render loop on this engine.
 */
SceneJS_Engine.prototype.start = function () {

    if (!this.running) { // Do nothing if already started

        this.running = true;
        this.paused = false;
        this.sceneDirty = true;

        var self = this;
        var fnName = "__scenejs_sceneLoop" + this.id;
        var sleeping = false;
        var time = Date.now();
        var prevTime = time;
        var startTime = time;
        var scene = this.scene;
        var rendered = false;
        var canvas = this.canvas.canvas;
        var width;
        var height;
        var lastWidth = null;
        var lastHeight = null;

        var renderCountdown = this.ticksPerRender;

        // Notify started
        this.events.fireEvent("started", {
            sceneId: self.id,
            startTime: startTime
        });

        var renderingEvent = {
            pass: 0
        };
        var renderOptions = {
            clear: true
        };
        var renderedEvent = {
            sceneId: self.id,
            time: time,
            pass: 0
        };
        var sleepEvent = {
            sceneId: self.id,
            startTime: time,
            prevTime: time,
            time: time
        };
        var canvasSizeEvent = {
            width: 0,
            height: 0,
            aspect: 1
        };
        var tickEvent = {
            sceneId: self.id,
            startTime: time,
            prevTime: time,
            time: time
        };

        function draw(rendering) {
            rendered = false;

            // Render the scene once for each pass
            for (var i = 0; i < self._numPasses; i++) {

                if (self._willRender() || rendered) {

                    sleeping = false;

                    // Notify we're about to do a render
                    renderingEvent.pass = i;
                    scene.publish("rendering", renderingEvent);

                    // Compile scene graph to display graph, if necessary
                    self.compile();
                    self.display.prepareScene();

                    if (rendering) {

                        renderOptions.pass = i;
                        renderOptions.clear = self._clearEachPass || (i == 0);

                        self.display.render(renderOptions);

                        // Notify that we've just done a render
                        renderedEvent.sceneId = self.id;
                        renderedEvent.time = time;
                        renderedEvent.pass = i;
                        scene.publish("rendered", renderedEvent);

                        rendered = true;
                    } else {
                        break;
                    }
                }
            }

            self.stats.frame.frameCount++;

            // If any of the passes did not render anything, then put the render loop to sleep again
            if (!rendered) {
                if (!sleeping) {
                    sleepEvent.sceneId = self.id;
                    sleepEvent.startTime = startTime;
                    sleepEvent.prevTime = time;
                    sleepEvent.time = time;
                    scene.publish("sleep", sleepEvent);
                }
                sleeping = true;
            }
        }

        var gpuQueryInProgress = false;

        // Animation frame callback
        window[fnName] = function () {

            var cpuStartTime = self.cpuTimer.now();

            var willRender = false;

            if (self.gpuTimer) {
                var gpuTimerAvailable = self.gpuTimer.getQueryObjectEXT(self.gpuTimerQuery, self.gpuTimer.QUERY_RESULT_AVAILABLE_EXT);
                var gpuTimerDisjoint = self.canvas.gl.getParameter(self.gpuTimer.GPU_DISJOINT_EXT);

                if (gpuTimerAvailable) {
                    gpuQueryInProgress = false;
                }

                if (gpuTimerAvailable && !gpuTimerDisjoint) {
                    self.stats.frame.gpuTime = self.gpuTimer.getQueryObjectEXT(self.gpuTimerQuery, self.gpuTimer.QUERY_RESULT_EXT) / 1000000;
                }
            }

            if (--renderCountdown === 0) {
                willRender = true;
                renderCountdown = self.ticksPerRender;
            }

            var resolutionScaling = self.canvas.resolutionScaling || 1;

            width = canvas.width = canvas.clientWidth * resolutionScaling;
            height = canvas.height = canvas.clientHeight * resolutionScaling;

            if (width != lastWidth || height != lastHeight) {
                canvasSizeEvent.width = width;
                canvasSizeEvent.height = height;
                canvasSizeEvent.aspect = width / height;
                scene.publish("canvasSize", canvasSizeEvent);
                self.display.setViewport(0, 0, width, height);
                self.display.imageDirty = true;
                lastWidth = width;
                lastHeight = height;
            }

            if (self.running && !self.paused) {

                time = Date.now();

                tickEvent.sceneId = self.id;
                tickEvent.startTime = startTime;
                tickEvent.prevTime = time;
                tickEvent.time = time;
                tickEvent.rendering = willRender;
                scene.publish("tick", tickEvent);

                prevTime = time;

                if (!self.running) { // "tick" handler have destroyed scene
                    return;
                }

                if (self.gpuTimer && !gpuQueryInProgress) {
                    self.gpuTimer.beginQueryEXT(self.gpuTimer.TIME_ELAPSED_EXT, self.gpuTimerQuery);
                }
                draw(willRender);
                if (self.gpuTimer && !gpuQueryInProgress) {
                    self.gpuTimer.endQueryEXT(self.gpuTimer.TIME_ELAPSED_EXT);
                    gpuQueryInProgress = true;
                }
            }

            self.stats.frame.cpuTime = self.cpuTimer.now() - cpuStartTime;

            if (self.running) {
                requestAnimationFrame(window[fnName]);
            }
        };

        requestAnimationFrame(window[fnName]);
    }
};

/**
 * Performs a pick on this engine and returns a hit record containing at least the name of the picked
 * scene object (as configured by SceneJS.Name nodes) and the canvas pick coordinates. Ordinarily, picking
 * is the simple GPU color-name mapped method, but this method can instead perform a ray-intersect pick
 * when the 'rayPick' flag is set on the options parameter for this method. For that mode, this method will
 * also find the intersection point on the picked object's near surface with a ray cast from the eye that passes
 * through the mouse position on the projection plane.
 *
 * @param params Pick options
 * @param params.canvasPos Canvas coordinates
 * @param params.rayPick Performs additional ray-intersect pick when true
 * @param params.regionPick Performs additional region-intersect pick when true
 * @returns The pick record
 */
SceneJS_Engine.prototype.pick = function (params) {

    // Do any pending scene compilations
    if (this._willRender()) {
        this.compile();
    }

    var hit = this.display.pick({
        pickTriangle: params ? params.rayPick : false,
        pickRegion: params ? params.regionPick : false,
        canvasPos: params.canvasPos,
        origin: params.origin,
        direction: params.direction
    });

    return hit;
};

/**
 * Reads colors of pixels from the last rendered frame.
 */
SceneJS_Engine.prototype.readPixels = function (entries, size, opaqueOnly) {

    // Do any pending scene compilations
    if (this._willRender()) {
        this.compile();
    }

    return this.display.readPixels(entries, size, opaqueOnly);
};

/**
 * Returns true if view needs refreshing from scene
 * @returns {Boolean}
 * @private
 */
SceneJS_Engine.prototype._willRender = function () {
    SceneJS_events.fireEvent(SceneJS_events.RENDER);

    return (this.display.imageDirty // Frame buffer needs redraw
    || this.display.stateSortDirty // Draw list needs to redetermine state order
    || this.display.stateOrderDirty // Draw list needs state sort
    || this.display.objectListDirty // Draw list needs to be rebuilt
    || this._sceneBranchesDirty // One or more branches in scene graph need (re)compilation
    || this.sceneDirty); // Whole scene needs recompilation
};

/**
 * Prevent engine from compiling the scene graph
 */
SceneJS_Engine.prototype.pauseCompilation = function () {
    this._compilationPaused = true;
};

/**
 * Resume compilation of scene graph
 */
SceneJS_Engine.prototype.resumeCompilation = function () {
    this._compilationPaused = false;
};

/**
 * Performs any pending scene compilations or display rebuilds
 */
SceneJS_Engine.prototype.compile = function () {
    if (this._compilationPaused) {
        return;
    }

    if (this._sceneBranchesDirty || this.sceneDirty) { // Need scene graph compilation
        this._sceneBranchesDirty = false;
        SceneJS_events.fireEvent(SceneJS_events.SCENE_COMPILING, {  // Notify compilation support start
            engine: this                                            // Compilation support modules get ready
        });
        this.pubSubProxy = new SceneJS_PubSubProxy(this.scene, null);
        var ctx = {
            pubSubProxy: this.pubSubProxy
        };
        var startTime = SceneJS.timer.now();
        this.scene._compileNodes(ctx); // Begin depth-first compilation descent into scene sub-nodes
        this.stats.load.sceneGraphCompilation += SceneJS.timer.now() - startTime;
        this.sceneDirty = false;
    }
    this._doDestroyNodes(); // Garbage collect destroyed nodes - node destructions set imageDirty true
};

/**
 * Pauses/unpauses the render loop
 * @param {Boolean} doPause Pauses or unpauses the render loop
 */
SceneJS_Engine.prototype.pause = function (doPause) {
    this.paused = doPause;
};

/**
 * Stops the render loop
 */
SceneJS_Engine.prototype.stop = function () {
    if (this.running) {
        this.running = false;
        this.paused = false;
        window["__scenejs_sceneLoop" + this.id] = null;
        //   this.events.fireEvent("stopped", { sceneId: this.id });
    }
};

/**
 * Destroys a node within this engine's {@link SceneJS.Scene}
 *
 * @param {SceneJS.Node} node Node to destroy
 */
SceneJS_Engine.prototype.destroyNode = function (node) {

    /* The node is actually scheduled for lazy destruction within the next invocation of #_tryCompile
     */
    this._nodesToDestroy[this._numNodesToDestroy++] = node;

    /* Stop tracking node's status
     */
    var nodeStatus = this.sceneStatus.nodes[node.id];

    if (nodeStatus) {
        this.sceneStatus.numTasks -= nodeStatus.numTasks;
        delete this.sceneStatus.nodes[node.id];
    }
};

/**
 * Destroys this engine
 */
SceneJS_Engine.prototype.destroy = function () {
    this.destroyed = true;
    // this.events.fireEvent("destroyed", { sceneId: this.id });
};

/*---------------------------------------------------------------------------------------------------------------------
 * JavaScript augmentations to support render loop
 *--------------------------------------------------------------------------------------------------------------------*/

if (!self.Int32Array) {
    self.Int32Array = Array;
    self.Float32Array = Array;
}

// Ripped off from THREE.js - https://github.com/mrdoob/three.js/blob/master/src/Three.js
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

(function () {
    var lastTime = 0;
    var vendors = ['ms', 'moz', 'webkit', 'o'];
    for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
        window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame']
            || window[vendors[x] + 'RequestCancelAnimationFrame'];
    }

    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function () {
                    callback(currTime + timeToCall);
                },
                timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
}());
;/**
 * Backend module that provides single point through which exceptions may be raised
 *
 * @class SceneJS_error
 * @private
 */
var SceneJS_error = new (function() {

    var activeSceneId;

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING, // Set default logging for scene root
            function(params) {
                activeSceneId = params.engine.id;
            });

    SceneJS_events.addListener(
            SceneJS_events.RESET,
            function() {
                activeSceneId = null;
            },
            100000);  // Really low priority - must be reset last

    this.fatalError = function(code, message) {
        if (typeof code == "string") {
            message = code;
            code = SceneJS.errors.ERROR;
        }
        var error = {
            errorName: SceneJS.errors._getErrorName(code) || "ERROR",
            code: code,
            exception: message,
            fatal: true
        };
        if (activeSceneId) {
            error.sceneId = activeSceneId;
        }
        SceneJS_events.fireEvent(SceneJS_events.ERROR, error);
        return message;
    };

    this.error = function(code, message) {
        var error = {
            errorName: SceneJS.errors._getErrorName(code) || "ERROR",
            code: code,
            exception: message,
            fatal: false
        };
        if (activeSceneId) {
            error.sceneId = activeSceneId;
        }
        SceneJS_events.fireEvent(SceneJS_events.ERROR, error);
    };
})();

(function() {
    SceneJS.errors = {};

    var n = 0;
    SceneJS.errors.ERROR = n++;
    SceneJS.errors.INVALID_FRAMEBUFFER = n++;
    SceneJS.errors.WEBGL_NOT_SUPPORTED = n++;
    SceneJS.errors.WEBGL_CONTEXT_LOST = n++;
    SceneJS.errors.NODE_CONFIG_EXPECTED = n++;
    SceneJS.errors.ILLEGAL_NODE_CONFIG = n++;
    SceneJS.errors.SHADER_COMPILATION_FAILURE = n++;
    SceneJS.errors.SHADER_LINK_FAILURE = n++;
    SceneJS.errors.CANVAS_NOT_FOUND = n++;
    SceneJS.errors.OUT_OF_VRAM = n++;
    SceneJS.errors.WEBGL_UNSUPPORTED_NODE_CONFIG = n++;
    SceneJS.errors.NODE_NOT_FOUND = n++;
    SceneJS.errors.NODE_ILLEGAL_STATE = n++;
    SceneJS.errors.ID_CLASH = n++;
})();

SceneJS.errors._getErrorName = function(code) {
    for (var key in SceneJS.errors) {
        if (SceneJS.errors.hasOwnProperty(key) && SceneJS.errors[key] == code) {
            return key;
        }
    }
    return null;
};

;/**
 * Backend that manages configurations.
 *
 * @class SceneJS_configsModule
 * @private
 */
var SceneJS_configsModule = new (function () {

    this.configs = {};
    var subs = {};

    /**
     * Set a config
     * @param path
     * @param data
     */
    this.setConfigs = function (path, data) {
        // Update configs
        if (!path) {
            this.configs = data;
        } else {
            var parts = path.split(".");
            var cfg = this.configs;
            var subCfg;
            var name;
            for (var i = 0; i < parts.length - 1; i++) {
                name = parts[i];
                subCfg = cfg[name];
                if (!subCfg) {
                    subCfg = cfg[name] = {};
                }
                cfg = subCfg;
            }
            cfg[parts.length - 1] = data;
        }
        // Notify subscribers
        var list = subs[path || "_all"];
        if (list) {
            for (var i = 0, len = list.length; i < len; i++) {
                list[i](cfg);
            }
        }

        SceneJS.publish("configs", this.configs);
    };

    /**
     * Get a config
     * @param path
     * @return {*}
     */
    this.getConfigs = function (path) {
        if (!path) {
            return this.configs;
        } else {
            var cfg = this.configs;
            var parts = path.split(".");
            for (var i = 0; cfg && i < parts.length; i++) {
                cfg = cfg[parts[i]];
            }
            return (cfg != undefined) ? cfg : {};
        }
    };

    /**
     * Subscribe to updates to a config
     * @param path
     * @param ok
     */
    this.on = function (path, ok) {
        path = path || "_all";
        (subs[path] || (subs[path] = [])).push(ok);
        ok(this.getConfigs(path));
    };

})();

/** Sets configurations.
 */
SceneJS.configure = SceneJS.setConfigs = SceneJS.setDebugConfigs = function () {
    if (arguments.length == 1) {
        SceneJS_configsModule.setConfigs(null, arguments[0]);
    } else if (arguments.length == 2) {
        SceneJS_configsModule.setConfigs(arguments[0], arguments[1]);
    } else {
        throw SceneJS_error.fatalError("Illegal arguments given to SceneJS.setDebugs - should be either ({String}:name, {Object}:cfg) or ({Object}:cfg)");
    }
};

/** Gets configurations
 */
SceneJS.getConfigs = SceneJS.getDebugConfigs = function (path) {
    return SceneJS_configsModule.getConfigs(path);
};

;/**
 * @class Manages logging
 *  @private
 */
SceneJS.log = new (function() {

    var activeSceneId;
    var funcs = null;
    var queues = {};
    var indent = 0;
    var indentStr = "";

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING, // Set default logging for scene root
            function(params) {
                activeSceneId = params.engine.id;
            });

    SceneJS_events.addListener(
            SceneJS_events.RESET,
            function() {
                queues = {};
                funcs = null;
                activeSceneId = null;
            },
            100000);  // Really low priority - must be reset last

    this._setIndent = function(_indent) {
        indent = _indent;
        var indentArray = [];
        for (var i = 0; i < indent; i++) {
            indentArray.push("----");
        }
        indentStr = indentArray.join("");
    };

    this.error = function(msg) {
        this._log("error", msg);
    };

    this.warn = function(msg) {
        this._log("warn", msg);
    };

    this.info = function(msg) {
        this._log("info", msg);
    };

    this.debug = function(msg) {
        this._log("debug", msg);
    };

    this.setFuncs = function(l) {
        if (l) {
            funcs = l;
            for (var channel in queues) {
                this._flush(channel);
            }
        }
    };

    this._flush = function(channel) {
        var queue = queues[channel];
        if (queue) {
            var func = funcs ? funcs[channel] : null;
            if (func) {
                for (var i = 0; i < queue.length; i++) {
                    func(queue[i]);
                }
                queues[channel] = [];
            }
        }
    };

    this._log = function(channel, message) {
        if (SceneJS._isArray(message)) {
            for (var i = 0; i < message.length; i++) {
                this.__log(channel, message[i]);
            }
        } else {
            this.__log(channel, message);
        }
    };

    this.__log = function(channel, message) {
        message = indentStr + message;

        if (funcs && funcs[channel]) {
            funcs[channel](message);

        } else if (console && console[channel]) {
            console[channel](message);
        }
    };

    this.getFuncs = function() {
        return funcs;
    };

})();;(function () {

    /*
     * Optimizations made based on glMatrix by Brandon Jones
     */

    /*
     * Copyright (c) 2010 Brandon Jones
     *
     * This software is provided 'as-is', without any express or implied
     * warranty. In no event will the authors be held liable for any damages
     * arising from the use of this software.
     *
     * Permission is granted to anyone to use this software for any purpose,
     * including commercial applications, and to alter it and redistribute it
     * freely, subject to the following restrictions:
     *
     *    1. The origin of this software must not be misrepresented; you must not
     *    claim that you wrote the original software. If you use this software
     *    in a product, an acknowledgment in the product documentation would be
     *    appreciated but is not required.
     *
     *    2. Altered source versions must be plainly marked as such, and must not
     *    be misrepresented as being the original software.
     *
     *    3. This notice may not be removed or altered from any source
     *    distribution.
     */


    // Some temporary vars to help avoid garbage collection

    var tempMat1 = mat4.create();
    var tempMat2 = mat4.create();
    var tempVec2 = vec2.create();
    var tempVec3 = vec3.create();
    var tempVec3b = vec3.create();
    var tempVec3c = vec3.create();
    var tempVec3d = vec3.create();
    var tempVec3e = vec3.create();
    var tempVec3f = vec3.create();
    var tempVec3g = vec3.create();
    var tempVec3h = vec3.create();
    var tempVec4 = vec4.create();

    /** @private */
    window.SceneJS_math_cross3Vec4 = function (u, v) {
        var u0 = u[0], u1 = u[1], u2 = u[2];
        var v0 = v[0], v1 = v[1], v2 = v[2];
        return [
            u1 * v2 - u2 * v1,
            u2 * v0 - u0 * v2,
            u0 * v1 - u1 * v0,
            0.0];
    };

    /** @private */
    window.SceneJS_math_setCellMat4 = function (m, row, col, s) {
        m[row + col * 4] = s;
    };

    /**
     * Default lookat properties - eye at 0,0,1, looking at 0,0,0, up vector pointing up Y-axis
     */
    window.SceneJS_math_LOOKAT_OBJ = {
        eye: {x: 0, y: 0, z: 10.0},
        look: {x: 0, y: 0, z: 0.0},
        up: {x: 0, y: 1, z: 0.0}
    };

    /**
     * Default lookat properties in array form - eye at 0,0,1, looking at 0,0,0, up vector pointing up Y-axis
     */
    window.SceneJS_math_LOOKAT_ARRAYS = {
        eye: [0, 0, 10.0],
        look: [0, 0, 0.0],
        up: [0, 1, 0.0]
    };

    /**
     * Default orthographic projection properties
     */
    window.SceneJS_math_ORTHO_OBJ = {
        left: -1.0,
        right: 1.0,
        bottom: -1.0,
        near: 0.1,
        top: 1.0,
        far: 5000.0
    };

    window.SceneJS_math_identityQuaternion = function () {
        return [0.0, 0.0, 0.0, 1.0];
    };

    window.SceneJS_math_angleAxisQuaternion = function (x, y, z, degrees) {
        var angleRad = (degrees / 180.0) * Math.PI;
        var halfAngle = angleRad / 2.0;
        var fsin = Math.sin(halfAngle);
        return [
            fsin * x,
            fsin * y,
            fsin * z,
            Math.cos(halfAngle)
        ];
    };

    window.SceneJS_math_mulQuaternions = function (p, q) {
        var p0 = p[0], p1 = p[1], p2 = p[2], p3 = p[3];
        var q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
        return [
            p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1,
            p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2,
            p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0,
            p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2
        ];
    };

    window.SceneJS_math_newMat4FromQuaternion = function (q) {
        var q0 = q[0], q1 = q[1], q2 = q[2], q3 = q[3];
        var tx = 2.0 * q0;
        var ty = 2.0 * q1;
        var tz = 2.0 * q2;
        var twx = tx * q3;
        var twy = ty * q3;
        var twz = tz * q3;
        var txx = tx * q0;
        var txy = ty * q0;
        var txz = tz * q0;
        var tyy = ty * q1;
        var tyz = tz * q1;
        var tzz = tz * q2;
        var m = mat4.create();
        SceneJS_math_setCellMat4(m, 0, 0, 1.0 - (tyy + tzz));
        SceneJS_math_setCellMat4(m, 0, 1, txy - twz);
        SceneJS_math_setCellMat4(m, 0, 2, txz + twy);
        SceneJS_math_setCellMat4(m, 1, 0, txy + twz);
        SceneJS_math_setCellMat4(m, 1, 1, 1.0 - (txx + tzz));
        SceneJS_math_setCellMat4(m, 1, 2, tyz - twx);
        SceneJS_math_setCellMat4(m, 2, 0, txz - twy);
        SceneJS_math_setCellMat4(m, 2, 1, tyz + twx);
        SceneJS_math_setCellMat4(m, 2, 2, 1.0 - (txx + tyy));
        return m;
    };

    window.SceneJS_math_normalizeQuaternion = function (q) {
        var len = vec4.length([q[0], q[1], q[2], q[3]]);
        return [q[0] / len, q[1] / len, q[2] / len, q[3] / len];
    };

    window.SceneJS_math_angleAxisFromQuaternion = function (q) {
        q = SceneJS_math_normalizeQuaternion(q);
        var q3 = q[3];
        var angle = 2 * Math.acos(q3);
        var s = Math.sqrt(1 - q3 * q3);
        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
            return {
                x: q[0],
                y: q[1],
                z: q[2],
                angle: angle * 57.295779579
            };
        } else {
            return {
                x: q[0] / s,
                y: q[1] / s,
                z: q[2] / s,
                angle: angle * 57.295779579
            };
        }
    };

    window.SceneJS_math_decompressPosition  = function(out, position, decodeMatrix) {
        out[0] = position[0] * decodeMatrix[0]  + decodeMatrix[12];
        out[1] = position[1] * decodeMatrix[5]  + decodeMatrix[13];
        out[2] = position[2] * decodeMatrix[10] + decodeMatrix[14];
    }; 

    window.SceneJS_math_decompressUV  = function(out, uv, decodeMatrix) {
        out[0] = uv[0] * decodeMatrix[0]  + decodeMatrix[6];
        out[1] = uv[1] * decodeMatrix[4]  + decodeMatrix[7];
    }; 

    /**
     * Builds vertex and index arrays needed by color-indexed triangle picking.
     *
     * @method getPickPrimitives
     * @static
     * @param {Array of Number} positions One-dimensional flattened array of positions.
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @returns {*} Object containing the arrays, created by this method or reused from 'pickTris' parameter.
     */
    window.SceneJS_math_getPickPrimitives = function (positions, indices, compressed) {

        var numIndices = indices.length;

        var pickPositions = compressed ? new Uint16Array(numIndices * 3) : new Float32Array(numIndices * 3);
        var pickColors = new Uint8Array(numIndices * 4);

        var primIndex = 0;

        // Positions array index
        var vi;

        // Picking positions array index
        var pvi;

        // Picking color array index
        var pci;

        // Triangle indices

        var i;
        var r;
        var g;
        var b;
        var a;

        for (var location = 0; location < numIndices; location += 3) {

            pvi = location * 3;
            pci = location * 4;

            // Primitive-indexed triangle pick color

            a = (primIndex >> 24 & 0xFF);
            b = (primIndex >> 16 & 0xFF);
            g = (primIndex >> 8 & 0xFF);
            r = (primIndex & 0xFF);

            // A

            i = indices[location];
            vi = i * 3;

            pickPositions[pvi]     = positions[vi];
            pickPositions[pvi + 1] = positions[vi + 1];
            pickPositions[pvi + 2] = positions[vi + 2];

            pickColors[pci]     = r;
            pickColors[pci + 1] = g;
            pickColors[pci + 2] = b;
            pickColors[pci + 3] = a;


            // B

            i = indices[location + 1];
            vi = i * 3;

            pickPositions[pvi + 3] = positions[vi];
            pickPositions[pvi + 4] = positions[vi + 1];
            pickPositions[pvi + 5] = positions[vi + 2];

            pickColors[pci + 4] = r;
            pickColors[pci + 5] = g;
            pickColors[pci + 6] = b;
            pickColors[pci + 7] = a;


            // C

            i = indices[location + 2];
            vi = i * 3;

            pickPositions[pvi + 6] = positions[vi];
            pickPositions[pvi + 7] = positions[vi + 1];
            pickPositions[pvi + 8] = positions[vi + 2];

            pickColors[pci + 8]  = r;
            pickColors[pci + 9]  = g;
            pickColors[pci + 10] = b;
            pickColors[pci + 11] = a;

            primIndex++;
        }

        return {
            positions: pickPositions,
            colors: pickColors
        };
    };

    /**
     * Builds vertex array needed by color-indexed triangle picking (for morph target positions).
     *
     * @method getPickPositions
     * @static
     * @param {Array of Number} positions One-dimensional flattened array of positions.
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @returns {Array of Number} The pick positions.
     */
    window.SceneJS_math_getPickPositions = function (positions, indices) {

        var numIndices = indices.length;

        var pickPositions = new Float32Array(numIndices * 3);
        var pvi, vi;
        var i;

        for (var location = 0; location < numIndices; location++) {

            // Picking position array index
            pvi = location * 3;

            i = indices[location];

            // Drawing position index
            vi = i * 3;

            pickPositions[pvi]     = positions[vi];
            pickPositions[pvi + 1] = positions[vi + 1];
            pickPositions[pvi + 2] = positions[vi + 2];

        }

        return pickPositions;
    };

    /**
     * Builds color arrays needed by color-indexed triangle picking.
     *
     * @method getPickPrimitives
     * @static
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @returns {Array of Number} The pick colors
     */
    window.SceneJS_math_getPickColors = function (indices) {

        var numIndices = indices.length;

        var pickColors = new Uint8Array(numIndices * 4);

        var primIndex = 0;
        var pci;

        // Triangle indices

        var r;
        var g;
        var b;
        var a;

        for (var location = 0; location < numIndices; location += 3) {

            // Picking color array index;
            pci = location * 4;

            // Primitive-indexed triangle pick color

            a = (primIndex >> 24 & 0xFF);
            b = (primIndex >> 16 & 0xFF);
            g = (primIndex >> 8 & 0xFF);
            r = (primIndex & 0xFF);

            // A

            pickColors[pci]     = r;
            pickColors[pci + 1] = g;
            pickColors[pci + 2] = b;
            pickColors[pci + 3] = a;

            // B

            pickColors[pci + 4] = r;
            pickColors[pci + 5] = g;
            pickColors[pci + 6] = b;
            pickColors[pci + 7] = a;

            // C

            pickColors[pci + 8]  = r;
            pickColors[pci + 9]  = g;
            pickColors[pci + 10] = b;
            pickColors[pci + 11] = a;

            primIndex++;
        }

        return pickColors;
    };

    /**
     * Finds the intersection of a 3D ray with a plane defined by 3 points.
     *
     * @method rayPlaneIntersect
     * @static
     * @param {Array of Number} origin Ray origin.
     * @param {Array of Number} dir Ray direction.
     * @param {Array of Number} a First point on plane.
     * @param {Array of Number} b Second point on plane.
     * @param {Array of Number} c Third point on plane.
     * @param {Array of Number} [isect] Intersection point.
     * @returns {Array of Number} The intersection point.
     */
    window.SceneJS_math_rayPlaneIntersect = function (origin, dir, a, b, c, isect) {

        isect = isect || vec3.create();
        dir = vec3.normalize(tempVec3, dir);

        var edge1 = vec3.subtract(tempVec3b, b, a);
        var edge2 = vec3.subtract(tempVec3c, c, a);

        var n = vec3.cross(tempVec3d, edge1, edge2);
        vec3.normalize(n, n);

        var d = -vec3.dot(a, n);

        var t = -(vec3.dot(origin, n) + d) / vec3.dot(dir, n);
        isect[0] = origin[0] + t * dir[0];
        isect[1] = origin[1] + t * dir[1];
        isect[2] = origin[2] + t * dir[2];

        return isect;
    };


    /**
     * Gets barycentric coordinates from cartesian coordinates within a triangle.
     *
     * @method cartesianToBaryCentric
     * @static
     * @param {Array of Number} cartesian Cartesian coordinates.
     * @param {Array of Number} a First triangle vertex.
     * @param {Array of Number} b Second triangle vertex.
     * @param {Array of Number} c Third triangle vertex.
     * @param {Array of Number} [bary] The barycentric coordinates.
     * @returns {Array of Number} The barycentric coordinates, or null if the triangle was invalid.
     * @returns {*}
     */

    window.SceneJS_math_cartesianToBarycentric = function (cartesian, a, b, c, dest) {

        var v0 = vec3.subtract(tempVec3, c, a);
        var v1 = vec3.subtract(tempVec3b, b, a);
        var v2 = vec3.subtract(tempVec3c, cartesian, a);

        var dot00 = vec3.dot(v0, v0);
        var dot01 = vec3.dot(v0, v1);
        var dot02 = vec3.dot(v0, v2);
        var dot11 = vec3.dot(v1, v1);
        var dot12 = vec3.dot(v1, v2);

        var denom = ( dot00 * dot11 - dot01 * dot01 );

        // Colinear or singular triangle

        if (denom === 0) {

            // Arbitrary location outside of triangle

            return null;
        }

        var invDenom = 1 / denom;

        var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
        var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

        dest[0] = 1 - u - v;
        dest[1] = v;
        dest[2] = u;

        return dest;
    };

    /**
     * Gets cartesian coordinates from barycentric coordinates within a triangle.
     *
     * @method barycentricToCartesian
     * @static
     * @param {Array of Number} bary The barycentric coordinate.
     * @param {Array of Number} a First triangle vertex.
     * @param {Array of Number} b Second triangle vertex.
     * @param {Array of Number} c Third triangle vertex.
     * @param {Array of Number} [cartesian] Cartesian coordinates.
     * @returns {Array of Number} The cartesian coordinates, or null if the triangle was invalid.
     * @returns {*}
     */
    window.SceneJS_math_barycentricToCartesian = function (bary, a, b, c, cartesian) {

        cartesian = cartesian || vec3.create();

        var u = bary[0];
        var v = bary[1];
        var w = bary[2];

        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;
        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;
        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;

        return cartesian;
    };


    /**
     * Builds vertex tangent vectors from positions, UVs and indices
     *
     * @method buildTangents
     * @static
     * @param {Array of Number} positions One-dimensional flattened array of positions.
     * @param {Array of Number} indices One-dimensional flattened array of indices.
     * @param {Array of Number} uv One-dimensional flattened array of UV coordinates.
     * @returns {Array of Number} One-dimensional flattened array of tangents.
     */

    window.SceneJS_math_buildTangents = function (positions, indices, uv, decodePositions, decodeUV) {

        var tangents = new Float32Array(positions.length);

        // The vertex arrays needs to be calculated
        // before the calculation of the tangents

        var MIN_DEN = 1e-3;

        var v0 = vec3.create();
        var v1 = vec3.create();
        var v2 = vec3.create();

        var uv0 = vec2.create();
        var uv1 = vec2.create();
        var uv2 = vec2.create();

        for (var location = 0; location < indices.length; location += 3) {

            // Recontructing each vertex and UV coordinate into the respective vectors

            var index = indices[location];

            v0.set(positions.subarray(index * 3, index * 3 + 3));
            uv0.set(uv.subarray(index * 2, index * 2 + 2));

            index = indices[location + 1];

            v1.set(positions.subarray(index * 3, index * 3 + 3));
            uv1.set(uv.subarray(index * 2, index * 2 + 2));

            index = indices[location + 2];

            v2.set(positions.subarray(index * 3, index * 3 + 3));
            uv2.set(uv.subarray(index * 2, index * 2 + 2));

            if (decodePositions) {
                SceneJS_math_decompressPosition(v0, v0, decodePositions);
                SceneJS_math_decompressPosition(v1, v1, decodePositions);
                SceneJS_math_decompressPosition(v2, v2, decodePositions);
            }

            if (decodeUV) {
                SceneJS_math_decompressUV(uv0, uv0, decodeUV);
                SceneJS_math_decompressUV(uv1, uv1, decodeUV);
                SceneJS_math_decompressUV(uv2, uv2, decodeUV);
            }

            var deltaPos1 = vec3.subtract(tempVec3, v1, v0);
            var deltaPos2 = vec3.subtract(tempVec3b, v2, v0);

            var deltaUV1 = vec2.subtract(tempVec3c, uv1, uv0);
            var deltaUV2 = vec2.subtract(tempVec3d, uv2, uv0);

            var den = deltaUV1[0] * deltaUV2[1] - deltaUV1[1] * deltaUV2[0];

            if (den === 0) {
                den = MIN_DEN;
            }

            var r = 1 / den;

            var tangent = vec3.scale(tempVec3f,
                vec3.subtract(tempVec3g,
                    vec3.scale(tempVec3e, deltaPos1, deltaUV2[1]),
                    vec3.scale(tempVec3f, deltaPos2, deltaUV1[1])
                ),
                r
            );

            // Average the value of the vectors outs
            for (var v = 0; v < 3; v++) {
                var addTo = indices[location + v] * 3;

                tangents[addTo]     += tangent[0];
                tangents[addTo + 1] += tangent[1];
                tangents[addTo + 2] += tangent[2];
            }
        }

        return tangents;
    };

    window.SceneJS_math_octDecodeVec2 = function(oct, result) {
        var x = oct[0];
        var y = oct[1];
        x = (2 * x + 1) / 255;
        y = (2 * y + 1) / 255;

        var z = 1 - Math.abs(x) - Math.abs(y);

        if (z < 0) {
            x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
            y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        }

        var length = Math.sqrt(x * x + y * y + z * z);

        result[0] = x / length;
        result[1] = y / length;
        result[2] = z / length;

        return result;
    };

})();
;/**
 * Backend that tracks statistics on loading states of nodes during scene traversal.
 *
 * This supports the "loading-status" events that we can listen for on scene nodes.
 *
 * When a node with that listener is pre-visited, it will call getStatus on this module to
 * save a copy of the status. Then when it is post-visited, it will call diffStatus on this
 * module to find the status for its sub-nodes, which it then reports through the "loading-status" event.
 *
 * @private
 */
var SceneJS_sceneStatusModule = new (function () {

    // Public activity summary
    this.sceneStatus = {};

    // IDs of all tasks
    var taskIds = new SceneJS_Map();
    var tasks = {};

    var sceneStates = {};

    var self = this;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_DESTROYED,
        function (params) {
            var sceneId = params.engine.id;
            delete self.sceneStatus[sceneId];
            delete sceneStates[sceneId];
        });

    /** Notifies that a node has begun loading some data
     */
    this.taskStarted = function (node, description) {

        var popups = SceneJS_configsModule.configs.statusPopups !== false;

        var scene = node.getScene();
        var sceneId = scene.getId();
        var nodeId = node.getId();
        var canvas = scene.getCanvas();

        var taskId = taskIds.addItem();

        // Update public info
        var status = this.sceneStatus[sceneId];
        if (!status) {
            status = this.sceneStatus[sceneId] = {
                numTasks: 0
            };
        }
        status.numTasks++;

        // Track node
        var sceneState = sceneStates[sceneId];
        if (!sceneState) {
            sceneState = sceneStates[sceneId] = {
                sceneId: sceneId,
                nodeStates: {},
                scene: scene,
                popupContainer: popups ? createPopupContainer(canvas) : null,
                descCounts: {}
            };
        }
        var descCount = sceneState.descCounts[description];
        if (descCount == undefined) {
            descCount = sceneState.descCounts[description] = 0;
        }
        sceneState.descCounts[description]++;
        var nodeState = sceneState.nodeStates[nodeId];
        if (!nodeState) {
            nodeState = sceneState.nodeStates[nodeId] = {
                nodeId: nodeId,
                numTasks: 0,
                tasks: {}
            };
        }
        description = description + " " + sceneState.descCounts[description] + "...";
        nodeState.numTasks++;
        var task = {
            sceneState: sceneState,
            nodeState: nodeState,
            description: description,
            element: popups ? createPopup(sceneState.popupContainer, description) : null
        };
        nodeState.tasks[taskId] = task;
        tasks[taskId] = task;
        return taskId;
    };

    function createPopupContainer(canvas) {
        var body = document.getElementsByTagName("body")[0];
        var div = document.createElement('div');
        var style = div.style;
        style.position = "absolute";
        style.width = "200px";
        style.right = "10px";
        style.top = "0";
        style.padding = "10px";
        style["z-index"] = "10000";
        body.appendChild(div);
        return div;
    }

    function createPopup(popupContainer, description) {
        var div = document.createElement('div');
        var style = div.style;
        style["font-family"] = "Helvetica";
        style["font-size"] = "14px";
        style.padding = "5px";
        style.margin = "4px";
        style["padding-left"] = "12px";
        style["border"] = "1px solid #000055";
        style.color = "black";
        style.background = "#AAAAAA";
        style.opacity = "0.8";
        style["border-radius"] = "3px";
        style["-moz-border-radius"] = "3px";
        style["box-shadow"] = "3px 3px 3px #444444";
        div.innerHTML = description;
        popupContainer.appendChild(div);
        return div;
    }

    /** Notifies that a load has finished loading some data
     */
    this.taskFinished = function (taskId) {
        if (taskId == -1 || taskId == null) {
            return null;
        }
        var task = tasks[taskId];
        if (!task) {
            return null;
        }
        var sceneState = task.sceneState;
        this.sceneStatus[sceneState.sceneId].numTasks--;
        if (task.element) {
            dismissPopup(task.element);
        }
        var nodeState = task.nodeState;
        if (--nodeState.numTasks < 0) {
            nodeState.numTasks = 0;
        }
        delete nodeState.tasks[taskId];
        if (nodeState.numTasks == 0) {
            delete sceneState.nodeStates[nodeState.nodeId];
        }
        return null;
    };

    function dismissPopup(element) {
        element.style.background = "#AAFFAA";
        var opacity = 0.8;
        var interval = setInterval(function () {
            if (opacity <= 0) {
                element.parentNode.removeChild(element);
                clearInterval(interval);
            } else {
                element.style.opacity = opacity;
                opacity -= 0.1;
            }
        }, 100);
    }

    /** Notifies that a task has failed
     */
    this.taskFailed = function (taskId) {
        if (taskId == -1 || taskId == null) {
            return null;
        }
        var task = tasks[taskId];
        if (!task) {
            return null;
        }
        var popups = !!SceneJS_configsModule.configs.statusPopups;
        var sceneState = task.sceneState;
        this.sceneStatus[sceneState.sceneId].numTasks--;
        if (popups) {
            failPopup(task.element);
        }
        var nodeState = task.nodeState;
        nodeState.numTasks--;
        delete nodeState.tasks[taskId];
        if (nodeState.numTasks == 0) {
            delete task.sceneState.nodeStates[nodeState.nodeId];
        }
        return null;
    };

    function failPopup(element) {
        element.style.background = "#FFAAAA";
    }
})();;SceneJS._webgl = {};
;/** Buffer for vertices and indices
 *
 * @private
 * @param gl  WebGL gl
 * @param type     Eg. ARRAY_BUFFER, ELEMENT_ARRAY_BUFFER
 * @param values   WebGL array wrapper
 * @param numItems Count of items in array wrapper
 * @param itemSize Size of each item
 * @param usage    Eg. STATIC_DRAW
 */

SceneJS._webgl.ArrayBuffer = function (gl, type, values, numItems, itemSize, usage, normalize) {

    /**
     * True when this buffer is allocated and ready to go
     * @type {boolean}
     */
    this.allocated = false;

    switch (values.constructor) {

        case Uint8Array:
            this.itemType = gl.UNSIGNED_BYTE;
            this.itemByteSize = 1;
            break;

        case Int8Array:
            this.itemType = gl.BYTE;
            this.itemByteSize = 1;
            break;

        case  Uint16Array:
            this.itemType = gl.UNSIGNED_SHORT;
            this.itemByteSize = 2;
            break;

        case  Int16Array:
            this.itemType = gl.SHORT;
            this.itemByteSize = 2;
            break;

        case Uint32Array:
            this.itemType = gl.UNSIGNED_INT;
            this.itemByteSize = 4;
            break;

        case Int32Array:
            this.itemType = gl.INT;
            this.itemByteSize = 4;
            break;

        default:
            this.itemType = gl.FLOAT;
            this.itemByteSize = 4;
    }

    this.gl = gl;
    this.type = type;
    this.numItems = numItems;
    this.itemSize = itemSize;
    this.usage = usage;
    this.normalize = !!normalize;
    this._allocate(values, numItems);
};

/**
 * Allocates this buffer
 *
 * @param values
 * @param numItems
 * @private
 */
SceneJS._webgl.ArrayBuffer.prototype._allocate = function (values, numItems) {
    this.allocated = false;
    this.handle = this.gl.createBuffer();
    if (!this.handle) {
        throw SceneJS_error.fatalError(SceneJS.errors.OUT_OF_VRAM, "Failed to allocate WebGL ArrayBuffer");
    }
    if (this.handle) {
        this.gl.bindBuffer(this.type, this.handle);
        this.gl.bufferData(this.type, values, this.usage);
        this.gl.bindBuffer(this.type, null);
        this.numItems = numItems;
        this.length = values.length;
        this.allocated = true;
    }
};

/**
 * Updates values within this buffer, reallocating if needed
 *
 * @param data
 */
SceneJS._webgl.ArrayBuffer.prototype.setData = function (data) {
    if (!this.allocated) {
        return;
    }

    this.gl.bindBuffer(this.type, this.handle);

    if (data.length > this.length) {
        // Needs reallocation
        this.gl.bufferData(this.type, data, this.usage);
        this.length = data.length;
    } else {
        // No reallocation needed
        this.gl.bufferSubData(this.type, 0, data);
    }
    this.gl.bindBuffer(this.type, null);
    this.numItems = data.length;
};

/**
 * Unbinds this buffer on WebGL
 */
SceneJS._webgl.ArrayBuffer.prototype.unbind = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.bindBuffer(this.type, null);
};

/**
 * Destroys this buffer
 */
SceneJS._webgl.ArrayBuffer.prototype.destroy = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.deleteBuffer(this.handle);
    this.handle = null;
    this.allocated = false;
};


SceneJS._webgl.ArrayBuffer.prototype.bind = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.bindBuffer(this.type, this.handle);
};


;
/** An attribute within a shader
 */
SceneJS._webgl.Attribute = function (gl, program, name, type, size, location) {

    this.gl = gl;
    this.location = location;

    this.bindArrayBuffer = function (buffer) {
        if (buffer) {
            buffer.bind();
            gl.enableVertexAttribArray(location);
            gl.vertexAttribPointer(location, buffer.itemSize, buffer.itemType, buffer.normalize, 0, 0);   // Vertices are not homogeneous - no w-element
        }
    };
};

SceneJS._webgl.Attribute.prototype.bindInterleavedFloatArrayBuffer = function (components, stride, byteOffset) {
    this.gl.enableVertexAttribArray(this.location);
    this.gl.vertexAttribPointer(this.location, components, this.gl.FLOAT, false, stride, byteOffset);   // Vertices are not homogeneous - no w-element
};
;
/** Maps SceneJS node parameter names to WebGL enum names
 * @private
 */
SceneJS._webgl.enumMap = {
    funcAdd: "FUNC_ADD",
    funcSubtract: "FUNC_SUBTRACT",
    funcReverseSubtract: "FUNC_REVERSE_SUBTRACT",
    zero: "ZERO",
    one: "ONE",
    srcColor: "SRC_COLOR",
    oneMinusSrcColor: "ONE_MINUS_SRC_COLOR",
    dstColor: "DST_COLOR",
    oneMinusDstColor: "ONE_MINUS_DST_COLOR",
    srcAlpha: "SRC_ALPHA",
    oneMinusSrcAlpha: "ONE_MINUS_SRC_ALPHA",
    dstAlpha: "DST_ALPHA",
    oneMinusDstAlpha: "ONE_MINUS_DST_ALPHA",
    contantColor: "CONSTANT_COLOR",
    oneMinusConstantColor: "ONE_MINUS_CONSTANT_COLOR",
    constantAlpha: "CONSTANT_ALPHA",
    oneMinusConstantAlpha: "ONE_MINUS_CONSTANT_ALPHA",
    srcAlphaSaturate: "SRC_ALPHA_SATURATE",
    front: "FRONT",
    back: "BACK",
    frontAndBack: "FRONT_AND_BACK",
    never: "NEVER",
    less: "LESS",
    equal: "EQUAL",
    lequal: "LEQUAL",
    greater: "GREATER",
    notequal: "NOTEQUAL",
    gequal: "GEQUAL",
    always: "ALWAYS",
    cw: "CW",
    ccw: "CCW",
    linear: "LINEAR",
    nearest: "NEAREST",
    linearMipMapNearest: "LINEAR_MIPMAP_NEAREST",
    nearestMipMapNearest: "NEAREST_MIPMAP_NEAREST",
    nearestMipMapLinear: "NEAREST_MIPMAP_LINEAR",
    linearMipMapLinear: "LINEAR_MIPMAP_LINEAR",
    repeat: "REPEAT",
    clampToEdge: "CLAMP_TO_EDGE",
    mirroredRepeat: "MIRRORED_REPEAT",
    alpha: "ALPHA",
    rgb: "RGB",
    rgba: "RGBA",
    luminance: "LUMINANCE",
    luminanceAlpha: "LUMINANCE_ALPHA",
    textureBinding2D: "TEXTURE_BINDING_2D",
    textureBindingCubeMap: "TEXTURE_BINDING_CUBE_MAP",
    compareRToTexture: "COMPARE_R_TO_TEXTURE", // Hardware Shadowing Z-depth,
    unsignedByte: "UNSIGNED_BYTE"
};

;SceneJS._webgl.RenderBuffer = function (cfg) {

    /**
     * True as soon as this buffer is allocated and ready to go
     */
    this.allocated = false;

    /**
     * The canvas, to synch buffer size with when its dimensions change
     */
    this.canvas = cfg.canvas;

    /**
     * WebGL context
     */
    this.gl = cfg.canvas.gl;

    /**
     * Buffer resources, set up in #_touch
     */
    this.buf = null;

    /**
     * True while this buffer is bound
     * @type {boolean}
     */
    this.bound = false;
};

/**
 * Called after WebGL context is restored.
 */
SceneJS._webgl.RenderBuffer.prototype.webglRestored = function (_gl) {
    this.gl = _gl;
    this.buf = null;
    this.allocated = false;
    this.bound = false;
};

/**
 * Binds this buffer
 */
SceneJS._webgl.RenderBuffer.prototype.bind = function () {
    this._touch();
    if (this.bound) {
        return;
    }
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buf.framebuf);
    this.bound = true;
};

SceneJS._webgl.RenderBuffer.prototype._touch = function () {
    var width = this.canvas.canvas.width;
    var height = this.canvas.canvas.height;
    if (this.buf) { // Currently have a buffer
        if (this.buf.width == width && this.buf.height == height) { // Canvas size unchanged, buffer still good
            return;
        } else { // Buffer needs reallocation for new canvas size
            this.gl.deleteTexture(this.buf.texture);
            this.gl.deleteFramebuffer(this.buf.framebuf);
            this.gl.deleteRenderbuffer(this.buf.renderbuf);
        }
    }

    this.buf = {
        framebuf: this.gl.createFramebuffer(),
        renderbuf: this.gl.createRenderbuffer(),
        texture: this.gl.createTexture(),
        width: width,
        height: height
    };

    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buf.framebuf);
    this.gl.bindTexture(this.gl.TEXTURE_2D, this.buf.texture);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);
    this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);

    this._setTexture(width, height);

    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, this.buf.renderbuf);
    this.gl.renderbufferStorage(this.gl.RENDERBUFFER, this.gl.DEPTH_COMPONENT16, width, height);
    this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER, this.gl.COLOR_ATTACHMENT0, this.gl.TEXTURE_2D, this.buf.texture, 0);
    this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER, this.gl.DEPTH_ATTACHMENT, this.gl.RENDERBUFFER, this.buf.renderbuf);
    this.gl.bindTexture(this.gl.TEXTURE_2D, null);
    this.gl.bindRenderbuffer(this.gl.RENDERBUFFER, null);
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);

    // Verify framebuffer is OK
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.buf.framebuf);

    if (!this.gl.isFramebuffer(this.buf.framebuf)) {
        throw SceneJS_error.fatalError(SceneJS.errors.INVALID_FRAMEBUFFER, "Invalid framebuffer");
    }

    var status = this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);

    switch (status) {

        case this.gl.FRAMEBUFFER_COMPLETE:
            break;

        case this.gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_ATTACHMENT");

        case this.gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");

        case this.gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_INCOMPLETE_DIMENSIONS");

        case this.gl.FRAMEBUFFER_UNSUPPORTED:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: FRAMEBUFFER_UNSUPPORTED");

        default:
            throw SceneJS_error.fatalError(SceneJS.errors.ERROR, "Incomplete framebuffer: " + status);
    }

    this.bound = false;
};

SceneJS._webgl.RenderBuffer.prototype._setTexture = function (width, height) {
    try {
        // Do it the way the spec requires
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, null);
    } catch (exception) {
        // Workaround for what appears to be a Minefield bug.
        var textureStorage = new WebGLUnsignedByteArray(width * height * 3);
        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, width, height, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, textureStorage);
    }
};

/**
 * Clears this renderbuffer
 */
SceneJS._webgl.RenderBuffer.prototype.clear = function () {
    if (!this.bound) {
        throw "Render buffer not bound";
    }
    this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);
    this.gl.disable(this.gl.BLEND);
};

/**
 * Reads buffer pixel at given coordinates
 */
SceneJS._webgl.RenderBuffer.prototype.read = function (pickX, pickY) {
    var x = pickX;
    var y = this.canvas.canvas.height - pickY;
    var pix = new Uint8Array(4);
    this.gl.readPixels(x, y, 1, 1, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pix);
    return pix;
};

/**
 * Unbinds this renderbuffer
 */
SceneJS._webgl.RenderBuffer.prototype.unbind = function () {
    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
    this.bound = false;
};

/** Returns the texture
 */
SceneJS._webgl.RenderBuffer.prototype.getTexture = function () {
    var self = this;
    return {
        bind: function (unit) {
            if (self.buf && self.buf.texture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, self.buf.texture);
                return true;
            }
            return false;
        },
        unbind: function (unit) {
            if (self.buf && self.buf.texture) {
                self.gl.activeTexture(self.gl["TEXTURE" + unit]);
                self.gl.bindTexture(self.gl.TEXTURE_2D, null);
            }
        }
    };
};

/** Destroys this buffer
 */
SceneJS._webgl.RenderBuffer.prototype.destroy = function () {
    if (this.buf) {
        this.gl.deleteTexture(this.buf.texture);
        this.gl.deleteFramebuffer(this.buf.framebuf);
        this.gl.deleteRenderbuffer(this.buf.renderbuf);
        this.buf = null;
        this.bound = false;
    }
};
;/**
 * @class Wrapper for a WebGL program
 *
 * @param hash SceneJS-managed ID for program
 * @param {*} stats Collects scene statistics
 * @param gl WebGL gl
 * @param vertexSources Source codes for vertex shaders
 * @param fragmentSources Source codes for fragment shaders
 * @param logging Program and shaders will write to logging's debug channel as they compile and link
 */
SceneJS._webgl.Program = function (stats, gl, vertexSources, fragmentSources) {

    this.stats = stats;

    /**
     * True as soon as this program is allocated and ready to go
     * @type {boolean}
     */
    this.allocated = false;

    this.gl = gl;

    this._uniforms = {};
    this._samplers = {};
    this._attributes = {};

    this.materialSettings = {
        specularColor: [0, 0, 0],
        specular: 0,
        shine: 0,
        emit: 0,
        alpha: 0
    };

    // Create shaders from sources

    this._shaders = [];

    var a, i, u, u_name, location, shader;

    var startTime = SceneJS.timer.now();

    for (i = 0; i < vertexSources.length; i++) {
        this._shaders.push(new SceneJS._webgl.Shader(stats, gl, gl.VERTEX_SHADER, vertexSources[i]));
    }

    for (i = 0; i < fragmentSources.length; i++) {
        this._shaders.push(new SceneJS._webgl.Shader(stats, gl, gl.FRAGMENT_SHADER, fragmentSources[i]));
    }

    // Create program, attach shaders, link and validate program

    this.handle = gl.createProgram();

    if (this.handle) {

        for (i = 0; i < this._shaders.length; i++) {
            shader = this._shaders[i];
            if (shader.valid) {
                gl.attachShader(this.handle, shader.handle);
            }
        }

        gl.linkProgram(this.handle);

        if (!gl.getProgramParameter(this.handle, gl.LINK_STATUS)) {
            SceneJS.log.error("Shader program failed to link: " + gl.getProgramInfoLog(this.handle));
        }

        // Discover uniforms and samplers

        var numUniforms = gl.getProgramParameter(this.handle, gl.ACTIVE_UNIFORMS);
        var valueIndex = 0;
        for (i = 0; i < numUniforms; ++i) {
            u = gl.getActiveUniform(this.handle, i);
            if (u) {
                u_name = u.name;
                if (u_name[u_name.length - 1] == "\u0000") {
                    u_name = u_name.substr(0, u_name.length - 1);
                }
                location = gl.getUniformLocation(this.handle, u_name);
                if ((u.type == gl.SAMPLER_2D) || (u.type == gl.SAMPLER_CUBE) || (u.type == 35682)) {
                    this._samplers[u_name] = new SceneJS._webgl.Sampler(gl, this.handle, u_name, u.type, u.size, location);
                } else {
                    this._uniforms[u_name] = new SceneJS._webgl.Uniform(gl, this.handle, u_name, u.type, u.size, location, valueIndex);
                    ++valueIndex;
                }
            }
        }

        // Discover attributes

        var numAttribs = gl.getProgramParameter(this.handle, gl.ACTIVE_ATTRIBUTES);
        for (i = 0; i < numAttribs; i++) {
            a = gl.getActiveAttrib(this.handle, i);
            if (a) {
                location = gl.getAttribLocation(this.handle, a.name);
                this._attributes[a.name] = new SceneJS._webgl.Attribute(gl, this.handle, a.name, a.type, a.size, location);
            }
        }

        stats.load.programCompilation += SceneJS.timer.now() - startTime;

        // Program allocated
        this.allocated = true;

    } // if (this.handle)
};


SceneJS._webgl.Program.prototype.bind = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.useProgram(this.handle);
};

SceneJS._webgl.Program.prototype.getUniformLocation = function (name) {
    if (!this.allocated) {
        return;
    }
    var u = this._uniforms[name];
    if (u) {
        return u.getLocation();
    }
};

SceneJS._webgl.Program.prototype.getUniform = function (name) {
    if (!this.allocated) {
        return;
    }
    var u = this._uniforms[name];
    if (u) {
        return u;
    }
};

SceneJS._webgl.Program.prototype.getAttribute = function (name) {
    if (!this.allocated) {
        return;
    }
    var attr = this._attributes[name];
    if (attr) {
        return attr;
    }
};

SceneJS._webgl.Program.prototype.bindArrayBuffer = function (name, buffer) {
    if (!this.allocated) {
        return;
    }
    var attr = this._attributes[name];
    if (attr) {
        attr.bindArrayBuffer(buffer);
    }
};

SceneJS._webgl.Program.prototype.bindTexture = function (name, texture, unit) {
    if (!this.allocated) {
        return false;
    }
    var sampler = this._samplers[name];
    if (sampler) {
        return sampler.bindTexture(texture, unit);
    } else {
        return false;
    }
};

SceneJS._webgl.Program.prototype.destroy = function () {
    if (!this.allocated) {
        return;
    }
    this.gl.deleteProgram(this.handle);
    for (var s in this._shaders) {
        this.gl.deleteShader(this._shaders[s].handle);
    }
    this.handle = null;
    this._attributes = null;
    this._uniforms = null;
    this._samplers = null;
    this.allocated = false;
};


SceneJS._webgl.Program.prototype.setUniform = function (name, value) {
    if (!this.allocated) {
        return;
    }
    var u = this._uniforms[name];
    if (u) {
        u.setValue(value);
    }
};
;SceneJS._webgl.Sampler = function (gl, program, name, type, size, location) {

    this.bindTexture = function (texture, unit) {
        if (texture.bind(unit)) {
            gl.uniform1i(location, unit);
            return true;
        }
        return false;
    };
};
;/**
 * A vertex/fragment shader in a program
 *
 * @private
 * @param gl WebGL gl
 * @param gl.VERTEX_SHADER | gl.FRAGMENT_SHADER
 * @param source Source code for shader
 * @param logging Shader will write logging's debug channel as it compiles
 */
SceneJS._webgl.Shader = function (stats, gl, type, source) {

    /**
     * True as soon as this shader is allocated and ready to go
     * @type {boolean}
     */
    this.allocated = false;

    var startTime = SceneJS.timer.now();

    this.handle = gl.createShader(type);

    if (!this.handle) {
        throw SceneJS_error.fatalError(SceneJS.errors.OUT_OF_VRAM, "Failed to create WebGL shader");
    }

    gl.shaderSource(this.handle, source);
    gl.compileShader(this.handle);

    this.valid = (gl.getShaderParameter(this.handle, gl.COMPILE_STATUS) != 0);

    if (!this.valid) {

        if (!gl.isContextLost()) { // Handled explicitely elsewhere, so wont rehandle here

            SceneJS.log.error("Shader program failed to compile: " + gl.getShaderInfoLog(this.handle));
            SceneJS.log.error("Shader source:");
            var lines = source.split('\n');
            for (var j = 0; j < lines.length; j++) {
                SceneJS.log.error((j + 1) + ": " + lines[j]);
            }

            throw SceneJS_error.fatalError(
                SceneJS.errors.SHADER_COMPILATION_FAILURE, "Shader program failed to compile");
        }
    }

    stats.load.shaderCompilation += SceneJS.timer.now() - startTime;

    this.allocated = true;
};
;
SceneJS._webgl.Texture2D = function (gl, cfg) {

    try {
        this._init(gl, cfg);
    } catch (e) {
        throw SceneJS_error.fatalError(SceneJS.errors.OUT_OF_VRAM, "Failed to create texture: " + e.message || e);
    }

};

SceneJS._webgl.Texture2D.prototype._init = function (gl, cfg) {
    /**
     * True as soon as this texture is allocated and ready to go
     * @type {boolean}
     */
    this.allocated = false;
    this.gl = gl;

    this.target = cfg.target || gl.TEXTURE_2D;
    this.minFilter = cfg.minFilter;
    this.magFilter = cfg.magFilter;
    this.wrapS = cfg.wrapS;
    this.wrapT = cfg.wrapT;
    this.update = cfg.update;  // For dynamically-sourcing textures (ie movies etc)
    this.texture = cfg.texture;
    this.compressed = !!cfg.compressed;
    this.format = gl.RGBA;
    this.isDepth = false;
    this.depthMode = 0;
    this.depthCompareMode = 0;
    this.depthCompareFunc = 0;

    gl.bindTexture(this.target, this.texture);

    if (cfg.minFilter) {
        gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, cfg.minFilter);
    }

    if (cfg.magFilter) {
        gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, cfg.magFilter);
    }

    if (cfg.wrapS) {
        gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, cfg.wrapS);
    }

    if (cfg.wrapT) {
        gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, cfg.wrapT);
    }

    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

    if (!this.compressed &&
         (this.minFilter == gl.NEAREST_MIPMAP_NEAREST ||
          this.minFilter == gl.LINEAR_MIPMAP_NEAREST ||
          this.minFilter == gl.NEAREST_MIPMAP_LINEAR ||
          this.minFilter == gl.LINEAR_MIPMAP_LINEAR)) {
        gl.generateMipmap(this.target);
    }

    gl.bindTexture(this.target, null);

    this.allocated = true;
}

SceneJS._webgl.Texture2D.prototype.bind = function (unit) {
    if (!this.allocated) {
        return;
    }

    var gl = this.gl;

    if (this.texture) {
        gl.activeTexture(gl["TEXTURE" + unit]);
        gl.bindTexture(this.target, this.texture);
        if (this.update) {
            this.update(gl);
        }
        return true;
    }
    return false;
};

SceneJS._webgl.Texture2D.prototype.unbind = function (unit) {
    if (!this.allocated) {
        return;
    }

    var gl = this.gl;

    if (this.texture) {
        gl.activeTexture(gl["TEXTURE" + unit]);
        gl.bindTexture(this.target, null);
    }
};

SceneJS._webgl.Texture2D.prototype.destroy = function () {
    if (!this.allocated) {
        return;
    }

    var gl = this.gl;

    if (this.texture) {
        gl.deleteTexture(this.texture);
        this.texture = null;
    }
};


SceneJS._webgl.clampImageSize = function (image, numPixels) {
    var n = image.width * image.height;
    if (n > numPixels) {
        var ratio = numPixels / n;

        var width = image.width * ratio;
        var height = image.height * ratio;

        var canvas = document.createElement("canvas");

        canvas.width = SceneJS._webgl.nextHighestPowerOfTwo(width);
        canvas.height = SceneJS._webgl.nextHighestPowerOfTwo(height);

        var ctx = canvas.getContext("2d");

        ctx.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);

        image = canvas;
    }
    return image;
};

SceneJS._webgl.ensureImageSizePowerOfTwo = function (image) {
    if (!SceneJS._webgl.isPowerOfTwo(image.width) || !SceneJS._webgl.isPowerOfTwo(image.height)) {
        var canvas = document.createElement("canvas");
        canvas.width = SceneJS._webgl.nextHighestPowerOfTwo(image.width);
        canvas.height = SceneJS._webgl.nextHighestPowerOfTwo(image.height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image,
            0, 0, image.width, image.height,
            0, 0, canvas.width, canvas.height);
        image = canvas;
    }
    return image;
};

SceneJS._webgl.isPowerOfTwo = function (x) {
    return (x & (x - 1)) == 0;
};

SceneJS._webgl.nextHighestPowerOfTwo = function (x) {
    --x;
    for (var i = 1; i < 32; i <<= 1) {
        x = x | x >> i;
    }
    return x + 1;
};
;(function() {

    var SET_VALUE_FUNCS = (function() {
        var FUNCS = {};
        var canvas = document.createElement("canvas");
        var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

        if(!gl) {
            return FUNCS;
        }

        FUNCS[gl.BOOL] = function (v) {
            if (this.value === v) {
                return;
            }
            this.value = v;
            this.gl.uniform1i(this.location, v);
        };

        FUNCS[gl.BOOL_VEC2] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1]) {
                return;
            }
            this.value[0] = v[0];
            this.value[1] = v[1];
            this.gl.uniform2iv(this.location, v);
        };

        FUNCS[gl.BOOL_VEC3] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1] && this.value[2] === v[2]) {
                return;
            }
            this.value[0] = v[0];
            this.value[1] = v[1];
            this.value[2] = v[2];
            this.gl.uniform3iv(this.location, v);
        };

        FUNCS[gl.BOOL_VEC4] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1] && this.value[2] === v[2] && this.value[3] === v[3]) {
                return;
            }
            this.value[0] = v[0];
            this.value[1] = v[1];
            this.value[2] = v[2];
            this.value[3] = v[3];
            this.gl.uniform4iv(this.location, v);
        };

        FUNCS[gl.INT_VEC2] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1]) {
                return;
            }
            this.value.set(v);
            this.gl.uniform2iv(this.location, v);
        };

        FUNCS[gl.INT_VEC3] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1] && this.value[2] === v[2]) {
                return;
            }
            this.value.set(v);
            this.gl.uniform3iv(this.location, v);
        };

        FUNCS[gl.INT_VEC4] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1] && this.value[2] === v[2] && this.value[3] === v[3]) {
                return;
            }
            this.value.set(v);
            this.gl.uniform4iv(this.location, v);
        };

        FUNCS[gl.FLOAT] = function (v) {
            if (this.value === v) {
                return;
            }
            this.value = v;
            this.gl.uniform1f(this.location, v);
        };

        FUNCS[gl.FLOAT_VEC2] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1]) {
                return;
            }
            this.value.set(v);
            this.gl.uniform2fv(this.location, v);
        };

        FUNCS[gl.FLOAT_VEC3] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1] && this.value[2] === v[2]) {
                return;
            }
            this.value.set(v);
            this.gl.uniform3fv(this.location, v);
        };

        FUNCS[gl.FLOAT_VEC4] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1] && this.value[2] === v[2] && this.value[3] === v[3]) {
                return;
            }
            this.value.set(v);
            this.gl.uniform4fv(this.location, v);
        };

        FUNCS[gl.FLOAT_MAT2] = function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1] &&
                this.value[2] === v[2] && this.value[3] === v[3]) {
                return;
            }
            this.value.set(v);
            this.gl.uniformMatrix2fv(this.location, gl.FALSE, v);
        };


        FUNCS[gl.FLOAT_MAT3] =function (v) {
            if (this.value[0] === v[0] && this.value[1] === v[1] && this.value[2] === v[2] &&
                this.value[3] === v[3] && this.value[4] === v[4] && this.value[5] === v[5] &&
                this.value[6] === v[6] && this.value[7] === v[7] && this.value[8] === v[8]) {
                return;
            }
            this.value.set(v);
            this.gl.uniformMatrix3fv(this.location, gl.FALSE, v);
        };

        FUNCS[gl.FLOAT_MAT4] =function (v) {
            if (this.value[0] === v[0]   && this.value[1] === v[1]   && this.value[2] === v[2]   && this.value[3] === v[3]   &&
                this.value[4] === v[4]   && this.value[5] === v[5]   && this.value[6] === v[6]   && this.value[7] === v[7]   &&
                this.value[8] === v[8]   && this.value[9] === v[9]   && this.value[10] === v[10] && this.value[11] === v[11] &&
                this.value[12] === v[12] && this.value[13] === v[13] && this.value[14] === v[14] && this.value[15] === v[15]) {
                return;
            }
            this.value.set(v);
            this.gl.uniformMatrix4fv(this.location, gl.FALSE, v);
        };

        return FUNCS;
    })();

    SceneJS._webgl.Uniform = function (gl, program, name, type, size, location, index, logging) {
        // This is just an integer key for caching the uniform's value, more efficient than caching by name.
        this.index = index;
        this.gl = gl;
        this.location = location;
        this.value = getCache(gl, type);
        this.setValue = SET_VALUE_FUNCS[type];
    };


    SceneJS._webgl.Uniform.prototype.getLocation = function() {
        return this.location;
    };

    function getCache(gl, type) {
        if (type === gl.BOOL) {
            return null
        } else if (type === gl.BOOL_VEC2) {
            return new Array(2);
        } else if (type === gl.BOOL_VEC3) {
            return new Array(3);
        } else if (type === gl.BOOL_VEC4) {
            return new Array(4);
        } else if (type === gl.INT) {
            return null;
        } else if (type === gl.INT_VEC2) {
            return new Uint32Array(2);
        } else if (type === gl.INT_VEC3) {
            return new Uint32Array(3);
        } else if (type === gl.INT_VEC4) {
            return new Uint32Array(4);
        } else if (type === gl.FLOAT) {
            return null;
        } else if (type === gl.FLOAT_VEC2) {
            return new Float32Array(2);
        } else if (type === gl.FLOAT_VEC3) {
            return new Float32Array(3);
        } else if (type === gl.FLOAT_VEC4) {
            return new Float32Array(4);
        } else if (type === gl.FLOAT_MAT2) {
            return new Float32Array(4);
        } else if (type === gl.FLOAT_MAT3) {
            return new Float32Array(9);
        } else if (type === gl.FLOAT_MAT4) {
            return new Float32Array(16);
        } else {
            throw "Unsupported shader uniform type: " + type;
        }
    }
})();








;/**
 * Manages scene node event listeners
 * @private
 */
var SceneJS_nodeEventsModule = new (function () {

    var idStack = [];
    var listenerStack = [];
    var stackLen = 0;
    var dirty;

    var defaultCore = {
        type:"listeners",
        stateId:SceneJS._baseStateId++,
        empty:true,
        listeners:[]
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function () {
            stackLen = 0;
            dirty = true;
        });

    SceneJS_events.addListener(
        SceneJS_events.OBJECT_COMPILING,
        function (params) {
            if (dirty) {
                if (stackLen > 0) {
                    var core = {
                        type:"listeners",
                        stateId:idStack[stackLen - 1],
                        listeners:listenerStack.slice(0, stackLen)
                    };
                    params.display.renderListeners = core;
                } else {
                    params.display.renderListeners = defaultCore;
                }
                dirty = false;
            }
        });


    this.preVisitNode = function (node) {

        var renderedSubs = !!node.onRendered;
        var worldPosSubs = !!node.onWorldPos;
        var viewPosSubs = !!node.onViewPos;
        var cameraPosSubs = !!node.onCameraPos;
        var projPosSubs = !!node.onProjPos;
        var canvasPosSubs = !!node.onCanvasPos;

        if (renderedSubs || worldPosSubs || viewPosSubs || cameraPosSubs || projPosSubs || canvasPosSubs) {
            idStack[stackLen] = node.id;

            listenerStack[stackLen] = function (event) {

                // Don't retain - callback must get positions for
                // required coordinate via methods on the event object.
                // That's dirty, therefore deprecated.
                if (renderedSubs) {
                    node.onRendered(event); // DEPRECATED in V3.2
                }

                // Publish retained positions for coordinate systems where subscribed
                if (worldPosSubs) {
                    node.onWorldPos(event.getWorldPos());
                }
                if (viewPosSubs) {
                    node.onViewPos(event.getViewPos());
                }
                if (cameraPosSubs) {
                    node.onCameraPos(event.getCameraPos());
                }
                if (projPosSubs) {
                    node.onProjPos(event.getProjPos());
                }
                if (canvasPosSubs) {
                    node.onCanvasPos(event.getCanvasPos());
                }
            };

            stackLen++;
            dirty = true;
        }
    };

    this.postVisitNode = function (node) {
        if (node.id == idStack[stackLen - 1]) {
            stackLen--;
            dirty = true;
        }
    };

})();

;/**
 * @class Holds state for one or more {@link SceneJS.Node}s.
 *
 * <p>Each {@link SceneJS.Node} has a state core to hold its state, and the core may be shared by other
 * {@link SceneJS.Nodes}s of the same type.</p>
 *
 * <p>The state held by core is rendered by a {@link SceneJS_Chunk}  
 *
 * @private
 */
var SceneJS_Core = function(type) {

    /**
     * The state core type, which will be the same value as the type property on the {@link SceneJS.Node}s that use the core
     * @type String
     * @see SceneJS.Node#type
     */
    this.type = type;

    /**
     * The state core ID, unique within the scene. This ID may be either a string assigned by the application layer via
     * scene node configs, or a number that is automatically generated by the {@link SceneJS_CoreFactory} managing
     * this core instance.
     * @type String|Number
     */
    this.coreId = null;

    /**
     * Uniquely identifies this state core within a {@link SceneJS_Display}.
     *
     * This ID is used by a {@link SceneJS_Display} to reduce redundant state changes when rendering a sequence of cores, 
     * where as a {@link SceneJS_Display} renders a frame it avoids applying consecutive cores that have the
     * same value for this ID.
     *
     * @type Number
     */
    this.stateId = null;

    /**
     * Count of {@link SceneJS.Node} instances this core holds state for
     */
    this.useCount = 0;
};;/**
 * @class Holds state for one or more {@link SceneJS.Node}s.
 *
 * <p>Each {@link SceneJS.Node} has a state core to hold its state, and the core may be shared by other
 * {@link SceneJS.Nodes}s of the same type.</p>
 *
 * <p>The state held by core is rendered by a {@link SceneJS_Chunk}
 *
 * @private
 */
(function() {
    var FLAGS = {
        MATRIX_DIRTY: 1,
        COMPILING:    1 << 1,
        DIRTY:        1 << 2,
    }

    var SceneJS_XformCore = window.SceneJS_XformCore = function() {

        /**
         * The state core type, which will be the same value as the type property on the {@link SceneJS.Node}s that use the core
         * @type String
         * @see SceneJS.Node#type
         */
        this.type = "xform";

        /**
         * The state core ID, unique within the scene. This ID may be either a string assigned by the application layer via
         * scene node configs, or a number that is automatically generated by the {@link SceneJS_CoreFactory} managing
         * this core instance.
         * @type String|Number
         */
        this.coreId = null;

        /**
         * Uniquely identifies this state core within a {@link SceneJS_Display}.
         *
         * This ID is used by a {@link SceneJS_Display} to reduce redundant state changes when rendering a sequence of cores,
         * where as a {@link SceneJS_Display} renders a frame it avoids applying consecutive cores that have the
         * same value for this ID.
         *
         * @type Number
         */
        this.stateId = null;

        /**
         * Count of {@link SceneJS.Node} instances this core holds state for
         */
        this.useCount = 0;

        this.parent = null;         // Parent transform core
        this.cores = [];            // Child transform cores
        this.numCores = 0;          // Number of child transform cores

        this.matrix = mat4.create();
        this.mat = mat4.create();
        this.normalMat = mat4.create();
    };

    SceneJS_XformCore.prototype.setDirty = function () {

        this.flags = this.flags | FLAGS.MATRIX_DIRTY;

        setDirty(this);
    };

    /**
     * Recursively flag this subtree of transforms cores as dirty,
     * ie. needing their matrices rebuilt.
     */
    function setDirty(core) {
        this.flags = this.flags | FLAGS.MATRIX_DIRTY | FLAGS.DIRTY;

        for (var i = 0, len = core.numCores; i < len; i++) {
            setDirty(core.cores[i]);
        }
    }

    /**
     * Pre-multiply matrices at cores on path up to root into matrix at this core
     */

    var matrix = new mat4.create();

    SceneJS_XformCore.prototype.build = function () {

        if (this.flags & FLAGS.MATRIX_DIRTY) {
            if (this.buildMatrix) { // Matrix might be explicit property on some transform node types
                this.buildMatrix();
            }
            this.flags = this.flags & ~FLAGS.MATRIX_DIRTY;
        }

        var parent = this.parent;

        if (parent) {

            matrix.set(this.matrix);

            while (parent) {

                if (parent.flags & FLAGS.MATRIX_DIRTY) {

                    if (parent.buildMatrix) { // Matrix might be explicit property on some transform node types
                        parent.buildMatrix();
                    }
                    parent.mat.set(parent.matrix);
                    mat4.invert(parent.normalMat, parent.matrix);
                    mat4.transpose(parent.normalMat, parent.normalMat);

                    parent.flags = parent.flags & ~FLAGS.MATRIX_DIRTY;
                }

                mat4.multiply(matrix, parent.matrix, matrix);

                parent = parent.parent;
            }

        } else {
            matrix.set(this.matrix);
        }

        this.mat.set(matrix);

        mat4.invert(this.normalMat, matrix);
        mat4.transpose(this.normalMat, this.normalMat);

        this.flags = this.flags & ~FLAGS.DIRTY;
    };

})();
;/**
 * @class Holds state for one or more {@link SceneJS.Node}s.
 *
 * <p>Each {@link SceneJS.Node} has a state core to hold its state, and the core may be shared by other
 * {@link SceneJS.Nodes}s of the same type.</p>
 *
 * <p>The state held by core is rendered by a {@link SceneJS_Chunk}
 *
 * @private
 */
(function() {
    var KD_TREE_MAX_DEPTH = SceneJS.KD_TREE_MAX_DEPTH;
    var KD_TREE_MIN_TRIANGLES = SceneJS.KD_TREE_MIN_TRIANGLES;

    var SceneJS_GeometryCore = window.SceneJS_GeometryCore = function() {

        /**
         * The state core type, which will be the same value as the type property on the {@link SceneJS.Node}s that use the core
         * @type String
         * @see SceneJS.Node#type
         */
        this.type = "xform";

        /**
         * The state core ID, unique within the scene. This ID may be either a string assigned by the application layer via
         * scene node configs, or a number that is automatically generated by the {@link SceneJS_CoreFactory} managing
         * this core instance.
         * @type String|Number
         */
        this.coreId = null;

        /**
         * Uniquely identifies this state core within a {@link SceneJS_Display}.
         *
         * This ID is used by a {@link SceneJS_Display} to reduce redundant state changes when rendering a sequence of cores,
         * where as a {@link SceneJS_Display} renders a frame it avoids applying consecutive cores that have the
         * same value for this ID.
         *
         * @type Number
         */
        this.stateId = null;

        this.kdTree = null;
        this.kdTreeDirty = true;
    };

    // Lazy-build tangents, only when needed as rendering
    SceneJS_GeometryCore.prototype.getTangents = function (uvLayerIdx) {

        // We're only allowed one normal map per drawable, but we'll
        // cache tangents for each UV layer. In practice the cache would
        // only contain one array of tangents, for the UV layer that
        // happens to be used for normal mapping.

        if (!this.tangentBufs) {
            this.tangentBufs = [];
        }
        if (this.tangentBufs[uvLayerIdx]) {
            return this.tangentBufs[uvLayerIdx];
        }
        var arrays = this.arrays;
        var tangents = this.arrays.tangents[uvLayerIdx];
        var gl = this._engine.canvas.gl;
        if (!tangents) {
            // Retaining tangents data after WebGL context recovery
            if (arrays.positions && arrays.indices && arrays.uvs && arrays.uvs[uvLayerIdx]) {
                tangents = SceneJS_math_buildTangents(arrays.positions, arrays.indices, arrays.uvs[uvLayerIdx],
                            this.positionDecodeMat, this.compressedUVs && this.uvDecodeMats[uvLayerIdx]); // Build tangents array;
                this._engine.stats.memory.tangents += tangents.length * tangents.constructor.BYTES_PER_ELEMENT;
            }
        }
        if (tangents) {
            this.tangentBufs[uvLayerIdx] = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, tangents, tangents.length, 3, gl.STATIC_DRAW);
            this.arrays.tangents[uvLayerIdx] = true; // Don't need array anymore.
            return this.tangentBufs[uvLayerIdx];
        } else {
            return null;
        }
    };

    // Buffers for primitive-pick rendering

    SceneJS_GeometryCore.prototype.getPickPositions = function () {
        if (this.pickPositionsBuf) {
            return this.pickPositionsBuf;
        }

        createPickArrays(this);

        return this.pickPositionsBuf;
    };

    SceneJS_GeometryCore.prototype.getPickColors = function () {
        if (this.pickColorsBuf) {
            return this.pickColorsBuf;
        }

        createPickArrays(this);

        return this.pickColorsBuf;
    };

    SceneJS_GeometryCore.prototype.getKdTree = function () {
        if (!this.kdTree) {
            this.buildKdTree();
        }
        
        return this.kdTree;
    };

    // k-d tree nodes have the following structure: 
    //   {
    //       triangles: [NUMBER, NUMBER, ...],    // Indices of triangles in this leaf node (null if not leaf node)
    //       left: kdTreeNode,                    // Left subtree (null if leaf node)
    //       right: kdTreeNode,                   // Right subtree (null if leaf node)
    //       leaf: BOOLEAN,                       // Is this a leaf node?
    //       splitDim: 0,                         // Dimension split on at this node (0 = x, 1 = y, 2 = z)
    //       bb: {                                // Bounding box of triangles in this node and its subtrees.
    //           min: VEC3,
    //           max: VEC3
    //       }
    //   }
    // 
    SceneJS_GeometryCore.prototype.buildKdTree = function () {
        if (!this.kdTreeDirty) {
            return;
        }

        var positions = this.arrays.positions;
        var indices = this.arrays.indices;

        if (!positions || !indices) {
            return;
        }

        var numTris = this.arrays.indices.length / 3;
        var triangles = new Array(numTris);
        for (var i = 0; i < numTris; ++i) {
            triangles[i] = i;
        }
        this.kdTree = buildKdTreeNode(triangles, indices, positions, this.positionDecodeMat, 0);
        this.kdTreeDirty = false;
    };

    function createPickArrays(core) {
        var gl = core._engine.canvas.gl;

        var pickArrays, pickPositions, pickColors;

        if (core.arrays.positions) {
            pickArrays = SceneJS_math_getPickPrimitives(core.arrays.positions, core.arrays.indices, core.compressedPositions);
            pickPositions = pickArrays.positions;
            pickColors = pickArrays.colors;
            core.pickPositionsBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickPositions, pickPositions.length, 3, gl.STATIC_DRAW);
            core._engine.stats.memory.pickPositions += pickPositions.length * pickPositions.constructor.BYTES_PER_ELEMENT;
            core._engine.stats.memory.pickColors += pickColors.length * pickColors.constructor.BYTES_PER_ELEMENT;
        } else {
            pickColors = SceneJS_math_getPickColors(core.arrays.indices);
            core._engine.stats.memory.pickColors += pickColors.length * pickColors.constructor.BYTES_PER_ELEMENT;
        }

        core.pickColorsBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickColors, pickColors.length, 4, gl.STATIC_DRAW, true);
    }

    var dimLength = vec3.create();
    var position = vec3.create();

    function buildKdTreeNode(triangles, indices, positions, decompress, depth) {
        var min = vec3.create();
        var max = vec3.create();

        var node = {
            triangles: null,
            left: null,
            numLeft: 0,
            right: null,
            numRight: 0,
            leaf: false,
            splitDim: 0,
            bb: {
                min: min,
                max: max
            }
        };

        if (triangles.length === 0) {
            node.triangles = triangles;
            node.leaf = true;
            return node;
        }

        min[0] = min[1] = min[2] = Number.POSITIVE_INFINITY;
        max[0] = max[1] = max[2] = Number.NEGATIVE_INFINITY;

        var i, len;
        
        for (t = 0, len = triangles.length; t < len; ++t) {
            var ii = triangles[t] * 3;

            for (var j = 0; j < 3; ++j) {
                var pi = indices[ii + j] * 3;
                position[0] = positions[pi];
                position[1] = positions[pi + 1];
                position[2] = positions[pi + 2];

                if (decompress) {
                    SceneJS_math_decompressPosition(position, position, decompress);
                }

                if (position[0] < min[0]) {
                    min[0] = position[0]
                } 

                if (position[0] > max[0]) {
                    max[0] = position[0]
                }

                if (position[1] < min[1]) {
                    min[1] = position[1]
                } 

                if (position[1] > max[1]) {
                    max[1] = position[1]
                }

                if (position[2] < min[2]) {
                    min[2] = position[2]
                } 

                if (position[2] > max[2]) {
                    max[2] = position[2]
                }
            }
        }

        if (triangles.length < KD_TREE_MIN_TRIANGLES || depth > KD_TREE_MAX_DEPTH) {
            node.triangles = triangles;
            node.leaf = true;
            return node;
        }

        dimLength[0] = max[0] - min[0];
        dimLength[1] = max[1] - min[1];
        dimLength[2] = max[2] - min[2];

        var dim = 0;

        if (dimLength[1] > dimLength[dim]) {
            dim = 1;
        }

        if (dimLength[2] > dimLength[dim]) {
            dim = 2;
        }

        node.splitDim = dim;

        var mid = (min[dim] + max[dim]) / 2;
        var left = new Array(triangles.length);
        var numLeft = 0;
        var right = new Array(triangles.length);
        var numRight = 0;

        for (t = 0, len = triangles.length; t < len; ++t) {
            var ii = triangles[t] * 3;
            var i0 = indices[ii];
            var i1 = indices[ii + 1];
            var i2 = indices[ii + 2];

            var pi0 = i0 * 3;
            var pi1 = i1 * 3;
            var pi2 = i2 * 3;

            var v1 = positions[pi0 + dim];
            var v2 = positions[pi1 + dim];
            var v3 = positions[pi2 + dim];

            if (decompress) {
                var scale = decompress[dim * 5];
                var translate = decompress[dim + 12]
                v1 = v1 * scale + translate;
                v2 = v2 * scale + translate;
                v3 = v3 * scale + translate;
            }

            if (v1 <= mid || v2 <= mid || v3 <= mid) {
                left[numLeft++] = triangles[t];
            } else {
                right[numRight++] = triangles[t];
            }
        }

        node.numLeft = left.length = numLeft;
        node.numRight = right.length = numRight;

        node.left = buildKdTreeNode(left, indices, positions, decompress, depth + 1);
        node.right = buildKdTreeNode(right, indices, positions, decompress, depth + 1);

        return node;
    }

})();
;/**
 * @class Holds state for one or more {@link SceneJS.Node}s.
 *
 * <p>Each {@link SceneJS.Node} has a state core to hold its state, and the core may be shared by other
 * {@link SceneJS.Nodes}s of the same type.</p>
 *
 * <p>The state held by core is rendered by a {@link SceneJS_Chunk}
 *
 * @private
 */
var SceneJS_PropertiesCore = function() {

    var FLAGS = SceneJS.PROPERTY_FLAGS;

    /**
     * The state core type, which will be the same value as the type property on the {@link SceneJS.Node}s that use the core
     * @type String
     * @see SceneJS.Node#type
     */
    this.type = "properties";

    /**
     * The state core ID, unique within the scene. This ID may be either a string assigned by the application layer via
     * scene node configs, or a number that is automatically generated by the {@link SceneJS_CoreFactory} managing
     * this core instance.
     * @type String|Number
     */
    this.coreId = null;

    /**
     * Uniquely identifies this state core within a {@link SceneJS_Display}.
     *
     * This ID is used by a {@link SceneJS_Display} to reduce redundant state changes when rendering a sequence of cores,
     * where as a {@link SceneJS_Display} renders a frame it avoids applying consecutive cores that have the
     * same value for this ID.
     *
     * @type Number
     */
    this.stateId = null;

    /**
     * Count of {@link SceneJS.Node} instances this core holds state for
     */
    this.useCount = 0;

    this.xrayParams = new Float32Array([0, 0.4, 0.8, 1.0]); // x = xray, y = glassfactor, z = murkiness, w = opacity
    this.colorParams = new Float32Array([0, 1, 0]); // x = saturation, y = contrast, z = brightness
    this.clippingParams = new Float32Array([1.0, 1.0, 1.0, 1.0]); // RGB = solidColor, A = Clipping
    this.tintColor = new Float32Array([1.0, 1.0, 1.0 ]);
    this.name = null;              // Picking name
    this.layer = 0;              // Rendering priority
    this.glassFactor = 0.4; // Full glass effect
    this.murkiness = 0.8;
    this.opacity = 1.0;
    this.saturation = 0;
    this.contrast = 1.0;
    this.brightness = 0;
    this.flags = FLAGS.PICKING | FLAGS.ENABLED | FLAGS.BACKFACES | FLAGS.REFLECTIVE | FLAGS.CCW | FLAGS.DEPTH_MASK;
    this.transparent = false;
    this.blend = false;
    this.hash = "refl;;;;";
};

SceneJS_PropertiesCore.prototype.getFlag = function(flag) {
    return !!(this.flags & flag);
};

SceneJS_PropertiesCore.prototype.setFlag = function(flag, value) {
    this.flags = value ? (this.flags | flag) : (this.flags & ~flag);
};

SceneJS_PropertiesCore.prototype.resetTransparency = function() {
    var xray = this.xrayParams[0];
    var opacity = this.xrayParams[3];
    this.transparent = opacity < 1 || !!(this.getFlag(SceneJS.PROPERTY_FLAGS.XRAY_ENABLED) && xray);
};
;/**
 * @class Manages creation, recycle and destruction of {@link SceneJS_Core} instances
 * @private
 */
var SceneJS_CoreFactory = function () {

    this._stateMap = new SceneJS_Map(null, SceneJS._baseStateId);  // For creating unique state IDs for cores

    this._cores = {}; // Map of cores for each type
};

/* HACK - allows different types of node to have same type of core, eg. "rotate" and "translate" nodes can both have an "xform" core
 */
SceneJS_CoreFactory.coreAliases = {
    "rotate":"xform",
    "translate":"xform",
    "scale":"xform",
    "matrix":"xform",
    "xform":"xform"
};

SceneJS_CoreFactory.coreConstructors = {
    xform: SceneJS_XformCore,
    geometry: SceneJS_GeometryCore,
    properties: SceneJS_PropertiesCore,
    default: SceneJS_Core
};

/**
 * Gets a core of the given type from this factory. Reuses any existing existing core of the same type and ID.
 *
 * The caller (a scene node) will then augment the core with type-specific attributes and methods.
 *
 * @param {String} type Type name of core, e.g. "material", "texture"
 * @param {String} coreId ID for the core, unique among all cores of the given type within this factory
 * @returns {Core} The core
 */
SceneJS_CoreFactory.prototype.getCore = function (type, coreId) {

    /* HACK - allows different types of node to have same type of core, eg. "rotate" and "translate" nodes can both have an "xform" core
     */
    var alias = SceneJS_CoreFactory.coreAliases[type];
    if (alias) {
        type = alias;
    }

    var cores = this._cores[type];

    if (!cores) {
        cores = this._cores[type] = {};
    }

    var core;

    if (coreId) { // Attempt to reuse a core

        core = cores[coreId];

        if (core) {
            core.useCount++;
            return core;
        }
    }

    var Core = SceneJS_CoreFactory.coreConstructors[type] || SceneJS_CoreFactory.coreConstructors.default;

    core = new Core(type);
    core.useCount = 1;  // One user so far

    core.stateId = this._stateMap.addItem(core);
    core.coreId = (coreId != undefined && coreId != null) ? coreId : core.stateId; // Use state ID as core ID by default

    cores[core.coreId] = core;

    return core;
};


/**
 * Tests if a core of the given type and ID currently exists within this factory.
 *
 * @param {String} type Type name of core, e.g. "material", "texture"
 * @param {String} coreId ID for the core, unique among all cores of the given type within this factory
 * @returns {Boolean} True if the core exists
 */
SceneJS_CoreFactory.prototype.hasCore = function (type, coreId) {
    // HACK - allows different types of node to have same type of core, eg. "rotate" and "translate" nodes can both have an "xform" core
    var alias = SceneJS_CoreFactory.coreAliases[type];
    if (alias) {
        type = alias;
    }
    var cores = this._cores[type];
    return cores && cores[coreId];
};

/**
 * Releases a state core back to this factory, destroying it if the core's use count is then zero.
 * @param {Core} core Core to release
 */
SceneJS_CoreFactory.prototype.putCore = function (core) {

    if (core.useCount == 0) {
        return; // In case of excess puts
    }

    if (--core.useCount <= 0) {                    // Release shared core if use count now zero

        var cores = this._cores[core.type];

        delete cores[core.coreId];

        this._stateMap.removeItem(core.stateId);  // Release state ID for reuse
    }
};

/**
 * Reallocates WebGL resources for cores within this factory
 */
SceneJS_CoreFactory.prototype.webglRestored = function () {

    var cores;
    var core;

    for (var type in this._cores) {
        if (this._cores.hasOwnProperty(type)) {

            cores = this._cores[type];

            if (cores) {

                for (var coreId in cores) {
                    if (cores.hasOwnProperty(coreId)) {

                        core = cores[coreId];

                        if (core && core.webglRestored) { // Method augmented on core by user
                            core.webglRestored();
                        }
                    }
                }
            }
        }
    }
};
;/**
 * @class The basic scene graph node type
 */
SceneJS.Node = function () {
};

/**
 * @class Basic scene graph node
 */
SceneJS.Node.prototype.constructor = SceneJS.Node;

/**
 * Called by SceneJS_Engine after it has instantiated the node
 *
 * @param {SceneJS_Engine} engine The engine which will manage this node
 * @param {SceneJS_Core} core The core which will hold state for this node, may be shared with other nodes of the same type
 * @param cfg Configuration for this node
 * @param {String} cfg.id ID for the node, unique among all nodes in the scene
 * @param {String} cfg.type type Type of this node (eg. "material", "texture" etc)
 * @param {Object} cfg.data Optional arbitrary JSON object to attach to node
 * @param {String} nodeId Optional ID for node
 */
SceneJS.Node.prototype._construct = function (engine, core, cfg, nodeId) {

    /**
     * Engine that manages this node
     * @type SceneJS_Engine
     */
    this._engine = engine;

    /**
     * The core which holds state for this node, may be shared with other nodes of the same type
     * @type SceneJS_Core
     */
    this._core = core;

    /**
     * The core ID
     * @type {String|Number}
     */
    this.coreId = core.coreId;

    /**
     * ID of this node, unique within its scene. The ID is a string if it was defined by the application
     * via the node's JSON configuration, otherwise it is a number if it was left to SceneJS to automatically create.
     * @type String|Number
     */
    this.id = cfg.id || cfg.nodeId || nodeId;

    /**
     * Type of this node (eg. "material", "texture" etc)
     * @type String
     */
    this.type = cfg.type || "node";

    /**
     * Optional arbitrary JSON object attached to this node
     * @type JSON
     */
    this.data = cfg.data;

    /**
     * Parent node
     * @type SceneJS.Node
     */
    this.parent = null;

    /**
     * Child nodes
     * @type SceneJS.Node[]
     */
    this.nodes = [];

    /**
     *
     */
    this.dirty = false;

    this.disabled = false;

    /**
     *
     */
    this.branchDirty = false;

    if (this._init) {
        this._init(cfg);
    }
};

SceneJS.Node.prototype.disable = function () {
    if (!this.disabled) {
        this.disabled = true;
        this._engine.branchDirty(this);
    }
};

SceneJS.Node.prototype.enable = function () {
    if (this.disabled) {
        this.disabled = false;
        this._engine.branchDirty(this);
    }
};

/**
 * Notifies that an asynchronous task has started on this node
 * @param {String} [description] Description - will be "Task" by default
 * @return {String} Unique ID for the task, which may be given to {@link #taskFinished} or {@link #taskFailed}
 */
SceneJS.Node.prototype.taskStarted = function (description) {
    return SceneJS_sceneStatusModule.taskStarted(this, description || "Task");
};

/**
 * Notifies that a task, whose initiation was previously notified with {@link #taskStarted},
 * has now completed successfully.
 * @param {String} taskId Unique ID for the task, which was got with {@link #taskStarted}
 * @return null
 */
SceneJS.Node.prototype.taskFinished = function (taskId) {
    return SceneJS_sceneStatusModule.taskFinished(taskId);
};

/**
 * Notifies that a task, whose initiation was previously notified with {@link #taskStarted},
 * has failed.
 * @param {String} taskId Unique ID for the task, which was got with {@link #taskStarted}
 * @return null
 */
SceneJS.Node.prototype.taskFailed = function (taskId) {
    return SceneJS_sceneStatusModule.taskFailed(taskId);
};

/**
 * Logs a message in the context of this node
 * @param {String} [channel] Logging channel - "error", "warn" or "info" (default)
 * @param {String} msg Message to log
 */
SceneJS.Node.prototype.log = function () {
    var channel;
    var msg;
    if (arguments.length == 1) {
        channel = "info";
        msg = arguments[0];
    } else if (arguments.length == 2) {
        channel = arguments[0];
        msg = arguments[1];
    }
    switch (channel) {
        case "warn":
            msg = "WARN;  [SceneJS.Node type=" + this.type + ", id=" + this.id + "] : " + msg;
            break;
        case "error":
            msg = "ERROR; [SceneJS.Node type=" + this.type + ", id=" + this.id + "] : " + msg;
            break;
        default:
            msg = "INFO;  [SceneJS.Node type=" + this.type + ", id=" + this.id + "] : " + msg;
            break;
    }

    if (console[channel]) {
        console[channel](msg);
    } else {
        console.log(msg);
    }
};

/**
 * Returns this node's {@link SceneJS.Scene}
 */
SceneJS.Node.prototype.getScene = function () {
    return this._engine.scene;
};

/**
 * Returns the ID of this node's core
 */
SceneJS.Node.prototype.getCoreId = function () {
    return this._core.coreId;
};

/**
 * Get the node's ID
 *
 */
SceneJS.Node.prototype.getID = function () {
    return this.id;
};

/**
 * Alias for getID
 *  @function
 */
SceneJS.Node.prototype.getId = function () {
    return this.id;
};

/**
 * Alias for getID
 *  @function
 */
SceneJS.Node.prototype.getNodeId = function () {
    return this.id;
};


/**
 * Returns the node's type. For the Node base class, it is "node", overridden in sub-classes.
 */
SceneJS.Node.prototype.getType = function () {
    return this.type;
};

/**
 * Returns the data object attached to this node.
 */
SceneJS.Node.prototype.getData = function () {
    return this.data;
};

/**
 * Sets a data object on this node.
 */
SceneJS.Node.prototype.setData = function (data) {
    this.data = data;
    return this;
};

/**
 * Returns the number of child nodes
 */
SceneJS.Node.prototype.getNumNodes = function () {
    return this.nodes.length;
};

/** Returns child nodes
 * @returns {Array} Child nodes
 */
SceneJS.Node.prototype.getNodes = function () {
    return this.nodes.slice(0);
};

/** Returns child node at given index. Returns null if no node at that index.
 * @param {Number} index The child index
 * @returns {Node} Child node, or null if not found
 */
SceneJS.Node.prototype.getNodeAt = function (index) {
    if (index < 0 || index >= this.nodes.length) {
        return null;
    }
    return this.nodes[index];
};

/** Returns first child node. Returns null if no child nodes.
 * @returns {Node} First child node, or null if not found
 */
SceneJS.Node.prototype.getFirstNode = function () {
    if (this.nodes.length == 0) {
        return null;
    }
    return this.nodes[0];
};

/** Returns last child node. Returns null if no child nodes.
 * @returns {Node} Last child node, or null if not found
 */
SceneJS.Node.prototype.getLastNode = function () {
    if (this.nodes.length == 0) {
        return null;
    }
    return this.nodes[this.nodes.length - 1];
};

/** Returns child node with the given ID.
 * Returns null if no such child node found.
 */
SceneJS.Node.prototype.getNode = function (id) {
    for (var i = 0; i < this.nodes.length; i++) {
        if (this.nodes[i].id == id) {
            return this.nodes[i];
        }
    }
    return null;
};

/** Disconnects the child node at the given index from its parent node
 * @param {int} index Child node index
 * @returns {Node} The disconnected child node if located, else null
 */
SceneJS.Node.prototype.disconnectNodeAt = function (index) {
    var r = this.nodes.splice(index, 1);
    if (r.length > 0) {
        r[0]._disconnectFromScene();
        r[0].parent = null;
        this._engine.branchDirty(this);
        return r[0];
    } else {
        return null;
    }
};

/** Disconnects the child node from its parent, given as a node object
 * @param {String | Node} id The target child node, or its ID
 * @returns {Node} The removed child node if located
 */
SceneJS.Node.prototype.disconnect = function () {
    if (this.parent) {
        for (var i = 0; i < this.parent.nodes.length; i++) {
            if (this.parent.nodes[i] === this) {
                var node = this.parent.disconnectNodeAt(i);
                this._disconnectFromScene();
                this.parent = null;
                return node;
            }
        }
        this._disconnectFromScene();
        this.parent = null;
    }
    return null;
};

/**
 * Connection callback that can be overridden in
 * specific node types
 */
SceneJS.Node.prototype._connectToScene = function () {
    if (this._connect) {
        this._connect();
    }
    for (var i = 0, len = this.nodes.length; i < len; i++) {
        this.nodes[i]._connectToScene();
    }
};

/**
 * Disconnection callback that can be overridden in
 * specific node types
 */
SceneJS.Node.prototype._disconnectFromScene = function () {
    if (this._disconnect) {
        this._disconnect();
    }
    for (var i = 0, len = this.nodes.length; i < len; i++) {
        this.nodes[i]._disconnectFromScene();
    }
};

/** Removes the child node at the given index
 * @param {int} index Child node index
 */
SceneJS.Node.prototype.removeNodeAt = function (index) {
    var child = this.disconnectNodeAt(index);
    if (child) {
        child.destroy();
    }
};

/** Removes the child node, given as either a node object or an ID string.
 * @param {String | Node} id The target child node, or its ID
 * @returns {Node} The removed child node if located
 */
SceneJS.Node.prototype.removeNode = function (node) {

    if (!node) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "Node#removeNode - node argument undefined");
    }

    if (!node._compile) {
        if (typeof node == "string") {
            var gotNode = this._engine.findNode(node);
            if (!gotNode) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.NODE_NOT_FOUND,
                    "Node#removeNode - node not found anywhere: '" + node + "'");
            }
            node = gotNode;
        }
    }

    if (node._compile) { //  instance of node
        for (var i = 0; i < this.nodes.length; i++) {
            if (this.nodes[i] === node) {
                var removedNode = this.removeNodeAt(i);
                return removedNode;
            }
        }
    }

    throw SceneJS_error.fatalError(
        SceneJS.errors.NODE_NOT_FOUND,
        "Node#removeNode - child node not found: " + (node._compile ? ": " + node.id : node));
};

/** Disconnects all child nodes from their parent node and returns them in an array.
 */
SceneJS.Node.prototype.disconnectNodes = function () {
    var len = this.nodes.length;
    for (var i = 0; i < len; i++) {  // Unlink nodes from this
        this.nodes[i]._disconnectFromScene();
        this.nodes[i].parent = null;
    }
    var nodes = this.nodes;
    this.nodes = [];
    this._engine.branchDirty(this);
    return nodes;
};

/** Removes all child nodes and returns them in an array.
 */
SceneJS.Node.prototype.removeNodes = function () {
    var nodes = this.disconnectNodes();
    for (var i = 0; i < nodes.length; i++) {
        nodes[i].destroy();
    }
};

/** Destroys this node and moves children up to parent, inserting them where this node resided.
 */
SceneJS.Node.prototype.splice = function () {

    var i, len;

    if (this.parent == null) {
        return null;
    }
    var parent = this.parent;
    var nodes = this.disconnectNodes();
    for (i = 0, len = nodes.length; i < len; i++) {  // Link this node's nodes to new parent
        nodes[i].parent = this.parent;
        nodes[i]._connectToScene();
    }
    for (i = 0, len = parent.nodes.length; i < len; i++) { // Replace node on parent's nodes with this node's nodes
        if (parent.nodes[i] === this) {

            parent.nodes.splice.apply(parent.nodes, [i, 1].concat(nodes));

            this.nodes = [];
            this._disconnectFromScene();
            this.parent = null;

            this.destroy();

            this._engine.branchDirty(parent);

            return parent;
        }
    }
};

/** Appends multiple child nodes
 */
SceneJS.Node.prototype.addNodes = function (nodes) {
    if (!nodes) {
        return null;
    }
    for (var i = nodes.length - 1; i >= 0; i--) {
        this.addNode(nodes[i]);
    }
};

/** Appends a child node
 */
SceneJS.Node.prototype.addNode = function (node, ok) {

    node = node || {};

    // Graft node object
    if (node._compile) {
        if (node.parent != null) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Node#addNode - node argument is still attached to another parent");
        }
        this.nodes.push(node);
        node.parent = this;
        node._connectToScene();
        this._engine.branchDirty(node);
        if (ok) {
            ok(node);
        }
        return node;
    }

    // Graft node object by ID reference
    if (typeof node == "string") {
        var gotNode = this._engine.findNode(node);
        if (!gotNode) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Node#addNode - node not found: '" + node + "'");
        }
        node = gotNode;
        if (node.parent != null) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Node#addNode - node argument is still attached to another parent");
        }
        this.nodes.push(node);
        node.parent = this;
        node._connectToScene();
        this._engine.branchDirty(node);
        if (ok) {
            ok(node);
        }
        return node;
    }

    // Create node

    node.type = node.type || "node";

    if (node.type == "node" || this._engine.hasNodeType(node.type)) {

        // Root node's type is already loaded, so we are able
        // to create the root synchronously. When the caller
        // is creating a core node type, then by this contract
        // it can rely on the return value

        node = this._engine.createNode(node);
        this.nodes.push(node);
        node.parent = this;
        node._connectToScene();
        this._engine.branchDirty(node);
        if (ok) {
            ok(node);
        }
        return node;

    } else {

        // Otherwise the root node's type needs to be loaded,
        // so we need to create it asynchronously. By this contract,
        // the Caller would not rely on synchronous creation of
        // non-core types.
        var self = this;
        this._engine.createNode(node,
            function (node) {
                self.nodes.push(node);
                node.parent = self;
                node._connectToScene();
                self._engine.branchDirty(node);
                if (ok) {
                    ok(node);
                }
            });
        return null;
    }
};

/** Inserts a subgraph into child nodes
 * @param {Node} node Child node
 * @param {int} i Index for new child node
 * @return {Node} The child node
 */
SceneJS.Node.prototype.insertNode = function (node, i) {

    if (!node) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.Node#insertNode - node argument is undefined");
    }

    if (!node._compile) { // JSON node definition
        node = this._engine.createNode(node); // Create node
    }

    if (!node._compile) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.Node#insertNode - node argument is not a SceneJS.Node");
    }

    if (node.parent != null) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.Node#insertNode - node argument is still attached to another parent");
    }

    if (i === undefined || i === null) {
        node.addNodes(this.disconnectNodes());
        this.addNode(node);

    } else if (i < 0) {

        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.Node#insertNode - node index out of range: -1");

    } else if (i >= this.nodes.length) {
        this.nodes.push(node);
    } else {
        this.nodes.splice(i, 0, node);
    }

    node.parent = this;
    node._connectToScene();
    return node;
};

/** Calls the given function on each node in the subgraph rooted by this node, including this node.
 * The callback takes each node as it's sole argument and traversal stops as soon as the function returns
 * true and returns the node.
 * @param {function(Node)} func The function
 */
SceneJS.Node.prototype.mapNodes = function (func) {
    if (func(this)) {
        return this;
    }
    var result;
    for (var i = 0; i < this.nodes.length; i++) {
        result = this.nodes[i].mapNodes(func);
        if (result) {
            return result;
        }
    }
    return null;
};

/**
 * Returns the parent node
 * @return {SceneJS.Node}
 */
SceneJS.Node.prototype.getParent = function (type) {
    return this.parent;
};

/**
 * Finds the first node of given type on path to root.
 * @param {String} type Parent type to find on path to root
 * @return {SceneJS.Node}
 */
SceneJS.Node.prototype.getParentOfType = function (type) {
    var parent = this.parent;
    while (parent && parent.type != type) {
        parent = parent.parent;
    }
    return parent;
};

/**
 * Iterates over parent nodes on the path from the selected node to the root, executing a function
 * for each.
 * If the function returns true at any node, then traversal stops and a selector is
 * returned for that node.
 * @param {Function(node, index)} fn Function to execute on each instance node
 * @return {Object} Selector for selected node, if any
 */
SceneJS.Node.prototype.eachParent = function (fn) {

    if (!fn) {
        throw "SceneJS.Node.eachParent param 'fn' is null or undefined";
    }

    var count = 0;
    var node = this;

    while (node.parent) {
        if (fn.call(node.parent, count++) === true) {
            return node.parent;
        }
        node = node.parent;
    }

    return null;
};

/** Returns true if a child node matching given ID or index exists on this node
 * @param {Number|String} node Child node index or ID
 */
SceneJS.Node.prototype.hasNode = function (node) {

    if (node === null || node === undefined) {
        throw "SceneJS.Node.hasNode param 'node' is null or undefined";
    }

    var type = typeof node;
    var nodeGot;

    if (type == "number") {
        nodeGot = this.getNodeAt(node);

    } else if (type == "string") {
        nodeGot = this.getNode(node);

    } else {
        throw "SceneJS.Node.hasNode param 'node' should be either an index number or an ID string";
    }

    return (nodeGot != undefined && nodeGot != null);
};

/** Selects a child node matching given ID or index
 * @param {Number|String} node Child node index or ID
 */
SceneJS.Node.prototype.node = function (node) {

    if (node === null || node === undefined) {
        throw "SceneJS.Node.node param 'node' is null or undefined";
    }

    var type = typeof node;
    var nodeGot;

    if (type == "number") {
        nodeGot = this.getNodeAt(node);

    } else if (type == "string") {
        nodeGot = this.getNode(node);

    } else {
        throw "SceneJS.Node.node param 'node' should be either an index number or an ID string";
    }

    if (!nodeGot) {
        throw "SceneJS.Node.node - node not found: '" + node + "'";
    }

    return nodeGot;
};

/**
 * Iterates over sub-nodes of the selected node, executing a function
 * for each. With the optional options object we can configure is depth-first or breadth-first order.
 * If neither, then only the child nodes are iterated.
 * If the function returns true at any node, then traversal stops and a selector is
 * returned for that node.
 * @param {Function(index, node)} fn Function to execute on each child node
 * @return {Object} Selector for selected node, if any
 */
SceneJS.Node.prototype.eachNode = function (fn, options) {

    if (!fn) {
        throw "SceneJS.Node.eachNode param 'fn' is null or undefined";
    }

    if (typeof fn != "function") {
        throw "SceneJS.Node.eachNode param 'fn' should be a function";
    }

    var stoppedNode;
    options = options || {};
    var count = 0;

    if (options.andSelf) {
        if (fn.call(this, count++) === true) {
            return this;
        }
    }

    if (!options.depthFirst && !options.breadthFirst) {
        stoppedNode = this._iterateEachNode(fn, this, count);

    } else if (options.depthFirst) {
        stoppedNode = this._iterateEachNodeDepthFirst(fn, this, count, false); // Not below root yet

    } else {
        // TODO: breadth-first
    }

    if (stoppedNode) {
        return stoppedNode;
    }

    return undefined; // IDE happy now
};

SceneJS.Node.prototype.numNodes = function () {
    return this.nodes.length;
};

SceneJS.Node.prototype._iterateEachNode = function (fn, node, count) {

    var len = node.nodes.length;
    var child;

    for (var i = 0; i < len; i++) {
        child = node.nodes[i];

        if (fn.call(child, count++) === true) {
            return child;
        }
    }

    return null;
};

SceneJS.Node.prototype._iterateEachNodeDepthFirst = function (fn, node, count, belowRoot) {

    if (belowRoot) {

        /* Visit this node - if we are below root, because entry point visits the root
         */
        if (fn.call(node, count++) === true) {
            return node;
        }
    }

    belowRoot = true;

    /* Iterate nodes
     */
    var len = node.nodes.length;
    var child;
    for (var i = 0; i < len; i++) {
        child = this._iterateEachNodeDepthFirst(fn, node.nodes[i], count, belowRoot);
        if (child) {
            return child;
        }
    }

    return null;
};

/** Returns either all child or all sub-nodes of the given type, depending on whether search is recursive or not.
 */
SceneJS.Node.prototype.findNodesByType = function (type, recursive) {
    return this._findNodesByType(type, [], recursive);
};

SceneJS.Node.prototype._findNodesByType = function (type, list, recursive) {
    var i;
    for (i = 0; i < this.nodes.length; i++) {
        var node = this.nodes[i];
        if (node.type == type) {
            list.push(node);
        }
    }
    if (recursive) {
        for (i = 0; i < this.nodes.length; i++) {
            this.nodes[i]._findNodesByType(type, list, recursive);
        }
    }
    return list;
};

/** Finds the first node on path up to root whose type equals that given
 */
SceneJS.Node.prototype.findParentByType = function (type) {
    var parent = this.parent;
    while (parent && parent.type != type) {
        parent = parent.parent;
    }
    return parent;
};

/**
 * Returns an object containing the attributes that were given when creating the node. Obviously, the map will have
 * the current values, plus any attributes that were later added through set/add methods on the node
 *
 */
SceneJS.Node.prototype.getJSON = function () {
    return this;
};


SceneJS.Node.prototype._compile = function (ctx) {
    if (this.preCompile) {
        this.preCompile();
    }
    this._compileNodes(ctx);
    if (this.postCompile) {
        this.postCompile();
    }
};

SceneJS.Node.prototype._compileNodes = function (ctx) {

    var renderSubs = !!this.onRendered;

    if (renderSubs) {
        SceneJS_nodeEventsModule.preVisitNode(this);
    }

    var child;

    for (var i = 0, len = this.nodes.length; i < len; i++) {

        child = this.nodes[i];

        child.branchDirty = child.branchDirty || this.branchDirty; // Compile subnodes if scene branch dirty

        if (child.dirty || child.branchDirty || this._engine.sceneDirty) {  // Compile nodes that are flagged dirty
            if (child.disabled) {
                child._compileNodes(ctx);
            } else {
                child._compile(ctx);
            }
            child.dirty = false;
            child.branchDirty = false;
        }
    }

    if (renderSubs) {
        SceneJS_nodeEventsModule.postVisitNode(this);
    }
};



/**
 * Destroys this node. It is marked for destruction; when the next scene traversal begins (or the current one ends)
 * it will be destroyed and removed from it's parent.
 */
SceneJS.Node.prototype.destroy = function () {

    if (!this.destroyed) {

        if (this.parent) {

            // Remove from parent's child node list

            var parentNodes = this.parent.nodes;
            var len = parentNodes.length;
            for (var i = 0; i < len; i++) {
                if (parentNodes[i].id === this.id) {
                    parentNodes.splice(i, 1);
                    break;
                }
            }
        }

        // Remove publication
        this._engine.scene.unpublish("nodes/" + this.id);

        /* Recusrsively destroy child nodes without
         * bothering to remove them from their parents
         */
        this._destroyTree();

        /* Need object list recompilation on display
         */
        this._engine.display.objectListDirty = true;
    }

    return this;
};

SceneJS.Node.prototype._destroyTree = function () {

    this.destroyed = true;

    this._engine.destroyNode(this); // Release node object

    var childNode;
    for (var i = 0, len = this.nodes.length; i < len; i++) {
        childNode = this.nodes[i];
        this._engine.scene.unpublish("nodes/" + childNode.id);
        childNode._destroyTree();
    }
};

/**
 * Performs the actual destruction of this node, calling the node's optional template destroy method
 */
SceneJS.Node.prototype._doDestroy = function () {

    if (this._destroy) {  // Call destruction handler for each node subclass
        this._destroy();
    }

    return this;
};
;SceneJS_PubSubProxy = function (scene, proxy) {
    this.scene = scene;
    this.proxy = proxy;

};



;/**
 * @class Manages creation, recycle and destruction of {@link SceneJS.Node} instances
 * @private
 */
var SceneJS_NodeFactory = function () {
    this.nodes = new SceneJS_Map({});
};

SceneJS_NodeFactory.nodeTypes = {};

SceneJS_NodeFactory.createNodeType = function (typeName) {
    if (SceneJS_NodeFactory.nodeTypes[typeName]) {
        throw "Node type already defined: " + typeName;
    }
    var nodeType = function () { // Create the class
        SceneJS.Node.apply(this, arguments);
        this.type = typeName;
    };
    nodeType.prototype = new SceneJS.Node();            // Inherit from base class
    nodeType.prototype.constructor = nodeType;
    SceneJS_NodeFactory.nodeTypes[typeName] = nodeType;
    return nodeType;
};

SceneJS_NodeFactory.prototype.getNode = function (engine, json, core) {
    json.type = json.type || "node";
    var nodeType;
    if (json.type === "node") {
        nodeType = SceneJS.Node;
    } else {
        nodeType = SceneJS_NodeFactory.nodeTypes[json.type];
        if (!nodeType) {
            console.error("Unknown node type: " + json.type + " - can't create - making a SceneJS.Node by default");
            nodeType = SceneJS.Node;
        }
    }
    var node = new nodeType();
    var id = json.id || json.nodeId;
    if (id) {
        this.nodes.addItem(id, node);
    } else {
        id = this.nodes.addItem(node);
    }
    node._construct(engine, core, json, id); // Instantiate node
    return node;
};

SceneJS_NodeFactory.prototype.putNode = function (node) {
    this.nodes.removeItem(node.id);
};
;(function () {

    var defaultMatrix = mat4.perspective(
        mat4.create(),
        45, // fov
        1, // aspect
        0.1, // near
        10000); // far

    var defaultMat = new Float32Array(defaultMatrix);

    // The default state core singleton for {@link SceneJS.Camera} nodes
    var defaultCore = {
        type: "camera",
        stateId: SceneJS._baseStateId++,
        matrix: defaultMatrix,
        mat: defaultMat,
        optics: {
            type: "perspective",
            fov: 45.0,
            fovAxis: "y", // x/y/min/max
            aspect: 1.0,
            near: 0.1,
            far: 10000.0
        },
        checkAspect: function (core, aspect) {
            if (core.optics.aspect != aspect) {
                core.optics.aspect = aspect;
                rebuildCore(this);
            }
        }
    };

    var coreStack = [];
    var stackLen = 0;

    // Set default core on the display at the start of each new scene compilation
    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.projTransform = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines the projection transform to apply to the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Camera = SceneJS_NodeFactory.createNodeType("camera"); // Camera node publishes events

    SceneJS.Camera.prototype._init = function (params) {
        if (this._core.useCount == 1) {

            params.optics = params.optics || {};
            var canvas = this.getScene().getCanvas();
            params.optics.aspect = canvas.width / canvas.height;
            this.setOptics(params.optics); // Can be undefined

            if (params.pan) {
                this.setPan(params.pan);
            }

            var self = this;

            this._canvasSizeSub = this.getScene().on("canvasSize",
                function (c) {
                    self._core.optics.aspect = c.aspect;
                    rebuildCore(self._core);
                    self._engine.display.imageDirty = true;
                });
        }
    };

    /**
     * Returns the default camera projection matrix
     * @return {Float32Array}
     */
    SceneJS.Camera.getDefaultMatrix = function () {
        return defaultMat;
    };

    SceneJS.Camera.prototype.setOptics = function (optics) {
        var core = this._core;
        if (!optics) {
            core.optics = {
                type: "perspective",
                fov: 60.0,
                fovAxis: "y",
                aspect: 1.0,
                near: 0.1,
                far: 10000.0
            };
        } else {
            var type = optics.type;
            if (!type) {
                if (core.optics) {
                    type = core.optics.type;
                }
            }
            type = type || "perspective";
            if (type == "ortho") {
                core.optics = SceneJS._applyIf(SceneJS_math_ORTHO_OBJ, {
                    type: type,
                    left: optics.left,
                    bottom: optics.bottom,
                    near: optics.near,
                    right: optics.right,
                    top: optics.top,
                    far: optics.far
                });
            } else if (type == "frustum") {
                core.optics = {
                    type: type,
                    left: optics.left || -1.0,
                    bottom: optics.bottom || -1.0,
                    near: optics.near || 0.1,
                    right: optics.right || 1.00,
                    top: optics.top || 1.0,
                    far: optics.far || 10000.0
                };
            } else if (type == "perspective") {
                if (optics.fovy != undefined) {
                    optics.fov = optics.fovy;
                    optics.fovAxis = "y";
                }

                core.optics = {
                    type: type,
                    fov: optics.fov || 60.0,
                    fovAxis: optics.fovAxis || "y",
                    aspect: optics.aspect == undefined ? 1.0 : optics.aspect,
                    near: optics.near || 0.1,
                    far: optics.far || 10000.0
                };
            } else if (!optics.type) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "SceneJS.Camera configuration invalid: optics type not specified - " +
                    "supported types are 'perspective', 'frustum' and 'ortho'");
            } else {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "SceneJS.Camera configuration invalid: optics type not supported - " +
                    "supported types are 'perspective', 'frustum' and 'ortho'");
            }
        }
        this._core.optics.pan = optics.pan;
        rebuildCore(this._core);
        if (this.onMatrix) {
            this.onMatrix(this._core.matrix);
        }
        this._engine.display.imageDirty = true;
    };

    SceneJS.Camera.prototype.setPan = function (pan) {
        this._core.pan = pan;
        rebuildCore(this._core);
        if (this.onMatrix) {
            this.onMatrix(this._core.matrix);
        }
        this._engine.display.imageDirty = true;
    };

    function rebuildCore(core) {
        var optics = core.optics;

        core.matrix = mat4.create();

        if (optics.type == "ortho") {
            mat4.ortho(
                core.matrix,
                optics.left,
                optics.right,
                optics.bottom,
                optics.top,
                optics.near,
                optics.far);

        } else if (optics.type == "frustum") {
            mat4.frustum(
                core.matrix,
                optics.left,
                optics.right,
                optics.bottom,
                optics.top,
                optics.near,
                optics.far);

        } else if (optics.type == "perspective") {
            var fov = optics.fov;
            var fovAxis = optics.fovAxis;

            if ( fovAxis == "x" || 
                (fovAxis == "min" && optics.aspect < 1) ||  
                (fovAxis == "max" && optics.aspect > 1)) {
                fov = fov / optics.aspect;
            }

            fov = Math.min(fov, 120);

            mat4.perspective(
                core.matrix,
                fov * Math.PI / 180.0,
                optics.aspect,
                optics.near,
                optics.far);
        }

        if (core.pan) {
            // Post-multiply a screen-space pan
            var pan = core.pan;
            var panMatrix = mat4.fromTranslation(mat4.create(), [pan.x || 0, pan.y || 0, pan.z || 0]);
            mat4.multiply(core.matrix, panMatrix, core.matrix);
        }

        if (!core.mat) {
            core.mat = new Float32Array(core.matrix);
        } else {
            core.mat.set(core.matrix);
        }
    }

    SceneJS.Camera.prototype.getOptics = function () {
        var optics = {};
        for (var key in this._core.optics) {
            if (this._core.optics.hasOwnProperty(key)) {
                optics[key] = this._core.optics[key];
            }
        }
        return optics;
    };

    SceneJS.Camera.prototype.getMatrix = function () {
        return SceneJS._sliceArray(this._core.matrix, 0);
    };

    SceneJS.Camera.prototype.setMatrix = function (matrix) {

        var core = this._core;

        core.matrix.set(matrix);

        // Post-multiply a screen-space pan
        var pan = core.pan;
        var panMatrix = mat4.fromTranslation(mat4.create(), [pan.x || 0, pan.y || 0, pan.z || 0]);
        mat4.multiply(core.matrix, panMatrix, core.matrix);

        core.mat.set(core.matrix);
        this.publish("matrix", core.matrix);
        this._engine.display.imageDirty = true;
    };

    /**
     * Compiles this camera node, setting this node's state core on the display, compiling sub-nodes,
     * then restoring the previous camera state core back onto the display on exit.
     */
    SceneJS.Camera.prototype._compile = function (ctx) {
        this._engine.display.projTransform = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.projTransform = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Camera.prototype._destroy = function () {
        this.getScene().off(this._canvasSizeSub);
    };
})();
;(function() {

    /**
     * The default state core singleton for {@link SceneJS.Clips} nodes
     */
    var defaultCore = {
        type: "clips",
        stateId: SceneJS._baseStateId++,
        empty: true,        
        hash: "",
        clips : []
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
            SceneJS_events.SCENE_COMPILING,
            function(params) {
                params.engine.display.clips = defaultCore;
                stackLen = 0;
            });

    /**
     * @class Scene graph node which defines one or more arbitrarily-aligned clip planes to clip the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Clips = SceneJS_NodeFactory.createNodeType("clips");

    SceneJS.Clips.prototype._init = function(params) {

        if (this._core.useCount == 1) { // This node defines the resource

            var clips = params.clips;

            if (!clips) {
                throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "clips node attribute missing : 'clips'");
            }

            this._core.clips = this._core.clips || [];

            for (var i = 0, len = clips.length; i < len; i++) {
                this._setClip(i, clips[i]);
            }
        }
    };

    SceneJS.Clips.prototype.setClips = function(clips) {
        var indexNum;
        for (var index in clips) {
            if (clips.hasOwnProperty(index)) {
                if (index != undefined || index != null) {
                    indexNum = parseInt(index);
                    if (indexNum < 0 || indexNum >= this._core.clips.length) {
                        throw SceneJS_error.fatalError(
                                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                                "Invalid argument to set 'clips': index out of range (" + this._core.clips.length + " clips defined)");
                    }
                    this._setClip(indexNum, clips[index] || {});
                }
            }
        }
        this._engine.display.imageDirty = true;
    };

    SceneJS.Clips.prototype._setClip = function(index, cfg) {

        var clip = this._core.clips[index] || (this._core.clips[index] = {});

        clip.normalAndDist = [cfg.x || 0,  cfg.y || 0, cfg.z || 0, cfg.dist || 0];

        var mode = cfg.mode || clip.mode || "disabled";

        if (mode != "inside" && mode != "outside" && mode != "disabled") {
            throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "clips node invalid value for property 'mode': should be 'inside' or 'outside' or 'disabled'");
        }
        clip.mode = mode;

        this._core.hash = null;
    };

    SceneJS.Clips.prototype._compile = function(ctx) {

        if (!this._core.hash) {
            this._core.hash = this._core.clips.length;
        }

        this._engine.display.clips = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.clips = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };


})();;(function () {

    var FLAGS = SceneJS.PROPERTY_FLAGS;

    /**
     * The default state core singleton for {@link SceneJS.Properties} nodes
     */
    var defaultCore = new SceneJS_PropertiesCore();
    defaultCore.stateId = SceneJS._baseStateId++;

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.properties = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which sets rendering mode properties for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Properties = SceneJS_NodeFactory.createNodeType("properties");

    SceneJS.Properties.prototype._init = function (params) {

        if (this._core.useCount == 1) {         // This node is first to reference the state core, so sets it up
            if (params.properties) {                  // 'properties' property is actually optional in the node definition
                this.setProperties(params.properties);
            }
        }
    };

    SceneJS.Properties.prototype.setProperties = function (properties) {

        var core = this._core;

        if (properties.picking != undefined) {
            core.setFlag(FLAGS.PICKING, properties.picking);
            this._engine.display.imageDirty = true;
        }

        if (properties.solidColor != undefined) {
            var defaultClippingParams = defaultCore.clippingParams;
            var color = properties.solidColor;
            core.clippingParams[0] = color.r != undefined ? color.r : defaultClippingParams[0];
            core.clippingParams[1] = color.g != undefined ? color.g : defaultClippingParams[1];
            core.clippingParams[2] = color.b != undefined ? color.b : defaultClippingParams[2];
            this._engine.display.imageDirty = true;
        }

        if (properties.clipping != undefined) {
            core.clippingParams[3] = properties.clipping;
            this._engine.display.imageDirty = true;
        }

        if (properties.enabled != undefined) {
            core.setFlag(FLAGS.ENABLED, properties.enabled);
            this._engine.display.imageDirty = true;
        }

        if (properties.backfaces != undefined) {
            core.setFlag(FLAGS.BACKFACES, properties.backfaces);
            this._engine.display.imageDirty = true;
        }

        if (properties.frontface != undefined) {
            core.setFlag(FLAGS.CCW, properties.frontface === "ccw");
            this._engine.display.imageDirty = true;
        }

        if (properties.reflective != undefined) {
            core.setFlag(FLAGS.REFLECTIVE, properties.reflective);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (properties.solid != undefined) {
            core.setFlag(FLAGS.SOLID, properties.solid);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (properties.skybox != undefined) {
            core.setFlag(FLAGS.SKYBOX, properties.skybox);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (properties.billboard != undefined) {
            core.setFlag(FLAGS.BILLBOARD, properties.billboard);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }

        if (properties.tintColor != undefined) {
            var color = properties.tintColor;
            core.tintColor[0] = color.r != undefined ? color.r : 1,
            core.tintColor[1] = color.g != undefined ? color.g : 1,
            core.tintColor[2] = color.b != undefined ? color.b : 1
            this._engine.display.imageDirty = true;
        }

        if (properties.saturation != undefined) {
            core.colorParams[0] = properties.saturation;
            this._engine.display.imageDirty = true;
        }

        if (properties.contrast != undefined) {
            core.colorParams[1] = properties.contrast + 1; // Map from -1,1 to 0,2
            this._engine.display.imageDirty = true;
        }

        if (properties.brightness != undefined) {
            core.colorParams[2] = properties.brightness;
            this._engine.display.imageDirty = true;
        }

        if (properties.xrayEnabled != undefined) {
            var wasTransparent = core.transparent;
            core.setFlag(FLAGS.XRAY_ENABLED, properties.xrayEnabled);
            core.resetTransparency();
            this._engine.branchDirty(this);
            if (core.transparent !== wasTransparent) {
                this._engine.display.stateOrderDirty = true;
                this._engine.display.imageDirty = true;
            }
        }

        if (properties.name != undefined) {
            core.name = properties.name;
        }

        if (properties.layer != undefined) {
            core.layer = properties.layer;
            this._engine.display.stateOrderDirty = true;
        }

        if (properties.xray != undefined) {
            var wasTransparent = core.transparent;
            core.xrayParams[0] = properties.xray;
            core.resetTransparency();
            if (core.transparent !== wasTransparent) {
                this._engine.display.stateOrderDirty = true;
                this._engine.display.imageDirty = true;
            }
        }

        if (properties.glassFactor != undefined) {
            core.xrayParams[1] = properties.glassFactor;
            if (core.getFlag(FLAGS.XRAY_ENABLED)) {
                this._engine.display.imageDirty = true;
            }
        }

        if (properties.murkiness != undefined) {
            core.xrayParams[2] = properties.murkiness;
            if (core.getFlag(FLAGS.XRAY_ENABLED)) {
                this._engine.display.imageDirty = true;
            }
        }

        if (properties.opacity != undefined) {
            var wasTransparent = core.transparent;
            core.xrayParams[3] = properties.opacity;
            core.resetTransparency();
            if (core.transparent !== wasTransparent) {
                this._engine.display.stateOrderDirty = true;
            }
            this._engine.display.imageDirty = true;    
        }

        if (properties.depthMask != undefined) {
            core.setFlag(FLAGS.DEPTH_MASK, properties.depthMask);
            this._engine.display.imageDirty = true;
        }

        if (properties.roundPoints != undefined) {
            core.setFlag(FLAGS.ROUND_POINTS, properties.roundPoints);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        
        core.hash = getHash(core);

        return this;
    };

    SceneJS.Properties.prototype.getProperties = function () {
        var core = this._core;
        return {
            picking: core.getFlag(FLAGS.PICKING),
            clipping: !!core.clippingParams[3],
            enabled: core.getFlag(FLAGS.ENABLED),
            backfaces: core.getFlag(FLAGS.BACKFACES),
            frontface: core.getFlag(FLAGS.CCW) ? "ccw" : "cw",
            reflective: core.getFlag(FLAGS.REFLECTIVE),
            solid: core.getFlag(FLAGS.SOLID),
            solidColor: core.clippingParams.slice(0, 3),
            xrayEnabled: core.getFlag(FLAGS.XRAY_ENABLED),
            skybox: core.getFlag(FLAGS.SKYBOX),
            billboard: core.getFlag(FLAGS.BILLBOARD),
            depthMask: core.getFlag(FLAGS.DEPTH_MASK),
            xray: !!core.xrayParams[0],
            glassFactor: core.xrayParams[1],
            murkiness: core.xrayParams[2],
            opacity: core.xrayParams[3],
            roundPoints: core.roundPoints,
            saturation: core.colorParams[0],
            contrast: core.colorParams[1] - 1, // Map from 0,2 to -1, 1
            brightness: core.colorParams[2]
        };
    };

    SceneJS.Properties.prototype.setPicking = function (picking) {
        picking = !!picking;
        if (this._core.getFlag(FLAGS.PICKING) !== picking) {
            this._core.setFlag(FLAGS.PICKING, picking);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getPicking = function () {
        return this._core.getFlag(FLAGS.PICKING);
    };

    SceneJS.Properties.prototype.setClipping = function (clipping) {
        this.setProperties({clipping: clipping})
        return this;
    };

    SceneJS.Properties.prototype.getClipping = function () {
        return !!this.clippingParams[3];
    };

    SceneJS.Properties.prototype.setEnabled = function (enabled) {
        enabled = !!enabled;
        if (this._core.getFlag(FLAGS.ENABLED) !== enabled) {
            this._core.setFlag(FLAGS.ENABLED, enabled);
            this._engine.display.objectListDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getEnabled = function () {
        return this._core.getFlag(FLAGS.ENABLED);
    };

    SceneJS.Properties.prototype.setBackfaces = function (backfaces) {
        backfaces = !!backfaces;
        if (this._core.getFlag(FLAGS.BACKFACES) !== backfaces) {
            this._core.setFlag(FLAGS.BACKFACES, backfaces);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getBackfaces = function () {
        return this._core.getFlag(FLAGS.BACKFACES);
    };

    SceneJS.Properties.prototype.setFrontface = function (frontface) {
        var ccw = frontface === "ccw";
        if (this._core.getFlag(FLAGS.CCW) !== ccw) {
            this._core.setFlag(FLAGS.CCW, ccw);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getFrontface = function () {
        return this._core.getFlag(FLAGS.CCW) ? "ccw" : "cw";
    };

    SceneJS.Properties.prototype.setReflective = function (reflective) {
        reflective = !!reflective;
        if (this._core.getFlag(FLAGS.REFLECTIVE) != reflective) {
            this._core.setFlag(FLAGS.REFLECTIVE, reflective);
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getReflective = function () {
        return this._core.getFlag(FLAGS.REFLECTIVE);
    };

    SceneJS.Properties.prototype.setSolid = function (solid) {
        solid = !!solid;
        if (this._core.getFlag(FLAGS.SOLID) != solid) {
            this._core.setFlag(FLAGS.SOLID, solid);
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getSolid = function () {
        return this._core.getFlag(FLAGS.SOLID);
    };

    SceneJS.Properties.prototype.setSolidColor = function (color) {
        this.setProperties({solidColor: color})
        return this;
    };

    SceneJS.Properties.prototype.getSolidColor = function () {
        return {
            r: this._core.clippingParams[0],
            g: this._core.clippingParams[1],
            b: this._core.clippingParams[2]
        };
    };

    SceneJS.Properties.prototype.setSkybox = function (skybox) {
        skybox = !!skybox;
        if (this._core.getFlag(FLAGS.SKYBOX) != skybox) {
            this._core.setFlag(FLAGS.SKYBOX, skybox);
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getSkybox = function () {
        return this._core.getFlag(FLAGS.SKYBOX);
    };

    SceneJS.Properties.prototype.setName = function (name) {
        this._core.name = name;
    };

    SceneJS.Properties.prototype.getName = function () {
        return this._core.name;
    };

    SceneJS.Properties.prototype.setLayer = function (layer) {
        if (this._core.layer != layer) {
            this._core.layer = layer;
            this._engine.display.stateOrderDirty = true;
        }
    };

    SceneJS.Properties.prototype.getLayer = function () {
        return this._core.layer;
    };

    SceneJS.Properties.prototype.setDepthMask = function (dm) {
        dm = !!dm;
        if (this._core.getFlag(FLAGS.DEPTH_MASK) !== dm) {
            this._core.setFlag(FLAGS.DEPTH_MASK, dm);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getDepthMask = function () {
        return this._core.getFlag(FLAGS.DEPTH_MASK);
    };

    SceneJS.Properties.prototype.setRoundPoints = function (roundPoints) {
        roundPoints = !!roundPoints;
        if (this._core.getFlag(FLAGS.ROUND_POINTS) != roundPoints) {
            this._core.setFlag(FLAGS.ROUND_POINTS, roundPoints);
            this._core.hash = getHash(this._core);
            this._engine.branchDirty(this);
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    SceneJS.Properties.prototype.getRoundPoints = function () {
        return this._core.getFlag(FLAGS.ROUND_POINTS);
    };

    SceneJS.Properties.prototype._compile = function (ctx) {
        this._engine.display.properties = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.properties = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    function getHash(core) {
        return (core.getFlag(FLAGS.REFLECTIVE) ? "refl" : "") + ";" +
                (core.getFlag(FLAGS.SKYBOX) ? "s" : "") + ";" +
                (core.getFlag(FLAGS.SOLID) ? "sky" : "") + ";" +
                (core.getFlag(FLAGS.XRAY_ENABLED) ? "xray" : "") + ";" +
                (core.getFlag(FLAGS.ROUND_POINTS) ? "rp" : "") + ";" + 
                (core.getFlag(FLAGS.BILLBOARD) ? "b" : "") + ";";
    }

})();
;new (function () {

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function () {
            stackLen = 0;
        });

    /**
     * @class Scene graph node that defines geometry.
     * @extends SceneJS.Node
     * When this node is at a leaf, it defines a scene object which inherits the state set up by all the nodes above it
     * on the path up to the root. These nodes can be nested, so that child geometries inherit arrays
     * defined by parent geometries.
     */
    SceneJS.Geometry = SceneJS_NodeFactory.createNodeType("geometry");

    SceneJS.Geometry.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node defines the core

            this._initNodeCore(params, {
                origin: params.origin,
                scale: params.scale,
                autoNormals: params.normals == "auto"
            });

            this._buildNodeCore(this._engine.canvas.gl, this._core);

            this._core.webglRestored = getContextRestoredCallback(this);

            this._engine.stats.geometry.meshes++;
        }
    };

    /**
     * Convert JSON arrays into typed arrays,
     * apply optional baked Model-space transforms to positions
     */
    SceneJS.Geometry.prototype._initNodeCore = function (data, options) {

        var self = this;

        options = options || {};

        var primitive = data.primitive || "triangles";
        var core = this._core;
        var IndexArrayType = SceneJS.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"] ? Uint32Array : Uint16Array;

        core._engine = this._engine;
        core.primitive = this._getPrimitiveType(primitive);
        core.primitiveName = primitive;
        core.pointSize = data.pointSize || 1;
        core.compressedPositions = false;
        core.compressedNormals = false;
        core.compressedUVs = false;

        // Generate normals
        if (data.normals) {
            if (primitive == "triangles") {
                if (data.normals === "auto" || data.normals === true) {
                    if (data.positions && data.indices) {
                        this._buildNormals(data); // Auto normal generation - build normals array
                    }
                }
            }
        }

        // Create typed arrays, apply any baked transforms
        core.arrays = {};

        if (data.positions) {
            if (data.positionDecodeMat) {
                core.arrays.positions = data.positions;


                core.positionDecodeMat = data.positionDecodeMat;
                core.compressedPositions = true;
            } else {
                if (data.positions.constructor != Float32Array) {
                    data.positions = new Float32Array(data.positions);
                }

                if (options.scale || options.origin) {
                    this._applyOptions(data.positions, options)
                }

                core.arrays.positions = data.positions;
            }
            this._engine.stats.geometry.vertices += data.positions.length / 3;
            this._engine.stats.memory.positions += data.positions.length * data.positions.constructor.BYTES_PER_ELEMENT;
        }

        if (data.normals) {
            if (data.normals.constructor == Int8Array) {
                core.arrays.normals = data.normals;

                core.compressedNormals = true;
            } else {
                if (data.normals.constructor != Float32Array) {
                    data.normals = new Float32Array(data.normals);
                }

                core.arrays.normals = data.normals;
            }

            this._engine.stats.memory.normals += data.normals.length * data.normals.constructor.BYTES_PER_ELEMENT;
        }

        var uvs, uv;
        if (data.uvDecodeMats) {
            uvs = data.uvs;
            uv;
            for (var i = 0, len = uvs.length; i < len; i++) {
                uv = uvs[i];
                if (uv.constructor != Uint16Array) {
                    uvs[i] = new Uint16Array(uvs[i]);
                }
                this._engine.stats.memory.uvs += uv.length * uv.constructor.BYTES_PER_ELEMENT;
            }
            core.arrays.uvs = uvs;
            core.uvDecodeMats = data.uvDecodeMats;
            core.compressedUVs = true;
        } else if (data.uvs) {
            uvs = data.uvs;
            uv;
            for (var i = 0, len = uvs.length; i < len; i++) {
                uv = uvs[i];
                if (uv.constructor != Float32Array) {
                    uvs[i] = new Float32Array(uvs[i]);
                }
                this._engine.stats.memory.uvs += uv.length * uv.constructor.BYTES_PER_ELEMENT;
            }
            core.arrays.uvs = uvs;
        }

        // ---------------- Backward-compatibility -------------------

        if (data.uv) {
            if (data.uv.constructor != Float32Array) {
                data.uv = new Float32Array(data.uv);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[0] = data.uv;
            this._engine.stats.memory.uvs += data.uv.length * data.uv.constructor.BYTES_PER_ELEMENT;
        }

        if (data.uv1) {
            if (data.uv1.constructor != Float32Array) {
                data.uv1 = new Float32Array(data.uv1);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[1] = data.uv1;
            this._engine.stats.memory.uvs += data.uv1.length * data.uv1.constructor.BYTES_PER_ELEMENT;
        }

        if (data.uv2) {
            if (data.uv2.constructor != Float32Array) {
                data.uv2 = new Float32Array(data.uv2);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[2] = data.uv2;
            this._engine.stats.memory.uvs += data.uv2.length * data.uv2.constructor.BYTES_PER_ELEMENT;
        }

        if (data.uv3) {
            if (data.uv3.constructor != Float32Array) {
                data.uv3 = new Float32Array(data.uv3);
            }
            if (!core.arrays.uvs) {
                core.arrays.uvs = [];
            }
            core.arrays.uvs[3] = data.uv3;
            this._engine.stats.memory.uvs += data.uv3.length * data.uv3.constructor.BYTES_PER_ELEMENT;
        }

        // ----------------------------------------------------------

        if (core.arrays.normals && core.arrays.uvs) {
            core.arrays.tangents = [];
        }

        if (data.colors) {
            if (data.colors.constructor != Uint8Array) {
                data.colors = new Uint8Array(data.colors);
            }

            core.arrays.colors = data.colors;
            this._engine.stats.memory.colors += data.colors.length * data.colors.constructor.BYTES_PER_ELEMENT;
        }

        if (data.indices) {
            if (data.indices.constructor != Uint8Array &&
                data.indices.constructor != Uint16Array &&
                data.indices.constructor != Uint32Array)
            {
                data.indices = new IndexArrayType(data.indices);
            }

            core.arrays.indices = data.indices;
            this._engine.stats.geometry.triangles += data.indices.length / 3;
            this._engine.stats.memory.indices += data.indices.length * data.indices.constructor.BYTES_PER_ELEMENT;
        }
    };


    /**
     * Returns WebGL constant for primitive name
     */
    SceneJS.Geometry.prototype._getPrimitiveType = function (primitive) {

        var gl = this._engine.canvas.gl;

        switch (primitive) {

            case "points":
                return gl.POINTS;

            case "lines":
                return gl.LINES;

            case "line-loop":
                return gl.LINE_LOOP;

            case "line-strip":
                return gl.LINE_STRIP;

            case "triangles":
                return gl.TRIANGLES;

            case "triangle-strip":
                return gl.TRIANGLE_STRIP;

            case "triangle-fan":
                return gl.TRIANGLE_FAN;

            default:
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "geometry primitive unsupported: '" +
                    primitive +
                    "' - supported types are: 'points', 'lines', 'line-loop', " +
                    "'line-strip', 'triangles', 'triangle-strip' and 'triangle-fan'");
        }
    };

    /**
     * Apply baked Model-space transformations to give position array
     */
    SceneJS.Geometry.prototype._applyOptions = function (positions, options) {

        if (options.scale) {

            var scaleX = options.scale.x != undefined ? options.scale.x : 1.0;
            var scaleY = options.scale.y != undefined ? options.scale.y : 1.0;
            var scaleZ = options.scale.z != undefined ? options.scale.z : 1.0;

            for (var i = 0, len = positions.length; i < len; i += 3) {
                positions[i] *= scaleX;
                positions[i + 1] *= scaleY;
                positions[i + 2] *= scaleZ;
            }
        }

        if (options.origin) {

            var originX = options.origin.x != undefined ? options.origin.x : 0.0;
            var originY = options.origin.y != undefined ? options.origin.y : 0.0;
            var originZ = options.origin.z != undefined ? options.origin.z : 0.0;

            for (var i = 0, len = positions.length; i < len; i += 3) {
                positions[i] -= originX;
                positions[i + 1] -= originY;
                positions[i + 2] -= originZ;
            }
        }

        return positions;
    };

    function getContextRestoredCallback(node) {
        return function () {

            // Ensure that we recreate these in subsequent calls to
            // core.getTangents and core.getPickPositions
            node._core.tangentBufs = null;
            node._core.pickPositionsBuf = null;

            if (node._core.arrays.tangents) {
                node._core.arrays.tangents = [];
            }

            node._buildNodeCore(node._engine.canvas.gl, node._core);
        }
    }

    /**
     * Destroy vertex buffers associated with given core
     */
    var destroyBuffers = function (core) {
        if (core.vertexBuf) {
            core.vertexBuf.destroy();
            core.vertexBuf = null;
        }

        if (core.normalBuf) {
            core.normalBuf.destroy();
            core.normalBuf = null;
        }

        if (core.uvBufs) {
            var uvBufs = core.uvBufs;
            var uvBuf;
            for (var i = 0, len = uvBufs.length; i < len; i++) {
                uvBuf = uvBufs[i];
                if (uvBuf) {
                    uvBuf.destroy();
                }
            }
            core.uvBufs = null;
        }

        if (core.colorBuf) {
            core.colorBuf.destroy();
            core.colorBuf = null;
        }

        if (core.tangentBufs) {
            var tangentBufs = core.tangentBufs;
            var tangentBuf;
            for (var j = 0, lenj = tangentBufs.length; j < lenj; j++) {
                tangentBuf = tangentBufs[j];
                if (tangentBuf) {
                    tangentBuf.destroy();
                }
            }
            core.tangentBufs = null;
        }

        if (core.indexBuf) {
            core.indexBuf.destroy();
            core.indexBuf = null;
        }

        if (core.interleavedBuf) {
            core.interleavedBuf.destroy();
            core.interleavedBuf = null;
        }
    };

    /**
     * Allocates WebGL buffers for geometry arrays
     *
     * In addition to initially allocating those, this is called to reallocate them after
     * WebGL context is regained after being lost.
     */
    SceneJS.Geometry.prototype._buildNodeCore = function (gl, core) {

        try { // TODO: Modify usage flags in accordance with how often geometry is evicted
            buildCore(gl, core);
        } catch (e) { // Allocation failure - delete whatever buffers got allocated
            destroyBuffers(core);
            throw SceneJS_error.fatalError(
                SceneJS.errors.ERROR,
                "Failed to allocate geometry: " + e);
        }
    };

    SceneJS.Geometry.prototype._updateArray = function (array, items, offset) {

        var arrayLen = array.length;
        var itemsLen = items.length;

        if (itemsLen + offset > arrayLen) {
            itemsLen -= (itemsLen + offset) - arrayLen;
        }

        for (var i = offset, j = 0; j < itemsLen; i++, j++) {
            array[i] = items[j];
        }

    };

    /** Builds normal vectors from positions and indices
     * @private
     */
    SceneJS.Geometry.prototype._buildNormals = function (data) {

        var positions = data.positions;
        var indices = data.indices;
        var nvecs = new Array(positions.length / 3);
        var j0;
        var j1;
        var j2;
        var v1;
        var v2;
        var v3;

        for (var i = 0, len = indices.length - 3; i < len; i += 3) {
            j0 = indices[i + 0];
            j1 = indices[i + 1];
            j2 = indices[i + 2];

            v1 = [positions[j0 * 3 + 0], positions[j0 * 3 + 1], positions[j0 * 3 + 2]];
            v2 = [positions[j1 * 3 + 0], positions[j1 * 3 + 1], positions[j1 * 3 + 2]];
            v3 = [positions[j2 * 3 + 0], positions[j2 * 3 + 1], positions[j2 * 3 + 2]];

            v2 = vec4.subtract(vec4.create(), v2, v1);
            v3 = vec4.subtract(vec4.create(), v3, v1);

            var n = vec4.normalize(vec4.create(), SceneJS_math_cross3Vec4(v2, v3, [0, 0, 0, 0]));

            if (!nvecs[j0]) nvecs[j0] = [];
            if (!nvecs[j1]) nvecs[j1] = [];
            if (!nvecs[j2]) nvecs[j2] = [];

            nvecs[j0].push(n);
            nvecs[j1].push(n);
            nvecs[j2].push(n);
        }

        var normals = new Float32Array(positions.length);

        // now go through and average out everything
        for (var i = 0, len = nvecs.length; i < len; i++) {
            var nvec = nvecs[i];
            if (!nvec) {
                continue;
            }
            var count = nvec.length;
            var x = 0;
            var y = 0;
            var z = 0;
            for (var j = 0; j < count; j++) {
                x += nvec[j][0];
                y += nvec[j][1];
                z += nvec[j][2];
            }
            normals[i * 3 + 0] = (x / count);
            normals[i * 3 + 1] = (y / count);
            normals[i * 3 + 2] = (z / count);
        }

        data.normals = normals;
        this._engine.stats.memory.normals += normals.length / 3;
    };

    SceneJS.Geometry.prototype.setSource = function (sourceConfigs) {
        this._sourceConfigs = sourceConfigs;
        var source = this._source;
        if (source && source.configure) {
            source.configure(sourceConfigs);
        }
    };

    SceneJS.Geometry.prototype.getSource = function () {
        return this._sourceConfigs || {};
    };

    SceneJS.Geometry.prototype.setPositions = function (positions) {
        if (positions && this._core.vertexBuf) {
            this._boundary = null;
            var core = this._core;
            core.vertexBuf.bind();
            core.vertexBuf.setData(positions);
            core.arrays.positions.set(positions);
            core.kdTreeDirty = true;
            this._engine.display.imageDirty = true;
            if (core.interleavedBuf) {
                core.interleavedBuf.dirty = true;
            }
        }
    };

    SceneJS.Geometry.prototype.getPositions = function () {
        return this._core.arrays ? this._core.arrays.positions : null;
    };

    SceneJS.Geometry.prototype.getPositionDecodeMat = function () {
        return this._core.positionDecodeMat || null;
    };

    SceneJS.Geometry.prototype.setNormals = function (normals) {
        if (normals && this._core.normalBuf) {
            var core = this._core;
            core.normalBuf.bind();
            core.normalBuf.setData(normals);
            core.arrays.normals.set(normals);
            this._engine.display.imageDirty = true;
            if (core.interleavedBuf) {
                core.interleavedBuf.dirty = true;
            }
        }
    };

    SceneJS.Geometry.prototype.getNormals = function () {
        return this._core.arrays ? this._core.arrays.normals : null;
    };

    SceneJS.Geometry.prototype.setColors = function (colors) {
        if (colors && this._core.colorBuf) {
            var core = this._core;
            core.colorBuf.bind();
            core.colorBuf.setData(colors);
            core.arrays.colors.set(colors);
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getColors = function () {
        return this._core.arrays ? this._core.arrays.colors : null;
    };

    SceneJS.Geometry.prototype.setIndices = function (indices) {
        if (indices && this._core.indexBuf) {
            this._boundary = null;
            var core = this._core;
            core.indexBuf.bind();

            // Make sure indices remain of the same type.
            if (indices.constructor != core.arrays.indices.constructor) {
                indices = new core.arrays.indices.constructor(indices);
            }
            core.indexBuf.setData(indices);
            core.arrays.indices.set(indices);
            core.kdTreeDirty = true;
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getIndices = function () {
        return this._core.arrays ? this._core.arrays.indices : null;
    };

    SceneJS.Geometry.prototype.getUV = function () {
        return this._core.arrays ? this._core.arrays.uvs[0] : null;
    };

    SceneJS.Geometry.prototype.getUVDecodeMat = function () {
        return this._core.uvDecodeMats[0] || null;
    };

    SceneJS.Geometry.prototype.getUV2 = function () {
        return this._core.arrays ? this._core.arrays.uvs[1] : null;
    };

    SceneJS.Geometry.prototype.getUV2 = function () {
        return this._core.arrays ? this._core.arrays.uvs[2] : null;
    };

    SceneJS.Geometry.prototype.getUv3 = function () {
        return this._core.arrays ? this._core.arrays.uvs[3] : null;
    };

    SceneJS.Geometry.prototype.getPrimitive = function () {
        return this.primitive;
    };

    SceneJS.Geometry.prototype.getPointSize = function () {
        return this._core.pointSize;
    };

    SceneJS.Geometry.prototype.setPointSize = function (size) {
        if (size && this._core.pointSize !== size) {
            this._core.pointSize = size;
            this._engine.display.imageDirty = true;
        }
    };

    SceneJS.Geometry.prototype.getKdTree = function () {
        var object = this.getObject();
        if (object) {
            return object.getKdTree();
        } else {
            return this._core.getKdTree();
        }
    };

    SceneJS.Geometry.prototype.getObject = function() {
        return this._engine.display._objects[this.id] || null;
    };

    /** Returns the Model-space boundary of this geometry
     *
     * @returns {*}
     */
    SceneJS.Geometry.prototype.getBoundary = function () {
        if (this._boundary) {
            return this._boundary;
        }

        var arrays = this._core.arrays;

        if (!arrays) {
            return null;
        }

        var positions = arrays.positions;

        if (!positions) {
            return null;
        }

        this._boundary = {
            xmin: Number.POSITIVE_INFINITY,
            ymin: Number.POSITIVE_INFINITY,
            zmin: Number.POSITIVE_INFINITY,
            xmax: Number.NEGATIVE_INFINITY,
            ymax: Number.NEGATIVE_INFINITY,
            zmax: Number.NEGATIVE_INFINITY
        };

        var x, y, z;

        for (var i = 0, len = positions.length - 2; i < len; i += 3) {

            x = positions[i];
            y = positions[i + 1];
            z = positions[i + 2];

            if (x < this._boundary.xmin) {
                this._boundary.xmin = x;
            }
            if (y < this._boundary.ymin) {
                this._boundary.ymin = y;
            }
            if (z < this._boundary.zmin) {
                this._boundary.zmin = z;
            }
            if (x > this._boundary.xmax) {
                this._boundary.xmax = x;
            }
            if (y > this._boundary.ymax) {
                this._boundary.ymax = y;
            }
            if (z > this._boundary.zmax) {
                this._boundary.zmax = z;
            }
        }

        return this._boundary;
    };

    SceneJS.Geometry.prototype._compile = function (ctx) {

        if (this._core._loading) { // TODO: Breaks with asynch loaded cores - this node needs to recompile when target core is loaded
            this._compileNodes(ctx);
            return;
        }

        var core = this._core;

        var parts = [                           // Safe to build geometry hash here - geometry is immutable
            core.normalBuf ? "t" : "f",
            core.arrays && core.arrays.tangents ? "t" : "f",
            core.colorBuf ? "t" : "f",
            core.primitive,
            core.compressedPositions ? "t" : "f",
            core.compressedNormals ? "t" : "f",
            core.compressedUVs ? "t" : "f"
        ];

        // Hash parts for UVs

        parts.push(";uvs");
        var uvBufs = core.uvBufs;
        if (uvBufs) {
            for (var i = 0, len = uvBufs.length; i < len; i++) {
                parts.push(uvBufs[i] ? "t" : "f");
            }
        }

        core.hash = parts.join("");

        core.stateId = this._core.stateId;
        core.type = "geometry";

        this._engine.display.geometry = core;

        SceneJS_events.fireEvent(SceneJS_events.OBJECT_COMPILING, { // Pull in state updates from scenes nodes
            display: this._engine.display
        });

        this._engine.display.buildObject(this.id);

        this._compileNodes(ctx);
    };

    SceneJS.Geometry.prototype._destroy = function () {

        this._engine.display.removeObject(this.id);

        /* Destroy core if no other references
         */
        if (this._core.useCount == 1) {

            this._destroyNodeCore();

            if (this._source && this._source.destroy) {
                this._source.destroy();
            }

            this._engine.stats.geometry.meshes--;
        }
    };

    SceneJS.Geometry.prototype._destroyNodeCore = function () {

        if (document.getElementById(this._engine.canvas.canvasId)) { // Context won't exist if canvas has disappeared
            destroyBuffers(this._core);
        }

        var arrays = this._core.arrays;

        if (arrays.positions) {
            this._engine.stats.memory.positions -= arrays.positions.length / 3;
        }
        if (arrays.normals) {
            this._engine.stats.memory.normals -= arrays.normals.length / 3;
        }
        if (arrays.colors) {
            this._engine.stats.memory.colors -= arrays.colors.length / 3;
        }
        if (arrays.uvs && arrays.uvs.length > 0) {
            this._engine.stats.memory.uvs -= arrays.uvs.length * (arrays.uvs[0].length / 2);
        }
        if (arrays.indices) {
            this._engine.stats.memory.indices -= arrays.indices.length;
        }
    };

    function buildCore(gl, core) {
        var usage = gl.STATIC_DRAW;
        var arrays = core.arrays;
        var compressed = core.compressedPositions || core.compressedNormals || core.compressedUVs;
        var canInterleave = !compressed && !arrays.colors && (SceneJS.getConfigs("enableInterleaving") !== false);
        var dataLength = 0;
        var interleavedValues = 0;
        var interleavedArrays = [];
        var interleavedArrayStrides = [];

        core.transparent = !!arrays.colors;

        var prepareInterleaveBuffer = function (array, strideInElements) {
            if (dataLength == 0) {
                dataLength = array.length / strideInElements;
            } else if (array.length / strideInElements != dataLength) {
                canInterleave = false;
            }
            interleavedArrays.push(array);
            interleavedArrayStrides.push(strideInElements);
            interleavedValues += strideInElements;
            return (interleavedValues - strideInElements) * 4;
        };

        if (arrays.positions) {
            if (canInterleave) {
                core.interleavedPositionOffset = prepareInterleaveBuffer(arrays.positions, 3);
            }
            core.vertexBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.positions, arrays.positions.length, 3, usage);
        }

        if (core.compressedNormals) {
            // Note: Oct-encoded normal buffer has to be normalized.
            core.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.normals, arrays.normals.length, 2, usage, true);
        } else if (arrays.normals) {
            if (canInterleave) {
                core.interleavedNormalOffset = prepareInterleaveBuffer(arrays.normals, 3);
            }
            core.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.normals, arrays.normals.length, 3, usage);
        }

        if (arrays.uvs) {

            var uvs = arrays.uvs;
            var offsets;
            var i;
            var len;
            var uv;

            if (canInterleave) {
                core.interleavedUVOffsets = [];
                offsets = core.interleavedUVOffsets;
                for (i = 0, len = uvs.length; i < len; i++) {
                    offsets.push(prepareInterleaveBuffer(arrays.uvs[i], 2));
                }
            }

            core.uvBufs = [];

            for (i = 0, len = uvs.length; i < len; i++) {
                uv = arrays.uvs[i];
                if (uv.length > 0) {
                    core.uvBufs.push(new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, uv, uv.length, 2, usage));
                }
            }
        }

        if (arrays.colors) {
            if (canInterleave) {
                core.interleavedColorOffset = prepareInterleaveBuffer(arrays.colors, 4);
            }
            core.colorBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, arrays.colors, arrays.colors.length, 4, usage, true);
        }

        if (arrays.indices) {
            core.indexBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ELEMENT_ARRAY_BUFFER, arrays.indices, arrays.indices.length, 1, usage);
        }

        if (interleavedValues > 0 && canInterleave) {
            // We'll place the vertex attribute data interleaved in this array.
            // This will enable us to use less bindBuffer calls and make the data
            // efficient to address on the GPU.
            var interleaved = [];

            var arrayCount = interleavedArrays.length;
            for (var i = 0; i < dataLength; ++i) {
                for (var j = 0; j < arrayCount; ++j) {
                    var stride = interleavedArrayStrides[j];
                    for (var k = 0; k < stride; ++k) {
                        interleaved.push(interleavedArrays[j][i * stride + k]);
                    }
                }
            }
            core.interleavedStride = interleavedValues * 4; // in bytes
            core.interleavedBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, new Float32Array(interleaved), interleaved.length, interleavedValues, usage);
            core.interleavedBuf.dirty = false;
        }
    }

})();
;/**
 * @class Scene graph node which assigns nodes in its subgraph to a library
 * @extends SceneJS.Node
 */
SceneJS.Library = SceneJS_NodeFactory.createNodeType("library");
SceneJS.Library.prototype._compile = function(ctx) { // Bypass child nodes
};

;(function () {

    /**
     * The default state core singleton for {@link SceneJS.Lights} nodes
     */
    var defaultCore = {
        type: "lights",
        stateId: SceneJS._baseStateId++,
        hash: null,
        empty: false,
        lights: [
            {
                mode: "ambient",
                color: new Float32Array([0.7, 0.7, 0.8 ]),
                diffuse: true,
                specular: false
            },
            {
                mode: "dir",
                color: new Float32Array([1.0, 1.0, 1.0 ]),
                diffuse: true,
                specular: true,
                dir: new Float32Array([-0.5, -0.5, -1.0 ]),
                space: "view"
            },
            {
                mode: "dir",
                color: new Float32Array([1.0, 1.0, 1.0 ]),
                diffuse: false,
                specular: true,
                dir: new Float32Array([1.0, -0.9, -0.7 ]),
                space: "view"
            }
        ]
    };

    makeHash(defaultCore);

    function makeHash(core) {
        if (core.lights && core.lights.length > 0) {
            var lights = core.lights;
            var parts = [];
            var light;
            for (var i = 0, len = lights.length; i < len; i++) {
                light = lights[i];
                parts.push(light.mode);
                if (light.specular) {
                    parts.push("s");
                }
                if (light.diffuse) {
                    parts.push("d");
                }
                parts.push((light.space == "world") ? "w" : "v");
            }
            core.hash = parts.join("");

        } else {
            core.hash = "";
        }
    }

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.lights = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines light sources to illuminate the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Lights = SceneJS_NodeFactory.createNodeType("lights");

    SceneJS.Lights.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node defines the resource

            var lights = params.lights;

            if (!lights) {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.NODE_CONFIG_EXPECTED,
                    "lights node attribute missing : 'lights'");
            }

            this._core.lights = this._core.lights || [];

            for (var i = 0, len = lights.length; i < len; i++) {
                this._initLight(i, lights[i]);
            }
        }
    };

    SceneJS.Lights.prototype._initLight = function (index, cfg) {

        var light = {};
        this._core.lights[index] = light;

        var mode = cfg.mode || "dir";
        if (mode != "dir" && mode != "point" && mode != "ambient" && mode != "spot") {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Light mode not supported - should be 'dir' or 'point' or 'spot' or 'ambient'");
        }

        var pos = cfg.pos;
        var dir = cfg.dir;

        var color = cfg.color;
        light.color = new Float32Array([
                color.r != undefined ? color.r : 1.0,
                color.g != undefined ? color.g : 1.0,
                color.b != undefined ? color.b : 1.0
        ]);

        // Ambient lights hardwired to contribute to diffuse lighting
        light.mode = mode;
        light.diffuse = (mode == "ambient") ? true : ((cfg.diffuse != undefined) ? cfg.diffuse : true);
        light.specular = (mode == "ambient") ? false : ((cfg.specular != undefined) ? cfg.specular : true);
        light.pos = new Float32Array(cfg.pos ? [pos.x || 0, pos.y || 0, pos.z || 0 ] : [0, 0, 0]);
        light.dir = new Float32Array(cfg.dir ? [dir.x || 0, dir.y || 0, dir.z || 0] : [0, 0, 1]);
        light.innerCone = cfg.innerCone != undefined ? cfg.innerCone : 0.25;
        light.outerCone = cfg.outerCone != undefined ? cfg.outerCone : 0;
        light.attenuation = new Float32Array([
                cfg.constantAttenuation != undefined ? cfg.constantAttenuation : 0.0,
                cfg.linearAttenuation || 0.0,
                cfg.quadraticAttenuation || 0.0
        ]);

        var space = cfg.space;

        if (!space) {

            space = "world";

        } else if (space != "view" && space != "world") {

            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "lights node invalid value for property 'space': '" + space + "' - should be 'view' or 'world'");
        }

        light.space = space;

        this._core.hash = null;
    };


    SceneJS.Lights.prototype.setLights = function (lights) {
        var indexNum;
        for (var index in lights) {
            if (lights.hasOwnProperty(index)) {
                if (index != undefined || index != null) {
                    indexNum = parseInt(index);
                    if (indexNum < 0 || indexNum >= this._core.lights.length) {
                        throw SceneJS_error.fatalError(
                            SceneJS.errors.ILLEGAL_NODE_CONFIG,
                                "Invalid argument to set 'lights': index out of range (" + this._core.lights.length + " lights defined)");
                    }
                    this._setLight(indexNum, lights[index] || {});
                }
            }
        }
        this._engine.branchDirty(this); // Schedule recompilation of this subgraph
    };

    SceneJS.Lights.prototype._setLight = function (index, cfg) {

        var light = this._core.lights[index];

        // Impact of light update
        var imageDirty = false; // Redraw display list?
        var branchDirty = false; // Recompile scene branch?

        if (cfg.mode && cfg.mode != light.mode) {
            var mode = cfg.mode;
            if (mode != "dir" && mode != "point" && mode != "ambient") {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                    "Light mode not supported - should be 'dir' or 'point' or 'ambient'");
            }
            light.mode = mode;
            light.diffuse = (mode == "ambient") ? true : ((cfg.diffuse != undefined) ? cfg.diffuse : true);
            light.specular = (mode == "ambient") ? false : ((cfg.specular != undefined) ? cfg.specular : true);
            branchDirty = true;
        }

        if (cfg.color) {
            var color = cfg.color;
            light.color = new Float32Array([
                    color.r != undefined ? color.r : 1.0,
                    color.g != undefined ? color.g : 1.0,
                    color.b != undefined ? color.b : 1.0
            ]);
            imageDirty = true;
        }

        var pos = cfg.pos;
        if (pos) {
            light.pos = new Float32Array([ pos.x || 0, pos.y || 0, pos.z || 0 ]);
            imageDirty = true;
        }

        var dir = cfg.dir;
        if (dir) {
            light.dir = new Float32Array([dir.x || 0, dir.y || 0, dir.z || 0]);
            imageDirty = true;
        }

        if (cfg.innerCone != undefined && cfg.innerCone != light.innerCone) {
            light.innerCone = cfg.innerCone;
            imageDirty = true;
        }

        if (cfg.outerCone != undefined && cfg.outerCone != light.outerCone) {
            light.outerCone = cfg.outerCone;
            imageDirty = true;
        }

        if (cfg.constantAttenuation != undefined) {
            light.attenuation[0] = cfg.constantAttenuation;
            imageDirty = true;
        }
        if (cfg.linearAttenuation != undefined) {
            light.attenuation[1] = cfg.linearAttenuation;
            imageDirty = true;
        }
        if (cfg.quadraticAttenuation != undefined) {
            light.attenuation[2] = cfg.quadraticAttenuation;
            imageDirty = true;
        }

        if (cfg.space && cfg.space != light.space) {
            var space = cfg.space;
            if (space != "view" && space != "world") {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.ILLEGAL_NODE_CONFIG,
                        "lights node invalid value for property 'space': '" + space + "' - should be 'view' or 'world'");
            }
            light.space = space;
            this._core.hash = null;
            branchDirty = true;
        }

        if (cfg.specular != undefined && cfg.specular != light.specular) {
            light.specular = cfg.specular;
            branchDirty = true;
        }
        if (cfg.diffuse != undefined && cfg.diffuse != light.diffuse) {
            light.diffuse = cfg.diffuse;
            branchDirty = true;
        }

        if (branchDirty) {
            this._engine.branchDirty(this); // Schedule recompilation of this subgraph
        } else if (imageDirty) {
            this._engine.display.imageDirty = true;
        }

        this._core.hash = null;
    };

    SceneJS.Lights.prototype._compile = function (ctx) {

        if (!this._core.hash) {
            makeHash(this._core);
        }

        this._engine.display.lights = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.lights = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();
;(function () {

    var defaultMatrix = mat4.lookAt(mat4.create(), [0, 0, 10], [0, 0, 0], [0, 1, 0]);
    var defaultDeviceMatrix = mat4.create();
    var defaultMat = new Float32Array(defaultMatrix);

    /**
     * The default state core singleton for {@link SceneJS.Lookat} nodes
     */
    var defaultCore = {
        type:"lookAt",
        stateId:SceneJS._baseStateId++,
        viewMatrix: defaultMatrix,
        matrix:defaultMatrix,
        deviceMatrix: defaultDeviceMatrix,
        hasDeviceMatrix: false,
        mat:defaultMat,
        lookAt:SceneJS_math_LOOKAT_ARRAYS
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.viewTransform = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines the viewing transform for the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Lookat = SceneJS_NodeFactory.createNodeType("lookAt");

    SceneJS.Lookat.prototype._init = function (params) {

        this._mat = null;

        this._xf = {
            type:"lookat"
        };

        if (this._core.useCount == 1) { // This node is the resource definer

            this._core.eyeX = 0;
            this._core.eyeY = 0;
            this._core.eyeZ = 10.0;

            this._core.lookX = 0;
            this._core.lookY = 0;
            this._core.lookZ = 0;

            this._core.upX = 0;
            this._core.upY = 1;
            this._core.upZ = 0;

            if (!params.eye && !params.look && !params.up) {
                this.setEye({x:0, y:0, z:10.0 });
                this.setLook({x:0, y:0, z:0 });
                this.setUp({x:0, y:1.0, z:0 });
            } else {
                this.setEye(params.eye);
                this.setLook(params.look);
                this.setUp(params.up);
            }

            var core = this._core;

            core.matrix = mat4.create();
            core.deviceMatrix = mat4.create();

            var self = this;

            this._core.rebuild = function () {

                if (!core.mat) { // Lazy-create arrays
                    core.viewMatrix = mat4.create();
                    core.mat = mat4.create();
                }

                mat4.lookAt(core.viewMatrix,
                    [core.eyeX, core.eyeY, core.eyeZ],
                    [core.lookX, core.lookY, core.lookZ],
                    [core.upX, core.upY, core.upZ]);

                if (core.hasDeviceMatrix) {
                    mat4.multiply(core.matrix, core.deviceMatrix, core.viewMatrix); // Post-multiply the device matrix by the lookat matrix
                } else {
                    core.matrix.set(core.viewMatrix);
                }

                core.lookAt = {
                    eye:[core.eyeX, core.eyeY, core.eyeZ ],
                    look:[core.lookX, core.lookY, core.lookZ ],
                    up:[core.upX, core.upY, core.upZ ]
                };
                core.mat.set(core.matrix);

                if (self.onMatrix) {
                    self.onMatrix(core.matrix);
                }

                core.dirty = false;
            };

            this._core.dirty = true;

            // Rebuild on every scene tick
            // https://github.com/xeolabs/scenejs/issues/277
            this._tick = this.getScene().on("tick", function () {
                if (self._core.dirty) {
                    self._core.rebuild();
                }
            });
        }
    };

    /**
     * Returns the default view transformation matrix
     * @return {Float32Array}
     */
    SceneJS.Lookat.getDefaultMatrix = function () {
        return defaultMat;
    };

    SceneJS.Lookat.prototype.setEye = function (eye) {

        eye = eye || {};

        if (eye.x != undefined && eye.x != null) {
            this._core.eyeX = eye.x;
        }

        if (eye.y != undefined && eye.y != null) {
            this._core.eyeY = eye.y;
        }

        if (eye.z != undefined && eye.z != null) {
            this._core.eyeZ = eye.z;
        }

        this._core.dirty = true;
        this._engine.display.imageDirty = true;

        return this;
    };

    SceneJS.Lookat.prototype.incEye = function (eye) {
        eye = eye || {};
        this._core.eyeX += (eye.x != undefined && eye.x != null) ? eye.x : 0;
        this._core.eyeY += (eye.y != undefined && eye.y != null) ? eye.y : 0;
        this._core.eyeZ += (eye.z != undefined && eye.z != null) ? eye.z : 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setEyeX = function (x) {
        this._core.eyeX = x || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setEyeY = function (y) {
        this._core.eyeY = y || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setEyeZ = function (z) {
        this._core.eyeZ = z || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incEyeX = function (x) {
        this._core.eyeX += x;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incEyeY = function (y) {
        this._core.eyeY += y;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incEyeZ = function (z) {
        this._core.eyeZ += z;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.getEye = function () {
        return {
            x:this._core.eyeX,
            y:this._core.eyeY,
            z:this._core.eyeZ
        };
    };

    SceneJS.Lookat.prototype.setLook = function (look) {
        look = look || {};

        if (look.x != undefined && look.x != null) {
            this._core.lookX = look.x;
        }

        if (look.y != undefined && look.y != null) {
            this._core.lookY = look.y;
        }

        if (look.z != undefined && look.z != null) {
            this._core.lookZ = look.z;
        }

        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incLook = function (look) {
        look = look || {};
        this._core.lookX += (look.x != undefined && look.x != null) ? look.x : 0;
        this._core.lookY += (look.y != undefined && look.y != null) ? look.y : 0;
        this._core.lookZ += (look.z != undefined && look.z != null) ? look.z : 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setLookX = function (x) {
        this._core.lookX = x || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setLookY = function (y) {
        this._core.lookY = y || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setLookZ = function (z) {
        this._core.lookZ = z || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incLookX = function (x) {
        this._core.lookX += x;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incLookY = function (y) {
        this._core.lookY += y;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incLookZ = function (z) {
        this._core.lookZ += z;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.getLook = function () {
        return {
            x:this._core.lookX,
            y:this._core.lookY,
            z:this._core.lookZ
        };
    };

    SceneJS.Lookat.prototype.setUp = function (up) {
        up = up || {};

        if (up.x != undefined && up.x != null) {
            this._core.upX = up.x;
        }

        if (up.y != undefined && up.y != null) {
            this._core.upY = up.y;
        }

        if (up.z != undefined && up.z != null) {
            this._core.upZ = up.z;
        }

        this._core.dirty = true;
        this._engine.display.imageDirty = true;

        return this;
    };

    SceneJS.Lookat.prototype.incUp = function (up) {
        up = up || {};
        this._core.upX += (up.x != undefined && up.x != null) ? up.x : 0;
        this._core.upY += (up.y != undefined && up.y != null) ? up.y : 0;
        this._core.upZ += (up.z != undefined && up.z != null) ? up.z : 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setUpX = function (x) {
        this._core.upX = x || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setUpY = function (y) {
        this._core.upY = y || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.setUpZ = function (z) {
        this._core.upZ = z || 0;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incUpX = function (x) {
        this._core.upX += x;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incUpY = function (y) {
        this._core.upY += y;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.incUpZ = function (z) {
        this._core.upZ += z;
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Lookat.prototype.getUp = function () {
        return {
            x:this._core.upX,
            y:this._core.upY,
            z:this._core.upZ
        };
    };

    /**
     * Returns a copy of the matrix as a 1D array of 16 elements
     * @returns {Number[16]}
     */
    SceneJS.Lookat.prototype.getMatrix = function () {

        if (this._core.dirty) {
            this._core.rebuild();
        }

        return  SceneJS._sliceArray(this._core.viewMatrix, 0);
    };

    SceneJS.Lookat.prototype.getAttributes = function () {
        return {
            look:{
                x:this._core.lookX,
                y:this._core.lookY,
                z:this._core.lookZ
            },
            eye:{
                x:this._core.eyeX,
                y:this._core.eyeY,
                z:this._core.eyeZ
            },
            up:{
                x:this._core.upX,
                y:this._core.upY,
                z:this._core.upZ
            }
        };
    };

    SceneJS.Lookat.prototype.setDeviceMatrix = function (mat) {
        this._core.hasDeviceMatrix = !!mat;
        if (mat) {
            this._core.deviceMatrix.set(mat);
        }
        this._core.dirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Lookat.prototype._compile = function (ctx) {
        this._engine.display.viewTransform = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.viewTransform = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Lookat.prototype._destroy = function () {
        // Stop publishing matrix on each tick
        this.getScene().off(this._tick);
    };

})();
;/*

 TODO: material system from virtualworldframework:

 "color":
 "ambient":
 "specColor":
 "shininess":
 "reflect":
 "specular":
 "emit":
 "alpha":
 "binaryAlpha":
 */
new (function () {

    /**
     * The default state core singleton for {@link SceneJS.Material} nodes
     */
    var defaultCore = {
        type:"material",
        stateId:SceneJS._baseStateId++,
        baseColor:new Float32Array([ 1.0, 1.0, 1.0, 1.0 ]),
        specularColor:new Float32Array([ 1.0, 1.0, 1.0, 1.0 ]),
        emitColor:new Float32Array([ 1.0, 1.0, 1.0, 0.0 ]),
        shine:70.0,
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.material = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines surface material properties for the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Material = SceneJS_NodeFactory.createNodeType("material");

    SceneJS.Material.prototype._init = function (params) {
        if (this._core.useCount == 1) {
            this._core.baseColor = new Float32Array(defaultCore.baseColor);
            this._core.specularColor = new Float32Array(defaultCore.specularColor);
            this._core.emitColor = new Float32Array(defaultCore.emitColor);
            this._core.shine = defaultCore.shine;
            if (params.color || params.baseColor) {
                this.setBaseColor(params.color || params.baseColor);
            }
            if (params.specularColor) {
                this.setSpecularColor(params.specularColor);
            }
            if (params.emitColor) {
                this.setEmitColor(params.emitColor);
            }
            if (params.specular != undefined) {
                this.setSpecular(params.specular);
            }
            if (params.shine != undefined) {
                this.setShine(params.shine);
            }
            if (params.emit != undefined) {
                this.setEmit(params.emit);
            }
            if (params.alpha != undefined) {
                this.setAlpha(params.alpha);
            }
        }
    };

    /**
     * @deprecated
     * @param color
     * @return {*}
     */
    SceneJS.Material.prototype.setBaseColor = function (color) {
        var defaultBaseColor = defaultCore.baseColor;
        this._core.baseColor[0] = color.r != undefined ? color.r : defaultBaseColor[0];
        this._core.baseColor[1] = color.g != undefined ? color.g : defaultBaseColor[1];
        this._core.baseColor[2] = color.b != undefined ? color.b : defaultBaseColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.setColor = SceneJS.Material.prototype.setBaseColor;

    /**
     * @deprecated
     * @return {Object}
     */
    SceneJS.Material.prototype.getBaseColor = function () {
        return {
            r:this._core.baseColor[0],
            g:this._core.baseColor[1],
            b:this._core.baseColor[2]
        };
    };

    SceneJS.Material.prototype.getColor = SceneJS.Material.prototype.getBaseColor;

    SceneJS.Material.prototype.setSpecularColor = function (color) {
        var defaultSpecularColor = defaultCore.specularColor;
        this._core.specularColor[0] = color.r != undefined ? color.r : defaultSpecularColor[0];
        this._core.specularColor[1] = color.g != undefined ? color.g : defaultSpecularColor[1];
        this._core.specularColor[2] = color.b != undefined ? color.b : defaultSpecularColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getSpecularColor = function () {
        return {
            r:this._core.specularColor[0],
            g:this._core.specularColor[1],
            b:this._core.specularColor[2]
        };
    };

    SceneJS.Material.prototype.setEmitColor = function (color) {
        var defaultEmitColor = defaultCore.emitColor;
        this._core.emitColor[0] = color.r != undefined ? color.r : defaultEmitColor[0];
        this._core.emitColor[1] = color.g != undefined ? color.g : defaultEmitColor[1];
        this._core.emitColor[2] = color.b != undefined ? color.b : defaultEmitColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getEmitColor = function () {
        return {
            r:this._core.emitColor[0],
            g:this._core.emitColor[1],
            b:this._core.emitColor[2]
        };
    };

    SceneJS.Material.prototype.setSpecular = function (specular) {
        this._core.specularColor[3] = (specular != undefined && specular != null) ? specular : defaultCore.specularColor[3];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getSpecular = function () {
        return this._core.specularColor[3];
    };

    SceneJS.Material.prototype.setShine = function (shine) {
        this._core.shine = (shine != undefined) ? shine : defaultCore.shine;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getShine = function () {
        return this._core.shine;
    };

    SceneJS.Material.prototype.setEmit = function (emit) {
        this._core.emitColor[3] = (emit != undefined) ? emit : defaultCore.emitColor[3];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Material.prototype.getEmit = function () {
        return this._core.emitColor[3];
    };

    SceneJS.Material.prototype.setAlpha = function (alpha) {
        this._core.baseColor[3] = (alpha != undefined) ? alpha : defaultCore.baseColor[3];
        this._core.transparent = this._core.baseColor[3] < 1;
        this._engine.display.imageDirty = true;

        return this;
    };

    SceneJS.Material.prototype.getAlpha = function () {
        return this._core.baseColor[3];
    };

    SceneJS.Material.prototype._compile = function (ctx) {
        this._engine.display.material = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.material = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();
;new (function () {

    var KD_TREE_MAX_DEPTH = SceneJS.KD_TREE_MAX_DEPTH;
    var KD_TREE_MIN_TRIANGLES = SceneJS.KD_TREE_MIN_TRIANGLES;

    /**
     * The default state core singleton for {@link SceneJS.MorphGeometry} nodes
     */
    var defaultCore = {
        type: "morphGeometry",
        stateId: SceneJS._baseStateId++,
        hash: "",
        //         empty: true,
        morph: null
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.morphGeometry = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which defines morphing behaviour for the {@link SceneJS.Geometry}s within its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.MorphGeometry = SceneJS_NodeFactory.createNodeType("morphGeometry");

    SceneJS.MorphGeometry.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node defines the resource

            this._pickPositionsDirty = true;

            this._buildNodeCore(params);

            this._core.webglRestored = function () {
                //self._buildNodeCore(self._engine.canvas.gl, self._core);
            };

            var self = this;

            // For the morph target at the given index,
            // returns a positions VBO for triangle-picking,
            // lazy-generated from the given indices if not yet existing.

            this._core.getPickPositions = function (index, indices) {
                if (self._pickPositionsDirty) {
                    self._buildPickPositions(indices);
                }
                return self._core.targets[index].pickPositionsBuf;
            };

            // For the morph target at the given index,
            // returns tangents for normal mapping
            // lazy-generated from the given indices if not yet existing.

            this._core.getTangents = function (index, indices, uv, positionDecodeMat, uvDecodeMat) {
                var core = self._core;
                var target = core.targets[index];
                if (target.tangentBuf) {
                    return target.tangentBuf;
                }
                var positions = target.positions;
                var positionDecodeMat = target.positionDecodeMat || positionDecodeMat;
                uv = target.uv || uv;
                if (positions && indices && uv) {
                    var gl = self._engine.canvas.gl;
                    var tangents = SceneJS_math_buildTangents(positions, indices, uv, positionDecodeMat, uvDecodeMat);
                    target.tangents = tangents;
                    var usage = gl.STATIC_DRAW;
                    target.tangentBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, tangents, tangents.length, 3, usage);
                    return target.tangentBuf;
                }
            };

            this.setFactor(params.factor);
        }

        this._core.factor = params.factor || 0;
        this._core.clamp = !!params.clamp;
    };

    SceneJS.MorphGeometry.prototype._buildNodeCore = function (data) {

        try {
            buildCore(this, data);
        } catch (e) {

            /* Allocation failure - deallocate target VBOs
             */
            for (var i = 0, len = this._core.targets.length; i < len; i++) {

                target = core.targets[i];

                if (target.vertexBuf) {
                    target.vertexBuf.destroy();
                }
                if (target.normalBuf) {
                    target.normalBuf.destroy();
                }
                if (target.uvBuf) {
                    target.uvBuf.destroy();
                }
                if (target.uvBuf2) {
                    target.uvBuf2.destroy();
                }
            }

            throw SceneJS_error.fatalError(
                SceneJS.errors.ERROR,
                "Failed to allocate VBO(s) for morphGeometry: " + e);
        }

    };

    SceneJS.MorphGeometry.prototype._buildPickPositions = function (indices) {

        var core = this._core;
        var target = null;
        var pickPositions;
        var gl = this._engine.canvas.gl;
        var usage = gl.STATIC_DRAW;

        // On each morph target, build a positions array for
        // color-indexed triangle-picking.

        for (var i = 0, len = core.targets.length; i < len; i++) {

            target = core.targets[i];

            if (target.positions) {

                if (target.pickPositionsBuf) {
                    target.pickPositionsBuf.destroy();
                    target.pickPositionsBuf = null;
                }

                pickPositions = SceneJS_math_getPickPositions(target.positions, indices);

                target.pickPositionsBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, pickPositions, pickPositions.length, 3, usage);
            }
        }

        this._pickPositionsDirty = false;
    };

    SceneJS.MorphGeometry.prototype.setFactor = function (factor) {
        factor = factor || 0.0;

        var core = this._core;

        var keys = core.keys;
        var key1 = core.key1;
        var key2 = core.key2;

        var oldFactor = core.factor;

        if (factor < keys[0]) {
            key1 = 0;
            key2 = 1;

        } else if (factor > keys[keys.length - 1]) {
            key1 = keys.length - 2;
            key2 = key1 + 1;

        } else {
            while (keys[key1] > factor) {
                key1--;
                key2--;
            }
            while (keys[key2] < factor) {
                key1++;
                key2++;
            }
        }

        var frameUpdate = key1 != core.key1;

        /* Normalise factor to range [0.0..1.0] for the target frame
         */
        core.factor = (factor - keys[key1]) / (keys[key2] - keys[key1]);

        this._factor = factor;

        var morphUpdate = frameUpdate || oldFactor != core.factor;

        core.key1 = key1;
        core.key2 = key2;

        if (morphUpdate) {
            var currentFrame = this.getCurrentFrame();
            if (this.onUpdate) {
                this.onUpdate(currentFrame);
            }
            if (frameUpdate && this.onFrameUpdate) {
                this.onFrameUpdate(currentFrame);
            }

            core.kdTreeDirty = true;
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.MorphGeometry.prototype.getFactor = function () {
        return this._factor;
    };

    SceneJS.MorphGeometry.prototype.getKeys = function () {
        return this._core.keys;
    };

    SceneJS.MorphGeometry.prototype.getTargets = function () {
        return this._core.targets;
    };

    SceneJS.MorphGeometry.prototype.getCurrentFrame = function () {
        var core = this._core;
        var key1 = core.key1;
        var key2 = core.key2;
        return {
            key1: key1,
            key2: key2,
            factor: core.factor,
            target1: core.targets[key1],
            target2: core.targets[key2]
        }
    };

    SceneJS.MorphGeometry.prototype._compile = function (ctx) {

        if (!this._core.hash) {
            this._makeHash();
        }

        this._engine.display.morphGeometry = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.morphGeometry = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.MorphGeometry.prototype._makeHash = function () {
        var core = this._core;
        if (core.targets.length > 0) {
            var target0 = core.targets[0];  // All targets have same arrays
            var t = "t";
            var f = "f";
            core.hash = ([
                target0.vertexBuf ? t : f,
                target0.normalBuf ? t : f,
                target0.uvBuf ? t : f,
                target0.uvBuf2 ? t : f
            ]).join("");
        } else {
            core.hash = "";
        }
    };

    SceneJS.MorphGeometry.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Destroy core if no other references
            if (document.getElementById(this._engine.canvas.canvasId)) { // Context won't exist if canvas has disappeared
                var core = this._core;
                var target;
                for (var i = 0, len = core.targets.length; i < len; i++) {
                    target = core.targets[i];
                    if (target.vertexBuf) {
                        target.vertexBuf.destroy();
                    }
                    if (target.pickPositionsBuf) {
                        target.pickPositionsBuf.destroy();
                    }
                    if (target.normalBuf) {
                        target.normalBuf.destroy();
                    }
                    if (target.uvBuf) {
                        target.uvBuf.destroy();
                    }
                    if (target.uvBuf2) {
                        target.uvBuf2.destroy();
                    }
                }
            }
        }
    };

    function buildCore(node, data) {
        var targetsData = data.targets || [];
        if (targetsData.length < 2) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "morphGeometry node should have at least two targets");
        }

        var keysData = data.keys || [];
        if (keysData.length != targetsData.length) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "morphGeometry node mismatch in number of keys and targets");
        }

        var core = node._core;
        var gl = node._engine.canvas.gl;
        var usage = gl.STATIC_DRAW; //var usage = (!arrays.fixed) ? gl.STREAM_DRAW : gl.STATIC_DRAW;

        core.keys = keysData;
        core.targets = [];
        core.key1 = 0;
        core.key2 = 1;

        /* First target's arrays are defaults for where not given on previous and subsequent targets.
         * When target does have array, subsequent targets without array inherit it.
         */

        var positions;
        var normals;
        var uv;
        var uv2;

        var targetData;

        for (var i = 0, len = targetsData.length; i < len; i++) {
            targetData = targetsData[i];

            if (!positions && targetData.positions) {
                positions = targetData.positions;
            }
            if (!normals && targetData.normals) {
                normals = targetData.normals;
            }
            if (!uv && targetData.uv) {
                uv = targetData.uv;
            }
            if (!uv2 && targetData.uv2) {
                uv2 = targetData.uv2;
            }
        }

        var target;
        var arry;

        for (var i = 0, len = targetsData.length; i < len; i++) {
            targetData = targetsData[i];
            target = {};

            arry = targetData.positions || positions;
            if (arry) {
                if (targetData.positionDecodeMat) {
                    target.positions = arry;
                    target.positionDecodeMat = targetData.positionDecodeMat;
                    core.compressedPositions = true;
                } else {
                    target.positions = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                }

                target.vertexBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.positions, arry.length, 3, usage);

                positions = arry;
                node._engine.stats.memory.morphPositions += target.positions.length * target.positions.constructor.BYTES_PER_ELEMENT;
            }

            arry = targetData.normals || normals;
            if (arry) {
                if (arry.constructor == Int8Array) {
                    target.normals = arry;
                    core.compressedNormals = true;
                    target.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.normals, arry.length, 2, usage, true);
                } else {
                    target.normals = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                    target.normalBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.normals, arry.length, 3, usage);
                }
                normals = arry;
                node._engine.stats.memory.morphNormals += target.normals.length * target.normals.constructor.BYTES_PER_ELEMENT;
            }

            arry = targetData.uv || uv;
            if (arry) {
                target.uv = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                target.uvBuf = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.uv, arry.length, 2, usage);
                uv = arry;
            }

            arry = targetData.uv2 || uv2;
            if (arry) {
                target.uv2 = (arry.constructor == Float32Array) ? arry : new Float32Array(arry);
                target.uvBuf2 = new SceneJS._webgl.ArrayBuffer(gl, gl.ARRAY_BUFFER, target.uv2, arry.length, 2, usage);
                uv2 = arry;
            }

            core.targets.push(target);  // We'll iterate this to destroy targets when we recover from error
        }

        core.kdTree = null;
        core.kdTreeDirty = true;

        core.getKdTree = function (indices) {
            if (!this.kdTreeDirty) {
                return this.kdTree;
            }

            var key1 = this.key1;
            var key2 = this.key2;
            var positions1 = this.targets[key1].positions;
            var positions1DecodeMat = this.targets[key1].positionDecodeMat;
            var positions2 = this.targets[key2].positions;
            var positions2DecodeMat = this.targets[key2].positionDecodeMat;
            var factor = this.factor;

            var numTris = indices.length / 3;
            var triangles = new Array(numTris);
            for (var i = 0; i < numTris; ++i) {
                triangles[i] = i;
            }
            this.kdTree = buildKdTreeNode(triangles, indices, positions1, positions1DecodeMat, positions2, positions2DecodeMat, factor, 0);
            this.kdTreeDirty = false;

            return this.kdTree;
        };

        node._pickPositionsDirty = true;
    }

    var dimLength = vec3.create();
    var position1 = vec3.create();
    var position2 = vec3.create();
    var position = vec3.create();

    function buildKdTreeNode(triangles, indices, positions1, decompress1, positions2, decompress2, factor, depth) {
        var min = vec3.create();
        var max = vec3.create();

        var node = {
            triangles: null,
            left: null,
            numLeft: 0,
            right: null,
            numRight: 0,
            leaf: false,
            splitDim: 0,
            bb: {
                min: min,
                max: max
            }
        };

        if (triangles.length === 0) {
            node.triangles = triangles;
            node.leaf = true;
            return node;
        }

        min[0] = min[1] = min[2] = Number.POSITIVE_INFINITY;
        max[0] = max[1] = max[2] = Number.NEGATIVE_INFINITY;

        var oneMinus = 1 - factor;
        var i, len;
        
        for (t = 0, len = triangles.length; t < len; ++t) {
            var ii = triangles[t] * 3;

            for (var j = 0; j < 3; ++j) {
                var pi = indices[ii + j] * 3;
                position1[0] = positions1[pi];
                position1[1] = positions1[pi + 1];
                position1[2] = positions1[pi + 2];

                if (decompress1) {
                    SceneJS_math_decompressPosition(position1, position1, decompress1);
                }

                position2[0] = positions2[pi];
                position2[1] = positions2[pi + 1];
                position2[2] = positions2[pi + 2];

                if (decompress2) {
                    SceneJS_math_decompressPosition(position2, position2, decompress2);
                }

                position[0] = oneMinus * position1[0] + factor * position2[0];
                position[1] = oneMinus * position1[1] + factor * position2[1];
                position[2] = oneMinus * position1[2] + factor * position2[2];

                if (position[0] < min[0]) {
                    min[0] = position[0]
                } 

                if (position[0] > max[0]) {
                    max[0] = position[0]
                }

                if (position[1] < min[1]) {
                    min[1] = position[1]
                } 

                if (position[1] > max[1]) {
                    max[1] = position[1]
                }

                if (position[2] < min[2]) {
                    min[2] = position[2]
                } 

                if (position[2] > max[2]) {
                    max[2] = position[2]
                }
            }
        }

        if (triangles.length < KD_TREE_MIN_TRIANGLES || depth > KD_TREE_MAX_DEPTH) {
            node.triangles = triangles;
            node.leaf = true;
            return node;
        }

        dimLength[0] = max[0] - min[0];
        dimLength[1] = max[1] - min[1];
        dimLength[2] = max[2] - min[2];

        var dim = 0;

        if (dimLength[1] > dimLength[dim]) {
            dim = 1;
        }

        if (dimLength[2] > dimLength[dim]) {
            dim = 2;
        }

        node.splitDim = dim;

        var mid = (min[dim] + max[dim]) / 2;
        var left = new Array(triangles.length);
        var numLeft = 0;
        var right = new Array(triangles.length);
        var numRight = 0;

        for (t = 0, len = triangles.length; t < len; ++t) {
            var ii = triangles[t] * 3;
            var i0 = indices[ii];
            var i1 = indices[ii + 1];
            var i2 = indices[ii + 2];

            var pi0 = i0 * 3;
            var pi1 = i1 * 3;
            var pi2 = i2 * 3;

            var v11 = positions1[pi0 + dim];
            var v12 = positions1[pi1 + dim];
            var v13 = positions1[pi2 + dim];

            if (decompress1) {
                var scale = decompress1[dim * 5];
                var translate = decompress1[dim + 12]
                v11 = v11 * scale + translate;
                v12 = v12 * scale + translate;
                v13 = v13 * scale + translate;
            }

            var v21 = positions2[pi0 + dim];
            var v22 = positions2[pi1 + dim];
            var v23 = positions2[pi2 + dim];

            if (decompress2) {
                var scale = decompress2[dim * 5];
                var translate = decompress2[dim + 12]
                v21 = v21 * scale + translate;
                v22 = v22 * scale + translate;
                v23 = v23 * scale + translate;
            }

            var v1 = oneMinus * v11 + factor * v21;
            var v2 = oneMinus * v12 + factor * v22;
            var v3 = oneMinus * v13 + factor * v23;

            if (v1 <= mid || v2 <= mid || v3 <= mid) {
                left[numLeft++] = triangles[t];
            } else {
                right[numRight++] = triangles[t];
            }
        }

        node.numLeft = left.length = numLeft;
        node.numRight = right.length = numRight;

        node.left = buildKdTreeNode(left, indices, positions1, decompress1, positions2, decompress2, factor, depth + 1);
        node.right = buildKdTreeNode(right, indices, positions1, decompress1, positions2, decompress2, factor, depth + 1);

        return node;
    }
})();
;(function () {

    // The default state core singleton for {@link SceneJS.View} nodes
    var defaultCore = {
        type:"view",
        stateId:SceneJS._baseStateId++,
        scissorTestEnabled:false
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.view = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures view parameters such as depth range, scissor test and viewport
     * @extends SceneJS.Node
     * void depthRange(floatzNear, floatzFar)
     zNear: Clamped to the range 0 to 1 Must be <= zFar
     zFar: Clamped to the range 0 to 1.
     void scissor(int x, int y, long width, long height)
     void viewport(int x, int y, long width, long height)
     */
    SceneJS.View = SceneJS_NodeFactory.createNodeType("view");

    SceneJS.View.prototype._init = function (params) {

        if (params.scissorTestEnabled != undefined) {
            this.setScissorTestEnabled(params.scissorTestEnabled);
        } else if (this._core.useCount == 1) { // This node defines the core
            this.setScissorTestEnabled(false);
        }
    };

    /**
     * Enable or disables scissor test.
     *
     * When enabled, the scissor test will discards fragments that are outside the scissor box.
     *
     * Scissor test is initially disabled.
     *
     * @param scissorTestEnabled Specifies whether scissor test is enabled or not
     * @return {*}
     */
    SceneJS.View.prototype.setScissorTestEnabled = function (scissorTestEnabled) {
        if (this._core.scissorTestEnabled != scissorTestEnabled) {
            this._core.scissorTestEnabled = scissorTestEnabled;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Get whether or not scissor test is enabled.
     * Initial value will be false.
     *
     * @return Boolean
     */
    SceneJS.View.prototype.getScissorTestEnabled = function () {
        return this._core.scissorTestEnabled;
    };

    SceneJS.View.prototype._compile = function (ctx) {
        this._engine.display.view = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.view = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();;/**
 * @class The root node of a scenegraph
 * @extends SceneJS.Node
 *
 */

SceneJS.Scene = SceneJS_NodeFactory.createNodeType("scene");

SceneJS.Scene.prototype._init = function (params) {

    /**
     * Set false when canvas is to be transparent.
     * @type {boolean}
     */
    this.transparent = (params.transparent === true);

    /**
     * Tracks statistics within this engine, such as numbers of
     * scenes, textures, geometries etc.
     *
     * @property stats
     * @type {*}
     * @final
     */
    this.stats = this._engine.stats;

    // Pub/sub support
    this._handleMap = new SceneJS_Map(); // Subscription handle pool
    this._topicSubs = {}; // A [handle -> callback] map for each topic name
    this._handleTopics = {}; // Maps handles to topic names
    this._topicPubs = {}; // Maps topics to publications
};


/**
 * Simulate a lost WebGL context for testing purposes.
 * Only works if the simulateWebGLLost was given as an option to {@link SceneJS.createScene}.
 */
SceneJS.Scene.prototype.loseWebGLContext = function () {
    this._engine.loseWebGLContext();
};


/**
 * Returns the HTML canvas for this scene
 * @return {HTMLCanvas} The canvas
 */
SceneJS.Scene.prototype.getCanvas = function () {
    return this._engine.canvas.canvas;
};

/**
 * Returns the WebGL context for this scene
 */
SceneJS.Scene.prototype.getGL = function () {
    return this._engine.canvas.gl;
};

/**
 * True if WebGL 2 is supported
 */
SceneJS.Scene.prototype.getWebGL2Supported = function () {
    return this._engine.canvas.webgl2;
};

/** Returns the Z-buffer depth in bits of the webgl context that this scene is to bound to.
 */
SceneJS.Scene.prototype.getZBufferDepth = function () {
    var gl = this._engine.canvas.gl;
    return gl.getParameter(gl.DEPTH_BITS);
};

/**
 * Set canvas size multiplier for supersample anti-aliasing
 */
SceneJS.Scene.prototype.setResolutionScaling = function (resolutionScaling) {
    return this._engine.canvas.setResolutionScaling(resolutionScaling);
};

SceneJS.Scene.prototype.setFogDensity = function(d) {
    this._engine.display.fogDensity = d;
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setFogStart = function(s) {
    this._engine.display.fogParams[0] = s;
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setFogEnd = function(e) {
    this._engine.display.fogParams[1] = e;
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setFogMin = function(min) {
    this._engine.display.fogParams[2] = min;
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setFogMax = function(max) {
    this._engine.display.fogParams[3] = max;
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setFogColor = function(r, g, b) {
    this._engine.display.fogColor[0] = r;
    this._engine.display.fogColor[1] = g;
    this._engine.display.fogColor[2] = b;
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setFogDensity = function(d) {
    this._engine.display.fogColor[3] = d;
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setFogMode = function(mode) {
    this._engine.display.fogMode = mode;
    this._engine.branchDirty(this);
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setFogEnabled = function(enabled) {
    this._engine.display.fogEnabled = enabled;
    this._engine.branchDirty(this);
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setXrayGlassFactor = function(gf) {
    this._engine.display.xrayGlassFactor = gf;
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setXrayMurkiness = function(m) {
    this._engine.display.xrayMurkiness = m;
    this._engine.display.imageDirty = true;
};

SceneJS.Scene.prototype.setXrayBGColor = function(r, g, b) {
    this._engine.display.xrayBGColor[0] = r;
    this._engine.display.xrayBGColor[1] = g;
    this._engine.display.xrayBGColor[2] = b;
    this._engine.display.imageDirty = true;
};

/**
 * Sets the number of times this scene is drawn on each render.
 * <p>This is useful for when we need to do things like render for left and right eyes.
 * @param {Number} numPasses The number of times the scene is drawn on each frame.
 */
SceneJS.Scene.prototype.setNumPasses = function (numPasses) {
    this._engine.setNumPasses(numPasses);
};

/**
 *  When doing multiple passes per frame, specifies whether to clear the
 * canvas before each pass (true) or just before the first pass (false).
 *
 * <p>This is useful for when we need to do things like render a separate pass to a stereo framebuffer for left and right eyes,
 * where we want to clear the buffer before each pass.</p>
 *
 * @param {Boolean} clearEachPass Tryu to clear before each pass (default is false).
 */
SceneJS.Scene.prototype.setClearEachPass = function (clearEachPass) {
    this._engine.setClearEachPass(clearEachPass);
};

SceneJS.Scene.prototype.setViewport = function (xmin, ymin, width, height) {
    this._engine.display.setViewport(xmin, ymin, width, height);
};

/**
 * Render a single frame if new frame pending, or force a new frame
 * Returns true if frame rendered
 */
SceneJS.Scene.prototype.renderFrame = function (params) {
    return this._engine.renderFrame(params);
};

/**
 * Prevent re-compilation of scene graph.
 */
SceneJS.Scene.prototype.pauseCompilation = function () {
    return this._engine.pauseCompilation();
};

/**
 * Resume re-compilation of scene graph.
 */
SceneJS.Scene.prototype.resumeCompilation = function () {
    return this._engine.resumeCompilation();
};

/**
 * Force compilation of the scene graph.
 */
SceneJS.Scene.prototype.compile = function () {
    return this._engine.compile();
};

/**
 * Signals that a new frame will be needed
 * @param params
 */
SceneJS.Scene.prototype.needFrame = function () {
    this._engine.display.imageDirty = true;
};

/**
 * Starts the render loop for this scene
 */
SceneJS.Scene.prototype.start = function (params) {
    this._engine.start(params);
};

/**
 * Set refresh rate for the scene
 */
SceneJS.Scene.prototype.setTicksPerRender = function (ticks) {
    this._engine.ticksPerRender = ticks;
};

/**
 * Pauses/unpauses current render loop that was started with {@link #start}. After this, {@link #isRunning} will return false.
 * @param {Boolean} doPause Indicates whether to pause or unpause the render loop
 */
SceneJS.Scene.prototype.pause = function (doPause) {
    this._engine.pause(doPause);
};

/**
 * Returns true if the scene's render loop is currently running.
 * @returns {Boolean} True when scene render loop is running
 */
SceneJS.Scene.prototype.isRunning = function () {
    return this._engine.running;
};

/**
 *
 */
SceneJS.Scene.prototype.pick = function () {

    // Backwards compatibility with pick(canvasX, canvasY, params)
    var params;
    if (SceneJS._isNumeric(arguments[0])) {
        var canvasX = arguments[0];
        var canvasY = arguments[1];
        params = arguments[2] || {};
        params.canvasPos = new Float32Array([canvasX, canvasY])
    } else {
        params = arguments[0] || {};
    }

    var result = this._engine.pick(params);
    this.renderFrame({force: true}); // HACK: canvas blanks after picking
    if (result) {
        this.publish("pick", result);
        return result;
    } else {
        this.publish("nopick");
    }
};


/**
 * Reads colors of pixels from the last rendered frame.
 *
 * <p>Call this method like this:</p>
 *
 * <pre>
 *
 * // Ignore transparent pixels (default is false)
 * var opaqueOnly = true;
 *
 * #readPixels([
 *      { x: 100, y: 22,  r: 0, g: 0, b: 0 },
 *      { x: 120, y: 82,  r: 0, g: 0, b: 0 },
 *      { x: 12,  y: 345, r: 0, g: 0, b: 0 }
 * ], 3, opaqueOnly);
 * </pre>
 *
 * Then the r,g,b components of the entries will be set to the colors at those pixels.
 */
SceneJS.Scene.prototype.readPixels = function (entries, size, opaqueOnly) {
    return this._engine.readPixels(entries, size, opaqueOnly);
};

/**
 * Scene node's destroy handler, called by {@link SceneJS_node#destroy}
 * @private
 */
SceneJS.Scene.prototype._destroy = function () {
    if (!this.destroyed) {
        delete SceneJS._engines[this.id];  // HACK: circular dependency
        SceneJS._engineIds.removeItem(this.id); // HACK: circular dependency
        this.destroyed = true;
    }
};

/**
 * Returns true if scene active, ie. not destroyed. A destroyed scene becomes active again
 * when you render it.
 */
SceneJS.Scene.prototype.isActive = function () {
    return !this._engine.destroyed;
};

/**
 * Stops current render loop that was started with {@link #start}. After this, {@link #isRunning} will return false.
 */
SceneJS.Scene.prototype.stop = function () {
    this._engine.stop();
};

/** Determines if node exists in this scene
 * @deprecated
 */
SceneJS.Scene.prototype.containsNode = function (nodeId) {
    return !!this._engine.findNode(nodeId);
};

/**
 * Finds nodes in this scene that have nodes IDs matching the given regular expression
 *
 * @param {String} nodeIdRegex Regular expression to match on node IDs
 * @return {[SceneJS.Node]} Array of nodes whose IDs match the given regex
 */
SceneJS.Scene.prototype.findNodes = function (nodeIdRegex) {
    return this._engine.findNodes(nodeIdRegex);
};

/**
 * Finds the node with the given ID in this scene
 * @deprecated
 * @param {String} nodeId Node ID
 * @return {SceneJS.Node} The node if found, else null
 */
SceneJS.Scene.prototype.findNode = function (nodeId) {
    return this.getNode(nodeId);
};

/**
 * @function Finds the node with the given ID in this scene
 * @param {String} nodeId Node ID
 * @return {SceneJS.Node} The node if found, else null
 */
SceneJS.Scene.prototype.getNode = function (nodeId) {
    return this._engine.findNode(nodeId);
};

/**
 * Tests whether a node core of the given ID exists for the given node type
 * @param {String} type Node type
 * @param {String} coreId
 * @returns Boolean
 */
SceneJS.Scene.prototype.hasCore = function (type, coreId) {
    return this._engine.hasCore(type, coreId);
};

/**
 * Returns the current status of this scene.
 *
 * When the scene has been destroyed, the returned status will be a map like this:
 *
 * {
 *      destroyed: true
 * }
 *
 * Otherwise, the status will be:
 *
 * {
 *      numTasks: Total number of asset loads (eg. texture, geometry stream etc.) currently in progress for this scene
 * }
 *
 */
SceneJS.Scene.prototype.getStatus = function () {
    var sceneStatus = SceneJS_sceneStatusModule.sceneStatus[this.id];
    if (!sceneStatus) {
        return {
            destroyed: true
        };
    }
    return SceneJS._shallowClone(sceneStatus);
};

/**
 * Publishes to a topic on this node.
 *
 * Immediately notifies existing subscriptions to that topic, and unless the "forget' parameter is
 * true, retains the publication to give to any subsequent notifications on that topic as they are made.
 *
 * @param {String} topic Publication topic
 * @param {Object} pub The publication
 * @param {Boolean} [forget] When true, the publication will be sent to subscribers then forgotten, so that any
 * subsequent subscribers will not receive it
 */
SceneJS.Scene.prototype.publish = function (topic, pub, forget) {
    if (!forget) {
        this._topicPubs[topic] = pub; // Save notification
    }
    if (this._topicSubs[topic]) { // Notify subscriptions
        var subsForTopic = this._topicSubs[topic];
        for (var handle in subsForTopic) {
            if (subsForTopic.hasOwnProperty(handle)) {
                subsForTopic[handle].call(this, pub);
            }
        }
    }
};

/**
 * Removes a topic publication
 *
 * Immediately notifies existing subscriptions to that topic, sending them each a null publication.
 *
 * @param topic Publication topic
 * @private
 */
SceneJS.Scene.prototype.unpublish = function (topic) {
    var subsForTopic = this._topicSubs[topic];
    if (subsForTopic) { // Notify subscriptions
        for (var handle in subsForTopic) {
            if (subsForTopic.hasOwnProperty(handle)) {
                subsForTopic[handle].call(this, null);
            }
        }
    }
    delete this._topicPubs[topic];
};


/**
 * Listen for data changes at a particular location on this node
 *
 * <p>Your callback will be triggered for
 * the initial data and again whenever the data changes. Use {@link #off} to stop receiving updates.</p>
 *
 * <p>The callback is be called with this node as scope.</p>
 *
 * @param {String} location Publication location
 * @param {Function(data)} callback Called when fresh data is available at the location
 * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
 */
SceneJS.Scene.prototype.on = function (topic, callback) {
    var subsForTopic = this._topicSubs[topic];
    if (!subsForTopic) {
        subsForTopic = {};
        this._topicSubs[topic] = subsForTopic;
    }
    var handle = this._handleMap.addItem(); // Create unique handle
    subsForTopic[handle] = callback;
    this._handleTopics[handle] = topic;
    var pub = this._topicPubs[topic];
    if (pub) { // A publication exists, notify callback immediately
        callback.call(this, pub);
    }
    //else {
    if (topic == "rendered") {
        this._engine.branchDirty(this);
    }
//    if (topic == "tick") {
//        this._engine.scene.on("tick",callback);
//    }
    // }
    return handle;
};

/**
 * Unsubscribes from a publication on this node that was previously made with {@link #on}.
 * @param handle Publication handle
 */
SceneJS.Scene.prototype.off = function (handle) {
    var topic = this._handleTopics[handle];
    if (topic) {
        delete this._handleTopics[handle];
        var topicSubs = this._topicSubs[topic];
        if (topicSubs) {
            delete topicSubs[handle];
        }
        this._handleMap.removeItem(handle); // Release handle
        if (topic == "rendered") {
            this._engine.branchDirty(this);
        }
    }
//    else {
//        this._engine.scene.off(handle);
//    }
};

/**
 * Listens for exactly one data update at the specified location on this node, and then stops listening.
 * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
 * @param {String} location Data location to listen to
 * @param {Function(data)} callback Called when fresh data is available at the location
 */
SceneJS.Scene.prototype.once = function (topic, callback) {
    var self = this;
    var sub = this.on(topic,
        function (pub) {
            self.off(sub);
            callback(pub);
        });
};
;(function () {

    // The default state core singleton for {@link SceneJS.Line} nodes
    var defaultCore = {
        type:"style",
        stateId:SceneJS._baseStateId++,
        lineWidth:1.0
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.style = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures style parameters such as line width for subnodes
     * @extends SceneJS.Node
     */
    SceneJS.Style = SceneJS_NodeFactory.createNodeType("style");

    SceneJS.Style.prototype._init = function (params) {
        if (params.lineWidth != undefined) {
            this.setLineWidth(params.lineWidth);
        }
    };

    /**
     * Sets the line width
     *
     * Line width is initially 1.
     *
     * @param lineWidth The line width
     * @return {*}
     */
    SceneJS.Style.prototype.setLineWidth = function (lineWidth) {
        if (this._core.lineWidth != lineWidth) {
            this._core.lineWidth = lineWidth;
            this._engine.display.imageDirty = true;
        }
        return this;
    };

    /**
     * Gets the line width
     * Initial value will be 1.
     *
     * @return Boolean
     */
    SceneJS.Style.prototype.getLineWidth = function () {
        return this._core.lineWidth;
    };

    SceneJS.Style.prototype._compile = function (ctx) {
        this._engine.display.style = coreStack[stackLen++] = this._core;
        this._compileNodes(ctx);
        this._engine.display.style = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

})();;/**
 * @class Scene graph node which defines textures to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
 /*
    Compressed texture code based on Brandon Jones' Texture Format Tester
    http://toji.github.io/texture-tester/
 */
new (function () {

    // The default state core singleton for {@link SceneJS.Texture} nodes
    var defaultCore = {
        type: "texture",
        stateId: SceneJS._baseStateId++,
        empty: true,
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.texture = defaultCore;
            stackLen = 0;
        });

    var coreStack = [];
    var stackLen = 0;

    // Set up compressed texture constants
    var GL_CONSTANTS = null;
    var DDS_CONSTANTS = null;
    var PVR_CONSTANTS = null;

    var FLAGS = SceneJS.TEXTURE_FLAGS;

    /**
     * @class Scene graph node which defines one or more textures to apply to the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.TextureMap = SceneJS_NodeFactory.createNodeType("texture");

    SceneJS.TextureMap.prototype._init = function (params) {

        var self = this;

        if (this._core.useCount == 1) { // This node is the resource definer

            var applyFrom = params.applyFrom || "uv";
            if (applyFrom.substring(0,2) !== "uv") {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyFrom value is unsupported - should be 'uv<index>'");
            }
            var uvLayerIdx = 0;
            if (applyFrom !== "uv") {
                uvLayerIdx = parseInt(applyFrom.substring(2));
                if (isNaN(uvLayerIdx)) {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyFrom value invalid - should be 'uv<index>'");
                }
            }

            if (params.applyTo) {

                var applyTo = params.applyTo;

                if (applyTo != "baseColor" && // Colour map (deprecated)
                    applyTo != "color" && // Colour map
                    applyTo != "specular" && // Specular map
                    applyTo != "emit" && // Emission map
                    applyTo != "alpha" && // Alpha map
                    applyTo != "normals" && // Normal map
                    applyTo != "shine") { // Shininess map

                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyTo value is unsupported - " +
                        "should be either 'color', 'baseColor', 'specular' or 'normals'");
                }
            }

            if (params.blendMode) {
                if (params.blendMode != "add" && params.blendMode != "multiply" && params.blendMode != "over") {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture layer blendMode value is unsupported - " +
                        "should be either 'add' or 'multiply'");
                }
            }

            if (params.applyTo == "color") {
                params.applyTo = "baseColor";
            }

            var flags = FLAGS[params.applyTo || "baseColor"] | FLAGS[params.blendMode || "multiply"];

            SceneJS._apply({
                    waitForLoad: params.waitForLoad == undefined ? true : params.waitForLoad,
                    texture: null,
                    minFilter: params.minFilter,
                    magFilter: params.magFilter,
                    wrapS: params.wrapS,
                    wrapT: params.wrapT,
                    uvLayerIdx: uvLayerIdx,
                    isNormalMap: params.applyTo === "normals",
                    isAlphaMap: params.applyTo === "alpha",
                    flags: flags,
                    blendFactor: (params.blendFactor != undefined && params.blendFactor != null) ? params.blendFactor : 1.0,
                },
                this._core);
            this._initTexture(params.preloadColor);
            if (params.compressedImage) {
                this.setCompressedImage(params.compressedImage, params.containerFormat, params.compressedSrc);
            } else if (params.compressedSrc) {
                this._core.compressedSrc = params.compressedSrc;  // Can be used for context recovery if provided.
                var parseFunction;
                if (params.containerFormat === "dds") {
                    parseFunction = this._parseDDS;
                } else if (params.containerFormat === "pvr") {
                    parseFunction = this._parsePVR;
                } else {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "Compressed textures require containerFormat parameter to be 'dds' or 'pvr'");
                }
                SceneJS._loadBinary(params.compressedSrc, parseFunction.bind(this));
            } else if (params.image) { // Create from image
                this._setTextureImage(params.image);
            } else if (params.src) { // Load from URL
                this._core.src = params.src;
                this._loadTexture(params.src, params.preloadSrc);
            }

            this._core.webglRestored = getContextRestoredCallback(this, this._core, params.preloadColor, params.containerFormat);

        }
    };

    function getContextRestoredCallback(node, core, preloadColor, containerFormat) {
        return function () {
            if (core.compressedSrc) {
                node._initTexture(preloadColor);
                var parseFunction;
                if (containerFormat === "dds") {
                    parseFunction = node._parseDDS;
                } else if (containerFormat === "pvr") {
                    parseFunction = node._parsePVR;
                }
                SceneJS._loadBinary(core.compressedSrc, parseFunction.bind(this));
            } else if (core.image) {
                node._initTexture(preloadColor);
                node._setTextureImage(core.image);
            } else if (core.src) {
                node._initTexture(preloadColor);
                node._loadTexture(core.src);
            }
        };
    }

    SceneJS.TextureMap.prototype._initTexture = function (preloadColor) {
        var gl = this._engine.canvas.gl;

        preloadColor = preloadColor || { r: 0.57735, g: 0.57735, b: 0.57735 };
        preloadColor.a = preloadColor.a === undefined ? 1 : preloadColor.a;

        preloadColor = new Uint8Array([
            Math.floor(preloadColor.r * 255),
            Math.floor(preloadColor.g * 255),
            Math.floor(preloadColor.b * 255),
            Math.floor(preloadColor.a * 255)
        ]);

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, preloadColor);
        this._setCoreTexture(texture);
    };

    SceneJS.TextureMap.prototype._loadTexture = function (src, preloadSrc) {
        var self = this;
        var taskId = SceneJS_sceneStatusModule.taskStarted(this, "Loading texture");
        var image = new Image();
        var loaded = false;
        var taskFinished = false;

        if (preloadSrc) {
            var preloadImage = new Image();

            preloadImage.onload = function () {
                if (!loaded) {
                    self._setTextureImage(preloadImage);
                    SceneJS_sceneStatusModule.taskFinished(taskId);
                    taskFinished = true;
                    self._engine.display.imageDirty = true;
                }
            };

            preloadImage.src = preloadSrc;
        }

        image.onload = function () {
            self._setTextureImage(image);
            if (!taskFinished) {
                SceneJS_sceneStatusModule.taskFinished(taskId);
            }
            loaded = true;
            self._engine.display.imageDirty = true;
        };
        image.onerror = function () {
            SceneJS_sceneStatusModule.taskFailed(taskId);
        };
        image.src = src;
    };

    SceneJS.TextureMap.prototype._setTextureImage = function (image) {

        var gl = this._engine.canvas.gl;
        var core = this._core;
        var texture = core.texture && core.texture.texture ? core.texture.texture : gl.createTexture();

        gl.bindTexture(gl.TEXTURE_2D, texture);

        var maxTextureSize = SceneJS_configsModule.configs.maxTextureSize;
        if (maxTextureSize) {
            image = SceneJS._webgl.clampImageSize(image, maxTextureSize);
        }

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, SceneJS._webgl.ensureImageSizePowerOfTwo(image));

        this._setCoreTexture(texture);
        core.width = image.width;
        core.height = image.height;

        // Note(Tarek): Assumes mip maps are generated.
        this._gatherStats(image.width, image.height, image.width * image.height * 4);
    };

    SceneJS.TextureMap.prototype._setCompressedTextureImage = function (data, extension, internalFormat, width, height, mipMapLevels) {

        var gl = this._engine.canvas.gl;
        var core = this._core;
        var texture = core.texture && core.texture.texture ? core.texture.texture : gl.createTexture();

        var ext = SceneJS._getExtension(gl, extension);

        if (!ext) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Compressed texture format " + extension + "not available.");
        }

        gl.bindTexture(gl.TEXTURE_2D, texture);

        var offset = 0;

        this._core.width = width;
        this._core.height = height;
        this._core.mipMapLevels = mipMapLevels;
        this._core.compressed = true;

        var sizeFunction = GL_CONSTANTS.SIZE_FUNCTIONS[internalFormat];

        var levelWidth = width;
        var levelHeight = height;

        for (var i = 0; i < mipMapLevels; ++i) {
            var levelSize = sizeFunction(levelWidth, levelHeight);
            var image = new Uint8Array(data.buffer, data.byteOffset + offset, levelSize);

            gl.compressedTexImage2D(gl.TEXTURE_2D, i, internalFormat, levelWidth, levelHeight, 0, image);

            levelWidth = levelWidth / 2;
            levelHeight = levelHeight / 2;

            offset += levelSize;
        }

        this._setCoreTexture(texture);

        this._gatherStats(width, height, data.byteLength);
    };

    SceneJS.TextureMap.prototype._gatherStats = function (width, height, mem) {
        this._engine.stats.memory.textures += mem;

        var textureStats = this._engine.stats.textures;
        var dimensions = width + "x" + height

        var applyTo = this._getTextureTarget();
        var textureTargetStats = textureStats[applyTo] = textureStats[applyTo] || {};
        textureTargetStats[dimensions] = (textureTargetStats[dimensions] || 0) + 1;
        textureTargetStats.memory = (textureTargetStats.memory || 0) + mem;
    };

    SceneJS.TextureMap.prototype._setCoreTexture = function (texture) {
        var gl = this._engine.canvas.gl;

        var defaultMinFilter = this._core.compressed && this._core.mipMapLevels === 1 ? gl.LINEAR : gl.LINEAR_MIPMAP_NEAREST;

        this._core.texture = new SceneJS._webgl.Texture2D(gl, {
            texture: texture, // WebGL texture object
            minFilter: this._getGLOption("minFilter", defaultMinFilter),
            magFilter: this._getGLOption("magFilter", gl.LINEAR),
            wrapS: this._getGLOption("wrapS", gl.REPEAT),
            wrapT: this._getGLOption("wrapT", gl.REPEAT),
            compressed: this._core.compressed,
            update: null
        });

        if (this.destroyed) { // Node was destroyed while loading
            this._core.texture.destroy();
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype._getTextureTarget = function () {
        var flags = this._core.flags;
 
        if (flags & FLAGS.baseColor) {
            return "baseColor";
        }

        if (flags & FLAGS.normals) {
            return "normals";
        }

        if (flags & FLAGS.alpha) {
            return "alpha";
        }

        if (flags & FLAGS.specular) {
            return "specular";
        }

        if (flags & FLAGS.emit) {
            return "emit";
        }

        if (flags & FLAGS.shine) {
            return "shine";
        }
    };

    SceneJS.TextureMap.prototype._getGLOption = function (name, defaultVal) {
        var gl = this._engine.canvas.gl;
        var value = this._core[name];
        if (value == undefined) {
            return defaultVal;
        }
        var glName = SceneJS._webgl.enumMap[value];
        if (glName == undefined) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Unrecognised value for texture node property '" + name + "' value: '" + value + "'");
        }
        return gl[glName];
    };

    SceneJS.TextureMap.prototype._getOption = function (value, defaultVal) {
        return (value == undefined) ? defaultVal : value;
    };

    SceneJS.TextureMap.prototype.setSrc = function (src) {
        this._core.image = null;
        this._core.src = src;
        this._core.target = null;
        this._loadTexture(src);
    };

    SceneJS.TextureMap.prototype.setImage = function (image) {
        this._core.src = null;
        this._core.target = null;
        this._setTextureImage(image);
    };

    SceneJS.TextureMap.prototype.setCompressedImage = function (image, container, src) {
        this._core.src = null;
        this._core.image = null;
        this._core.target = null;
        this._core.compressedSrc = src;  // Can be used for context recovery if provided.
        if (container === "dds") {
            this._parseDDS(image);
        } else {
            this._parsePVR(image);
        }
    };

    SceneJS.TextureMap.prototype.setTarget = function (target) {
        if (target.type != "colorTarget" && target.type != "depthTarget") {
            console.log("Target node type not compatible: " + target.type);
            return;
        }
        delete this._core.src;
        this._core.target = target;
        this._core.src = null;
        this._core.image = null;
        this._core.texture = target._core.renderBuf.getTexture(); // TODO: what happens when the target is destroyed?
        this._core.texture.bufType = target._core.bufType;
        this._engine.display.imageDirty = true;
    };

    /**
     * Sets the texture's blend factor with respect to other active textures.
     * @param {number} blendFactor The blend factor, in range [0..1]
     */
    SceneJS.TextureMap.prototype.setBlendFactor = function (blendFactor) {
        this._core.blendFactor = blendFactor;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getBlendFactor = function () {
        return this._core.blendFactor;
    };

    SceneJS.TextureMap.prototype.setTranslate = function (t) {
        if (!this._core.translate) {
            this._core.translate = {x: 0, y: 0};
        }
        this._core.translate.x = t.x;
        this._core.translate.y = t.y;
        this._core._matrixDirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getTranslate = function () {
        return this._core.translate;
    };

    SceneJS.TextureMap.prototype.setScale = function (s) {
        if (!this._core.scale) {
            this._core.scale = {x: 0, y: 0};
        }
        this._core.scale.x = s.x;
        this._core.scale.y = s.y;
        this._core._matrixDirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getScale = function () {
        return this._core.scale;
    };

    SceneJS.TextureMap.prototype.setRotate = function (angle) {
        this._core.rotate = angle;
        this._core._matrixDirty = true;
        this._engine.display.imageDirty = true;
    };

    SceneJS.TextureMap.prototype.getRotate = function () {
        return this._core.rotate;
    };

    SceneJS.TextureMap.prototype.getMatrix = function () {
        if (this._core._matrixDirty) {
            this._core.buildMatrix.call(this.core)()
        }
        return this.core.matrix;
    };

    SceneJS.TextureMap.prototype._compile = function (ctx) {
        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("texture");
            this.__core.transparent = false;
        }
        var parentCore = this._engine.display.texture;
        if (!this._core.empty) {
            this.__core.layers = (parentCore && parentCore.layers) ? parentCore.layers.concat([this._core]) : [this._core];
            this.__core.transparent = this._core.isAlphaMap || parentCore.transparent;
        }
        this._makeHash(this.__core);
        coreStack[stackLen++] = this.__core;
        this._engine.display.texture = this.__core;
        this._compileNodes(ctx);
        this._engine.display.texture = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.TextureMap.prototype._makeHash = function (core) {
        var hash;
        if (core.layers && core.layers.length > 0) {
            var layers = core.layers;
            var hashParts = [];
            var texLayer;
            for (var i = 0, len = layers.length; i < len; i++) {
                texLayer = layers[i];
                hashParts.push("/");
                hashParts.push(texLayer.uvLayerIdx);
                hashParts.push("/");
                hashParts.push(texLayer.flags);
                if (texLayer.matrix) {
                    hashParts.push("/anim");
                }
                if (texLayer.compressed) {
                    hashParts.push("/comp");
                }
            }
            hash = hashParts.join("");
        } else {
            hash = "";
        }
        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.TextureMap.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last core user
            if (this._core.texture && !this._core.target) { // Don't wipe out target texture
                this._core.texture.destroy();
                this._core.texture = null;
            }
            this._engine.stats.memory.textures--;
        }
        if (this._core) {
            this._engine._coreFactory.putCore(this._core);
        }
    };

    SceneJS.TextureMap.prototype._parseDDS = function(buffer) {

        if (!DDS_CONSTANTS) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "DXT compressed textures not supported on this platform.");
        }

        var header = new Uint32Array(buffer, 0, DDS_CONSTANTS.HEADER_LENGTH);

        if (header[DDS_CONSTANTS.MAGIC_NUMBER_INDEX] != DDS_CONSTANTS.MAGIC_NUMBER) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Invalid DDS File: Magic number invalid.");
        }

        if (header[DDS_CONSTANTS.PIXEL_FORMAT_FLAGS_INDEX] & DDS_CONSTANTS.PIXEL_FORMAT_FOURCC_FLAG === 0) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Invalid DDS File: FourCC required.");
        }

        var internalFormat = DDS_CONSTANTS.FOURCC_MAP[header[DDS_CONSTANTS.PIXEL_FORMAT_FOURCC_INDEX]];
        var extension = DDS_CONSTANTS.EXTENSION_MAP[header[DDS_CONSTANTS.PIXEL_FORMAT_FOURCC_INDEX]];

        var mipMapLevels = 1;
        if (header[DDS_CONSTANTS.FLAGS_INDEX] & DDS_CONSTANTS.MIPMAPCOUNT_FLAG) {
            mipMapLevels = header[DDS_CONSTANTS.MIPMAPCOUNT_INDEX];
        }

        var width = header[DDS_CONSTANTS.WIDTH_INDEX];
        var height = header[DDS_CONSTANTS.HEIGHT_INDEX];

        var data = new Uint8Array(buffer, DDS_CONSTANTS.DATA_OFFSET);

        this._setCompressedTextureImage(data, extension, internalFormat, width, height, mipMapLevels);
    }

    SceneJS.TextureMap.prototype._parsePVR = function(buffer) {

        var header = new Uint32Array(buffer, 0, PVR_CONSTANTS.HEADER_LENGTH);

        if (header[PVR_CONSTANTS.MAGIC_NUMBER_INDEX] != PVR_CONSTANTS.MAGIC_NUMBER) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Invalid PVR File: Magic number invalid.");
        }

        var pvrFormat = header[PVR_CONSTANTS.PIXEL_FORMAT_INDEX]

        var extension = PVR_CONSTANTS.EXTENSION_MAP[pvrFormat];
        var internalFormat = PVR_CONSTANTS.FORMAT_MAP[pvrFormat];

        var mipMapLevels = header[PVR_CONSTANTS.MIPMAPCOUNT_INDEX];

        var width = header[PVR_CONSTANTS.WIDTH_INDEX];
        var height = header[PVR_CONSTANTS.HEIGHT_INDEX];

        var dataOffset = PVR_CONSTANTS.HEADER_SIZE + header[PVR_CONSTANTS.METADATA_SIZE_INDEX];

        var data = new Uint8Array(buffer, dataOffset);

        this._setCompressedTextureImage(data, extension, internalFormat, width, height, mipMapLevels);
    }

    // Builds a numeric code for a given fourCC DDS file string
    function parseFourCC(value) {
      return value.charCodeAt(0) +
            (value.charCodeAt(1) << 8) +
            (value.charCodeAt(2) << 16) +
            (value.charCodeAt(3) << 24);
    }

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    function pvrtc2bppSize(width, height) {
        var width = Math.max(width, 16);
        var height = Math.max(height, 8);

        return width * height / 4;
    }

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    function pvrtc4bppSize(width, height) {
        var width = Math.max(width, 8);
        var height = Math.max(height, 8);

        return width * height / 2;
    }

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_etc1/
    // Also size for RGB ATC
    function dxt1etc1Size(width, height) {
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    }

    // https://www.khronos.org/registry/webgl/extensions/WEBGL_compressed_texture_s3tc/
    // Also size for both alpha ATC formats
    function dxt35Size(width, height) {
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    }

    (function() {
        var canvas = document.createElement("canvas");

        if (!canvas) {
            return;
        }

        var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

        if (!gl) {
            return;
        }

        GL_CONSTANTS = getGLConstants(gl);
        DDS_CONSTANTS = getDDSConstants();
        PVR_CONSTANTS = getPVRConstants();

        function getGLConstants(gl) {
            var pvrtc = SceneJS._getExtension(gl, "WEBGL_compressed_texture_pvrtc");
            var etc1 = SceneJS._getExtension(gl, "WEBGL_compressed_texture_etc1");
            var dxt = SceneJS._getExtension(gl, "WEBGL_compressed_texture_s3tc");

            var CONSTANTS = {
                PVRTC_SUPPORTED: !!pvrtc,
                ETC1_SUPPORTED: !!etc1,
                DXT_SUPPORTED: !!dxt,
                FORMAT_ENUMS: {},
                SIZE_FUNCTIONS: {}
            }

            if (CONSTANTS.PVRTC_SUPPORTED) {
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = pvrtc.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = pvrtc.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = pvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;

                CONSTANTS.SIZE_FUNCTIONS[pvrtc.COMPRESSED_RGB_PVRTC_2BPPV1_IMG] = pvrtc2bppSize;
                CONSTANTS.SIZE_FUNCTIONS[pvrtc.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG] = pvrtc2bppSize;
                CONSTANTS.SIZE_FUNCTIONS[pvrtc.COMPRESSED_RGB_PVRTC_4BPPV1_IMG] = pvrtc4bppSize;
                CONSTANTS.SIZE_FUNCTIONS[pvrtc.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG] = pvrtc4bppSize;
            }

            if (CONSTANTS.ETC1_SUPPORTED) {
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_ETC1_WEBGL = etc1.COMPRESSED_RGB_ETC1_WEBGL;

                CONSTANTS.SIZE_FUNCTIONS[etc1.COMPRESSED_RGB_ETC1_WEBGL] = dxt1etc1Size;
            }

            if (CONSTANTS.DXT_SUPPORTED) {
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_S3TC_DXT1_EXT = dxt.COMPRESSED_RGB_S3TC_DXT1_EXT;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT3_EXT = dxt.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT5_EXT = dxt.COMPRESSED_RGBA_S3TC_DXT5_EXT;

                CONSTANTS.SIZE_FUNCTIONS[dxt.COMPRESSED_RGB_S3TC_DXT1_EXT] = dxt1etc1Size;
                CONSTANTS.SIZE_FUNCTIONS[dxt.COMPRESSED_RGBA_S3TC_DXT3_EXT] = dxt35Size;
                CONSTANTS.SIZE_FUNCTIONS[dxt.COMPRESSED_RGBA_S3TC_DXT5_EXT] = dxt35Size;
            }

            return CONSTANTS;
        }

        function getDDSConstants() {

            // http://msdn.microsoft.com/en-us/library/bb943991.aspx/
            var CONSTANTS = {
                MAGIC_NUMBER: 0x20534444,
                MIPMAPCOUNT_FLAG: 0x20000,
                PIXEL_FORMAT_FOURCC_FLAG: 0x4,

                HEADER_LENGTH: 31,

                MAGIC_NUMBER_INDEX: 0,

                SIZE_INDEX: 1,
                FLAGS_INDEX: 2,
                HEIGHT_INDEX: 3,
                WIDTH_INDEX: 4,

                MIPMAPCOUNT_INDEX: 7,
                
                PIXEL_FORMAT_FLAGS_INDEX: 20,
                PIXEL_FORMAT_FOURCC_INDEX: 21,

                DATA_OFFSET: 128,

                FOURCC_MAP: {},
                EXTENSION_MAP: {}
            };

            if (GL_CONSTANTS.DXT_SUPPORTED) {
                var dxt1 = parseFourCC("DXT1");
                var dxt3 = parseFourCC("DXT3");
                var dxt5 = parseFourCC("DXT5");

                CONSTANTS.FOURCC_MAP[dxt1] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_S3TC_DXT1_EXT;
                CONSTANTS.FOURCC_MAP[dxt3] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                CONSTANTS.FOURCC_MAP[dxt5] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT5_EXT;
                
                CONSTANTS.EXTENSION_MAP[dxt1] = "WEBGL_compressed_texture_s3tc";
                CONSTANTS.EXTENSION_MAP[dxt3] = "WEBGL_compressed_texture_s3tc";
                CONSTANTS.EXTENSION_MAP[dxt5] = "WEBGL_compressed_texture_s3tc";
            }

            if (GL_CONSTANTS.ETC1_SUPPORTED) {
                var etc1 = parseFourCC("ETC1");

                CONSTANTS.FOURCC_MAP[etc1] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_ETC1_WEBGL;

                CONSTANTS.EXTENSION_MAP[etc1] = "WEBGL_compressed_texture_etc1";
            }

            return CONSTANTS;
        }

        function getPVRConstants() {

            // http://cdn.imgtec.com/sdk-documentation/PVR+File+Format.Specification.pdf
            var CONSTANTS = {
                MAGIC_NUMBER: 0x03525650,
                HEADER_LENGTH: 13,
                HEADER_SIZE: 52,
                MAGIC_NUMBER_INDEX: 0,
                PIXEL_FORMAT_INDEX: 2,
                HEIGHT_INDEX: 6,
                WIDTH_INDEX: 7,
                MIPMAPCOUNT_INDEX: 11,
                METADATA_SIZE_INDEX: 12,
                EXTENSION_MAP: {
                    0: "WEBGL_compressed_texture_pvrtc",
                    1: "WEBGL_compressed_texture_pvrtc",
                    2: "WEBGL_compressed_texture_pvrtc",
                    3: "WEBGL_compressed_texture_pvrtc",
                    6: "WEBGL_compressed_texture_etc1",
                    7: "WEBGL_compressed_texture_s3tc",
                    9: "WEBGL_compressed_texture_s3tc",
                    11: "WEBGL_compressed_texture_s3tc"
                },
                FORMAT_MAP: {}
            };

            if (GL_CONSTANTS.PVRTC_SUPPORTED) {
                CONSTANTS.FORMAT_MAP[0] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                CONSTANTS.FORMAT_MAP[1] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
                CONSTANTS.FORMAT_MAP[2] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                CONSTANTS.FORMAT_MAP[3] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            }

            if (GL_CONSTANTS.ETC1_SUPPORTED) {
                CONSTANTS.FORMAT_MAP[6] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_ETC1_WEBGL;
            }

            if (GL_CONSTANTS.DXT_SUPPORTED) {
                CONSTANTS.FORMAT_MAP[7] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGB_S3TC_DXT1_EXT;
                CONSTANTS.FORMAT_MAP[9] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                CONSTANTS.FORMAT_MAP[11] = GL_CONSTANTS.FORMAT_ENUMS.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            }

            return CONSTANTS;
        }
    })();


})();
;/**
 * @class Scene graph node which defines fresnels to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
new (function () {

    var FLAGS = SceneJS.TEXTURE_FLAGS;

    // The default state core singleton for {@link SceneJS.Fresnel} nodes
    var defaultCore = {
        type: "fresnel",
        stateId: SceneJS._baseStateId++,
        power: 1.0,
        centerColor: new Float32Array([ 1.0, 1.0, 1.0, 1.0 ]),
        edgeColor: new Float32Array([ 0.0, 0.0, 0.0, 0.0 ]),
        blendFactor: 1.0,
        blendMode: FLAGS.multiply,
        empty: true,
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.fresnel = defaultCore;
            stackLen = 0;
        });

    var coreStack = [];
    var stackLen = 0;

    /**
     * @class Scene graph node which defines a fresnel to apply to the {@link SceneJS.Geometry} nodes in its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Fresnel = SceneJS_NodeFactory.createNodeType("fresnel");

    SceneJS.Fresnel.prototype._init = function (params) {

        if (this._core.useCount == 1) { // This node is the resource definer

            if (params.applyTo) {
                if (params.applyTo != "color" &&
                    params.applyTo != "specular" &&
                    params.applyTo != "alpha" &&
                    params.applyTo != "reflect" &&
                    params.applyTo != "emit" &&
                    params.applyTo != "fragment") {

                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "fresnel applyTo value is unsupported - should be either 'color', 'specular', 'alpha', 'reflect', 'emit' or 'fragment'");
                }
            }

            this._core.applyTo = params.applyTo;

            if (params.blendMode) {
                if (params.blendMode != "add" && params.blendMode != "multiply" && params.blendMode != "over") {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture layer blendMode value is unsupported - " +
                        "should be either 'add' or 'multiply'");
                }
            }

            this._core.blendMode = FLAGS[params.blendMode || "multiply"];

            this._core.centerColor = new Float32Array(defaultCore.centerColor);
            this._core.edgeColor = new Float32Array(defaultCore.edgeColor);
            this._core.power = defaultCore.power;

            if (params.centerBias != undefined) {
                this.setCenterBias(params.centerBias);
            }
            if (params.edgeBias != undefined) {
                this.setEdgeBias(params.edgeBias);
            }
            if (params.power != undefined) {
                this.setPower(params.power);
            }
            if (params.centerColor != undefined) {
                this.setCenterColor(params.centerColor);
            }
            if (params.edgeColor != undefined) {
                this.setEdgeColor(params.edgeColor);
            }
        }
    };

    SceneJS.Fresnel.prototype.getApplyTo = function () {
        return this._core.applyTo;
    };

    SceneJS.Fresnel.prototype.setCenterBias = function (centerBias) {
        this._core.centerColor[3] = (centerBias !== undefined) ? centerBias : defaultCore.centerColor[3];
        this._engine.display.imageDirty = true;
    };

    SceneJS.Fresnel.prototype.getCenterBias = function () {
        return this._core.centerColor[3];
    };

    SceneJS.Fresnel.prototype.setEdgeBias = function (edgeBias) {
        this._core.edgeColor[3] = (edgeBias !== undefined) ? edgeBias : defaultCore.edgeColor[3];
        this._engine.display.imageDirty = true;
    };

    SceneJS.Fresnel.prototype.getEdgeBias = function () {
        return this._core.edgeColor[3];
    };

    SceneJS.Fresnel.prototype.setPower = function (power) {
        this._core.power = (power !== undefined) ? power : defaultCore.power;
        this._engine.display.imageDirty = true;
    };

    SceneJS.Fresnel.prototype.getPower = function () {
        return this._core.power;
    };

    SceneJS.Fresnel.prototype.setCenterColor = function (color) {
        var defaultCenterColor = defaultCore.centerColor;
        this._core.centerColor[0] = color.r != undefined ? color.r : defaultCenterColor[0];
        this._core.centerColor[1] = color.g != undefined ? color.g : defaultCenterColor[1];
        this._core.centerColor[2] = color.b != undefined ? color.b : defaultCenterColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Fresnel.prototype.getCenterColor = function () {
        return {
            r:this._core.centerColor[0],
            g:this._core.centerColor[1],
            b:this._core.centerColor[2]
        };
    };

    SceneJS.Fresnel.prototype.setEdgeColor = function (color) {
        var defaultEdgeColor = defaultCore.edgeColor;
        this._core.edgeColor[0] = color.r != undefined ? color.r : defaultEdgeColor[0];
        this._core.edgeColor[1] = color.g != undefined ? color.g : defaultEdgeColor[1];
        this._core.edgeColor[2] = color.b != undefined ? color.b : defaultEdgeColor[2];
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.Fresnel.prototype.getEdgeColor = function () {
        return {
            r:this._core.edgeColor[0],
            g:this._core.edgeColor[1],
            b:this._core.edgeColor[2]
        };
    };

    SceneJS.Fresnel.prototype._compile = function (ctx) {

        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("fresnel");
            this.__core.transparent = false;
        }

        var parentCore = this._engine.display.fresnel;

        if (!this._core.empty) {
            this.__core.diffuse = this._core.applyTo == "color" ? this._core : parentCore.diffuse;
            this.__core.specular = this._core.applyTo == "specular" ? this._core : parentCore.specular;
            this.__core.alpha = this._core.applyTo == "alpha" ? this._core : parentCore.alpha;
            this.__core.reflect = this._core.applyTo == "reflect" ? this._core : parentCore.reflect;
            this.__core.emit = this._core.applyTo == "emit" ? this._core : parentCore.emit;
            this.__core.fragment = this._core.applyTo == "fragment" ? this._core : parentCore.fragment;
            this.__core.transparent = this._core.applyTo == "alpha" || parentCore.transparent;
        }

        this._makeHash(this.__core);

        coreStack[stackLen++] = this.__core;

        this._engine.display.fresnel = this.__core;
        this._compileNodes(ctx);
        this._engine.display.fresnel = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Fresnel.prototype._makeHash = function (core) {
        var hash = [];
        if (core.diffuse) {
            hash.push("d" + core.diffuse.blendMode + ";")
        }
        if (core.specular) {
            hash.push("s" + core.specular.blendMode + ";")
        }
        if (core.alpha) {
            hash.push("a" + core.alpha.blendMode + ";")
        }
        if (core.reflect) {
            hash.push("r" + core.reflect.blendMode + ";")
        }
        if (core.emit) {
            hash.push("e" + core.emit.blendMode + ";")
        }
        if (core.fragment) {
            hash.push("f" + core.fragment.blendMode + ";")
        }
        hash.push(core.blendMode + ";");
        hash = hash.join("");
        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.Fresnel.prototype._destroy = function () {
        if (this._core) {
            this._engine._coreFactory.putCore(this._core);
        }
    };

})();
;(function () {

    // The default state core singleton for {@link SceneJS.ColorBuf} nodes
    var defaultCore = {
        type: "cubemap",
        stateId: SceneJS._baseStateId++,
        empty: true,
        texture: null,
        hash: ""
    };

    var coreStack = [];
    var stackLen = 0;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.cubemap = defaultCore;
            stackLen = 0;
        });

    /**
     * @class Scene graph node which configures the color buffer for its subgraph
     * @extends SceneJS.Node
     */
    SceneJS.Reflect = SceneJS_NodeFactory.createNodeType("reflect");

    SceneJS.Reflect.prototype._init = function (params) {
        if (this._core.useCount == 1) { // This node is first to reference the state core, so sets it up
            this._core.hash = "y";

            if (params.blendMode) {
                if (params.blendMode != "add" && params.blendMode != "multiply") {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                            "reflection blendMode value is unsupported - " +
                            "should be either 'add' or 'multiply'");
                }
            }

            this._core.blendMode = params.blendMode || "multiply";
            this._core.intensity = (params.intensity != undefined && params.intensity != null) ? params.intensity : 1.0;
            this._core.applyTo = "reflect";

            var self = this;

            var gl = this._engine.canvas.gl;
            var texture = gl.createTexture();

            var faces = [
                gl.TEXTURE_CUBE_MAP_POSITIVE_X,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
                gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
                gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
            ];

            var images = new Array(6);
            var taskId = SceneJS_sceneStatusModule.taskStarted(this, "Loading reflection texture");
            var loadFailed = false;

            var imagesToLoad = 6;
            for (var i = 0; i < faces.length; i++) {

                var image = new Image();

                image.onload = (function(index) {

                    var _image = image;

                    return function () {

                        if (loadFailed) {
                            return;
                        }

                        images[index] = _image;

                        if (--imagesToLoad === 0) {

                            gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
                            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

                            for (var j = 0, lenj = images.length; j < lenj; j++) {
                                gl.texImage2D(faces[j], 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,
                                    SceneJS._webgl.ensureImageSizePowerOfTwo(images[j]));
                            }

                            self._core.texture = new SceneJS._webgl.Texture2D(gl, {
                                texture: texture,
                                target: gl.TEXTURE_CUBE_MAP,
                                minFilter: gl.LINEAR,
                                magFilter: gl.LINEAR,
                                wrapS: gl.CLAMP_TO_EDGE,
                                wrapT: gl.CLAMP_TO_EDGE
                            });

                            SceneJS_sceneStatusModule.taskFinished(taskId);

                            self._engine.display.imageDirty = true;
                        }
                    };
                })(i);

                image.onerror = function () {
                    loadFailed = true;
                    SceneJS_sceneStatusModule.taskFailed(taskId);
                };

                image.src = params.src[i];
            }
        }
    };

    SceneJS.Reflect.prototype._compile = function (ctx) {
        if (!this.__core) {
            this.__core = this._engine._coreFactory.getCore("cubemap");
        }
        var parentCore = this._engine.display.cubemap;
        if (!this._core.empty) {
            this.__core.layers = (parentCore && parentCore.layers) ? parentCore.layers.concat([this._core]) : [this._core];
        }
        this._makeHash(this.__core);
        coreStack[stackLen++] = this.__core;
        this._engine.display.cubemap = this.__core;
        this._compileNodes(ctx);
        this._engine.display.cubemap = (--stackLen > 0) ? coreStack[stackLen - 1] : defaultCore;
        coreStack[stackLen] = null; // Release memory
    };

    SceneJS.Reflect.prototype._makeHash = function (core) {
        var hash;
        if (core.layers && core.layers.length > 0) {
            var layers = core.layers;
            var hashParts = [];
            var texLayer;
            for (var i = 0, len = layers.length; i < len; i++) {
                texLayer = layers[i];
                hashParts.push("/");
                hashParts.push(texLayer.applyTo);
                hashParts.push("/");
                hashParts.push(texLayer.blendMode);
            }
            hash = hashParts.join("");
        } else {
            hash = "";
        }
        if (core.hash != hash) {
            core.hash = hash;
        }
    };

    SceneJS.Reflect.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last resource user
            if (this._core.texture) {
                this._core.texture.destroy();
                this._core.texture = null;
            }
        }
        if (this._core) {
            this._engine._coreFactory.putCore(this._core);
        }
    }

})();;/**
 * @class Scene graph node which defines textures to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
new (function () {

    // The default state core singleton for {@link SceneJS.RegionMap} nodes
    var defaultCore = {
        type: "regionMap",
        stateId: SceneJS._baseStateId++,
        empty: true,
        texture: null,
        regionColor:[ -1.0, -1.0, -1.0 ],    // Highlight off by default
        highlightFactor:[ 1.5, 1.5, 0.0 ],
        hideAlpha: 0.0,
        regionData: [],
        mode: "info",
        hash: ""
    };

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function (params) {
            params.engine.display.regionMap = defaultCore;
            stackLen = 0;
        });

    var stackLen = 0;
    var validModes = {
        info: true,
        highlight: true,
        hide: true,
        isolate: true
    };

    /**
     * @class Scene graph node which defines a color-coded region map
     * @extends SceneJS.Node
     */
    SceneJS.RegionMap = SceneJS_NodeFactory.createNodeType("regionMap");

    SceneJS.RegionMap.prototype._init = function (params) {

        var self = this;

        if (this._core.useCount == 1) { // This node is the resource definer

            SceneJS._apply({
                    regionMap: null
                },
                this._core);

            // Index of UV layer for this region map

            var applyFrom = params.applyFrom || "uv";
            if (applyFrom.substring(0,2) !== "uv") {
                throw SceneJS_error.fatalError(
                    SceneJS.errors.NODE_CONFIG_EXPECTED,
                    "texture applyFrom value is unsupported - should be 'uv<index>'");
            }
            var uvLayerIdx = 0;
            if (applyFrom !== "uv") {
                uvLayerIdx = applyFrom.substring(2);
                if (isNaN(uvLayerIdx)) {
                    throw SceneJS_error.fatalError(
                        SceneJS.errors.NODE_CONFIG_EXPECTED,
                        "texture applyFrom value invalid - should be 'uv<index>'");
                }
            }
            this._core.uvLayerIdx = uvLayerIdx;

            if (params.src) {

                // Load from URL

                this._initTexture();
                this._core.src = params.src;
                this._loadTexture(params.src);

            } else if (params.image) {

                // Create from image

                this._initTexture(params.preloadColor);
                this._core.image = params.image;
                this._setTextureImage(params.image);
            }

            this._core.webglRestored = function () {

                if (self._core.image) {
                    self._initTexture();
                    self._setTextureImage(self._core.image);

                } else if (self._core.src) {
                    self._initTexture();
                    self._loadTexture(self._core.src);

                } else if (self._core.target) {
                    // Don't need to rebind anything for targets
                }
            };

            this.setRegionColor(params.regionColor);
            this.setHighlightFactor(params.highlightFactor);
            this.setHideAlpha(params.hideAlpha);
            this.setRegionData(params.regionData);
            this.setMode(params.mode);
        }
    };

    SceneJS.RegionMap.prototype._initTexture = function () {

        var gl = this._engine.canvas.gl;

        // Keep this for a little bit for debugging
        var preloadColor = {r: 0.57735, g: 0.57735, b: 0.57735};
        preloadColor.a = preloadColor.a === undefined ? 1 : preloadColor.a;
        preloadColor = new Uint8Array([
            Math.floor(preloadColor.r * 255),
            Math.floor(preloadColor.g * 255),
            Math.floor(preloadColor.b * 255),
            Math.floor(preloadColor.a * 255)
        ]);

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, preloadColor);
        this._setCoreTexture(texture);
    };

    SceneJS.RegionMap.prototype._loadTexture = function (src) {
        var self = this;
        var taskId = SceneJS_sceneStatusModule.taskStarted(this, "Loading texture");
        var image = new Image();
        var loaded = false;
        var taskFinished = false;

        image.onload = function () {
            self._setTextureImage(image);
            if (!taskFinished) {
                SceneJS_sceneStatusModule.taskFinished(taskId);
            }
            loaded = true;
            self._engine.display.imageDirty = true;
        };
        image.onerror = function () {
            SceneJS_sceneStatusModule.taskFailed(taskId);
        };
        this._fetchImage(image, src);
    };

    SceneJS.RegionMap.prototype._fetchImage = function (image, src) {
        if (src.indexOf("data") == 0) {  // Image data
            image.src = src;
        } else { // Image file
            image.crossOrigin = "Anonymous";
            image.src = src;
        }
    };

    SceneJS.RegionMap.prototype._setTextureImage = function (image) {
        var gl = this._engine.canvas.gl;
        var texture = this._core.texture ? this._core.texture.texture : gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, SceneJS._webgl.ensureImageSizePowerOfTwo(image));
        this._core.image = image;
        this._setCoreTexture(texture);
    };

    SceneJS.RegionMap.prototype._setCoreTexture = function (texture) {
        var gl = this._engine.canvas.gl;

        this._core.texture = new SceneJS._webgl.Texture2D(gl, {
            texture: texture, // WebGL texture object
            minFilter: this._getGLOption("minFilter", gl.NEAREST_MIPMAP_NEAREST),  // Don't want any interpolation
            magFilter: this._getGLOption("magFilter", gl.NEAREST),
            wrapS: this._getGLOption("wrapS", gl.REPEAT),
            wrapT: this._getGLOption("wrapT", gl.REPEAT),
            isDepth: this._getOption(this._core.isDepth, false),
            depthMode: this._getGLOption("depthMode", gl.LUMINANCE),
            depthCompareMode: this._getGLOption("depthCompareMode", gl.COMPARE_R_TO_TEXTURE),
            depthCompareFunc: this._getGLOption("depthCompareFunc", gl.LEQUAL),
            flipY: this._getOption(this._core.flipY, true),
            width: this._getOption(this._core.width, 1),
            height: this._getOption(this._core.height, 1),
            internalFormat: this._getGLOption("internalFormat", gl.ALPHA),
            sourceFormat: this._getGLOption("sourceFormat", gl.ALPHA),
            sourceType: this._getGLOption("sourceType", gl.UNSIGNED_BYTE),
            update: null
        });

        if (this.destroyed) { // Node was destroyed while loading
            this._core.texture.destroy();
        }

        this._engine.display.imageDirty = true;
    };

    SceneJS.RegionMap.prototype._getGLOption = function (name, defaultVal) {
        var gl = this._engine.canvas.gl;
        var value = this._core[name];
        if (value == undefined) {
            return defaultVal;
        }
        var glName = SceneJS._webgl.enumMap[value];
        if (glName == undefined) {
            throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "Unrecognised value for texture node property '" + name + "' value: '" + value + "'");
        }
        return gl[glName];
    };

    SceneJS.RegionMap.prototype._getOption = function (value, defaultVal) {
        return (value == undefined) ? defaultVal : value;
    };

    SceneJS.RegionMap.prototype.setSrc = function (src) {
        this._core.image = null;
        this._core.src = src;
        this._core.target = null;
        this._loadTexture(src);
    };

    SceneJS.RegionMap.prototype.setImage = function (image) {
        this._core.image = image;
        this._core.src = null;
        this._core.target = null;
        this._setTextureImage(image);
    };

    SceneJS.RegionMap.prototype.setTarget = function (target) {
        if (target.type != "colorTarget" && target.type != "depthTarget") {
            console.log("Target node type not compatible: " + target.type);
            return;
        }
        delete this._core.src;
        this._core.target = target;
        this._core.src = null;
        this._core.image = null;
        this._core.texture = target._core.renderBuf.getTexture(); // TODO: what happens when the target is destroyed?
        this._core.texture.bufType = target._core.bufType;
        this._engine.display.imageDirty = true;
    };

    SceneJS.RegionMap.prototype.setRegionColor = function (color) {
        var defaultHighlightColor = defaultCore.regionColor;
        this._core.regionColor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultHighlightColor[0],
            color.g != undefined && color.g != null ? color.g : defaultHighlightColor[1],
            color.b != undefined && color.b != null ? color.b : defaultHighlightColor[2]
        ] : defaultCore.regionColor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.RegionMap.prototype.setHighlightFactor = function (color) {
        var defaultHighlightFactor = defaultCore.highlightFactor;
        this._core.highlightFactor = color ? [
            color.r != undefined && color.r != null ? color.r : defaultHighlightFactor[0],
            color.g != undefined && color.g != null ? color.g : defaultHighlightFactor[1],
            color.b != undefined && color.b != null ? color.b : defaultHighlightFactor[2]
        ] : defaultCore.highlightFactor;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.RegionMap.prototype.setHideAlpha = function (hideAlpha) {
        this._core.hideAlpha = hideAlpha != undefined ? hideAlpha : defaultCore.hideAlpha;
        this._engine.display.imageDirty = true;
        return this;
    };

    SceneJS.RegionMap.prototype.setMode = function (mode) {
        var wasTransparent = !!this._core.transparent;
        this._core.mode = mode && validModes[mode] ? mode : defaultCore.mode;
        this._core.transparent = this._core.mode === "hide" || this._core.mode === "isolate";
        if (wasTransparent !== this._core.transparent) {
            this._engine.display.stateOrderDirty = true;
        }
        this._engine.branchDirty(this);
        this._engine.display.imageDirty = true;
        this._core.hash = "reg-" + mode;
        return this;
    };

    SceneJS.RegionMap.prototype.setRegionData = function (data) {
        this._core.regionData = data ? data : defaultCore.regionData;
        return this;
    };


    SceneJS.RegionMap.prototype._compile = function (ctx) {
        var parentCore = this._engine.display.regionMap;
        this._engine.display.regionMap = this._core;
        this._compileNodes(ctx);
        this._engine.display.regionMap = parentCore;
    };

    SceneJS.RegionMap.prototype._destroy = function () {
        if (this._core.useCount == 1) { // Last core user
            if (this._core.texture && !this._core.target) { // Don't wipe out target texture
                this._core.texture.destroy();
                this._core.texture = null;
            }
        }
    };

})();;/**
 * @class Scene graph node which defines the modelling transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.XForm = SceneJS_NodeFactory.createNodeType("xform");

SceneJS.XForm.prototype._init = function (params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        this.setElements(params.elements);

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.XForm.prototype.getModelMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, XForm, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.XForm.prototype.getWorldMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply( [], this._core.mat);
};


SceneJS.XForm.prototype.setElements = function (elements) {

    elements = elements || mat4.create();

    if (elements.length != 16) {
        throw SceneJS_error.fatalError(
            SceneJS.errors.ILLEGAL_NODE_CONFIG,
            "SceneJS.XForm elements should number 16");
    }

    var core = this._core;

    if (!core.matrix) {
        core.matrix = elements;

    } else {

        for (var i = 0; i < 16; i++) {
            core.matrix[i] = elements[i];
        }
    }

    core.setDirty();

    this._engine.display.imageDirty = true;

    return this;
};

SceneJS.XForm.prototype._compile = function (ctx) {
    var core = this._core;
    var i, len;

    core.numCores = 0;
    for (i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.XForm.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.XForm.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;
/**
 * @class Scene graph node which defines a modelling transform matrix to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.Matrix = SceneJS_NodeFactory.createNodeType("matrix");

SceneJS.Matrix.prototype._init = function(params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        this.setElements(params.elements);

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.Matrix.prototype.getModelMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, matrix, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.Matrix.prototype.getWorldMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply( [], this._core.mat);
};

/**
 * Sets the matrix elements
 * @type {Function}
 */
SceneJS.Matrix.prototype.setMatrix = function(elements) {

    elements = elements || mat4.create();

    if (elements.length != 16) {
        throw SceneJS_error.fatalError(
                SceneJS.errors.ILLEGAL_NODE_CONFIG,
                "SceneJS.Matrix elements should number 16");
    }

    var core = this._core;

    if (!core.matrix) {
        core.matrix = elements;

    } else {

        for (var i = 0; i < 16; i++) {
            core.matrix[i] = elements[i];
        }
    }

    core.setDirty();

    this._engine.display.imageDirty = true;

    return this;
};

/**
 * Sets the matrix elements
 * @deprecated
 * @type {Function}
 */
SceneJS.Matrix.prototype.setElements = SceneJS.Matrix.prototype.setMatrix;

SceneJS.Matrix.prototype._compile = function (ctx) {
    var core = this._core;
    core.numCores = 0;
    for (var i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.Matrix.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.Matrix.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;/**
 * @class Scene graph node which defines a rotation modelling transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.Rotate = SceneJS_NodeFactory.createNodeType("rotate");

SceneJS.Rotate.prototype._init = function(params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        this.setMultOrder(params.multOrder);

        this.setAngle(params.angle);

        this.setXYZ({
            x: params.x,
            y: params.y,
            z: params.z
        });

        var core = this._core;

        core.matrix = mat4.create();

        this._core.buildMatrix = function() {
            mat4.fromRotation(core.matrix, core.angle * Math.PI / 180.0, [core.x, core.y, core.z]);
        };

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.Rotate.prototype.getModelMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, rotate, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.Rotate.prototype.getWorldMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply( [], this._core.mat);
};

/**
 * Sets the multiplication order of this node's transform matrix with respect to the parent modeling transform
 * in the scene graph.
 *
 * @param {String} multOrder Mulplication order - "post" and "pre"
 */
SceneJS.Rotate.prototype.setMultOrder = function(multOrder) {

    multOrder = multOrder || "post";

    if (multOrder != "post" && multOrder != "pre") {

        throw SceneJS_error.fatalError(
                SceneJS.errors.NODE_CONFIG_EXPECTED,
                "Illegal multOrder for rotate node - '" + multOrder + "' should be 'pre' or 'post'");
    }

    this._core.multOrder = multOrder;

    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.setAngle = function(angle) {
    this._core.angle = angle || 0;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getAngle = function() {
    return this._core.angle;
};

SceneJS.Rotate.prototype.setXYZ = function(xyz) {

    xyz = xyz || {};

    this._core.x = xyz.x || 0;
    this._core.y = xyz.y || 0;
    this._core.z = xyz.z || 0;

    this._core.setDirty();

    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getXYZ = function() {
    return {
        x: this._core.x,
        y: this._core.y,
        z: this._core.z
    };
};

SceneJS.Rotate.prototype.setX = function(x) {
    this._core.x = x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getX = function() {
    return this._core.x;
};

SceneJS.Rotate.prototype.setY = function(y) {
    this._core.y = y;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getY = function() {
    return this._core.y;
};

SceneJS.Rotate.prototype.setZ = function(z) {
    this._core.z = z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype.getZ = function() {
    return this._core.z;
};

SceneJS.Rotate.prototype.incAngle = function(angle) {
    this._core.angle += angle;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Rotate.prototype._compile = function (ctx) {
    var core = this._core;
    core.numCores = 0;
    for (var i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.Rotate.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.Rotate.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;/**
 * @class Scene graph node which defines a translation modelling transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.Translate = SceneJS_NodeFactory.createNodeType("translate");

SceneJS.Translate.prototype._init = function(params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        this.setMultOrder(params.multOrder);

        this.setXYZ({
            x: params.x,
            y: params.y,
            z: params.z
        });

        var core = this._core;

        this._core.buildMatrix = function() {
            mat4.fromTranslation(core.matrix, [core.x, core.y, core.z]);
        };

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.Translate.prototype.getModelMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, translate, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.Translate.prototype.getWorldMatrix = function() {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply( [], this._core.mat);
};


/**
 * Sets the multiplication order of this node's transform matrix with respect to the parent modeling transform
 * in the scene graph.
 *
 * @param {String} multOrder Mulplication order - "post" and "pre"
 */
SceneJS.Translate.prototype.setMultOrder = function(multOrder) {

    multOrder = multOrder || "post";

    if (multOrder != "post" && multOrder != "pre") {

        throw SceneJS_error.fatalError(
                SceneJS.errors.NODE_CONFIG_EXPECTED,
                "Illegal multOrder for translate node - '" + multOrder + "' should be 'pre' or 'post'");
    }

    this._core.multOrder = multOrder;

    this._core.setDirty();

    this._engine.display.imageDirty = true;
};

SceneJS.Translate.prototype.setXYZ = function(xyz) {

    xyz = xyz || {};

    this._core.x = xyz.x || 0;
    this._core.y = xyz.y || 0;
    this._core.z = xyz.z || 0;

    this._core.setDirty();

    this._engine.display.imageDirty = true;

    return this;
};

SceneJS.Translate.prototype.getXYZ = function() {
    return {
        x: this._core.x,
        y: this._core.y,
        z: this._core.z
    };
};

SceneJS.Translate.prototype.setX = function(x) {
    this._core.x = x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.setY = function(y) {
    this._core.y = y;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.setZ = function(z) {
    this._core.z = z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.incX = function(x) {
    this._core.x += x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.incY = function(y) {
    this._core.y += y;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.incZ = function(z) {
    this._core.z += z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
    return this;
};

SceneJS.Translate.prototype.getX = function() {
    return this._core.x;
};

SceneJS.Translate.prototype.getY = function() {
    return this._core.y;
};

SceneJS.Translate.prototype.getZ = function() {
    return this._core.z;
};

SceneJS.Translate.prototype._compile = function (ctx) {
    var core = this._core;
    core.numCores = 0;
    for (var i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.Translate.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.Translate.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;/**
 * @class Scene graph node which defines a rotation modelling transform to apply to the objects in its subgraph
 * @extends SceneJS.Node
 */
SceneJS.Scale = SceneJS_NodeFactory.createNodeType("scale");

SceneJS.Scale.prototype._init = function (params) {

    if (this._core.useCount == 1) { // This node is the resource definer

        this.setMultOrder(params.multOrder);

        this.setXYZ({
            x:params.x,
            y:params.y,
            z:params.z
        });

        var core = this._core;

        core.matrix = mat4.create();

        this._core.buildMatrix = function () {
             mat4.fromScaling(core.matrix, [core.x, core.y, core.z]);
        };

        this.xformParent = null;
        this.xformChildren = [];
    }
};

/**
 * Get Model matrix
 * @return {*}
 */
SceneJS.Scale.prototype.getModelMatrix = function () {
    if (this._core.dirty) {
        this._core.build();
    }
    return this._core.matrix;
};

/**
 * Get World matrix. That's the multiplication of this node's Model matrix by the World matrix of the the next
 * tranform (scale, scale, translate etc) node on the path to the scene root.
 * @return {*}
 */
SceneJS.Scale.prototype.getWorldMatrix = function () {
    if (this._core.dirty) {
        this._core.build();
    }
    return Array.apply([], this._core.mat);
};

/**
 * Sets the multiplication order of this node's transform matrix with respect to the parent modeling transform
 * in the scene graph.
 *
 * @param {String} multOrder Mulplication order - "post" and "pre"
 */
SceneJS.Scale.prototype.setMultOrder = function (multOrder) {

    multOrder = multOrder || "post";

    if (multOrder != "post" && multOrder != "pre") {

        throw SceneJS_error.fatalError(
            SceneJS.errors.NODE_CONFIG_EXPECTED,
            "Illegal multOrder for scale node - '" + multOrder + "' should be 'pre' or 'post'");
    }

    this._core.multOrder = multOrder;

    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.setXYZ = function (xyz) {

    xyz = xyz || {};

    this._core.x = xyz.x == undefined ? 1 : xyz.x;
    this._core.y = xyz.y == undefined ? 1 : xyz.y;
    this._core.z = xyz.z == undefined ? 1 : xyz.z;

    this._core.setDirty();

    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.getXYZ = function () {
    return {
        x:this._core.x,
        y:this._core.y,
        z:this._core.z
    };
};

SceneJS.Scale.prototype.setX = function (x) {
    this._core.x = x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.setY = function (y) {
    this._core.y = y;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.setZ = function (z) {
    this._core.z = z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.getX = function () {
    return this._core.x;
};

SceneJS.Scale.prototype.getY = function () {
    return this._core.y;
};

SceneJS.Scale.prototype.getZ = function () {
    return this._core.z;
};

SceneJS.Scale.prototype.incX = function (x) {
    this._core.x += x;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype.incY = function (y) {
    this._core.y += y;
    this._core.matrixDirty = true;
};

SceneJS.Scale.prototype.incZ = function (z) {
    this._core.z += z;
    this._core.setDirty();
    this._engine.display.imageDirty = true;
};

SceneJS.Scale.prototype._compile = function (ctx) {
    var core = this._core;
    core.numCores = 0;
    for (var i = 0, len = this.xformChildren.length; i < len; i++) {
        var child = this.xformChildren[i];
        if (!this.branchDirty && !child.dirty) {
            core.cores[core.numCores++] = child._core;
        }
    }

    for (i = core.numCores, len = core.cores.length; i < len; i++) {
        core.cores[i] = null;
    }

    SceneJS_modelXFormStack.push(core);
    this._compileNodes(ctx);
    SceneJS_modelXFormStack.pop();
};

SceneJS.Scale.prototype._connect = function () {
    if (this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        if (n.xformChildren && this.xformParent !== n) {
            this.xformParent = n;
            n.xformChildren.push(this);
            break;
        }
    }
};

SceneJS.Scale.prototype._disconnect = function () {
    if (!this.xformParent) {
        return;
    }

    var n = this;

    while (n.parent) {
        n = n.parent;

        // Still connected to xformParent
        if (this.xformParent === n) {
            return;
        }
    }

    var siblings = this.xformParent.xformChildren;
    siblings.splice(siblings.indexOf(this), 1);
    this.xformParent = null;
};
;/**
 * Provides a model transform stack in front of the renderer.
 * Nodes peek push and pop to the stack, while the renderer peeks at
 * the transform on the top of the stack whenever it builds a renderer node.
 *
 */
var SceneJS_modelXFormStack = new (function () {

    var defaultMatrix = mat4.create();
    var defaultMat = mat4.create();

    var defaultNormalMatrix = mat4.create();
    var defaultNormalMat = mat4.create();

    var defaultCore = {
        type:"xform",
        stateId:SceneJS._baseStateId++,

        matrix:defaultMatrix,
        mat:defaultMat,

        normalMat:defaultNormalMat,

        parent:null, // Parent transform core
        cores:[], // Child transform cores
        numCores:0, // Number of child transform cores
        dirty:false, // Does this subtree need matrices rebuilt
        matrixDirty:false
    };

    var transformStack = [];
    var stackLen = 0;

    this.top = defaultCore;

    var dirty;

    var self = this;

    SceneJS_events.addListener(
        SceneJS_events.SCENE_COMPILING,
        function () {
            stackLen = 0;
            self.top = defaultCore;
            dirty = true;
        });

    SceneJS_events.addListener(
        SceneJS_events.OBJECT_COMPILING,
        function (params) {

            if (dirty) {

                if (stackLen > 0) {

                    params.display.modelTransform = transformStack[stackLen - 1];

                } else {

                    params.display.modelTransform = defaultCore;
                }

                dirty = false;
            }
        });

    this.push = function (core) {

        transformStack[stackLen++] = core;

        core.parent = this.top;
        core.dirty = true;

        if (this.top) {
            this.top.cores[this.top.numCores++] = core;
        }

        this.top = core;

        dirty = true;
    };

    this.pop = function () {

        this.top = (--stackLen > 0) ? transformStack[stackLen - 1] : defaultCore;
        transformStack[stackLen] = null;  // Release previous top node

        dirty = true;
    };

})();
;/**
 * Container for custom node types
 */
SceneJS.Types = new (function () {

    /**
     * Installs a node type
     * @param typeName
     * @param methods
     */
    this.addType = function (typeName, methods) {
        var type = SceneJS_NodeFactory.createNodeType(typeName);
        var method;
        for (var methodName in methods) {
            if (methods.hasOwnProperty(methodName)) {
                method = methods[methodName];
                switch (methodName) {
                    case "init": // Deprecated
                    case "construct":
                        (function () {
                            var _method = methods[methodName];
                            type.prototype._init = function (params) {
                                _method.call(this, params);
                            };

                            // Mark node type as a plugin
                            type.prototype._fromPlugin = true;
                        })();
                        break;
                    case "destroy": // Deprecated
                    case "destruct":
                        type.prototype._destroy = method;
                        break;
                    default:
                        type.prototype[methodName] = method;
                }
            }
        }
    };

    /**
     * Tests if given node type is installed
     * @param typeName
     */
    this.hasType = function (typeName) {
        return !!SceneJS_NodeFactory.nodeTypes[typeName];
    };
})();

;/**
 * @class Display compiled from a {@link SceneJS.Scene}, providing methods to render and pick.
 * @private
 *
 * <p>A Display is a container of {@link SceneJS_Object}s which are created (or updated) by a depth-first
 * <b>compilation traversal</b> of a {@link SceneJS.Scene}.</b>
 *
 * <h2>Rendering Pipeline</h2>
 *
 * <p>Conceptually, a Display implements a pipeline with the following stages:</p>
 *
 * <ol>
 * <li>Create or update {@link SceneJS_Object}s during scene compilation</li>
 * <li>Organise the {@link SceneJS_Object} into an <b>object list</b></li>
 * <li>Determine the GL state sort order for the object list</li>
 * <li>State sort the object list</li>
 * <li>Create a <b>draw list</b> containing {@link SceneJS_Chunk}s belonging to the {@link SceneJS_Object}s in the object list</li>
 * <li>Render the draw list to draw the image</li>
 * </ol>
 *
 * <p>An update to the scene causes the pipeline to be re-executed from one of these stages, and SceneJS is designed
 * so that the pipeline is always re-executed from the latest stage possible to avoid redoing work.</p>
 *
 * <p>For example:</p>
 *
 * <ul>
 * <li>when an object is created or updated, we need to (re)do stages 2, 3, 4, 5 and 6</li>
 * <li>when an object is made invisible, we need to redo stages 5 and 6</li>
 * <li>when an object is assigned to a different scene render layer (works like a render bin), we need to redo
 *   stages 3, 4, 5, and 6</li>
 *<li>when the colour of an object changes, or maybe when the viewpoint changes, we simplt redo stage 6</li>
 * </ul>
 *
 * <h2>Object Creation</h2>
 * <p>The object soup (stage 1) is constructed by a depth-first traversal of the scene graph, which we think of as
 * "compiling" the scene graph into the Display. As traversal visits each scene node, the node's state core is
 * set on the Display (such as {@link #flags}, {@link #layer}, {@link #renderer} etc), which we think of as the
 * cores that are active at that instant during compilation. Each of the scene's leaf nodes is always
 * a {@link SceneJS.Geometry}, and when traversal visits one of those it calls {@link #buildObject} to create an
 * object in the soup. For each of the currently active cores, the object is given a {@link SceneJS_Chunk}
 * containing the WebGL calls for rendering it.</p>
 *
 * <p>The object also gets a shader (implemented by {@link SceneJS_Program}), taylored to render those state cores.</p>
 *
 * <p>Limited re-compilation may also be done on portions of a scene that have been added or sufficiently modified. When
 * traversal visits a {@link SceneJS.Geometry} for which an object already exists in the display, {@link #buildObject}
 * may update the {@link SceneJS_Chunk}s on the object as required for any changes in the core soup since the
 * last time the object was built. If differences among the cores require it, then {@link #buildObject} may also replace
 * the object's {@link SceneJS_Program} in order to render the new core soup configuration.</p>
 *
 * <p>So in summary, to each {@link SceneJS_Object} it builds, {@link #buildObject} creates a list of
 * {@link SceneJS_Chunk}s to render the set of node state cores that are currently set on the {@link SceneJS_Display}.
 * When {@link #buildObject} is re-building an existing object, it may replace one or more {@link SceneJS_Chunk}s
 * for state cores that have changed from the last time the object was built or re-built.</p>

 * <h2>Object Destruction</h2>
 * <p>Destruction of a scene graph branch simply involves a call to {@link #removeObject} for each {@link SceneJS.Geometry}
 * in the branch.</p>
 *
 * <h2>Draw List</h2>
 * <p>The draw list is actually comprised of two lists of state chunks: a "pick" list to render a pick buffer
 * for colour-indexed GPU picking, along with a "draw" list for normal image rendering. The chunks in these lists
 * are held in the state-sorted order of their objects in #_objectList, with runs of duplicate states removed.</p>
 *
 * <p>After a scene update, we set a flag on the display to indicate the stage we will need to redo from. The pipeline is
 * then lazy-redone on the next call to #render or #pick.</p>
 */
var SceneJS_Display = function (stats, cfg) {

    // Collects runtime statistics
    this.stats = stats || {};

    // Display is bound to the lifetime of an HTML5 canvas
    this._canvas = cfg.canvas;

    // Factory which creates and recycles {@link SceneJS_Program} instances
    this._programFactory = new SceneJS_ProgramFactory(this.stats, {
        canvas: cfg.canvas
    });

    // Factory which creates and recycles {@link SceneJS.Chunk} instances
    this._chunkFactory = new SceneJS_ChunkFactory();

    /**
     * True when the background is to be transparent
     * @type {boolean}
     */
    this.transparent = cfg.transparent === true;

    /**
     * Depth sort mode. Default to only sorting transparent objects.
     */
    this.depthSort = cfg.depthSort === true;

    /**
     * Node state core for the last {@link SceneJS.Enable} visited during scene graph compilation traversal
     * @type Object
     */
    this.enable = null;

    /**
     * Node state core for the last {@link SceneJS.Flags} visited during scene graph compilation traversal
     * @type Object
     */
    this.properties = null;

    /**
     * Node state core for the last {@link SceneJS.Layer} visited during scene graph compilation traversal
     * @type Object
     */
    this.layer = null;

    /**
     * Node state core for the last {@link SceneJS.View} visited during scene graph compilation traversal
     * @type Object
     */
    this.view = null;

    /**
     * Node state core for the last {@link SceneJS.Lights} visited during scene graph compilation traversal
     * @type Object
     */
    this.lights = null;

    /**
     * Node state core for the last {@link SceneJS.Material} visited during scene graph compilation traversal
     * @type Object
     */
    this.material = null;

    /**
     * Node state core for the last {@link SceneJS.Texture} visited during scene graph compilation traversal
     * @type Object
     */
    this.texture = null;

    /**
     * Node state core for the last {@link SceneJS.Fresnel} visited during scene graph compilation traversal
     * @type Object
     */
    this.fresnel = null;

    /**
     * Node state core for the last {@link SceneJS.Reflect} visited during scene graph compilation traversal
     * @type Object
     */
    this.cubemap = null;

    /**
     * Node state core for the last {@link SceneJS.XForm} visited during scene graph compilation traversal
     * @type Object
     */
    this.modelTransform = null;

    /**
     * Node state core for the last {@link SceneJS.LookAt} visited during scene graph compilation traversal
     * @type Object
     */
    this.viewTransform = null;

    /**
     * Node state core for the last {@link SceneJS.Camera} visited during scene graph compilation traversal
     * @type Object
     */
    this.projTransform = null;

    /**
     * Node state core for the last {@link SceneJS.RegionMap} visited during scene graph compilation traversal
     * @type Object
     */
    this.regionMap = null;

    /**
     * Node state core for the last {@link SceneJS.Clips} visited during scene graph compilation traversal
     * @type Object
     */
    this.clips = null;

    /**
     * Node state core for the last {@link SceneJS.MorphGeometry} visited during scene graph compilation traversal
     * @type Object
     */
    this.morphGeometry = null;

    /**
     * Node state core for the last render {@link SceneJS.Node} listener encountered during scene graph compilation traversal
     * @type Object
     */
    this.renderListeners = null;

    /**
     * Node state core for the last {@link SceneJS.Style} visited during scene graph compilation traversal
     * @type Object
     */
    this.style = null;

    /**
     * Node state core for the last {@link SceneJS.Geometry} visited during scene graph compilation traversal
     * @type Object
     */
    this.geometry = null;

    /* Factory which creates and recycles {@link SceneJS_Object} instances
     */
    this._objectFactory = new SceneJS_ObjectFactory();

    /**
     * The objects in the display
     */
    this._objects = {};

    /**
     * Ambient color, which must be given to gl.clearColor before draw list iteration
     */
    this._ambientColor = [0, 0, 0, 1.0];

    this.highlightColor = new Float32Array([1.5, 1.5, 0.5]);
    this.desatParams = new Float32Array([0.9, 0.3]);
    this.fogParams = new Float32Array([0, 1000, 0, 1]);
    this.fogColor = new Float32Array([1, 1, 1, 0.01]);
    this.fogEnabled = false;
    this.xrayGlassFactor = 1.0;
    this.xrayMurkiness = 0.8;
    this.xrayBGColor = new Float32Array([0.0, 0.0, 0.1]);
    this.fogMode = SceneJS.DISPLAY_FLAGS.FOG_LINEAR;
    this.viewport = [0, 0, this._canvas.canvas.width, this._canvas.canvas.height];

    /**
     * The object list, containing all elements of #_objects, kept in GL state-sorted order
     */
    this._objectList = [];
    this._objectListLen = 0;

    this._pickLookup = [];

    /* The frame context holds state shared across a single render of the draw list, along with any results of
     * the render, such as pick hits
     */
    this._frameCtx = {
        regionData: [],
        canvas: this._canvas,           // The canvas
        VAO: null                       // Vertex array object extension
    };

    /* The frame context has this facade which is given to scene node "rendered" listeners
     * to allow application code to access things like transform matrices from within those listeners.
     */
    this._frameCtx.renderListenerCtx = new SceneJS.RenderContext(this._frameCtx);

    /*-------------------------------------------------------------------------------------
     * Flags which schedule what the display is to do when #render is next called.
     *------------------------------------------------------------------------------------*/

    /**
     * Flags the object list as needing to be rebuilt from existing objects on the next call to {@link #render} or {@link #pick}.
     * Setting this will cause the rendering pipeline to be executed from stage #2 (see class comment),
     * causing object list rebuild, state order determination, state sort, draw list construction and image render.
     * @type Boolean
     */
    this.objectListDirty = true;

    /**
     * Flags the object list as needing state orders to be computed on the next call to {@link #render} or {@link #pick}.
     * Setting this will cause the rendering pipeline to be executed from stage #3 (see class comment),
     * causing state order determination, state sort, draw list construction and image render.
     * @type Boolean
     */
    this.stateOrderDirty = true;

    /**
     * Flags the object list as needing to be state sorted on the next call to {@link #render} or {@link #pick}.
     * Setting this will cause the rendering pipeline to be executed from stage #4 (see class comment),
     * causing state sort, draw list construction and image render.
     * @type Boolean
     */
    this.stateSortDirty = true;

    /**
     * Flags the image as needing to be redrawn from the draw list on the next call to {@link #render} or {@link #pick}.
     * Setting this will cause the rendering pipeline to be executed from stage #6 (see class comment),
     * causing the image render.
     * @type Boolean
     */
    this.imageDirty = true;
};

/**
 * Reallocates WebGL resources for objects within this display
 */
SceneJS_Display.prototype.webglRestored = function () {
    this._programFactory.webglRestored();// Reallocate programs
    this._chunkFactory.webglRestored(); // Recache shader var locations
    var gl = this._canvas.gl;
    if (this.pickBuf) {
        this.pickBuf.webglRestored(gl);          // Rebuild pick buffers
    }
    this.imageDirty = true;             // Need redraw
};

SceneJS_Display.prototype.setViewport = function (xmin, ymin, width, height) {
    this.viewport = [xmin, ymin, width, height];
    this.imageDirty = true;
};


/**
 * Internally creates (or updates) a {@link SceneJS_Object} of the given ID from whatever node state cores are currently set
 * on this {@link SceneJS_Display}. The object is created if it does not already exist in the display, otherwise it is
 * updated with the current state cores, possibly replacing cores already referenced by the object.
 *
 * @param {String} objectId ID of object to create or update
 */
SceneJS_Display.prototype.buildObject = function (objectId) {

    var object = this._objects[objectId];

    if (!object) { // Create object
        object = this._objects[objectId] = this._objectFactory.getObject(objectId);
        this.objectListDirty = true;
    }

    object.modelTransform = this.modelTransform;
    object.viewTransform = this.viewTransform;
    object.projTransform = this.projTransform;
    object.texture = this.texture;
    object.cubemap = this.cubemap;
    object.geometry = this.geometry;
    object.morphGeometry = this.morphGeometry;
    object.properties = this.properties;
    object.material = this.material;
    object.fresnel = this.fresnel;
    object.regionMap = this.regionMap;

    var hash = ([                   // Build current state hash
        this.geometry.hash,
        this.clips.hash,
        this.morphGeometry.hash,
        this.texture.hash,
        this.fresnel.hash,
        this.cubemap.hash,
        this.lights.hash,
        this.properties.hash,
        this.regionMap.hash,
        this.fogEnabled ? ("f" + this.fogMode) : ""
    ]).join(";");

    if (!object.program || hash != object.hash) {
        // Get new program for object if no program or hash mismatch
        if (object.program) {
            this._programFactory.putProgram(object.program);
        }
        object.program = this._programFactory.getProgram(hash, this);
        object.hash = hash;
    }
    //}

    // Build draw chunks for object

    this._setChunk(object, 0, "program"); // Must be first
    this._setChunk(object, 1, "xform", this.modelTransform);
    this._setChunk(object, 2, "lookAt", this.viewTransform);
    this._setChunk(object, 3, "camera", this.projTransform);
    this._setChunk(object, 4, "properties", this.properties);
    this._setChunk(object, 5, "style", this.style);
    this._setChunk(object, 6, "view", this.view);
    this._setChunk(object, 7, "lights", this.lights);
    this._setChunk(object, 8, "material", this.material);
    this._setChunk(object, 9, "texture", this.texture);
    this._setChunk(object, 10, "regionMap", this.regionMap);
    this._setChunk(object, 11, "fresnel", this.fresnel);
    this._setChunk(object, 12, "cubemap", this.cubemap);
    this._setChunk(object, 13, "clips", this.clips);
    this._setChunk(object, 14, "geometry", this.morphGeometry, this.geometry);
    this._setChunk(object, 15, "listeners", this.renderListeners); // Must be after the above chunks
    this._setChunk(object, 16, "draw", this.geometry); // Must be last

    // At the very least, the object sort order
    // will need be recomputed

    this.stateOrderDirty = true;
};


SceneJS_Display.prototype._setChunk = function (object, order, chunkType, core, core2) {

    var chunkId;
    var chunkClass = this._chunkFactory.chunkTypes[chunkType];

    if (core) {

        // Core supplied
        if (core.empty) { // Only set default cores for state types that have them
            var oldChunk = object.chunks[order];
            if (oldChunk) {
                this._chunkFactory.putChunk(oldChunk); // Release previous chunk to pool
            }
            object.chunks[order] = null;
            return;
        }

        // Note that core.stateId can be either a number or a string, that's why we make
        // chunkId a string here.
        // TODO: Would it be better if all were numbers?
        chunkId = chunkClass.prototype.programGlobal
            ? '_' + core.stateId
            : 'p' + object.program.id + '_' + core.stateId;

        if (core2) {
            chunkId += '__' + core2.stateId;
        }

    } else {

        // No core supplied, probably a program.
        // Only one chunk of this type per program.
        chunkId = 'p' + object.program.id;
    }

    // This is needed so that chunkFactory can distinguish between draw and geometry
    // chunks with the same core.
    chunkId = order + '__' + chunkId;

    var oldChunk = object.chunks[order];

    if (oldChunk) {
        if (oldChunk.id == chunkId) { // Avoid needless chunk reattachment
            return;
        }
        this._chunkFactory.putChunk(oldChunk); // Release previous chunk to pool
    }

    object.chunks[order] = this._chunkFactory.getChunk(chunkId, chunkType, object.program, core, core2); // Attach new chunk

    // Ambient light is global across everything in display, and
    // can never be disabled, so grab it now because we want to
    // feed it to gl.clearColor before each display list render
    if (chunkType == "lights") {
        this._setAmbient(core);
    }
};

SceneJS_Display.prototype._setAmbient = function (core) {
    var lights = core.lights;
    var light;
    for (var i = 0, len = lights.length; i < len; i++) {
        light = lights[i];
        if (light.mode == "ambient") {
            this._ambientColor[0] = light.color[0];
            this._ambientColor[1] = light.color[1];
            this._ambientColor[2] = light.color[2];
        }
    }
};

/**
 * Removes an object from this display
 *
 * @param {String} objectId ID of object to remove
 */
SceneJS_Display.prototype.removeObject = function (objectId) {
    var object = this._objects[objectId];
    if (!object) {
        return;
    }
    this._programFactory.putProgram(object.program);
    object.program = null;
    object.hash = null;
    var chunk;
    for (var i = 0, len = object.chunks.length; i < len; i++) {
        chunk = object.chunks[i];
        if (chunk) {
            this._chunkFactory.putChunk(chunk);
        }
    }
    this._objectFactory.putObject(object);
    delete this._objects[objectId];
    this.objectListDirty = true;
};

/**
 * Render this display. What actually happens in the method depends on what flags are set.
 *
 */
SceneJS_Display.prototype.prepareScene = function () {
    if (this.objectListDirty) {
        this._buildObjectList();          // Build object render bin
        this.objectListDirty = false;
        this.stateOrderDirty = true;        // Now needs state ordering
    }

    if (this.stateOrderDirty) {
        this._makeStateSortKeys();      // Compute state sort order
        this.stateOrderDirty = false;
        this.stateSortDirty = true;     // Now needs state sorting
    }

    if (this.stateSortDirty) {
        this._stateSort();              // State sort the object render bin
        this.stateSortDirty = false;
        this.imageDirty = true;
    }
};

/**
 * Render this display. What actually happens in the method depends on what flags are set.
 *
 */
SceneJS_Display.prototype.render = function (params) {

    params = params || {};

    if (this._canvas.canvas.width == 0 || this._canvas.canvas.height == 0) {
        // Canvas hidden
        return;
    }

    if (this.imageDirty || params.force) {
        this._doDrawList({ // Render, no pick
            clear: (params.clear !== false), // Clear buffers by default
            opaqueOnly: params.opaqueOnly,
            pass: params.pass
        });
        this.imageDirty = false;
        this.pickBufDirty = true;       // Pick buff will now need rendering on next pick
    }
};

SceneJS_Display.prototype._buildObjectList = function () {
    var lastObjectListLen = this._objectListLen;
    this._objectListLen = 0;
    for (var objectId in this._objects) {
        if (this._objects.hasOwnProperty(objectId) && this._objects[objectId].properties.getFlag(SceneJS.PROPERTY_FLAGS.ENABLED)) {
            this._objectList[this._objectListLen++] = this._objects[objectId];
        }
    }

    // Release memory

    if (lastObjectListLen > this._objectListLen) {
        for (i = this._objectListLen; i < lastObjectListLen; i++) {
            this._objectList[i] = null;
        }
    }
};

SceneJS_Display.prototype._makeStateSortKeys = function () {
   var object;
    for (var i = 0, len = this._objectListLen; i < len; i++) {
        object = this._objectList[i];
        if (!object.program) { // Non-visual object (eg. sound)
            object.sortKey1 = -1;
        } else {
            object.sortKey1 = (object.properties.layer + 1);
            object.sortKey2 = (object.program.id + 1) * 100000 + object.texture.stateId;
            object.sortKey3 = object.properties.stateId;
        }
    }
};

SceneJS_Display.prototype._stateSort = function () {
    this._objectList.length = this._objectListLen;
    this._objectList.sort(this._stateSortObjects);
};

SceneJS_Display.prototype._stateSortObjects = function (a, b) {
    return (a.sortKey1 - b.sortKey1) || (a.sortKey2 - b.sortKey2) || (a.sortKey3 - b.sortKey3);
};

SceneJS_Display.prototype._logObjectList = function () {
    console.log("--------------------------------------------------------------------------------------------------");
    console.log(this._objectListLen + " objects");
    for (var i = 0, len = this._objectListLen; i < len; i++) {
        var object = this._objectList[i];
        console.log("SceneJS_Display : object[" + i + "] sortKey = " + object.sortKey);
    }
    console.log("--------------------------------------------------------------------------------------------------");
};

(function () {

    var localRayOrigin = vec3.create();
    var localRayDir = vec3.create();

    var pickViewMatrix = mat4.create();
    var pickProjMatrix = mat4.frustum(mat4.create(), -1, 1, -1, 1, 0.1, 10000);

    var a = vec3.create();
    var b = vec3.create();
    var c = vec3.create();

    var na = vec3.create();
    var nb = vec3.create();
    var nc = vec3.create();

    var uva = vec3.create();
    var uvb = vec3.create();
    var uvc = vec3.create();

    var tempMat4 = mat4.create();
    var tempMat4b = mat4.create();

    var tempVec4 = vec4.create();
    var tempVec4b = vec4.create();

    var tempVec3 = vec3.create();
    var tempVec3b = vec3.create();
    var tempVec3c = vec3.create();
    var tempVec3d = vec3.create();

    var tempVec2 = vec2.create();
    var tempVec2b = vec2.create();
    var tempVec2c = vec2.create();
    var tempVec2d = vec2.create();


    // Transforms canvas coordinates into a Local-space ray

    var canvasPosToLocalRay = (function () {

        var vmMat = mat4.create();
        var pvMat = mat4.create();
        var pvMatInv = mat4.create();
        var a  = vec4.create(); // Local-space ray endpoints
        var b = vec4.create();

        return function (canvas, object, canvasPos, localRayOrigin, localRayDir) {

            var modelMat = object.modelTransform.mat;
            var viewMat = object.viewTransform.mat;
            var projMat = object.projTransform.mat;

            mat4.multiply(vmMat, viewMat, modelMat);
            mat4.multiply(pvMat, projMat, vmMat);
            mat4.invert(pvMatInv, pvMat);

            var canvasWidth = canvas.width;
            var canvasHeight = canvas.height;

            var clipX = (canvasPos[0] - canvasWidth / 2) / (canvasWidth / 2);  // Calculate clip space coordinates
            var clipY = -(canvasPos[1] - canvasHeight / 2) / (canvasHeight / 2);

            vec4.transformMat4(a, [clipX, clipY, -1, 1], pvMatInv);
            vec3.scale(a, a, 1 / a[3]);

            vec4.transformMat4(b, [clipX, clipY, 1, 1], pvMatInv);
            vec3.scale(b, b, 1 / b[3]);

            localRayOrigin[0] = a[0];
            localRayOrigin[1] = a[1];
            localRayOrigin[2] = a[2];

            vec3.subtract(localRayDir, b, a);
            vec3.normalize(localRayDir, localRayDir)
        };
    })();

    // Transforms a World-space ray into Local-space ray

    var worldRayToLocalRay = (function () {

        var modelMatInv = mat4.create();
        var a = vec4.create();
        var b = vec4.create();

        return function (object, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir) {

            var modelMat = object.modelTransform.mat;

            mat4.invert(modelMatInv, modelMat);

            a[0] = worldRayOrigin[0];
            a[1] = worldRayOrigin[1];
            a[2] = worldRayOrigin[2];
            a[3] = 1;

            vec4.transformMat4(b, a, modelMatInv);

            localRayOrigin[0] = b[0];
            localRayOrigin[1] = b[1];
            localRayOrigin[2] = b[2];

            vec3.transformMat4(localRayDir, worldRayDir, modelMatInv);
        };
    })();

    /**
     * Performs a pick on the display graph and returns info on the result.
     * @param {*} params
     * @returns {*}
     */
    SceneJS_Display.prototype.pick = function (params) {

        if (!params.canvasPos && (params.rayPick && (!params.origin || !params.direction))) {
            console.warn("Incomplete pick parameters");
            return;
        }

        if (this._canvas.canvas.width == 0 || this._canvas.canvas.height == 0) {
            // Canvas hidden
            return;
        }

        var canvas = this._canvas.canvas;
        var resolutionScaling = this._canvas.resolutionScaling;
        var canvasPos = params.canvasPos;
        if (canvasPos) {
            canvasPos = new Float32Array([canvasPos[0] * resolutionScaling, canvasPos[1] * resolutionScaling]);
        }
        var pickBuf = this.pickBuf;
        var hit = null;
        var object;
        var i;
        var len;

        // Lazy-create pick buffer

        if (!pickBuf) {
            pickBuf = this.pickBuf = new SceneJS._webgl.RenderBuffer({
                canvas: this._canvas
            });
        }

        var worldRayPicking = !params.canvasPos; // Picking with ray given as origin->direction

        var worldRayOrigin;
        var worldRayDir;

        var pickBufX;
        var pickBufY;

        if (worldRayPicking) {

            worldRayOrigin = params.origin || new Float32Array([0, 0, 0]);
            worldRayDir = params.direction || new Float32Array([0, 0, 1]);

            var look = vec3.add(tempVec3, worldRayOrigin, worldRayDir);
            var up = new Float32Array([0, 1, 0]); // TODO: derive from ray?

            mat4.lookAt(pickViewMatrix, worldRayOrigin, look, up);

            pickBufX = canvas.clientWidth * 0.5; // Sample center of pick buffer
            pickBufY = canvas.clientHeight * 0.5;

        } else {

            pickBufX = canvasPos[0];
            pickBufY = canvasPos[1];
        }

        this.prepareScene();
        this.render(); // Do any pending visible render

        //------------------------------------------------------------------
        // Pick an object using color-indexed render
        //------------------------------------------------------------------

        pickBuf.bind();

        pickBuf.clear();

        this._doDrawList({
            pickObject: true,
            clear: true,
            pickViewMatrix: worldRayPicking ? pickViewMatrix : null,
            pickProjMatrix: worldRayPicking ? pickProjMatrix : null
        });

        this._canvas.gl.finish();

        // Read pixel color in pick buffer at given coordinates,
        // convert to an index into the pick name list

        var pix = pickBuf.read(pickBufX, pickBufY);

        var pickedColorIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);

        var objectIndex = this._pickLookup[pickedColorIndex - 1];

        if (objectIndex >= 0) {

            object = this._objectList[objectIndex];

            hit = {
                canvasPos: canvasPos
            };

            var properties = object.properties;

            if (properties) {
                hit.name = properties.name;
                hit.nodeId = properties.nodeId;
            }
        }

        if (params.pickRegion) {

            //------------------------------------------------------------------
            // Pick a region
            // Region picking is independent of having picked an object
            //------------------------------------------------------------------

            pickBuf.clear();

            this._doDrawList({
                pickRegion: true,
                object: object,
                pickViewMatrix: worldRayPicking ? pickViewMatrix: null,
                pickProjMatrix: worldRayPicking ? pickProjMatrix: null,
                clear: true
            });

            pix = pickBuf.read(pickBufX, pickBufY);

            if (pix[0] !== 0 || pix[1] !== 0 || pix[2] !== 0 || pix[3] !== 0) {

                hit = hit || {
                        canvasPos: canvasPos
                    };

                var regionColor = {r: pix[0] / 255, g: pix[1] / 255, b: pix[2] / 255, a: pix[3] / 255};
                var regionData = this._frameCtx.regionData;
                var tolerance = 0.01;
                var data = {};
                var color, delta;

                for (i = 0, len = regionData.length; i < len; i++) {
                    color = regionData[i].color;
                    if (regionColor && regionData[i].data) {
                        delta = Math.max(
                            Math.abs(regionColor.r - color.r),
                            Math.abs(regionColor.g - color.g),
                            Math.abs(regionColor.b - color.b),
                            Math.abs(regionColor.a - (color.a === undefined ? regionColor.a : color.a))
                        );

                        if (delta < tolerance) {
                            data = regionData[i].data;
                            break;
                        }
                    }
                }

                hit.color = regionColor;
                hit.regionData = data;
            }
        }

        if (params.pickTriangle && object) {

            //------------------------------------------------------------------
            // Pick a triangle on the picked object
            //------------------------------------------------------------------

            pickBuf.clear();

            this._doDrawList({
                pickTriangle: true,
                object: object,
                pickViewMatrix: worldRayPicking ? pickViewMatrix: null,
                pickProjMatrix: worldRayPicking ? pickProjMatrix: null,
                clear: true
            });

            pix = pickBuf.read(pickBufX, pickBufY);
            var primitiveIndex = pix[0] + (pix[1] * 256) + (pix[2] * 256 * 256) + (pix[3] * 256 * 256 * 256);
            primitiveIndex *= 3; // Convert from triangle number to first vertex in indices

            hit.primitiveIndex = primitiveIndex;

            var geometry = object.geometry;
            var positionDecodeMat = geometry.positionDecodeMat;

            if (geometry.primitiveName === "triangles") {

                // Triangle picked; this only happens when the
                // GameObject has a Geometry that has primitives of type "triangle"

                hit.primitive = "triangle";

                // Find the local-space ray to test for intersection with the triangle

                if (worldRayPicking) { // Convert world-space picking ray to local-space ray
                    worldRayToLocalRay(object, worldRayOrigin, worldRayDir, localRayOrigin, localRayDir);

                } else  { // Convert canvas pos to local-space ray
                    canvasPosToLocalRay(canvas, object, canvasPos, localRayOrigin, localRayDir);
                }

                // Get triangle indices

                var indices = geometry.arrays.indices;

                var ia = indices[primitiveIndex];
                var ib = indices[primitiveIndex + 1];
                var ic = indices[primitiveIndex + 2];

                var ia3 = ia * 3;
                var ib3 = ib * 3;
                var ic3 = ic * 3;

                var triangleVertices = vec3.create();

                triangleVertices[0] = ia;
                triangleVertices[1] = ib;
                triangleVertices[2] = ic;

                hit.indices = triangleVertices;

                // Get World-space triangle vertex positions

                var morphGeometry = object.morphGeometry;
                var targets = morphGeometry.targets;

                if (targets && targets.length > 0 && targets[0].positions) {

                    // Positions from morphGeometry

                    this._lerpTargets(
                        morphGeometry.keys,
                        morphGeometry.targets,
                        "positions",
                        ia, ib, ic,
                        morphGeometry.factor,
                        a, b, c);

                } else {

                    // Positions from static geometry

                    var positions = geometry.arrays.positions;

                    a[0] = positions[ia3];
                    a[1] = positions[ia3 + 1];
                    a[2] = positions[ia3 + 2];

                    b[0] = positions[ib3];
                    b[1] = positions[ib3 + 1];
                    b[2] = positions[ib3 + 2];

                    c[0] = positions[ic3];
                    c[1] = positions[ic3 + 1];
                    c[2] = positions[ic3 + 2];

                    if (positionDecodeMat) {
                        SceneJS_math_decompressPosition(a, a, positionDecodeMat);
                        SceneJS_math_decompressPosition(b, b, positionDecodeMat);
                        SceneJS_math_decompressPosition(c, c, positionDecodeMat);
                    }
                }

                // Get Local-space cartesian coordinates of the ray-triangle intersection

                var position = hit.position = SceneJS_math_rayPlaneIntersect(localRayOrigin, localRayDir, a, b, c, vec3.create());

                // Get interpolated World-space coordinates

                // Need to transform homogeneous coords

                tempVec4.set(position);
                tempVec4[3] = 1;

                // Get World-space cartesian coordinates of the ray-triangle intersection

                vec4.transformMat4(tempVec4b, tempVec4, object.modelTransform.mat);

                hit.worldPos = SceneJS._sliceArray(tempVec4b, 0, 3);

                // Get barycentric coordinates of the ray-triangle intersection

                var barycentric = hit.barycentric = SceneJS_math_cartesianToBarycentric(position, a, b, c, vec3.create());

                // Get interpolated normal vector

                var gotNormals = false;

                if (targets && targets.length > 0 && targets[0].normals) {

                    // Normals from morphGeometry

                    this._lerpTargets(
                        morphGeometry.keys,
                        morphGeometry.targets,
                        "normals",
                        ia, ib, ic,
                        morphGeometry.factor,
                        na, nb, nc);

                    gotNormals = true;
                }

                if (!gotNormals) {

                    // Normals from static geometry

                    var normals = geometry.arrays.normals;

                    if (normals) {

                        if (geometry.compressedNormals) {

                            var ia2 = ia * 2;
                            var ib2 = ib * 2;
                            var ic2 = ic * 2;

                            var encna = normals.subarray(ia2, ia2 + 2);
                            var encnb = normals.subarray(ib2, ib2 + 2);
                            var encnc = normals.subarray(ic2, ic2 + 2);

                            SceneJS_math_octDecodeVec2(normals.subarray(ia2, ia2 + 2), na);
                            SceneJS_math_octDecodeVec2(normals.subarray(ib2, ib2 + 2), nb);
                            SceneJS_math_octDecodeVec2(normals.subarray(ic2, ic2 + 2), nc);

                        } else {

                            na[0] = normals[ia3];
                            na[1] = normals[ia3 + 1];
                            na[2] = normals[ia3 + 2];

                            nb[0] = normals[ib3];
                            nb[1] = normals[ib3 + 1];
                            nb[2] = normals[ib3 + 2];

                            nc[0] = normals[ic3];
                            nc[1] = normals[ic3 + 1];
                            nc[2] = normals[ic3 + 2];

                        }

                        gotNormals = true;
                    }
                }

                if (gotNormals) {

                    // Interpolate on triangle

                    hit.normal = vec3.create();
                    vec3.scale(hit.normal, na, barycentric[0]);
                    vec3.add(hit.normal, hit.normal, vec3.scale(tempVec3b, nb, barycentric[1]));
                    vec3.add(hit.normal, hit.normal, vec3.scale(tempVec3d, nc, barycentric[2]));
                }

                // Get interpolated UV coordinates in each UV layer

                var uvLayers = geometry.arrays.uvs;

                if (uvLayers && uvLayers.length > 0) {

                    hit.uvs = []; // TODO: Optimize for GC

                    var uvs;
                    var uv;
                    var ia2 = ia * 2;
                    var ib2 = ib * 2;
                    var ic2 = ic * 2;

                    for (i = 0, len = uvLayers.length; i < len; i++) {

                        uvs = uvLayers[i];

                        if (!uvs) {

                            uvs.push(null);

                        } else {

                            uva[0] = uvs[ia2];
                            uva[1] = uvs[ia2 + 1];

                            uvb[0] = uvs[ib2];
                            uvb[1] = uvs[ib2 + 1];

                            uvc[0] = uvs[ic2];
                            uvc[1] = uvs[ic2 + 1];

                            if (geometry.compressedUVs) {
                                var uvDecodeMat = geometry.uvDecodeMats[i];
                                SceneJS_math_decompressUV(uva, uva, uvDecodeMat);
                                SceneJS_math_decompressUV(uvb, uvb, uvDecodeMat);
                                SceneJS_math_decompressUV(uvc, uvc, uvDecodeMat);
                            }

                            uv = vec2.create();
                            vec2.scale(uv, uva, barycentric[0]);
                            vec2.add(uv, uv, vec2.scale(tempVec2b, uvb, barycentric[1]));
                            vec2.add(uv, uv, vec2.scale(tempVec2c, uvc, barycentric[2]));

                            hit.uvs.push(uv);
                        }
                    }

                    if (uvLayers.length > 0) {
                        hit.uv = hit.uvs[0]; // Backward compatibility
                    }
                }
            }
        }

        pickBuf.unbind();

        return hit;
    };

    SceneJS_Display.prototype._lerpTargets = function (times,
                                                       targets,
                                                       arrayName,
                                                       ia, ib, ic,
                                                       time,
                                                       a, b, c) {

        // Trivial case in which we can just return the
        // positions at a target matching the given time

        for (var i = 0; i < times.length; i++) {
            if (times[i] === time) {

                var array = targets[i][arrayName];

                var ia3 = ia * 3;
                var ib3 = ib * 3;
                var ic3 = ic * 3;

                a[0] = array[ia3];
                a[1] = array[ia3 + 1];
                a[2] = array[ia3 + 2];

                b[0] = array[ib3];
                b[1] = array[ib3 + 1];
                b[2] = array[ib3 + 2];

                c[0] = array[ic3];
                c[1] = array[ic3 + 1];
                c[2] = array[ic3 + 2];

                return;
            }
        }

        // Find the indexes of the targets that enclose the given time

        var i2 = 0;

        while (times[i2] < time) {
            i2++;
        }

        var i1 = i2 - 1;

        this._lerpTargetPair(
            time,
            times[i1],
            times[i2],
            targets[i1][arrayName],
            targets[i2][arrayName],
            ia, ib, ic,
            a, b, c
        );
    };

    var a1 = vec3.create();
    var b1 = vec3.create();
    var c1 = vec3.create();
    var a2 = vec3.create();
    var b2 = vec3.create();
    var c2 = vec3.create();

    SceneJS_Display.prototype._lerpTargetPair = function (time, time1, time2, target1, target2, ia, ib, ic, a, b, c) {

        var ia3 = ia * 3;
        var ib3 = ib * 3;
        var ic3 = ic * 3;

        a1[0] = target1[ia3];
        a1[1] = target1[ia3 + 1];
        a1[2] = target1[ia3 + 2];

        b1[0] = target1[ib3];
        b1[1] = target1[ib3 + 1];
        b1[2] = target1[ib3 + 2];

        c1[0] = target1[ic3];
        c1[1] = target1[ic3 + 1];
        c1[2] = target1[ic3 + 2];

        a2[0] = target2[ia3];
        a2[1] = target2[ia3 + 1];
        a2[2] = target2[ia3 + 2];

        b2[0] = target2[ib3];
        b2[1] = target2[ib3 + 1];
        b2[2] = target2[ib3 + 2];

        c2[0] = target2[ic3];
        c2[1] = target2[ic3 + 1];
        c2[2] = target2[ic3 + 2];

        var factor = (time - time1) / (time2 - time1);

        vec3.lerp(a, a1, a2, factor);
        vec3.lerp(b, b1, b2, factor);
        vec3.lerp(c, c1, c2, factor);
    };

})();

/** Renders either the draw or pick list.
 *
 * @param {*} params
 * @param {Boolean} params.clear Set true to clear the color, depth and stencil buffers first
 * @param {*} params.object Object to render chunks of, for pickTriangle or pickRegion modes
 * @param {Number} [params.pass=0] Which rendering pass we're drawing for (eg. left vs right eye)
 * @param {Boolean} params.pickObject Set true to render for object-picking, using per-object indexed color
 * @param {Boolean} params.pickTriangle Set true to render for triangle-picking, using per-triangle indexed color
 * @param {Boolean} params.pickRegion Set true to render for region-picking
 * @param {Boolean} params.transparent Set false to only render opaque objects
 * @private
 */
SceneJS_Display.prototype._doDrawList = (function() {

    var outlinedObjects = [];
    var lastChunkId = new Int32Array(30);

    var transparentObjects = [];
    var numTransparentObjects = 0;

    function clearStateTracking() {
        for (var i = 0; i < 20; i++) {
            lastChunkId[i] = -9999999999;
        }
    }

    function drawObject(frameCtx, object) {
        var chunks = object.chunks;
        var chunk;
        for (var j = 0, lenj = chunks.length; j < lenj; j++) {
            chunk = chunks[j];
            if (chunk) {
                if (chunk.draw && (chunk.unique || chunk.type === "properties"  || lastChunkId[j] !== chunk.id)) {
                    chunk.draw(frameCtx);
                    lastChunkId[j] = chunk.id;
                }
            }
        }
    }

    function pickObject(frameCtx, object) {
        var chunks = object.chunks;
        var chunk;
        for (var j = 0, lenj = chunks.length; j < lenj; j++) {
            chunk = chunks[j];
            if (chunk) {
                if (chunk.pick && (chunk.unique || lastChunkId[j] !== chunk.id)) {
                    chunk.pick(frameCtx);
                    lastChunkId[j] = chunk.id;
                }
            }
        }
    }

    return function (params) {

        var gl = this._canvas.gl;

        var frameCtx = this._frameCtx;

        frameCtx.pass = params.pass || 0;
        frameCtx.renderTarget = null;
        frameCtx.targetIndex = 0;
        frameCtx.viewMat = null;
        frameCtx.modelMat = null;
        frameCtx.cameraMat = null;
        frameCtx.highlightColor = this.highlightColor;
        frameCtx.desatParams = this.desatParams;
        frameCtx.fogParams = this.fogParams;
        frameCtx.fogColor = this.fogColor;
        frameCtx.fogMode = this.fogMode;
        frameCtx.fogEnabled = this.fogEnabled;
        frameCtx.xrayGlassFactor = this.xrayGlassFactor;
        frameCtx.xrayMurkiness = this.xrayMurkiness;
        frameCtx.xrayBGColor = this.xrayBGColor;
        frameCtx.scissorTestEnabled = false;
        frameCtx.backfaces = SceneJS.PROPERTY_FLAGS.BACKFACES;
        frameCtx.frontface = SceneJS.PROPERTY_FLAGS.CCW;
        frameCtx.picking = !!params.pickObject || !!params.pickTriangle || !!params.pickRegion;
        frameCtx.pickObject = !!params.pickObject;
        frameCtx.pickTriangle = !!params.pickTriangle;
        frameCtx.pickRegion = !!params.pickRegion;
        frameCtx.pickIndex = 1;
        frameCtx.textureUnit = 0;
        frameCtx.lineWidth = 1;
        frameCtx.transparent = 0;
        frameCtx.ambientColor = this._ambientColor;
        frameCtx.aspect = this._canvas.canvas.width / this._canvas.canvas.height;
        frameCtx.texture = null;
        frameCtx.hasNormalMap = false;
        frameCtx.regionMapUVLayerIdx = -1;
        frameCtx.drawElements = 0;
        frameCtx.drawArrays = 0;
        frameCtx.useProgram = 0;
        frameCtx.bindTexture = 0;
        frameCtx.bindArray = 0;
        frameCtx.pickViewMatrix = params.pickViewMatrix;
        frameCtx.pickProjMatrix = params.pickProjMatrix;

        // The extensions needs to be re-queried in case the context was lost and has been recreated.
        if (SceneJS.WEBGL_INFO.SUPPORTED_EXTENSIONS["OES_element_index_uint"]) {
            gl.getExtension("OES_element_index_uint");
        }

        var VAO = gl.getExtension("OES_vertex_array_object");
        frameCtx.VAO = (VAO) ? VAO : null;

        gl.viewport(this.viewport[0], this.viewport[1], this.viewport[2], this.viewport[3]);

        gl.enable(gl.DEPTH_TEST);
        gl.frontFace(gl.CCW);
        gl.disable(gl.CULL_FACE);
        gl.depthMask(true);

        if (this.transparent || frameCtx.picking) {
            gl.clearColor(0, 0, 0, 0);
        } else {
            gl.clearColor(this._ambientColor[0], this._ambientColor[1], this._ambientColor[2], 1.0);
        }

        if (params.clear) {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
        }

        var i;
        var len;
        var object;

        if (params.pickObject) {
            var pickListLen = 0;
            for (i = 0, len = this._objectListLen; i < len; i++) {
                object = this._objectList[i];
                if (object.properties.getFlag(SceneJS.PROPERTY_FLAGS.PICKING)) {
                    pickObject(frameCtx, object);
                    this._pickLookup[pickListLen++] = i;
                }
            }

        } else if (params.pickRegion || params.pickTriangle) {

            if (params.object) {
                pickObject(frameCtx, params.object);

            } else {
                var pickListLen = 0;
                if (params.pickRegion) {
                    for (i = 0, len = this._objectListLen; i < len; i++) {
                        object = this._objectList[i];
                        if (object.properties.getFlag(SceneJS.PROPERTY_FLAGS.PICKING)) {
                            pickObject(frameCtx, object);
                            this._pickLookup[pickListLen++] = i;
                        }
                    }
                }
            }

        } else { // Render scene

            var startTime = Date.now();
            var opaqueOnly = params.opaqueOnly;

            numTransparentObjects = 0;

            for (i = 0, len = this._objectListLen; i < len; i++) { // Render opaque objects
                object = this._objectList[i];
                if (object.isTransparent()) {
                    if (!opaqueOnly) {
                        transparentObjects[numTransparentObjects++] = object;
                    }
                } else {
                    drawObject(frameCtx, object);
                }
            }

            if (numTransparentObjects > 0) { // Render transparent objects

                gl.enable(gl.BLEND);
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

                for (i = 0; i < numTransparentObjects; i++) {
                    drawObject(frameCtx, transparentObjects[i]);
                    transparentObjects[i] = null; // Release memory
                }

                gl.disable(gl.BLEND);
            }

            var endTime = Date.now();

            this.stats.frame.drawElements = frameCtx.drawElements;
            this.stats.frame.drawArrays = frameCtx.drawArrays;
            this.stats.frame.useProgram = frameCtx.useProgram;
            this.stats.frame.bindTexture = frameCtx.bindTexture;
            this.stats.frame.bindArray = frameCtx.bindArray;
            this.stats.frame.drawChunks = this._drawListLen;
        }

        if (frameCtx.VAO) {
            frameCtx.VAO.bindVertexArrayOES(null);
            for (i = 0; i < 10; i++) {
                gl.disableVertexAttribArray(i);
            }
        }
//
//    var numTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
//    for (var ii = 0; ii < numTextureUnits; ++ii) {
//        gl.activeTexture(gl.TEXTURE0 + ii);
//        gl.bindTexture(gl.TEXTURE_CUBE_MAP, null);
//        gl.bindTexture(gl.TEXTURE_2D, null);
//    }
    };
})();

SceneJS_Display.prototype.readPixels = function (entries, size, opaqueOnly) {

    if (this._canvas.canvas.width == 0 || this._canvas.canvas.height == 0) {
        // Canvas hidden
        return;
    }

    if (!this._readPixelBuf) {
        this._readPixelBuf = new SceneJS._webgl.RenderBuffer({canvas: this._canvas});
    }

    this._readPixelBuf.bind();

    this._readPixelBuf.clear();

    this.prepareScene();
    this.render({
        force: true,
        opaqueOnly: opaqueOnly
    });

    var entry;
    var color;

    for (var i = 0; i < size; i++) {

        entry = entries[i] || (entries[i] = {});

        color = this._readPixelBuf.read(entry.x, entry.y);

        entry.r = color[0];
        entry.g = color[1];
        entry.b = color[2];
        entry.a = color[3];
    }

    this._readPixelBuf.unbind();
};

SceneJS_Display.prototype.destroy = function () {
    this._programFactory.destroy();
};
;/**
 * @class Manages creation, sharing and recycle of {@link SceneJS_ProgramSource} instances
 * @private
 */
var SceneJS_ProgramSourceFactory = new (function () {

    var DISPLAY_FLAGS = SceneJS.DISPLAY_FLAGS;
    var TEXTURE_FLAGS = SceneJS.TEXTURE_FLAGS;
    var PROPERTY_FLAGS = SceneJS.PROPERTY_FLAGS;

    var FRAG_HIGHP_SUPPORTED = SceneJS.WEBGL_INFO.FS_MAX_FLOAT_PRECISION === "highp";

    var cache = {}; // Source codes are shared across all scenes

    var states; // Cache rendering state
    var diffuseFresnel;
    var specularFresnel;
    var alphaFresnel;
    var reflectFresnel;
    var emitFresnel;
    var fragmentFresnel;
    var fresnel;
    var texturing;// True when rendering state contains textures
    var cubeMapping;
    var normals;// True when rendering state contains normals
    var solid;
    var skybox;  // True when object should be treated as a skybox
    var billboard;
    var tangents;
    var clipping;
    var morphing;
    var regionMapping;
    var regionInteraction;
    var depthTargeting;
    var points;
    var roundPoints;
    var quantizedPositions;
    var octNormals;
    var quantizedUVs;
    var xrayEnabled;
    var fogEnabled;
    var fogMode;

    var src = ""; // Accumulates source code as it's being built

    /**
     * Get sourcecode for a program to render the given states
     */
    this.getSource = function (hash, _states) {

        var source = cache[hash];
        if (source) {
            source.useCount++;
            return source;
        }

        states = _states;

        diffuseFresnel = states.fresnel.diffuse;
        specularFresnel = states.fresnel.specular;
        alphaFresnel = states.fresnel.alpha;
        reflectFresnel = states.fresnel.reflect;
        emitFresnel = states.fresnel.emit;
        fragmentFresnel = states.fresnel.fragment;
        fresnel = diffuseFresnel || specularFresnel || alphaFresnel || reflectFresnel || emitFresnel || fragmentFresnel;
        texturing = hasTextures(states);
        cubeMapping = hasCubemap(states);
        normals = hasNormals(states);
        clipping = states.clips.clips.length > 0;
        solid = clipping && !!(states.properties.flags & PROPERTY_FLAGS.SOLID);
        skybox = !!(states.properties.flags & PROPERTY_FLAGS.SKYBOX);
        billboard = !!(states.properties.flags & PROPERTY_FLAGS.BILLBOARD);
        tangents = hasTangents(states);
        morphing = !!states.morphGeometry.targets;
        regionMapping = hasRegionMap();
        regionInteraction = regionMapping && states.regionMap.mode !== "info";
        depthTargeting = hasDepthTarget();
        points = states.geometry.primitiveName === "points";
        roundPoints = !!(states.properties.flags & PROPERTY_FLAGS.ROUND_POINTS);
        quantizedPositions = !!(states.geometry.compressedPositions || states.morphGeometry.compressedPositions);
        octNormals = !!(states.geometry.compressedNormals || states.morphGeometry.compressedNormals);
        quantizedUVs = !!(states.geometry.compressedUVs || states.morphGeometry.compressedUVs);
        xrayEnabled = normals && !!(states.properties.flags & PROPERTY_FLAGS.XRAY_ENABLED);
        fogEnabled = states.fogEnabled;
        fogMode = states.fogMode;

        source = new SceneJS_ProgramSource(
            hash,

            vertexPicking(states),
            fragmentPicking(states),

            vertexRendering(states),
            fragmentRendering(states)
        );

        cache[hash] = source;

        return source;
    };

    /**
     * Releases program source code
     */
    this.putSource = function (hash) {
        var source = cache[hash];
        if (source) {
            if (--source.useCount == 0) {
                cache[source.hash] = null;
            }
        }
    };

    function vertexPicking() {

        begin();

        add("attribute vec4 SCENEJS_aVertex;");
        add("attribute vec4 SCENEJS_aColor;");
        add("uniform mat4 SCENEJS_uMMatrix;");
        add("uniform mat4 SCENEJS_uVMatrix;");
        add("uniform mat4 SCENEJS_uPMatrix;");

        if (points) {
            add("uniform float SCENEJS_uPointSize;");
        }

        if (quantizedPositions) {
            add("uniform mat4 SCENEJS_uDecodePositionMatrix;");
        }

        add("varying vec4 SCENEJS_vWorldVertex;");

        if (regionMapping) {
            add("attribute vec2 SCENEJS_aRegionMapUV;");
            add("varying vec2 SCENEJS_vRegionMapUV;");
        }

        if (morphing) {
            add("uniform float SCENEJS_uMorphFactor;");       // LERP factor for morph
            if (states.morphGeometry.targets[0].vertexBuf) {      // target2 has these arrays also
                add("attribute vec4 SCENEJS_aMorphVertex;");
            }

            if (quantizedPositions) {
                add("uniform mat4 SCENEJS_uDecodeMorphPosMatrix;");
            }
        }

        add("varying vec4 SCENEJS_vColor;");

        add("void main(void) {");

        if (quantizedPositions) {
            add("    vec4 modelVertex = SCENEJS_uDecodePositionMatrix * SCENEJS_aVertex;");
        } else {
            add("    vec4 modelVertex = SCENEJS_aVertex;");
        }

        if (morphing) {
            if (states.morphGeometry.targets[0].vertexBuf) {
                if (quantizedPositions) {
                    add("  modelVertex = mix(modelVertex, SCENEJS_uDecodeMorphPosMatrix * SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                } else {
                    add("  modelVertex = mix(modelVertex, SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                }
            }
        }
        add("  SCENEJS_vWorldVertex = SCENEJS_uMMatrix * modelVertex; ");

        add("mat4 vPosMatrix = SCENEJS_uVMatrix;");

        if (skybox) {
            add("vPosMatrix[3].xyz = vec3(0.0);");
        }

        add("  gl_Position =  SCENEJS_uPMatrix * (vPosMatrix * SCENEJS_vWorldVertex);");

        if (regionMapping) {
            add("SCENEJS_vRegionMapUV = SCENEJS_aRegionMapUV;");
        }

        add("SCENEJS_vColor = SCENEJS_aColor;");

        if (points) {
            add("gl_PointSize = SCENEJS_uPointSize;");
        }

        add("}");

        return end();
    }

    function fragmentPicking() {

        begin();

        add("precision " + SceneJS.WEBGL_INFO.FS_MAX_FLOAT_PRECISION + " float;");

        add("varying vec4 SCENEJS_vWorldVertex;");
        add("varying vec4  SCENEJS_vColor;");

        add("uniform float  SCENEJS_uPickMode;");                   // Z-pick mode when true else colour-pick
        add("uniform vec4  SCENEJS_uPickColor;");                   // Used in colour-pick mode
        add("uniform bool  SCENEJS_uClipping;");

        if (clipping) {
            for (var i = 0; i < states.clips.clips.length; i++) {
                add("uniform float SCENEJS_uClipMode" + i + ";");
                add("uniform vec4  SCENEJS_uClipNormalAndDist" + i + ";");
            }
        }

        if (regionMapping) {
            add("varying vec2 SCENEJS_vRegionMapUV;");
            add("uniform sampler2D SCENEJS_uRegionMapSampler;");
        }

        add("void main(void) {");

        if (clipping) {
            add("if (SCENEJS_uClipping) {");
            add("  float dist = 0.0;");
            for (var i = 0; i < states.clips.clips.length; i++) {
                add("  if (SCENEJS_uClipMode" + i + " != 0.0) {");
                add("      dist += clamp(dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) - SCENEJS_uClipNormalAndDist" + i + ".w, 0.0, 1000.0);");
                add("  }");
            }
            add("  if (dist > 0.0) { discard; }");
            add("}");
        }

        add("    if  (SCENEJS_uPickMode == 0.0) {");  // Pick object
        add("          gl_FragColor = SCENEJS_uPickColor;  ");

        add("    } else if (SCENEJS_uPickMode == 1.0) {"); // Pick triangle
        add("          gl_FragColor = SCENEJS_vColor;  ");

        add("    } else {"); // Pick region
        if (regionMapping) {
            add("          gl_FragColor = texture2D(SCENEJS_uRegionMapSampler, vec2(SCENEJS_vRegionMapUV.s, SCENEJS_vRegionMapUV.t));");
        } else {
            add("          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);");
        }
        add("    }");
        add("}");

        return end();
    }

    function hasRegionMap() {
        if (!states.regionMap.empty) {
            return hasUVs();
        }
        return false;
    }

    function hasTextures() {
        if (states.texture.layers && states.texture.layers.length > 0) {
            return hasUVs();
        }
        return false;
    }

    function hasUVs() {
        if (states.geometry.uvBufs) { // TODO only if there is at least one defined member in this array
            return true;
        }
        if (states.morphGeometry.targets && (states.morphGeometry.targets[0].uvBuf || states.morphGeometry.targets[0].uvBuf2)) {
            return true;
        }
        return false;
    }

    function hasCubemap(states) {
        return (states.properties.getFlag(PROPERTY_FLAGS.REFLECTIVE) && states.cubemap.layers && states.cubemap.layers.length > 0 && states.geometry.normalBuf);
    }

    function hasNormals(states) {
        if (states.geometry.normalBuf) {
            return true;
        }
        if (states.morphGeometry.targets && states.morphGeometry.targets[0].normalBuf) {
            return true;
        }
        return false;
    }

    function hasTangents(states) {
        if (states.texture) {
            var layers = states.texture.layers;
            if (!layers) {
                return false;
            }
            for (var i = 0, len = layers.length; i < len; i++) {
                if (layers[i].flags & TEXTURE_FLAGS.normals) {
                    return true;
                }
            }
        }
        return false;
    }

    function hasDepthTarget() {
        if (states.renderTarget && states.renderTarget.targets) {
            var targets = states.renderTarget.targets;
            for (var i = 0, len = targets.length; i < len; i++) {
                if (targets[i].bufType === "depth") {
                    return true;
                }
            }
        }
        return false;
    }

    function vertexRendering() {

        var i;
        var uvBufs;

        begin();

        add("uniform mat4 SCENEJS_uMMatrix;");             // Model matrix
        
        if (FRAG_HIGHP_SUPPORTED) {  
            add("uniform mat4 SCENEJS_uVMatrix;");             // View matrix
        } else {
            add("uniform mediump mat4 SCENEJS_uVMatrix;");             // View matrix
        }
        
        add("uniform mat4 SCENEJS_uPMatrix;");             // Projection matrix

        add("attribute vec4 SCENEJS_aVertex;");            // Model coordinates
        
        if (FRAG_HIGHP_SUPPORTED) {  
            add("uniform vec3 SCENEJS_uWorldEye;");            // World-space eye position
        } else {
            add("uniform mediump vec3 SCENEJS_uWorldEye;");
        }

        add("varying vec3 SCENEJS_vViewEyeVec;");          // View-space vector from origin to eye

        if (points) {
            add("uniform float SCENEJS_uPointSize;");
        }

        if (quantizedPositions) {
            add("uniform mat4 SCENEJS_uDecodePositionMatrix;");
        }

        if (normals) {
            add("attribute vec3 SCENEJS_aNormal;");        // Normal vectors
            add("uniform   mat4 SCENEJS_uMNMatrix;");      // Model normal matrix

            add("varying   vec3 SCENEJS_vViewNormal;");    // Output view-space vertex normal

            if (fresnel || cubeMapping) {
                add("varying   vec3 SCENEJS_vWorldNormal;");    // Output view-space vertex normal
            }

            if (tangents) {
                add("attribute vec3 SCENEJS_aTangent;"); // Pass through to frag
                add("varying   vec3 SCENEJS_vTangent;");
            }
        }

        if (texturing) {

            uvBufs = states.geometry.uvBufs;

            if (uvBufs) {
                for (var i = 0, len = uvBufs.length; i < len; i++) {
                    if (uvBufs[i]) {
                        add("attribute vec2 SCENEJS_aUVCoord" + i + ";");
                        if (quantizedUVs) {
                            add("uniform mat3 SCENEJS_uDecodeUVMatrix" + i + ";")
                        }
                    }
                }
            }
        }

        if (states.geometry.colorBuf) {
            add("attribute vec4 SCENEJS_aVertexColor;");
            add("varying vec4 SCENEJS_vColor;");               // Varying for fragment texturing
        }

        if (clipping || normals) {
            add("varying vec4 SCENEJS_vWorldVertex;");         // Varying for fragment clip or world pos hook
        }

        add("varying vec4 SCENEJS_vViewVertex;");              // Varying for fragment view clip hook

        if ( texturing) {                                            // Varyings for fragment texturing

            uvBufs = states.geometry.uvBufs;

            if (uvBufs) {
                for (i = 0, len = uvBufs.length; i < len; i++) {
                    if (uvBufs[i]) {
                        add("varying vec2 SCENEJS_vUVCoord" + i + ";");
                    }
                }
            }
        }

        if (regionInteraction) {
            add("attribute vec2 SCENEJS_aRegionMapUV;");
            add("varying vec2 SCENEJS_vRegionMapUV;");
        }

        if (morphing) {
            add("uniform float SCENEJS_uMorphFactor;");       // LERP factor for morph
            if (states.morphGeometry.targets[0].vertexBuf) {      // target2 has these arrays also
                add("attribute vec4 SCENEJS_aMorphVertex;");
            }
            if (normals) {
                if (states.morphGeometry.targets[0].normalBuf) {
                    add("attribute vec3 SCENEJS_aMorphNormal;");
                }
            }
            if (tangents) {
                //if (states.morphGeometry.targets[0].normalBuf) {
                    add("attribute vec3 SCENEJS_aMorphTangent;");
               // }
            }

            if (quantizedPositions) {
                add("uniform mat4 SCENEJS_uDecodeMorphPosMatrix;");
            }
        }

        if (billboard) {

            // Billboarding function which modifies the rotation
            // elements of the given matrix

            add("void billboard(inout mat4 mat) {");
            add("   mat[0].xyz = vec3(1.0, 0.0, 0.0);");
            add("   mat[1].xyz = vec3(0.0, 1.0, 0.0);");
            add("   mat[2].xyz = vec3(0.0, 0.0, 1.0);");
            add("}");
        }

        if (octNormals) {
            add("vec3 octDecode(vec2 oct) {");
            add("    vec3 v = vec3(oct.xy, 1.0 - abs(oct.x) - abs(oct.y));");
            add("    if (v.z < 0.0) {");
            add("        v.xy = (1.0 - abs(v.yx)) * vec2(v.x >= 0.0 ? 1.0 : -1.0, v.y >= 0.0 ? 1.0 : -1.0);");
            add("    }");
            add("    return normalize(v);");
            add("}");
        }

        add("void main(void) {");

        if (tangents) {
            add("vec3 modelTangent = SCENEJS_aTangent;");
        }


        if (quantizedPositions) {
            add("  vec4 modelVertex = SCENEJS_uDecodePositionMatrix * SCENEJS_aVertex;");
        } else {
            add("  vec4 modelVertex = SCENEJS_aVertex; ");
        }

        if (octNormals) {
            add("  vec4 modelNormal = vec4(octDecode(SCENEJS_aNormal.xy), 0.0); ");
        } else if (normals) {
            add("  vec4 modelNormal = vec4(SCENEJS_aNormal, 0.0); ");
        }

        // Morphing - morph targets are in same model space as the geometry
        if (morphing) {
            if (states.morphGeometry.targets[0].vertexBuf) {
                if (quantizedPositions) {
                    add("  modelVertex = mix(modelVertex, SCENEJS_uDecodeMorphPosMatrix * SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                } else {
                    add("  modelVertex = mix(modelVertex, SCENEJS_aMorphVertex, SCENEJS_uMorphFactor); ");
                }
            }
            if (normals) {
                if (states.morphGeometry.targets[0].normalBuf) {
                    if (octNormals) {
                        add("  modelNormal = vec4( mix(modelNormal.xyz, octDecode(SCENEJS_aMorphNormal.xy), SCENEJS_uMorphFactor), 0.0); ");
                    } else {
                        add("  modelNormal = vec4( mix(modelNormal.xyz, SCENEJS_aMorphNormal, SCENEJS_uMorphFactor), 0.0); ");
                    }
                }
            }
            if (tangents) {
                add("  modelTangent = mix(modelTangent, SCENEJS_aMorphTangent, SCENEJS_uMorphFactor); ");
            }
        }

        add("mat4 modelMatrix = SCENEJS_uMMatrix;");
        add("mat4 viewMatrix = SCENEJS_uVMatrix;");

        if (normals) {
            add("mat4 modelNormalMatrix = SCENEJS_uMNMatrix;");
        }

        add("vec4 worldVertex;");
        add("vec4 viewVertex;");

        if (skybox) {
            add("viewMatrix[3].xyz = vec3(0.0);");
        }

        if (billboard) {

            // Since billboard effect is not preserved
            // in the product of two billboarded matrices,
            // we need to get the product of the model and
            // view matrices and billboard that

            add("   mat4 modelViewMatrix =  viewMatrix * modelMatrix;");

            add("   billboard(modelMatrix);");
            add("   billboard(viewMatrix);");
            add("   billboard(modelViewMatrix);");

            if (normals) {
                add("   billboard(modelNormalMatrix);");
            }

            add("   worldVertex = modelMatrix * modelVertex;");
            add("   viewVertex = modelViewMatrix * modelVertex;");

        } else {

            add("  worldVertex = modelMatrix * modelVertex;");
            add("  viewVertex  = viewMatrix * worldVertex; ");
        }

        if (normals) {
            add("  vec3 worldNormal = (modelNormalMatrix * modelNormal).xyz; ");
            add("  SCENEJS_vViewNormal = (viewMatrix * vec4(worldNormal, 0.0)).xyz;");

            if (fresnel || cubeMapping) {
                add("  SCENEJS_vWorldNormal = worldNormal;");
            }
        }

        if (clipping || normals) {
            add("  SCENEJS_vWorldVertex = worldVertex;");
        }

        add("  SCENEJS_vViewVertex = viewVertex;");

        add("  gl_Position = SCENEJS_uPMatrix * viewVertex;");

        if (tangents) {
            add("SCENEJS_vTangent = modelTangent;");
        }

        add("SCENEJS_vViewEyeVec = ((viewMatrix * vec4(SCENEJS_uWorldEye, 0.0)).xyz  - viewVertex.xyz);");

        if (texturing) {

            uvBufs = states.geometry.uvBufs;

            if (uvBufs) {
                for (i = 0, len = uvBufs.length; i < len; i++) {
                    if (uvBufs[i]) {
                        if (quantizedUVs) {
                            add("SCENEJS_vUVCoord" + i + " = (SCENEJS_uDecodeUVMatrix" + i + " * vec3(SCENEJS_aUVCoord" + i + ", 1.0)).xy;");
                        } else {
                            add("SCENEJS_vUVCoord" + i + " = SCENEJS_aUVCoord" + i + ";");
                        }
                    }
                }
            }
        }

        if (states.geometry.colorBuf) {
            add("SCENEJS_vColor = SCENEJS_aVertexColor;");
        }

        if (regionInteraction) {
            add("SCENEJS_vRegionMapUV = SCENEJS_aRegionMapUV;");
        }

        if (points) {
            add("gl_PointSize = SCENEJS_uPointSize;");
        }

        add("}");

        return end();
    }


    /*-----------------------------------------------------------------------------------------------------------------
     * Rendering Fragment shader
     *---------------------------------------------------------------------------------------------------------------*/

    function fragmentRendering() {

        var diffuseFresnel = states.fresnel.diffuse;
        var specularFresnel = states.fresnel.specular;
        var alphaFresnel = states.fresnel.alpha;
        var reflectFresnel = states.fresnel.reflect;
        var emitFresnel = states.fresnel.emit;
        var fragmentFresnel = states.fresnel.fragment;

        begin();

        add("precision " + SceneJS.WEBGL_INFO.FS_MAX_FLOAT_PRECISION + " float;");

        add("uniform mat4 SCENEJS_uVMatrix;");
        add("uniform mat4 SCENEJS_uMMatrix;");             // Model matrix

        if (clipping || normals) {
            add("varying vec4 SCENEJS_vWorldVertex;");             // World-space vertex
        }

        add("varying vec4 SCENEJS_vViewVertex;");              // View-space vertex

        add("uniform float SCENEJS_uZNear;");                      // Used in Z-pick mode
        add("uniform float SCENEJS_uZFar;");                       // Used in Z-pick mode

        add("uniform vec3 SCENEJS_uWorldEye;");

        /*-----------------------------------------------------------------------------------
         * Variables
         *----------------------------------------------------------------------------------*/

        if (clipping) {
            for (var i = 0; i < states.clips.clips.length; i++) {
                add("uniform float SCENEJS_uClipMode" + i + ";");
                add("uniform vec4  SCENEJS_uClipNormalAndDist" + i + ";");
            }
        }

        if (texturing) {
            var uvBufs = states.geometry.uvBufs;
            if (uvBufs) {
                for (var i = 0, len = uvBufs.length; i < len; i++) {
                    if (uvBufs[i]) {
                        add("varying vec2  SCENEJS_vUVCoord" + i + ";");
                    }
                }
            }

            if (texturing) {
                var layer;
                for (var i = 0, len = states.texture.layers.length; i < len; i++) {
                    layer = states.texture.layers[i];
                    add("uniform sampler2D SCENEJS_uSampler" + i + ";");
                    if (layer.matrix) {
                        add("uniform mat4 SCENEJS_uLayer" + i + "Matrix;");
                    }
                    add("uniform float SCENEJS_uLayer" + i + "BlendFactor;");
                }
            }
        }

        if (normals && cubeMapping) {

            var layer;
            for (var i = 0, len = states.cubemap.layers.length; i < len; i++) {
                layer = states.cubemap.layers[i];
                add("uniform samplerCube SCENEJS_uCubeMapSampler" + i + ";");
                add("uniform float SCENEJS_uCubeMapIntensity" + i + ";");
            }
        }

        if (regionInteraction) {
            add("varying vec2 SCENEJS_vRegionMapUV;");
            add("uniform sampler2D SCENEJS_uRegionMapSampler;");
            add("uniform vec3 SCENEJS_uRegionMapRegionColor;");
            add("uniform vec3 SCENEJS_uRegionMapHighlightFactor;");
            add("uniform float SCENEJS_uRegionMapHideAlpha;");
        }

        if (tangents) {
            add("varying vec3 SCENEJS_vTangent;");
        }

        // True when lighting
        add("uniform vec4  SCENEJS_uClippingParams;");

        // Added in v4.0 to support depth targets
        add("uniform bool  SCENEJS_uDepthMode;");

        /* Vertex color variable
         */
        if (states.geometry.colorBuf) {
            add("varying vec4 SCENEJS_vColor;");
        }

        add("uniform vec3  SCENEJS_uAmbientColor;");                         // Scene ambient colour - taken from clear colour

        add("uniform vec4  SCENEJS_uMaterialColor;");
        add("uniform vec4  SCENEJS_uMaterialSpecularColor;");
        add("uniform vec4  SCENEJS_uMaterialEmitColor;");

        add("uniform float SCENEJS_uMaterialShine;");

        if (diffuseFresnel) {
            add("uniform vec4 SCENEJS_uDiffuseFresnelCenterColor;");
            add("uniform vec4 SCENEJS_uDiffuseFresnelEdgeColor;");
            add("uniform float SCENEJS_uDiffuseFresnelPower;");
        }

        if (specularFresnel) {
            add("uniform vec4 SCENEJS_uSpecularFresnelCenterColor;");
            add("uniform vec4 SCENEJS_uSpecularFresnelEdgeColor;");
            add("uniform float SCENEJS_uSpecularFresnelPower;");
        }

        if (alphaFresnel) {
            add("uniform vec4 SCENEJS_uAlphaFresnelCenterColor;");
            add("uniform vec4 SCENEJS_uAlphaFresnelEdgeColor;");
            add("uniform float SCENEJS_uAlphaFresnelPower;");
        }

        if (reflectFresnel) {
            add("uniform vec4 SCENEJS_uReflectFresnelCenterColor;");
            add("uniform vec4 SCENEJS_uReflectFresnelEdgeColor;");
            add("uniform float SCENEJS_uReflectFresnelPower;");
        }

        if (emitFresnel) {
            add("uniform vec4 SCENEJS_uEmitFresnelCenterColor;");
            add("uniform vec4 SCENEJS_uEmitFresnelEdgeColor;");
            add("uniform float SCENEJS_uEmitFresnelPower;");
        }

        if (fragmentFresnel) {
            add("uniform vec4 SCENEJS_uFragmentFresnelCenterColor;");
            add("uniform vec4 SCENEJS_uFragmentFresnelEdgeColor;");
            add("uniform float SCENEJS_uFragmentFresnelPower;");
        }

        add("varying vec3 SCENEJS_vViewEyeVec;");                          // Direction of world-space vertex from eye

        if (normals) {

            add("varying vec3 SCENEJS_vViewNormal;");

            if (fresnel || cubeMapping) {
                add("varying vec3 SCENEJS_vWorldNormal;");
            }

            var light;
            for (var i = 0; i < states.lights.lights.length; i++) {
                light = states.lights.lights[i];
                if (light.mode == "ambient") {
                    continue;
                }
                add("uniform vec3  SCENEJS_uLightColor" + i + ";");

                if (light.mode == "dir") {
                    add("uniform vec3 SCENEJS_uLightDir" + i + ";");
                }

                if (light.mode == "point") {
                    add("uniform vec3  SCENEJS_uLightAttenuation" + i + ";");
                    add("uniform vec3 SCENEJS_uLightPos" + i + ";");
                }

                if (light.mode == "spot") {
                    add("uniform vec3  SCENEJS_uLightAttenuation" + i + ";");
                    add("uniform vec3 SCENEJS_uLightPos" + i + ";");
                    add("uniform vec3 SCENEJS_uLightDir" + i + ";");
                    add("uniform float SCENEJS_uInnerCone" + i + ";");
                    add("uniform float SCENEJS_uOuterCone" + i + ";");
                }

            }
        }

        if (xrayEnabled) {
            add("uniform float SCENEJS_uXrayGlassFactor;");
            add("uniform float SCENEJS_uXrayMurkiness;");
            add("uniform vec3  SCENEJS_uXrayBGColor;");
            add("uniform vec4  SCENEJS_uXrayParams;"); // x = xray, y = glassfactor, z = murkiness, w = opacity
        }
        
        add("uniform vec3 SCENEJS_uTintColor;");
        add("uniform vec3 SCENEJS_uColorParams;"); // x = saturation, y = contrast, z = brightness

        if (fogEnabled) {
            add("uniform vec4   SCENEJS_uFogParams;"); // x = start, y = end, z = min, w = max
            add("uniform vec4   SCENEJS_uFogColor;"); // RGB = color, a = density
        }

        if (diffuseFresnel || specularFresnel || alphaFresnel || reflectFresnel || emitFresnel || fragmentFresnel) {
            add("float fresnel(vec3 viewDirection, vec3 worldNormal, float edgeBias, float centerBias, float power) {");
            add("    float fr = abs(dot(viewDirection, worldNormal));");
            add("    float finalFr = clamp((fr - edgeBias) / (centerBias - edgeBias), 0.0, 1.0);");
            add("    return pow(finalFr, power);");
            add("}");
        }

        add("void main(void) {");

        // World-space arbitrary clipping planes

        if (clipping) {
            add("if (bool(SCENEJS_uClippingParams.w)) {");
            add("  float dist = 0.0;");
            for (var i = 0; i < states.clips.clips.length; i++) {
                add("  if (SCENEJS_uClipMode" + i + " != 0.0) {");
                add("      dist += clamp(dot(SCENEJS_vWorldVertex.xyz, SCENEJS_uClipNormalAndDist" + i + ".xyz) - SCENEJS_uClipNormalAndDist" + i + ".w, 0.0, 1000.0);");
                add("  }");
            }
            add("  if (dist > 0.0) { discard; }");
            add("}");
        }

        if (points && roundPoints) {
            add("vec2 cxy = 2.0 * gl_PointCoord - 1.0;");
            add("float r = dot(cxy, cxy);");
            add("if (r > 1.0) {");
            add("   discard;");
            add("}");
        }

        if (normals) {
            add("vec3 worldEyeVec = normalize(SCENEJS_uWorldEye - SCENEJS_vWorldVertex.xyz);");            // World-space eye position

            if (fresnel || cubeMapping) {
                add("vec3 worldNormal = normalize(SCENEJS_vWorldNormal); ")
            }

            if (solid) {

                add("  if (gl_FrontFacing == false) {");
                add("     gl_FragColor = vec4(SCENEJS_uClippingParams.rgb, 1.0);");
                add("     return;");
                add("  }");
            }
        }

        add("  vec3 ambient= SCENEJS_uAmbientColor;");

        if (states.geometry.colorBuf) {
            add("  vec3    color   = SCENEJS_vColor.rgb;");
            add("  float   colorA  = SCENEJS_vColor.a;");
        } else {
            add("  vec3    color   = SCENEJS_uMaterialColor.rgb;")
        }

        add("  float alpha         = SCENEJS_uMaterialColor.a;");
        add("  float emit          = SCENEJS_uMaterialEmitColor.a;");
        add("  float specular      = SCENEJS_uMaterialSpecularColor.a;");
        add("  vec3  specularColor = SCENEJS_uMaterialSpecularColor.rgb;");
        add("  vec3  emitColor     = SCENEJS_uMaterialEmitColor.rgb;");
        add("  float shine         = SCENEJS_uMaterialShine;");

        if (states.geometry.colorBuf) {
            add("alpha *= colorA;");
        }

        if (normals) {
            add("  float   attenuation = 1.0;");
            if (tangents) {
                add("  vec3    viewNormalVec = vec3(0.0, 0.0, 0.0);");
            } else {

                // Normalize the interpolated normals in the per-fragment-fragment-shader,
                // because if we linear interpolated two nonparallel normalized vectors, the resulting vector won’t be of length 1
                add("  vec3    viewNormalVec = normalize(SCENEJS_vViewNormal);");
            }
            add("vec3 viewEyeVec = normalize(SCENEJS_vViewEyeVec);");
        }


        if (xrayEnabled) {
            add("bool xray = bool(SCENEJS_uXrayParams.x);");
            add("if (xray) {");
            add("    alpha = 1.0;");
            // If in transparency mode, set transparency to lowest among 'opacity' and 'alpha'
            add("} else {");
            add("    float glassfactor = SCENEJS_uXrayParams.y;");
            add("    float murkiness = SCENEJS_uXrayParams.z;");
            add("    float opacity = SCENEJS_uXrayParams.w;");
            add("    alpha = min(alpha, opacity);");
            add("    float gf = (glassfactor  * (murkiness - abs(dot(SCENEJS_vViewNormal, vec3(0.0, 0.0, -1.0)))));");
            add("    alpha = max(alpha, gf);");
            add("}");
        }

        if (normals && tangents) {
            add("mat3 mat =  mat3(SCENEJS_uVMatrix * SCENEJS_uMMatrix);");
            add("vec3 n = normalize(SCENEJS_vViewNormal);");
            add("vec3 t = normalize(mat * SCENEJS_vTangent);");
            add("vec3 b = normalize(cross(SCENEJS_vViewNormal, mat * SCENEJS_vTangent));");
            add("mat3 TBN = mat3(t, b, n);");
        }

        var layer;

        if (texturing) {

            add("  vec2    textureCoord;");

            // ------------ Texture maps ------------------------------------

            var firstNormal = true;

            for (var i = 0, len = states.texture.layers.length; i < len; i++) {
                layer = states.texture.layers[i];

                // Texture input

                // Apply from UV layers
                var uvLayerIndex = layer.uvLayerIdx || 0;
                var uvBufs = states.geometry.uvBufs;

                if (uvBufs[uvLayerIndex]) {
                    add("textureCoord = SCENEJS_vUVCoord" + uvLayerIndex + ";");
                } else {
                    SceneJS.log.warn("Texture layer applyTo='uv' but geometry has no UV coordinates for layer " + uvLayerIndex);
                    continue;
                }

                /* Texture matrix
                 */
                if (layer.matrix) {
                    add("textureCoord=(SCENEJS_uLayer" + i + "Matrix * vec4(textureCoord, 1.0, 1.0)).xy;");
                }

                if (layer.compressed) {
                    add("textureCoord.y = 1.0 - textureCoord.y;");
                }

                /* Alpha from Texture
                 */
                if (layer.flags & TEXTURE_FLAGS.alpha) {
                    if (layer.flags & TEXTURE_FLAGS.multiply) {
                        add("alpha *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                    } else if (layer.flags & TEXTURE_FLAGS.add) {
                        add("alpha += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).r;");
                    } else if (layer.flags & TEXTURE_FLAGS.over) {
                        add("alpha = mix(alpha, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                    }
                }

                /* Texture output
                 */
                if (layer.flags & TEXTURE_FLAGS.baseColor) {
                    if (layer.flags & TEXTURE_FLAGS.multiply) {
                        add("color *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb);");
                    } else if (layer.flags & TEXTURE_FLAGS.add) {
                        add("color += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb;")
                    } else if (layer.flags & TEXTURE_FLAGS.over) {
                        add("color = mix(color, texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                    }
                }

                if (layer.flags & TEXTURE_FLAGS.emit) {
                    if (layer.flags & TEXTURE_FLAGS.multiply) {
                        add("emitColor *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb);");
                    } else if (layer.flags & TEXTURE_FLAGS.add) {
                        add("emitColor += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb;");
                    } else if (layer.flags & TEXTURE_FLAGS.over) {
                        add("emitColor = mix(emitColor, texture2D(SCENEJS_uSampler" + i + ", textureCoord).rgb, SCENEJS_uLayer" + i + "BlendFactor);");
                    }
                }

                if ((layer.flags & TEXTURE_FLAGS.specular) && normals) {
                    if (layer.flags & TEXTURE_FLAGS.multiply) {
                        add("specular *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                    } else if (layer.flags & TEXTURE_FLAGS.add) {
                        add("specular += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).r;");
                    } else if (layer.flags & TEXTURE_FLAGS.over) {
                        add("specular = mix(specular, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                    }
                }

                if (layer.flags & TEXTURE_FLAGS.shine) {
                    if (layer.flags & TEXTURE_FLAGS.multiply) {
                        add("shine *= 1.0 - SCENEJS_uLayer" + i + "BlendFactor * (1.0 - texture2D(SCENEJS_uSampler" + i + ", textureCoord).r);");
                    } else if (layer.flags & TEXTURE_FLAGS.add) {
                        add("shine += SCENEJS_uLayer" + i + "BlendFactor * texture2D(SCENEJS_uSampler" + i + ", textureCoord).r;");
                    } else if (layer.flags & TEXTURE_FLAGS.over) {
                        add("shine = mix((shine, texture2D(SCENEJS_uSampler" + i + ", textureCoord).r, SCENEJS_uLayer" + i + "BlendFactor);");
                    }
                }

                if ((layer.flags & TEXTURE_FLAGS.normals) && normals) {
                    var op;
                    
                    if (layer.flags & TEXTURE_FLAGS.add) {
                        op = firstNormal ? "=" : "+=";
                        add("viewNormalVec " + op + " (TBN * normalize(texture2D(SCENEJS_uSampler" + i + ", textureCoord).xyz * 2.0 - 1.0)) * SCENEJS_uLayer" + i + "BlendFactor;");
                    } else {
                        add("viewNormalVec = mix(viewNormalVec, TBN * normalize(texture2D(SCENEJS_uSampler" + i + ", textureCoord).xyz * 2.0 - 1.0), SCENEJS_uLayer" + i + "BlendFactor);");
                    }

                    firstNormal = false;
                }
            }

            if (tangents) {
                add("viewNormalVec = normalize(viewNormalVec);")
            }
        }

        if (normals && cubeMapping) {
            add("float reflectFactor = 1.0;");

            if (reflectFresnel) {
                add("float reflectFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uReflectFresnelEdgeColor.a,  SCENEJS_uReflectFresnelCenterColor.a, SCENEJS_uReflectFresnelPower);");
                
                if (reflectFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                    add("reflectFactor *= mix(SCENEJS_uReflectFresnelEdgeColor.b, SCENEJS_uReflectFresnelCenterColor.b, reflectFresnel);");
                } else if (reflectFresnel.blendMode & TEXTURE_FLAGS.add) {
                    add("reflectFactor += mix(SCENEJS_uReflectFresnelEdgeColor.b, SCENEJS_uReflectFresnelCenterColor.b, reflectFresnel);");
                }
            }

            add("vec3 envLookup = reflect(-viewEyeVec, viewNormalVec);");

            add("vec4 envColor;");
            for (var i = 0, len = states.cubemap.layers.length; i < len; i++) {
                layer = states.cubemap.layers[i];
                add("envColor = textureCube(SCENEJS_uCubeMapSampler" + i + ", envLookup);");
                add("color = mix(color, envColor.rgb, reflectFactor * specular * SCENEJS_uCubeMapIntensity" + i + ");");
            }
        }

        add("  vec4    fragColor;");

        if (normals) {

            add("  vec3    lightValue      = vec3(0.0, 0.0, 0.0);");
            add("  vec3    specularValue   = vec3(0.0, 0.0, 0.0);");
            add("  vec3    viewLightVec;");
            add("  vec3    viewLightDir;")
            add("  float   dotN;");
            add("  float   spotDirRatio;");
            add("  float   lightDist;");

            var light;

            for (var i = 0, len = states.lights.lights.length; i < len; i++) {
                light = states.lights.lights[i];

                if (light.mode == "ambient") {
                    continue;
                }

                if (light.mode == "point") {

                    if (light.space == "world") {

                        // World space

                        add("viewLightVec = SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz;"); // Vector from World coordinate to light pos

                        // Transform to View space
                        add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;");

                    } else {

                        // View space

                        add("viewLightVec = SCENEJS_uLightPos" + i + ".xyz - SCENEJS_vViewVertex.xyz;"); // Vector from View coordinate to light pos
                    }

                    add("dotN = max(dot(viewNormalVec, normalize(viewLightVec)), 0.0);");

                    add("lightDist = length( SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz);");

                    add("attenuation = 1.0 - (" +
                        "  SCENEJS_uLightAttenuation" + i + ".x + " +
                        "  SCENEJS_uLightAttenuation" + i + ".y * lightDist + " +
                        "  SCENEJS_uLightAttenuation" + i + ".z * lightDist * lightDist);");

                    if (light.diffuse) {
                        add("      lightValue += dotN * SCENEJS_uLightColor" + i + " * attenuation;");
                    }

                    if (light.specular) {
                        add("    specularValue += specularColor * SCENEJS_uLightColor" + i +
                            " * specular * pow(max(dot(reflect(normalize(-viewLightVec), normalize(-viewNormalVec)), normalize(-SCENEJS_vViewVertex.xyz)), 0.0), shine) * attenuation;");
                    }
                }

                if (light.mode == "spot") {

                    add("viewLightDir = SCENEJS_uLightDir" + i + ";");

                    if (light.space == "world") {

                        // World space

                        add("viewLightVec = SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz;"); // Vector from World coordinate to light pos

                        // Transform to View space
                        add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;");
                        add("viewLightDir = vec3(SCENEJS_uVMatrix * vec4(viewLightDir, 0.0)).xyz;");

                    } else {

                        // View space

                        add("viewLightVec = SCENEJS_uLightPos" + i + ".xyz - SCENEJS_vViewVertex.xyz;"); // Vector from View coordinate to light pos
                    }

                    add("dotN = max(dot(viewNormalVec, normalize(viewLightVec)), 0.0);");
                    add("spotDirRatio = 1.0 - max(dot(normalize(viewLightDir), normalize(-viewLightVec)), 0.0);");

                    add("lightDist = length( SCENEJS_uLightPos" + i + " - SCENEJS_vWorldVertex.xyz);");

                    add("attenuation = 1.0 - (" +
                        "  SCENEJS_uLightAttenuation" + i + ".x + " +
                        "  SCENEJS_uLightAttenuation" + i + ".y * lightDist + " +
                        "  SCENEJS_uLightAttenuation" + i + ".z * lightDist * lightDist);");

                    // Attenuations due to spotlight cones
                    add("attenuation *= 1.0 - clamp((spotDirRatio - SCENEJS_uInnerCone" + i + ") / max(SCENEJS_uOuterCone" + i + " - SCENEJS_uInnerCone" + i + ", 0.0001), 0.0, 1.0);");

                    if (light.diffuse) {
                        add("      lightValue += dotN * SCENEJS_uLightColor" + i + " * attenuation;");
                    }

                    if (light.specular) {
                        add("    specularValue += specularColor * SCENEJS_uLightColor" + i +
                            " * specular * pow(max(dot(reflect(normalize(-viewLightVec), normalize(-viewNormalVec)), normalize(-SCENEJS_vViewVertex.xyz)), 0.0), shine) * attenuation;");
                    }
                }

                if (light.mode == "dir") {

                    if (light.space == "world") {

                        // World space light

                        add("viewLightVec = normalize(SCENEJS_uLightDir" + i + ");");

                        // Transform to View space
                        add("viewLightVec = vec3(SCENEJS_uVMatrix * vec4(viewLightVec, 0.0)).xyz;");

                    } else {

                        // View space light

                        add("viewLightVec = normalize(SCENEJS_uLightDir" + i + ");");
                    }

                    add("viewLightVec = -viewLightVec;");

                    add("dotN = max(dot(viewNormalVec, normalize(viewLightVec)), 0.0);");

                    if (light.diffuse) {
                        add("lightValue += dotN * SCENEJS_uLightColor" + i + ";");
                    }

                    if (light.specular) {
                        add("specularValue += specularColor * SCENEJS_uLightColor" + i +
                            " * specular * pow(max(dot(reflect(normalize(-viewLightVec), normalize(-viewNormalVec)), normalize(-SCENEJS_vViewVertex.xyz)), 0.0), shine);");
                    }
                }
            }

            if (diffuseFresnel) {
                add("float diffuseFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uDiffuseFresnelEdgeColor.a, SCENEJS_uDiffuseFresnelCenterColor.a, SCENEJS_uDiffuseFresnelPower);");
                
                if (diffuseFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                    add("color.rgb *= mix(SCENEJS_uDiffuseFresnelEdgeColor.rgb, SCENEJS_uDiffuseFresnelCenterColor.rgb, diffuseFresnel);");
                } else if (diffuseFresnel.blendMode & TEXTURE_FLAGS.add) {
                    add("color.rgb += mix(SCENEJS_uDiffuseFresnelEdgeColor.rgb, SCENEJS_uDiffuseFresnelCenterColor.rgb, diffuseFresnel);");
                }
            }

            if (specularFresnel) {
                add("float specFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uSpecularFresnelEdgeColor.a, SCENEJS_uSpecularFresnelCenterColor.a, SCENEJS_uSpecularFresnelPower);");
                
                if (specularFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                    add("specularValue *= mix(SCENEJS_uSpecularFresnelEdgeColor.rgb, SCENEJS_uSpecularFresnelCenterColor.rgb, specFresnel);");
                } else if (specularFresnel.blendMode & TEXTURE_FLAGS.add) {
                    add("specularValue += mix(SCENEJS_uSpecularFresnelEdgeColor.rgb, SCENEJS_uSpecularFresnelCenterColor.rgb, specFresnel);");
                }
            }

            if (alphaFresnel) {
                add("float alphaFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uAlphaFresnelEdgeColor.a, SCENEJS_uAlphaFresnelCenterColor.a, SCENEJS_uAlphaFresnelPower);");
                
                if (alphaFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                    add("alpha *= mix(SCENEJS_uAlphaFresnelEdgeColor.r, SCENEJS_uAlphaFresnelCenterColor.r, alphaFresnel);");
                } else if (alphaFresnel.blendMode & TEXTURE_FLAGS.add) {
                    add("alpha += mix(SCENEJS_uAlphaFresnelEdgeColor.r, SCENEJS_uAlphaFresnelCenterColor.r, alphaFresnel);");
                }
            }

            if (emitFresnel) {
                add("float emitFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uEmitFresnelEdgeColor.a, SCENEJS_uEmitFresnelCenterColor.a, SCENEJS_uEmitFresnelPower);");
                
                if (emitFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                    add("emitColor.rgb *= mix(SCENEJS_uEmitFresnelEdgeColor.rgb, SCENEJS_uEmitFresnelCenterColor.rgb, emitFresnel);");
                } else if (emitFresnel.blendMode & TEXTURE_FLAGS.add) {
                    add("emitColor.rgb += mix(SCENEJS_uEmitFresnelEdgeColor.rgb, SCENEJS_uEmitFresnelCenterColor.rgb, emitFresnel);");
                }
            }

            add("fragColor = vec4((specularValue.rgb + color.rgb * (lightValue.rgb + ambient.rgb)) + (emit * emitColor.rgb), alpha);");

        } else { // No normals

            add("fragColor = vec4((color.rgb + (emit * color.rgb)) *  (vec3(1.0, 1.0, 1.0) + ambient.rgb), alpha);");
        }

        if (regionInteraction) {

            // Region map highlighting

            add("vec3 regionColor = texture2D(SCENEJS_uRegionMapSampler, vec2(SCENEJS_vRegionMapUV.s, SCENEJS_vRegionMapUV.t)).rgb;");
            add("float tolerance = 0.01;");
            add("vec3 colorDelta = abs(SCENEJS_uRegionMapRegionColor - regionColor);");
            if (states.regionMap.mode === "highlight" || states.regionMap.mode === "hide") {
                add("if (max(colorDelta.x, max(colorDelta.y, colorDelta.z)) < tolerance) {");
                if (states.regionMap.mode === "highlight") {
                    add("  fragColor.rgb *= SCENEJS_uRegionMapHighlightFactor;");
                } else {
                    // mode = "hide"
                    add("  fragColor.a = SCENEJS_uRegionMapHideAlpha;");
                }
                add("}");
            } else {
                // mode = "isolate"
                add("if (max(colorDelta.x, max(colorDelta.y, colorDelta.z)) > tolerance) {");
                add("  fragColor.a = SCENEJS_uRegionMapHideAlpha;");
                add("}");
            }
        }

        if (xrayEnabled) {
            add("if (xray) {");
            add("    fragColor.a *= (SCENEJS_uXrayGlassFactor  * (SCENEJS_uXrayMurkiness - abs(dot(SCENEJS_vViewNormal, vec3(0.0, 0.0, -1.0)))));");
            add("    fragColor.rgb = SCENEJS_uXrayBGColor;");
            add("}");
        }

        add("float L = dot(vec3(0.3, 0.59, 0.11), fragColor.rgb);");
        add("fragColor.rgb -= SCENEJS_uColorParams.x * (L - fragColor.rgb);"); // Saturation
        add("fragColor.rgb = (fragColor.rgb - 0.5) * SCENEJS_uColorParams.y + 0.5 + SCENEJS_uColorParams.z;"); // Contrast/brightness
        add("fragColor.rgb *= SCENEJS_uTintColor.rgb;"); // tint
        

        if (fogEnabled) {
            add("vec3 fogColor = SCENEJS_uFogColor.rgb;");
            add("float fogDensity = SCENEJS_uFogColor.a;");
            add("float fogStart = SCENEJS_uFogParams.x;");
            add("float fogEnd = SCENEJS_uFogParams.y;");
            add("float fogMin = SCENEJS_uFogParams.z;");
            add("float fogMax = SCENEJS_uFogParams.w;");
            if (fogMode === DISPLAY_FLAGS.FOG_LINEAR) {
                add("float fog = (length(SCENEJS_vViewVertex.xyz) - fogStart) / (fogEnd - fogStart);");
            } else {
                add("float fogAttenuation = fogDensity * max(length(SCENEJS_vViewVertex.xyz) - fogStart, 0.0);");
                if (fogMode === DISPLAY_FLAGS.FOG_EXP2) {
                    add("fogAttenuation = fogAttenuation * fogAttenuation;");
                }
                add("float fog = 1.0 - exp(-fogAttenuation);");

            }
            add("fog = clamp(fog, fogMin, fogMax);");
            add("fragColor.rgb = mix(fragColor.rgb, fogColor, fog);");
        }

        if (false && debugCfg.whitewash === true) {

            add("    fragColor = vec4(1.0, 1.0, 1.0, 1.0);");

        } else {

            if (depthTargeting) {

                // Only compile in depth mode support if a depth render target is present

                add("    if (SCENEJS_uDepthMode) {");
                add("          float depth = length(SCENEJS_vViewVertex) / (SCENEJS_uZFar - SCENEJS_uZNear);");
                add("          const vec4 bias = vec4(1.0 / 255.0,");
                add("          1.0 / 255.0,");
                add("          1.0 / 255.0,");
                add("          0.0);");
                add("          float r = depth;");
                add("          float g = fract(r * 255.0);");
                add("          float b = fract(g * 255.0);");
                add("          float a = fract(b * 255.0);");
                add("          vec4 colour = vec4(r, g, b, a);");
                add("          fragColor = colour - (colour.yzww * bias);");
                add("    }");
            }
        }

        if (fragmentFresnel) {
            add("float fragmentFresnel = fresnel(worldEyeVec, worldNormal, SCENEJS_uFragmentFresnelEdgeColor.a, SCENEJS_uFragmentFresnelCenterColor.a, SCENEJS_uFragmentFresnelPower);");
            
            if (fragmentFresnel.blendMode & TEXTURE_FLAGS.multiply) {
                add("fragColor.rgb *= mix(SCENEJS_uFragmentFresnelEdgeColor.rgb, SCENEJS_uFragmentFresnelCenterColor.rgb, fragmentFresnel);");
            } else if (fragmentFresnel.blendMode & TEXTURE_FLAGS.add) {
                add("fragColor.rgb += mix(SCENEJS_uFragmentFresnelEdgeColor.rgb, SCENEJS_uFragmentFresnelCenterColor.rgb, fragmentFresnel);");
            }
        }

        if (!depthTargeting) {
            add("fragColor.rgb *= fragColor.a;");
        }

        add("gl_FragColor = fragColor;");

        add("}");

//        console.log(src.join("\n"));
        return end();
    }

    // Start fresh program source
    function begin() {
        src = [];
    }

    // Append to program source
    function add(txt) {
        src.push(txt || "");
    }

    // Finish building program source
    function end() {
        return src;
    }

})();
;/**
 * @class Source code for pick and draw shader programs, to be compiled into one or more {@link SceneJS_Program}s
 * @private
 *
 * @param {String} hash Hash code identifying the rendering capabilities of the programs
 * @param {String} pickVertexSrc Source code of the pick vertex shader
 * @param {String} pickFragmentSrc Source code of the pick fragment shader
 * @param {String} drawVertexSrc Source code of the draw vertex shader
 * @param {String} drawFragmentSrc Source code of the draw fragment shader
 */
var SceneJS_ProgramSource = function(hash, pickVertexSrc, pickFragmentSrc, drawVertexSrc, drawFragmentSrc) {

    /**
     * Hash code identifying the capabilities of the {@link SceneJS_Program} that is compiled from this source
     * @type String
     */
    this.hash = hash;

    /**
     * Source code for pick vertex shader
     * @type String
     */
    this.pickVertexSrc = pickVertexSrc;

    /**
     * Source code for pick fragment shader
     * @type String
     */
    this.pickFragmentSrc = pickFragmentSrc;

    /**
     * Source code for draw vertex shader
     * @type String
     */
    this.drawVertexSrc = drawVertexSrc;

    /**
     * Source code for draw fragment shader
     * @type String
     */
    this.drawFragmentSrc = drawFragmentSrc;

    /**
     * Count of {@link SceneJS_Program}s compiled from this program source code
     * @type Number
     */
    this.useCount = 0;
};

;/**
 * @class Manages creation, sharing and recycle of {@link SceneJS_Program} instances
 * @private
 */
var SceneJS_ProgramFactory = function(stats, cfg) {

    this.stats = stats;

    this._canvas = cfg.canvas;

    this._programs = {};

    this._nextProgramId = 0;
};

/**
 * Gets a program to render the given states
 */
SceneJS_ProgramFactory.prototype.getProgram = function(hash, states) {

    var program = this._programs[hash];

    if (!program) {

        var source = SceneJS_ProgramSourceFactory.getSource(hash, states);

        program = new SceneJS_Program(this.stats, this._nextProgramId++, hash, source, this._canvas.gl);

        this._programs[hash] = program;

        this.stats.state.programs++;
    }

    program.useCount++;

    return program;
};

/**
 * Releases a program back to the shader factory
 */
SceneJS_ProgramFactory.prototype.putProgram = function(program) {

    if (--program.useCount <= 0) {

        program.draw.destroy();
        program.pick.destroy();

        SceneJS_ProgramSourceFactory.putSource(program.hash);

        delete this._programs[program.hash];

        this.stats.state.programs--;
    }
};

/**
 * Notifies this shader factory that the WebGL context has been restored after previously being lost
 */
SceneJS_ProgramFactory.prototype.webglRestored = function() {

    var gl = this._canvas.gl;
    var program;

    for (var id in this._programs) {
        if (this._programs.hasOwnProperty(id)) {
            program = this._programs[id];
            if (program && program.build) {
                program.build(gl);
            }
        }
    }
};

/**
 * Destroys this shader factory
 */
SceneJS_ProgramFactory.prototype.destroy = function() {
};
;/**
 * @class Vertex and fragment shaders for pick and draw
 * @private
 *
 * @param {*} stats Collects runtime statistics
 * @param {Number} id ID unique among all programs in the owner {@link SceneJS_ProgramFactory}
 * @param {String} hash Hash code which uniquely identifies the capabilities of the program, computed from hashes on the {@link Scene_Core}s that the {@link SceneJS_ProgramSource} composed to render
 * @param {SceneJS_ProgramSource} source Sourcecode from which the the program is compiled in {@link #build}
 * @param {WebGLRenderingContext} gl WebGL context
 */
var SceneJS_Program = function(stats, id, hash, source, gl) {

    this.stats = stats;

    /**
     * ID for this program, unique among all programs in the display
     * @type Number
     */
    this.id = id;

    /**
     * Hash code for this program's capabilities, same as the hash on {@link #source}
     * @type String
     */
    this.hash = source.hash;

    /**
     * Source code for this program's shaders
     * @type SceneJS_ProgramSource
     */
    this.source = source;

    /**
     * WebGL context on which this program's shaders are allocated
     * @type WebGLRenderingContext
     */
    this.gl = gl;

    /**
     * The drawing program
     * @type SceneJS._webgl.Program
     */
    this.draw = null;

    /**
     * The picking program
     * @type SceneJS._webgl.Program
     */
    this.pick = null;

    /**
     * The count of display objects using this program
     * @type Number
     */
    this.useCount = 0;

    this.build(gl);
};

/**
 *  Creates the render and pick programs.
 * This is also re-called to re-create them after WebGL context loss.
 */
SceneJS_Program.prototype.build = function(gl) {

    this.gl = gl;
    this.draw = new SceneJS._webgl.Program(this.stats, gl, [this.source.drawVertexSrc.join("\n")], [this.source.drawFragmentSrc.join("\n")]);
    this.pick = new SceneJS._webgl.Program(this.stats, gl, [this.source.pickVertexSrc.join("\n")], [this.source.pickFragmentSrc.join("\n")]);
};
;/**
 * @class Manages creation and recycle of {@link SceneJS_Object} instances
 * @private
 */
var SceneJS_ObjectFactory = function() {

};

/**
 * @property {[SceneJS_Object]} _freeObjects Pool of free display objects, shared by all object factories
 */
SceneJS_ObjectFactory.prototype._freeObjects = [];

/**
 * @property {Number} _numFreeObjects Number of free objects
 */
SceneJS_ObjectFactory.prototype._numFreeObjects = 0;

/**
 * Gets a display object from this factory
 *
 * @param {String} id ID to assign to the object
 * @returns {SceneJS_Object} The object
 */
SceneJS_ObjectFactory.prototype.getObject = function(id) {

    var object;

    if (this._numFreeObjects > 0) {

        object = this._freeObjects[--this._numFreeObjects];
        object.id = id;

        return object;
    }

    return new SceneJS_Object(id);
};

/**
 * Releases a display object back to this factory
 * @param {SceneJS_Object} object Object to release
 */
SceneJS_ObjectFactory.prototype.putObject = function (object) {

  //  this._freeObjects[this._numFreeObjects++] = object;
};;/**
 * @class An object within a {@link SceneJS_Display}
 * @private
 */
var SceneJS_Object = function(id) {

    /**
     * ID for this objects, unique among all objects in the display
     * @type Number
     */
    this.id = id;

    /**
     * Hash code for this object, unique among all objects in the display
     * @type String
     */
    this.hash = null;

    /**
     * State sort key, computed from {@link #layer}, {@link #program} and {@link #texture}
     * @type Number
     */
    this.sortKey1 = null;
    this.sortKey2 = null;

    /**
     * Sequence of state chunks applied to render this object
     * @type {[SceneJS_Chunk]} chunks
     */
    this.chunks = [];

    /**
     * Number of state chunks applied to render this object
     * @type Number
     */
    this.chunksLen = 0;

    /**
     * Shader programs that render this object, also used for (re)computing {@link #sortKey}
     * @type SceneJS_Program
     */
    this.program = null;

    /**
     * State core for the {@link SceneJS.Layer} that this object was compiled from, used for (re)computing {@link #sortKey} and visibility cull
     */
    this.layer = null;

     /**
     * State core for the {@link SceneJS.Texture} that this object was compiled from, used for (re)computing {@link #sortKey}
     */
    this.texture = null;

    /**
     * State core for the {@link SceneJS.Flags} that this object was compiled from, used for visibility cull
     */
    this.properties = null;

    /**
    *   Used to calculate the depth for depth sorting
    */
    this.centroid = null;
};

(function() {
    var tempVec3 = new vec3.create();

    SceneJS_Object.prototype.getDepth = function() {
        if (!this.centroid) {
            this.centroid = this._calculateCentroid(this);
        }

        var modelMatrix = this.modelTransform.mat;
        var viewMatrix = this.viewTransform.mat;

        var viewCentroid = vec3.transformMat4(tempVec3, this.centroid, modelMatrix);

        vec3.transformMat4(viewCentroid, viewCentroid, viewMatrix);

        return -viewCentroid[2];
    };

    SceneJS_Object.prototype.isTransparent = function() {
        return !!(this.properties.transparent || 
            this.material.transparent ||
            this.fresnel.transparent ||
            this.texture.transparent ||
            this.geometry.transparent ||
            this.regionMap.transparent);
    };

    SceneJS_Object.prototype.getKdTree = function() {
        var indices = this.geometry.arrays.indices;
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return this.morphGeometry.getKdTree(indices);
        } else {
            return this.geometry.getKdTree();
        }
    };

    SceneJS_Object.prototype.getPositions = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key1].positions;
        } else {
            return this.geometry.arrays.positions;
        }
    };

    SceneJS_Object.prototype.getPositionDecodeMat = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key1].positionDecodeMat;
        } else {
            return this.geometry.positionDecodeMat;
        }
    };

    SceneJS_Object.prototype.getFrameEndPositions = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key2].positions;
        } else {
            return null;
        }
    };

    SceneJS_Object.prototype.getFrameEndPositionDecodeMat = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key2].positionDecodeMat;
        } else {
            return null;
        }
    };

    SceneJS_Object.prototype.getNormals = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key1].normals;
        } else {
            return this.geometry.arrays.normals;
        }
    };

    SceneJS_Object.prototype.getFrameEndNormals = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return targets[this.morphGeometry.key2].normals;
        } else {
            return null;
        }
    };

    SceneJS_Object.prototype.getIndices = function() {
        return this.geometry.arrays.indices || null;
    };

    SceneJS_Object.prototype.getMorphFactor = function() {
        var targets = this.morphGeometry.targets;
        if (targets && targets.length > 0) {
            return this.morphGeometry.factor;
        } else {
            return null;
        }
    };

    SceneJS_Object.prototype._calculateCentroid = function() {

        var centroid = vec3.create();

        var positions = this.geometry.arrays.positions;
        var indices = this.geometry.arrays.indices;

        var xmin = Infinity;
        var ymin = Infinity;
        var zmin = Infinity;
        var xmax = -Infinity;
        var ymax = -Infinity;
        var zmax = -Infinity;

        var min = Math.min;
        var max = Math.max;

        for (var i = 0, len = indices.length; i < len; i++) {
            var vi = indices[i] * 3;
            var x = positions[vi];
            var y = positions[vi + 1];
            var z = positions[vi + 2];

            xmin = min(x, xmin);
            ymin = min(y, ymin);
            zmin = min(z, zmin);
            xmax = max(x, xmax);
            ymax = max(y, ymax);
            zmax = max(z, zmax);
        }

        centroid[0] = 0.5 * (xmin + xmax);
        centroid[1] = 0.5 * (ymin + ymax);
        centroid[2] = 0.5 * (zmin + zmax);

        return centroid;
    };
})();


;/**
 * @class A facade which exposes internal scene rendering state to "rendered" event listeners bound to scene graph nodes with {@link SceneJS.Node#bind}.
 *
 * <p>The listener is fired for each {@link SceneJS.Geometry} that is rendered within the subgraph of the bound node.
 * An instance of this facade is passed into the listener's handler, enabling the listener to obtain the various transform
 * matrices that are active at that {@link SceneJS.Geometry}.</p>
 *
 * <p>The facade instance is only valid within the callback's execution; internally, SceneJS reuses the same instance of the
 * facade with each scene.</p>
 */
SceneJS.RenderContext = function (frameCtx) {
    this._frameCtx = frameCtx;
    this._worldPos = vec4.create();
    this._viewPos = vec4.create();
    this._projPos = vec4.create();
    this._cameraPos = vec4.create();
    this._canvasPos = vec2.create();
};

SceneJS.RenderContext.prototype.getPass = function () {
    return this._frameCtx.pass;
};

/**
 * Get the projection matrix, as defined by the active {@link SceneJS.Camera} node.
 */
SceneJS.RenderContext.prototype.getCameraMatrix = function () {
    return this._frameCtx.cameraMat;
};

/**
 * Get the view matrix, as defined by the active {@link SceneJS.LookAt} node.
 */
SceneJS.RenderContext.prototype.getViewMatrix = function () {
    return this._frameCtx.viewMat;
};

/**
 * Get the model matrix, as defined by the active {@link SceneJS.XForm} node.
 */
SceneJS.RenderContext.prototype.getModelMatrix = function () {
    return this._frameCtx.modelMat;
};

/**
 * Transforms the given world coordinate by the model, view and projection matrices defined by the active {@link SceneJS.XForm}, {@link SceneJS.LookAt} and {@link SceneJS.Camera} nodes.
 * @returns [Number] The 2D Canvas-space coordinate
 */
SceneJS.RenderContext.prototype.getCanvasPos = function (offset) {

    this.getProjPos(offset);

    var canvas = this._frameCtx.canvas.canvas;
    var resolutionScaling = this._frameCtx.canvas.resolutionScaling;
    var canvasWidth = canvas.width / resolutionScaling;
    var canvasHeight = canvas.height / resolutionScaling;
    var x = (this._projPos[0] / this._projPos[3]) * canvasWidth * 0.5;
    var y = (this._projPos[1] / this._projPos[3]) * canvasHeight * 0.5;

    this._canvasPos[0] = x + (canvasWidth * 0.5);
    this._canvasPos[1] = canvasHeight - y - (canvasHeight * 0.5);

    return this._canvasPos;
};

SceneJS.RenderContext.prototype.getCameraPos = function (offset) {
    return vec3.normalize(this._cameraPos, this.getProjPos(offset));
};

SceneJS.RenderContext.prototype.getProjPos = function (offset) {
    return vec4.transformMat4(this._projPos, this.getViewPos(offset), this._frameCtx.cameraMat);
};

SceneJS.RenderContext.prototype.getViewPos = function (offset) {
    return vec4.transformMat4(this._viewPos, this.getWorldPos(offset), this._frameCtx.viewMat);
};

SceneJS.RenderContext.prototype.getWorldPos = (function () {
    var offsetDefault = vec4.fromValues(0, 0, 0, 1);
    return function (offset) {
        offsetDefault[0] = offset ? offset[0] : 0;
        offsetDefault[1] = offset ? offset[1] : 0;
        offsetDefault[2] = offset ? offset[2] : 0;
        return vec4.transformMat4(this._worldPos, offsetDefault, this._frameCtx.modelMat);
    };
})();

;/**
 * @class A chunk of WebGL state changes to render a {@link SceneJS_Core} for drawing and picking (if applicable to the core type).
 *
 * <p>Instances of this class are created and recycled by a {@link SceneJS_ChunkFactory}.</p>
 *
 * <p>Each {@link SceneJS_Object} has a list of chunks to render it's {@link SceneJS_Core}s</p>
 *
 * @private
 */
var SceneJS_Chunk = function() {};

/**
 * Initialises the chunk. This is called within the constructor, and also to by the owner {@link SceneJS_ChunkFactory}
 * when recycling a chunk from its free chunk pool. This method sets the given properties on the chunk, then calls the
 * chunk instance's <b>build</b> method if the chunk has been augmented with one.
 *
 * @param {String} id Chunk ID
 * @param {SceneJS_Program} program Program to render the chunk
 * @param {SceneJS_Core} core The state core rendered by this chunk
 * @param {SceneJS_Core} core2 Another state core rendered by this chunk, only used for geometry
 */
SceneJS_Chunk.prototype.init = function(id, program, core, core2) {

    this.id = id;
    this.program = program;
    this.core = core;
    this.core2 = core2;

    if (this.build) {
        this.build();
    }
};
;/**
 * @class Manages creation, reuse and destruction of {@link SceneJS_Chunk}s for the nodes within a single {@link SceneJS_Display}.
 * @private
 */
var SceneJS_ChunkFactory = function() {

    this._chunks = {};
    this.chunkTypes = SceneJS_ChunkFactory.chunkTypes;
};

/**
 * Sub-classes of {@link SceneJS_Chunk} provided by this factory
 */
SceneJS_ChunkFactory.chunkTypes = {};    // Supported chunk classes, installed by #createChunkType

/**
 * Free pool of unused {@link SceneJS_Chunk} instances
 */
SceneJS_ChunkFactory._freeChunks = {};    // Free chunk pool for each type

/**
 * Creates a chunk class for instantiation by this factory
 *
 * @param params Members to augment the chunk class prototype with
 * @param params.type Type name for the new chunk class
 * @param params.draw Method to render the chunk in draw render
 * @param params.pick Method to render the chunk in pick render
 * @param params.drawAndPick Method to render the chunk in both draw and pick renders
 */
SceneJS_ChunkFactory.createChunkType = function(params) {

    if (!params.type) {
        throw "'type' expected in params";
    }

    var supa = SceneJS_Chunk;

    var chunkClass = function() { // Create the class
        this.useCount = 0;
        this.init.apply(this, arguments);
    };

    chunkClass.prototype = new supa();              // Inherit from base class
    chunkClass.prototype.constructor = chunkClass;

    if (params.drawAndPick) {                       // Common method for draw and pick render
        params.draw = params.pick = params.drawAndPick;
    }

    SceneJS_ChunkFactory.chunkTypes[params.type] = chunkClass;

    SceneJS._apply(params, chunkClass.prototype);   // Augment subclass

    SceneJS_ChunkFactory._freeChunks[params.type] = { // Set up free chunk pool for this type
        chunks: [],
        chunksLen: 0
    };

    return chunkClass;
};

/**
 *
 */
SceneJS_ChunkFactory.prototype.getChunk = function(chunkId, type, program, core, core2) {

    var chunkClass = SceneJS_ChunkFactory.chunkTypes[type]; // Check type supported

    if (!chunkClass) {
        throw "chunk type not supported: '" + type + "'";
    }

    var chunk = this._chunks[chunkId];  // Try to reference an existing chunk

    if (chunk) {
        chunk.useCount++;
        return chunk;
    }

    //var freeChunks = SceneJS_ChunkFactory._freeChunks[type]; // Try to recycle a free chunk
    //
    //if (freeChunks.chunksLen > 0) {
    //    chunk = freeChunks.chunks[--freeChunks.chunksLen];
    //}
    //
    //if (chunk) {    // Reinitialise the recycled chunk
    //
    //    chunk.init(chunkId, program, core, core2);
    //
    //} else {        // Instantiate a fresh chunk

        chunk = new chunkClass(chunkId, program, core, core2); // Create new chunk

//    }

    chunk.type = type;

    chunk.useCount = 1;

    this._chunks[chunkId] = chunk;

    return chunk;
};

/**
 * Releases a display state chunk back to this factory, destroying it if the chunk's use count is then zero.
 *
 * @param {SceneJS_Chunk} chunk Chunk to release
 */
SceneJS_ChunkFactory.prototype.putChunk = function (chunk) {

    if (chunk.useCount == 0) {
        return; // In case of excess puts
    }

    if (--chunk.useCount <= 0) {    // Release shared core if use count now zero

        if (chunk.recycle) {
            chunk.recycle();
        }

        delete this._chunks[chunk.id];

    //    var freeChunks = SceneJS_ChunkFactory._freeChunks[chunk.type];

    //    freeChunks.chunks[freeChunks.chunksLen++] = chunk;
    }
};

/**
 * Re-cache shader variable locations for each active chunk and reset VAOs if any
 */
SceneJS_ChunkFactory.prototype.webglRestored = function () {

    var chunk;

    for (var chunkId in this._chunks) {

        if (this._chunks.hasOwnProperty(chunkId)) {

            chunk = this._chunks[chunkId]; // Re-cache chunk's shader variable locations

            if (chunk && chunk.build) {
                chunk.build();
            }
        }
    }
};
;SceneJS_ChunkFactory.createChunkType({

    type: "camera",

    build : function() {

        this._uPMatrixDraw = this.program.draw.getUniform("SCENEJS_uPMatrix");
        this._uZNearDraw = this.program.draw.getUniform("SCENEJS_uZNear");
        this._uZFarDraw = this.program.draw.getUniform("SCENEJS_uZFar");

        this._uPMatrixPick = this.program.pick.getUniform("SCENEJS_uPMatrix");
        this._uZNearPick = this.program.pick.getUniform("SCENEJS_uZNear");
        this._uZFarPick = this.program.pick.getUniform("SCENEJS_uZFar");
    },

    draw : function(frameCtx) {

        if (this.core.checkAspect) {
            this.core.checkAspect(this.core, frameCtx.aspect);
        }

        var gl = this.program.gl;

        if (this._uPMatrixDraw) {
            this._uPMatrixDraw.setValue(this.core.mat);
        }

        if (this._uZNearDraw) {
            this._uZNearDraw.setValue(this.core.optics.near);
        }

        if (this._uZFarDraw) {
            this._uZFarDraw.setValue(this.core.optics.far);
        }

        frameCtx.cameraMat = this.core.mat; // Query only in draw pass
    },


    pick : function(frameCtx) {

        if (this.core.checkAspect) {
            this.core.checkAspect(this.core, frameCtx.aspect);
        }

        var gl = this.program.gl;

        if (this._uPMatrixPick) {
            this._uPMatrixPick.setValue(frameCtx.pickProjMatrix || this.core.mat);
        }

        if (frameCtx.rayPick) { // Z-pick pass: feed near and far clip planes into shader

            if (this._uZNearPick) {
                this._uZNearPick.setValue(this.core.optics.near);
            }

            if (this._uZFarPick) {
                this._uZFarPick.setValue(this.core.optics.far);
            }
        }

        frameCtx.cameraMat = this.core.mat; // Query only in draw pass
    }
});;/**
 * Create display state chunk type for draw and pick render of user clipping planes
 */
SceneJS_ChunkFactory.createChunkType({

    type: "clips",

    build : function() {

        this._draw = this._draw || [];

        var draw = this.program.draw;

        for (var i = 0, len = this.core.clips.length; i < len; i++) {
            this._draw[i] = {
                uClipMode :draw.getUniform("SCENEJS_uClipMode" + i),
                uClipNormalAndDist: draw.getUniform("SCENEJS_uClipNormalAndDist" + i)
            };
        }

        this._pick = this._pick || [];

        var pick = this.program.pick;

        for (var i = 0, len = this.core.clips.length; i < len; i++) {
            this._pick[i] = {
                uClipMode :pick.getUniform("SCENEJS_uClipMode" + i),
                uClipNormalAndDist: pick.getUniform("SCENEJS_uClipNormalAndDist" + i)
            };
        }
    },

    drawAndPick: function(frameCtx) {

        var picking = frameCtx.picking;
        var vars = picking ? this._pick : this._draw;
        var mode;
        var normalAndDist;
        var clips = this.core.clips;
        var clip;
        var gl = this.program.gl;

        for (var i = 0, len = clips.length; i < len; i++) {

            if (picking) {
                mode = vars[i].uClipMode;
                normalAndDist = vars[i].uClipNormalAndDist;
            } else {
                mode = vars[i].uClipMode;
                normalAndDist = vars[i].uClipNormalAndDist;
            }

            if (mode && normalAndDist) {

                clip = clips[i];

                if (clip.mode == "inside") {

                    mode.setValue(2);
                    normalAndDist.setValue(clip.normalAndDist);

                } else if (clip.mode == "outside") {

                    mode.setValue(1);
                    normalAndDist.setValue(clip.normalAndDist);

                } else { // disabled
                    mode.setValue(0);
                }
            }
        }
    }
});;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type: "draw",

    /**
     * As we apply a list of state chunks in a {@link SceneJS_Display}, we track the ID of each chunk
     * in order to avoid redundantly re-applying the same chunk.
     *
     * We don't want that for draw chunks however, because they contain GL drawElements calls,
     * which we need to do for each object.
     */
    unique: true,

    build: function () {

        this._depthModeDraw = this.program.draw.getUniform("SCENEJS_uDepthMode");

        this._uPickColor = this.program.pick.getUniform("SCENEJS_uPickColor");
    },


    draw: function (frameCtx) {

        var core = this.core;
        var gl = this.program.gl;

        if (this._depthModeDraw) {
            this._depthModeDraw.setValue(frameCtx.depthMode);
        }

        if (core.indexBuf) {
            gl.drawElements(core.primitive, core.indexBuf.numItems, core.indexBuf.itemType, 0);
            frameCtx.drawElements++;
        } else {
            gl.drawArrays(core.primitive, 0, core.vertexBuf.numItems / 3);
            frameCtx.drawArrays++;
        }

        frameCtx.transparent = false;
    },

    pick: function (frameCtx) {

        var core = this.core;
        var gl = this.program.gl;

        if (frameCtx.pickObject || frameCtx.pickRegion) {

            if (frameCtx.pickObject) {

                if (this._uPickColor) {

                    var a = frameCtx.pickIndex >> 24 & 0xFF;
                    var b = frameCtx.pickIndex >> 16 & 0xFF;
                    var g = frameCtx.pickIndex >> 8 & 0xFF;
                    var r = frameCtx.pickIndex & 0xFF;

                    frameCtx.pickIndex++;

                    this._uPickColor.setValue([r / 255, g / 255, b / 255, a / 255]);
                }
            }

            if (core.indexBuf) {
                gl.drawElements(core.primitive, core.indexBuf.numItems, core.indexBuf.itemType, 0);
            } else {
                gl.drawArrays(core.primitive, 0, core.vertexBuf.numItems / 3);
            }

        } else if (frameCtx.pickTriangle) {

            var pickPositions = core.getPickPositions();

            if (pickPositions) {
                gl.drawArrays(core.primitive, 0, pickPositions.numItems / 3);
            }
        }
    }
});
;/**
 *  Create display state chunk type for draw and pick render of flags
 */

(function() {

    var FLAGS = SceneJS.PROPERTY_FLAGS;

    SceneJS_ChunkFactory.createChunkType({

        type: "properties",

        build: function () {

            var draw = this.program.draw;

            this._uClippingParamsDraw = draw.getUniform("SCENEJS_uClippingParams"); 
            this._uXrayParamsDraw = draw.getUniform("SCENEJS_uXrayParams"); 
            this._uTintColorDraw = draw.getUniform("SCENEJS_uTintColor"); 
            this._uColorParamsDraw = draw.getUniform("SCENEJS_uColorParams");

            var pick = this.program.pick;

            this._uClippingPick = pick.getUniform("SCENEJS_uClipping");
        },

        drawAndPick: function (frameCtx) {

            var gl = this.program.gl;

            var backfaces = this.core.flags & FLAGS.BACKFACES;

            if (frameCtx.backfaces != backfaces) {
                if (backfaces) {
                    gl.disable(gl.CULL_FACE);
                } else {
                    gl.enable(gl.CULL_FACE);
                }
                frameCtx.backfaces = backfaces;
            }

            var frontfaceCCW = this.core.flags & FLAGS.CCW;

            if (frameCtx.frontface != frontfaceCCW) {
                if (frontfaceCCW) {
                    gl.frontFace(gl.CCW);
                } else {
                    gl.frontFace(gl.CW);
                }
                frameCtx.frontface = frontfaceCCW;
            }

            var picking = frameCtx.picking;

            if (picking) {

                if (this._uClippingPick) {
                    this._uClippingPick.setValue(this.core.clippingParams[3]);
                }

            } else {

                var depthMask = this.core.flags & FLAGS.DEPTH_MASK;

                if (frameCtx.depthMask != depthMask) {

                    gl.depthMask(depthMask);

                    frameCtx.depthMask = depthMask;
                }

                if (this._uTintColorDraw) {
                    this._uTintColorDraw.setValue(this.core.tintColor);
                }

                if (this._uColorParamsDraw) {
                    this._uColorParamsDraw.setValue(this.core.colorParams);
                }

                if (this._uClippingParamsDraw) {
                    this._uClippingParamsDraw.setValue(this.core.clippingParams);
                }

                if (this._uXrayParamsDraw) {
                    this._uXrayParamsDraw.setValue(this.core.xrayParams);
                }

            }
        }
    });
})();

;/**
 *  Create display state chunk type for draw and pick render of geometry
 */
SceneJS_ChunkFactory.createChunkType({

    type: "geometry",

    build: function () {

        var draw = this.program.draw;

        this._aRegionMapUVDraw = draw.getAttribute("SCENEJS_aRegionMapUV");
        this._aVertexDraw = draw.getAttribute("SCENEJS_aVertex");
        this._aNormalDraw = draw.getAttribute("SCENEJS_aNormal");

        // Get attributes for unlimited UV layers

        this._aUVDraw = [];
        this._uDecodeUV = [];
        var aUV, uDecodeUV;
        for (var i = 0; i < 1000; i++) { // Assuming we'll never have more than 1000 UV layers
            aUV = draw.getAttribute("SCENEJS_aUVCoord" + i);
            if (!aUV) {
                break;
            }
            this._aUVDraw.push(aUV);
            uDecodeUV = draw.getUniform("SCENEJS_uDecodeUVMatrix" + i);
            if (uDecodeUV) {
                this._uDecodeUV.push(uDecodeUV);
            }
        }

        this._aTangentDraw = draw.getAttribute("SCENEJS_aTangent");
        this._aColorDraw = draw.getAttribute("SCENEJS_aVertexColor");

        this._aMorphVertexDraw = draw.getAttribute("SCENEJS_aMorphVertex");
        this._aMorphNormalDraw = draw.getAttribute("SCENEJS_aMorphNormal");
        this._aMorphTangentDraw = draw.getAttribute("SCENEJS_aMorphTangent");
        this._uMorphFactorDraw = draw.getUniform("SCENEJS_uMorphFactor");
        this._uPointSizeDraw = draw.getUniform("SCENEJS_uPointSize");
        this._uDecodePositionsDraw = draw.getUniform("SCENEJS_uDecodePositionMatrix");
        this._uDecodeMorphPosDraw = draw.getUniform("SCENEJS_uDecodeMorphPosMatrix");

        var pick = this.program.pick;

        this._aRegionMapUVPick = pick.getAttribute("SCENEJS_aRegionMapUV");
        this._aVertexPick = pick.getAttribute("SCENEJS_aVertex");
        this._aColorPick = pick.getAttribute("SCENEJS_aColor");
        this._aMorphVertexPick = pick.getAttribute("SCENEJS_aMorphVertex");
        this._uMorphFactorPick = pick.getUniform("SCENEJS_uMorphFactor");
        this._uPointSizePick = pick.getUniform("SCENEJS_uPointSize");
        this._uDecodePositionsPick = pick.getUniform("SCENEJS_uDecodePositionMatrix");
        this._uDecodeMorphPosPick = pick.getUniform("SCENEJS_uDecodeMorphPosMatrix");

        this.VAO = null;
        this.VAOMorphKey1 = 0;
        this.VAOMorphKey2 = 0;
        this.VAOHasInterleavedBuf = false;
    },

    recycle: function () {
        if (this.VAO) {
            // Guarantee that the old VAO is deleted immediately when recycling the object.
            var VAOExt = this.program.gl.getExtension("OES_vertex_array_object");
            VAOExt.deleteVertexArrayOES(this.VAO);
            this.VAO = null;
        }
    },

    morphDraw: function (frameCtx) {

        this.VAOMorphKey1 = this.core.key1;
        this.VAOMorphKey2 = this.core.key2;

        var key1 = this.core.key1;
        var key2 = this.core.key2;

        var target1 = this.core.targets[key1]; // Keys will update
        var target2 = this.core.targets[key2];

        if (this._aMorphVertexDraw) {
            this._aVertexDraw.bindArrayBuffer(target1.vertexBuf);
            this._aMorphVertexDraw.bindArrayBuffer(target2.vertexBuf);
            frameCtx.bindArray += 2;

        } else if (this._aVertexDraw) {
            this._aVertexDraw.bindArrayBuffer(this.core2.vertexBuf);
            frameCtx.bindArray++;
        }

        if (this._aMorphNormalDraw) {
            this._aNormalDraw.bindArrayBuffer(target1.normalBuf);
            this._aMorphNormalDraw.bindArrayBuffer(target2.normalBuf);
            frameCtx.bindArray += 2;

        } else if (this._aNormalDraw) {
            this._aNormalDraw.bindArrayBuffer(this.core2.normalBuf);
            frameCtx.bindArray++;
        }

        if (this._aMorphTangentDraw || this._aTangentDraw) {

            // Bind tangent arrays from geometry and morphGeometry

            // Use the first UV layer since tangents should be the same for all UV layouts.

            if (frameCtx.hasNormalMap) {
                if (this._aMorphTangentDraw) {
                    this._aTangentDraw.bindArrayBuffer(
                        this.core.getTangents(key1, this.core2.arrays.indices, this.core2.arrays.uvs[0],
                                                this.core2.positionDecodeMat, this.core2.compressedUVs && this.core2.uvDecodeMats[0])
                    );
                    this._aMorphTangentDraw.bindArrayBuffer(
                        this.core.getTangents(key2, this.core2.arrays.indices, this.core2.arrays.uvs[0],
                                                this.core2.positionDecodeMat, this.core2.compressedUVs && this.core2.uvDecodeMats[0])
                        );
                    frameCtx.bindArray += 2;

                }
            }
        }

        // Bind UV layer from geometry

        var uvBuf;
        for (var i = 0, len = this._aUVDraw.length; i < len; i++) {
            uvBuf = this.core2.uvBufs[i];
            if (uvBuf) {
                this._aUVDraw[i].bindArrayBuffer(uvBuf);
                frameCtx.bindArray++;
            }
        }

        if (this._aColorDraw) {
            this._aColorDraw.bindArrayBuffer(this.core2.colorBuf);
            frameCtx.bindArray++;
        }

        this.updateMorphDrawUniforms();
    },

    updateGeoDrawUniforms: function() {
        if (this._uDecodePositionsDraw) {
            this._uDecodePositionsDraw.setValue(this.core2.positionDecodeMat);
        }
    },

    updateMorphDrawUniforms: function () {
        var key1 = this.core.key1;
        var key2 = this.core.key2;

        var target1 = this.core.targets[key1]; // Keys will update
        var target2 = this.core.targets[key2];

        if (this._uDecodePositionsDraw) {
            this._uDecodePositionsDraw.setValue(target1.positionDecodeMat);
        }

        if (this._uDecodeMorphPosDraw) {
            this._uDecodeMorphPosDraw.setValue(target2.positionDecodeMat);
        }

        if (this._uMorphFactorDraw) {
            this._uMorphFactorDraw.setValue(this.core.factor); // Bind LERP factor
        }
    },

    draw: function (frameCtx) {
        var doMorph = this.core.targets && this.core.targets.length;
        var cleanInterleavedBuf = this.core2.interleavedBuf && !this.core2.interleavedBuf.dirty;

        if (this._uPointSizeDraw) {
            this._uPointSizeDraw.setValue(this.core2.pointSize);
        }

        for (var i = 0, len = this._uDecodeUV.length; i < len; i++) {
            if (this._uDecodeUV[i]) {
                this._uDecodeUV[i].setValue(this.core2.uvDecodeMats[i]);
            }
        }

        if (!doMorph) {
            this.updateGeoDrawUniforms();
        }

        if (this.VAO && frameCtx.VAO) { // Workaround for https://github.com/xeolabs/scenejs/issues/459
            frameCtx.VAO.bindVertexArrayOES(this.VAO);
            if (doMorph) {
                if (this.VAOMorphKey1 == this.core.key1 && this.VAOMorphKey2 == this.core.key2) {
                    this.updateMorphDrawUniforms();
                    return;
                }
            } else if (cleanInterleavedBuf || !this.VAOHasInterleavedBuf) {
                return;
            }
        } else if (frameCtx.VAO) {
            // Start creating a new VAO by switching to the default VAO, which doesn't have attribs enabled.
            frameCtx.VAO.bindVertexArrayOES(null);
            this.VAO = frameCtx.VAO.createVertexArrayOES();
            frameCtx.VAO.bindVertexArrayOES(this.VAO);
        }

        if (doMorph) {
            this.morphDraw(frameCtx);
        } else {
            if (cleanInterleavedBuf) {
                this.VAOHasInterleavedBuf = true;
                this.core2.interleavedBuf.bind();
                if (this._aVertexDraw) {
                    this._aVertexDraw.bindInterleavedFloatArrayBuffer(3, this.core2.interleavedStride, this.core2.interleavedPositionOffset);
                    frameCtx.bindArray++;
                }
                if (this._aNormalDraw) {
                    this._aNormalDraw.bindInterleavedFloatArrayBuffer(3, this.core2.interleavedStride, this.core2.interleavedNormalOffset);
                    frameCtx.bindArray++;
                }
                for (var i = 0, len = this._aUVDraw.length; i < len; i++) {
                    this._aUVDraw[i].bindInterleavedFloatArrayBuffer(2, this.core2.interleavedStride, this.core2.interleavedUVOffsets[i]);
                    frameCtx.bindArray++;
                }
                if (this._aColorDraw) {
                    this._aColorDraw.bindInterleavedFloatArrayBuffer(4, this.core2.interleavedStride, this.core2.interleavedColorOffset);
                    frameCtx.bindArray++;
                }
            } else {
                this.VAOHasInterleavedBuf = false;
                if (this._aVertexDraw) {
                    this._aVertexDraw.bindArrayBuffer(this.core2.vertexBuf);
                    frameCtx.bindArray++;
                }
                if (this._aNormalDraw) {
                    this._aNormalDraw.bindArrayBuffer(this.core2.normalBuf);
                    frameCtx.bindArray++;
                }
                var uvBuf;
                for (var i = 0, len = this._aUVDraw.length; i < len; i++) {
                    uvBuf = this.core2.uvBufs[i];
                    if (uvBuf) {
                        this._aUVDraw[i].bindArrayBuffer(uvBuf);
                        frameCtx.bindArray++;
                    }
                }
                if (this._aColorDraw) {
                    this._aColorDraw.bindArrayBuffer(this.core2.colorBuf);
                    frameCtx.bindArray++;
                }
            }

            if (this._aTangentDraw) {

                // In the texture chunk we remembered which UV layer we're using for the normal
                // map so that we can lazy-generate the tangents from the appropriate UV layer
                // in the geometry chunk.

                // Just use the first UV layer to generate tangest since it should be the same
                // for all layouts.

                if (frameCtx.hasNormalMap) {
                    this._aTangentDraw.bindArrayBuffer(this.core2.getTangents(0));
                    frameCtx.bindArray++;
                }
            }
        }

        if (this._aRegionMapUVDraw) {
            var regionMapUVLayerIdx = frameCtx.regionMapUVLayerIdx; // Set by regionMapChunk
            if (regionMapUVLayerIdx >= 0) {
                var uvBufs = this.core2.uvBufs;
                if (regionMapUVLayerIdx < uvBufs.length) {
                    this._aRegionMapUVDraw.bindArrayBuffer(uvBufs[regionMapUVLayerIdx]);
                    frameCtx.bindArray++;
                }
            }
        }

        if (this.core2.indexBuf) {
            this.core2.indexBuf.bind();
        }
    },

    morphPick: function (frameCtx) {

        var core = this.core;
        var core2 = this.core2;

        var target1 = core.targets[core.key1];
        var target2 = core.targets[core.key2];

        if (frameCtx.pickObject || frameCtx.pickRegion) {

            if (this._aMorphVertexPick) {

                this._aVertexPick.bindArrayBuffer(target1.vertexBuf);
                this._aMorphVertexPick.bindArrayBuffer(target2.vertexBuf);

            } else if (this._aVertexPick) {
                this._aVertexPick.bindArrayBuffer(core2.vertexBuf);
            }

            core2.indexBuf.bind();

        } else if (frameCtx.pickTriangle) {

            if (this._aMorphVertexPick) {

                var pickPositionsBuf = core.getPickPositions(core.key1, core2.arrays.indices);
                if (pickPositionsBuf) {
                    this._aVertexPick.bindArrayBuffer(pickPositionsBuf);
                }

                pickPositionsBuf = core.getPickPositions(core.key2, core2.arrays.indices);
                if (pickPositionsBuf) {
                    this._aMorphVertexPick.bindArrayBuffer(pickPositionsBuf);
                }

                if (this._aColorPick) {
                    this._aColorPick.bindArrayBuffer(core2.getPickColors());
                }

            } else if (this._aVertexPick) {

                this._aVertexPick.bindArrayBuffer(core2.vertexBuf);

                core2.indexBuf.bind();
            }
        }

        if (this._uDecodePositionsPick) {
            this._uDecodePositionsPick.setValue(target1.positionDecodeMat);
        }

        if (this._uDecodeMorphPosPick) {
            this._uDecodeMorphPosPick.setValue(target2.positionDecodeMat);
        }

        if (this._uMorphFactorPick) {
            this._uMorphFactorPick.setValue(core.factor);
        }
    },

    pick: function (frameCtx) {

        var core = this.core;
        var core2 = this.core2;

        if (core.targets && core.targets.length) {

            this.morphPick(frameCtx);

        } else {

            if (frameCtx.pickObject || frameCtx.pickRegion) {

                if (this._aVertexPick) {
                    this._aVertexPick.bindArrayBuffer(core2.vertexBuf);
                }

                if (this._aRegionMapUVPick) {
                    this._aRegionMapUVPick.bindArrayBuffer(core2.uvBufs[frameCtx.regionMapUVLayerIdx]); // Set by regionMapChunk
                }

                if (core2.indexBuf) {
                    core2.indexBuf.bind();
                }

            } else if (frameCtx.pickTriangle) {

                if (this._aVertexPick) {
                    this._aVertexPick.bindArrayBuffer(core2.getPickPositions());
                }

                if (this._aColorPick) {
                    this._aColorPick.bindArrayBuffer(core2.getPickColors());
                }

            }

            if (this._uDecodePositionsPick) {
                this._uDecodePositionsPick.setValue(this.core2.positionDecodeMat);
            }

            if (this._uPointSizePick) {
                this._uPointSizePick.setValue(this.core2.pointSize);
            }
        }
    }
});
;/**
 *  Create display state chunk type for draw render of lights projection
 */
SceneJS_ChunkFactory.createChunkType({

    type:"lights",

    build:function () {

        this._uAmbientColor = this._uAmbientColor || [];
        this._uLightColor = this._uLightColor || [];
        this._uLightDir = this._uLightDir || [];
        this._uLightPos = this._uLightPos || [];
        this._uLightCutOff = this._uLightCutOff || [];
        this._uLightSpotExp = this._uLightSpotExp || [];
        this._uLightAttenuation = this._uLightAttenuation || [];
        this._uInnerCone = this._uInnerCone || [];
        this._uOuterCone = this._uOuterCone || [];

        var lights = this.core.lights;
        var program = this.program;

        for (var i = 0, len = lights.length; i < len; i++) {

            switch (lights[i].mode) {

                case "ambient":
                    this._uAmbientColor[i] = (program.draw.getUniform("SCENEJS_uAmbientColor"));
                    break;

                case "dir":
                    this._uLightColor[i] = program.draw.getUniform("SCENEJS_uLightColor" + i);
                    this._uLightPos[i] = null;
                    this._uLightDir[i] = program.draw.getUniform("SCENEJS_uLightDir" + i);
                    break;

                case "point":
                    this._uLightColor[i] = program.draw.getUniform("SCENEJS_uLightColor" + i);
                    this._uLightPos[i] = program.draw.getUniform("SCENEJS_uLightPos" + i);
                    this._uLightDir[i] = null;
                    this._uLightAttenuation[i] = program.draw.getUniform("SCENEJS_uLightAttenuation" + i);
                    break;

                case "spot":
                    this._uLightColor[i] = program.draw.getUniform("SCENEJS_uLightColor" + i);
                    this._uLightPos[i] = program.draw.getUniform("SCENEJS_uLightPos" + i);
                    this._uLightDir[i] = program.draw.getUniform("SCENEJS_uLightDir" + i);
                    this._uLightAttenuation[i] = program.draw.getUniform("SCENEJS_uLightAttenuation" + i);
                    this._uInnerCone[i] = program.draw.getUniform("SCENEJS_uInnerCone" + i);
                    this._uOuterCone[i] = program.draw.getUniform("SCENEJS_uOuterCone" + i);
                    break;
            }
        }
    },

    draw:function (frameCtx) {

        if (frameCtx.dirty) {
            this.build();
        }

        var lights = this.core.lights;
        var light;

        var gl = this.program.gl;

        for (var i = 0, len = lights.length; i < len; i++) {

            light = lights[i];

            if (this._uAmbientColor[i]) {
                this._uAmbientColor[i].setValue(light.color);

            } else {

                if (this._uLightColor[i]) {
                    this._uLightColor[i].setValue(light.color);
                }

                if (this._uLightPos[i]) {
                    this._uLightPos[i].setValue(light.pos);

                    if (this._uLightAttenuation[i]) {
                        this._uLightAttenuation[i].setValue(light.attenuation);
                    }
                }

                if (this._uLightDir[i]) {
                    this._uLightDir[i].setValue(light.dir);
                }

                if (this._uInnerCone[i]) {
                    this._uInnerCone[i].setValue(light.innerCone);
                }

                if (this._uOuterCone[i]) {
                    this._uOuterCone[i].setValue(light.outerCone);
                }
            }
        }
    }
});
;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type: "listeners",

    // Avoid reapplication of a chunk after a program switch.
    programGlobal:true,

    build : function() {
    },

    draw : function(frameCtx) {

        var listeners = this.core.listeners;
        var renderListenerCtx = frameCtx.renderListenerCtx;

        for (var i = listeners.length - 1; i >= 0; i--) { // Child listeners first
            if (listeners[i](renderListenerCtx) === true) { // Call listener with query facade object as scope
                return true;
            }
        }
    }
});;/**
 * Create display state chunk type for draw and pick render of lookAt transform
 */
SceneJS_ChunkFactory.createChunkType({

    type: "lookAt",

    build : function() {

        this._uvMatrixDraw = this.program.draw.getUniform("SCENEJS_uVMatrix");
        this._uWorldEyeDraw = this.program.draw.getUniform("SCENEJS_uWorldEye");

        this._uvMatrixPick = this.program.pick.getUniform("SCENEJS_uVMatrix");
    },

    draw : function(frameCtx) {

        if (this.core.dirty) {
            this.core.rebuild();
        }

        var gl = this.program.gl;

        if (this._uvMatrixDraw) {
            this._uvMatrixDraw.setValue(this.core.mat);
        }

        if (this._uWorldEyeDraw) {
            this._uWorldEyeDraw.setValue(this.core.lookAt.eye);
        }

        frameCtx.viewMat = this.core.mat;
    },

    pick : function(frameCtx) {

        var gl = this.program.gl;

        if (this._uvMatrixPick) {
            this._uvMatrixPick.setValue(frameCtx.pickViewMatrix || this.core.mat);
        }

        frameCtx.viewMat = this.core.mat;
    }
});;SceneJS_ChunkFactory.createChunkType({

    type: "material",

    build: function () {

        var draw = this.program.draw;

        this._uMaterialBaseColor = draw.getUniform("SCENEJS_uMaterialColor");
        this._uMaterialSpecularColor = draw.getUniform("SCENEJS_uMaterialSpecularColor");
        this._uMaterialEmitColor = draw.getUniform("SCENEJS_uMaterialEmitColor");

        this._uMaterialShine = draw.getUniform("SCENEJS_uMaterialShine");
    },

    draw: function (frameCtx) {

        var gl = this.program.gl;

        if (this._uMaterialBaseColor) {
            this._uMaterialBaseColor.setValue(this.core.baseColor);
        }

        if (this._uMaterialSpecularColor) {
            this._uMaterialSpecularColor.setValue(this.core.specularColor);
        }

        if (this._uMaterialEmitColor) {
            this._uMaterialEmitColor.setValue(this.core.emitColor);
        }

        if (this._uMaterialSpecular) {
            this._uMaterialSpecular.setValue(this.core.specular);
        }

        if (this._uMaterialShine) {
            this._uMaterialShine.setValue(this.core.shine);
        }

        if (this._uMaterialEmit) {
            this._uMaterialEmit.setValue(this.core.emit);
        }

        if (this._uMaterialAlpha) {
            this._uMaterialAlpha.setValue(this.core.alpha);
        }
    }
});
;SceneJS_ChunkFactory.createChunkType({

    type: "program",

    build: function () {

        var draw = this.program.draw;
        var pick = this.program.pick;

        // Note that "program" chunks are always after "renderTarget" chunks
        this._depthModeDraw = draw.getUniform("SCENEJS_uDepthMode");
        this._pickMode = pick.getUniform("SCENEJS_uPickMode");
        this._uFogParamsDraw = draw.getUniform("SCENEJS_uFogParams"); // x = start, y = end, z = min, w = max
        this._uFogColorDraw = draw.getUniform("SCENEJS_uFogColor"); // RGB = color, a = density
        this._uXrayGlassFactorDraw = draw.getUniform("SCENEJS_uXrayGlassFactor");
        this._uXrayMurkinessDraw = draw.getUniform("SCENEJS_uXrayMurkiness");
        this._uXrayBGColorDraw = draw.getUniform("SCENEJS_uXrayBGColor");
    },

    draw: function (frameCtx) {
        var drawProgram = this.program.draw;
        drawProgram.bind();

        frameCtx.textureUnit = 0;
        
        var gl = this.program.gl;
        if (this._depthModeDraw) {
            this._depthModeDraw.setValue(frameCtx.depthMode);
        }
        if (!frameCtx.VAO) {
            for (var i = 0; i < 10; i++) {
                gl.disableVertexAttribArray(i);
            }
        }

        if (this._uDesatParamsDraw) {
            this._uDesatParamsDraw.setValue(frameCtx.desatParams);
        }

        if (this._uFogParamsDraw) {
            this._uFogParamsDraw.setValue(frameCtx.fogParams);
        }

        if (this._uFogColorDraw) {
            this._uFogColorDraw.setValue(frameCtx.fogColor);
        }

        if (this._uXrayGlassFactorDraw) {
            this._uXrayGlassFactorDraw.setValue(frameCtx.xrayGlassFactor);
        }

        if (this._uXrayMurkinessDraw) {
            this._uXrayMurkinessDraw.setValue(frameCtx.xrayMurkiness);
        }


        if (this._uXrayBGColorDraw) {
            this._uXrayBGColorDraw.setValue(frameCtx.xrayBGColor);
        }

        frameCtx.drawProgram = this.program.draw;
        frameCtx.useProgram++;
    },

    pick: function (frameCtx) {

        var pickProgram = this.program.pick;
        pickProgram.bind();

        var gl = this.program.gl;

        // Set the picking mode

        if (frameCtx.pickObject) {
            this._pickMode.setValue(0.0); // Pick object

        } else if (frameCtx.pickTriangle) {
            this._pickMode.setValue(1.0);// Pick triangle

        } else {
            this._pickMode.setValue(2.0); // Pick region
        }

        frameCtx.textureUnit = 0;

        for (var i = 0; i < 10; i++) {
            gl.disableVertexAttribArray(i);
        }
    }
});



;SceneJS_ChunkFactory.createChunkType({

    type: "regionMap",

    build: function () {
        this._uRegionMapRegionColor = this.program.draw.getUniform("SCENEJS_uRegionMapRegionColor");
        this._uRegionMapHighlightFactor = this.program.draw.getUniform("SCENEJS_uRegionMapHighlightFactor");
        this._uRegionMapHideAlpha = this.program.draw.getUniform("SCENEJS_uRegionMapHideAlpha");
        this._uRegionMapSampler = "SCENEJS_uRegionMapSampler";
    },

    draw: function (frameCtx) {

        var texture = this.core.texture;

        if (texture) {

            this.program.draw.bindTexture(this._uRegionMapSampler, texture, frameCtx.textureUnit);
            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;
        }

        var gl = this.program.gl;

        if (texture) {

            if (this._uRegionMapRegionColor) {
                this._uRegionMapRegionColor.setValue(this.core.regionColor);
            }

            if (this._uRegionMapHighlightFactor) {
                this._uRegionMapHighlightFactor.setValue(this.core.highlightFactor);
            }

            if (this._uRegionMapHideAlpha) {
                this._uRegionMapHideAlpha.setValue(this.core.hideAlpha);
            }

            frameCtx.regionMapUVLayerIdx = this.core.uvLayerIdx;

        } else {

            frameCtx.regionMapUVLayerIdx = -1;
        }
    },

    pick: function (frameCtx) {

        var texture = this.core.texture;

        if (texture) {

            frameCtx.regionData = this.core.regionData;

            frameCtx.textureUnit = 0;

            this.program.pick.bindTexture(this._uRegionMapSampler, texture, frameCtx.textureUnit);
            frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;

            frameCtx.regionMapUVLayerIdx = this.core.uvLayerIdx;

        } else {

            frameCtx.regionMapUVLayerIdx = -1;
        }
    }
});;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type:"view",

    // Avoid reapplication of a chunk after a program switch.
    programGlobal:true,

    build:function () {
    },

    drawAndPick:function (frameCtx) {

        var scissorTestEnabled = this.core.scissorTestEnabled;

        if (frameCtx.scissorTestEnabled != scissorTestEnabled) {
            var gl = this.program.gl;
            if (scissorTestEnabled) {
                gl.enable(gl.SCISSOR_TEST);
            } else {
                gl.disable(gl.SCISSOR_TEST);
            }
            frameCtx.scissorTestEnabled = scissorTestEnabled;
        }
    }
});
;/**
 *
 */
SceneJS_ChunkFactory.createChunkType({

    type:"style",

    // Avoid reapplication of a chunk after a program switch.
    programGlobal:true,

    drawAndPick:function (frameCtx) {

        var lineWidth = this.core.lineWidth;

        if (frameCtx.lineWidth != lineWidth) {
            var gl = this.program.gl;
            gl.lineWidth(lineWidth);
            frameCtx.lineWidth = lineWidth;
        }
    }
});
;SceneJS_ChunkFactory.createChunkType({

    type: "texture",

    build : function() {

        this._uTexSampler = this._uTexSampler || [];
        this._uTexMatrix = this._uTexMatrix || [];
        this._uTexBlendFactor = this._uTexBlendFactor || [];

        var layers = this.core.layers;

        if (layers) {

            var layer;
            var draw = this.program.draw;

            for (var i = 0, len = layers.length; i < len; i++) {

                layer = layers[i];

                this._uTexSampler[i] = "SCENEJS_uSampler" + i;

                this._uTexMatrix[i] = draw.getUniform("SCENEJS_uLayer" + i + "Matrix");

                this._uTexBlendFactor[i] = draw.getUniform("SCENEJS_uLayer" + i + "BlendFactor");
            }
        }
    },

    draw : function(frameCtx) {

        frameCtx.textureUnit = 0;
        frameCtx.hasNormalMap = false;
        
        var layers = this.core.layers;

        if (layers) {

            var draw = this.program.draw;
            var layer;

            for (var i = 0, len = layers.length; i < len; i++) {

                layer = layers[i];

                if (this._uTexSampler[i] && layer.texture) {    // Lazy-loads

                    draw.bindTexture(this._uTexSampler[i], layer.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;

                    frameCtx.bindTexture++;

                    if (layer._matrixDirty && layer.buildMatrix) {
                        layer.buildMatrix.call(layer);
                    }

                    if (this._uTexMatrix[i]) {
                        this._uTexMatrix[i].setValue(layer.matrixAsArray);
                    }

                    if (this._uTexBlendFactor[i]) {
                        this._uTexBlendFactor[i].setValue(layer.blendFactor);
                    }

                    frameCtx.hasNormalMap = frameCtx.hasNormalMap || layer.isNormalMap;

                } else {
                     // draw.bindTexture(this._uTexSampler[i], null, i); // Unbind
                }
            }
        }

        frameCtx.texture = this.core;
    }
});
;SceneJS_ChunkFactory.createChunkType({

    type: "fresnel",

    build: function () {

        var draw = this.program.draw;

        var core = this.core;

        if (core.diffuse) {
            this._uDiffuseFresnelCenterColor = draw.getUniform("SCENEJS_uDiffuseFresnelCenterColor");
            this._uDiffuseFresnelEdgeColor = draw.getUniform("SCENEJS_uDiffuseFresnelEdgeColor");
            this._uDiffuseFresnelPower = draw.getUniform("SCENEJS_uDiffuseFresnelPower");
        }

        if (core.specular) {
            this._uSpecularFresnelCenterColor = draw.getUniform("SCENEJS_uSpecularFresnelCenterColor");
            this._uSpecularFresnelEdgeColor = draw.getUniform("SCENEJS_uSpecularFresnelEdgeColor");
            this._uSpecularFresnelPower = draw.getUniform("SCENEJS_uSpecularFresnelPower");
        }

        if (core.alpha) {
            this._uAlphaFresnelCenterColor = draw.getUniform("SCENEJS_uAlphaFresnelCenterColor");
            this._uAlphaFresnelEdgeColor = draw.getUniform("SCENEJS_uAlphaFresnelEdgeColor");
            this._uAlphaFresnelPower = draw.getUniform("SCENEJS_uAlphaFresnelPower");
        }

        if (core.reflect) {
            this._uReflectFresnelCenterColor = draw.getUniform("SCENEJS_uReflectFresnelCenterColor");
            this._uReflectFresnelEdgeColor = draw.getUniform("SCENEJS_uReflectFresnelEdgeColor");
            this._uReflectFresnelPower = draw.getUniform("SCENEJS_uReflectFresnelPower");
        }

        if (core.emit) {
            this._uEmitFresnelCenterColor = draw.getUniform("SCENEJS_uEmitFresnelCenterColor");
            this._uEmitFresnelEdgeColor = draw.getUniform("SCENEJS_uEmitFresnelEdgeColor");
            this._uEmitFresnelPower = draw.getUniform("SCENEJS_uEmitFresnelPower");
        }

        if (core.fragment) {
            this._uFragmentFresnelCenterColor = draw.getUniform("SCENEJS_uFragmentFresnelCenterColor");
            this._uFragmentFresnelEdgeColor = draw.getUniform("SCENEJS_uFragmentFresnelEdgeColor");
            this._uFragmentFresnelPower = draw.getUniform("SCENEJS_uFragmentFresnelPower");
        }
    },

    draw: function (frameCtx) {

        var gl = this.program.gl;

        var core = this.core;

        if (core.diffuse) {

            if (this._uDiffuseFresnelCenterColor) {
                this._uDiffuseFresnelCenterColor.setValue(core.diffuse.centerColor);
            }

            if (this._uDiffuseFresnelEdgeColor) {
                this._uDiffuseFresnelEdgeColor.setValue(core.diffuse.edgeColor);
            }

            if (this._uDiffuseFresnelPower) {
                this._uDiffuseFresnelPower.setValue(core.diffuse.power);
            }
        }

        if (core.specular) {

            if (this._uSpecularFresnelCenterColor) {
                this._uSpecularFresnelCenterColor.setValue(core.specular.centerColor);
            }

            if (this._uSpecularFresnelEdgeColor) {
                this._uSpecularFresnelEdgeColor.setValue(core.specular.edgeColor);
            }

            if (this._uSpecularFresnelPower) {
                this._uSpecularFresnelPower.setValue(core.specular.power);
            }
        }

        if (core.alpha) {

            if (this._uAlphaFresnelCenterColor) {
                this._uAlphaFresnelCenterColor.setValue(core.alpha.centerColor);
            }

            if (this._uAlphaFresnelEdgeColor) {
                this._uAlphaFresnelEdgeColor.setValue(core.alpha.edgeColor);
            }

            if (this._uAlphaFresnelPower) {
                this._uAlphaFresnelPower.setValue(core.alpha.power);
            }
        }

        if (core.reflect) {

            if (this._uReflectFresnelCenterColor) {
                this._uReflectFresnelCenterColor.setValue(core.reflect.centerColor);
            }

            if (this._uReflectFresnelEdgeColor) {
                this._uReflectFresnelEdgeColor.setValue(core.reflect.edgeColor);
            }

            if (this._uReflectFresnelPower) {
                this._uReflectFresnelPower.setValue(core.reflect.power);
            }
        }

        if (core.emit) {

            if (this._uEmitFresnelCenterColor) {
                this._uEmitFresnelCenterColor.setValue(core.emit.centerColor);
            }

            if (this._uEmitFresnelEdgeColor) {
                this._uEmitFresnelEdgeColor.setValue(core.emit.edgeColor);
            }

            if (this._uEmitFresnelPower) {
                this._uEmitFresnelPower.setValue(core.emit.power);
            }
        }

        if (core.fragment) {

            if (this._uFragmentFresnelCenterColor) {
                this._uFragmentFresnelCenterColor.setValue(core.fragment.centerColor);
            }

            if (this._uFragmentFresnelEdgeColor) {
                this._uFragmentFresnelEdgeColor.setValue(core.fragment.edgeColor);
            }

            if (this._uFragmentFresnelPower) {
                this._uFragmentFresnelPower.setValue(core.fragment.power);
            }
        }
    }
});
;SceneJS_ChunkFactory.createChunkType({

    type: "cubemap",

    build: function () {
        this._uCubeMapSampler = this._uCubeMapSampler || [];
        this._uCubeMapIntensity = this._uCubeMapIntensity || [];
        var layers = this.core.layers;
        if (layers) {
            var layer;
            var draw = this.program.draw;
            for (var i = 0, len = layers.length; i < len; i++) {
                layer = layers[i];
                this._uCubeMapSampler[i] = "SCENEJS_uCubeMapSampler" + i;
                this._uCubeMapIntensity[i] = draw.getUniform("SCENEJS_uCubeMapIntensity" + i);
            }
        }
    },

    draw: function (frameCtx) {
        var layers = this.core.layers;
        if (layers) {
            var layer;
            var draw = this.program.draw;
            for (var i = 0, len = layers.length; i < len; i++) {
                layer = layers[i];
                if (this._uCubeMapSampler[i] && layer.texture) {

                    draw.bindTexture(this._uCubeMapSampler[i], layer.texture, frameCtx.textureUnit);
                    frameCtx.textureUnit = (frameCtx.textureUnit + 1) % SceneJS.WEBGL_INFO.MAX_TEXTURE_UNITS;

                    if (this._uCubeMapIntensity[i]) {
                        this._uCubeMapIntensity[i].setValue(layer.intensity);
                    }
                }
            }
        }
    }
});;SceneJS_ChunkFactory.createChunkType({

    type: "xform",

    build: function () {

        var draw = this.program.draw;

        this._uMatLocationDraw = draw.getUniform("SCENEJS_uMMatrix");
        this._uNormalMatLocationDraw = draw.getUniform("SCENEJS_uMNMatrix");

        var pick = this.program.pick;

        this._uMatLocationPick = pick.getUniform("SCENEJS_uMMatrix");
    },

    draw: function (frameCtx) {

        /* Rebuild core's matrix from matrices at cores on path up to root
         */
        var coreRebuilt = false;

        if (SceneJS_configsModule.configs.forceXFormCoreRebuild === true || this.core.dirty && this.core.build) {
            this.core.build();
            coreRebuilt = true;
        }

        var gl = this.program.gl;

        if (this._uMatLocationDraw) {
            this._uMatLocationDraw.setValue(this.core.mat);
        }

        if (this._uNormalMatLocationDraw) {
            this._uNormalMatLocationDraw.setValue(this.core.normalMat);
        }

        frameCtx.modelMat = this.core.mat;
    },

    pick: function (frameCtx) {

        /* Rebuild core's matrix from matrices at cores on path up to root
         */
        if (this.core.dirty) {
            this.core.build();
        }

        var gl = this.program.gl;

        if (this._uMatLocationPick) {
            this._uMatLocationPick.setValue(this.core.mat);
        }

        frameCtx.modelMat = this.core.mat;
    }
});
;// SceneJS configuration
SceneJS.configure({

    // Point SceneJS at where dynamically-loaded plugins live
    // This is relative to the index document
    pluginPath: location.origin + location.pathname.substring(0, location.pathname.lastIndexOf("/")) + "/lib/scenejs/plugins"
});;/**
 * Box geometry node type
 *
 * @author xeolabs / http://xeolabs.com
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/box",
 *      xSize: 10,
 *      ySize: 20,
 *      zSize: 1.5,
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/box", {

        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        var x, y, z;
        if (params.size) {
            x = params.size[0];
            y = params.size[1];
            z = params.size[2];
        } else {
            // Deprecated
            x = params.xSize || 1;
            y = params.ySize || 1;
            z = params.zSize || 1;
        }

        var coreId = "geometry/box_" + x + "_" + y + "_" + z + (params.wire ? "wire" : "_solid");

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type:"geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry
        return {
            type:"geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId:coreId,
            positions:new Float32Array([
                x, y, z, -x, y, z, -x, -y, z, x, -y, z, // v0-v1-v2-v3 front
                x, y, z, x, -y, z, x, -y, -z, x, y, -z, // v0-v3-v4-v5 right
                x, y, z, x, y, -z, -x, y, -z, -x, y, z, // v0-v5-v6-v1 top
                -x, y, z, -x, y, -z, -x, -y, -z, -x, -y, z, // v1-v6-v7-v2 left
                -x, -y, -z, x, -y, -z, x, -y, z, -x, -y, z, // v7-v4-v3-v2 bottom
                x, -y, -z, -x, -y, -z, -x, y, -z, x, y, -z // v4-v7-v6-v5 back
            ]),
            normals:new Float32Array([
                0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, // v0-v1-v2-v3 front
                1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, // v0-v3-v4-v5 right
                0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, // v0-v5-v6-v1 top
                -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, // v1-v6-v7-v2 left
                0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, // v7-v4-v3-v2 bottom
                0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1     // v4-v7-v6-v5 back
            ]),
            uv:new Float32Array([
                x, y, 0, y, 0, 0, x, 0, // v0-v1-v2-v3 front
                0, y, 0, 0, x, 0, x, y, // v0-v3-v4-v5 right
                x, 0, x, y, 0, y, 0, 0, // v0-v5-v6-v1 top
                x, y, 0, y, 0, 0, x, 0, // v1-v6-v7-v2 left
                0, 0, x, 0, x, y, 0, y, // v7-v4-v3-v2 bottom
                0, 0, x, 0, x, y, 0, y    // v4-v7-v6-v5 back
            ]),
            indices:new Uint16Array([
                0, 1, 2, 0, 2, 3, // front
                4, 5, 6, 4, 6, 7, // right
                8, 9, 10, 8, 10, 11, // top
                12, 13, 14, 12, 14, 15, // left
                16, 17, 18, 16, 18, 19, // bottom
                20, 21, 22, 20, 22, 23   // back
            ])
        };
    }
})();;/**
 * Quad geometry node type
 *
 *  @author xeolabs / http://xeolabs.com
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/quad",
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/quad", {
        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        // TODO: support size properties like 'geometry/plane'

        var coreId = "geometry/quad" + (params.wire ? "wire" : "_solid");

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type: "geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry
        return {
            type: "geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId:coreId,
            positions:[ 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0 ],
            normals:[ -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0 ],
            uv:[ 1, 1, 0, 1, 0, 0, 1, 0 ],
            indices:[ 0, 1, 2, 0, 2, 3 ]
        };
    }
})();;/**
 * Sphere geometry node type
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/sphere",
 *      latitudeBands: 30, // Default
 *      longitudeBands: 30, // Default
 *      radius: 1, // Default
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/sphere", {

        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        // Thanks awfully to: http://learningwebgl.com/cookbook/index.php/How_to_draw_a_sphere

        var latitudeBands = params.latitudeBands || 30;
        var longitudeBands = params.longitudeBands || 30;
        var radius = params.radius || 1;

        var coreId = "geometry/sphere_" + (params.wire ? "wire" : "_solid") + radius + "_" + longitudeBands + "_" + latitudeBands;

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type: "geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry

        var positions = [];
        var normals = [];
        var uvs = [];
        for (var latNumber = 0; latNumber <= latitudeBands; latNumber++) {
            var theta = latNumber * Math.PI / latitudeBands;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            for (var longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                var phi = longNumber * 2 * Math.PI / longitudeBands;
                var sinPhi = Math.sin(phi);
                var cosPhi = Math.cos(phi);

                var x = cosPhi * sinTheta;
                var y = cosTheta;
                var z = sinPhi * sinTheta;
                var u = 1- (longNumber / longitudeBands);
                var v = latNumber / latitudeBands;

                normals.push(x);
                normals.push(y);
                normals.push(z);
                uvs.push(u);
                uvs.push(v);
                positions.push(radius * x);
                positions.push(radius * y);
                positions.push(radius * z);
            }
        }

        var indices = [];
        for (var latNumber = 0; latNumber < latitudeBands; latNumber++) {
            for (var longNumber = 0; longNumber < longitudeBands; longNumber++) {
                var first = (latNumber * (longitudeBands + 1)) + longNumber;
                var second = first + longitudeBands + 1;
                indices.push(first + 1);
                indices.push(second + 1);
                indices.push(second);
                indices.push(first + 1);
                indices.push(second);
                indices.push(first);
            }
        }

        return {
            type: "geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId : coreId,
            positions : new Float32Array(positions),
            normals: new Float32Array(normals),
            uv : new Float32Array(uvs),
            indices : new Uint16Array(indices)
        };
    }
})();;/**
 * Plane geometry node type
 *
 * @author xeolabs / http://xeolabs.com
 *
 * <p>Usage example:</p>
 *
 * <pre>
 * someNode.addNode({
 *      type: "geometry/plane",
 *      width: 10,
 *      height: 20,
 *      wire: false // Default
 *  });
 *  </pre>
 */
(function () {

    SceneJS.Types.addType("geometry/plane", {

        construct:function (params) {
            this.addNode(build.call(this, params));
        }
    });

    function build(params) {

        var width = params.width || 1.0;
        var height = params.height || 1.0;

        var widthSegments = params.widthSegments || 1;
        var heightSegments = params.heightSegments || 1;

        var coreId = "geometry/plane_" + (params.wire == true ? "wire_" : "") + height + "_" + widthSegments + "_" + heightSegments;

        // If a node core already exists for a prim with the given properties,
        // then for efficiency we'll share that core rather than create another geometry
        if (this.getScene().hasCore("geometry", coreId)) {
            return {
                type: "geometry",
                coreId:coreId
            };
        }

        // Otherwise, create a new geometry

        var positions = [];
        var normals = [];
        var uvs = [];
        var indices = [];

        var ix, iz;
        var halfWidth = width / 2;
        var halfHeight = height / 2;

        var gridX = widthSegments;
        var gridZ = heightSegments;

        var gridX1 = gridX + 1;
        var gridZ1 = gridZ + 1;

        var segWidth = width / gridX;
        var segHeight = height / gridZ;

        var x;
        var y;

        for (iz = 0; iz < gridZ1; iz++) {
            for (ix = 0; ix < gridX1; ix++) {

                x = ix * segWidth - halfWidth;
                y = iz * segHeight - halfHeight;

                positions.push(x);
                positions.push(-y);
                positions.push(0);

                normals.push(0);
                normals.push(0);
                normals.push(1);

                uvs.push(ix / gridX);
                uvs.push(1 - iz / gridZ);
            }
        }

        var a;
        var b;
        var c;
        var d;

        for (iz = 0; iz < gridZ; iz++) {
            for (ix = 0; ix < gridX; ix++) {

                a = ix + gridX1 * iz;
                b = ix + gridX1 * ( iz + 1 );
                c = ( ix + 1 ) + gridX1 * ( iz + 1 );
                d = ( ix + 1 ) + gridX1 * iz;

                indices.push(a);
                indices.push(b);
                indices.push(c);

                indices.push(c);
                indices.push(d);
                indices.push(a);
            }
        }

        return {
            type: "geometry",
            primitive:params.wire ? "lines" : "triangles",
            coreId:coreId,
            positions:new Float32Array(positions),
            normals:new Float32Array(normals),
            uv:new Float32Array(uvs),
            indices:new Uint16Array(indices)
        };
    }
})();
;/**
 * @namespace The core engine namespace.
 */
(function () {
    "use strict";

    var Human = window.Human = {};

    var VERSION = "10.2.2";
    VERSION = VERSION.indexOf("ENGINE_VERSION") > 0 ? "qa" : VERSION;

    var API_VERSION = "2.0.1";
    API_VERSION = API_VERSION.indexOf("API_VERSION") > 0 ? "qa" : API_VERSION;


    /**
     * Engine version.
     *
     * @memberof Human
     * @name VERSION
     * @property
     * @type {string}
     */
    Human.VERSION = VERSION;
    Human.API_VERSION = API_VERSION;

    /** True when this engine instance is running on the Web
     *
     * @type {boolean}
     * @memberof Human
     */
    Human.deployed = !( window.location.hostname.match(/(localhost|192\.168\.11\.\d{1,3})/) ||
        window.location.protocol === "file:" );
		
     /** The language used for content requests.
     *
     * @type {string}
     * @memberof Human
     */
    Human.locale = "en-US";

    Human.timer = window.performance || window.Date;

    Human.stats = {
        trackingDownloadSize: false,
        jsonDownloadTotal: 0,
        geometryDownloadTotal: 0,
        textureDownloadTotal: 0,
        jsonDownloadSizes: {},
        geometryDownloadSizes: {},
        textureDownloadSizes: {},
        loadSequence: {
            startTime: Human.timer.now(),
            moduleRequest: 0,
            moduleLoaded: 0,
            assetsRequested: 0,
            assetsLoaded: 0,
            texturesRequested: 0,
            texturesLoaded: 0
        },
        loadTimes: {
            preModule: 0,
            moduleDownload: 0,
            preAsset: 0,
            assetDownload: 0,
            preTexture: 0,
            textureDownload: 0
        },
        trackDownloadSize: function() {
            if (window.pako) {
                this.trackingDownloadSize = true;
            }
        }
    };

    /* IDs of nodes in the document and scene graph
     */
    Human.CANVAS_ID = "theCanvas";
    Human.ANNOTATION_CANVAS_ID = "annotationCanvas";
    Human.CONTAINER_ID = "container";
    Human.SCENE_ROOT_ID = "bds-human";
    Human.CONTENT_ROOT_ID = "outline";
    Human.MATERIAL_ROOT_ID = "human.outline";
    Human.NULL_OBJECT_ID = "null-object";   // ID of invisible object at origin, used for anchoring things like labels to
    Human.NULL_OBJECT_ID2 = "null-object-2";   // ID of invisible object at origin, used for anchoring things like labels to
    Human.CLIP_INDICATORS_ATTACH_ID = "clip-indicators";
    Human.CLIP_ATTACH_ID = "clips";
    Human.LOOKAT_ID = "theLookat";
    Human.CAMERA_ID = "theCamera";
    Human.VIEW_SPACE_ID = "viewSpace";

    /*-----------------------------------------------------------------------------------------------------------------
     * Error management
     *---------------------------------------------------------------------------------------------------------------*/

    SceneJS.bind("error",
        function (e) {
            Human._error("WEBGL", e.errorName, e.exception, true);
        });

    /**
     * Signals non-fatal error.
     * @memberof Human
     */
    Human.error = function (name, msg) {
        if (msg === undefined) {
            msg = name;
            name = "ERROR";
        }
        return Human._error("HUMAN", name, msg, false);
    };

    /**
     * Signals fatal error.
     * @memberof Human
     */
    Human.fatalError = function (name, msg) {
        if (msg === undefined) {
            msg = name;
            name = "ERROR";
        }
        return Human._error("HUMAN", name, msg, true);
    };

    Human._error = function (type, name, msg, fatal) {

        Human.events.fire("error", {
            type: type,
            name: name,
            message: msg,
            fatal: fatal,
            log: Human.log.messages.join("\n"),
            stack: Human.utils.getStackTrace(),
            webglInfo: SceneJS.WEBGL_INFO
        });

        return msg;
    };

    var annotationCanvas = document.getElementById(Human.ANNOTATION_CANVAS_ID);

    // Chrome seems to switch to WebGL canvas if not initialized?
    // On Windows/Linux
    if (annotationCanvas) {
        annotationCanvas.getContext("2d");
    }

})();

;/**
 * @class Base class for the various engine modules.
 *
 * @constructor
 */

(function() {
    "use strict";

    Human.Component = function () {

    };


    Human.Component.prototype = {

        _init:function (ctx) {

            this._ctx = ctx;

            this._handleMap = new Human.utils.Map(); // Subscription handle pool
            this._topicSubs = {}; // A [handle -> callback] map for each topic name
            this._handleTopics = {}; // Maps handles to topic names
            this._topicPubs = {}; // Maps topics to publications
        },

        /**
         * Publishes to a topic.
         *
         * Immediately notifies existing subscriptions to that topic, retains the publication to give to
         * any subsequent notifications on that topic as they are made.
         *
         * This is called internally by proxies. Only they create publications, which are subscribed
         * to by client code.
         *
         * @param topic Publication topic
         * @param pub The publication
         * @param once True to publish once ie. not retain
         * @private
         */
        publish:function (topic, pub, once) {
            if (!once) {
                this._topicPubs[topic] = pub; // Save notification
            }
            var subsForTopic = this._topicSubs[topic];
            if (subsForTopic) { // Notify subscriptions
                for (var handle in subsForTopic) {
                    if (subsForTopic.hasOwnProperty(handle)) {
                        subsForTopic[handle].call(this, pub);
                    }
                }
            }
        },

        /**
         * Listen for data changes at a particular location on this component.
         *
         * <p>This is the primary way to read data from the Human API. Your callback will be triggered for
         * the initial data and again whenever the data changes. Use {@link #unsubscribe} to stop receiving updates.</p>
         *
         * <p>The callback is be called with this component as scope.</p>
         *
         * @param {String} topic Publication location
         * @param {Function(data)} callback Called when fresh data is available at the location
         * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
         */
        on:function (topic, callback) {
            var subsForTopic = this._topicSubs[topic];
            if (!subsForTopic) {
                subsForTopic = {};
                this._topicSubs[topic] = subsForTopic;
            }
            var handle = this._handleMap.addItem(); // Create unique handle
            subsForTopic[handle] = callback;
            this._handleTopics[handle] = topic;
            var pub = this._topicPubs[topic];
            if (pub) { // A publication exists, notify callback immediately
                callback.call(this, pub);
            }
            return handle;
        },

        /**
         * Unsubscribes from a publication on this proxy that was previously made with {@link #on}.
         * @param handle Publication handle
         */
        off:function (handle) {
            var topic = this._handleTopics[handle];
            if (topic) {
                delete this._handleTopics[handle];
                var topicSubs = this._topicSubs[topic];
                if (topicSubs) {
                    delete topicSubs[handle];
                }
                this._handleMap.removeItem(handle); // Release handle
            }
        },

        /**
         * Listens for exactly one data update at the specified location, and then stops listening.
         * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
         * @param {String} topic Data location to listen to
         * @param {Function(data)} callback Called when fresh data is available at the location
         */
        once:function (topic, callback) {
            var self = this;
            var sub = this.on(topic,
                function (pub) {
                    self.off(sub);
                    callback(pub);
                });
        }
    };

})();

;
/**
 * @namespace Math functions
 * @private
 */

(function() {
    "use strict";

    var HumanMath = Human.math = {
        X_AXIS: vec3.fromValues(1, 0, 0),
        Y_AXIS: vec3.fromValues(0, 1, 0),
        Z_AXIS: vec3.fromValues(0, 0, 1),
        VEC3_ZEROS: vec3.fromValues(0, 0, 0),
        VEC3_ONES: vec3.fromValues(1, 1, 1),
        TO_RADIANS: Math.PI / 180.0
    };

    HumanMath.clamp = function(u, min, max) {
       return (u < min) ? min : ((u > max) ? max : u);
    };

    /**
     *
     */
    HumanMath.lerpVec3 = function(t, t1, t2, p1, p2, dest) {
        dest = dest || vec3.create();
        var f = (t - t1) / (t2 - t1);

        dest[0] = p1[0] + (f * (p2[0] - p1[0]));
        dest[1] = p1[1] + (f * (p2[1] - p1[1]));
        dest[2] = p1[2] + (f * (p2[2] - p1[2]));

        return dest;
    };


    /**
     * @return short rotation from r1 to r2
     */
    HumanMath.getShortRotation = function (r1, r2) {
        var flip = r2 > r1 ? 1 : -1;
        var gap = (r2 - r1) * flip;
        gap = (gap + Math.PI) % (Math.PI * 2) - Math.PI;
        return gap * flip;
    };

    /**
     * f: [0, 1]
     * r1, r2 : [-PI, PI]
     */
    HumanMath.lerpRadian = function (f, r1, r2) {
        var gap = HumanMath.getShortRotation(r1, r2);
        var result = r1 + f * gap;
        return result;
    };

    /**
     *
     */
    HumanMath.lerpVec3Cylindrical = function(t, t1, t2, p1, p2, dest) {
        dest = dest || vec3.create();
        var f = (t - t1) / (t2 - t1);

        dest[0] = p1[0] + (f * (p2[0] - p1[0]));
        dest[1] = HumanMath.lerpRadian(f, p1[1], p2[1]);
        dest[2] = p1[2] + (f * (p2[2] - p1[2]));

        return dest;
    };

    /**
     *
     */
    Human.math.vec3ObjToArray = function(v, dest) {
        var result = dest || vec3.create();

        result[0] = v.x || 0;
        result[1] = v.y || 0;
        result[2] = v.z || 0;

        return result;
    };

    /**
     *
     */
    Human.math.vec3ArrayToObj = function(v) {
        return { x: v[0], y: v[1], z: v[2] };
    };

    /** cartesian coordinate (x,y,z) to cylindrical coordinate (r, theta, h)
     * x - left, y - up, z - in (right hand)
     * r = x^2 + z^2
     * theta = atan2(x, z)
     * h = y
     */
    HumanMath.cartesianToCylindrical = function (v, dest) {
        var result = dest || vec3.create();

        result[0] = Math.sqrt( v[0] * v[0] + v[2] * v[2]);
        result[1] = Math.atan2( v[0], v[2] );
        result[2] = v[1];

        return result;
    };

    /** cylindrical coordinate (r, theta, h) to cartesian coordinate (x,y,z)
     * x - left, y - up, z - in (right hand)
     * x = r * sin(theta)
     * y = h
     * z = r * cos(theta)
     */
    HumanMath.cylindricalToCartesian = function (v, dest) {
        var result = dest || vec3.create();

        result[0] = v[0] * Math.sin(v[1]);
        result[1] = v[2];
        result[2] = v[0] * Math.cos(v[1]);

        return result;
    };

    /** @private
     *
     * @param min
     * @param max
     */
    HumanMath.AxisBox3 = function(min, max) {
        this.verts = [
            [min[0], min[1], min[2]],
            [max[0], min[1], min[2]],
            [max[0], max[1], min[2]],
            [min[0], max[1], min[2]],

            [min[0], min[1], max[2]],
            [max[0], min[1], max[2]],
            [max[0], max[1], max[2]],
            [min[0], max[1], max[2]]
        ];
    };

    /**
     * Note: Assume 0 <= t <= 1
     */
    HumanMath.easeOut = function (t, b, c) {
        var ts = t * t;
        var tc = ts * t;
        return b + c * (-1 * ts * ts + 4 * tc + -6 * ts + 4 * t);
    };

    /**
     * Note: Assume 0 <= t <= 1
     */
    HumanMath.easeIn = function (t, b, c) {
        return 1 - HumanMath.easeOut(1 - t, b, c);
    };

    /**
     * Note: Assume 0 <= t <= 1
     */
    HumanMath.easeInOut = function (t, b, c) {
        if (t < 0.5) {
            return HumanMath.easeIn(2 * t, b, c) / 2;      
        } else {
            return HumanMath.easeOut(2 * t - 1, b, c) * 0.5 + 0.5;
        }
    };

    /**
     *
     */
    HumanMath.getBoundaryCenter = function(boundary, dest) {
        var r = dest || vec3.create();

        r[0] = (boundary.xmax + boundary.xmin ) * 0.5;
        r[1] = (boundary.ymax + boundary.ymin ) * 0.5;
        r[2] = (boundary.zmax + boundary.zmin ) * 0.5;

        return r;
    };
    /**
     *
     */
    var diag = vec3.create();
    HumanMath.getBoundaryDiag = function(boundary) {

        diag[0] = boundary.xmax - boundary.xmin;
        diag[1] = boundary.ymax - boundary.ymin;
        diag[2] = boundary.zmax - boundary.zmin;

        return vec3.length(diag);
    };

    var scaleMat = mat4.create();
    var rotateZMat = mat4.create();
    var rotateYMat = mat4.create();
    var rotateXMat = mat4.create();
    var result = mat4.create();

    HumanMath.buildRotationScaleMat3 = function(out, rotate, scale) {
        rotate = rotate || this.VEC3_ZEROS;
        scale = scale || this.VEC3_ONES;

        mat4.fromScaling(scaleMat, scale);
        mat4.fromZRotation(rotateZMat, rotate[2] * this.TO_RADIANS);
        mat4.fromYRotation(rotateYMat, rotate[1] * this.TO_RADIANS);
        mat4.fromXRotation(rotateXMat, rotate[0] * this.TO_RADIANS);


        mat4.multiply(result, rotateXMat, scaleMat);
        mat4.multiply(result, rotateYMat, result);
        mat4.multiply(result, rotateZMat, result);
        
        return mat3.fromMat4(out, result);
    };

})();
;/**
  A javascript Bezier curve library by Pomax.

  Based on http://pomax.github.io/bezierinfo

  This code is MIT licensed.
**/
(function() {
  "use strict";

    // math-inlining.
  var abs = Math.abs,
      cos = Math.cos,
      sin = Math.sin,
      atan2 = Math.atan2,
      sqrt = Math.sqrt,
      pow = Math.pow,
      // a zero coordinate, which is surprisingly useful
      ZERO = {x:0,y:0,z:0};


  // Bezier utils 
  var bezierUtils = {
    // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
    Tvalues: [
      -0.0640568928626056260850430826247450385909,
      0.0640568928626056260850430826247450385909,
      -0.1911188674736163091586398207570696318404,
      0.1911188674736163091586398207570696318404,
      -0.3150426796961633743867932913198102407864,
      0.3150426796961633743867932913198102407864,
      -0.4337935076260451384870842319133497124524,
      0.4337935076260451384870842319133497124524,
      -0.5454214713888395356583756172183723700107,
      0.5454214713888395356583756172183723700107,
      -0.6480936519369755692524957869107476266696,
      0.6480936519369755692524957869107476266696,
      -0.7401241915785543642438281030999784255232,
      0.7401241915785543642438281030999784255232,
      -0.8200019859739029219539498726697452080761,
      0.8200019859739029219539498726697452080761,
      -0.8864155270044010342131543419821967550873,
      0.8864155270044010342131543419821967550873,
      -0.9382745520027327585236490017087214496548,
      0.9382745520027327585236490017087214496548,
      -0.9747285559713094981983919930081690617411,
      0.9747285559713094981983919930081690617411,
      -0.9951872199970213601799974097007368118745,
      0.9951872199970213601799974097007368118745
    ],

    // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
    Cvalues: [
      0.1279381953467521569740561652246953718517,
      0.1279381953467521569740561652246953718517,
      0.1258374563468282961213753825111836887264,
      0.1258374563468282961213753825111836887264,
      0.1216704729278033912044631534762624256070,
      0.1216704729278033912044631534762624256070,
      0.1155056680537256013533444839067835598622,
      0.1155056680537256013533444839067835598622,
      0.1074442701159656347825773424466062227946,
      0.1074442701159656347825773424466062227946,
      0.0976186521041138882698806644642471544279,
      0.0976186521041138882698806644642471544279,
      0.0861901615319532759171852029837426671850,
      0.0861901615319532759171852029837426671850,
      0.0733464814110803057340336152531165181193,
      0.0733464814110803057340336152531165181193,
      0.0592985849154367807463677585001085845412,
      0.0592985849154367807463677585001085845412,
      0.0442774388174198061686027482113382288593,
      0.0442774388174198061686027482113382288593,
      0.0285313886289336631813078159518782864491,
      0.0285313886289336631813078159518782864491,
      0.0123412297999871995468056670700372915759,
      0.0123412297999871995468056670700372915759
    ],

    arcfn: function(t, derivativeFn) {
      var d = derivativeFn(t);
      var l = d.x*d.x + d.y*d.y;
      if(typeof d.z !== "undefined") {
        l += d.z*d.z;
      }
      return sqrt(l);
    },

    length: function(derivativeFn) {
      var z=0.5,sum=0,len=bezierUtils.Tvalues.length,i,t;
      for(i=0; i<len; i++) {
        t = z * bezierUtils.Tvalues[i] + z;
        sum += bezierUtils.Cvalues[i] * bezierUtils.arcfn(t,derivativeFn);
      }
      return z * sum;
    },

    map: function(v, ds,de, ts,te) {
      var d1 = de-ds, d2 = te-ts, v2 =  v-ds, r = v2/d1;
      return ts + d2*r;
    },

    lerp: function(r, v1, v2) {
      var ret = {
        x: v1.x + r*(v2.x-v1.x),
        y: v1.y + r*(v2.y-v1.y)
      };
      if(!!v1.z && !!v2.z) {
        ret.z =  v1.z + r*(v2.z-v1.z);
      }
      return ret;
    },

    pointToString: function(p) {
      var s = p.x+"/"+p.y;
      if(typeof p.z !== "undefined") {
        s += "/"+p.z;
      }
      return s;
    },

    pointsToString: function(points) {
      return "[" + points.map(bezierUtils.pointToString).join(", ") + "]";
    },

    angle: function(o,v1,v2) {
      var dx1 = v1.x - o.x,
          dy1 = v1.y - o.y,
          dx2 = v2.x - o.x,
          dy2 = v2.y - o.y,
          cross = dx1*dy2 - dy1*dx2,
          m1 = sqrt(dx1*dx1+dy1*dy1),
          m2 = sqrt(dx2*dx2+dy2*dy2),
          dot;
      dx1/=m1; dy1/=m1; dx2/=m2; dy2/=m2;
      dot = dx1*dx2 + dy1*dy2;
      return atan2(cross, dot);
    },

    dist: function(p1, p2) {
      var dx = p1.x - p2.x,
          dy = p1.y - p2.y;
      return sqrt(dx*dx+dy*dy);
    },

    abcratio: function(t, n) {
      // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var bottom = pow(t,n) + pow(1-t,n), top = bottom - 1;
      return abs(top/bottom);
    },

    projectionratio: function(t, n) {
      // see u(t) note on http://pomax.github.io/bezierinfo/#abc
      if (n!==2 && n!==3) {
        return false;
      }
      if (typeof t === "undefined") {
        t = 0.5;
      } else if (t===0 || t===1) {
        return t;
      }
      var top = pow(1-t, n), bottom = pow(t,n) + top;
      return top/bottom;
    },

    align: function(points, line) {
      var tx = line.p1.x,
          ty = line.p1.y,
          a = -atan2(line.p2.y-ty, line.p2.x-tx),
          d = function(v) {
            return {
              x: (v.x-tx)*cos(a) - (v.y-ty)*sin(a),
              y: (v.x-tx)*sin(a) + (v.y-ty)*cos(a)
            };
          };
      return points.map(d);
    }

  };
  
  //--------------------------------------


  /**
   * Bezier curve constructor. The constructor argument can be one of three things:
   *
   * 1. array/4 of {x:..., y:..., z:...}, z optional
   * 2. numerical array/8 ordered x1,y1,x2,y2,x3,y3,x4,y4
   * 3. numerical array/12 ordered x1,y1,z1,x2,y2,z2,x3,y3,z3,x4,y4,z4
   *
   */
  var Bezier = Human.math.bezier = function(coords) {
    var args = (coords && coords.forEach) ? coords : [].slice.call(arguments);
    var coordlen = false;
    if(typeof args[0] === "object") {
      coordlen = args.length;
      var newargs = [];
      args.forEach(function(point) {
        ['x','y','z'].forEach(function(d) {
          if(typeof point[d] !== "undefined") {
            newargs.push(point[d]);
          }
        });
      });
      args = newargs;
    }
    var higher = false;
    var len = args.length;
    if (coordlen) {
      if(coordlen>4) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
        higher = true;
      }
    } else {
      if(len!==6 && len!==8 && len!==9 && len!==12) {
        if (arguments.length !== 1) {
          throw new Error("Only new Bezier(point[]) is accepted for 4th and higher order curves");
        }
      }
    }
    var _3d = (!higher && (len === 9 || len === 12)) || (coords && coords[0] && typeof coords[0].z !== "undefined");
    this._3d = _3d;
    var points = [];
    for(var idx=0, step=(_3d ? 3 : 2); idx<len; idx+=step) {
      var point = {
        x: args[idx],
        y: args[idx+1]
      };
      if(_3d) { point.z = args[idx+2]; }
      points.push(point);
    }
    this.order = points.length - 1;
    this.points = points;
    var dims = ['x','y'];
    if(_3d) {dims.push('z');}
    this.dims = dims;
    this.dimlen = dims.length;
    (function(curve) {
      var a = bezierUtils.align(points, {p1:points[0], p2:points[curve.order]});
      for(var i=0; i<a.length; i++) {
        if(abs(a[i].y) > 0.0001) {
          curve._linear = false;
          return;
        }
      }
      curve._linear = true;
    }(this));
    this._t1 = 0;
    this._t2 = 1;
    this.update();
  };

  function getABC(n,S,B,E,t) {
    if(typeof t === "undefined") { t = 0.5; }
    var u = bezierUtils.projectionratio(t,n),
        um = 1-u,
        C = {
          x: u*S.x + um*E.x,
          y: u*S.y + um*E.y
        },
        s = bezierUtils.abcratio(t,n),
        A = {
          x: B.x + (B.x-C.x)/s,
          y: B.y + (B.y-C.y)/s
        };
    return { A:A, B:B, C:C };
  }

  Bezier.quadraticFromPoints = function(p1,p2,p3, t) {
    if(typeof t === "undefined") { t = 0.5; }
    // shortcuts, although they're really dumb
    if(t===0) { return new Bezier(p2,p2,p3); }
    if(t===1) { return new Bezier(p1,p2,p2); }
    // real fitting.
    var abc = getABC(2,p1,p2,p3,t);
    return new Bezier(p1, abc.A, p3);
  };

  Bezier.cubicFromPoints = function(S,B,E, t,d1) {
    if(typeof t === "undefined") { t = 0.5; }
    var abc = getABC(3,S,B,E,t);
    if(typeof d1 === "undefined") { d1 = bezierUtils.dist(B,abc.C); }
    var d2 = d1 * (1-t)/t;

    var selen = bezierUtils.dist(S,E),
        lx = (E.x-S.x)/selen,
        ly = (E.y-S.y)/selen,
        bx1 = d1 * lx,
        by1 = d1 * ly,
        bx2 = d2 * lx,
        by2 = d2 * ly;
    // derivation of new hull coordinates
    var e1  = { x: B.x - bx1, y: B.y - by1 },
        e2  = { x: B.x + bx2, y: B.y + by2 },
        A = abc.A,
        v1  = { x: A.x + (e1.x-A.x)/(1-t), y: A.y + (e1.y-A.y)/(1-t) },
        v2  = { x: A.x + (e2.x-A.x)/(t), y: A.y + (e2.y-A.y)/(t) },
        nc1 = { x: S.x + (v1.x-S.x)/(t), y: S.y + (v1.y-S.y)/(t) },
        nc2 = { x: E.x + (v2.x-E.x)/(1-t), y: E.y + (v2.y-E.y)/(1-t) };
    // ...done
    return new Bezier(S,nc1,nc2,E);
  };


  Bezier.prototype = {
    valueOf: function() {
      return this.toString();
    },
    toString: function() {
      return bezierUtils.pointsToString(this.points);
    },
    update: function() {
      // one-time compute derivative coordinates
      this.dpoints = [];
      for(var p=this.points, d=p.length, c=d-1; d>1; d--, c--) {
        var list = [];
        for(var j=0, dpt; j<c; j++) {
          dpt = {
            x: c * (p[j+1].x - p[j].x),
            y: c * (p[j+1].y - p[j].y)
          };
          if(this._3d) {
            dpt.z = c * (p[j+1].z - p[j].z);
          }
          list.push(dpt);
        }
        this.dpoints.push(list);
        p = list;
      }
      this.computedirection();
    },
    computedirection: function() {
      var points = this.points;
      var angle = bezierUtils.angle(points[0], points[this.order], points[1]);
      this.clockwise = angle > 0;
    },
    length: function() {
      return bezierUtils.length(this.derivative.bind(this));
    },
    _lut: [],
    getLUT: function(steps) {
      steps = steps || 100;
      if (this._lut.length === steps) { return this._lut; }
      this._lut = [];
      for(var t=0; t<=steps; t++) {
        this._lut.push(this.compute(t/steps));
      }
      return this._lut;
    },
    on: function(point, error) {
      error = error || 5;
      var lut = this.getLUT(), hits = [], c, t=0;
      for(var i=0; i<lut.length; i++) {
        c = lut[i];
        if (bezierUtils.dist(c,point) < error) {
          hits.push(c);
          t += i / lut.length;
        }
      }
      if(!hits.length) {return false;}
      return t /= hits.length;
    },
    get: function(t) {
      return this.compute(t);
    },
    point: function(idx) {
      return this.points[idx];
    },
    compute: function(t) {
      // shortcuts
      if(t===0) { return this.points[0]; }
      if(t===1) { return this.points[this.order]; }

      var p = this.points;
      var mt = 1-t;
      var ret;

      // linear?
      if(this.order===1) {
        ret = {
          x: mt*p[0].x + t*p[1].x,
          y: mt*p[0].y + t*p[1].y
        };
        if (this._3d) { ret.z = mt*p[0].z + t*p[1].z; }
        return ret;
      }

      // quadratic/cubic curve?
      if(this.order<4) {
        var mt2 = mt*mt,
            t2 = t*t,
            a,b,c,d = 0;
        if(this.order===2) {
          p = [p[0], p[1], p[2], ZERO];
          a = mt2;
          b = mt*t*2;
          c = t2;
        }
        else if(this.order===3) {
          a = mt2*mt;
          b = mt2*t*3;
          c = mt*t2*3;
          d = t*t2;
        }
        ret = {
          x: a*p[0].x + b*p[1].x + c*p[2].x + d*p[3].x,
          y: a*p[0].y + b*p[1].y + c*p[2].y + d*p[3].y
        };
        if(this._3d) {
          ret.z = a*p[0].z + b*p[1].z + c*p[2].z + d*p[3].z;
        }
        return ret;
      }

      // higher order curves: use de Casteljau's computation
      var dCpts = JSON.parse(JSON.stringify(this.points));
      while(dCpts.length > 1) {
        for (var i=0; i<dCpts.length-1; i++) {
          dCpts[i] = {
            x: dCpts[i].x + (dCpts[i+1].x - dCpts[i].x) * t,
            y: dCpts[i].y + (dCpts[i+1].y - dCpts[i].y) * t
          };
          if (typeof dCpts[i].z !== "undefined") {
            dCpts[i] = dCpts[i].z + (dCpts[i+1].z - dCpts[i].z) * t;
          }
        }
        dCpts.splice(dCpts.length-1, 1);
      }
      return dCpts[0];
    },
    derivative: function(t) {
      var mt = 1-t,
          a,b,c=0,
          p = this.dpoints[0];
      if(this.order===2) { p = [p[0], p[1], ZERO]; a = mt; b = t; }
      if(this.order===3) { a = mt*mt; b = mt*t*2; c = t*t; }
      var ret = {
        x: a*p[0].x + b*p[1].x + c*p[2].x,
        y: a*p[0].y + b*p[1].y + c*p[2].y
      };
      if(this._3d) {
        ret.z = a*p[0].z + b*p[1].z + c*p[2].z;
      }
      return ret;
    }
  };

}());
;(function() {
    "use strict";

    var Intersections = Human.math.intersections = {};

    var EPSILON = 1e-8;

    // NOTE(Tarek): 5 different rays tests
    // to account for potential numerical errors
    var POINT_POLYHEDRON_RAY_DIRS = [
        new Float32Array([1, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([-1, 0, 0]),
        new Float32Array([0, -1, 0])
    ];

    Intersections.pointAabb = function(p, min, max) {
        if (p[0] < min[0]) {
            return false;
        }

        if (p[0] > max[0]) {
            return false;
        }

        if (p[1] < min[1]) {
            return false;
        }

        if (p[1] > max[1]) {
            return false;
        }

        if (p[2] < min[2]) {
            return false;
        }

        if (p[2] > max[2]) {
            return false;
        }

        return true;
    };

    Intersections.aabbAabb = function(minA, maxA, minB, maxB) {
        if (maxA[0] < minB[0]) {
            return false;
        }

        if (maxB[0] < minA[0]) {
            return false;
        }

        if (maxA[1] < minB[1]) {
            return false;
        }

        if (maxB[1] < minA[1]) {
            return false;
        }

        if (maxA[2] < minB[2]) {
            return false;
        }

        if (maxB[2] < minA[2]) {
            return false;
        }

        return true;
    };

    Intersections.rayAabb = function(origin, direction, min, max) {
        var tmin = 0;
        var tmax = Number.POSITIVE_INFINITY;

        var fabs = Math.abs;
        var fmin = Math.min;
        var fmax = Math.max;

        for (var i = 0; i < 3; ++i) {
            if (fabs(direction[i]) < EPSILON) {
                if (origin[i] < min[i] || origin[i] > max[i]) {
                    return false;
                }
            } else {
                var t1 = (min[i] - origin[i]) / direction[i];
                var t2 = (max[i] - origin[i]) / direction[i];

                if (t1 > t2) {
                    var tmp = t1;
                    t1 = t2;
                    t2 = tmp;
                }

                tmin = fmax(tmin, t1);
                tmax = fmin(tmax, t2);

                if (tmin > tmax) {
                    return false;
                }
            }
        }

        return true;
    };

    var v1 = new Float32Array(3);
    var v2 = new Float32Array(3);
    var v3 = new Float32Array(3);
    
    var e1 = new Float32Array(3);
    var e2 = new Float32Array(3);
    var t = new Float32Array(3);
    var p = new Float32Array(3);
    var q = new Float32Array(3);

    // From: http://dl.acm.org/citation.cfm?id=272315
    Intersections.rayTriangle = function(origin, direction, offset, indices, positions) {

        var index1 = indices[offset] * 3;
        v1[0] = positions[index1];
        v1[1] = positions[index1 + 1];
        v1[2] = positions[index1 + 2];

        var index2 = indices[offset + 1] * 3;
        v2[0] = positions[index2];
        v2[1] = positions[index2 + 1];
        v2[2] = positions[index2 + 2];

        var index3 = indices[offset + 2] * 3;
        v3[0] = positions[index3];
        v3[1] = positions[index3 + 1];
        v3[2] = positions[index3 + 2];

        vec3.sub(e1, v2, v1);
        vec3.sub(e2, v3, v1);
        vec3.cross(p, direction, e2);

        var det = vec3.dot(p, e1);

        if (det > -EPSILON && det < EPSILON) {
            return false;
        }

        var invDet = 1 / det;
        vec3.sub(t, origin, v1);
        var u = invDet * vec3.dot(p, t);

        if (u < 0 || u > 1) {
            return false;
        } 

        vec3.cross(q, t, e1);
        var v = invDet * vec3.dot(q, direction);

        if (v < 0 || u + v > 1) {
            return false;
        } 

        return invDet * vec3.dot(q, e2) > EPSILON;
        
    };

    // Basic idea: cast a ray from the point of interest outward and 
    // count the number of intersections with the mesh. If it's an odd
    // number, the point was inside the mesh, even number means it was 
    // outside. Five different rays are cast to account for potential 
    // numerical errors. A kdTree is used speed up queries. KdTree node
    // format: 
    //   {
    //       triangles: [NUMBER, NUMBER, ...],    // Indices of triangles in this leaf node (null if not leaf node)
    //       left: kdTreeNode,                    // Left subtree (null if leaf node)
    //       right: kdTreeNode,                   // Right subtree (null if leaf node)
    //       leaf: BOOLEAN,                       // Is this a leaf node?
    //       splitDim: 0,                         // Dimension split on at this node (0 = x, 1 = y, 2 = z)
    //       bb: {                                // Bounding box of triangles in this node and its subtrees.
    //           min: VEC3,
    //           max: VEC3
    //       }
    //   }
    // 
    Intersections.pointPolyhedron = function(p, kdTree, indices, positions) {
        var inside = 0;
        var outside = 0;

        for (var i = 0, len = POINT_POLYHEDRON_RAY_DIRS.length; i < len; ++i) {
            if (rayKdTreeCountIntersections(p, POINT_POLYHEDRON_RAY_DIRS[i], kdTree, indices, positions) % 2 === 1) {
                ++inside;
            } else {
                ++outside;
            }
        }

        return inside > outside;
    };


    // Test if a point is inside a Human object
    // First test point against object AABB.
    // If that passes, perform full point-in-polyhedron
    // test agains object's kd-tree

    var toModel = mat4.create();
    var modelPoint = vec3.create();
    var boundaryMin = vec3.create();
    var boundaryMax = vec3.create();

    Intersections.pointObject = function(p, objectId) {
        var object = Human.scene.objects[objectId];

        if (!object) {
            return false;
        }

        var boundary = object.getBoundary();
        boundaryMin[0] = boundary.xmin;
        boundaryMin[1] = boundary.ymin;
        boundaryMin[2] = boundary.zmin;

        boundaryMax[0] = boundary.xmax;
        boundaryMax[1] = boundary.ymax;
        boundaryMax[2] = boundary.zmax;

        if (!this.pointAabb(p, boundaryMin, boundaryMax)) {
            return false;
        }

        var geometry = object.geometry;

        if (!geometry) {
            return false;
        }

        mat4.invert(toModel, object.getWorldMatrix());
        vec3.transformMat4(modelPoint, p, toModel);

        return this.pointPolyhedron(p, geometry.getKdTree(), geometry.getIndices(), geometry.getPositions());
    };

    function rayKdTreeCountIntersections(origin, direction, kdTreeNode, indices, positions) {
        if (!Intersections.rayAabb(origin, direction, kdTreeNode.bb.min, kdTreeNode.bb.max)) {
            return 0;
        }

        if (kdTreeNode.leaf) {
            var triangles = kdTreeNode.triangles;
            var intersections = 0;
            for (var t = 0, len = triangles.length; t < len; ++t) {

                if (Intersections.rayTriangle(origin, direction, triangles[t] * 3, indices, positions)) {
                    ++intersections;
                }

            }

            return intersections;
        } else {
            return rayKdTreeCountIntersections(origin, direction, kdTreeNode.left, indices, positions) +
                rayKdTreeCountIntersections(origin, direction, kdTreeNode.right, indices, positions);
        }
    }


})();
;/** @namespace
 * @private
 */

(function() {
    "use strict";

    Human.utils = Human.utils || {};

    /**
     * Tests if the given object is an array (including typed arrays)
     */
    Human.utils.isArray = function (testObject) {
        return testObject && !(testObject.propertyIsEnumerable('length')) &&
                typeof testObject === 'object' && typeof testObject.length === 'number';
    };

    /**
     * Tests if the given object is a simple object
     */
    Human.utils.isObject = function (testObject) {
        return !!testObject && Object.prototype.toString.call(testObject) === "[object Object]";
    };

    /**
     * Tests if the argument is of a primitive type
     */
    Human.utils.isPrimitive = function (value) {
        return  value === null || !!(typeof value).match(/^(string|number|boolean|undefined)$/);
    };

    /* Tests if the given value is a string.
     */
    Human.utils.isString = function (value) {
        return (typeof value === "string" || value instanceof String);
    };

    /* Filters elements from an array in place.
     */
    Human.utils.filterInPlace = function filter(array, fn) {
        var skip = 0;

        for (var i = 0, len = array.length; i < len; i++) {
            if (!fn(array[i])) {
                skip++;
                continue;
            }
            array[i - skip] = array[i];
        }

        array.length = array.length - skip;

        return array;
    };

    /**
     * Return a string representing the current call stack
     */
    Human.utils.getStackTrace = function() {
        var error = new Error();
        var stack;
        if (error.stack) {
            stack = error.stack;
        } else {
            try {
                throw error;
            } catch (e) {
                stack = e.stack;
            }
        }

        return stack || null;
    };

    /**
     * @private
     * @param childObj
     * @param parentObj
     */
    Human.utils.extend = function (childObj, parentObj) {
        var TmpObj = function () {
        };
        TmpObj.prototype = parentObj.prototype;
        childObj.prototype = new TmpObj();
        childObj.prototype.constructor = childObj;
    };

    /** Add properties of o to o2, overwriting them on o2 if already there
     */
    Human.utils.apply = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /**
     * Add properties of o to o2 where undefined or null on o2
     * @private
     */
    Human.utils.applyIf = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                if (o2[name] === undefined || o2[name] === null) {
                    o2[name] = o[name];
                }
            }
        }
        return o2;
    };

    Human.utils.applyIf2 = function (p, q) {
        p = p || {};
        var r = {};
        for (var key in q) {
            if (q.hasOwnProperty(key)) {
                r[key] = p[key] !== undefined ? p[key] : q[key];
            }
        }
        return r;
    };

    /** Returns shallow copy of object
     * @private
     */
    Human.utils.shallowClone = function (o) {
        var o2 = {};
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /**
     * Returns true if given map has no items
     * @private
     */
    Human.utils.isEmpty = function (map) {
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    };

    /**
     * Gets directory from given path
     * @private
     */
    Human.utils.getDir = function (path) {
        var i = path.lastIndexOf("/");
        return (i > -1) ? path.substring(0, i > 0 ? i + 1 : 0) : "";
    };

    /**
     * Run function asynchronously (i.e. wait for next exec context)
     * @private
     */
    Human.utils.async = function(fn) {
        setTimeout(fn, 0);
    };

    /**
     * Null function
     * @private
     */
    Human.utils.noop = function () {
    };

    /**
     * Gets keys on given map in array
     * @private
     */
    Human.utils.getKeys = function (map) {
        var keys = [];
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys;
    };

    /**
     * Returns new universally unique ID
     * @private
     */
    Human.utils.createUUID = function () {
        var data = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
        var data2 = ["8", "9", "A", "B"];
        var uuid = [];
        for (var i = 0; i < 38; i++) {
            switch (i) {
                case 8:
                    uuid.push("-");
                    break;
                case 13:
                    uuid.push("-");
                    break;
                case 18:
                    uuid.push("-");
                    break;
                case 14:
                    uuid.push("4");
                    break;
                case 19:
                    uuid.push(data2[Math.round(Math.random() * 3)]);
                    break;
                default:
                    uuid.push(data[Math.round(Math.random() * 15)]);
                    break;
            }
        }
        return uuid.join("");
    };

    /**
     * Look up interval in sorted array where value x resides.
     * Returns both left-index,left-value, right-index, right-value.
     * Out of Bounds cases:
     *   - if target < first item in sequence return [null,null,0,sequence[0]]
     *   - if target > last item in sequence return [end,sequence[end], null, null]
     *
     * @param lessThan(value, element) : function that returns true if value < element
     *    - value is of whatever type you pass to target.
     *    - element is the type of an element in the sequence.
     *
    */

    function defaultCompare(arrayElement, target){
        if (arrayElement < target){
            return -1;
        } else if (arrayElement > target){
            return 1;
        } else {
            return 0;
        }
    }

    Human.utils.binarySearch = function (array, target, compare, result){
        compare = compare || defaultCompare;
        result = result || {
            index1: null,
            index2: null,
            value1: null,
            value2: null
        };

        var lowIndex = 0;
        var highIndex = array.length - 1;
        var mid, value1, value2;

        // Boundary Cases
        if (compare(array[0], target) > 0) {
            result.index1 = null;
            result.value1 = null;
            result.index2 = 0;
            result.value2 = array[0];
            return result;
        } else if (compare(array[highIndex], target) < 0){
            result.index1 = highIndex;
            result.value1 = array[highIndex];
            result.index2 = null;
            result.value2 = null;
            return result;
        }

        // Do Bisection Search
        while (lowIndex <= highIndex){
            mid = Math.floor((lowIndex + highIndex) / 2);
            value1 = array[mid];
            value2 = array[mid + 1];

            if (compare(value1, target) <= 0 && compare(value2, target) >= 0){
                result.index1 = mid;
                result.index2 = mid + 1;
                result.value1 = value1;
                result.value2 = value2;
                return result;
            } else if (compare(value1, target) > 0) {
                highIndex = mid - 1;
            } else {
                lowIndex = mid + 1;
            }
        }
    };

    /**
     * Converts binary buffer to string
     * @private
     */
    Human.utils.atos = function(buffer, index, length) {
        index = index || 0;
        length = length || buffer.byteLength;
        var view = new Uint8Array(buffer, index, length);
        var str = new TextDecoder("utf-8").decode(view);
        return str;
    };

    /**
     * Converts binary buffer to JSON
     * @private
     */
    Human.utils.atoj = function(buffer, index, length) {
        return JSON.parse(Human.utils.atos(buffer, index, length));
    };

    /**
     * Benchmark a function.
     * @private
     */
    Human.utils.benchmark = function(fn, iterations) {
        iterations = iterations || 10000000;

        var t = performance.now();

        for (var i = 0; i < iterations; i++) {
            fn();
        }

        t = performance.now() - t;

        console.log("Total time: " + t.toFixed(3) + "ms");
        console.log("Time / operation: " + (t / iterations).toExponential(3) + "ms");
    };

    /**
     * Make n random objects visible
     * @private
     */
    Human.utils.setRandomVisibleObjects = function(n) {
        var objectIds = Object.keys(Human.scene.objects).filter(function(o) {
            return Human.scene.objects[o].isLeaf();
        });

        var showObjectIds = {};

        for (var i = 0; i < n; i++) {
            var j = Math.floor(Math.random() * objectIds.length);
            showObjectIds[objectIds.splice(j, 1)] = true;
        }

        Human.scene.setEnabledObjects({objectIds: showObjectIds, replace: true});
    };

    /**
    * Load binary data
    */
    Human.utils.getBinary = function (src, callback, error) {
        var request = new XMLHttpRequest();
        request.open("GET", src);
        request.responseType = "arraybuffer";

        request.onload = function() {
            if (request.status === 200) {
                callback(request.response);
            } else {
                error();
            }
        };

        request.send(null);
    };

    Human.utils.boundaryToScreen = function(boundary) {
        var xmin = Number.POSITIVE_INFINITY;
        var xmax = Number.NEGATIVE_INFINITY;
        var ymin = Number.POSITIVE_INFINITY;
        var ymax = Number.NEGATIVE_INFINITY;

        var v1 = [boundary.xmin, boundary.ymin, boundary.zmin, 1];
        var v2 = [boundary.xmin, boundary.ymin, boundary.zmax, 1];
        var v3 = [boundary.xmin, boundary.ymax, boundary.zmin, 1];
        var v4 = [boundary.xmin, boundary.ymax, boundary.zmax, 1];
        var v5 = [boundary.xmax, boundary.ymin, boundary.zmin, 1];
        var v6 = [boundary.xmax, boundary.ymin, boundary.zmax, 1];
        var v7 = [boundary.xmax, boundary.ymax, boundary.zmin, 1];
        var v8 = [boundary.xmax, boundary.ymax, boundary.zmax, 1];

        var viewMatrix = Human.view.camera._lookatNode.getMatrix();
        var projMatrix = Human.view.camera._cameraNode.getMatrix();

        var viewProj = mat4.create();
        mat4.multiply(viewProj, projMatrix, viewMatrix);

        vec4.transformMat4(v1, v1, viewProj);
        xmin = Math.min(xmin, v1[0] / v1[3]);
        xmax = Math.max(xmax, v1[0] / v1[3]);
        ymin = Math.min(ymin, v1[1] / v1[3]);
        ymax = Math.max(ymax, v1[1] / v1[3]);

        vec4.transformMat4(v2, v2, viewProj);
        xmin = Math.min(xmin, v2[0] / v2[3]);
        xmax = Math.max(xmax, v2[0] / v2[3]);
        ymin = Math.min(ymin, v2[1] / v2[3]);
        ymax = Math.max(ymax, v2[1] / v2[3]);

        vec4.transformMat4(v3, v3, viewProj);
        xmin = Math.min(xmin, v3[0] / v3[3]);
        xmax = Math.max(xmax, v3[0] / v3[3]);
        ymin = Math.min(ymin, v3[1] / v3[3]);
        ymax = Math.max(ymax, v3[1] / v3[3]);

        vec4.transformMat4(v4, v4, viewProj);
        xmin = Math.min(xmin, v4[0] / v4[3]);
        xmax = Math.max(xmax, v4[0] / v4[3]);
        ymin = Math.min(ymin, v4[1] / v4[3]);
        ymax = Math.max(ymax, v4[1] / v4[3]);

        vec4.transformMat4(v5, v5, viewProj);
        xmin = Math.min(xmin, v5[0] / v5[3]);
        xmax = Math.max(xmax, v5[0] / v5[3]);
        ymin = Math.min(ymin, v5[1] / v5[3]);
        ymax = Math.max(ymax, v5[1] / v5[3]);

        vec4.transformMat4(v6, v6, viewProj);
        xmin = Math.min(xmin, v6[0] / v6[3]);
        xmax = Math.max(xmax, v6[0] / v6[3]);
        ymin = Math.min(ymin, v6[1] / v6[3]);
        ymax = Math.max(ymax, v6[1] / v6[3]);

        vec4.transformMat4(v7, v7, viewProj);
        xmin = Math.min(xmin, v7[0] / v7[3]);
        xmax = Math.max(xmax, v7[0] / v7[3]);
        ymin = Math.min(ymin, v7[1] / v7[3]);
        ymax = Math.max(ymax, v7[1] / v7[3]);

        vec4.transformMat4(v8, v8, viewProj);
        xmin = Math.min(xmin, v8[0] / v8[3]);
        xmax = Math.max(xmax, v8[0] / v8[3]);
        ymin = Math.min(ymin, v8[1] / v8[3]);
        ymax = Math.max(ymax, v8[1] / v8[3]);

        var canvas = Human.renderer.canvas.canvas[0];
        
        var canvasXMin = (xmin * 0.5 + 0.5) * canvas.width;
        var canvasXMax = (xmax * 0.5 + 0.5) * canvas.width;
        var canvasYMin = canvas.height - (ymax * 0.5 + 0.5) * canvas.height;
        var canvasYMax = canvas.height - (ymin * 0.5 + 0.5) * canvas.height;

        var pixelCoverage = (canvasXMax - canvasXMin) * (canvasYMax - canvasYMin);

        return {
            min: [canvasXMin, canvasYMin],
            max: [canvasXMax, canvasYMax],
            pixelCoverage: pixelCoverage
        };
    };

    Human.utils.visibleAssetReport = function() {
        var report = {
            totalVertices: 0,
            totalTriangles: 0,
            objectStats: {},
            geometryStats: {},
            textureStats: {},
            objectsByTrianglesPerPixel: null,
            objectsByTexelsPerPixel: null,
            geometriesByTriangleCount: null,
            texturesBySize: null,
        };

        var objects = Human.scene.objects;

        var objectIds = Object.keys(Human.scene.enabledObjects).filter(function(objectId) {
            return !!Human.scene.objects[objectId].geometry && !!Human.scene.objects[objectId].material;
        });

        report.objectsByTrianglesPerPixel = new Array(objectIds.length);
        report.objectsByTexelsPerPixel = new Array(objectIds.length);

        var geometryStats = report.geometryStats;
        var textureStats = report.textureStats;

        for (var i = 0, len = objectIds.length; i < len; ++i) {
            var objectId = objectIds[i];
            var object = objects[objectId];
            var geometry = object.geometry._core.arrays;
            var vertices = geometry.positions.length / 3;
            var triangles = geometry.indices.length / 3;
            var materialTextures = object.material.textures || [];
            var objectTextures = new Array(materialTextures.length);

            for (var t = 0; t < materialTextures.length; ++t) {
                var texture = materialTextures[t]._core;
                var src = texture.compressedSrc || texture.src || texture.uri;

                objectTextures[t] = textureStats[src] = textureStats[src] || {
                    src: src,
                    width: texture.width,
                    height: texture.height,
                    objectIds: [],
                    count: 0,
                    atlasSharing: 0,
                    atlas: false,
                    adjustedTexels: texture.width * texture.height
                };

                textureStats[src].count++;

                var atlasNew = true;
                for (var o = 0, oLen = textureStats[src].objectIds.length; o < oLen; ++o) {
                    var otherGeometryId = objects[textureStats[src].objectIds[o]].geometryId;

                    if (otherGeometryId !== object.geometryId) {
                        textureStats[src].atlas = true;
                    }

                    if (otherGeometryId === object.geometryId) {
                        atlasNew = false;
                    }
                }

                if (atlasNew) {
                    textureStats[src].atlasSharing++;
                }

                textureStats[src].objectIds.push(objectId);
            }

            // NOTE(TAREK): There seems to be a bug in boundary calculations.
            // They aren't always updated with the transforms.
            object._setBoundaryDirty();
            var canvasBounds = Human.utils.boundaryToScreen(object.getBoundary());
            
            report.totalVertices += vertices;
            report.totalTriangles += triangles;

            report.objectsByTexelsPerPixel[i] = report.objectsByTrianglesPerPixel[i] = report.objectStats[objectId] = {
                objectId: objectId,
                vertices: vertices,
                triangles: triangles,
                textures: objectTextures,
                canvasBounds: {
                    min: canvasBounds.min,
                    max: canvasBounds.max
                },
                pixelCoverage: canvasBounds.pixelCoverage,
                trianglesPerPixel: triangles / canvasBounds.pixelCoverage,
                texelsPerPixel: 0
            };

            geometryStats[object.geometryId] = geometryStats[object.geometryId] || {
                geometryId: object.geometryId,
                vertices: vertices,
                triangles: triangles,
                totalVertices: 0,
                totalTriangles: 0,
                objectIds: [],
                count: 0
            };

            geometryStats[object.geometryId].count++;
            geometryStats[object.geometryId].totalVertices += vertices;
            geometryStats[object.geometryId].totalTriangles += triangles;
            geometryStats[object.geometryId].objectIds.push(objectId);
        }
        

        Object.keys(textureStats).forEach(function(src) {
            var texture = textureStats[src];
            if (texture.atlas) {
                texture.adjustedTexels /= texture.atlasSharing;
            }
        });

        report.objectsByTrianglesPerPixel.sort(function(a, b) {
            return b.trianglesPerPixel - a.trianglesPerPixel;
        });

        report.objectsByTexelsPerPixel.filter(function(object) {
            return object.textures.length > 0;
        }).forEach(function(object) {
            var textures = object.textures;

            textures.sort(function(a, b) {
                return b.adjustedTexels - a.adjustedTexels;
            });

            object.texelsPerPixel = object.textures[0].adjustedTexels / object.pixelCoverage;
        });
        report.objectsByTexelsPerPixel.sort(function(a, b) {
            return b.texelsPerPixel - a.texelsPerPixel;
        });

        report.geometriesByTriangleCount = Object.keys(geometryStats).map(function(geometryId) {
            return geometryStats[geometryId];
        }).sort(function(a, b) {
            return b.triangles * b.count - a.triangles * a.count;
        });

        report.texturesBySize = Object.keys(textureStats).map(function(src) {
            return textureStats[src];
        }).sort(function(a, b) {
            return b.adjustedTexels - a.adjustedTexels;
        });
        
        return report;
    };

    Human.utils.textGzipSize = function(str) {
        if (window.pako) {
            var binary = new TextEncoder().encode(str);
            return pako.deflate(binary).byteLength;
        }

        return 0;
    };

    Human.utils.binaryGzipSize = function(data) {
        if (window.pako) {
            var binary = new Uint8Array(data);
            return pako.deflate(binary).byteLength;
        }

        return 0;
    };

})();
;
/**
 * Applies a callback to each item in a map concurrently, Returns via callback when
 * all items processed. In addition to the key and item, passes a context into callback also.
 * @param map
 * @param context
 * @param fn
 * @param ok
 * @param error
 */
Human.utils.concurrentMapIterate = function (map, context, fn, ok, error) {
    "use strict";

    var keys = [];
    for (var key in map) {
        if (map.hasOwnProperty(key)) {
            keys.push(key);
        }
    }
    var numKeys = keys.length;

    // Immediate ok when no items
    if (numKeys === 0) {
        ok();
        return;
    }

    var numComplete = 0;
    var wasError = false;

    // Fires ok when all items processed
    function done() {
        if (++numComplete >= numKeys && !wasError) {
            ok();
        }
    }

    // Catches only first error to avoid cascade
    function error2(message) {
        if (!wasError) {
            wasError = true;
            error(message);
        }
    }

    if (context) {
        for (var i = 0, len = keys.length; i < len; i++) {
            fn.call(context, keys[i], map[keys[i]], done, error2);
        }
    } else {
        for (i = 0, len = keys.length; i < len; i++) {
            fn(keys[i], map[keys[i]], done, error2);
        }
    }
};
;
/**
 * Executes a collection of tasks concurrently, signals completion
 * when all tasks complete, or error as soon as a task fails.
 */
Human.utils.ConcurrentTasks = function() {
    "use strict";

    var tasks = [];
    var numTasks = 0;
    var _onComplete;
    var _onError;
    var wasError = false;

    /**
     * Adds a task, like this:
     *
     * add(function(done, error) {
     *
     *      // Do task here, then call done() on success, or error("some error") on failure
     *
     * })
     *
     */
    this.add = function(task) {
        tasks[numTasks++] = task;
    };

    function done() {
        if (--numTasks <= 0 && !wasError) {
            _onComplete();
        }
    }

    function error(errMsg) {
        if (!wasError) {
            wasError = true;
            _onError(errMsg);
        }
    }

    /**
     * Runs added tasks concurrently.
     *
     * Calls onComplete as soon as all tasks have called their done() callbacks, else onError
     * as soon as one task calls its error() callback.
     *
     * The onError callback is only called once, for the first task that fails.
     */
    this.go = function(onComplete, onError) {
        _onComplete = onComplete;
        _onError = onError;
        wasError = false;
        if (numTasks > 0) {
            for (var i = 0, len = numTasks; i < len; i++) {
                (tasks[i])(done, error);
            }
        } else {
            onComplete();
        }
    };
};
;/**
 * Tests if files exist on server, caches results.
 */
(function () {
    "use strict";

    var FileExists = Human.utils.fileExists = {}; 

    // Caches flags for URLs
    var cache = {};

    // Ensures that cache doesn't grow too much
    var evictionQueue = [];
    var maxSize = 200;

    /**
     * Test if file exists at the given URL.
     * @param {String} url The file URL
     * @param {Function} callback callback which returns boolean flag which indicates if file exists
     */
    FileExists.test = function (url, callback) {

        var exists = cache[url];

        if (exists !== undefined) {
            callback(exists);
            return;
        }

        var http = new XMLHttpRequest();

        http.open('HEAD', url);

        http.onreadystatechange = function () {
            // response completed
            if (http.readyState === 4) {

                // Evict least-recently-used
                // if cache size limit reached

                if (evictionQueue.length >= maxSize) {
                    var evictURL = evictionQueue.shift();
                    delete cache[evictURL];
                }

                // Cache result
                exists = http.status !== 404;
                cache[url] = exists;
                evictionQueue.push(url);

                // Return result
                callback(exists);
            }
        };
        http.send();
    };

})();






;// TODO: Why is this a constructor?
Human.utils.ArrayIteration = function(array, fn, onComplete, onError) {
    "use strict";

    this.push = function(item) {
        array.push(item);
        window.setTimeout(next, 1);
    };

    var wasError = false;

    if (array.length === 0) {
        if (onComplete) {
            onComplete();
        }
        return;
    }

    function done() {
        if (array.length === 0) {
            if (onComplete) {
                onComplete();
            }
        } else {
            window.setTimeout(next, 1);
        }
    }

    function error(msg) {
        if (!wasError) {
            wasError = true;
            if (onError) {
                onError(msg);
            } else {
                if (onComplete) {
                    onComplete();
                }
            }
        }
    }

    function next() {
        if (array.length > 0) {
            fn(array.shift(), done, error);
        }
    }

    window.setTimeout(next, 1);
};
;
/**
 * Maps tags to items, supports fast queries to find items matching queries on tags
 */
Human.utils.TagMap = function () {
    "use strict";

    // Map of tags to items
    var tagMap = {};

    // Count of items mapped to each tag
    var tagCounts = {};

    // Map of all items by ID
    var items = {};

    // Search results cached against sets of query tags
    var cachedSearchResults;

    /**
     * Insert item into tag map
     */
    this.addItem = function (itemId, tags, item) {
        var tag;
        var tagItems;
        var tagCount;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagItems = tagMap[tag];
            if (!tagItems) {
                tagItems = tagMap[tag] = {};
            }
            tagItems[itemId] = item;
            tagCount = tagCounts[tag];
            if (!tagCount) {
                tagCounts[tag] = 1;
            } else {
                tagCounts[tag]++;
            }
        }
        items[itemId] = item;

        /* Blow away search results cache - could refine this
         */
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };

    /**
     * Returns items that match the given tags.
     * Caches them against the tags for fast re-query.
     */
    this.findItems = function (withTags) {

        withTags = withTags || {};

        var tags = withTags.tags || [];
        var key = tags.join(".");

        var matching = withTags.matching || "any";

        if (!cachedSearchResults) {
            cachedSearchResults = {};
        }
        var matchTypeCache = cachedSearchResults[matching];
        if (!matchTypeCache) {
            matchTypeCache = cachedSearchResults[matching] = {};
        }

        var result = matchTypeCache[key];

        if (!result) {
            switch (matching) {

                case "most":
                    result = this._findHitsMost(tags);
                    break;

                case "atLeast":
                    result = this._findHitsAtLeast(tags);
                    break;

                case "any":
                    result = this._findHitsAny(tags);
                    break;
            }
            matchTypeCache[key] = result;
        }

        return result;
    };

    /**
     * Returns the first item found (in lexical order) that matches the largest subset of the given tags.
     */
    this._findHitsMost = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var bestItemId;
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {                // With each item info for tag
                    if (items.hasOwnProperty(itemId)) {
                        var hits = itemHits[itemId];       // Record tag hit for item info
                        if (!hits) {
                            hits = itemHits[itemId] = 1;
                        } else {
                            hits = ++itemHits[itemId];
                        }
                        if (!bestItemId || hits > itemHits[bestItemId]) { // Track item info with most hits
                            bestItemId = itemId;
                        }
                    }
                }
            }
        }
        var result = {};// Return item info with most hits
        if (bestItemId) {
            result[bestItemId] = items[bestItemId];
        }
        return result;
    };

    /**
     * Returns items matching the complete set of given tags
     */
    this._findHitsAtLeast = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var numTags = tags.length;
        var result = {};
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) { // With each item info for tag
                        var hits = itemHits[itemId];    // Record tag hit for item info
                        if (!hits) {
                            hits = itemHits[itemId] = 1;
                        } else {
                            hits = ++itemHits[itemId];
                        }
                        if (hits === numTags) {          // Collect item infos matching
                            result[itemId] = items[itemId]; // all the query tags
                        }
                    }
                }
            }
        }
        return result;
    };

    /**
     * Returns item infos matching any of the given tags
     */
    this._findHitsAny = function (tags) {
        var tag;
        var items;
        var result = {};
        for (var i = 0, len = tags.length; i < len; i++) {  // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) {   // With each item info for tag
                        result[itemId] = items[itemId];   // Collect item infos matching the tag
                    }
                }
            }
        }
        return result;
    };

    /** Remove item from map
     */
    this.removeItem = function (itemId) {
        var tagItems;
        var item;
        for (var tag in tagMap) {
            if (tagMap.hasOwnProperty(tag)) {
                tagItems = tagMap[tag];
                item = tagItems[itemId];
                if (item) {
                    delete tagItems[itemId];
                    if (--tagCounts[tag] === 0) {
                        delete tagMap[tag];
                        delete tagCounts[tag];
                    }
                }
            }
        }
        delete items[itemId];
        // Blow away search results cache - could refine this
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };
};;/**
 * Maps tags to lists of items, supports fast queries to find items matching given tags
 */
Human.utils.TagMapList = function () {
    "use strict";

    //  Map of tags to items
    var tagMap = {};

    //  Count of items mapped to each tag
    var tagCounts = {};

    //  Map of all items by ID
    var items = {};

    /**
     * Search results cached against sets of query tags
     */
    var cachedSearchResults;

    /**
     * Insert item into tag map
     */
    this.addItem = function (itemId, tags, item) {
        // Must have tags
        if (tags.length === 0) {
            return;
        }

        var tag;
        var tagItems;
        var tagCount;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagItems = tagMap[tag];
            if (!tagItems) {
                tagItems = tagMap[tag] = {};
            }
            tagItems[itemId] = item;
            tagCount = tagCounts[tag];
            if (!tagCount) {
                tagCounts[tag] = 1;
            } else {
                tagCounts[tag]++;
            }
        }
        items[itemId] = item;

        // Blow away search results cache - could refine this
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };

    /**
     * Returns items that match the given tags.
     * Caches them against the tags for fast re-query.
     */
    this.findItems = function (withTags) {
        withTags = withTags || {};
        var tags = withTags.tags || [];
        var key = tags.join(".");
        var matching = withTags.matching || "any";
        if (!cachedSearchResults) {
            cachedSearchResults = {};
        }
        var matchTypeCache = cachedSearchResults[matching];
        if (!matchTypeCache) {
            matchTypeCache = cachedSearchResults[matching] = {};
        }
        var result = matchTypeCache[key];
        if (!result) {
            switch (matching) {
                case "most":
                    result = this._findHitsMost(tags);
                    break;
                case "atLeast":
                    result = this._findHitsAtLeast(tags);
                    break;
                case "any":
                    result = this._findHitsAny(tags);
                    break;
                case "except":
                    result = this._findHitsExcept(tags);
            }
            matchTypeCache[key] = result;
        }
        return result;
    };

    /**
     * Returns the first item found (in lexical order) that
     * matches the largest subset of the given tags.
     */
    this._findHitsMost = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var bestItemId;
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) { // With each item info for tag
                    if (items.hasOwnProperty(itemId)) {
                        var hits = itemHits[itemId]; // Record tag hit for item info
                        if (!hits) {
                            hits = itemHits[itemId] = 1;
                        } else {
                            hits = ++itemHits[itemId];
                        }
                        if (!bestItemId || hits > itemHits[bestItemId]) { // Track item info with most hits
                            bestItemId = itemId;
                        }
                    }
                }
            }
        }
        var result = []; // Return item info with most hits
        if (bestItemId) {
            result.push(items[bestItemId]);
        }
        return result;
    };

    /**
     * Returns items matching the complete set of given tags
     */
    this._findHitsAtLeast = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var numTags = tags.length;
        var got = {};
        var result = [];
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) { // With each item info for tag
                        if (!got[itemId]) {
                            var hits = itemHits[itemId];    // Record tag hit for item info
                            if (!hits) {
                                hits = itemHits[itemId] = 1;
                            } else {
                                hits = ++itemHits[itemId];
                            }
                            if (hits === numTags) {          // Collect item infos matching
                                result.push(items[itemId]); // all the query tags
                                got[itemId] = true;
                            }
                        }
                    }
                }
            }
        }
        return result;
    };

    /**
     * Returns item infos matching any of the given tags
     */
    this._findHitsAny = function (tags) {
        var tag;
        var items;
        var got = {};
        var result = [];
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) { // With each item info for tag
                        if (!got[itemId]) {
                            result.push(items[itemId]);  // Collect item infos matching the tag
                            got[itemId] = true;
                        }
                    }
                }
            }
        }
        return result;
    };

    /**
     * Returns item infos not matching the given tags
     */
    this._findHitsExcept = function (tags) {
        var result = [];

        // Go through each item
        for (var itemId in items) {
            if (items.hasOwnProperty(itemId)) {
                // Go through each given tag
                for (var i = 0; i < tags.length; i++) {
                    // Does the item exist in the tagmap?
                    var tagItems = tagMap[tags[i]];
                    if (tagItems !== undefined) {
                        if (tagItems[itemId] !== undefined) {
                            break;
                        }
                    }
                    if (i === (tags.length-1)) {
                        result.push(items[itemId]);
                    }
                }
            }
        }

        return result;
    };

    /** Remove item from map
     */
    this.removeItem = function (itemId) {
        var tagItems;
        var item;
        for (var tag in tagMap) {
            if (tagMap.hasOwnProperty(tag)) {
                tagItems = tagMap[tag];
                item = tagItems[itemId];
                if (item) {
                    delete tagItems[itemId];
                    if (--tagCounts[tag] === 0) {
                        delete tagMap[tag];
                        delete tagCounts[tag];
                    }
                }
            }
        }

        delete items[itemId];

        /* Blow away search results cache - could refine this
         */
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };
};;/**
 * @class Generic map of IDs to items - can generate own IDs or accept given IDs. IDs should be strings in order to not
 * clash with internally generated IDs, which are numbers.
 * @private
 */
Human.utils.Map = function (items, _baseId) {
    "use strict";

    /**
     * @property Items in this map
     */
    this.items = items || [];


    var baseId = _baseId || 0;
    var lastUniqueId = baseId;
    // Attach id number to make unique
    if (typeof baseId !== "number") {
        lastUniqueId = baseId + "0";
    }

    /**
     * Adds an item to the map and returns the ID of the item in the map. If an ID is given, the item is
     * mapped to that ID. Otherwise, the map automatically generates the ID and maps to that.
     *
     * id = myMap.addItem("foo") // ID internally generated
     *
     * id = myMap.addItem("foo", "bar") // ID is "foo"
     *
     */
    this.addItem = function () {

        var item;

        if (arguments.length === 2) {

            var id = arguments[0];

            item = arguments[1];

            if (this.items[id]) { // Won't happen if given ID is string
                throw "ID clash: '" + id + "'";
            }

            this.items[id] = item;

            return id;

        } else {

            while (true) {

                item = arguments[0];

                // Last unique id is either # or prefix + #
                var findId;
                if (typeof baseId === "number") {
                    findId = lastUniqueId++;
                } else {
                    findId = baseId + parseInt(lastUniqueId.substr(baseId.length));
                    lastUniqueId = baseId + (parseInt(lastUniqueId.substr(baseId.length)) + 1);
                }

                if (!this.items[findId]) {
                    this.items[findId] = item;
                    return findId;
                }
            }
        }
    };

    /**
     * Removes the item of the given ID from the map and returns it
     */
    this.removeItem = function (id) {
        var item = this.items[id];

        if (item !== undefined) {
            // Remove id from item list
            delete this.items[id];
            // Update last unique id -- prevents holes
            lastUniqueId = id;
        }

        return item;
    };
};;
/**
 * A fast pool of reusable ids
 */
Human.utils.IDPool = function(cfg) {
    "use strict";

    cfg = cfg || {};

    var prefix = cfg.prefix || "id";
    var prefixLen = prefix.length;
    var idNums = [];
    var clientIds = {};    // IDs explicitly supplied by client
    var internalIds = {};  // IDs internally generated

    /** Gets new ID
     */
    this.getId = function(clientId) {
        if (clientId) {
            // Explicit user-supplied ID
            if (clientIds[clientId] || internalIds[clientId]) {
                throw "ID already in use: " + clientId;
            }
            clientIds[clientId] = true;
            return clientId;
        }
        var internalId;
        // Try to find hole in ID nums
        for (var i = 0, len = idNums.length; i < len; i++) {
            if (!idNums[i]) {
                internalId = prefix + i;
                if (!clientIds[internalId]) { // Don't clobber user ID
                    idNums[i] = true;
                    internalIds[internalId] = true;
                    return internalId;
                }
            }
        }
        // No hole found in ID nums - append new one
        idNums.push(true);
        internalId = prefix + (idNums.length - 1);
        internalIds[internalId] = true;
        return internalId;
    };

    /** Returns true if given ID in use
     *
     * @param id
     * @return {Boolean}
     */
    this.containsId = function(id) {
        return clientIds[id] !== undefined || internalIds[id] !== undefined;
    };

    /** Releases ID to the pool for reuse
     */
    this.putId = function(id) {
        if (clientIds[id]) {
            delete clientIds[id];
        } else if (internalIds[id]) {
            // Additional check to make sure that id exists in pool

            idNums[parseInt(id.substr(prefixLen))] = false;
            delete internalIds[id];
        }
    };

};
;

/**
 * Base class for all content library loader types.
 *
 * Provides template methods to overload to do the actual load and unload of libraries.
 *
 * Tracks what's loaded against a model/state ID so you can just unload using that ID.
 *
 * @param cfg
 * @param cfg.libraries Library container this loader loads into
 * @param cfg.load Loader strategy

 */
Human.utils.Loader = function () {
    "use strict";

    // Tracks asset libraries that are loaded for models
    this._loadedModelLibs = {};

    /**
     * Override this template method to configure the loader subclass
     */
    this.configure = function () {
    };

    /**
     * Loads a library for a given model
     *
     * @param moduleId
     * @param modelId
     * @param libraryId
     * @param params
     * @param ok
     * @param error
     */
    this.load = function (moduleId, modelId, libraryId, params, ok, error) {
        this._loadedModelLibs[modelId] = this._loadedModelLibs[modelId] || {};
        if (this._loadedModelLibs[modelId][libraryId]) {
            Human.log.warn("Human.utils.Loader.load", "Library '" + libraryId + "' already loaded for model '" + modelId + "' - not reloading");
            ok();
            return;
        }
        var self = this;
        var _ok = function () {
            self._loadedModelLibs[modelId][libraryId] = true;
            ok();
        };
        this._load(moduleId, modelId, libraryId, params,_ok, error);
    };

    /** Override this template method to implement the load method
     *
     * @param moduleId Module that owns this model
     * @param modelId State collection we're loading for
     * @param libraryId Library we're loading
     * @param params Whatever params are involved for this load
     * @param ok Success callback
     * @param error Failure callback
     * @private
     */

    this._load = function (moduleId, modelId, libraryId, params, ok, error) {
        // jshint unused:false

        Human.log.error("Human.utils.Loader._load not implemented");
        ok();
    };

    /**
     * Unloads libraries for the given model
     *
     * @param modelId
     */
    this.unload = function (modelId) {
    //    Human.log.info("Human.utils.Loader.unload", "Unloading model '" + modelId + "'");
        var loaded = this._loadedModelLibs[modelId];
        if (loaded) {
            for (var libraryId in loaded) {
                if (loaded.hasOwnProperty(libraryId)) {
                    this._unload(modelId + "." + libraryId);
                }
            }
            delete this._loadedModelLibs[modelId];
        }
    };

    /** Override this template method to implement unload
     *
     * @param globalLibraryId Library to unload
     * @private
     */
    this._unload = function (globalLibraryId) {
        // jshint unused:false
        
        Human.log.error("Human.utils.Loader._unload", "This method needs to be implemented");
    };
};

;/**
 * @namespace Provides methods for sending and subscribing events.
 */
(function () {
    "use strict";

    var HumanEvents = Human.events = {};

    var eventBinders = {};

    var DEFAULT_EVENT_CHANNEL = 0;

    var eventChannels = [
        {} // Default channel
    ];

    var enabledEventChannels = {};

    var remembered = {};

    var suspendEvents = false;   // If set to true, events will be blocked.

    /**
     * Injects a factory function which creates bindings for a given event type. This enables an event source
     * to decide when to fire events based on an event-specific mask that may be optionally given to the .onEvent method.
     *
     * <h3>Works like this:</h3>
     *
     * Human.events.addBinder(
     *      "my-event-type",
     *      function(mask, fn) {  // The factory function
     *
     *          // Creates bindings where fn will be called
     *          // by event source, passing event to it,
     *          // when criteria in mask are met.
     *
     *      });
     * </pre>
     *
     * @memberof Human.events
     */
    HumanEvents.addBinder = function (eventName, eventBinder) {
        (eventBinders[eventName] || (eventBinders[eventName] = [])).push(eventBinder);
    };

    /**
     * Creates an event channel. Events can be fired on these channels,
     * which can be selectively enabled/disabled for efficient dynamic event
     * subscription/unsubsubscription.
     *
     * <h3>Example:</h3>
     * <pre>
     *     var myNewChannel = createEventChannel({
     *        enabled: true
     *     });
     * </pre>
     *
     * @memberof Human.events
     */
    HumanEvents.createChannel = function (cfg) {
        var channel = eventChannels.length;
        eventChannels.push({});
        if (cfg && cfg.enabled) {
            HumanEvents.enableChannel(channel, cfg.enabled);
        }
        return channel;
    };

    /**
     * Enable or disable an event channel.
     *
     * @memberof Human.events
     */
    HumanEvents.enableChannel = function (channel, enable) {
        enabledEventChannels[channel] = enable;
    };

    /**
     * Registers a handler for a type of engine event.
     *
     * <p>The handler can be registered with an optional priority number which specifies the order it is
     * called among the other handler already registered for the event.</p>
     *
     * <p>So, with n being the number of handlers registered for the given event:</p>
     * <ul>
     * <li>(priority <= 0)      - handler will be the first called</li>
     * <li>(priority >= n)      - handler will be the last called</li>
     * <li>(0 < priority < n)   - handler will be called at the order given by the priority</li>
     *
     * @param channel - Optional channel name, falls back on default channel when omitted
     * @param type Event type - one of the values in SceneJS._eventModule
     * @param fn - Handler function that will accept whatever parameter object accompanies the event
     * @param priority - Optional priority number (see above)
     * @memberof Human.events
     */
    HumanEvents.onEvent = HumanEvents.on = function () {
        var channel;
        var type;
        var fn;
        var options;
        if (typeof arguments[0] === "number") {
            channel = arguments[0];
            if (channel > eventChannels.length - 1) {
                Human.log.error("Human_event.onEvent", "Channel not created: " + channel +
                    " - should be created first with Human.events.createChannel");
                return;
            }
            type = arguments[1];
            fn = arguments[2];
            options = arguments[3];
        } else if (typeof arguments[0] === "object") {
            var params = arguments[0];
            type = params.type;
            fn = params.fn;
            // Masked subscriptions not (yet) channeled or prioritised
            var binders = eventBinders[type];
            if (binders) {
                var mask = params.mask || {};
                for (var i = 0, len = binders.length; i < len; i++) {
                    binders[i](mask, fn);
                }
            }
            channel = (params.channel !== undefined && params.channel !== null) ? params.channel : DEFAULT_EVENT_CHANNEL;
            options = params.options;
        } else {
            channel = DEFAULT_EVENT_CHANNEL;
            type = arguments[0];
            fn = arguments[1];
            options = arguments[2];
        }
        enabledEventChannels[channel] = (options && options.enable !== undefined && options.enable !== null) ? options.enable : true;
        options = options || {};
        var subscriberLists = eventChannels[channel];
        if (!subscriberLists) {
            subscriberLists = eventChannels[channel] = {};
        }
        var list = subscriberLists[type];
        if (!list) {
            list = [];
            subscriberLists[type] = list;
        }
        var handler = {
            fn: fn,
            priority: (options.priority === undefined) ? list.length : options.priority,
            once: options.once
        };
        for (i = 0; i < list.length; i++) {
            if (list[i].priority > handler.priority) {
                list.splice(i, 0, handler);
                return;
            }
        }
        list.push(handler);
        if (remembered[type]) {
            handler.fn(remembered[type]);
        }
    };

    /** Single-shot event subscribe
     *
     * @param type
     * @param ok
     */
    HumanEvents.once = function (type, ok) {
        HumanEvents.on(type, ok, { once: true });
    };

    /**
     * Fire an event.
     * @param {String} type Event type name
     * @param {{}} [params] Map of parameters to accompany the event - must be JSON-serializable.
     * @memberof Human.events
     */
    HumanEvents.fireEvent = HumanEvents.fire = function (type, params, remember) {
        if (suspendEvents) {
            return;
        }

        var subscriberLists;
        var list;
        for (var channel = 0, numChannels = eventChannels.length; channel < numChannels; channel++) {
            if (enabledEventChannels[channel]) {
                subscriberLists = eventChannels[channel];
                list = subscriberLists[type];
                if (list) {
                    if (!params) {
                        params = {};
                    }
                    var toRemove;
                    var handler;
                    for (var i = 0, len = list.length; i < len; i++) {
                        handler = list[i];
                        // A handler could be undefined by this time,
                        // should we ever unEvent it before we get here.
                        try {
                            handler.fn(params);
                            if (handler.once) {
                                if (!toRemove) {
                                    toRemove = [];
                                }
                                toRemove.push(i);
                            }
                       } catch(exception) {
                           Human.log.error(exception);
                       }
                    }
                    if (toRemove) {
                        for (i = toRemove.length - 1; i >= 0; i--) {
                            list.splice(toRemove[i], 1);
                        }
                    }
                }
            }
        }
        if (remember) {
            remembered[type] = params;
        }
    };

    HumanEvents.blockEvents = function(fn) {
        suspendEvents = true;
        try {
            fn();
        } catch (e) {
            Human.log.error(e.message);
        }
        suspendEvents = false;
    };

    /** Remove a Handler with a certain Function from the List of Handlers for
     * an Event of a certain Type.
     * @memberof Human.events
     * @param channel to turn off -- default if undefined
     * @param type of the channel
     * @param fn -- function to call
     */
    HumanEvents.unEvent = HumanEvents.off = function (type, fn, channel) {  // TODO: unbind for optional channel
        // If channel unspecified -- it is default channel
        // If channel does not exist, nothing to turn off
        if (channel === undefined || channel === null) {
            channel = DEFAULT_EVENT_CHANNEL;
        } else if (channel >= eventChannels.length || channel < 0) {
            throw "Channel does not exist: " + channel;
        }

        var subscriberLists = eventChannels[ channel ];
        if (!subscriberLists) {
            subscriberLists = eventChannels[ channel ] = {};
        }
        var list = subscriberLists[ type ];
        if (!list) {
            list = [];
            subscriberLists[ type ] = list;
        }
        for (var i = list.length; i--;) {
            if (list[ i ].fn === fn) {
                list.splice(i, 1);
            }
        }
    };
})();
;/**
 @namespace Engine configs definition, update, subscription and query.

 <p>Properties are various engine configurations, such as background color in the 3D view, or mouse sensitivity.</p>

 <h3>Setting multiple properties:</h3>
 <pre>
 Human.properties.set({
        "annotation.teacher" : {
            pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
            pinShaftColor: { r: 1.0,b: 0.0, g: 1.0 }
        }
        "annotation.student" : {
            pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 }
            pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
        }
    });
 </pre>
 <h3>Querying properties</h3>
 <p>Querying all engine properties:</p>
 <pre>
 Human.properties.query();
 </pre>
 <p>Result:</p>
 <pre>
 {
     "annotation.default" : {
          pinHeadColor: { r: 1.0, g: 0.5, b: 0.5 },
          pinShaftColor: { r: 1.0, b: 1.0, g: 0.0 }
      },
      "annotation.teacher" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      },
      "annotation.student" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      }
  }
 </pre>

 <p>Querying engine properties with keys matching a regular expression:</p>
 <pre>
 Human.properties.query("teacher");
 </pre>
 <p>Result:</p>
 <pre>
 {
      "annotation.teacher" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      }
  }
 </pre>

 <h3>Subscribing to a property</h3>
 <p>A property may be subscribed to by a consumer who wants to be notified of any change to its value.</p>
 <ul>
 <li>The property will be created first if it does not yet exist, and a subscriber can provide an initial value to assign to the property if
 it is being created.</li>
 <li>The subscription will return an ID which is a handle to the subscription which can be used to unsubscribe. By default,
 the subscription ID is automatically generated, but the subscriber may optionally provide their own subscription ID instead.</li>
 </ul>
 <pre>
 var subId = Human.properties.subscribe({

          // Optional subscriber-managed ID.
          // Auto-generated if not supplied.
          subId: "mySub",

          // Mandatory property ID
          propId: "annotation.student",

          // Default config properties - these are overridden by
          // any properties that are previously or subsequently set
          // by a Config.Set command:
          value: {
              pinHeadColor:  { r: 1, g: 0, b: 0 },
              pinShaftColor: { r: 1, g: 1, b: 0 }
          },

          // Callback fired each time the config properties are set,
          // and immediately when the config is bound in this call:
          callback: function(props) {

              if (props.pinHeadColor) {
                 theAnnotation.setPinHeadColor(props.pinHeadColor);
              }

              if (props.pinShaftColor) {
                theAnnotation.setPinShaftColor(props.pinShaftColor);
             }

          }
  });
 </pre>

 <h3>Unsubscribing from a property:</h3>
 <pre>
 Human.properties.unsubscribe(subId);
 </pre>
 */
(function () {
    "use strict";

    var HumanProperties = Human.properties = {};

    // Subscription handle map, can internally generate new handles,
    // as well as insert user-generated handles
    var idPool = new Human.utils.IDPool();

    /**
     * Currently defined properties
     * @type {{*}}
     * @memberof Human.properties
     */
    HumanProperties.properties = {};

    // Maps subscription handles to callbacks
    var subCallbacks = {};

    // For each style, a map of callbacks mapped to subscription IDs
    var propSubCallbacks = {};

    // Maps subscription handles to property IDs
    var subProps = {};

    /**
     * Subscribes to a property, defining it first if not defined, and optionally setting its value
     *
     * <pre>
     *
     * // This format is extensible, eg. in case we want to add metadata etc
     *
     * var subId = Human.properties.subscribe({
     *          subId: "foo", // Call can opt to manage subscription IDs themselves
     *          propId: "myProperty",
     *          value: {
     *              color: { r: 0.2, g: 0.7, b: 1.0 },
     *              width: 1.2
     *          },
     *          callback: function(config) {
     *              someElement.setColor(config.color);
     *              someElement.setWidth(config.width);
     *          }
     *     });
     * </pre>
     *
     * @memberof Human.properties
     * @return {String} Handle to the subscription, which can be given to {@link Human.properties.unsubscribe} to unsubscribe
     */
    HumanProperties.subscribe = function (params) {

        params = params || {};

        // Every property has an ID
        var propId = params.propId;
        if (!propId) {
            Human.log.error("Human.properties.subscribe", "Param expected: propId");
            return null;
        }

        // Subscriber gets updates via callback
        var callback = params.callback;
        if (!callback) {
            Human.log.error("Human.properties.subscribe", "Param expected: callback");
            return null;
        }

        // If caller supplies own subscription handle, ensure no clash with existing handles
        if (params.subId) {
            if (idPool.containsId(params.subId)) {
                Human.log.error("Human.properties.subscribe", "Subscription already exists with this ID: " + params.subId);
                return null;
            }
        }

        var value = params.value;
        var subId = idPool.getId(params.subId); // Generate or insert subscription handle in map
        var prop = HumanProperties.properties[propId];
        var callbacks;

        if (prop) {

            // TODO (AC): check if callbacks assignment can be consolidated.
            // Register callback for the new property
            callbacks = (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}));
            callbacks[subId] = callback;

            // Property already exists
            if (value) {

                // New value supplied; set the property
                HumanProperties.properties[propId] = value;
            }

            // Map callback to subscription handle
            subCallbacks[subId] = callback;

            // Map property to subscription handle
            subProps[subId] = propId;

            // Notify callback of new property value
            callback(value);

            // Return subscription handle
            return subId;
        }

        // Register callback for the new property
        callbacks = (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}));
        callbacks[subId] = callback;

        // Initial value not given, initialize to default
        if (value === undefined || value === null) {
            value = {}; // Might as well be a literal object
        }

        // Set property to new value
        HumanProperties.properties[propId] = value;

        // Map callback to subscription handle
        subCallbacks[subId] = callback;

        // Map property to subscription handle
        subProps[subId] = propId;

        // Notify callback of new property
        callback(value);

        // Return subscription handle
        return subId;
    };

    /**
     * Switches a subscription to a different property
     *
     * @param {String} subId Subscription handle that was obtained with {@link Human.properties.subscribe}
     * @param {String} propId ID of property to switch the subscription to
     * @memberof Human.properties
     */
    HumanProperties.resubscribe = function (subId, propId) {
        var callback = subCallbacks[subId];
        if (!callback) {
            Human.log.warn("Human.properties.resubscribe", "Subscription not found: '" + subId + "'");
            return;
        }
        var oldPropId = subProps[subId];
        var newProp = HumanProperties.properties[propId];
        if (oldPropId && newProp) {
            if (propSubCallbacks[oldPropId]) {
                delete propSubCallbacks[oldPropId][subId];
            }
            (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}))[subId] = callback;
            subProps[subId] = propId;
            callback(newProp);
        }
    };

    /**
     * Creates or edits one or more properties
     * @memberof Human.properties
     * @param {String} propId ID of config
     * @param {*} props Properties to write to the config
     */
    HumanProperties.set = function (props) {
        var value;
        var callbacks;
        for (var propId in props) {
            if (props.hasOwnProperty(propId)) {
                value = props[propId];
                HumanProperties.properties[propId] = value;
                callbacks = propSubCallbacks[propId];
                if (callbacks) {
                    for (var subId in callbacks) {
                        if (callbacks.hasOwnProperty(subId)) {
                            callbacks[subId](value);
                        }
                    }
                }
            }
        }
    };

    /**
     * Unsubscribes from a property
     * @memberof Human.properties
     * @param {String} subId Subscription ID
     */
    HumanProperties.unsubscribe = function (subId) {
        var propId = subProps[subId];
        if (!propId) {
            return;
        }
        delete subProps[subId];
        delete propSubCallbacks[propId][subId];
    };

    /**
     * Query existing props
     * @param {String} [regex] Regular expression to select properties by name
     * @returns {*} JSON map of queried props
     */
    HumanProperties.query = function (regex) {
        if (!regex) {
            return HumanProperties.properties;
        }
        var props;
        if (regex) {
            var pattern = new RegExp(regex);
            props = {};
            for (var propId in HumanProperties.properties) {
                if (HumanProperties.properties.hasOwnProperty(propId)) {
                    if (pattern.test(propId)) {
                        props[propId] = HumanProperties.properties[propId];
                    }
                }
            }
        }
        return props;
    };


    var defaults = {
      "annotations.margins":{
         "top":80,
         "left":50,
         "right":50,
         "bottom":50
      },
      "annotations.labelWidth":120,
      "annotations.horizontalLines":false,
      "annotations.fadeoutAngle":100,
      "annotation.layout.labelWidth":100,
      "annotations.layout.type":"draggable",
      'camera.optics.far': 5000,
      'camera.optics.fov': 55,
      'camera.optics.near': 0.1,
      'camera.zoomLimits':{
        max: 300,
        min: 0.01
      },
      'fog.color': [1,1,1],
      'fog.density': 0.01,
      'fog.enabled': false,
      'fog.end': 1000,
      'fog.max': 1,
      'fog.min': 0,
      'fog.mode':1,
      'fog.start':0,
      'timeline.autoPlay.enabled': false,
      'timeline.autoPlay.type': 'play',
      'timeline.chapterCamerasEnabled': true,
      'timeline.prevNextMode': 'scrub',
      'tooltips.enabled': true,
      'ui.mouseWheel.capture': true,
      'ui.zoom.mouseWheel.enabled': true
    };

    HumanProperties.getDefaults = function(prop){
      if (prop) {
            return defaults[prop];
      } else {
            return Human.utils.shallowClone(defaults);
      }
    };

    HumanProperties.setDefaults = function (props) {
        Human.utils.apply(props, defaults);
    };

    HumanProperties.applyDefaults = function () {
        this.set(defaults);
    };

})();
;/**
 * @namespace Provides methods for logging debug info, warnings and errors.
 */
(function () {
    "use strict";

    var log = Human.log = {};

    /**
     * Logging level at which nothing is logged
     * @memberof Human.log
     * @private
     */
    log.LOG_NONE = 0;

    /**
     * Logging level at which everything is logged
     * @memberof Human.log
     * @private
     */
    log.LOG_DEBUG = 1;

    /**
     * Logging level at which only info, warnings and errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_INFO = 2;

    /**
     * Logging level at which only warnings and errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_WARN = 3;

    /**
     * Logging level at only errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_ERROR = 4;

    // Store messages for reporting
    log.messages = [];
    log.maxMessages = 100;

    // Used in event that notifies on each logged message
    var levelNames = ["none", "debug", "info", "warn", "error"];

    // Buffers messages until engine ready, at which point
    // they are each fired off in a Log.Message event
    var messageBuf = log.messageBuf = [];
    var maxMessageBuf = 200;

    var minLogLevel = log.LOG_WARN;

    // Reporters which may be registered to report logging messages as they happen
    var reporters = log.reporters = {};

    /**
     * Sets minimum log level. Messages logged to levels below that will then not be reported.
     * @memberof Human.log
     * @private
     */
    log.setLevel = function (newLevel) {
        minLogLevel = newLevel;
    };

    /**
     * Returns the current minimum log level
     * @memberof Human.log
     * @private
     */
    log.getLevel = function () {
        return minLogLevel;
    };

    /**
     * Logs a message at the given logging level.
     * @memberof Human.log
     * @private
     */
    log.log = function (message, level) {
        level = (level === undefined || level === null) ? log.INFO : level;
        switch (level) {
            case log.LOG_DEBUG:
                if (minLogLevel <= log.LOG_DEBUG && window.console && window.console.debug) {
                    window.console.debug(message);
                    recordMessage(message, level);
                }
                break;
            case log.LOG_ERROR:
                if (minLogLevel <= log.LOG_ERROR && window.console && window.console.error) {
                    window.console.error(message);
                    recordMessage(message, level);
                }
                break;
            case log.LOG_INFO:
                if (minLogLevel <= log.LOG_INFO && window.console && window.console.info) {
                    window.console.info(message);
                    recordMessage(message, level);
                }
                break;
            case log.LOG_WARN:
                if (minLogLevel <= log.LOG_WARN && window.console && window.console.warn) {
                    window.console.warn(message);
                    recordMessage(message, level);
                }
                break;
        }
        var event = {
            message: message,
            level: levelNames[level]
        };
        // Fire off to existing reporters
        for (var reporterId in reporters) {
            if (reporters.hasOwnProperty(reporterId)) {
                Human.events.fire(reporterId, event);
            }
        }
        // If message buffer now too long, flush and start it again with warning
        if (messageBuf.length > maxMessageBuf) {
            messageBuf.length = 0;
            messageBuf.push({
                message: "Logging buffer exceeded max length of " + maxMessageBuf +
                    " - messages to this point were flushed",
                level: levelNames[log.LOG_WARN]
            });
        }
        // Buffer message for reporters which may be created later
        messageBuf.push(event);
    };

    /** Logs a debugging message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.debug = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_DEBUG);
    };

    function pad(str) {
        return (str.length < 45) ? str + "                                                           ".substr(0, 45 - str.length) : str;
    }

    /** Logs an error message
     * @name error
     * @function
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.error = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_ERROR);
    };

    /** Logs an info message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.info = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_INFO);
    };

    /** Logs a warning message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.warn = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_WARN);
    };

    // Relay engine errors through logging methods
    Human.events.on("error",
        function (event) {
            log.error(event.message);
        });

    function recordMessage(message, level) {
        var levelName = levelNames[level].toUpperCase();

        if (log.messages.length > log.maxMessages) {
            log.messages.shift();
        }

        message = "[" + levelName + "]\t" + message;

        log.messages.push(message);
    }

})();



;/**
 * @namespace Supports query of params on URL in browser location bar.
 */
(function () {
    "use strict";

    var request = Human.request = {};

    var prevHash;
    var hashParams;
    var searchParams;

    request.getHashStr = function () {
        return window.location.hash;
    };

    /**
     * Gets all hash params.
     * @memberof Human.request
     * @return {*}
     */
    request.getHashParams = function () {
        if (!hashParams || prevHash !== window.location.hash) {
            hashParams = {};
            var stringAfterHash = window.location.hash.slice(1);
            var paramsAfterHash = stringAfterHash.split(',');
            var tokens;
            for (var i = 0, len = paramsAfterHash.length; i < len; i++) {
                tokens = paramsAfterHash[i].split("=");
                hashParams[tokens[0]] = tokens[1];
            }
            prevHash = window.location.hash;
        }
        return hashParams;
    };

    /** Gets a selected hash param - those params after the hash in the URL.
     * @memberof Human.request
     *
     * @param {String} key Hash parameter key
     * @return {String} Value of the hash parameter
     */
    request.getHashParam = function (key) {
        if (!hashParams || prevHash !== window.location.hash) {
            request.getHashParams();
        }
        return hashParams[key];
    };

    /**
     * Gets the search string - those params after the "?" in the URL.
     * @memberof Human.request
     * @return {String} The search string
     */
    request.getSearchStr = function () {
        return window.location.search;
    };

    /**
     * Get all search parameters.
     * @memberof Human.request
     * @return {*}
     */
    request.getSearchParams = function () {
        if (!searchParams) {
            searchParams = {};
            var search = window.location.search.slice(1);
            var params = search.split('&');
            var tokens;
            for (var i = 0, len = params.length; i < len; i++) {
                tokens = params[i].split("=");
                searchParams[tokens[0]] = tokens[1];
            }
        }
        return searchParams;
    };

    /** Gets a selected search parameter
     * @memberof Human.request
     *
     * @param {String} key Search parameter key
     * @return {String} Value of the search parameter
     */
    request.getSearchParam = function (key) {
        if (!searchParams) {
            request.getSearchParams();
        }
        return searchParams[key];
    };

})();;
// This section is actually documenting rpc.js from human-rpc
/**
 * Human API constructor
 * @param {string} iframeId - ID of the iFrame that the Human is loaded into
 * @returns A HumanAPI instance
 *
 * @class HumanAPI
 * @classdesc The HumanAPI class is the core of the BioDIgital Human API.  A
 * HumanAPI instance will be attached to an iframe containing BioDIgital Human
 * content and can be used to send messages to or receive messages from it.
 */

/**
 * Send an API message to the Human.
 *
 * @param {string} message - Name of the API message
 * @param {object} [params] - Message parameters
 * @method
 * @name HumanAPI#send
 */

/**
 * Subscribe to a Human event
 *
 * @function
 * @name HumanAPI#on
 * @param {string} eventName - Name of the API event
 * @param {function} callback - Event handler function
 */

 /**
 * Subscribe to the next Human event of the given type
 *
 * @function
 * @name HumanAPI#once
 * @param {string} eventName - Name of the API event
 * @param {function} callback - Event handler function
 */


(function () {
    "use strict";

    var rpc = Human.rpc = {
        windowClientEnabled: true
    };

    var MAX_LOG_SIZE = 10000;

    /** Map of procedures that have been created with {@link Human.rpc.define}.
     * @memberof Human.rpc
     * @type {{}}
     */
    rpc._procedures = {};

    // Map of RPC event names to engine event names.
    rpc._eventMap = {};

    // Callbacks registered with #onResult
    var resultCallbacks = [];

    // Allow definition of several deprecated functions at a time.
    var globalHideDefinitions = false;

    var hiddenProcedures = {};

    var log = [];


    /**
     * Execution scope for a procedure execution.
     * <p>A fresh one of these is instantiated for every procedure call, providing the procedure with
     * methods for returning the procedure result and logging.</p>
     * @param {string} procName Procedure name, for logging
     * @param {string} callId ID of procedure call, against which procedure result, if any, will be published
     * @constructor
     */
    function Scope(procName, callId) {
        this.procName = procName;
        this.callId = callId;
    }

    /**
     * Publishes the result of the procedure call.
     * <p>The result value is published against the ID of the caller,
     * who may subscribe to that ID using methods like {#link Human.rpc.on} in order to get the result.</p>
     * @param {{}} value The result value
     */
    Scope.prototype.setResult = function (value) {
        for (var i = 0, len = resultCallbacks.length; i < len; i++) {
            resultCallbacks[i](this.callId, value);
        }
    };

    /**
     * Logs debug info in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.info = function (msg) {
        Human.log.info(this.procName, msg);
    };

    /**
     * Logs a warning in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.warn = function (msg) {
        Human.log.warn(this.procName, msg);
    };

    /**
     * Logs an error in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.error = function (msg) {
        Human.log.error(this.procName, msg);
    };

    /**
     * Registers a procedure, which may then be called with {@link #call}.
     *
     * @param {string} procName Procedure name
     * @param {function} proc The procedure
     */
    rpc.define = function (procName, proc, params) {
        if (rpc._procedures[procName]) {
            Human.log.warn("Human.rpc.define", "Redefining procedure: " + procName);
        }

        params = params || {};

        if (params.hidden || globalHideDefinitions) {
            hiddenProcedures[procName] = true;
        }

        rpc._procedures[procName] = function (callId, params) {
            proc.call(new Scope(procName, callId), params || {});
        };
    };

    rpc.defineEvent = function(rpcEventName, params) {

        if (rpc._eventMap[rpcEventName]) {
            Human.log.warn("Human.rpc.defineEvent", "Redefining event: " + rpcEventName);
        }

        rpc._eventMap[rpcEventName] = params || rpcEventName;
    };

    rpc.enableEvent = function(scope, rpcEventName, once) {

        if (!rpc._eventMap[rpcEventName]) {
            Human.log.warn("Human.rpc.enableEvent", "Event: " + rpcEventName + " not defined.");
            return;
        }

        var params = rpc._eventMap[rpcEventName];

        if (typeof params === "string") {
            var eventFn = once ? "once" : "on";

            Human.events[eventFn](params, function(event) {
                scope.setResult(event);
            });
        } else {
            mapEvents(scope, params, once);
        }

    };

    function mapEvents(scope, params, once) {

        var triggered = false;

        var eventFn = once ? "once" : "on";

        var eventNames = params.events;
        var mapFn = params.map;

        if (params.init) {
            params.init();
        }

        function callback(event) {
            if (once && triggered) {
                return;
            }

            triggered = true;

            var result = mapFn ? mapFn(event) : event;

            if (result !== null) {
                scope.setResult(result || {});
            }

        }

        for (var i = 0, len = eventNames.length; i < len; i++) {

            Human.events[eventFn](eventNames[i], callback);

        }
    }

    // Get names of all available, public procedures
    rpc.getProcedures = function() {
        var procNames = Object.keys(rpc._procedures);

        Human.utils.filterInPlace(procNames, function(name) {
            return !hiddenProcedures[name];
        });

        return procNames;
    };

    // Get names of all available events
    rpc.getEvents = function() {
        return ["human.ready"].concat(Object.keys(rpc._eventMap));
    };

    // RPC procedures created in the callback function
    // will be considered hidden.
    rpc.hideDefinitions = function(fn) {
        globalHideDefinitions = true;

        try {
            fn();
        } finally {
            globalHideDefinitions = false;
        }
    };

    /**
     * Subscribes to results of subsequent RPC calls.
     *
     * <p>Each time a procedure returns a result, the given callback will be fired
     * with the the ID of the procedure call and the value that was returned.</p>
     *
     * <pre>
     *     #onResult(function(callId, value) {
     *         //..
     *     });
     *
     * @param {function(callId, value)} callback The callback
     * @function
     * @name onResult
     * @memberof Human.rpc
     */
    rpc.onResult = function (callback) {
        resultCallbacks.push(callback);
    };


    rpc.call = function (callId, procName, params) {
        var proc = rpc._procedures[procName];
        if (!proc) {
            Human.log.warn("Human.rpc.call", "Target procedure not found: " + procName);
            return;
        }

        proc(callId, params);
    };

    rpc.log = function(procName) {
        if (log.length > MAX_LOG_SIZE) {
            log.shift();
        }

        log.push({
            "engine_version": Human.VERSION,
            "api_version": Human.API_VERSION,
            "identifier": procName,
            "category": procName.split(".")[0]
        });
    };

    rpc.getLog = function() {
        return log;
    };

    rpc.logPending = function() {
        return log.length > 0;
    };

    rpc.resetLog = function() {
        log.length = 0;
    };

    rpc.filterUnsafeProperties = function(obj) {
        if (!Human.utils.isObject(obj)) {
            return obj;
        }

        var clean = {};

        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                if (isSafe(obj[key])) {
                    clean[key] = obj[key];
                }
            }
        }

        return clean;
    };

    function isSafe(obj) {
        if (!obj || typeof obj !== "object") {
            return true;
        }

        // Window
        if (obj === window) {
            return false;
        }

        // Dom Element
        if (typeof obj.nodeName === "string" && typeof obj.querySelectorAll === "function" && typeof obj.getElementsByTagName === "function") {
            return false;
        }

        // Event
        if (typeof obj.preventDefault === "function" && typeof obj.stopPropagation === "function") {
            return false;
        }

        return true;
    }

})();
;/**
 * This is the global Human namespace, used primarly to get system or API
 * info.
 *
 * @namespace human
 */

(function () {
    "use strict";

    /**
     * @memberof human
     * @callback HumanInfoCallback
     * @param {object} params
     * @param {string} params.version - Human version number
     * @param {object} params.webglInfo - Client WebGL capabilities
     * @param {array} params.apiFunctions - Available API functions
     * @param {array} params.apiEvents - Available API events
     *
     */

    /**
     * Query human info
     *
     * @apimethod human.send
     * @function info
     * @memberof human
     *
     * @param {human.HumanInfoCallback} callback
     *
     * @example <caption>Get Human API info</caption> <codepen>http://codepen.io/biodigital/pen/d3ea3aed40f2b829b405ad2c6b5ae6a0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.send("human.info", function(human) {
     *     console.log("Gathering human info:");
     *     console.log(JSON.stringify(human));
     * });
     */
    Human.rpc.define("human.info", function () {
        this.setResult({
            version: Human.VERSION,
            webglInfo: SceneJS.WEBGL_INFO,
            apiFunctions: Human.rpc.getProcedures().sort(),
            apiEvents: Human.rpc.getEvents().sort(),
        });
    });

    Human.rpc.defineEvent("human.error", "error");

    // Events

    /**
     * Fired when the Human has loaded and is ready to respond to the API
     *
     * @event human.ready
     * @apimethod human.on
     * @memberof human
     *
     * @example <caption>Human ready event</caption> <codepen>http://codepen.io/biodigital/pen/df05be58332b56811acb9adaa39e4b03</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Listening for human.ready event");
     *
     * human.on("human.ready", function() {
     *     console.log("Human loaded!");
     * });
     */

})();
;/**
 * Annotations are custom labels that you can pin to the Human anatomy to
 * add descriptive text or bring attention to areas of interest. Each
 * annotation is defined by its 3D position, the object it's attached to,
 * summary text (the title), and optionally, longer descriptive text
 * (the description).
 *
 * @namespace annotations
 */
(function() {
    "use strict";

    /**
     * @memberof annotations
     * @callback AnnotationInfoCallback
     * @param {object} annotationList - A map of annotations IDs to annotation info
     *
     * @param {string} annotationList[].annotationId
     * @param {string} annotationList[].objectId - Id of the object this annotation is attached to
     * @param {string} annotationList[].title - Annotation title text
     * @param {string} annotationList[].description - Annotation description text
     * @param {array} annotationList[].position - Annotation's 3D position
     * @param {array} annotationList[].canvasPosition - Annotation's position on the canvas
     * @param {boolean} annotationList[].shown - Is the annotation currently visible?
     * @param {boolean} annotationList[].occludable - Can the annotation be hidden by objects in the scene
     *
     */

    /**
     * Get annotation Info
     *
     * @apimethod human.send
     * @function annotations.info
     *
     * @param {AnnotationInfoCallback} callback
     *
     * @example <caption>Get annotation info</caption> <codepen>http://codepen.io/biodigital/pen/82019c254ffbc102291e383336d9215b</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Annother annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * human.send("annotations.info", function(annotations) {
     *     console.log("Gathering annotation info:");
     *     console.log(JSON.stringify(annotations));
     * });
     */
    Human.rpc.define("annotations.info",
        function () {
            var annotations = Human.view.annotations.annotations;
            var result = {};
            var annotation;

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    result[annotationId] = getAnnotationResult(annotation);
                }
            }

            this.setResult(result);
        });

    /**
     * Create an annotation
     *
     * @apimethod human.send
     * @function create
     * @memberof annotations
     *
     * @fires annotations.created
     *
     * @param {object} params
     * @param {string} [params.annotationId] - ID to assign to the annotation, generated internally if omitted
     * @param {string} [params.title] - Annotation title text
     * @param {string} [params.description] - Annotation description text
     * @param {boolean} [params.shown=true] - Should this annotation be shown initially?
     * @param {boolean} [params.occludable=true] - Can the annotation be hidden by objects in the scene?
     * @param {string} [params.objectId] - ID of an object to attach to
     * @param {array} [params.position] - Position of the annotation pin in 3D space
     * @param {array} [params.labelOffset] - X and Y offsets of the label's position from the pin's
     *
     * @param {function} [callback]
     * @param {object} callback.annotation - The new annotation, or null if an error occurred
     *
     * @example <caption>Create an annotation</caption><codepen>http://codepen.io/biodigital/pen/93e75938ed8e2e662baeba55a885fd94</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotation attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID"
     * });
     */
    Human.rpc.define("annotations.create", function (params) {
        // Default to saving annotation when created via API
        params.saved = params.saved !== false;

        if (params.position) {
            params.pos = params.position;
        }

        var annotation = Human.view.annotations.createAnnotation(params);

        this.setResult(getAnnotationResult(annotation));
    });

    /**
     * Update an annotation
     *
     * @apimethod human.send
     * @function update
     * @memberof annotations
     *
     * @param {object} params
     * @param {string} params.annotationId - ID of the annotation to update
     * @param {string} [params.title] - New annotation title text
     * @param {string} [params.description] - New annotation description text
     *
     * @example <caption>Update annotations</caption> <codepen>http://codepen.io/biodigital/pen/2d6a49383f0194dd97291ce48ab07849</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotation attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     *
     *     // Provide annotation ID (must be unique!) so we can
     *     // refer to this annotation later.
     *     annotationId: "myAnnotationId"
     * });
     *
     * human.on("human.ready", function () {
     *     console.log("Updating annotation in 2s");
     *
     *     setTimeout(function() {
     *
     *         // Update annotation title and description using the
     *         // annotation ID we provided on creation.
     *         human.send("annotations.update", {
     *             annotationId: "myAnnotationId",
     *             title: "My updated annotation",
     *             description: "This annotation was created and updated via the API."
     *         });
     *
     *         console.log("Annotation updated");
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("annotations.update", function (params) {
        Human.view.annotations.updateAnnotation(params.annotationId, params);
        this.setResult(true);
    });

    /**
     * Show all annotations
     *
     * @apimethod human.send
     * @function show
     * @memberof annotations
     *
     * @fires annotations.shown
     *
     * @example <caption>Show and hide annotations</caption> <codepen>http://codepen.io/biodigital/pen/bbd8fca7fe2a6514374c23612b5e4bd0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Another annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * var shown = true;
     *
     * setInterval(function() {
     *     shown = !shown;
     *
     *     if (shown) {
     *         console.log("Show annotations")
     *         human.send("annotations.show");
     *     } else {
     *         console.log("Hide annotations")
     *         human.send("annotations.hide");
     *     }
     *
     * }, 2000);
     *
     */
    Human.rpc.define("annotations.show", function () {
        Human.view.annotations.setShown(true);
        this.setResult(true);
    });

    /**
     * Hide all annotations
     *
     * @apimethod human.send
     * @function hide
     * @memberof annotations
     *
     * @fires annotations.hidden
     *
     * @example <caption>Show and hide annotations</caption> <codepen>http://codepen.io/biodigital/pen/bbd8fca7fe2a6514374c23612b5e4bd0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Annother annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * var shown = true;
     *
     * setInterval(function() {
     *     shown = !shown;
     *
     *     if (shown) {
     *         console.log("Show annotations")
     *         human.send("annotations.show");
     *     } else {
     *         console.log("Hide annotations")
     *         human.send("annotations.hide");
     *     }
     *
     * }, 2000);
     */
    Human.rpc.define("annotations.hide", function () {
        Human.view.annotations.setShown(false);
        this.setResult(true);
    });

    /**
     * Destroy an annotation
     *
     * @apimethod human.send
     * @function destroy
     * @memberof annotations
     *
     * @fires annotations.destroyed
     *
     * @param {string} annotationId - ID of the annotation to destroy
     *
     * @example <caption>Destroy an annotation</caption> <codepen>http://codepen.io/biodigital/pen/aacf76b1dddd4aa9b628f15c75c5b86f</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotation attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     *
     *     // Provide annotation ID (must be unique!) so we can
     *     // refer to this annotation later.
     *     annotationId: "myAnnotationId"
     * });
     *
     * human.on("human.ready", function() {
     *     console.log("Destroying annotation in 2s");
     *
     *     setTimeout(function() {
     *
     *         // Destroy annotation using the annotation ID we provided
     *         // on creation.
     *         human.send("annotations.destroy", "myAnnotationId");
     *         console.log("Annotation destroyed");
     *     }, 2000);
     * });
     */
    Human.rpc.define("annotations.destroy", function (params) {
        if (typeof params === "string") {
            params = {
                annotationId: params
            };
        }
        var annotation = Human.view.annotations.annotations[params.annotationId];
        if (annotation) {
            annotation.destroy();
        }
        this.setResult(true);
    });




    // Events

    /**
     * @event
     * @name created
     * @apimethod human.on
     * @memberof annotations
     * @param {object} event
     * @param {string} event.annotationId
     * @param {string} event.objectId - Id of the object this annotation is attached to
     * @param {string} event.title - Annotation title text
     * @param {string} event.description - Annotation description text
     * @param {array} event.position - Annotation's 3D position
     * @param {array} event.canvasPosition - Annotation's position on the canvas
     * @param {boolean} event.shown - Is the annotation currently visible?
     * @param {boolean} event.occludable - Can the annotation be hidden by objects in the scene
     *
     * @example <caption>Created event</caption> <codepen>http://codepen.io/biodigital/pen/a1a13ec4bda1c3714d48db502c9f1534</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("annotations.created", function (event) {
     *     console.log("Annotation created!");
     *     console.log("annotations.created event info: " + JSON.stringify(event));
     * });
     *
     * console.log("Listening for annotations.created event");
     *
     * human.on("human.ready", function() {
     *     setTimeout(function() {
     *
     *         human.send("annotations.create", {
     *             title: "My annotation",
     *             description: "This annotation was created via the API.",
     *             objectId: "maleAdult_standard-Frontal_bone_52734_ID"
     *         });
     *
     *     }, 2000);
     * });
     */
    Human.rpc.defineEvent("annotations.created", {
        events: ["annotations.created"],
        map: getAnnotationResult
    });

    /**
     * @event annotations.destroyed
     * @apimethod human.on
     * @memberof annotations
     * @param {object} event
     * @param {string} event.annotationId
     *
     * @example <caption>Destroyed event</caption> <codepen>http://codepen.io/biodigital/pen/9c290307f91a098ed4f57e0c7c578c61</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("annotations.destroyed", function (event) {
     *     console.log("Annotation destroyed!");
     *     console.log("annotations.destroyed event info: " + JSON.stringify(event));
     * });
     *
     * // Create annotation attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     *
     *     // Provide annotation ID (must be unique!) so we can
     *     // refer to this annotation later.
     *     annotationId: "myAnnotationId"
     * });
     *
     * console.log("Listening for annotations.destroyed event");
     *
     * human.on("human.ready", function() {
     *     setTimeout(function() {
     *
     *         human.send("annotations.destroy", "myAnnotationId");
     *
     *     }, 2000);
     * });
     */
    Human.rpc.defineEvent("annotations.destroyed");

    /**
     * @event annotations.shown
     * @apimethod human.on
     * @memberof annotations
     *
     * @example <caption>Shown/hidden events</caption> <codepen>http://codepen.io/biodigital/pen/2032fc8bb50a363f7bb8bee19570d43f</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Annother annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * console.log("Listening for annotation shown and hidden events.")
     *
     * human.on("annotations.shown", function () {
     *     console.log("Annotations shown!");
     * });
     *
     * human.on("annotations.hidden", function () {
     *     console.log("Annotations hidden!");
     * });
     *
     * var shown = true;
     *
     * setInterval(function() {
     *     shown = !shown;
     *
     *     if (shown) {
     *         human.send("annotations.show");
     *     } else {
     *         human.send("annotations.hide");
     *     }
     *
     * }, 2000);
     */
    Human.rpc.defineEvent("annotations.shown", {
        events: ["annotations.shown"],
        map: function(event) {
            if (!event.shown) {
                return null;
            }
        }
    });

    /**
     * @event annotations.hidden
     * @apimethod human.on
     * @memberof annotations
     *
     * @example <caption>Shown/hidden events</caption> <codepen>http://codepen.io/biodigital/pen/2032fc8bb50a363f7bb8bee19570d43f</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "My annotation",
     *     description: "This annotation was created via the API.",
     *     objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     * });
     *
     * // Create annotations attached to an object
     * human.send("annotations.create", {
     *     title: "Annother annotation",
     *     description: "This annotation was also created via the API.",
     *     objectId: "maleAdult_standard-Right_major_alar_cartilage_59505_ID",
     * });
     *
     * console.log("Listening for annotation shown and hidden events.")
     *
     * human.on("annotations.shown", function () {
     *     console.log("Annotations shown!");
     * });
     *
     * human.on("annotations.hidden", function () {
     *     console.log("Annotations hidden!");
     * });
     *
     * var shown = true;
     *
     * setInterval(function() {
     *     shown = !shown;
     *
     *     if (shown) {
     *         human.send("annotations.show");
     *     } else {
     *         human.send("annotations.hide");
     *     }
     *
     * }, 2000);
     */
    Human.rpc.defineEvent("annotations.hidden", {
        events: ["annotations.shown"],
        map: function(event) {
            if (event.shown) {
                return null;
            }
        }
    });

    function getAnnotationResult(annotation) {
        annotation = Human.view.annotations.annotations[annotation.annotationId];

        var pin = annotation.pin;

        if (!pin.canvasPos) {
            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();
            var canvas = Human.renderer.canvas.annotationCanvas[0];

            pin.transform(viewMat, projMat, canvas);
        }

        return {
            annotationId: annotation.annotationId,
            title: annotation.label.title,
            description: annotation.label.description,
            objectId: annotation.object ? annotation.object.objectId : null,
            position: {
                x: pin.pos[0],
                y: pin.pos[1],
                z: pin.pos[2]
            },
            canvasPosition: {
                x: pin.canvasPos[0],
                y: pin.canvasPos[1]
            },
            occludable: annotation.occludable,
            shown: annotation.pin.shown
        };

    }
})();
;/**
 * The camera is your point of view into the 3D anatomy scene. It
 * is defined by its position in 3D space and the 3D point it's aimed at
 * (the target). Optionally, you can also set an "up" direction for the
 * camera, which allows you to get rotated or upside-down views of the
 * anatomy.
 *
 * @namespace camera
 */
(function() {
    "use strict";

    /**
     * @memberof camera
     * @callback CameraInfoCallback
     * @param {object} camera
     * @param {object} [camera.position] - Camera position in 3D space
     * @param {number} [camera.position.x]
     * @param {number} [camera.position.y]
     * @param {number} [camera.position.z]
     * @param {object} [camera.target] - 3D position the camera is focused on
     * @param {number} [camera.target.x]
     * @param {number} [camera.target.y]
     * @param {number} [camera.target.z]
     * @param {object} [camera.up] - Vector indicating which way is up for the camera
     * @param {number} [camera.up.x]
     * @param {number} [camera.up.y]
     * @param {number} [camera.up.z]
     * @param {number} camera.zoom - Camera zooming factor
     *
     */

    /**
     * Update camera location
     *
     * @apimethod human.send
     * @function set
     * @memberof camera
     *
     * @fires camera.updated
     *
     * @param {object} params
     * @param {string} [params.objectId] - ID of an object to focus on
     * @param {object} [params.position] - Camera position in 3D space
     * @param {number} [params.position.x]
     * @param {number} [params.position.y]
     * @param {number} [params.position.z]
     * @param {object} [params.target] - 3D position the camera should focus on
     * @param {number} [params.target.x]
     * @param {number} [params.target.y]
     * @param {number} [params.target.z]
     * @param {object} [params.up] - Vector indicating which way is up for the camera
     * @param {number} [params.up.x]
     * @param {number} [params.up.y]
     * @param {number} [params.up.z]
     * @param {boolean} [params.animate=false] - Animate camera's movement to new location
     * @param {string} [params.animationStyle="around"] - Animation can be straight to new position ("direct") or around objects in the scene ("around")
     * @param {number} [params.animationDuration] - Animation duration in seconds.
     * @param {function} [callback]
     *
     * @example <caption>Set camera position</caption> <codepen>http://codepen.io/biodigital/pen/daa6398b1a6b9aa6d18afe06eab5d5b4</codepen>
     * human.send("camera.set", {
     *     position: {
     *         x: 20,
     *         y: 40,
     *         z: 0
     *     }
     * });
     *
     * @example <caption>Set camera target</caption> <codepen>http://codepen.io/biodigital/pen/bf3783911239a812253a19e8e0b4f567</codepen>
     * human.send("camera.set", {
     *     target: {
     *         x: 3,
     *         y: 23,
     *         z: 0
     *     }
     * });
     *
     * @example <caption>Animate camera target</caption> <codepen>http://codepen.io/biodigital/pen/f11d3263bd4b411af27f7aa242c8199d</codepen>
     * human.send("camera.set", {
     *     target: {
     *         x: 3,
     *         y: 23,
     *         z: 0
     *     },
     *     animate: true,
     *     animationDuration: 1.0 // Default
     * }, function() {
     *     console.log("Camera update complete");
     * });
     *
     * @example <caption>Animate camera position</caption> <codepen>http://codepen.io/biodigital/pen/1aef21b044d3f266082167805d61469f</codepen>
     * human.send("camera.set", {
     *     position: {
     *         x: 20,
     *         y: 40,
     *         z: 0
     *     },
     *     animate: true,
     *     animationDuration: 1.0 // Default
     * }, function() {
     *     console.log("Camera update complete");
     * });
     */
    Human.rpc.define("camera.set", function (params) {
        var self = this;

        if (params.position) {
            params.eye = params.position;
        }

        if (params.target) {
            params.look = params.target;
        }

        if (params.animationStyle === "direct") {
            params.cylindricalView = false;
        }

        if (params.animate) {
            Human.view.camera.fly.flyTo(params,
                function () {
                    self.setResult(true);
                });
        } else {
            Human.view.camera.fly.jumpTo(params,
                function () {
                    self.setResult(true);
                });
        }

    });

    /**
     * Orbit around camera's current point of focus
     *
     * @apimethod human.send
     * @function orbit
     * @memberof camera
     *
     * @param {object} params
     * @param {number} [params.yaw]
     * @param {number} [params.pitch]
     *
     * @param {function} [callback]
     *
     * @example <caption>Orbit the camera</caption> <codepen>http://codepen.io/biodigital/pen/5bb309c23d8c0f84b39916ece2c397ef</codepen>
     * (function update() {
     *     // Orbit camera horizontally around target
     *     human.send("camera.orbit", {
     *         yaw: 0.2
     *     });
     *     requestAnimationFrame(update);
     * })();
     */
    Human.rpc.define("camera.orbit", function (params) {
        if (params.yaw) {
            Human.view.camera.rotateY(params.yaw);
        }
        if (params.pitch) {
            Human.view.camera.rotateX(params.pitch);
        }
        this.setResult(true);
    });


    /**
     * Pan camera to new position
     *
     * @apimethod human.send
     * @function pan
     * @memberof camera
     *
     * @param {object} params
     * @param {number} [params.x]
     * @param {number} [params.y]
     * @param {number} [params.z]
     *
     * @param {function} [callback]
     *
     * @example <caption>Pan the camera</caption> <codepen>http://codepen.io/biodigital/pen/e90560867be3fd3790cae2dfdf8a1ffe</codepen>
     * var MAX_PAN = 10;
     * var currentPan = 0;
     * var velocity = 0.1;
     *
     * (function update() {
     *     // Pan camera to the left or right
     *     human.send("camera.pan", {
     *         x: velocity
     *     });
     *
     *     currentPan += velocity;
     *     // Switch directions if outside range
     *     if (Math.abs(currentPan) > MAX_PAN) {
     *         velocity *= -1;
     *     }
     *     requestAnimationFrame(update);
     * })();
     */
    Human.rpc.define("camera.pan", function (params) {
        Human.view.camera.pan({
            x: params.x || 0,
            y: params.y || 0,
            z: params.z || 0
        });
        this.setResult(true);
    });

    /**
     * Zoom the camera in or out of its point of focus
     *
     * @apimethod human.send
     * @function zoom
     * @memberof camera
     *
     * @param {number} zoom - zoom factor, between 0 and 1
     * @param {function} [callback]
     *
     * @example <caption>Zoom the camera</caption> <codepen>http://codepen.io/biodigital/pen/1d49b190475ef182628c5f202c457b1b</codepen>
     * var currentZoom = 0.5;
     * var increment = 0.001;
     *
     * (function update() {
     *
     *     // Zoom camera in and out
     *     human.send("camera.zoom", currentZoom);
     *     currentZoom += increment;
     *
     *     // Switch directions if outside range (zoom range is 0..1)
     *     if (currentZoom > 0.9 || currentZoom < 0) {
     *         increment *= -1;
     *     }
     *     requestAnimationFrame(update);
     * })();
     */
    Human.rpc.define("camera.zoom", function (zoom) {
        var factor = typeof zoom === "number" ? zoom : zoom.factor;

        factor = Math.max(0, Math.min(factor || 0, 1));

        Human.view.camera.setZoom(factor);

        this.setResult(true);
    });

    /* NOTE: CURRENTLY UNDOCUMENTED
     * Camera path animation
     *
     * @apimethod human.send
     * @function path
     * @memberof camera
     *
     * @param {object} params
     * @param {object[]} params.points
     *
     * @param {object} params.points[].position - Camera position (eye)
     * @param {number} params.points[].position.x
     * @param {number} params.points[].position.y
     * @param {number} params.points[].position.z
     * @param {object} params.points[].target - Camera Target position (look at)
     * @param {number} params.points[].target.x
     * @param {number} params.points[].target.y
     * @param {number} params.points[].target.z
     * @param {object} [params.points[].up] - Camera Up Vector
     * @param {number} params.points[].up.x
     * @param {number} params.points[].up.y
     * @param {number} params.points[].up.z
     * @param {number} [params.velocity=1] - Camera velocity
     * @param {boolean} [params.constrainUp=false] - Fix camera up vector
     * @param {boolean} [params.easeIn=false] - Whether to ease in the animation
     * @param {boolean} [params.easeOut=true] - Whether to ease out the animation
     *
     * @param {function} [callback]
     *
     * @example <caption>Define a camera path</caption> <codepen>http://codepen.io/biodigital/pen/88c88c62d9b9f4fd0a08209220cc8b7c</codepen>
     * // Get initial camera position
     * human.send("camera.info", function(info) {
     *
     * // Define camera path.
     * // Initial camera position is inserted into path
     * // to avoid an initial jump.
     * human.send("camera.path", {
     *     points: [
     *     {
     *         position: info.position,
     *         target: info.target,
     *         up: info.up
     *     },
     *     {
     *         position: {
     *             x: 7.2915048649119685,
     *             y: 26.166339470455814,
     *             z: -11.74759554602381
     *         },
     *         target: {
     *             x: -0.06749999523162842,
     *             y: 19.702000617980957,
     *             z: 0.15849995613098145
     *         },
     *         up: {
     *             y:1
     *         }
     *     },
     *     ...
     *     ],
     *     velocity: 0.1,
     *     easeIn: false,
     *     easeOut: false,
     *     constrainUp: true
     * },
     * function() {
     *     console.log("Camera path animation complete!");
     * });
     */
    Human.rpc.define("camera.path", function (params) {
        var self = this;

        Human.view.camera.fly.flyAlongCurvePath(params,
            function () {
                self.setResult(true);
            });
    });

     /**
     * Get current camera information
     *
     * @apimethod human.send
     * @function info
     * @memberof camera
     *
     * @param {camera.CameraInfoCallback} callback
     *
     * @example <caption>Get camera info</caption> <codepen>http://codepen.io/biodigital/pen/f1659672f956bf2baec635994463b57d</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.console("camera.info", function(camera) {
     *     console.log("Gathering camera info:");
     *     console.log(JSON.stringify(camera));
     * });
     */
    Human.rpc.define("camera.info", function () {
        this.setResult(getCameraResult());
    });

    /**
     * Reset camera to original position
     *
     * @apimethod human.send
     * @function reset
     * @memberof camera
     *
     * @param {function} callback
     *
     * @example <caption>Reset camera</caption> <codepen>http://codepen.io/biodigital/pen/c25f90dab23d1cd3a87aca50745b9883</codepen>
     * human.send("camera.set", {
     *     position: {
     *         x: 20,
     *         y: 40,
     *         z: 0
     *     },
     *     animate: true
     * }, function() {
     *     console.log("Camera update complete");
     *     console.log("Resetting camera in 2s");
     *
     *     setTimeout(function() {
     *         // Return camera to original position
     *         human.send("camera.reset", function() {
     *             console.log("Camera reset complete");
     *         });
     *     }, 2000);
     * });
     */
    Human.rpc.define("camera.reset",
        function () {
            var self = this;
            Human.init.resetCamera(function () {
                self.setResult(true);
            });
        });

    // Events

    /**
     * @event camera.updated
     * @apimethod human.on
     * @memberof camera
     * @param {object} camera
     * @param {object} camera.position - Camera position in 3D space
     * @param {number} camera.position.x
     * @param {number} camera.position.y
     * @param {number} camera.position.z
     * @param {object} camera.target - 3D position the camera should focus on
     * @param {number} camera.target.x
     * @param {number} camera.target.y
     * @param {number} camera.target.z
     * @param {object} camera.up - Vector indicating which way is up for the camera
     * @param {number} camera.up.x
     * @param {number} camera.up.y
     * @param {number} camera.up.z
     * @param {number} camera.zoom - Camera zoom level
     *
     * @example <caption>Updated event</caption> <codepen>http://codepen.io/biodigital/pen/cf5cd1b2721a46903e814a76c7e7f725</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Listening for camera updated event");
     *
     * human.on("camera.updated", function(event) {
     *     console.log("Camera updated!");
     *     console.log("camera.updated event info: " + JSON.stringify(event));
     * });
     *
     * human.on("human.ready", function() {
     *     setTimeout(function() {
     *         human.send("camera.set", {
     *             position: {
     *                 x: 20,
     *                 y: 40,
     *                 z: 0
     *             },
     *             animate: true
     *         });
     *     }, 2000);
     * });
     */
    Human.rpc.defineEvent("camera.updated", {
        events: ["camera.rested"],
        map: getCameraResult
    });

    function getCameraResult() {
        var lookAt = Human.view.camera.getLookAt();

        return {
            position: lookAt.eye,
            target: lookAt.look,
            up: lookAt.up,
            zoom: Human.view.camera.getZoom()
        };
    }

})();
;/*
 * RPC procedures for subscription to engine events.
 *
 */

Human.rpc.hideDefinitions(function () {
    "use strict";

    Human.rpc.define("apiEvents.on", function (eventName) {
        Human.rpc.enableEvent(this, eventName, false);
    });

    Human.rpc.define("apiEvents.once", function (eventName) {
        Human.rpc.enableEvent(this, eventName, true);
    });

});
;/**
 * The input namespace defines messages that allow you to enable
 * or disable mouse and keyboard interaction with the Human scene.
 *
 * @namespace input
 */
(function() {
	"use strict";

	/**
     * Disable user input
     *
     * @apimethod human.send
     * @function disable
     * @memberof input
     *
	 * @example <caption>Enable/disable user input</caption> <codepen>http://codepen.io/biodigital/pen/67b7b6b1e689a745323efd14a464f590</codepen>
	 * // Initialize API
	 * var human = new HumanAPI("embeddedHuman");
	 *
	 * var enabled = true;
	 *
	 * setInterval(function() {
	 *     enabled = !enabled;
	 *
	 *     if (enabled) {
	 *         console.log("Input enabled (try clicking and dragging)")
	 *         human.send("input.enable");
	 *     } else {
	 *         console.log("Input disabled (try clicking and dragging)")
	 *         human.send("input.disable");
	 *     }
	 *
	 * }, 2000);
     */
	Human.rpc.define("input.disable",
	    function () {
	        Human.input.setEnabled(false);
	    });

	/**
     * Enable user input
     *
     * @apimethod human.send
     * @function enable
     * @memberof input
     *
	 * @example <caption>Enable/disable user input</caption> <codepen>http://codepen.io/biodigital/pen/67b7b6b1e689a745323efd14a464f590</codepen>
	 * // Initialize API
	 * var human = new HumanAPI("embeddedHuman");
	 *
	 * var enabled = true;
	 *
	 * setInterval(function() {
	 *     enabled = !enabled;
	 *
	 *     if (enabled) {
	 *         console.log("Input enabled (try clicking and dragging)")
	 *         human.send("input.enable");
	 *     } else {
	 *         console.log("Input disabled (try clicking and dragging)")
	 *         human.send("input.disable");
	 *     }
	 *
	 * }, 2000);
     */
	Human.rpc.define("input.enable",
	    function () {
	        Human.input.setEnabled(true);
	    });


})();
;/**
 * The scene is the collection of 3D objects currently being rendered. Scene messages allow
 * you to control what scenes are loaded, how they're rendered and to gather information
 * about what's currently in the scene.
 *
 * @namespace scene
 */
(function() {
    "use strict";

    /**
     * @memberof scene
     * @callback PickInfoCallback
     * @property {object} pick
     * @property {string} pick.objectId - ID of the object that was picked
     * @property {string} pick.mode - The mode of the pick
     * @property {object} pick.canvasPosition - 2D coordinates of the pick location on the canvas
     * @property {number} pick.canvasPosition.x
     * @property {number} pick.canvasPosition.y
     * @property {object} pick.position - 3D coordinates of the pick location in the scene
     * @property {number} pick.position.x
     * @property {number} pick.position.y
     * @property {number} pick.position.z
     *
     */

    /**
     * Load new content into the scene. This can be either a module (core
     * content created by BioDigital), or bookmark
     *
     * @apimethod HumanAPI.call
     * @function load
     * @memberof scene
     *
     * @fires scene.picked
     *
     * @param {string} [id] - ID of the module or bookmark to load
     * @param {scene.PickInfoCallback} callback
     *
     * @example <caption>Load a scene programmatically</caption> <codepen>http://codepen.io/biodigital/pen/643226c9138ca64ebca9db497d8cd70d</codepen>
     * var sceneState;
     *
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var sceneIds = ["production/maleAdult/heart.json", "production/maleAdult/artery.json", "1FAM", "1FAQ"];
     * var i = 0;
     *
     * console.log("Loading scenes programmatically");
     *
     * (function loadScene() {
      *     console.log("Loading scene ID: " + sceneIds[i]);
      *
      *     human.send("scene.load", sceneIds[i], function() {
      *         i = (i + 1) % sceneIds.length;
      *
      *         setTimeout(loadScene, 5000);
      *     });
      * })();
     */
    Human.rpc.define("scene.load",
        function (params) {
            var self = this;

            var bookmarkId = null;
            var moduleId = null;

            if (typeof params === "string") {
                if (params.slice(-5) === ".json") {
                    moduleId = params;
                } else {
                    bookmarkId = params;
                }
            } else {
                moduleId = params.moduleId;
                bookmarkId = params.bookmarkId;
            }


            function _buildAssetObjects(moduleId){
              var module = Human.modules.modules[moduleId];
              var loadObjects = [];
              for (var objId in module.showObjects) {
                if (module.showObjects.hasOwnProperty(objId) &&
                  module.showObjects[objId] && !!Human.scene.objects[objId]) {
                  loadObjects.push(Human.scene.objects[objId]);
                }
              }
              return loadObjects;
            }

            // NOTE[EM] Deactivate/Unload/Destroy
            function unloadModule(activeModID) { // JSHint wants func out of loop
                Human.modules.deactivate(activeModID, function () {
                    var graphNodes = Human.modules.modules[activeModID].rootObjects;
                    Human.modules.unload(activeModID, graphNodes, ["tweens", "reflections", "lights", "geometry", "material", "transform", "morph"], function () {
                        Human.modules.destroy(activeModID);
                    });
                });
            }

            for (var activeModID in Human.modules.activeModules) {
                if (Human.modules.activeModules.hasOwnProperty(activeModID)) {
                    unloadModule(activeModID);
                }
            }


            if (bookmarkId) {
                jQuery.ajax({
                    dataType: "json",
                    url: "/search/bookmarks/data?be=" + bookmarkId,
                    success: function (index) {
                        Human.bookmarks.restore(index.bookmark, function() {
                            self.setResult(true);
                        });
                    },
                    error: function() {
                        self.setResult(false);
                    }
                });

            } else if (moduleId) {
                var typeSet1 = ["material","tweens","reflections","lights","geometry","transform"];
                var typeSet2 = ["morph"];
                var config = {
                    camera: true,
                    cameraCallback: function(){
                        var cid = Human.timeline.activeRoot._nowBranch.id;
                        Human.events.fire("chapter.camera.finished", {"chapterId":cid});
                    },
                    graph: true,
                    annotations: false,
                    properties: true,
                    time: false,
                    hotspots: false
                };

                // a little callback hell
                Human.modules.fetch(moduleId, function(){
                    var moduleData = Human.modules.moduleData[moduleId];
                    Human.modules.create(moduleId, moduleData, function(){
                        var loadObjects = _buildAssetObjects(moduleId);
                        Human.modules.activate(moduleId, 0, config, function(){
                            Human.modules.load(moduleId, loadObjects, typeSet1, function(){
                                var _time = 0;
                                if (moduleData.animation){
                                    _time = Human.timeline.parsePlayInstruction(moduleData.animation).t;
                                }
                                config.annotations = true;
                                config.graph = false;
                                Human.modules.activate(moduleId, _time, config, function(){
                                    Human.modules.load(moduleId, loadObjects, typeSet2, function(){

                                        if (moduleData.animation){
                                            Human.timeline.play(moduleData.animation);
                                        }
                                        Human.events.fire("module.ready", {moduleId: moduleId});

                                        if (Human.modules.activeModules.hasOwnProperty(moduleId)){
                                            self.setResult(true);
                                        } else {
                                            self.setResult(false);
                                        }
                                    });
                                });
                            });
                        });
                    });
                });

            }

        });

    /**
     * Get info about the 3D scene at a given canvas location. Optionally, trigger
     * actions associated with the current pick mode
     *
     * @apimethod human.send
     * @function pick
     * @memberof scene
     *
     * @fires scene.picked
     *
     * @param {object} params
     * @param {number} params.x - Canvas X-coordinate
     * @param {number} params.y - Canvas Y-coordinate
     * @param {booleans} [params.triggerActions=false] - Trigger pick actions
     * @param {scene.PickInfoCallback} callback
     *
     * @example <caption>Programmatic picking</caption> <codepen>http://codepen.io/biodigital/pen/32ebcd4698b19d9d059462ba2f52691e</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var iframe = document.getElementById("embeddedHuman");
     *
     * var w = iframe.clientWidth;
     * var h = iframe.clientHeight;
     *
     * setInterval(function () {
     *     var canvasX = Math.round(Math.random() * 300 - 150 + w / 2);
     *     var canvasY = Math.round(Math.random() * 300 - 150 + h / 2);
     *
     *     console.log("Try pick at " + canvasX + ", " + canvasY);
     *     human.send("scene.pick", { x: canvasX, y: canvasY },
     *         function (hit) {
     *             if (hit) {
     *                 console.log("Hit: " + JSON.stringify(hit));
     *             } else {
     *                 console.log("Miss");
     *             }
     *         });
     * }, 2000);
     */
    Human.rpc.define("scene.pick",
        function (params) {
            var result;

            if (params.x !== undefined) {
                params.canvasX = params.x;
            }

            if (params.y !== undefined) {
                params.canvasY = params.y;
            }

            params.rayPick = params.rayPick !== false;

            if (params.triggerActions) {
                result = Human.view.pick.pick(params);
            } else {
                result = Human.view.pick.queryPick(params);
            }
            this.setResult(getPickResult(result));
        });

    /**
     * Set action to be triggered when an object is picked
     *
     * @apimethod human.send
     * @function pickingMode
     * @memberof scene
     *
     * @param {string} mode - Picking mode: "dissect" removes picked objects,
     * "highlight" highlights picked objects, "annotate" annotates picked objects
     *
     * @example <caption>Picking mode</caption> <codepen>http://codepen.io/biodigital/pen/17ae01cc6c14533f48c18a7e26fa4e15</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Alternating between highlight and dissect picking modes");
     *
     * var mode = "highlight";
     *
     * (function switchMode() {
     *     human.send("scene.pickingMode", mode);
     *
     *     mode = mode === "highlight" ? "dissect" : "highlight";
     *
     *     setTimeout(switchMode, 4000);
     * })();
     *
     * human.on("scene.pickingModeUpdated", function(event) {
     *     console.log("Enabling " + event.pickingMode + " mode. Click to " + event.pickingMode + " an object");
     * });
     */
    Human.rpc.define("scene.pickingMode",
        function (mode) {
            if (mode === "dissect") {
                Human.events.blockEvents(function() {
                    Human.view.annotations.setEnabled(false);
                });
                Human.view.dissect.setEnabled(true);
            } else if (mode === "annotate") {
                Human.events.blockEvents(function() {
                    Human.view.dissect.setEnabled(false);
                });
                Human.view.annotations.setEnabled(true);
            } else if (mode === "highlight") {
                Human.events.blockEvents(function() {
                    Human.view.dissect.setEnabled(false);
                    Human.view.annotations.setEnabled(false);
                });
                Human.view.highlight.setEnabled(true);
            }

            this.setResult(true);
        });

    /**
     * Set behavior of selected objects
     *
     * @apimethod human.send
     * @function selectionMode
     * @memberof scene
     *
     * @fires scene.selectionModeUpdated
     *
     * @param {string} mode - Selection mode: "isolate" hides all unselected object,
     * "highlight" highlights selected objects, "none" does nothing
     *
     * @example <caption>Selection mode</caption> <codepen>http://codepen.io/biodigital/pen/6db6bbd189097f63aeec640a165e45ff</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Switch between highlight and isolate selection modes");
     *
     * // These commands will be buffered before Human is loaded
     * human.send("scene.selectObjects", {
     *     "maleAdult_standard-Left_Craniofacial_Bones_ID": true
     * });
     *
     * var mode = "highlight";
     * var select = true;
     *
     * (function switchMode() {
     *     human.send("scene.selectionMode", mode);
     *
     *     mode = mode === "highlight" ? "isolate" : "highlight";
     *
     *     setTimeout(switchMode, 6000);
     * })();
     *
     * (function toggleSelect() {
     *     console.log("Change selected object")
     *     human.send("scene.selectObjects", {
     *         "maleAdult_standard-Left_Craniofacial_Bones_ID": select,
     *         "maleAdult_standard-Right_Craniofacial_Bones_ID": !select
     *     });
     *
     *     select = !select;
     *
     *     setTimeout(toggleSelect, 2000);
     * })();
     *
     * human.on("scene.selectionModeUpdated", function(event) {
     *     console.log("Enabling " + event.selectionMode + " mode. Will " + event.selectionMode + " selected objects");
     * });
     */
    Human.rpc.define("scene.selectionMode",
        function (mode) {
            if (mode === "isolate") {
                Human.events.blockEvents(function() {
                    Human.view.highlight.setEnabled(false);
                });
                Human.view.isolate.setEnabled(true);
            } else if (mode === "highlight") {
                Human.events.blockEvents(function() {
                    Human.view.isolate.setEnabled(false);
                });
                Human.view.highlight.setEnabled(true);
            } else if (mode === "none") {
                Human.events.blockEvents(function() {
                    Human.view.isolate.setEnabled(false);
                });
                Human.view.highlight.setEnabled(false);
            }

            this.setResult(true);
        });

    /**
     * Enable xray mode (make all unselected objects transparent)
     *
     * @apimethod human.send
     * @function enableXray
     * @memberof scene
     *
     * @fires scene.xrayEnabled
     *
     * @param {function} [callback]
     */
    Human.rpc.define("scene.enableXray",
        function () {
            Human.view.xray.setEnabled(true);
            this.setResult(true);
        });

    /**
     * Disable xray mode (see {@link scene.enableXray})
     *
     * @apimethod human.send
     * @function disableXray
     * @memberof scene
     *
     * @fires scene.xrayDisabled
     *
     * @param {function} [callback]
     */
    Human.rpc.define("scene.disableXray",
        function () {
            Human.view.xray.setEnabled(false);
            this.setResult(true);
        });



    function fmaIdsToObjectIds(map) {
        var result = {};
        var objectsByFMA = Human.rpc.fmaIds;
        var objectIds;
        var maleStateId = Human.modules.MALE_STATE_ID;
        var femaleStateId = Human.modules.FEMALE_STATE_ID;
        for (var fmaId in map) {
            if (map.hasOwnProperty(fmaId)) {
                objectIds = objectsByFMA[fmaId];
                for (var i = 0; i < objectIds.length; i++) {
                    var object = Human.scene.objects[maleStateId + "-" + objectIds[i]] ||
                        Human.scene.objects[femaleStateId + "-" + objectIds[i]];
                    if (object) {
                        result[object.objectId] = map[fmaId];
                    }
                }
            }
        }
        return result;
    }

    /**
     * Show or hide objects in the scene
     *
     * @apimethod human.send
     * @function showObjects
     * @memberof scene
     *
     * @fires scene.objectsShown
     *
     * @param {object} selectionMap - Map of object IDs or FMA IDs to true to show, false to hide
     * @param {boolean} selectionMap.replace=false - Hide any objects not shown in the current map
     *
     * @example <caption>Show objects</caption> <codepen>http://codepen.io/biodigital/pen/9da13866ed038955dab0738236201bf4</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var show = true;
     *
     * console.log("Intermittent showing and hiding of scene objects");
     *
     * (function toggleShow() {
     *     human.send("scene.showObjects", {
     *         "maleAdult_standard-Left_Craniofacial_Bones_ID": show,
     *         "maleAdult_standard-Right_Craniofacial_Bones_ID": !show
     *     });
     *
     *     show = !show;
     *
     *     setTimeout(toggleShow, 3000);
     * })();
     *
     * human.on("scene.objectsShown", function(event) {
     *     var shown = [];
     *     var hidden = [];
     *
     *     // Event contains a map of objects that were shown
     *     // or hidden by this update.
     *     Object.keys(event).forEach(function(objectId) {
     *         if (event[objectId]) {
     *             shown.push(objectId);
     *         } else {
     *             hidden.push(objectId);
     *         }
     *     });
     *
     *     console.log("Shown objects: " + shown.join(", "));
     *     console.log("Hidden objects: " + hidden.join(", "));
     * });
     */
    Human.rpc.define("scene.showObjects",
        function (params) {
            var replace = !!params.replace;
            delete params.replace;

            if (params.fmaIds) {
                params = fmaIdsToObjectIds(params.fmaIds);
            }

            Human.scene.setEnabledObjects({ objects: params, replace: replace, fetchAssets: true });
            this.setResult(true);
        });

    /**
     * Select or deselect objects in the scene
     *
     * @apimethod human.send
     * @function selectObjects
     * @memberof scene
     *
     * @fires scene.objectsSelected
     *
     * @param {object} selectionMap - Map of object IDs or FMA IDs to true to select, false to deselect
     * @param {boolean} selectionMap.replace=false - Deselect any objects not selected in the current map
     *
     * @example <caption>Select object</caption> <codepen>http://codepen.io/biodigital/pen/905dc4a79f3a6102cf16f4d763763ee4</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var select = true;
     *
     * console.log("Intermittent switching of selected objects");
     *
     * (function toggleSelect() {
     *     human.send("scene.selectObjects", {
     *         "maleAdult_standard-Left_Craniofacial_Bones_ID": select,
     *         "maleAdult_standard-Right_Craniofacial_Bones_ID": !select
     *     });
     *
     *     select = !select;
     *
     *     setTimeout(toggleSelect, 3000);
     * })();
     *
     * human.on("scene.objectsSelected", function(event) {
     *     var selected = [];
     *     var deselected = [];
     *
     *     // Event contains a map of objects that were selected
     *     // or deselected by this update.
     *     Object.keys(event).forEach(function(objectId) {
     *         if (event[objectId]) {
     *             selected.push(objectId);
     *         } else {
     *             deselected.push(objectId);
     *         }
     *     });
     *
     *     console.log("Selected objects: " + selected.join(", "));
     *     console.log("Deslected objects: " + deselected.join(", "));
     * });
     */
    Human.rpc.define("scene.selectObjects",
        function (params) {
            var replace = !!params.replace;
            delete params.replace;

            if (params.fmaIds) {
                params = fmaIdsToObjectIds(params.fmaIds);
            }

            Human.scene.setSelectedObjects({ objects: params, replace: replace });
            this.setResult(true);
        });



    /**
     * @memberof scene
     * @callback SceneInfoCallback
     * @param {string} name - Name of the currently loaded scene
     * @param {object} objectMap - A map of object IDs to object info
     * @param {string} objectMap[].objectId
     * @param {string} objectMap[].name - Object name
     * @param {string} objectMap[].description - Object description
     * @param {boolean} objectMap[].shown - Is the object currently being shown?
     * @param {boolean} objectMap[].selected  - Is the object currently being shown?
     * @param {string} objectMap[].parent - parent objectId
     * @param {array} objectMap[].children - objectIds of children
     *
     */

    /**
     * Gather information about the objects in the scene
     *
     * @apimethod human.send
     * @function info
     * @memberof scene
     *
     * @param {scene.SceneInfoCallback} callback
     *
     * @example <caption>Scene info</caption> <codepen>http://codepen.io/biodigital/pen/499e3700dd02f7e134ce49e99b07b6f9</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.send("scene.info", function (data) {
     *     console.log(JSON.stringify(data));
     * });
     */
    (function () {
        Human.rpc.define("scene.info",
            function (params) {
                var result = {};

                var activeModule = Human.modules.activeModules[Object.keys(Human.modules.activeModules)[0]];

                result.name = activeModule ? activeModule.displayName : null;

                var scenegraph = result.objects = {};
                var object;
                if (params.objectId) {
                    var objectId = params.objectId;
                    object = Human.scene.objects[objectId];
                    if (object) {
                        scenegraph[object.objectId] = getObjectDescription(object);
                    }
                } else {
                    // Get parent objects before their children so that on the API side we
                    // will always create HumanAPI.Objects for the parents BEFORE those for
                    // their children, so that each child's HumanAPI.Object can be instantiated
                    // with a reference to its parent's HumanAPI.Object.
                    for (var i = 0, len = Human.scene.rootObjects.length; i < len; i++) {
                        buildHierarchy(Human.scene.rootObjects[i].getRenderableObjects(), scenegraph);
                    }

                }
                this.setResult(result);
            });

        function buildHierarchy(objects, result) {

            function gatherObject(o) {
                if (!result[o.objectId]) {
                    result[o.objectId] = getObjectDescription(o);
                }
            }

            for (var i = 0, len = objects.length; i < len; i++) {
                objects[i].traverseUp(gatherObject);
            }

        }

        function getObjectDescription(object) {
            var desc = {
                objectId: object.objectId,
                name: object.displayName || "",
                description: object.description || "",
                shown: object.shown,
                selected: object.selected
            };

            desc.children = [];

            for (var i = 0, len = object.objects.length; i < len; i++) {
                desc.children.push(object.objects[i].objectId);
            }

            desc.parent = object.parent ? object.parent.objectId : null;

            return desc;
        }
    })();


    /**
     * Transform object to new position or orientation
     *
     * @apimethod human.send
     * @function transformObject
     * @memberof scene
     *
     * @param {object} params
     * @param {string} params.objectId - ID of object to transform
     * @param {object} [params.translate] - Translation transform
     * @param {number} [params.translate.x] - Translation along x axis
     * @param {number} [params.translate.y] - Translation along y axis
     * @param {number} [params.translate.z] - Translation along z axis
     * @param {object} [params.rotate] - Rotation transform
     * @param {number} [params.rotate.x] - Rotation about x axis
     * @param {number} [params.rotate.y] - Rotation about y axis
     * @param {number} [params.rotate.z] - Rotation about z axis
     * @param {object} [params.scale] - Scaling transform
     * @param {number} [params.scale.x] - Scaling along x axis
     * @param {number} [params.scale.y] - Scaling along y axis
     * @param {number} [params.scale.z] - Scaling along z axis
     * @param {object} [params.pivot] - 3D origin point for the defined transform
     * @param {number} [params.pivot.x]
     * @param {number} [params.pivot.y]
     * @param {number} [params.pivot.z]
     *
     * @example <caption>Transform objects</caption> <codepen>http://codepen.io/biodigital/pen/5309a4a58e565315f25c18239b99f975</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var t = 0;
     * var inc = 0.01;
     *
     * console.log("Animating object position");
     *
     * (function animate() {
     *     t += inc;
     *
     *     if (t > 1) {
     *         t = 1;
     *         inc *= -1;
     *     }
     *
     *     if (t < 0) {
     *         t = 0;
     *         inc *= -1;
     *     }
     *
     *      human.send("scene.transformObject", {
     *         objectId: "maleAdult_standard-Frontal_bone_52734_ID",
     *         translate: {x: -8 * t, y: 2 * t, z: -8 * t},
     *         rotate: { y: t * 90 }
     *     });
     *
     *     requestAnimationFrame(animate);
     * })();
     */
    Human.rpc.define("scene.transformObject",
        function (params) {
            var objectId = params.objectId;
            var object = Human.scene.objects[objectId];
            if (object) {
                object.setTransform(params);
                this.setResult(true);
            } else {
                this.error("Scene object not found: '" + objectId + "'");
                this.setResult(false);
            }
        });

    /**
     * Modify object colors
     *
     * @apimethod human.send
     * @function colorObject
     * @memberof scene
     *
     * @param {object} params
     * @param {string} params.objectId - ID of object to transform
     * @param {array} [params.tintColor] - RGB triplet to tint the object with. RGB values can be between 0 and 1
     * @param {number} [params.saturation] - Saturation of object colors. Values between -1 and 1.
     * @param {number} [params.brightness] - Brightness of object colors. Values between -1 and 1.
     * @param {number} [params.contrast] - Contrast of object colors. Values between -1 and 1.
     *
     * @example <caption>Scene reset</caption>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.send("scene.colorObject", {
     *     tintColor: [1, 0, 0],
     *     brightness: 0.1,
     *     saturation: -0.5,
     *     contrast: 0.5,
     * });
     */
    Human.rpc.define("scene.colorObject",
        function (params) {
            var objectId = params.objectId;
            var object = Human.scene.objects[objectId];
            if (object) {
                if (params.tintColor !== undefined) {
                    object.setTintColor(params.tintColor[0], params.tintColor[1], params.tintColor[2]);
                }
                if (params.saturation !== undefined) {
                    object.setSaturation(params.saturation);
                }
                if (params.brightness !== undefined) {
                    object.setBrightness(params.brightness);
                }
                if (params.contrast !== undefined) {
                    object.setContrast(params.contrast);
                }
                this.setResult(true);
            } else {
                this.error("Scene object not found: '" + objectId + "'");
                this.setResult(false);
            }
        });



    /**
     * @memberof scene
     * @callback SceneCaptureCallback
     * @param {object} sceneState - Captured scene state. Can be passed to {@link scene.restore}
     *
     */

    /**
     * Captures the current scene state
     *
     * @apimethod human.send
     * @function capture
     * @memberof scene
     *
     * @param {scene.SceneCaptureCallback} callback
     *
     * @example <caption>Scene capture and restore</caption> <codepen>http://codepen.io/biodigital/pen/baa38aa7bf10fc98ceb8c33ff075a6de</codepen>
     * var sceneState;
     *
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *
     *     console.log("Highlighting objects");
     *
     *     human.send("scene.selectObjects", {
     *         "maleAdult_standard-Right_Craniofacial_Bones_ID": true
     *     });
     *
     *     console.log("Setting camera");
     *
     *     human.send("camera.set", {
     *         position: {
     *             x: 20,
     *             y: 40,
     *             z: 0
     *         }
     *     }, function() {
     *         console.log("Capturing scene state");
     *
     *         // Capturing the scene state provides a JavaScript object
     *         // containing the data necessary to recreate the scene.
     *         // This object can be passed to "scene.restore" to re-create
     *         // the scene.
     *         human.send("scene.capture",
     *             function (scene) {
     *                 sceneState = scene;
     *             });
     *
     *         console.log("Resetting scene in 2s")
     *         setTimeout(function() {
     *             human.send("scene.reset");
     *
     *             console.log("Restoring scene state in 2s");
     *             setTimeout(function() {
     *
     *                 // Here, we pass the scene state object that
     *                 // was captured by "scene.capture" to "scene.restore"
     *                 // so it can restore the scene to the captured state.
     *                 human.send("scene.restore", sceneState);
     *
     *             }, 2000);
     *         }, 2000);
     *     });
     *
     * });
     *
     * // Fired whenever scene is restored to a captured state
     * human.on("scene.restored", function() {
     *     console.log("Scene restored!");
     * });
     */
    Human.rpc.define("scene.capture",
        function () {
            this.setResult(Human.bookmarks.capture());
        });

    /**
     * Restores scene state from description captured by {@link scene.capture}
     *
     * @apimethod human.send
     * @function restore
     * @memberof scene
     *
     * @fires scene.restored
     *
     * @param {object} sceneState - Scene state captured from {@link scene.capture}
     * @param {function} [callback]
     */
    Human.rpc.define("scene.restore",
        function (params) {
            var self = this;
            Human.bookmarks.restore(params, function () {
                self.setResult(true);
            });
        });

    /**
     * Reset the scene to its original state
     *
     * @apimethod human.send
     * @function reset
     * @memberof scene
     *
     * @param {function} [callback]
     *
     * @example <caption>Scene reset</caption> <codepen>http://codepen.io/biodigital/pen/401be856566cbf4824656102e666c213</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Setting camera")
     * human.send("camera.set", {
     *     position: {
     *         x: 20,
     *         y: 40,
     *         z: 0
     *     }
     * }, function() {
     *     console.log("Scene reset in 2s");
     *     setTimeout(function() {
     *         human.send("scene.reset");
     *     }, 2000);
     * });
     */
    Human.rpc.define("scene.reset",
        function () {
            var self = this;
            Human.init.reset(function () {
                self.setResult(true);
            });
        });

    // Events

    /**
     * @event scene.objectsShown
     * @apimethod human.on
     * @memberof scene
     * @property {object} event - Map listing object IDs and whether they were shown or hidden
     */
    Human.rpc.defineEvent("scene.objectsShown", {
        events: ["scene.objectsShown"],
        map: function(event) {
            return event.enabledObjectsUpdate;
        }
    });

    /**
     * @event scene.objectsSelected
     * @apimethod human.on
     * @memberof scene
     * @property {object} event - Map listing object IDs and whether they were selected or deselected
     */
    Human.rpc.defineEvent("scene.objectsSelected", {
        events: ["scene.objectsSelected"],
        map: function(event) {
            return event.selectedObjectsUpdate;
        }
    });

    /**
     * @event scene.restored
     * @apimethod human.on
     * @memberof scene
     * @property {object} event - Scene state captured by {@link scene.capture}
     */
    Human.rpc.defineEvent("scene.restored", "bookmarks.restored");

    /**
     * @event scene.picked
     * @apimethod human.on
     * @memberof scene
     * @property {object} event
     * @property {string} event.objectId - ID of the object that was picked
     * @property {string} event.mode - The mode of the pick event
     * @property {object} event.canvasPosition - 2D coordinates of the pick location on the canvas
     * @property {number} event.canvasPosition.x
     * @property {number} event.canvasPosition.y
     * @property {object} event.position - 3D coordinates of the pick location in the scene
     * @property {number} event.position.x
     * @property {number} event.position.y
     * @property {number} event.position.z
     *
     * @example <caption>Pick event</caption> <codepen>http://codepen.io/biodigital/pen/4f2da0e54e201754a0c0d9ef11d5a1cb</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * console.log("Pick or hover over something!");
     * human.on("scene.picked",
     *     function (pickEvent) {
     *         console.log("'scene.picked' event: " + JSON.stringify(pickEvent));
     * });
     */
    Human.rpc.defineEvent("scene.picked", {
        events: ["pick.picked"],
        init: function() {
            // API expects to always get raypick results
            Human.properties.set({ "pick.alwaysRayPick": true });
        },
        map: getPickResult
    });

    /**
     * @event scene.pickingModeUpdated
     * @apimethod human.on
     * @memberof scene
     * @property {object} event
     * @property {string} event.pickingMode
     */
    var pickingMode;

    Human.rpc.defineEvent("scene.pickingModeUpdated", {
        events: ["highlight.toggled", "dissect.toggled", "annotations.toggled"],
        map: function () {
            var newPickingMode;

            if (Human.view.dissect.enabled) {
                newPickingMode = "dissect";
            } else if (Human.view.annotations.enabled) {
                newPickingMode = "annotate";
            } else if (Human.view.highlight.enabled) {
                newPickingMode = "highlight";
            }

            if (newPickingMode === pickingMode) {
                return null;
            }

            pickingMode = newPickingMode;

            return {
                pickingMode: pickingMode
            };
        }
    });

    /**
     * @event scene.selectionModeUpdated
     * @apimethod human.on
     * @memberof scene
     * @property {object} event
     * @property {string} event.selectionMode
     */
    var selectionMode;

    Human.rpc.defineEvent("scene.selectionModeUpdated", {
        events: ["highlight.toggled", "isolate.toggled"],
        map: function () {
            var newSelectionMode;

            if (Human.view.isolate.enabled) {
                newSelectionMode = "isolate";
            } else if (Human.view.highlight.enabled) {
                newSelectionMode = "highlight";
            } else {
                newSelectionMode = "none";
            }

            if (newSelectionMode === selectionMode) {
                return null;
            }

            selectionMode = newSelectionMode;

            return {
                selectionMode: selectionMode
            };
        }
    });

    /**
     * @event scene.xrayEnabled
     * @apimethod human.on
     * @memberof scene
     *
     * @example <caption>Enable xray</caption> <codepen>http://codepen.io/biodigital/pen/fe721c86655e2dfab0480670cdc63383</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var enable = true;
     *
     * human.on("scene.xrayEnabled", function() {
     *     console.log("Xray mode enabled");
     * });
     *
     * human.on("scene.xrayDisabled", function() {
     *     console.log("Xray mode disabled");
     * });
     *
     * human.on("human.ready", toggleXray);
     *
     * function toggleXray() {
     *     human.send(enable ? "scene.enableXray" : "scene.disableXray");
     *
     *     enable = !enable;
     *
     *     setTimeout(toggleXray, 3000);
     * }
     */
    Human.rpc.defineEvent("scene.xrayEnabled", {
        events: ["xray.toggled"],
        map: function(event) {
            if (!event.enabled) {
                return null;
            }
        }
    });

    /**
     * @event scene.xrayDisabled
     * @apimethod human.on
     * @memberof scene
     *
     * @example <caption>Enable xray</caption> <codepen>http://codepen.io/biodigital/pen/fe721c86655e2dfab0480670cdc63383</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * var enable = true;
     *
     * human.on("scene.xrayEnabled", function() {
     *     console.log("Xray mode enabled");
     * });
     *
     * human.on("scene.xrayDisabled", function() {
     *     console.log("Xray mode disabled");
     * });
     *
     * human.on("human.ready", toggleXray);
     *
     * function toggleXray() {
     *     human.send(enable ? "scene.enableXray" : "scene.disableXray");
     *
     *     enable = !enable;
     *
     *     setTimeout(toggleXray, 3000);
     * }
     */
    Human.rpc.defineEvent("scene.xrayDisabled", {
        events: ["xray.toggled"],
        map: function(event) {
            if (event.enabled) {
                return null;
            }
        }
    });

    function getPickResult(hit) {
        if (!hit) {
            return null;
        }

        var result = {};

        result.objectId = hit.objectId;
        result.canvasPosition = {
            x: hit.canvasPos[0],
            y: hit.canvasPos[1]
        };

        if (hit.worldPos) {
            result.position = {
                x: hit.worldPos[0],
                y: hit.worldPos[1],
                z: hit.worldPos[2]
            };
        }

        result.mode = hit.mode;

        return result;
    }


})();
;/**
 * The timeline is in charge of animation and tours in the Human. Timeline messages allow you
 * to fast-forward or rewind animations, or to jump back or ahead in the chapters of a tour.
 *
 * @namespace timeline
 */

(function() {
    "use strict";

    /**
     * @memberof timeline
     * @callback TimelineInfoCallback
     * @param {object} timeline
     * @param {array} timeline.chapters - IDs of the chapters currently on the timeline
     * @param {number} timeline.time - Current time on the timeline
     * @param {number} timeline.startTime - Starting time of the timeline
     * @param {number} timeline.endTime - Ending time of the timeline
     * @param {boolean} timeline.playing - Is the timeline currently playin?
     */

    /**
     * Gather information about the timeline
     *
     * @apimethod human.send
     * @function info
     * @memberof timeline
     *
     * @param {timeline.TimelineInfoCallback} callback
     *
     * @example <caption>Get timeline info</caption> <codepen>http://codepen.io/biodigital/pen/8698a3446b0ff14dd367063736158bd6</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.send("timeline.info", function(timeline) {
     *     console.log("Gathering timeline info:");
     *     console.log(JSON.stringify(timeline));
     * });
     */
    Human.rpc.define("timeline.info",
        function () {
            this.setResult(getTimelineResult());
        });

    /**
     * Jump to a given point on the timeline
     *
     * @apimethod human.send
     * @function set
     * @memberof timeline
     *
     * @param {object} params
     * @param {number} [params.time] - Jump to the specified time
     * @param {string} [params.chapterId] - Jump to the specified chapter
     *
     * @example <caption>Setting the timeline</caption> <codepen>http://codepen.io/biodigital/pen/68045d3795f8c7bc7d62c16753ac9ac8</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *
     *     human.send("timeline.pause");
     *
     *     var currentTime = 0;
     *
     *     setInterval(function() {
     *
     *         currentTime += 0.3;
     *
     *         if (currentTime > 1) {
     *             currentTime = 0;
     *         }
     *
     *         console.log("Setting timeline to: " + currentTime.toFixed(1) + "s");
     *         human.send("timeline.set", { time: currentTime });
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.set",
        function (params) {
            if (params.hasOwnProperty("chapterId")){
              params.chapterId = normalizeChapterId(params.chapterId);
            }

            Human.timeline.scrub(params);
            this.setResult(true);
        });

    /**
     * Play the timeline
     *
     * @apimethod human.send
     * @function play
     * @memberof timeline
     *
     * @param {object} [params]
     * @param {number} [params.time] - Start at the specified time
     * @param {string} [params.chapterId] - Start at the specified chapter
     * @param {boolean} [params.loop=false] - Loop back to beginning when end of timeline is reached
     *
     * @example <caption>Pause/play timeline</caption> <codepen>http://codepen.io/biodigital/pen/93f7a9c1b7167553ca88d1a18b0501c0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *     var playing = true;
     *
     *     setInterval(function() {
     *         playing = !playing;
     *
     *         if (playing) {
     *             console.log("Playing timeline")
     *             human.send("timeline.play", { loop: true });
     *         } else {
     *             console.log("Pausing timeline")
     *             human.send("timeline.pause");
     *         }
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.play",
        function (params) {

            if (params.hasOwnProperty("chapterId")){
              params.chapterId = normalizeChapterId(params.chapterId);
            }


            if (params.time) {
                params.startTime = params.time;
            }

            if (params.chapterId) {
                params.startChapterId = params.chapterId;
            }

            Human.timeline.play(params);
            this.setResult(true);
        });

    /**
     * Pause the timeline
     *
     * @apimethod human.send
     * @function pause
     * @memberof timeline
     *
     * @example <caption>Pause/play timeline</caption> <codepen>http://codepen.io/biodigital/pen/93f7a9c1b7167553ca88d1a18b0501c0</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *     var playing = true;
     *
     *     setInterval(function() {
     *         playing = !playing;
     *
     *         if (playing) {
     *             console.log("Playing timeline")
     *             human.send("timeline.play", { loop: true });
     *         } else {
     *             console.log("Pausing timeline")
     *             human.send("timeline.pause");
     *         }
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.pause",
        function () {
            Human.timeline.pause();
            this.setResult(true);
        });

    /**
     * Jump back to the previous chapter on the timeline
     *
     * @apimethod human.send
     * @function previousChapter
     * @memberof timeline
     *
     * @example <caption>Navigating chapters</caption> <codepen>http://codepen.io/biodigital/pen/290cd16a6df9c1a0387d16e6ce2f60db</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *     var count = 0;
     *     var step = 1;
     *     var next = true;
     *
     *     setInterval(function() {
     *
     *         if (next) {
     *             console.log("Next chapter")
     *             human.send("timeline.nextChapter");
     *         } else {
     *             console.log("Previous chapter")
     *             human.send("timeline.previousChapter");
     *         }
     *
     *         count += step;
     *
     *         if (count >= 3 || count <= 0) {
     *             next = !next;
     *             step *= -1;
     *         }
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.previousChapter",
        function () {
            Human.timeline.prev();
            this.setResult(true);
        });

    /**
     * Jump ahead to the next chapter on the timeline
     *
     * @apimethod human.send
     * @function nextChapter
     * @memberof timeline
     *
     * @example <caption>Navigating chapters</caption> <codepen>http://codepen.io/biodigital/pen/290cd16a6df9c1a0387d16e6ce2f60db</codepen>
     * // Initialize API
     * var human = new HumanAPI("embeddedHuman");
     *
     * human.on("human.ready", function() {
     *     var count = 0;
     *     var step = 1;
     *     var next = true;
     *
     *     setInterval(function() {
     *
     *         if (next) {
     *             console.log("Next chapter")
     *             human.send("timeline.nextChapter");
     *         } else {
     *             console.log("Previous chapter")
     *             human.send("timeline.previousChapter");
     *         }
     *
     *         count += step;
     *
     *         if (count >= 3 || count <= 0) {
     *             next = !next;
     *             step *= -1;
     *         }
     *
     *     }, 2000);
     * });
     */
    Human.rpc.define("timeline.nextChapter",
        function () {
            Human.timeline.next();
            this.setResult(true);
        });

    /**
     * @event timeline.chapterTransition
     * @apimethod human.on
     * @memberof timeline
     * @property {object} event
     * @property {number} event.previousChapter - Number of the chapter that was previously playing
     * @property {number} event.currentChapter - Number of the chapter that was just entered
     * @property {number} event.time - Current time on the timeline
     */
    Human.rpc.defineEvent("timeline.chapterTransition", {
        events: ["timeline.chapters.activated"],
        map: function(event) {
            return {
                previousChapter: event.oldChapterIndex,
                currentChapter: event.newChapterIndex,
                time: event.time
            };
        }
    });

    function getTimelineResult() {
        var timeframe = Human.timeline.getTimeFrame();

        return {
            time: Human.timeline.time,
            startTime: timeframe.firstTime,
            endTime: timeframe.lastTime,
            chapters: Object.keys(Human.timeline.chapters),
            playing: Human.timeline.playing
        };
    }

    function normalizeChapterId(chapterId){
      /* Engines 7 to 9.X used to id chapters as <moduleID><index>
         Engine 10.X now ids chapters as <moduleID>_<index>
      */
      var parts = chapterId.split(".json");
      if (parts.length === 2 && !parts[1].startsWith("_") ) {
        return parts[0] + ".json_" + parts[1];
      } else {
        return chapterId;
      }
    }

})();
;Human.rpc.hideDefinitions(function() {
    "use strict";

    /** Captures a bookmark of current Human state, returns it as JSON
     *
     */
    Human.rpc.define("bookmarks.capture",
        function () {
            this.setResult(Human.bookmarks.capture());
        });

    /** Restores Human state from given bookmark JSON
     */
    Human.rpc.define("bookmarks.restore",
        function (params) {
            var self = this;
            Human.bookmarks.restore(params, function () {
                self.setResult(true);
            });
        });

    /**
     * Unsubscribes from an engine event
     */
    Human.rpc.define("events.off",
        function (params) {
            if (params.id) {
                // Undo specific subscription
                unbindEvent(params.id);
            } else if (params.ids) {
                // Undo list of subscriptions
                var ids = params.ids;
                for (var i = 0, len = ids.length; i < len; i++) {
                    unbindEvent(ids[i]);
                }
            } else {
                // Undo all subscriptions
                for (var id in callbacks) {
                    if (callbacks.hasOwnProperty(id)) {
                        unbindEvent(id);
                    }
                }
            }
        });

    /**
     * Queries the current state of the timeline - chapters, time and play/pause state.
     */
    Human.rpc.define("timeline.query",
        function () {
            this.setResult(Human.timeline.query());
        });

    Human.rpc.define("camera.query", function () {
        var camera = Human.view.camera.getLookAt();
        camera.zoom = Human.view.camera.getZoom();

        this.setResult(camera);
    });

    Human.rpc.define("properties.query",
        function (params) {
            this.setResult(Human.properties.query(params.regex));
        });

    Human.rpc.define("actions.doAction",
        function (params) {
            Human.actions._doAction([params.action, params.arguments]);
        });

    Human.rpc.define("alert",
        function (params) {
            window.alert(params.message || "");
        });

    Human.rpc.define("videos.getClips",
        function () {
            this.setResult(Human.media.videos.clipsList);
        });

    Human.rpc.define("videos.open",
        function (params) {
            var self = this;
            Human.media.videos.open(params.clipId,
                function () {
                    self.setResult(true); // Opened
                });
        });

    Human.rpc.define("videos.play",
        function (params) {
            Human.media.videos.play(params.clipId);
        });

    Human.rpc.define("videos.scrub",
        function (params) {
            Human.media.videos.scrub(params.clipId, params.time);
        });

    Human.rpc.define("videos.pause",
        function (params) {
            Human.media.videos.pause(params.clipId);
        });

    Human.rpc.define("videos.stop",
        function (params) {
            Human.media.videos.stop(params.clipId);
        });

    Human.rpc.define("videos.close",
        function (params) {
            Human.media.videos.close(params.clipId);
        });

    Human.rpc.define("audio.getClips",
        function () {
            this.setResult(Human.media.audio.clipsList);
        });

    Human.rpc.define("audio.open",
        function (params) {
            var self = this;
            Human.media.audio.open(params.clipId,
                function () {
                    self.setResult(true); // Opened
                });
        });

    Human.rpc.define("audio.play",
        function (params) {
            Human.media.audio.play(params.clipId);
        });

    Human.rpc.define("audio.scrub",
        function (params) {
            Human.media.audio.scrub(params.clipId, params.time);
        });

    Human.rpc.define("audio.pause",
        function (params) {
            Human.media.audio.pause(params.clipId);
        });

    Human.rpc.define("audio.stop",
        function (params) {
            Human.media.audio.stop(params.clipId);
        });

    Human.rpc.define("audio.close",
        function (params) {
            Human.media.videos.close(params.clipId);
        });

    Human.rpc.define("modules.getModules",
        function (params) {
            this.setResult(Human.modules.query(params));
        });

    Human.rpc.define("modules.activate",
        function (params) {
            var self = this;
            Human.modules.activateModules(params,
                function () {
                    self.setResult(true); // Activated
                });
        });

    Human.rpc.define("modules.deactivate",
        function (params) {
            Human.modules.deactivateModules(params);
        });

    Human.rpc.define("properties.subscribe",
        function (params) {
            var self = this;
            Human.properties.subscribe({
                subId: params.subId,
                propId: "myProperty",
                callback: function (value) {
                    self.setResult(value);
                }
            });
        });

    Human.rpc.define("properties.resubscribe",
        function (params) {
            Human.properties.resubscribe(params.subId, params.propId);
        });

    Human.rpc.define("properties.unsubscribe",
        function (params) {
            Human.properties.unsubscribe(params.subId);
        });

    Human.rpc.define("renderer.getBGColor", function () {
        this.setResult(Human.renderer.bg.getBGColor());
    });

    Human.rpc.define("renderer.setBGColor", function (params) {
        Human.renderer.bg.setBGColor(params.color);
    });

    Human.rpc.define("request.getParams",
        function () {
            this.setResult({
                hashParams: Human.request.getHashParams(),
                hashStr: Human.request.getHashStr(),
                searchParams: Human.request.getSearchParams(),
                searchStr: Human.request.getSearchStr()
            });
        });

    Human.rpc.define("scene.queryBoundary",
        function (params) {
            var boundary, object, fmaId;
            if (params.objectId) {

                // Get boundary of object by ID
                boundary = Human.scene.getBoundary({ objectId: params.objectId });

            } else if (params.fmaId) {

                // get boundary of object by FMA ID
                fmaId = params.fmaId;
                object = Human.scene.objectsByFMAID[fmaId];
                if (!object) {
                    this.error("No scene object found for the given FMA ID: '" + fmaId + "'");
                    return;
                }
                boundary = object.getBoundary();

            } else if (params.objectIds) {

                // Get collective boundary of multiple objects by IDs
                boundary = Human.scene.getBoundary({ objectIds: params.objectIds });

            } else if (params.fmaIds) {

                // Get collective boundary of multiple objects by FMA IDs
                var fmaIds = params.fmaIds;
                var objectIds = [];
                for (var i = 0, len = fmaIds.length; i < len; i++) {
                    fmaId = fmaIds[i];
                    object = Human.scene.objectsByFMAID[fmaId];
                    if (!object) {
                        this.error("No scene object found for the given FMA ID: '" + fmaId + "'");
                        return;
                    }
                    objectIds.push(object.objectId);
                }
                boundary = Human.scene.getBoundary({ objectIds: objectIds });

            } else if (params.selectedObjects) {

                // Get collective boundary of all currently selected objects
                boundary = Human.scene.getBoundary({ objects: Human.scene.selectedObjects });
            } else if (params.enabledObjects) {

                // Get collective boundary of all currently visible objects
                boundary = Human.scene.getBoundary({ objects: Human.scene.enabledObjects });
            } else {

                // Default: get boundary of all objects
                boundary = Human.scene.getBoundary();
            }
            this.setResult(boundary);
        });


    function fmaIdsToObjectIds(map) {
        var result = {};
        var objectsByFMA = Human.rpc.fmaIds;
        var objectIds;
        var maleStateId = Human.modules.MALE_STATE_ID;
        var femaleStateId = Human.modules.FEMALE_STATE_ID;
        for (var fmaId in map) {
            if (map.hasOwnProperty(fmaId)) {
                objectIds = objectsByFMA[fmaId];
                for (var i = 0; i < objectIds.length; i++) {
                    var object = Human.scene.objects[maleStateId + "-" + objectIds[i]] ||
                        Human.scene.objects[femaleStateId + "-" + objectIds[i]];
                    if (object) {
                        result[object.objectId] = map[fmaId];
                    }
                }
            }
        }
        return result;
    }

    Human.rpc.define("scene.showBoundary",
        function (params) {
            var boundary;
            if (params.objectId) {
                boundary = Human.scene.getBoundary({ objectId: params.objectId });
                if (boundary) {
                    Human.view.boundary.setBoundary(boundary, true);
                }
            } else {
                Human.view.boundary.setBoundary(false);
            }
        });

    (function () {
        var canvas = document.getElementById('theCanvas');

        var getCanvasPos = function (worldPos, offset) {
            if(offset) {
                vec3.add(worldPos, offset, worldPos);
            }

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();
            var projPos = vec4.create();

            vec3.transformMat4(projPos, worldPos, viewMat);
            projPos[3]  = 1; // Need homogeneous 'w' for perspective division
            vec4.transformMat4(projPos, projPos, projMat);

            var x = projPos[0];
            var y = projPos[1];
            var w = projPos[3];

            return [
                Math.round((1 + x / w) * canvas.width  / 2),
                Math.round((1 - y / w) * canvas.height / 2)
            ];
        };

        Human.rpc.define("scene.getCanvasPos",
            function (params) {
                this.setResult(getCanvasPos(params.worldPos, params.offset));
            });

        Human.rpc.define("scene.getObjectCanvasPos",
            function (params) {
               var object = Human.scene.objects[params.objectId];

               if(object) {
                   var worldPos = object.getCenter();
                   this.setResult(getCanvasPos(worldPos, params.offset));
               }
            });
    })();

    Human.rpc.define("annotations.setTitle", function (params) {
        var annotation = Human.view.annotations.annotations[params.annotationId];
        if (annotation) {
            annotation.label.setTitle(params.title);
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.setDescription", function (params) {
        var annotation = Human.view.annotations.annotations[params.annotationId];
        if (annotation) {
            annotation.label.setDescription(params.description);
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.setLabelStyles", function (styles) {
        if (styles.label) {
            $('.annotationContainer').css(styles.label);
        }

        if (styles.title) {
            $('.annotationContainer > .title').css(styles.title);
        }

        if (styles.description) {
            $('.annotationContainer > .description').css(styles.description);
        }

        Human.view.annotations.updateDimensions(); //updates width property
        Human.view.annotations.layouts.redrawLayout(); //redraws positions
        this.setResult(true);
    });

    Human.rpc.define("annotations.setPinStyles", function (styles) {
        if (styles.hasOwnProperty('pin')) {
            $('.annotationPin').css(styles.pin);

            if (styles.hasOwnProperty('after')) {
                //can't access :after pseudo element via js, so approximating...
                $('.annotationPin').html('<div class="after"></div>');
                $('.annotationPin > .after').css(styles.after);
            }
        } else {
            $('.annotationPin').css(styles);
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.setWireStyles", function (styles) {
        $('.annotationWire').css(styles);
        this.setResult(true);
    });

    //
    // Opens or closes annotations, either per their IDs and/or the IDs of their scene objects.
    //
    Human.rpc.define("annotations.setLabelsShown", function (params) {
        Human.view.annotations.setLabelsShown(params);
        this.setResult(true);
    });

        // Captures bookmark of timeline playing state
    Human.rpc.define("timeline.getBookmark",
        function () {
            this.setResult(Human.timeline.getBookmark());
        });

    // Restores playing state of timeline to given bookmark
    Human.rpc.define("timeline.setBookmark",
        function (params) {
            Human.timeline.setBookmark(params);
        });

     Human.rpc.define("clip.set",
        function (params) {
            if (params.clips) {
                var clips = params.clips;
                var clip;
                for (var clipId in clips) {
                    if (clips.hasOwnProperty(clipId)) {
                        clip = clips[clipId];
                        clip.clipId = clipId;
                        Human.view.clip.setClip(clip);
                    }
                }
            } else if (params.clip) {
                Human.view.clip.setClip(params.clip);
            }
        });

    Human.rpc.define("clip.reset",
        function () {
            Human.view.clip.reset();
        });

        /**
     * Queries what effects exist
     */
    Human.rpc.define("effects.getEffects",
        function () {
            var result = [];
            var effect;
            var effects = Human.view.effects.effects;
            for (var effectId in effects) {
                if (effects.hasOwnProperty(effectId)) {
                    effect = effects[effectId];
                    result.push({
                        effectId: effectId,
                        displayName: effect.displayName,
                        description: effect.description,
                        enabled: effect.enabled,
                        params: effect.params
                    });
                }
            }
            this.setResult(result);
        });

    /**
     * Enables or disables effects
     */
    Human.rpc.define("effects.setEnabled",
        function (params) {
            Human.view.effects.setEnabled(params);
        });

    /**
     * Sets parameters for effects
     */
    Human.rpc.define("effects.setParams",
        function (params) {
            Human.view.effects.setParams(params);
        });

    
    Human.rpc.define("focus.focusObject",
        function (params) {
            var self = this;

            var ok = function() {
                self.setResult(true);
            };

           var fmaId = params.fmaId;
           var objectId = params.objectId;
           var objectIds = params.objectIds;

           if (!objectId && !fmaId && !objectIds) {

               // Missing params

               Human.log.error("Human.view.focusObject", "Parameter expected: either 'objectId', 'objectIds' or 'fmaId'");
               ok();
               return;
           }

           var scene = Human.scene;

           var object;

           if (objectId) {

               // Focus on object by ID

               object = scene.objects[objectId];

               if (!object) {
                   Human.log.error("Human.view.focusObject", "Scene object not found: '" + objectId + "'");
                   ok();
                   return;
               }

           } else if (fmaId) {

               // Focus on object by FMA ID

               object = scene.objectsByFMAID[fmaId];

               if (!object) {
                   Human.log.error("Human.view.focusObject", "Scene object not found for this FMAID: '" + fmaId + "'");
                   ok();
                   return;
               }

               objectId = object.objectId;
           }

           if (params.xray === true) {

               // X-Ray mode

               Human.rpc.call(null, "xray.setEnabled", { enable: true });

           } else if (params.xray === false) {

               // No X-Ray

               Human.rpc.call(null, "xray.setEnabled", { enable: false });
           }

           var select = params.select;

           if (select === undefined || select === null) {
               select = params.replace || !scene.selectedObjects[objectId];
           } else {
               select = params.select;
           }

           var flyTo = params.flyTo;
           var boundary;

           if (params.replace) {    // Single focus

               scene.setSelectedObjects({
                   objectId: objectId,
                   select: select,
                   replace: params.replace
               });

           } else if (select) {   // Multi focus

               var objects = {};

               objects[objectId] = select;

               scene.setSelectedObjects({
                   objects: objects,
                   replace: params.replace
               });
           }

           if ((params.showLabel !== false) || !select) {
               Human.view.labels._clearLabels();
           }

           if (params.showLabel !== false) {
                Human.view.labels.createLabel({ objectId: params.objectId, afterDelay: true });
                Human.renderer.forceRenderFrame();
           }

           if (select && flyTo === "newSelected") {

               // Get boundary enclosing newly selected objects

               boundary = object.getBoundary();
               if (boundary) {
                   Human.view.boundary.setBoundary(boundary, true);     // Show selected object boundary
                   Human.view.camera.fly.flyTo({                               // Fly to selected object
                           boundary: boundary,
                           backOff: params.backOff,
                           arc: 0.0
                       },
                       function () {
                           Human.view.boundary.setBoundary(false);      // Hide boundary
                           ok();
                       });
               }

           } else if (!flyTo || flyTo === "allSelected") {

               // Get boundary enclosing currently selected objects

               boundary = scene.getBoundary({ objects: scene.selectedObjects });
               if (boundary) {
                   Human.view.boundary.setBoundary(boundary, true);     // Show selected object boundary
                   Human.view.camera.fly.flyTo({                               // Fly to selected object
                           boundary: boundary,
                           backOff: params.backOff,
                           arc: 0.0
                       },
                       function () {
                           Human.view.boundary.setBoundary(false);      // Hide boundary
                           ok();
                       });
               } else {

                   Human.view.boundary.setBoundary(false);      // Hide boundary
                   ok();
               }

           } else if (flyTo === "selectedLeafObjects") {

               // Fly to leaf objects from among those objects that are currently selected
               
               Human.view.camera.fly.flyTo({                        // Fly to selected object
                       selectedLeafObjects: true,
                       backOff: params.backOff,
                       arc: 0.0
                   },
                   function () {
                       Human.view.boundary.setBoundary(false);      // Hide boundary
                       ok();
                   });

           } else if (flyTo === "object") {

               boundary = object.getBoundary();

               Human.view.boundary.setBoundary(boundary, true);     // Show selected object boundary

               Human.view.camera.fly.flyTo({                               // Fly to selected object
                       boundary: boundary,
                       backOff: params.backOff,
                       arc: 0.0
                   },
                   function () {
                       Human.view.boundary.setBoundary(false);      // Hide boundary
                       ok();
                   });
           } else {
               ok();
           }
        });

    Human.rpc.define("labels.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.labels.getEnabled();
            }
            Human.view.labels.setEnabled(enable);
        });

    Human.rpc.define("labels.create",
        function (params) {
            if (!params.objectId) {
                this.error("parameter expected: 'objectId'");
                return;
            }
            if (params.replace) {
                Human.view.labels.clearLabels();
            }
            Human.view.labels.createLabel(params);
        });

    Human.rpc.define("labels.clear",
        function () {
            Human.view.labels.clearLabels();
        });

    /**
     * Queries what lights exist
     */
    Human.rpc.define("lights.getLights",
        function () {
            var result = [];
            var light;
            var lights = Human.view.lights.lights;
            for (var lightId in lights) {
                if (lights.hasOwnProperty(lightId)) {
                    light = lights[lightId];
                    result.push({
                        lightId: lightId,
                        displayName: light.displayName,
                        description: light.description,
                        enabled: light.enabled,
                        params: light.params
                    });
                }
            }
            this.setResult(result);
        });

    /**
     * Enables or disables lights
     */
    Human.rpc.define("lights.setEnabled",
        function (params) {
            Human.view.lights.setEnabled(params);
        });

    /**
     * Sets parameters for lights
     */
    Human.rpc.define("lights.setParams",
        function (params) {
            Human.view.lights.setParams(params);
        });

    Human.rpc.define("tooltips.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {   // Toggle by default
                enable = !Human.view.tooltips.getEnabled();
            }
            Human.view.tooltips.setEnabled(enable);
        });

    Human.rpc.define("dissect.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.dissect.enabled;
            }
            checkUnsavedAnnotation(enable,
                function () {
                    Human.view.dissect.setEnabled(enable);
                    if (enable) {
                        Human.view.pick.setMultiPickEnabled(false);
                        Human.view.pick.setSinglePickEnabled(false);
                        Human.view.annotations.setEnabled(false);
                    } else {
                        Human.view.pick.setSinglePickEnabled(true);
                        Human.view.xray.setEnabled(Human.view.xray.enabled);
                        Human.view.highlight.setEnabled(Human.view.highlight.enabled);
                    }
                });
        });

    Human.rpc.define("highlight.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.highlight.enabled;
            }
            Human.view.highlight.setEnabled(enable);
            if (enable) {
                Human.view.isolate.setEnabled(false);
                Human.view.xray.setEnabled(false);
            }
        });

    Human.rpc.define("isolate.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.isolate.enabled;
            }
            if (enable) {
                var selection = Human.scene.anySelected();
                if (!selection) {
                    return;
                }
            }
            Human.view.isolate.setEnabled(enable);
            if (enable) {
                Human.view.highlight.setEnabled(false);
                Human.view.xray.setEnabled(false);
                Human.view.pick.setSinglePickEnabled(true); // Multi-pick doesn't make sense in Isolate mode
                Human.view.pick.setMultiPickEnabled(false);
            }
        });

    Human.rpc.define("pick.single.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.pick.getSinglePickEnabled();
            }
            checkUnsavedAnnotation(enable,
                function () {
                    Human.view.pick.setSinglePickEnabled(enable);
                    if (enable) {
                        Human.view.pick.setMultiPickEnabled(false);
                        Human.view.dissect.setEnabled(false);
                        Human.view.annotations.setEnabled(false);
                    }
                });
        });

    Human.rpc.define("pick.multi.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.pick.getMultiPickEnabled();
            }
            checkUnsavedAnnotation(enable,
                function () {
                    Human.view.pick.setMultiPickEnabled(enable);
                    if (enable) {
                        Human.view.pick.setSinglePickEnabled(false);
                        Human.view.dissect.setEnabled(false);
                        Human.view.annotations.setEnabled(false);
                    } else {
                        Human.view.pick.setSinglePickEnabled(true);
                    }
                });
        });

    Human.rpc.define("pick.doublePick",
        function (params) {
            Human.view.pick.doublePick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });

    Human.rpc.define("pick.hoverPick",
        function (params) {
            Human.view.pick.hoverPick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });

    Human.rpc.define("annotations.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.annotations.enabled;
            }
            checkUnsavedAnnotation(!enable, // Don't check, if enabling annotation mode
                function () {
                    Human.view.annotations.setEnabled(enable);
                    if (enable) {
                        Human.view.pick.setSinglePickEnabled(false);
                        Human.view.pick.setMultiPickEnabled(false);
                        Human.view.dissect.setEnabled(false);
                    } else {
                        Human.view.pick.setSinglePickEnabled(true);
                        Human.view.xray.setEnabled(Human.view.xray.enabled);
                        Human.view.highlight.setEnabled(Human.view.highlight.enabled);
                    }
                });
        });

    Human.rpc.define("xray.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.xray.enabled;
            }
            Human.view.xray.setEnabled(enable);
            if (enable) {
                Human.view.highlight.setEnabled(false);
                Human.view.isolate.setEnabled(false);
            }
        });

    Human.rpc.define("queryModes",
        function () {
            var data = {
                xray: Human.view.xray.enabled,
                highlight: Human.view.highlight.enabled,
                annotation: Human.view.annotations.enabled,
                singlePick: Human.view.pick.singleEnabled,
                multipick: Human.view.pick.multiEnabled,
                dissect: Human.view.dissect.enabled
            };
            this.setResult(data);
        });

    //UI outside of the canvas
    Human.rpc.define("jquery",
        function (params) {
            if(params.selector === 'document'){
                params.selector = document;
            }

            $.fn[params.method].apply($(params.selector), params.args);
        });

    Human.rpc.define("navigation.setEnabled",
        function (params) {
            _setUIEnabled('navigator_container', params.enable);
        });

    Human.rpc.define("fullscreen.setEnabled",
        function (params) {
            _setUIEnabled('embed-full-screen', params.enable);
        });

    var reporters = Human.log.reporters;
    var messageBuf = Human.log.messageBuf;

    // Creates a log reporter
    // For network efficiency, this allows networked clients to only get
    // logging if they are interested in it. Potentially this is also
    // good for compression of that logging.
    Human.rpc.define("log.createReporter",
        function (params) {
            if (!params.id) {
                Human.log.error("param expected: id");
                return;
            }
            var id = "log.reporters." + params.id;
            if (reporters[id]) {
                // TODO: complain
                return;
            }
            reporters[id] = {};
            // Update reporter with events so far
            for (var i = 0, len = messageBuf.length; i < len; i++) {
                Human.events.fire(id, messageBuf[i]);
            }
        });

    // Destroys a log reporter
    Human.rpc.define("log.destroyReporter",
        function (params) {
            if (!params.id) {
                Human.log.error("param expected: id");
                return;
            }
            var id = "log.reporters." + params.id;
            delete reporters[id];
        });

    // Annotation object -> plain result object, only primitives, no private props
    function makeAnnotationResult(annotation) {
        var result = {};
        var value;

        for (var key in annotation) {
            if (annotation.hasOwnProperty(key)) {
                value = annotation[key];

                if(Human.utils.isPrimitive(value) && key[0] !== '_') {
                    result[key] = value;
                }
            }
        }

        // special prop adapting
        result.objectId = annotation.object ? annotation.object.objectId : "";

        result.title = annotation.label.title;
        result.description = annotation.label.description;

        result.pos = annotation.pin.pos;
        result.pinVec = annotation.pin.dir;
        result.visible = annotation.pin.visible;

        return result;
    }

    Human.rpc.define("annotations.getAnnotations",
        function () {
            var annotations = Human.view.annotations.annotations;
            var result = {};
            var annotation;

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    result[annotationId] = makeAnnotationResult(annotation);
                }
            }

            this.setResult(result);
        });

    Human.rpc.define("annotations.setShown", function (params) {
        Human.view.annotations.setShown(params.shown);
        this.setResult(true);
    });


    Human.rpc.define("camera.flyTo", function (params) {
        var self = this;
        Human.view.camera.fly.flyTo(params,
            function () {
                self.setResult(true);
            });
    });


    Human.rpc.define("camera.jumpTo", function (params) {
        var self = this;
        Human.view.camera.fly.jumpTo(params,
            function () {
                self.setResult(true);
            });
    });

    Human.rpc.define("camera.getZoom", function () {
        this.setResult(Human.view.camera.getZoom());
    });

    var callbacks = {};

    /**
     * Subscribes to an engine event
     */
    Human.rpc.define("events.on",
        function (params) {
            var self = this;
            var id = this.id;
            if (id) {
                if (callbacks[id]) {
                    // Support "events.off" for this subscription
                    this.error("an event is already bound to this ID: '" + id + "'");
                    return;
                }
            }
            var type = params.type;
            if (!type) {
                this.error("parameter expected: 'type'");
                return;
            }
            var fn = function (event) {
                self.setResult(event);
            };
            if (params.mask) {
                params.fn = fn;
                Human.events.on(params);
            } else {
                Human.events.on(params.type, fn);
            }
            if (id) { // So we can unbind with "events.off"
                callbacks[id] = [type, fn];
            }
        });

    /**
     * Subscribes to the next engine event of the given type
     */
    Human.rpc.define("events.once",
        function (params) {
            var self = this;
            var type = params.type;
            if (!type) {
                this.error("parameter expected: 'type'");
                return;
            }
            Human.events.once(type, function (event) {
                self.setResult(event);
            });
        });

    function unbindEvent(id) {
        var callback = callbacks[id];
        if (callback) {
            var type = callback[0];
            var fn = callback[1];
            Human.unEvent(type, fn);
            delete callbacks[id];
        }
    }

    /**
     * Triggers an engine event
     */
    Human.rpc.define("events.fire",
        function (params) {
            Human.events.fire(params.eventName, params.params);
        });

    Human.rpc.define("reset",
        function () {
            var self = this;
            Human.init.reset(function () {
                    self.setResult(true);
                });
        });

    Human.rpc.define("reload",
        function () {
            Human.init.reload();
        });

    Human.rpc.define("pick.pick",
        function (params) {
            Human.view.pick.pick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });


    Human.rpc.define("pick.queryPick",
        function (params) {
            this.setResult(Human.view.pick.queryPick({ canvasX: params.canvasX, canvasY: params.canvasY, rayPick: params.rayPick }) || {});
        });

    Human.rpc.define("scene.setEnabledObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human.utils.isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            Human.scene.setEnabledObjects({ objects: objectIds, replace: params.replace });
        });

    Human.rpc.define("scene.setSelectedObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human.utils.isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            params.objectIds = objectIds;
            Human.scene.setSelectedObjects(params);
        });

    (function () {
        Human.rpc.define("scene.getObjects",
            function (params) {
                var result = [];
                var object;
                if (params.objectId) {
                    var objectId = params.objectId;
                    object = Human.scene.objects[objectId];
                    if (object) {
                        result.push(getObjectDescription(object));
                    }
                } else {
                    // Get parent objects before their children so that on the API side we
                    // will always create HumanAPI.Objects for the parents BEFORE those for
                    // their children, so that each child's HumanAPI.Object can be instantiated
                    // with a reference to its parent's HumanAPI.Object.
                    for (var i = 0, len = Human.scene.rootObjects.length; i < len; i++) {
                        traverseObjects(Human.scene.rootObjects[i], result);
                    }
                }
                this.setResult(result);
            });

        function traverseObjects(object, result) {
            if (!object) {
                return;
            }
            result.push(getObjectDescription(object));
            for (var i = 0, len = object.objects.length; i < len; i++) {
                traverseObjects(object.objects[i], result);
            }
        }

        function getObjectDescription(object) {
            var desc = {};

            for (var prop in object) {
                if (object.hasOwnProperty(prop) && prop[0] !== "_") {
                    var value = object[prop];

                    if (Human.utils.isPrimitive(value)) {
                        desc[prop] = value;
                    }
                }
            }

            desc.parentObjectId = object.parent ? object.parent.objectId : null;

            return desc;
        }
    })();



    Human.rpc.define("scene.setObjectTransform",
        function (params) {
            var objectId = params.objectId;
            var fmaId = params.fmaId;
            var object;
            if (objectId) { // Find object by ID
                object = Human.scene.objects[objectId];
                if (!object) {
                    this.error("Scene object not found: '" + objectId + "'");
                    return;
                }
            } else if (fmaId) { // Find object by FMA ID
                object = Human.scene.objectsByFMAID[fmaId];
                if (!object) {
                    this.error("scene object not found for the given FMA ID: '" + fmaId + "'");
                    return;
                }
            }
            object.setTransform(params);
        });

    /**
     * Scrub timeline to time or chapter
     *
     * Scrub to given time in seconds:
     *
     * {
     *    time: 15
     * }
     *
     * Scrub to start of given chapter:
     *
     * {
     *    chapterId: "makeIncision"
     * }
     *
     */
    Human.rpc.define("timeline.scrub",
        function (params) {
            Human.timeline.scrub(params);
        });

    // Stops timeline if currently playing
    Human.rpc.define("timeline.stop",
        function () {
            Human.timeline.stop();
        });

    // Winds timeline to start of previous chapter
    Human.rpc.define("timeline.prev",
        function () {
            Human.timeline.prev();
        });

    // Winds timeline to start of next chapter
    Human.rpc.define("timeline.next",
        function () {
            Human.timeline.next();
        });

    // Unpauses timeline if currently paused
    Human.rpc.define("timeline.unpause",
        function () {
            Human.timeline.unpause();
        });

    Human.rpc.define("properties.set",
        function (params) {
            //backwards compatibility for older API libraries
            var props = params.props || params;
            Human.properties.set(props || {});
        });

    //Private methods

    var _setUIEnabled = function (id, enable) {
      var _enable = (typeof enable === 'undefined') ? true : enable;
      var el = document.getElementById(id);
      el.style.display = (_enable) ? 'block' : 'none';
    };

    function checkUnsavedAnnotation(doCheck, ok) {
        if (doCheck && Human.view.annotations.unsavedAnnotation) {
            alert("Please save or cancel annotation first");
        } else {
            ok();
        }
    }
});
;Human.rpc.fmaIds = {
    "3734": [
        "Base_of_aorta_3734_ID"
    ],
    "3768": [
        "Aortic_arch_3768_ID"
    ],
    "3784": [
        "Descending_Aorta_3784_ID"
    ],
    "3818": [
        "Marginal_branch_of_right_coronary_artery_3818_ID"
    ],
    "3829": [
        "Anterior_atrial_branch_of_right_coronary_artery_3829_ID"
    ],
    "3837": [
        "Posterior_left_ventricular_branch_of_left_coronary_artery_3837_ID"
    ],
    "3932": [
        "left_lower_subclavian_artery_3932_ID",
        "Right_Brachiocephalic_trunk_3932_ID"
    ],
    "3941": [
        "Right_common_carotid_artery_3941_ID"
    ],
    "3945": [
        "Right_external_carotid_artery_3945_ID"
    ],
    "3949": [
        "Right_Internal_Carotid_Artery_3949_ID"
    ],
    "3950": [
        "Right_Internal_Carotid_Artery_3950_ID"
    ],
    "3958": [
        "Right_Vertebral_Artery_3958_ID"
    ],
    "3969": [
        "Right_internal_thoracic_artery_3969_ID"
    ],
    "3988": [
        "Superior_right_epigastric_artery_3988_ID",
        "Right_Superior_epigastric_artery_3988_ID"
    ],
    "4058": [
        "Left_common_carotid_artery_4058_ID",
        "Base_of_left_common_carotid_artery_4058_ID",
        "Base_of_Left_common_carotid_artery_4058_ID"
    ],
    "4060": [
        "Left_external_carotid_artery_4060_ID"
    ],
    "4062": [
        "Left_Internal_Carotid_Artery_4062_ID"
    ],
    "4066": [
        "Left_Vertebral_Artery_4066_ID"
    ],
    "4068": [
        "Left_internal_thoracic_artery_4068_ID"
    ],
    "4083": [
        "Left_Superior_epigastric_artery_4083_ID"
    ],
    "4085": [
        "Right_costocervical_trunk_4085_ID"
    ],
    "4086": [
        "Right_costocervical_trunk_4086_ID",
        "Left_costocervical_trunk_4086_ID"
    ],
    "4134": [
        "Left_deep_cervical_artery_4134_ID",
        "left_deep_cervical_artery_4134_ID"
    ],
    "4634": [
        "Right_Subcostal_artery_4634_ID",
        "Right_subcostal_artery_4634_ID"
    ],
    "4654": [
        "Left_Subcostal_artery_4654_ID",
        "Left_subcostal_artery_4654_ID"
    ],
    "4693": [
        "Right_subclavian_artery_4693_ID"
    ],
    "4694": [
        "left_subclavian_artery_4694_ID",
        "Left_Lower_Subclavian_artery_4694_ID",
        "right_subclavian_artery_4694_ID"
    ],
    "4706": [
        "Coronary_sinus_4706_ID"
    ],
    "4707": [
        "Great_cardiac_vein_4707_ID"
    ],
    "4712": [
        "Posterior_vein_of_left_ventricle_4712_ID"
    ],
    "4713": [
        "Middle_cardiac_vein_4713_ID"
    ],
    "4714": [
        "Small_cardiac_vein_4714_ID"
    ],
    "4715": [
        "Oblique_vein_of_left_atrium_4715_ID"
    ],
    "4720": [
        "Superior_Vena_Cava_4720_ID"
    ],
    "4728": [
        "Inferior_Thyroid_vein_4728_ID"
    ],
    "4751": [
        "Right_Brachiocephalic_vein_4751_ID",
        "Right_brachiocephalic_vein_4751_ID"
    ],
    "4755": [
        "Right_internal_jugular_vein_4755_ID"
    ],
    "4756": [
        "Right_Vertebral_vein_4756_ID"
    ],
    "4758": [
        "Right_internal_thoracic_vein_4758_ID"
    ],
    "4761": [
        "Left_Brachiocephalic_vein_4761_ID",
        "Left_brachiocephalic_vein_4761_ID"
    ],
    "4763": [
        "Left_internal_jugular_vein_4763_ID"
    ],
    "4764": [
        "Left_Vertebral_vein_4764_ID"
    ],
    "4766": [
        "Left_internal_thoracic_vein_4766_ID"
    ],
    "4771": [
        "Right_Superior_epigastric_vein_4771_ID",
        "Right_superior_epigastric_vein_4771_ID"
    ],
    "4785": [
        "Left_superior_epigastric_vein_4785_ID"
    ],
    "4838": [
        "Azygos_Vein_4838_ID",
        "Azygos_vein_4838_ID"
    ],
    "4843": [
        "Right_ascending_lumbar_vein_4843_ID"
    ],
    "4944": [
        "Hemiazgos_vein_4944_ID",
        "Hemiazygos_vein_4944_ID"
    ],
    "4950": [
        "Left_ascending_lumbar_vein_4950_ID"
    ],
    "5011": [
        "Left_Accessory_Hemiazgos_vein_5011_ID",
        "Left_Accessory_Hemiazygos_vein_5011_ID"
    ],
    "5883": [
        "Right_Splanchnic_Nerve_5883_ID",
        "Left_Splanchnic_Nerve_5883_ID"
    ],
    "6192": [
        "Right_Phrenic_Nerve_6192_ID"
    ],
    "6193": [
        "Left_Phrenic_Nerve_6193_ID"
    ],
    "6246": [
        "Left_Recurrent_Laryngeal_Nerve_6246_ID",
        "Right_Recurrent_Laryngeal_Nerve_6246_ID"
    ],
    "6258": [
        "Left_Sympathetic_Chain_6258_ID",
        "Right_Sympathetic_Chain_6258_ID"
    ],
    "6259": [
        "Right_Sympathetic_Chain_6259_ID"
    ],
    "6442": [
        "Left_C1_Spinal_Nerve_6442_ID",
        "Right_C1_Spinal_Nerve_6442_ID"
    ],
    "6451": [
        "Left_C2_Spinal_Nerve_6451_ID",
        "Right_C2_Spinal_Nerve_6451_ID"
    ],
    "6453": [
        "Left_C3_Spinal_Nerve_6453_ID",
        "Right_C3_Spinal_Nerve_6453_ID"
    ],
    "6456": [
        "Left_C4_Spinal_Nerve_6456_ID",
        "Right_C4_Spinal_Nerve_6456_ID"
    ],
    "6457": [
        "Right_C5_Spinal_Nerve_6457_ID",
        "Left_C5_Spinal_Nerve_6457_ID"
    ],
    "6459": [
        "Left_C6_Spinal_Nerve_6459_ID",
        "Right_C6_Spinal_Nerve_6459_ID"
    ],
    "6461": [
        "Right_C7_Spinal_Nerve_Group_6461_ID",
        "Left_C7_Spinal_Nerve_6461_ID",
        "Right_C7_Spinal_Nerve_6461_ID",
        "Left_C7_Spinal_Nerve_Group_6461_ID"
    ],
    "6465": [
        "Left_C8_Spinal_Nerve_6465_ID",
        "Right_C8_Spinal_Nerve_6465_ID"
    ],
    "6582": [
        "Ansa_Subclavia_6582_ID"
    ],
    "6642": [
        "Superior_hypogastric_nerve_plexus_6642_ID"
    ],
    "6643": [
        "Inferior_hypogastric_nerve_plexus_6643_ID"
    ],
    "6647": [
        "Prostatic_nerve_plexus_6647_ID"
    ],
    "7088": [
        "Heart_7088_ID"
    ],
    "7096": [
        "Right_atrium_7096_ID"
    ],
    "7097": [
        "Left_atrium_7097_ID"
    ],
    "7098": [
        "Right_Ventricle_7098_ID"
    ],
    "7101": [
        "Left_Ventricle_7101_ID"
    ],
    "7131": [
        "Esophagus_7131_ID"
    ],
    "7133": [
        "Interventricular_Septum_7133_ID"
    ],
    "7148": [
        "Stomach_7148_ID"
    ],
    "7196": [
        "Spleen_7196_ID"
    ],
    "7197": [
        "Liver_7197_ID"
    ],
    "7198": [
        "Pancreas_7198_ID"
    ],
    "7200": [
        "Small_intestine_7200_ID"
    ],
    "7202": [
        "Gallbladder_7202_ID"
    ],
    "7204": [
        "Left_Kidney_7204_ID",
        "Right_Kidney_7204_ID"
    ],
    "7205": [
        "Right_Kidney_7205_ID",
        "Left_Kidney_7205_ID"
    ],
    "7206": [
        "Duodenum_7206_ID"
    ],
    "7207": [
        "Jejunum_7207_ID"
    ],
    "7208": [
        "Ileum_7208_ID"
    ],
    "7209": [
        "Ovaries_7209_ID"
    ],
    "7211": [
        "Right_testis_7211_ID"
    ],
    "7212": [
        "Left_testis_7212_ID"
    ],
    "7213": [
        "Right_Ovary_7213_ID"
    ],
    "7214": [
        "Left_Ovary_7214_ID"
    ],
    "7218": [
        "Right_auricle_7218_ID"
    ],
    "7219": [
        "Left_auricle_7219_ID"
    ],
    "7234": [
        "Tricuspid_Valve_7234_ID"
    ],
    "7235": [
        "Mitral_valve_7235_ID"
    ],
    "7236": [
        "Aortic_Valve_7236_ID"
    ],
    "7246": [
        "Pulmonary_Valve_7246_ID"
    ],
    "7309": [
        "Right_Lung_7309_ID"
    ],
    "7310": [
        "Left_Lung_7310_ID"
    ],
    "7333": [
        "Right_Superior_Lobe_7333_ID"
    ],
    "7337": [
        "Right_Inferior_Lobe_7337_ID"
    ],
    "7370": [
        "Left_Superior_Lobe_7370_ID"
    ],
    "7371": [
        "Left_Inferior_Lobe_7371_ID"
    ],
    "7383": [
        "Right_Middle_Lobe_7383_ID"
    ],
    "7394": [
        "Trachea_7394_ID"
    ],
    "7486": [
        "manubrium_of_sternum_7486_ID",
        "body_of_sternum_7486_ID"
    ],
    "7591": [
        "Right_Costal_Cartilage_7591_ID",
        "Left_Costal_Cartilage_7591_ID"
    ],
    "7592": [
        "Left_Costal_Cartilage_7592_ID",
        "Right_Costal_Cartilage_7592_ID"
    ],
    "7647": [
        "spinal_cord_7647_ID"
    ],
    "7857": [
        "Left_first_rib_7857_ID",
        "Right_first_rib_7857_ID"
    ],
    "7882": [
        "Right_second_rib_7882_ID"
    ],
    "7883": [
        "Left_second_rib_7883_ID"
    ],
    "7909": [
        "Right_third_rib_7909_ID"
    ],
    "7910": [
        "Left_third_rib_7910_ID"
    ],
    "7957": [
        "Right_fourth_rib_7957_ID"
    ],
    "7958": [
        "Left_fourth_rib_7958_ID"
    ],
    "8066": [
        "Right_fifth_rib_8066_ID",
        "Left_fifth_rib_8066_ID"
    ],
    "8175": [
        "Left_sixth_rib_8175_ID",
        "Right_sixth_rib_8175_ID"
    ],
    "8229": [
        "Left_seventh_rib_8229_ID",
        "Right_seventh_rib_8229_ID"
    ],
    "8283": [
        "Left_eighth_rib_8283_ID",
        "Right_eighth_rib_8283_ID"
    ],
    "8364": [
        "Left_ninth_rib_8364_ID",
        "Right_ninth_rib_8364_ID"
    ],
    "8445": [
        "Right_tenth_rib_8445_ID",
        "Left_tenth_rib_8445_ID"
    ],
    "8531": [
        "Left_eleventh_rib_8531_ID",
        "Right_eleventh_rib_8531_ID"
    ],
    "8533": [
        "Right_twelfth_rib_8533_ID",
        "Left_twelfth_rib_8533_ID"
    ],
    "8612": [
        "Pulmonary_trunk_8612_ID"
    ],
    "9165": [
        "First_thoracic_vertebra_9165_ID"
    ],
    "9187": [
        "Second_thoracic_vertebra_9187_ID"
    ],
    "9209": [
        "Third_thoracic_vertebra_9209_ID"
    ],
    "9248": [
        "Fourth_thoracic_vertebra_9248_ID"
    ],
    "9600": [
        "Prostate_9600_ID"
    ],
    "9603": [
        "Thyroid_Gland_9603_ID"
    ],
    "9615": [
        "Cricoid_cartilage_9615_ID"
    ],
    "9706": [
        "Bile_Ducts_9706_ID"
    ],
    "9707": [
        "Penis_9707_ID"
    ],
    "9710": [
        "Vomer_9710_ID"
    ],
    "9711": [
        "Maxilla_9711_ID"
    ],
    "9761": [
        "Right_Transversus_thoracis_9761_ID"
    ],
    "9762": [
        "Right_Transversus_thoracis_9762_ID",
        "Left_Transversus_thoracis_9762_ID"
    ],
    "9922": [
        "Fifth_thoracic_vertebra_9922_ID"
    ],
    "9945": [
        "Sixth_thoracic_vertebra_9945_ID"
    ],
    "9968": [
        "Seventh_thoracic_vertebra_9968_ID"
    ],
    "9991": [
        "Eighth_thoracic_vertebra_9991_ID"
    ],
    "10014": [
        "Ninth_thoracic_vertebra_10014_ID"
    ],
    "10037": [
        "Tenth_thoracic_vertebra_10037_ID"
    ],
    "10059": [
        "Eleventh_thoracic_vertebra_10059_ID"
    ],
    "10081": [
        "Twelfth_thoracic_vertebra_10081_ID"
    ],
    "10551": [
        "Right_dorsal_scapular_artery_10551_ID"
    ],
    "10552": [
        "right_dorsal_scapular_artery_10552_ID",
        "left_dorsal_scapular_artery_10552_ID"
    ],
    "10660": [
        "Right_deep_cervical_artery_10660_ID"
    ],
    "10679": [
        "Right_inferior_thyroid_artery_10679_ID"
    ],
    "10680": [
        "left_inferior_thyroid_artery_10680_ID",
        "Right_suprascapular_artery_10680_ID"
    ],
    "10681": [
        "left_suprascapular_artery_10681_ID",
        "Right_transverse_cervical_artery_10681_ID",
        "right_suprascapular_artery_10681_ID"
    ],
    "10682": [
        "left_transverse_cervical_artery_10682_ID",
        "Right_superficial_cervical_artery_10682_ID"
    ],
    "10683": [
        "left_superficial_cervical_artery_10683_ID"
    ],
    "10951": [
        "Inferior_vena_cava_10951_ID",
        "base_of_inferior_vena_cava_10951_ID"
    ],
    "12519": [
        "Atlas_C1_12519_ID"
    ],
    "12520": [
        "Axis_C2_12520_ID"
    ],
    "12521": [
        "Third_cervical_vertebra_12521_ID"
    ],
    "12522": [
        "Fourth_cervical_vertebra_12522_ID"
    ],
    "12523": [
        "Fifth_cervical_vertebra_12523_ID"
    ],
    "12524": [
        "Sixth_cervical_vertebra_12524_ID"
    ],
    "12525": [
        "Seventh_cervical_vertebra_12525_ID"
    ],
    "12770": [
        "Deep_lateral_cervical_lymph_nodes_12770_ID"
    ],
    "12858": [
        "Union_between_ascending_lumbar_veins_12858_ID"
    ],
    "13072": [
        "First_lumbar_vertebra_13072_ID"
    ],
    "13073": [
        "Second_lumbar_vertebra_13073_ID"
    ],
    "13074": [
        "Third_lumbar_vertebra_13074_ID"
    ],
    "13075": [
        "Fourth_lumbar_vertebra_13075_ID"
    ],
    "13076": [
        "Fifth_lumbar_vertebra_13076_ID"
    ],
    "13111": [
        "Right_external_jugular_vein_13111_ID"
    ],
    "13112": [
        "Left_external_jugular_vein_13112_ID",
        "Right_external_jugular_vein_13112_ID"
    ],
    "13113": [
        "Left_external_jugular_vein_13113_ID"
    ],
    "13295": [
        "Diaphragm_13295_ID"
    ],
    "13322": [
        "Right_Clavicle_13322_ID"
    ],
    "13323": [
        "Left_Clavicle_13323_ID"
    ],
    "13325": [
        "Right_cephalic_vein_13325_ID"
    ],
    "13326": [
        "right_cephalic_vein_13326_ID",
        "left_cephalic_vein_13326_ID"
    ],
    "13328": [
        "Left_Clavicle_13328_ID"
    ],
    "13336": [
        "Right_external_oblique_13336_ID"
    ],
    "13337": [
        "Left_external_oblique_13337_ID"
    ],
    "13346": [
        "Right_Sternohyoid_13346_ID"
    ],
    "13347": [
        "Left_Sternohyoid_13347_ID"
    ],
    "13350": [
        "Right_Sternothyroid_13350_ID"
    ],
    "13351": [
        "Left_Sternothyroid_13351_ID"
    ],
    "13352": [
        "Right_Thyrohyoid_13352_ID"
    ],
    "13353": [
        "Left_Thyrohyoid_13353_ID"
    ],
    "13354": [
        "Intercostal_Muscles_of_Left_Thorax_13354_ID",
        "Intercostal_Muscles_of_Right_Thorax_13354_ID"
    ],
    "13358": [
        "Right_latissimus_dorsi_13358_ID"
    ],
    "13359": [
        "Left_latissimus_dorsi_13359_ID"
    ],
    "13373": [
        "Right_pectoralis_major_13373_ID"
    ],
    "13374": [
        "Left_pectoralis_major_13374_ID",
        "Right_pectoralis_major_13374_ID"
    ],
    "13375": [
        "Right_Pectoralis_minor_13375_ID"
    ],
    "13376": [
        "Left_Pectoralis_minor_13376_ID",
        "Right_Pectoralis_minor_13376_ID"
    ],
    "13377": [
        "Right_Rectus_Abdominis_13377_ID"
    ],
    "13378": [
        "Left_Rectus_Abdominis_13378_ID"
    ],
    "13379": [
        "Right_Rectus_Abdominis_13379_ID"
    ],
    "13381": [
        "Right_Rhomboid_Major_13381_ID"
    ],
    "13382": [
        "Left_Rhomboid_Major_13382_ID"
    ],
    "13383": [
        "Right_Rhomboid_Minor_13383_ID"
    ],
    "13384": [
        "Left_Rhomboid_Minor_13384_ID"
    ],
    "13395": [
        "Right_Scapula_13395_ID"
    ],
    "13396": [
        "Left_Scapula_13396_ID",
        "Right_Scapula_13396_ID"
    ],
    "13398": [
        "Right_serratus_anterior_13398_ID"
    ],
    "13399": [
        "Left_serratus_anterior_13399_ID"
    ],
    "13403": [
        "Right_Serratus_Posterior_Superior_13403_ID"
    ],
    "13404": [
        "Left_Serratus_Posterior_Superior_13404_ID"
    ],
    "13405": [
        "Right_Serratus_Posterior_Inferior_13405_ID"
    ],
    "13406": [
        "Left_Serratus_Posterior_Inferior_13406_ID"
    ],
    "13408": [
        "Right_Sternocleidomastoid_13408_ID"
    ],
    "13409": [
        "Left_Sternocleidomastoid_13409_ID"
    ],
    "13410": [
        "Right_Subclavius_13410_ID"
    ],
    "13411": [
        "Left_Subclavius_13411_ID",
        "Right_Subclavius_13411_ID"
    ],
    "13414": [
        "Right_subscapularis_13414_ID"
    ],
    "13415": [
        "Left_subscapularis_13415_ID",
        "Right_subscapularis_13415_ID"
    ],
    "13417": [
        "Right_Thoracoepigastric_vein_13417_ID"
    ],
    "13418": [
        "Left_Thoracoepigastric_vein_13418_ID"
    ],
    "13419": [
        "Right_Trapezius_13419_ID"
    ],
    "13420": [
        "Left_Trapezius_13420_ID"
    ],
    "13421": [
        "Ligamentum_arteriosum_13421_ID"
    ],
    "13478": [
        "Vertebral_Column_13478_ID"
    ],
    "13889": [
        "Pituitary_Gland_13889_ID"
    ],
    "13890": [
        "Parathyroid_Glands_13890_ID"
    ],
    "13892": [
        "Right_Internal_oblique_13892_ID"
    ],
    "13893": [
        "Left_Internal_oblique_13893_ID"
    ],
    "13912": [
        "Anterior_interventricular_artery_13912_ID"
    ],
    "14331": [
        "splenic_vein_14331_ID"
    ],
    "14332": [
        "superior_mesenteric_vein_14332_ID"
    ],
    "14335": [
        "Right_renal_vein_14335_ID"
    ],
    "14336": [
        "Left_renal_vein_14336_ID"
    ],
    "14338": [
        "Right_Hepatic_Vein_14338_ID"
    ],
    "14339": [
        "Left_Hepatic_Vein_14339_ID"
    ],
    "14341": [
        "Right_testicular_vein_14341_ID"
    ],
    "14345": [
        "Left_testicular_vein_14345_ID"
    ],
    "14384": [
        "Right_median_nerve_14384_ID"
    ],
    "14385": [
        "Left_median_nerve_14385_ID"
    ],
    "14468": [
        "Right_Recurrent_Laryngeal_Nerve_14468_ID"
    ],
    "14469": [
        "Left_Recurrent_Laryngeal_Nerve_14469_ID"
    ],
    "14542": [
        "Appendix_14542_ID"
    ],
    "14543": [
        "Colon_14543_ID"
    ],
    "14544": [
        "Rectum_14544_ID"
    ],
    "14545": [
        "Ascending_colon_14545_ID"
    ],
    "14546": [
        "Transverse_colon_14546_ID"
    ],
    "14547": [
        "Descending_Colon_14547_ID"
    ],
    "14548": [
        "Sigmoid_Colon_14548_ID"
    ],
    "14735": [
        "Right_Lumbar_artery_14735_ID",
        "Left_Lumbar_Artery_14735_ID",
        "Right_Lumbar_Artery_14735_ID"
    ],
    "14746": [
        "Right_Inferior_Phrenic_Artery_14746_ID"
    ],
    "14747": [
        "Left_Inferior_Phrenic_Artery_14747_ID"
    ],
    "14749": [
        "superior_mesenteric_artery_14749_ID"
    ],
    "14750": [
        "Inferior_Mesenteric_artery_14750_ID"
    ],
    "14752": [
        "Right_renal_artery_14752_ID"
    ],
    "14753": [
        "Left_Renal_artery_14753_ID"
    ],
    "14759": [
        "Right_testicular_artery_14759_ID"
    ],
    "14760": [
        "Left_testicular_artery_14760_ID"
    ],
    "14768": [
        "Left_Gastric_Artery_14768_ID"
    ],
    "14771": [
        "Common_hepatic_artery_14771_ID"
    ],
    "14772": [
        "Hepatic_artery_proper_14772_ID"
    ],
    "14773": [
        "Splenic_artery_14773_ID"
    ],
    "14775": [
        "Gastroduodenal_artery_14775_ID"
    ],
    "14776": [
        "Right_Gastric_artery_14776_ID"
    ],
    "14778": [
        "Right_hepatic_artery_14778_ID"
    ],
    "14779": [
        "Left_hepatic_artery_14779_ID"
    ],
    "14781": [
        "Right_Gastroepiploic_artery_14781_ID"
    ],
    "14787": [
        "Dorsal_pancreatic_artery_14787_ID"
    ],
    "14790": [
        "Inferior_pancreatic_artery_14790_ID"
    ],
    "14791": [
        "Prepancreatic_Artery_14791_ID"
    ],
    "14792": [
        "Great_pancreatic_artery_14792_ID"
    ],
    "14793": [
        "Caudal_pancreatic_artery_14793_ID"
    ],
    "14796": [
        "Left_Gastroepiploic_artery_14796_ID"
    ],
    "14810": [
        "middle_colic_artery_14810_ID"
    ],
    "14811": [
        "Right_colic_artery_14811_ID"
    ],
    "14812": [
        "Celiac_Trunk_14812_ID"
    ],
    "14815": [
        "Ileocolic_artery_14815_ID"
    ],
    "14819": [
        "ileal_branch_of_ileocolic_artery_14819_ID"
    ],
    "14820": [
        "Ileal_branch_of_ileocolic_vein_14820_ID",
        "Colic_branch_of_ileocolic_vein_14820_ID"
    ],
    "14822": [
        "Superior_branch_of_ileocolic_artery_14822_ID"
    ],
    "14826": [
        "Left_colic_artery_14826_ID"
    ],
    "14830": [
        "Sigmoid_artery_14830_ID"
    ],
    "14831": [
        "Marginal_artery_of_colon_14831_ID"
    ],
    "14832": [
        "Superior_Rectal_artery_14832_ID"
    ],
    "14835": [
        "Cystic_artery_14835_ID"
    ],
    "15388": [
        "Pancreatic_tributary_of_splenic_vein_15388_ID"
    ],
    "15390": [
        "left_gastroepiploic_vein_15390_ID"
    ],
    "15391": [
        "Inferior_Mesenteric_vein_15391_ID"
    ],
    "15394": [
        "Left_colic_vein_15394_ID"
    ],
    "15395": [
        "Sigmoid_vein_15395_ID"
    ],
    "15397": [
        "Right_gastroepiploic_vein_15397_ID"
    ],
    "15398": [
        "Anterior_Superior_pancreaticoduodenal_vein_15398_ID",
        "Anterior_Inferior_pancreaticoduodenal_vein_15398_ID",
        "Pancreaticoduodenal_vein_15398_ID",
        "Posterior_Superior_pancreaticoduodenal_vein_15398_ID",
        "Posterior_Inferior_pancreaticoduodenal_vein_15398_ID"
    ],
    "15399": [
        "Left_Gastric_vein_15399_ID"
    ],
    "15400": [
        "Right_Gastric_vein_15400_ID"
    ],
    "15407": [
        "right_colic_vein_15407_ID"
    ],
    "15408": [
        "Ileocolic_vein_15408_ID"
    ],
    "15414": [
        "Right_Hepatic_Portal_Vein_15414_ID"
    ],
    "15415": [
        "Left_Hepatic_Portal_Vein_15415_ID"
    ],
    "15571": [
        "Right_Ureter_15571_ID"
    ],
    "15572": [
        "Left_Ureter_15572_ID"
    ],
    "15629": [
        "Right_Adrenal_Gland_15629_ID"
    ],
    "15630": [
        "Left_Adrenal_Gland_15630_ID"
    ],
    "15710": [
        "Internal_anal_sphincter_15710_ID"
    ],
    "15900": [
        "Bladder_15900_ID"
    ],
    "16202": [
        "Sacrum_16202_ID"
    ],
    "16491": [
        "Right_iliohypogastric_nerve_16491_ID"
    ],
    "16492": [
        "Left_iliohypogastric_nerve_16492_ID"
    ],
    "16493": [
        "Right_ilioinguinal_nerve_16493_ID"
    ],
    "16494": [
        "Left_ilioinguinal_nerve_16494_ID"
    ],
    "16497": [
        "Right_lateral_femoral_cutaneous_nerve_16497_ID"
    ],
    "16498": [
        "Left_lateral_femoral_cutaneous_nerve_16498_ID"
    ],
    "16499": [
        "Right_femoral_nerve_16499_ID"
    ],
    "16500": [
        "Left_femoral_nerve_16500_ID"
    ],
    "16501": [
        "Right_obturator_nerve_16501_ID"
    ],
    "16502": [
        "Left_obturator_nerve_16502_ID"
    ],
    "17559": [
        "Uterus_17559_ID"
    ],
    "17740": [
        "Cervix_of_uterus_17740_ID"
    ],
    "18245": [
        "Right_Fallopian_Tube_18245_ID",
        "Left_Fallopian_Tube_18245_ID"
    ],
    "18256": [
        "Right_epididymis_18256_ID"
    ],
    "18257": [
        "Left_epididymis_18257_ID"
    ],
    "18806": [
        "Right_external_iliac_artery_18806_ID"
    ],
    "18807": [
        "Left_external_iliac_artery_18807_ID"
    ],
    "18809": [
        "Right_internal_iliac_artery_18809_ID"
    ],
    "18810": [
        "Left_internal_iliac_artery_18810_ID"
    ],
    "18824": [
        "Right_inferior_vesical_artery_18824_ID"
    ],
    "18825": [
        "Left_inferior_vesical_artery_18825_ID"
    ],
    "18829": [
        "Left_Uterine_Artery_18829_ID",
        "Right_Uterine_Artery_18829_ID"
    ],
    "18836": [
        "Right_internal_pudendal_artery_18836_ID"
    ],
    "18837": [
        "Left_internal_pudendal_artery_18837_ID"
    ],
    "18846": [
        "Right_iliolumbar_artery_18846_ID"
    ],
    "18847": [
        "Left_iliolumbar_artery_18847_ID"
    ],
    "18856": [
        "Right_lateral_sacral_artery_18856_ID"
    ],
    "18857": [
        "Left_lateral_sacral_artery_18857_ID"
    ],
    "18866": [
        "Right_obturator_artery_18866_ID"
    ],
    "18867": [
        "Left_obturator_artery_18867_ID"
    ],
    "18869": [
        "Right_superior_gluteal_artery_18869_ID"
    ],
    "18870": [
        "Right_superior_gluteal_artery_18870_ID",
        "Left_superior_gluteal_artery_18870_ID"
    ],
    "18872": [
        "Right_inferior_gluteal_artery_18872_ID"
    ],
    "18873": [
        "Left_inferior_gluteal_artery_18873_ID"
    ],
    "18885": [
        "Right_external_iliac_vein_18885_ID"
    ],
    "18886": [
        "Left_external_iliac_vein_18886_ID"
    ],
    "18887": [
        "Right_internal_iliac_vein_18887_ID"
    ],
    "18888": [
        "Left_internal_iliac_vein_18888_ID"
    ],
    "18891": [
        "Right_inferior_vesical_vein_18891_ID"
    ],
    "18892": [
        "Left_inferior_vesical_vein_18892_ID"
    ],
    "18897": [
        "Right_Uterine_Vein_18897_ID"
    ],
    "18898": [
        "Left_Uterine_Vein_18898_ID"
    ],
    "18903": [
        "Right_iliolumbar_vein_18903_ID"
    ],
    "18904": [
        "Left_iliolumbar_vein_18904_ID"
    ],
    "18906": [
        "Right_lateral_sacral_vein_18906_ID"
    ],
    "18907": [
        "Left_lateral_sacral_vein_18907_ID"
    ],
    "18909": [
        "Right_superior_gluteal_vein_18909_ID"
    ],
    "18910": [
        "Left_superior_gluteal_vein_18910_ID"
    ],
    "18912": [
        "Right_inferior_gluteal_vein_18912_ID"
    ],
    "18913": [
        "Left_inferior_gluteal_vein_18913_ID"
    ],
    "18915": [
        "Right_obturator_vein_18915_ID"
    ],
    "18916": [
        "Left_obturator_vein_18916_ID"
    ],
    "18918": [
        "Right_internal_pudendal_vein_18918_ID"
    ],
    "18919": [
        "Left_internal_pudendal_vein_18919_ID"
    ],
    "19086": [
        "Muscles_of_the_Pelvis_19086_ID"
    ],
    "19087": [
        "Levator_Ani_19087_ID"
    ],
    "19090": [
        "Pubococcygeus_19090_ID"
    ],
    "19091": [
        "Puborectalis_19091_ID"
    ],
    "19119": [
        "Right_Uterosacral_Ligament_19119_ID"
    ],
    "19120": [
        "Left_Uterosacral_Ligament_19120_ID"
    ],
    "19235": [
        "Right_vas_deferens_19235_ID"
    ],
    "19236": [
        "Left_vas_deferens_19236_ID"
    ],
    "19387": [
        "Right_Seminal_Vesicle_19387_ID"
    ],
    "19388": [
        "Left_Seminal_Vesicle_19388_ID"
    ],
    "19617": [
        "Corpus_spongiosum_of_penis_19617_ID"
    ],
    "19618": [
        "Right_corporus_cavernosum_of_penis_19618_ID",
        "Left_corporus_cavernosum_of_penis_19618_ID"
    ],
    "19667": [
        "Urethra_19667_ID"
    ],
    "19668": [
        "Male_urethra_19668_ID"
    ],
    "19730": [
        "Left_Ischiocavernosus_19730_ID",
        "Right_Ischiocavernosus_19730_ID"
    ],
    "19731": [
        "Right_Superficial_Transverse_Perineal_Muscle_19731_ID",
        "Left_Superficial_Transverse_Perineal_Muscle_19731_ID"
    ],
    "19732": [
        "Deep_transverse_perineal_muscle_19732_ID"
    ],
    "19949": [
        "Vagina_19949_ID"
    ],
    "20224": [
        "Right_Ribs_20224_ID"
    ],
    "20225": [
        "Right_Ribs_20225_ID",
        "Left_Ribs_20225_ID"
    ],
    "20226": [
        "Right_Bony_Pelvis_20226_ID",
        "Left_Ribs_20226_ID",
        "Right_side_of_bony_pelvis_20226_ID"
    ],
    "20227": [
        "Left_Bony_Pelvis_20227_ID",
        "Left_side_of_bony_pelvis_20227_ID"
    ],
    "20274": [
        "Perineal_Body_20274_ID"
    ],
    "20630": [
        "Right_genitofemoral_nerve_20630_ID"
    ],
    "20631": [
        "Left_genitofemoral_nerve_20631_ID"
    ],
    "20632": [
        "Genital_branch_of_right_genitofemoral_nerve_20632_ID"
    ],
    "20633": [
        "Genital_branch_of_left_genitofemoral_nerve_20633_ID"
    ],
    "20634": [
        "Femoral_branch_of_right_genitofemoral_nerve_20634_ID"
    ],
    "20635": [
        "Femoral_branch_of_left_genitofemoral_nerve_20635_ID"
    ],
    "20688": [
        "Right_Inferior_Epigastric_Artery_20688_ID"
    ],
    "20689": [
        "Left_Inferior_Epigastric_Artery_20689_ID"
    ],
    "20735": [
        "Right_Superficial_Epigastric_Artery_20735_ID"
    ],
    "20736": [
        "Left_Superficial_Epigastric_Artery_20736_ID"
    ],
    "20796": [
        "Right_deep_femoral_artery_20796_ID"
    ],
    "20797": [
        "Left_deep_femoral_artery_20797_ID"
    ],
    "20801": [
        "Right_lateral_circumflex_femoral_artery_20801_ID"
    ],
    "20802": [
        "Left_lateral_circumflex_femoral_artery_20802_ID"
    ],
    "20807": [
        "Right_Medial_circumflex_femoral_artery_20807_ID"
    ],
    "20808": [
        "Left_Medial_circumflex_femoral_artery_20808_ID"
    ],
    "20818": [
        "Right_dorsal_artery_of_penis_20818_ID"
    ],
    "20819": [
        "Left_dorsal_artery_of_penis_20819_ID"
    ],
    "20967": [
        "Prostatic_part_of_right_inferior_vesical_artery_20967_ID"
    ],
    "20968": [
        "Prostatic_part_of_left_inferior_vesical_artery_20968_ID"
    ],
    "21163": [
        "Right_Inferior_Epigastric_Vein_21163_ID"
    ],
    "21164": [
        "Left_Inferior_Epigastric_Vein_21164_ID"
    ],
    "21188": [
        "Right_Femoral_Vein_21188_ID"
    ],
    "21189": [
        "Left_Femoral_Vein_21189_ID"
    ],
    "21378": [
        "Superficial_Veins_of_the_Left_Leg_21378_ID",
        "Superficial_Veins_of_the_Right_Leg_21378_ID"
    ],
    "21379": [
        "Right_Great_Saphenous_Vein_21379_ID"
    ],
    "21380": [
        "Left_Great_Saphenous_Vein_21380_ID"
    ],
    "21422": [
        "Descending_branch_of_right_lateral_circumflex_femoral_artery_21422_ID"
    ],
    "21423": [
        "Descending_branch_of_left_lateral_circumflex_femoral_artery_21423_ID"
    ],
    "21863": [
        "Right_Pudendal_nerve_21863_ID"
    ],
    "21864": [
        "Left_Pudendal_nerve_21864_ID"
    ],
    "21919": [
        "Right_superficial_transverse_perineal_muscle_21919_ID"
    ],
    "21920": [
        "Left_superficial_transverse_perineal_muscle_21920_ID"
    ],
    "21921": [
        "Right_bulbospongiosus_21921_ID"
    ],
    "21922": [
        "Left_bulbospongiosus_21922_ID"
    ],
    "21923": [
        "Right_ischiocavernosus_21923_ID"
    ],
    "21924": [
        "Left_ischiocavernosus_21924_ID"
    ],
    "21930": [
        "External_Anal_Sphincter_21930_ID"
    ],
    "22109": [
        "Right_Tibial_nerve_22109_ID"
    ],
    "22110": [
        "Left_Tibial_nerve_22110_ID"
    ],
    "22111": [
        "Right_sciatic_nerve_22111_ID"
    ],
    "22112": [
        "Left_sciatic_nerve_22112_ID"
    ],
    "22171": [
        "Right_inferior_ulnar_collateral_artery_22171_ID"
    ],
    "22172": [
        "right_inferior_ulnar_collateral_artery_22172_ID",
        "left_inferior_ulnar_collateral_artery_22172_ID"
    ],
    "22322": [
        "Right_Iliacus_22322_ID"
    ],
    "22323": [
        "Left_Iliacus_22323_ID"
    ],
    "22324": [
        "Right_Obturator_Internus_22324_ID"
    ],
    "22325": [
        "Left_Obturator_Internus_22325_ID"
    ],
    "22326": [
        "Right_Obturator_externus_22326_ID"
    ],
    "22327": [
        "Left_Obturator_externus_22327_ID"
    ],
    "22328": [
        "Right_gluteus_maximus_22328_ID"
    ],
    "22329": [
        "Left_gluteus_maximus_22329_ID"
    ],
    "22330": [
        "Right_gluteus_medius_22330_ID"
    ],
    "22331": [
        "Left_gluteus_medius_22331_ID"
    ],
    "22332": [
        "Right_Gluteus_minimus_22332_ID"
    ],
    "22333": [
        "Left_Gluteus_minimus_22333_ID"
    ],
    "22334": [
        "Right_superior_gemellus_22334_ID"
    ],
    "22335": [
        "Left_superior_gemellus_22335_ID"
    ],
    "22336": [
        "Right_inferior_gemellus_22336_ID"
    ],
    "22337": [
        "Left_inferior_gemellus_22337_ID"
    ],
    "22338": [
        "Right_Quadratus_femoris_22338_ID"
    ],
    "22339": [
        "Left_Quadratus_femoris_22339_ID"
    ],
    "22340": [
        "Right_Piriformis_22340_ID"
    ],
    "22341": [
        "Left_Piriformis_22341_ID"
    ],
    "22342": [
        "Right_Psoas_Major_22342_ID"
    ],
    "22343": [
        "Left_Psoas_Major_22343_ID"
    ],
    "22344": [
        "Right_Transversus_abdominis_22344_ID"
    ],
    "22345": [
        "Left_Transversus_abdominis_22345_ID"
    ],
    "22348": [
        "Right_Quadratus_lumborum_22348_ID"
    ],
    "22349": [
        "Left_Quadratus_lumborum_22349_ID"
    ],
    "22351": [
        "Right_Psoas_Minor_22351_ID"
    ],
    "22352": [
        "Left_Psoas_Minor_22352_ID"
    ],
    "22354": [
        "Right_Sartorius_22354_ID"
    ],
    "22355": [
        "Left_Sartorius_22355_ID"
    ],
    "22358": [
        "Right_Semitendinosus_22358_ID"
    ],
    "22359": [
        "Left_Semitendinosus_22359_ID"
    ],
    "22360": [
        "Right_Biceps_Femoris_22360_ID"
    ],
    "22361": [
        "Left_Biceps_Femoris_22361_ID"
    ],
    "22425": [
        "Right_Tensor_Fasciae_Latae_22425_ID"
    ],
    "22426": [
        "Left_Tensor_Fasciae_Latae_22426_ID"
    ],
    "22444": [
        "Right_quadriceps_femoris_22444_ID"
    ],
    "22445": [
        "Left_quadriceps_femoris_22445_ID"
    ],
    "22446": [
        "Right_Articularis_Genus_22446_ID"
    ],
    "22447": [
        "Left_Articularis_Genus_22447_ID"
    ],
    "22448": [
        "Right_Semimembranosus_22448_ID"
    ],
    "22449": [
        "Left_Semimembranosus_22449_ID"
    ],
    "22450": [
        "Right_Pectineus_22450_ID"
    ],
    "22451": [
        "Left_Pectineus_22451_ID"
    ],
    "22456": [
        "Right_Adductor_Longus_22456_ID"
    ],
    "22457": [
        "Right_Adductor_Longus_22457_ID",
        "Left_Adductor_Longus_22457_ID"
    ],
    "22458": [
        "Left_Adductor_Longus_22458_ID"
    ],
    "22459": [
        "Right_Adductor_Magnus_22459_ID"
    ],
    "22460": [
        "Left_Adductor_Magnus_22460_ID"
    ],
    "22507": [
        "Right_descending_genicular_artery_22507_ID"
    ],
    "22508": [
        "Left_descending_genicular_artery_22508_ID"
    ],
    "22539": [
        "Right_Fibularis_tertius_22539_ID",
        "Left_Fibularis_tertius_22539_ID"
    ],
    "22545": [
        "Right_Tibialis_anterior_22545_ID",
        "Left_Tibialis_anterior_22545_ID"
    ],
    "22547": [
        "Left_Extensor_hallucis_longus_22547_ID",
        "Right_Extensor_hallucis_longus_22547_ID"
    ],
    "22548": [
        "Right_Extensor_hallucis_longus_22548_ID",
        "Left_Extensor_hallucis_longus_22548_ID"
    ],
    "22549": [
        "Right_extensor_digitorum_longus_22549_ID",
        "Left_extensor_digitorum_longus_22549_ID"
    ],
    "22551": [
        "Right_Fibularis_tertius_22551_ID",
        "Left_Fibularis_tertius_22551_ID"
    ],
    "22553": [
        "Right_Fibularis_longus_22553_ID",
        "Left_Fibularis_longus_22553_ID"
    ],
    "22555": [
        "Left_Fibularis_brevis_22555_ID",
        "Right_Fibularis_brevis_22555_ID"
    ],
    "22556": [
        "Right_Gastrocnemius_22556_ID"
    ],
    "22557": [
        "Left_Gastrocnemius_22557_ID"
    ],
    "22559": [
        "Right_Soleus_22559_ID",
        "Left_Soleus_22559_ID"
    ],
    "22561": [
        "Left_Plantaris_22561_ID",
        "Right_Plantaris_22561_ID"
    ],
    "22586": [
        "Right_superior_medial_genicular_artery_22586_ID"
    ],
    "22587": [
        "Left_superior_medial_genicular_artery_22587_ID"
    ],
    "22588": [
        "Right_superior_lateral_genicular_artery_22588_ID"
    ],
    "22589": [
        "Left_superior_lateral_genicular_artery_22589_ID"
    ],
    "22592": [
        "Right_Popliteus_22592_ID",
        "Left_Popliteus_22592_ID"
    ],
    "22655": [
        "Right_Axillary_artery_22655_ID"
    ],
    "22656": [
        "Left_Axillary_artery_22656_ID",
        "Right_Axillary_artery_22656_ID"
    ],
    "22669": [
        "right_superior_thoracic_artery_22669_ID"
    ],
    "22670": [
        "left_superior_thoracic_artery_22670_ID"
    ],
    "22675": [
        "Right_lateral_thoracic_artery_22675_ID"
    ],
    "22676": [
        "right_lateral_thoracic_artery_22676_ID",
        "left_lateral_thoracic_artery_22676_ID"
    ],
    "22679": [
        "Right_subscapular_artery_22679_ID"
    ],
    "22680": [
        "left_subscapular_artery_22680_ID",
        "right_subscapular_artery_22680_ID"
    ],
    "22682": [
        "Right_anterior_humeral_circumflex_artery_22682_ID"
    ],
    "22683": [
        "right_anterior_humeral_circumflex_artery_22683_ID",
        "left_anterior_humeral_circumflex_artery_22683_ID"
    ],
    "22686": [
        "Right_posterior_humeral_circumflex_artery_22686_ID"
    ],
    "22687": [
        "left_posterior_humeral_circumflex_artery_22687_ID",
        "right_posterior_humeral_circumflex_artery_22687_ID"
    ],
    "22691": [
        "Right_brachial_artery_22691_ID"
    ],
    "22692": [
        "right_brachial_artery_22692_ID",
        "left_brachial_artery_22692_ID"
    ],
    "22696": [
        "Right_deep_brachial_artery_22696_ID"
    ],
    "22697": [
        "right_deep_brachial_artery_22697_ID",
        "left_deep_brachial_artery_22697_ID"
    ],
    "22707": [
        "Right_superior_ulnar_collateral_artery_22707_ID"
    ],
    "22708": [
        "right_superior_ulnar_collateral_artery_22708_ID",
        "left_superior_ulnar_collateral_artery_22708_ID"
    ],
    "22726": [
        "Right_Splenius_cervicis_22726_ID"
    ],
    "22727": [
        "Left_Splenius_cervicis_22727_ID"
    ],
    "22728": [
        "Right_Splenius_capitis_22728_ID"
    ],
    "22729": [
        "Left_Splenius_capitis_22729_ID"
    ],
    "22733": [
        "Right_radial_artery_22733_ID"
    ],
    "22734": [
        "Right_radial_artery_22734_ID",
        "Left_radial_artery_22734_ID"
    ],
    "22740": [
        "Right_Iliocostalis_Lumborum_22740_ID"
    ],
    "22741": [
        "Left_Iliocostalis_Lumborum_22741_ID"
    ],
    "22742": [
        "Right_Iliocostalis_Thoracis_22742_ID"
    ],
    "22743": [
        "Left_Iliocostalis_Thoracis_22743_ID"
    ],
    "22744": [
        "Right_Iliocostalis_Cervicis_22744_ID"
    ],
    "22745": [
        "Left_Iliocostalis_Cervicis_22745_ID"
    ],
    "22751": [
        "Right_Longissimus_Thoracis_22751_ID"
    ],
    "22753": [
        "Left_Longissimus_Thoracis_22753_ID"
    ],
    "22754": [
        "Right_Longissimus_Capitis_22754_ID"
    ],
    "22756": [
        "Left_Longissimus_Capitis_22756_ID"
    ],
    "22757": [
        "Right_Longissimus_Cervicis_22757_ID"
    ],
    "22758": [
        "Left_Longissimus_Cervicis_22758_ID"
    ],
    "22765": [
        "Right_radial_recurrent_artery_22765_ID"
    ],
    "22766": [
        "left_radial_recurrent_artery_22766_ID",
        "right_radial_recurrent_artery_22766_ID"
    ],
    "22772": [
        "dorsal_carpal_branch_of_Right_radial_artery_22772_ID"
    ],
    "22773": [
        "dorsal_carpal_branch_of_left_radial_artery_22773_ID",
        "dorsal_carpal_branch_of_right_radial_artery_22773_ID"
    ],
    "22779": [
        "Right_Spinalis_Thoracis_22779_ID"
    ],
    "22780": [
        "Left_Spinalis_Thoracis_22780_ID"
    ],
    "22781": [
        "Right_Spinalis_Cervicis_22781_ID"
    ],
    "22782": [
        "Left_Spinalis_Cervicis_22782_ID"
    ],
    "22783": [
        "Right_Spinalis_Capitis_22783_ID"
    ],
    "22784": [
        "Left_Spinalis_Capitis_22784_ID"
    ],
    "22798": [
        "Right_ulnar_artery_22798_ID",
        "Left_ulnar_artery_22798_ID"
    ],
    "22801": [
        "Right_anterior_ulnar_recurrent_artery_22801_ID"
    ],
    "22802": [
        "right_anterior_ulnar_recurrent_artery_22802_ID",
        "left_anterior_ulnar_recurrent_artery_22802_ID"
    ],
    "22804": [
        "Right_posterior_ulnar_recurrent_artery_22804_ID"
    ],
    "22805": [
        "right_posterior_ulnar_recurrent_artery_22805_ID",
        "left_posterior_ulnar_recurrent_artery_22805_ID"
    ],
    "22807": [
        "Right_common_interosseous_artery_22807_ID"
    ],
    "22808": [
        "left_common_interosseous_artery_22808_ID",
        "right_common_interosseous_artery_22808_ID"
    ],
    "22812": [
        "Right_anterior_interosseous_artery_22812_ID"
    ],
    "22813": [
        "left_anterior_interosseous_artery_22813_ID",
        "right_anterior_interosseous_artery_22813_ID"
    ],
    "22821": [
        "dorsal_carpal_branch_of_Right_ulnar_artery_22821_ID"
    ],
    "22822": [
        "dorsal_carpal_branch_of_left_ulnar_artery_22822_ID",
        "dorsal_carpal_branch_of_right_ulnar_artery_22822_ID"
    ],
    "22836": [
        "Right_superficial_palmar_arch_22836_ID"
    ],
    "22837": [
        "left_superficial_palmar_arch_22837_ID",
        "right_superficial_palmar_arch_22837_ID"
    ],
    "22839": [
        "Right_deep_palmar_arterial_arch_22839_ID"
    ],
    "22840": [
        "left_deep_palmar_venous_arch_22840_ID",
        "right_deep_palmar_venous_arch_22840_ID",
        "right_deep_palmar_arterial_arch_22840_ID",
        "left_deep_palmar_arterial_arch_22840_ID",
        "right_deep_palmar_arch_22840_ID",
        "left_deep_palmar_arch_22840_ID"
    ],
    "22872": [
        "Right_Semispinalis_thoracis_22872_ID"
    ],
    "22873": [
        "Left_Semispinalis_thoracis_22873_ID"
    ],
    "22874": [
        "Right_Semispinalis_cervicis_22874_ID"
    ],
    "22875": [
        "Left_Semispinalis_cervicis_22875_ID"
    ],
    "22876": [
        "Right_Semispinalis_capitis_22876_ID"
    ],
    "22877": [
        "Left_Semispinalis_capitis_22877_ID"
    ],
    "22878": [
        "Right_Multifidus_22878_ID"
    ],
    "22879": [
        "Left_Multifidus_22879_ID"
    ],
    "22909": [
        "Right_basilic_vein_22909_ID"
    ],
    "22910": [
        "right_basilic_vein_22910_ID",
        "left_basilic_vein_22910_ID",
        "Left_basilic_vein_22910_ID"
    ],
    "22920": [
        "Right_palmar_metacarpal_veins_22920_ID"
    ],
    "22921": [
        "right_palmar_metacarpal_veins_22921_ID",
        "left_palmar_metacarpal_veins_22921_ID"
    ],
    "22935": [
        "Right_medial_brachial_vein_22935_ID"
    ],
    "22936": [
        "right_medial_brachial_vein_22936_ID",
        "left_medial_brachial_vein_22936_ID"
    ],
    "22948": [
        "Right_radial_vein_22948_ID"
    ],
    "22949": [
        "left_radial_vein_22949_ID",
        "right_radial_vein_22949_ID"
    ],
    "22951": [
        "right_ulnar_vein_22951_ID"
    ],
    "22952": [
        "right_ulnar_vein_22952_ID",
        "left_ulnar_vein_22952_ID"
    ],
    "22964": [
        "Right_median_cubital_vein_22964_ID"
    ],
    "22965": [
        "right_median_cubital_vein_22965_ID",
        "left_median_cubital_vein_22965_ID"
    ],
    "22968": [
        "Right_median_antebrachial_vein_22968_ID"
    ],
    "22969": [
        "left_median_antebrachial_vein_22969_ID",
        "right_median_antebrachial_vein_22969_ID"
    ],
    "23111": [
        "Right_deep_dorsal_vein_23111_ID"
    ],
    "23112": [
        "right_deep_dorsal_vein_23112_ID",
        "left_deep_dorsal_vein_23112_ID"
    ],
    "23123": [
        "Right_medial_collateral_artery_23123_ID"
    ],
    "23124": [
        "right_medial_collateral_artery_23124_ID",
        "left_medial_collateral_artery_23124_ID"
    ],
    "23126": [
        "Right_radial_collateral_artery_23126_ID"
    ],
    "23127": [
        "right_radial_collateral_artery_23127_ID",
        "left_radial_collateral_artery_23127_ID"
    ],
    "23130": [
        "Right_Humerus_23130_ID",
        "Left_Humerus_23130_ID"
    ],
    "23180": [
        "Right_circumflex_scapular_artery_23180_ID"
    ],
    "23181": [
        "right_circumflex_scapular_artery_23181_ID",
        "left_circumflex_scapular_artery_23181_ID"
    ],
    "23464": [
        "Left_radius_23464_ID",
        "Right_radius_23464_ID"
    ],
    "23467": [
        "Left_Ulna_23467_ID",
        "Right_Ulna_23467_ID"
    ],
    "23707": [
        "Right_Interosseous_membrane_23707_ID"
    ],
    "23708": [
        "Left_Interosseous_membrane_23708_ID"
    ],
    "24160": [
        "Bones_of_the_Right_Arm_24160_ID"
    ],
    "24162": [
        "Bones_of_the_Left_Arm_24162_ID"
    ],
    "24435": [
        "Right_scaphoid_bone_24435_ID",
        "Left_scaphoid_bone_24435_ID"
    ],
    "24437": [
        "Left_lunate_bone_24437_ID",
        "Right_lunate_bone_24437_ID"
    ],
    "24439": [
        "Left_triquetral_bone_24439_ID",
        "Right_triquetral_bone_24439_ID"
    ],
    "24441": [
        "Right_pisiform_24441_ID",
        "Left_pisiform_24441_ID"
    ],
    "24443": [
        "Right_trapezium_24443_ID",
        "Left_trapezium_24443_ID"
    ],
    "24444": [
        "Right_trapezoid_bone_24444_ID",
        "Left_trapezoid_bone_24444_ID"
    ],
    "24446": [
        "Right_capitate_bone_24446_ID",
        "Left_capitate_bone_24446_ID"
    ],
    "24448": [
        "Left_hamate_bone_24448_ID",
        "Right_hamate_bone_24448_ID"
    ],
    "24474": [
        "Right_femur_24474_ID"
    ],
    "24475": [
        "Left_femur_24475_ID"
    ],
    "24477": [
        "Right_tibia_24477_ID"
    ],
    "24478": [
        "Right_tibia_24478_ID",
        "Left_tibia_24478_ID"
    ],
    "24480": [
        "Right_fibula_24480_ID"
    ],
    "24481": [
        "Right_fibula_24481_ID",
        "Left_fibula_24481_ID"
    ],
    "24482": [
        "Right_talus_24482_ID"
    ],
    "24483": [
        "Right_talus_24483_ID",
        "Left_talus_24483_ID"
    ],
    "24486": [
        "Right_patella_24486_ID"
    ],
    "24487": [
        "Right_patella_24487_ID",
        "Left_patella_24487_ID"
    ],
    "24497": [
        "Right_calcaneus_24497_ID"
    ],
    "24498": [
        "Right_calcaneus_24498_ID",
        "Left_calcaneus_24498_ID"
    ],
    "24500": [
        "Navicular_bone_of_right_foot_24500_ID"
    ],
    "24501": [
        "Navicular_of_right_foot_24501_ID",
        "Navicular_of_left_foot_24501_ID",
        "Navicular_bone_of_left_foot_24501_ID"
    ],
    "24521": [
        "Right_medial_Cuneiform_bone_24521_ID"
    ],
    "24522": [
        "Left_medial_Cuneiform_bone_24522_ID",
        "Right_medial_Cuneiform_bone_24522_ID"
    ],
    "24523": [
        "Right_intermediate_Cuneiform_bone_24523_ID"
    ],
    "24524": [
        "Right_intermediate_Cuneiform_bone_24524_ID",
        "Left_intermediate_Cuneiform_bone_24524_ID"
    ],
    "24525": [
        "Right_lateral_Cuneiform_bone_24525_ID"
    ],
    "24526": [
        "Right_lateral_Cuneiform_bone_24526_ID",
        "Left_lateral_Cuneiform_bone_24526_ID"
    ],
    "24528": [
        "Right_cuboid_bone_24528_ID"
    ],
    "24529": [
        "Left_cuboid_bone_24529_ID",
        "Right_cuboid_bone_24529_ID"
    ],
    "25005": [
        "Anterior_atlanto_occipital_membrane_25005_ID",
        "Anterior_atlantooccipital_membrane_25005_ID"
    ],
    "29711": [
        "Prostatic_venous_plexus_29711_ID"
    ],
    "31893": [
        "Anterior_longitudinal_ligament_31893_ID"
    ],
    "32530": [
        "Right_Rectus_capitis_posterior_major_32530_ID"
    ],
    "32531": [
        "Left_Rectus_Capitis_posterior_major_32531_ID"
    ],
    "32532": [
        "Right_Rectus_capitis_posterior_minor_32532_ID"
    ],
    "32533": [
        "Left_Rectus_capitis_posterior_minor_32533_ID",
        "Right_Rectus_Capitis_posterior_major_32533_ID"
    ],
    "32535": [
        "Right_Rectus_capitis_posterior_minor_32535_ID"
    ],
    "32540": [
        "Right_Levator_Scapulae_32540_ID",
        "Right_Levator_scapulae_32540_ID"
    ],
    "32541": [
        "Left_Levator_scapulae_32541_ID"
    ],
    "32542": [
        "Right_Deltoid_32542_ID"
    ],
    "32543": [
        "Left_Deltoid_32543_ID",
        "Right_Deltoid_32543_ID"
    ],
    "32544": [
        "Right_supraspinatus_32544_ID",
        "Right_Supraspinatus_32544_ID"
    ],
    "32545": [
        "Left_Supraspinatus_32545_ID"
    ],
    "32547": [
        "Right_infraspinatus_32547_ID"
    ],
    "32548": [
        "Left_infraspinatus_32548_ID"
    ],
    "32551": [
        "Right_Teres_Major_32551_ID"
    ],
    "32552": [
        "Left_Teres_Major_32552_ID"
    ],
    "32553": [
        "Right_teres_minor_32553_ID"
    ],
    "32554": [
        "Left_teres_minor_32554_ID"
    ],
    "33098": [
        "Right_Rotatores_short_fibers_33098_ID",
        "Right_Rotatores_long_fibers_33098_ID"
    ],
    "33099": [
        "Left_Rotatores_long_fibers_33099_ID",
        "Left_Rotatores_short_fibers_33099_ID"
    ],
    "33520": [
        "Right_pectoral_girdle_muscles_33520_ID"
    ],
    "33521": [
        "Left_pectoral_girdle_muscles_33521_ID",
        "Right_pectoral_girdle_muscles_33521_ID"
    ],
    "37318": [
        "Right_ulnar_nerve_37318_ID"
    ],
    "37319": [
        "Left_ulnar_nerve_37319_ID"
    ],
    "37386": [
        "Right_Abductor_pollicis_brevis_37386_ID"
    ],
    "37387": [
        "Left_Abductor_pollicis_brevis_37387_ID"
    ],
    "37388": [
        "Right_Flexor_pollicis_brevis_37388_ID"
    ],
    "37389": [
        "Left_Flexor_pollicis_brevis_37389_ID"
    ],
    "37390": [
        "Right_Opponens_pollicis_37390_ID"
    ],
    "37391": [
        "Left_Opponens_pollicis_37391_ID"
    ],
    "37392": [
        "Right_Adductor_pollicis_37392_ID"
    ],
    "37393": [
        "Left_Adductor_pollicis_37393_ID",
        "Right_Palmaris_brevis_37393_ID"
    ],
    "37395": [
        "Left_Palmaris_brevis_37395_ID"
    ],
    "37396": [
        "Right_Abductor_digiti_minimi_37396_ID"
    ],
    "37397": [
        "Left_Abductor_digiti_minimi_37397_ID"
    ],
    "37398": [
        "Right_Flexor_digiti_minimi_brevis_37398_ID"
    ],
    "37399": [
        "Left_Flexor_digiti_minimi_brevis_37399_ID"
    ],
    "37400": [
        "Right_Opponens_digiti_minimi_37400_ID"
    ],
    "37401": [
        "Left_Opponens_digiti_minimi_37401_ID"
    ],
    "37460": [
        "Right_Abductor_hallucis_37460_ID",
        "Left_Abductor_hallucis_37460_ID"
    ],
    "37462": [
        "Right_Flexor_digiti_minimi_brevis_37462_ID",
        "Left_Flexor_digiti_minimi_brevis_37462_ID"
    ],
    "37464": [
        "Abductor_digiti_minimi_of_right_foot_37464_ID",
        "Abductor_digiti_minimi_of_left_foot_37464_ID"
    ],
    "37468": [
        "Left_Flexor_hallucis_brevis_37468_ID",
        "Right_Flexor_hallucis_brevis_37468_ID"
    ],
    "37470": [
        "Left_Adductor_hallucis_37470_ID",
        "Left_Adductor_hallucis_oblique_head_37470_ID",
        "Left_Adductor_hallucis_transverse_head_37470_ID",
        "Right_Adductor_hallucis_37470_ID",
        "Right_Adductor_hallucis_oblique_head_37470_ID",
        "Right_Adductor_hallucis_transverse_head_37470_ID"
    ],
    "37665": [
        "Right_Coracobrachialis_37665_ID"
    ],
    "37666": [
        "Left_Coracobrachialis_37666_ID",
        "Right_Coracobrachialis_37666_ID"
    ],
    "37668": [
        "Right_Brachialis_37668_ID"
    ],
    "37669": [
        "Left_Brachialis_37669_ID"
    ],
    "37671": [
        "Right_Biceps_Brachii_37671_ID"
    ],
    "37672": [
        "Right_Biceps_Brachii_37672_ID",
        "Left_Biceps_Brachii_37672_ID"
    ],
    "37689": [
        "Right_Triceps_Brachii_37689_ID"
    ],
    "37690": [
        "Right_Triceps_Brachii_37690_ID",
        "Left_Triceps_Brachii_37690_ID"
    ],
    "37705": [
        "Right_anconeus_37705_ID"
    ],
    "37706": [
        "Left_anconeus_37706_ID",
        "Right_anconeus_37706_ID"
    ],
    "38451": [
        "Right_Pronator_teres_38451_ID"
    ],
    "38452": [
        "Left_Pronator_teres_38452_ID"
    ],
    "38454": [
        "Right_Pronator_quadratus_38454_ID"
    ],
    "38455": [
        "Left_Pronator_quadratus_38455_ID"
    ],
    "38460": [
        "Right_Flexor_carpi_radialis_longus_38460_ID"
    ],
    "38461": [
        "Left_Flexor_carpi_radialis_longus_38461_ID"
    ],
    "38463": [
        "Right_Palmaris_longus_38463_ID"
    ],
    "38464": [
        "Left_Palmaris_longus_38464_ID"
    ],
    "38466": [
        "Right_Flexor_carpi_ulnaris_38466_ID"
    ],
    "38467": [
        "Left_Flexor_carpi_ulnaris_38467_ID"
    ],
    "38483": [
        "Right_flexor_pollicis_longus_38483_ID"
    ],
    "38484": [
        "Left_flexor_pollicis_longus_38484_ID"
    ],
    "38486": [
        "Right_Brachioradialis_38486_ID"
    ],
    "38487": [
        "Left_Brachioradialis_38487_ID"
    ],
    "38495": [
        "Right_Extensor_carpi_radialis_longus_38495_ID"
    ],
    "38496": [
        "Left_Extensor_carpi_radialis_longus_38496_ID"
    ],
    "38498": [
        "Right_Extensor_carpi_radialis_brevis_38498_ID"
    ],
    "38499": [
        "Left_Extensor_carpi_radialis_brevis_38499_ID"
    ],
    "38504": [
        "Right_Extensor_digiti_minimi_38504_ID"
    ],
    "38505": [
        "Left_Extensor_digiti_minimi_38505_ID"
    ],
    "38507": [
        "Right_Extensor_carpi_ulnaris_38507_ID"
    ],
    "38508": [
        "Left_Extensor_carpi_ulnaris_38508_ID"
    ],
    "38513": [
        "Right_Supinator_38513_ID"
    ],
    "38514": [
        "Left_Supinator_38514_ID"
    ],
    "38516": [
        "Right_Abductor_pollicis_longus_38516_ID"
    ],
    "38517": [
        "Left_Abductor_pollicis_longus_38517_ID"
    ],
    "38519": [
        "Right_Extensor_pollicis_brevis_38519_ID"
    ],
    "38520": [
        "Left_Extensor_pollicis_brevis_38520_ID"
    ],
    "38522": [
        "Right_Extensor_pollicis_longus_38522_ID"
    ],
    "38523": [
        "Left_Extensor_pollicis_longus_38523_ID"
    ],
    "38525": [
        "Right_Extensor_indicis_38525_ID"
    ],
    "38526": [
        "Left_Extensor_indicis_38526_ID"
    ],
    "38928": [
        "Right_Rectus_Femoris_38928_ID"
    ],
    "38929": [
        "Left_Rectus_Femoris_38929_ID"
    ],
    "38930": [
        "Right_Vastus_Lateralis_38930_ID"
    ],
    "38931": [
        "Left_Vastus_Lateralis_38931_ID"
    ],
    "38932": [
        "Right_Vastus_Medialis_38932_ID"
    ],
    "38933": [
        "Left_Vastus_Medialis_38933_ID"
    ],
    "38934": [
        "Right_Vastus_Intermedius_38934_ID"
    ],
    "38935": [
        "Left_Vastus_Intermedius_38935_ID"
    ],
    "39091": [
        "Left_forearm_muscles_39091_ID"
    ],
    "39092": [
        "Right_forearm_muscles_39092_ID"
    ],
    "39987": [
        "Right_Extensor_retinaculum_of_hand_39987_ID",
        "Left_Extensor_retinaculum_of_hand_39987_ID"
    ],
    "39988": [
        "Right_Flexor_retinaculum_of_hand_39988_ID",
        "Left_Flexor_retinaculum_of_hand_39988_ID"
    ],
    "42313": [
        "Right_Pisohamate_Ligament_42313_ID",
        "Left_Pisohamate_Ligament_42313_ID"
    ],
    "42369": [
        "Right_hand_muscles_42369_ID"
    ],
    "42370": [
        "Left_hand_muscles_42370_ID"
    ],
    "43883": [
        "Right_Gracilis_43883_ID"
    ],
    "43884": [
        "Left_Gracilis_43884_ID"
    ],
    "43890": [
        "Right_inferior_medial_genicular_artery_43890_ID"
    ],
    "43891": [
        "Left_inferior_medial_genicular_artery_43891_ID",
        "Right_inferior_medial_genicular_artery_43891_ID"
    ],
    "43892": [
        "Right_inferior_lateral_genicular_artery_43892_ID"
    ],
    "43893": [
        "Left_inferior_lateral_genicular_artery_43893_ID"
    ],
    "43896": [
        "Right_anterior_tibial_artery_43896_ID"
    ],
    "43897": [
        "Right_anterior_tibial_artery_43897_ID",
        "Left_anterior_tibial_artery_43897_ID"
    ],
    "43898": [
        "Left_anterior_tibial_artery_43898_ID",
        "Right_posterior_tibial_artery_43898_ID"
    ],
    "43899": [
        "Left_posterior_tibial_artery_43899_ID"
    ],
    "43907": [
        "Right_anterior_tibial_recurrent_artery_43907_ID"
    ],
    "43908": [
        "Left_anterior_tibial_recurrent_artery_43908_ID"
    ],
    "43916": [
        "Right_dorsalis_pedis_artery_43916_ID"
    ],
    "43917": [
        "Left_dorsalis_pedis_artery_43917_ID"
    ],
    "43922": [
        "Right_fibular_artery_43922_ID"
    ],
    "43923": [
        "Left_fibular_artery_43923_ID"
    ],
    "43929": [
        "Right_medial_plantar_artery_43929_ID"
    ],
    "43930": [
        "Left_medial_plantar_artery_43930_ID"
    ],
    "43931": [
        "Right_lateral_plantar_artery_43931_ID"
    ],
    "43932": [
        "Left_lateral_plantar_artery_43932_ID"
    ],
    "43935": [
        "Right_deep_medial_plantar_artery_43935_ID"
    ],
    "43936": [
        "Left_deep_medial_plantar_artery_43936_ID"
    ],
    "43943": [
        "Right_plantar_arch_43943_ID"
    ],
    "43944": [
        "Left_plantar_arch_43944_ID"
    ],
    "43950": [
        "Calcaneal_branch_of_right_fibular_artery_43950_ID"
    ],
    "43951": [
        "Calcaneal_branch_of_left_fibular_artery_43951_ID"
    ],
    "44227": [
        "Left_Popliteal_Lymph_Nodes_44227_ID",
        "Right_Popliteal_Lymph_Nodes_44227_ID"
    ],
    "44249": [
        "Right_Long_plantar_ligament_44249_ID",
        "Left_Long_plantar_ligament_44249_ID"
    ],
    "44310": [
        "Lymphatics_of_the_Lower_Limb_44310_ID"
    ],
    "44326": [
        "Descending_branch_of_right_lateral_circumflex_femoral_Vein_44326_ID"
    ],
    "44327": [
        "Descending_branch_of_left_lateral_circumflex_femoral_Vein_44327_ID"
    ],
    "44328": [
        "Right_Popliteal_vein_44328_ID"
    ],
    "44329": [
        "Left_Popliteal_vein_44329_ID"
    ],
    "44334": [
        "Right_small_saphenous_vein_44334_ID"
    ],
    "44335": [
        "Left_small_saphenous_vein_44335_ID"
    ],
    "44336": [
        "Right_Anterior_Tibial_Vein_44336_ID"
    ],
    "44337": [
        "Left_Anterior_Tibial_Vein_44337_ID"
    ],
    "44338": [
        "Right_Posterior_Tibial_Vein_44338_ID"
    ],
    "44339": [
        "Left_Posterior_Tibial_Vein_44339_ID"
    ],
    "44340": [
        "Right_superficial_epigastric_vein_44340_ID"
    ],
    "44341": [
        "Left_superficial_epigastric_vein_44341_ID"
    ],
    "44583": [
        "Right_Oblique_Popliteal_Ligament_44583_ID"
    ],
    "44584": [
        "Left_Oblique_Popliteal_Ligament_44584_ID"
    ],
    "44585": [
        "Right_Patellar_Ligament_44585_ID"
    ],
    "44586": [
        "Left_Patellar_Ligament_44586_ID"
    ],
    "44597": [
        "Right_Arcuate_Popliteal_Ligament_44597_ID"
    ],
    "44599": [
        "Left_Arcuate_Popliteal_Ligament_44599_ID"
    ],
    "44601": [
        "Right_Tibial_Collateral_Ligament_44601_ID"
    ],
    "44602": [
        "Left_Tibial_Collateral_Ligament_44602_ID"
    ],
    "44609": [
        "Right_Fibular_Collateral_Ligament_44609_ID"
    ],
    "44610": [
        "Left_Fibular_Collateral_Ligament_44610_ID"
    ],
    "44615": [
        "Right_Anterior_Cruciate_Ligament_44615_ID"
    ],
    "44616": [
        "Left_Anterior_Cruciate_Ligament_44616_ID"
    ],
    "44618": [
        "Right_Posterior_Cruciate_Ligament_44618_ID"
    ],
    "44619": [
        "Left_Posterior_Cruciate_Ligament_44619_ID"
    ],
    "44741": [
        "Right_proper_plantar_digital_nerves_44741_ID"
    ],
    "44742": [
        "Left_proper_plantar_digital_nerves_44742_ID"
    ],
    "44874": [
        "Right_dorsal_branch_of_ulnar_nerve_44874_ID"
    ],
    "44875": [
        "Left_dorsal_branch_of_ulnar_nerve_44875_ID"
    ],
    "44881": [
        "Branch_of_Dorsal_venous_arch_of_Right_foot_44881_ID",
        "Right_Dorsalis_pedis_vein_44881_ID",
        "Dorsal_venous_arch_of_Right_foot_44881_ID"
    ],
    "44882": [
        "Branch_of_Dorsal_venous_arch_of_Left_foot_44882_ID",
        "Dorsal_venous_arch_of_Left_foot_44882_ID",
        "Left_Dorsalis_pedis_vein_44882_ID"
    ],
    "44883": [
        "Medial_branch_of_Plantar_venous_arch_of_right_foot_44883_ID",
        "Plantar_venous_arch_of_Right_foot_44883_ID",
        "Lateral_branch_of_Plantar_venous_arch_of_right_foot_44883_ID"
    ],
    "44884": [
        "Medial_branch_of_Plantar_venous_arch_of_left_foot_44884_ID",
        "Lateral_branch_of_Plantar_venous_arch_of_left_foot_44884_ID",
        "Plantar_venous_arch_of_Left_foot_44884_ID"
    ],
    "44885": [
        "Right_Fibular_vein_44885_ID"
    ],
    "44886": [
        "Left_Fibular_vein_44886_ID"
    ],
    "44887": [
        "Right_Superior_Medial_Genicular_vein_44887_ID",
        "Right_Genicular_Veins_44887_ID",
        "Right_Inferior_Medial_Genicular_Vein_44887_ID",
        "Right_Superior_Lateral_Genicular_vein_44887_ID",
        "Right_Inferior_Lateral_Genicular_Vein_44887_ID"
    ],
    "44888": [
        "Left_Inferior_Lateral_Genicular_Vein_44888_ID",
        "Left_Genicular_Veins_44888_ID",
        "Left_Inferior_Medial_Genicular_Vein_44888_ID",
        "Left_Superior_Medial_Genicular_vein_44888_ID",
        "Left_Superior_Lateral_Genicular_vein_44888_ID"
    ],
    "44918": [
        "Right_medial_circumflex_femoral_vein_44918_ID"
    ],
    "44919": [
        "Left_medial_circumflex_femoral_vein_44919_ID"
    ],
    "44920": [
        "Right_lateral_circumflex_femoral_vein_44920_ID"
    ],
    "44922": [
        "Left_lateral_circumflex_femoral_vein_44922_ID"
    ],
    "45257": [
        "Right_Intermediate_Femoral_Cutaneous_Nerve_45257_ID"
    ],
    "45258": [
        "Left_Intermediate_Femoral_Cutaneous_Nerve_45258_ID"
    ],
    "45263": [
        "Right_saphenous_nerve_45263_ID"
    ],
    "45264": [
        "Left_saphenous_nerve_45264_ID"
    ],
    "45338": [
        "Right_Posterior_femoral_cutaneous_nerve_45338_ID"
    ],
    "45339": [
        "Left_Posterior_femoral_cutaneous_nerve_45339_ID"
    ],
    "45357": [
        "Right_common_fibular_nerve_45357_ID"
    ],
    "45358": [
        "Left_common_fibular_nerve_45358_ID"
    ],
    "45363": [
        "Right_superficial_fibular_nerve_45363_ID"
    ],
    "45364": [
        "Left_superficial_fibular_nerve_45364_ID"
    ],
    "45387": [
        "Right_deep_fibular_nerve_45387_ID"
    ],
    "45388": [
        "Left_deep_fibular_nerve_45388_ID"
    ],
    "45389": [
        "Right_Lateral_terminal_branch_of_deep_fibular_nerve_45389_ID"
    ],
    "45390": [
        "Left_Lateral_terminal_branch_of_deep_fibular_nerve_45390_ID"
    ],
    "45426": [
        "Right_sural_nerve_45426_ID"
    ],
    "45427": [
        "Left_sural_nerve_45427_ID"
    ],
    "45434": [
        "Right_medial_proper_plantar_nerve_45434_ID"
    ],
    "45435": [
        "Left_medial_proper_plantar_nerve_45435_ID"
    ],
    "45450": [
        "Right_lateral_plantar_nerve_45450_ID"
    ],
    "45451": [
        "Left_lateral_plantar_nerve_45451_ID"
    ],
    "45654": [
        "Female_Internal_Genitalia_45654_ID"
    ],
    "45739": [
        "Right_platysma_45739_ID"
    ],
    "45740": [
        "Left_platysma_45740_ID"
    ],
    "45769": [
        "Internal_Urethral_Sphincter_45769_ID"
    ],
    "45826": [
        "Right_Stylohyoid_45826_ID"
    ],
    "45827": [
        "Left_Stylohyoid_45827_ID"
    ],
    "45858": [
        "Right_Iliococcygeus_45858_ID"
    ],
    "45859": [
        "Left_Iliococcygeus_45859_ID"
    ],
    "45890": [
        "Right_Biceps_Femoris_Short_Head_45890_ID"
    ],
    "45891": [
        "Left_Biceps_Femoris_Short_Head_45891_ID"
    ],
    "46283": [
        "Superior_oblique_part_of_right_longus_colli_46283_ID"
    ],
    "46284": [
        "Superior_oblique_part_of_left_longus_colli_46284_ID"
    ],
    "46285": [
        "Vertical_Intermediate_part_of_right_longus_colli_46285_ID"
    ],
    "46286": [
        "Vertical_Intermediate_part_of_left_longus_colli_46286_ID"
    ],
    "46287": [
        "Inferior_oblique_part_of_right_longus_colli_46287_ID"
    ],
    "46288": [
        "Inferior_oblique_part_of_left_longus_colli_46288_ID"
    ],
    "46292": [
        "Right_Digastric_46292_ID",
        "Right_Digastric_muscle_46292_ID"
    ],
    "46293": [
        "Left_Digastric_46293_ID",
        "Left_Digastric_muscle_46293_ID"
    ],
    "46309": [
        "Right_Longus_capitis_46309_ID"
    ],
    "46310": [
        "Left_Longus_capitis_46310_ID"
    ],
    "46313": [
        "Right_Rectus_capitis_anterior_46313_ID"
    ],
    "46314": [
        "Left_Rectus_capitis_anterior_46314_ID"
    ],
    "46317": [
        "Right_Rectus_capitis_lateralis_46317_ID"
    ],
    "46318": [
        "Right_Rectus_capitis_lateralis_46318_ID",
        "Left_Rectus_capitis_lateralis_46318_ID"
    ],
    "46319": [
        "Left_Rectus_capitis_lateralis_46319_ID"
    ],
    "46321": [
        "Right_Mylohyoid_muscle_46321_ID",
        "Right_Mylohyoid_Muscle_46321_ID"
    ],
    "46322": [
        "Left_Mylohyoid_46322_ID",
        "Left_Mylohyoid_Muscle_46322_ID"
    ],
    "46326": [
        "Right_Geniohyoid_46326_ID"
    ],
    "46327": [
        "Left_Geniohyoid_46327_ID"
    ],
    "46443": [
        "Right_Coccygeus_46443_ID"
    ],
    "46444": [
        "Left_Coccygeus_46444_ID"
    ],
    "46563": [
        "Vertical_part_of_left_cricothyroid_muscle_46563_ID",
        "Right_Cricothyroid_muscle_46563_ID",
        "Oblique_part_of_left_cricothyroid_muscle_46563_ID"
    ],
    "46564": [
        "Vertical_part_of_left_cricothyroid_muscle_46564_ID",
        "Left_Cricothyroid_muscle_46564_ID",
        "Oblique_part_of_left_cricothyroid_muscle_46564_ID"
    ],
    "46621": [
        "Superior_Pharyngeal_Constrictor_46621_ID"
    ],
    "46622": [
        "Middle_Pharyngeal_Constrictor_46622_ID"
    ],
    "46623": [
        "Inferior_Pharyngeal_Constrictor_46623_ID"
    ],
    "46690": [
        "Genioglossus_46690_ID"
    ],
    "46703": [
        "Right_Hyoglossus_46703_ID"
    ],
    "46704": [
        "Left_Hyoglossus_46704_ID"
    ],
    "46705": [
        "Right_Styloglossus_46705_ID"
    ],
    "46706": [
        "Right_Styloglossus_46706_ID",
        "Left_Styloglossus_46706_ID"
    ],
    "46759": [
        "Right_frontalis_46759_ID"
    ],
    "46760": [
        "Left_frontalis_46760_ID"
    ],
    "46761": [
        "Right_occipitalis_46761_ID"
    ],
    "46762": [
        "Left_occipitalis_46762_ID"
    ],
    "46768": [
        "Epicranial_aponeurosis_46768_ID"
    ],
    "46777": [
        "Depressor_septi_nasi_46777_ID"
    ],
    "46792": [
        "Right_orbicularis_oculi_46792_ID"
    ],
    "46793": [
        "Left_orbicularis_oculi_46793_ID"
    ],
    "46796": [
        "Right_corrugator_supercilii_46796_ID"
    ],
    "46797": [
        "Left_corrugator_supercilii_46797_ID"
    ],
    "46803": [
        "Right_levator_labii_superioris_alaeque_nasi_46803_ID"
    ],
    "46804": [
        "Left_levator_labii_superioris_alaeque_nasi_46804_ID"
    ],
    "46806": [
        "Right_levator_labii_superioris_46806_ID"
    ],
    "46807": [
        "Left_levator_labii_superioris_46807_ID"
    ],
    "46812": [
        "Right_zygomaticus_major_46812_ID"
    ],
    "46813": [
        "Left_zygomaticus_major_46813_ID"
    ],
    "46814": [
        "Right_zygomaticus_minor_46814_ID"
    ],
    "46815": [
        "Left_zygomaticus_minor_46815_ID"
    ],
    "46817": [
        "Right_depressor_labii_inferioris_46817_ID"
    ],
    "46818": [
        "Left_depressor_labii_inferioris_46818_ID"
    ],
    "46823": [
        "Right_levator_anguli_oris_46823_ID"
    ],
    "46824": [
        "Left_levator_anguli_oris_46824_ID"
    ],
    "46826": [
        "Right_mentalis_46826_ID"
    ],
    "46827": [
        "Left_mentalis_46827_ID"
    ],
    "46829": [
        "Right_depressor_anguli_oris_46829_ID"
    ],
    "46830": [
        "Left_depressor_anguli_oris_46830_ID"
    ],
    "46835": [
        "Right_buccinator_46835_ID"
    ],
    "46836": [
        "Left_buccinator_46836_ID"
    ],
    "46839": [
        "Right_risorius_46839_ID"
    ],
    "46840": [
        "Left_risorius_46840_ID"
    ],
    "46841": [
        "Orbicularis_oris_46841_ID"
    ],
    "48025": [
        "Left_Tendon_of_Digastric_48025_ID",
        "Right_Tendon_of_Digastric_48025_ID",
        "Right_Tendon_of_Digastric_Muscle_48025_ID",
        "Left_Tendon_of_Digastric_Muscle_48025_ID"
    ],
    "48957": [
        "Right_auricularis_superior_48957_ID"
    ],
    "48958": [
        "Left_auricularis_superior_48958_ID"
    ],
    "48959": [
        "Right_auricularis_anterior_48959_ID"
    ],
    "48960": [
        "Left_auricularis_anterior_48960_ID"
    ],
    "48961": [
        "Right_auricularis_posterior_48961_ID"
    ],
    "48962": [
        "Left_auricularis_posterior_48962_ID"
    ],
    "48997": [
        "Right_masseter_48997_ID"
    ],
    "48998": [
        "Left_masseter_48998_ID"
    ],
    "49007": [
        "Right_temporalis_49007_ID"
    ],
    "49008": [
        "Left_temporalis_49008_ID"
    ],
    "49012": [
        "Right_Medial_Pterygoid_49012_ID"
    ],
    "49013": [
        "Left_Medial_Pterygoid_49013_ID"
    ],
    "49016": [
        "Right_inferior_lateral_pterygoid_49016_ID",
        "Right_superior_lateral_pterygoid_49016_ID"
    ],
    "49017": [
        "Left_superior_lateral_pterygoid_49017_ID",
        "Left_inferior_lateral_pterygoid_49017_ID"
    ],
    "49036": [
        "Left_inferior_rectus_49036_ID"
    ],
    "49044": [
        "Right_superior_rectus_49044_ID"
    ],
    "49045": [
        "Left_superior_rectus_49045_ID"
    ],
    "49046": [
        "Right_inferior_rectus_49046_ID"
    ],
    "49047": [
        "Left_inferior_rectus_49047_ID"
    ],
    "49048": [
        "Right_levator_palpebrae_superioris_49048_ID"
    ],
    "49049": [
        "Left_levator_palpebrae_superioris_49049_ID"
    ],
    "49050": [
        "Right_inferior_oblique_49050_ID"
    ],
    "49051": [
        "Left_inferior_oblique_49051_ID"
    ],
    "49052": [
        "Right_superior_oblique_49052_ID"
    ],
    "49053": [
        "Left_superior_oblique_49053_ID"
    ],
    "49054": [
        "Right_lateral_rectus_49054_ID"
    ],
    "49055": [
        "Left_lateral_rectus_49055_ID"
    ],
    "49056": [
        "Right_medial_rectus_49056_ID"
    ],
    "49057": [
        "Left_medial_rectus_49057_ID"
    ],
    "49152": [
        "Right_Ciliary_Muscle_49152_ID"
    ],
    "49153": [
        "Left_Ciliary_Muscle_49153_ID"
    ],
    "49177": [
        "Upper_Gastrointestinal_Tract_49177_ID"
    ],
    "49386": [
        "Right_Inferior_extensor_retinaculum_49386_ID",
        "Left_Inferior_extensor_retinaculum_49386_ID"
    ],
    "49388": [
        "Right_Superior_extensor_retinaculum_49388_ID",
        "Left_Superior_extensor_retinaculum_49388_ID"
    ],
    "49481": [
        "Right_superior_laryngeal_artery_49481_ID"
    ],
    "49482": [
        "Left_superior_laryngeal_artery_49482_ID"
    ],
    "49486": [
        "Right_superior_thyroid_artery_49486_ID"
    ],
    "49487": [
        "Left_superior_thyroid_artery_49487_ID"
    ],
    "49498": [
        "Right_ascending_pharyngeal_artery_49498_ID"
    ],
    "49499": [
        "Left_ascending_pharyngeal_artery_49499_ID"
    ],
    "49550": [
        "Right_facial_artery_49550_ID"
    ],
    "49551": [
        "Left_facial_artery_49551_ID",
        "Right_facial_artery_49551_ID"
    ],
    "49552": [
        "Left_facial_artery_49552_ID"
    ],
    "49556": [
        "Right_ascending_palatine_artery_49556_ID"
    ],
    "49557": [
        "Left_ascending_palatine_artery_49557_ID"
    ],
    "49559": [
        "Right_tonsillar_artery_49559_ID"
    ],
    "49560": [
        "Left_tonsillar_artery_49560_ID"
    ],
    "49561": [
        "Right_tonsillar_artery_49561_ID"
    ],
    "49567": [
        "Inferior_labial_artery_49567_ID"
    ],
    "49570": [
        "Superior_labial_artery_49570_ID"
    ],
    "49584": [
        "Right_angular_artery_49584_ID"
    ],
    "49585": [
        "Left_angular_artery_49585_ID"
    ],
    "49625": [
        "Right_posterior_auricular_artery_49625_ID"
    ],
    "49626": [
        "Left_posterior_auricular_artery_49626_ID"
    ],
    "49651": [
        "Right_superficial_temporal_artery_49651_ID"
    ],
    "49652": [
        "Left_superficial_temporal_artery_49652_ID"
    ],
    "49658": [
        "Right_transverse_facial_artery_49658_ID"
    ],
    "49659": [
        "Left_transverse_facial_artery_49659_ID"
    ],
    "49660": [
        "Right_transverse_facial_artery_49660_ID"
    ],
    "49676": [
        "Right_maxillary_artery_49676_ID"
    ],
    "49677": [
        "Left_maxillary_artery_49677_ID"
    ],
    "49678": [
        "Right_maxillary_artery_49678_ID"
    ],
    "49705": [
        "Right_mental_artery_49705_ID",
        "branch_of_right_mental_artery_49705_ID"
    ],
    "49706": [
        "Left_mental_artery_49706_ID",
        "branch_of_left_mental_artery_49706_ID"
    ],
    "49712": [
        "Right_middle_meningeal_artery_49712_ID"
    ],
    "49713": [
        "Left_middle_meningeal_artery_49713_ID"
    ],
    "49743": [
        "Right_deep_temporal_artery_49743_ID"
    ],
    "49744": [
        "Left_deep_temporal_artery_49744_ID"
    ],
    "49755": [
        "Right_buccal_artery_49755_ID"
    ],
    "49756": [
        "Left_buccal_artery_49756_ID"
    ],
    "49768": [
        "Right_infraorbital_artery_49768_ID"
    ],
    "49769": [
        "Left_infraorbital_artery_49769_ID"
    ],
    "49792": [
        "Right_descending_palatine_artery_49792_ID"
    ],
    "49793": [
        "Left_descending_palatine_artery_49793_ID"
    ],
    "49799": [
        "Left_greater_palatine_artery_49799_ID"
    ],
    "49800": [
        "Right_greater_palatine_artery_49800_ID"
    ],
    "49802": [
        "Right_lesser_palatine_artery_49802_ID"
    ],
    "49803": [
        "Left_lesser_palatine_artery_49803_ID"
    ],
    "49805": [
        "Right_sphenopalatine_artery_49805_ID"
    ],
    "49806": [
        "Left_sphenopalatine_artery_49806_ID"
    ],
    "49810": [
        "Right_posterior_lateral_nasal_artery_49810_ID"
    ],
    "49811": [
        "Left_posterior_lateral_nasal_artery_49811_ID"
    ],
    "49812": [
        "Posterior_septal_branch_of_right_sphenopalatine_artery_49812_ID"
    ],
    "49813": [
        "Posterior_septal_branch_of_left_sphenopalatine_artery_49813_ID"
    ],
    "49869": [
        "Right_opthalmic_artery_49869_ID",
        "Right_ophthalmic_artery_49869_ID"
    ],
    "49870": [
        "Left_opthalmic_artery_49870_ID",
        "Left_ophthalmic_artery_49870_ID"
    ],
    "49881": [
        "Right_central_retinal_artery_49881_ID",
        "Left_central_retinal_artery_49881_ID"
    ],
    "49911": [
        "Right_Inferior_Pulmonary_vein_49911_ID"
    ],
    "49913": [
        "Left_Inferior_Pulmonary_vein_49913_ID"
    ],
    "49914": [
        "Right_Superior_Pulmonary_vein_49914_ID"
    ],
    "49916": [
        "Left_Superior_Pulmonary_vein_49916_ID"
    ],
    "49928": [
        "Right_lacrimal_artery_49928_ID"
    ],
    "49929": [
        "Left_lacrimal_artery_49929_ID"
    ],
    "49974": [
        "Right_supraorbital_artery_49974_ID"
    ],
    "49975": [
        "Left_supraorbital_artery_49975_ID"
    ],
    "49987": [
        "Right_anterior_ethmoidal_artery_49987_ID"
    ],
    "49988": [
        "Left_anterior_ethmoidal_artery_49988_ID"
    ],
    "49990": [
        "Right_posterior_ethmoidal_artery_49990_ID"
    ],
    "49991": [
        "Left_posterior_ethmoidal_artery_49991_ID"
    ],
    "50001": [
        "Right_dorsal_nasal_artery_50001_ID"
    ],
    "50002": [
        "Left_dorsal_nasal_artery_50002_ID"
    ],
    "50026": [
        "Right_supratrochlear_artery_50026_ID"
    ],
    "50027": [
        "Left_supratrochlear_artery_50027_ID",
        "Right_supratrochlear_artery_50027_ID"
    ],
    "50028": [
        "Left_supratrochlear_artery_50028_ID"
    ],
    "50029": [
        "Right_anterior_cerebral_artery_50029_ID"
    ],
    "50030": [
        "Left_anterior_cerebral_artery_50030_ID"
    ],
    "50031": [
        "Left_anterior_cerebral_artery_50031_ID"
    ],
    "50038": [
        "Left_coronary_artery_50038_ID"
    ],
    "50039": [
        "Right_Coronary_Artery_50039_ID"
    ],
    "50082": [
        "Right_Middle_Cerebral_Artery_50082_ID"
    ],
    "50083": [
        "Left_Middle_Cerebral_Artery_50083_ID"
    ],
    "50085": [
        "Right_Posterior_Communicating_Artery_50085_ID"
    ],
    "50086": [
        "Left_Posterior_Communicating_Artery_50086_ID"
    ],
    "50169": [
        "Anterior_Communicating_Artery_50169_ID"
    ],
    "50197": [
        "Muscles_of_the_Right_Arm_50197_ID"
    ],
    "50198": [
        "Muscles_of_the_Right_Arm_50198_ID",
        "Muscles_of_the_Left_Arm_50198_ID"
    ],
    "50203": [
        "Right_upper_arm_muscles_50203_ID"
    ],
    "50204": [
        "Right_upper_arm_muscles_50204_ID",
        "Left_upper_arm_muscles_50204_ID"
    ],
    "50221": [
        "Right_shoulder_muscles_50221_ID",
        "Left_shoulder_muscles_50221_ID"
    ],
    "50222": [
        "Left_shoulder_muscles_50222_ID",
        "Right_shoulder_muscles_50222_ID"
    ],
    "50542": [
        "Basilar_Artery_50542_ID"
    ],
    "50545": [
        "Right_Anterior_Inferior_cerebellar_artery_50545_ID",
        "Right_anterior_Inferior_cerebellar_artery_50545_ID"
    ],
    "50546": [
        "Left_Anterior_Inferior_cerebellar_artery_50546_ID",
        "Left_anterior_Inferior_cerebellar_artery_50546_ID"
    ],
    "50574": [
        "Right_Superior_Cerebellar_artery_50574_ID"
    ],
    "50575": [
        "Left_Superior_Cerebellar_Artery_50575_ID",
        "Left_Superior_Cerebellar_artery_50575_ID"
    ],
    "50584": [
        "Right_Posterior_cerebral_artery_50584_ID",
        "Right_posterior_cerebral_artery_50584_ID"
    ],
    "50585": [
        "Left_Posterior_cerebral_artery_50585_ID",
        "Left_posterior_cerebral_artery_50585_ID"
    ],
    "50718": [
        "Superior_Terminal_Branch_of_Right_Middle_Cerebral_Artery_50718_ID"
    ],
    "50719": [
        "Superior_Terminal_Branch_of_Left_Middle_Cerebral_Artery_50719_ID"
    ],
    "50735": [
        "Hepatic_Portal_and_Associated_Branches_50735_ID"
    ],
    "50764": [
        "Right_transverse_sinus_50764_ID"
    ],
    "50765": [
        "Left_transverse_sinus_50765_ID"
    ],
    "50767": [
        "Superior_sagittal_sinus_50767_ID"
    ],
    "50768": [
        "Inferior_Sagittal_Sinus_50768_ID"
    ],
    "50769": [
        "Straight_Sinus_50769_ID"
    ],
    "50773": [
        "Intercavernous_sinus_50773_ID"
    ],
    "50781": [
        "Occipital_Sinus_50781_ID"
    ],
    "50784": [
        "Sinus_Confluence_50784_ID"
    ],
    "50808": [
        "Right_superior_thyroid_vein_50808_ID"
    ],
    "50809": [
        "Left_superior_thyroid_vein_50809_ID"
    ],
    "50852": [
        "Right_posterior_auricular_vein_50852_ID"
    ],
    "50853": [
        "Left_posterior_auricular_vein_50853_ID"
    ],
    "50859": [
        "Right_suprascapular_vein_50859_ID"
    ],
    "50860": [
        "Left_suprascapular_vein_50860_ID",
        "Right_suprascapular_vein_50860_ID"
    ],
    "50872": [
        "Right_Pulmonary_artery_50872_ID"
    ],
    "50873": [
        "Left_Pulmonary_artery_50873_ID"
    ],
    "50875": [
        "Right_optic_nerve_50875_ID"
    ],
    "50876": [
        "Left_Facial_Vein_50876_ID",
        "Right_Facial_Vein_50876_ID"
    ],
    "50877": [
        "Right_Facial_Vein_50877_ID",
        "Left_Facial_Vein_50877_ID"
    ],
    "50878": [
        "Left_optic_nerve_50878_ID"
    ],
    "50879": [
        "Right_oculomotor_nerve_50879_ID"
    ],
    "50880": [
        "Left_oculomotor_nerve_50880_ID"
    ],
    "50881": [
        "Right_trochlear_nerve_50881_ID"
    ],
    "50882": [
        "Left_trochlear_nerve_50882_ID"
    ],
    "50886": [
        "Right_abducens_nerve_50886_ID"
    ],
    "50887": [
        "Left_abducens_nerve_50887_ID"
    ],
    "50888": [
        "Right_facial_nerve_50888_ID"
    ],
    "50889": [
        "Left_facial_nerve_50889_ID"
    ],
    "50890": [
        "Right_vestibulocochlear_nerve_50890_ID"
    ],
    "50891": [
        "Left_vestibulocochlear_nerve_50891_ID"
    ],
    "50892": [
        "Right_glossopharyngeal_nerve_50892_ID"
    ],
    "50894": [
        "Left_glossopharyngeal_nerve_50894_ID"
    ],
    "50897": [
        "Right_spinal_accessory_nerve_50897_ID",
        "Left_spinal_accessory_nerve_50897_ID"
    ],
    "50899": [
        "Left_spinal_accessory_nerve_50899_ID"
    ],
    "50902": [
        "Right_hypoglossal_nerve_50902_ID"
    ],
    "50903": [
        "Left_hypoglossal_Nerve_50903_ID"
    ],
    "50929": [
        "Right_retromandibular_vein_50929_ID"
    ],
    "50930": [
        "Left_retromandibular_vein_50930_ID"
    ],
    "50933": [
        "Right_Superficial_Temporal_Vein_50933_ID"
    ],
    "50934": [
        "Left_Superficial_Temporal_Vein_50934_ID"
    ],
    "51042": [
        "Right_Deep_Femoral_vein_51042_ID"
    ],
    "51043": [
        "Left_Deep_Femoral_vein_51043_ID"
    ],
    "51085": [
        "Tendon_of_left_flexor_digitorum_brevis_51085_ID",
        "Tendon_of_right_flexor_digitorum_brevis_51085_ID",
        "Right_flexor_digitorum_longus_51085_ID",
        "Left_flexor_digitorum_longus_51085_ID"
    ],
    "51289": [
        "Right_superior_petrosal_sinus_51289_ID"
    ],
    "51290": [
        "Left_superior_petrosal_sinus_51290_ID"
    ],
    "51402": [
        "Right_Cavernous_sinus_51402_ID"
    ],
    "51403": [
        "Left_Cavernous_Sinus_51403_ID"
    ],
    "51489": [
        "Right_occipital_vein_51489_ID"
    ],
    "51490": [
        "Left_occipital_vein_51490_ID"
    ],
    "51885": [
        "Left_central_retinal_vein_51885_ID",
        "Right_central_retinal_vein_51885_ID"
    ],
    "51942": [
        "Right_superior_central_retinal_artery_51942_ID",
        "Left_superior_central_retinal_artery_51942_ID"
    ],
    "51944": [
        "Right_inferior_central_retinal_artery_51944_ID",
        "Left_inferior_central_retinal_artery_51944_ID"
    ],
    "52619": [
        "Right_trigeminal_ganglion_52619_ID"
    ],
    "52620": [
        "Left_trigeminal_ganglion_52620_ID"
    ],
    "52629": [
        "Right_lacrimal_nerve_52629_ID"
    ],
    "52630": [
        "Left_lacrimal_nerve_52630_ID"
    ],
    "52639": [
        "Right_opthalmic_nerve_52639_ID"
    ],
    "52640": [
        "Left_opthalmic_nerve_52640_ID"
    ],
    "52643": [
        "Right_supratrochlear_nerve_52643_ID"
    ],
    "52644": [
        "Left_supratrochlear_nerve_52644_ID"
    ],
    "52661": [
        "Medial_branch_of_right_supraorbital_nerve_52661_ID"
    ],
    "52662": [
        "Medial_branch_of_left_supraorbital_nerve_52662_ID"
    ],
    "52663": [
        "Lateral_branch_of_right_supraorbital_nerve_52663_ID"
    ],
    "52664": [
        "Lateral_branch_of_left_supraorbital_nerve_52664_ID"
    ],
    "52669": [
        "Right_nasociliary_nerve_52669_ID"
    ],
    "52670": [
        "Left_nasociliary_nerve_52670_ID"
    ],
    "52725": [
        "Right_maxillary_nerve_52725_ID"
    ],
    "52726": [
        "Left_maxillary_nerve_52726_ID"
    ],
    "52734": [
        "Frontal_bone_52734_ID"
    ],
    "52735": [
        "Occipital_bone_52735_ID"
    ],
    "52736": [
        "Sphenoid_bone_52736_ID"
    ],
    "52738": [
        "Right_temporal_bone_52738_ID"
    ],
    "52739": [
        "Left_temporal_bone_52739_ID"
    ],
    "52740": [
        "Ethmoid_bone_52740_ID"
    ],
    "52745": [
        "Nasal_bone_52745_ID"
    ],
    "52746": [
        "Palatine_bone_52746_ID"
    ],
    "52748": [
        "Mandible_52748_ID"
    ],
    "52749": [
        "Hyoid_bone_52749_ID"
    ],
    "52784": [
        "Left_lateral_posterior_superior_nasal_nerve_52784_ID"
    ],
    "52785": [
        "Right_lateral_posterior_superior_nasal_nerve_52785_ID"
    ],
    "52788": [
        "Right_parietal_bone_52788_ID"
    ],
    "52789": [
        "Left_parietal_bone_52789_ID"
    ],
    "52803": [
        "Right_greater_palatine_nerve_52803_ID"
    ],
    "52804": [
        "Left_greater_palatine_nerve_52804_ID"
    ],
    "52806": [
        "Right_lesser_palatine_nerve_52806_ID"
    ],
    "52807": [
        "Left_lesser_palatine_nerve_52807_ID"
    ],
    "52824": [
        "Left_posterior_inferior_nasal_nerve_52824_ID"
    ],
    "52825": [
        "Right_posterior_inferior_nasal_nerve_52825_ID"
    ],
    "52892": [
        "Right_zygomatic_bone_52892_ID"
    ],
    "52893": [
        "Left_zygomatic_bone_52893_ID"
    ],
    "52974": [
        "Zygomaticotemporal_branch_of_right_zygomatic_nerve_52974_ID"
    ],
    "52975": [
        "Zygomaticotemporal_branch_of_left_zygomatic_nerve_52975_ID"
    ],
    "52976": [
        "Zygomaticofacial_branch_of_right_zygomatic_nerve_52976_ID"
    ],
    "52977": [
        "Zygomaticotemporal_branch_of_right_zygomatic_nerve_52977_ID",
        "Zygomaticofacial_branch_of_left_zygomatic_nerve_52977_ID"
    ],
    "52978": [
        "Zygomaticotemporal_branch_of_left_zygomatic_nerve_52978_ID"
    ],
    "52979": [
        "Right_infraorbital_nerve_52979_ID"
    ],
    "52980": [
        "Left_infra_orbital_nerve_52980_ID",
        "Left_infraorbital_nerve_52980_ID"
    ],
    "52997": [
        "Right_Mandibular_Nerve_52997_ID"
    ],
    "52998": [
        "Left_Mandibular_Nerve_52998_ID"
    ],
    "53001": [
        "Right_auriculotemporal_nerve_53001_ID"
    ],
    "53002": [
        "Left_auriculotemporal_nerve_53002_ID"
    ],
    "53069": [
        "Right_pterygopalatine_ganglion_53069_ID"
    ],
    "53070": [
        "Left_pterygopalatine_ganglion_53070_ID"
    ],
    "53121": [
        "Right_zygomatic_bone_53121_ID"
    ],
    "53122": [
        "Left_zygomatic_bone_53122_ID"
    ],
    "53185": [
        "Buccal_branch_of_right_facial_nerve_53185_ID",
        "Buccal_branch_of_Right_Facial_Nerve_53185_ID"
    ],
    "53186": [
        "Buccal_branch_of_Left_Facial_Nerve_53186_ID"
    ],
    "53219": [
        "Right_lingual_nerve_53219_ID"
    ],
    "53220": [
        "Left_lingual_nerve_53220_ID"
    ],
    "53244": [
        "Right_Inferior_Alveolar_Nerve_53244_ID"
    ],
    "53245": [
        "Left_Inferior_Alveolar_Nerve_53245_ID"
    ],
    "53251": [
        "Right_mental_nerve_53251_ID",
        "Left_mental_nerve_53251_ID"
    ],
    "53252": [
        "Left_mental_nerve_53252_ID"
    ],
    "53279": [
        "Right_posterior_auricular_nerve_53279_ID"
    ],
    "53280": [
        "Left_posterior_auricular_nerve_53280_ID"
    ],
    "53290": [
        "Temporal_branch_of_the_right_facial_nerve_53290_ID"
    ],
    "53291": [
        "Temporal_branch_of_the_left_facial_nerve_53291_ID",
        "Temporal_branch_of_the_right_facial_nerve_53291_ID"
    ],
    "53366": [
        "Marginal_mandibular_branch_of_right_facial_nerve_53366_ID"
    ],
    "53367": [
        "Marginal_mandibular_branch_of_left_facial_nerve_53367_ID"
    ],
    "53398": [
        "Cervical_branch_of_right_facial_nerve_53398_ID"
    ],
    "53399": [
        "Cervical_branch_of_left_facial_nerve_53399_ID"
    ],
    "53549": [
        "Right_ciliary_ganglion_53549_ID"
    ],
    "53550": [
        "Left_ciliary_ganglion_53550_ID"
    ],
    "53641": [
        "Right_ear_53641_ID"
    ],
    "53642": [
        "Left_ear_53642_ID"
    ],
    "53643": [
        "Left_ear_53643_ID"
    ],
    "53645": [
        "Right_Lacrimal_Bone_53645_ID"
    ],
    "53646": [
        "Left_lacrimal_bone_53646_ID"
    ],
    "53654": [
        "Palatine_bone_53654_ID"
    ],
    "54375": [
        "Nasal_septum_54375_ID"
    ],
    "54449": [
        "Right_eye_54449_ID"
    ],
    "54450": [
        "Left_eye_54450_ID"
    ],
    "54640": [
        "Tongue_54640_ID"
    ],
    "55099": [
        "Thyroid_Cartilage_55099_ID"
    ],
    "55123": [
        "Lower_part_of_cricopharyngeus_55123_ID"
    ],
    "55132": [
        "Thyrohyoid_Membrane_55132_ID"
    ],
    "55143": [
        "Right_ansa_cervicalis_nerve_55143_ID"
    ],
    "55144": [
        "left_ansa_cervicalis_nerve_55144_ID"
    ],
    "55145": [
        "Right_ansa_cervicalis_nerve_55145_ID"
    ],
    "55233": [
        "Cricothyroid_ligament_55233_ID"
    ],
    "55560": [
        "Right_Superior_Parathyroid_55560_ID"
    ],
    "55561": [
        "Left_Superior_Parathyroid_55561_ID"
    ],
    "55562": [
        "Right_Inferior_Parathyroid_55562_ID"
    ],
    "55563": [
        "Left_Inferior_Parathyroid_55563_ID"
    ],
    "55610": [
        "Right_procerus_55610_ID"
    ],
    "55611": [
        "Left_procerus_55611_ID"
    ],
    "55612": [
        "Transverse_part_of_right_nasalis_55612_ID"
    ],
    "55613": [
        "Transverse_part_of_left_nasalis_55613_ID"
    ],
    "55614": [
        "Alar_part_of_right_nasalis_55614_ID"
    ],
    "55615": [
        "Alar_part_of_left_nasalis_55615_ID"
    ],
    "56103": [
        "Right_Internal_acoustic_meatus_56103_ID"
    ],
    "56104": [
        "Left_Internal_acoustic_meatus_56104_ID"
    ],
    "56427": [
        "Right_tympanic_membrane_56427_ID"
    ],
    "56428": [
        "Left_tympanic_membrane_56428_ID"
    ],
    "58236": [
        "Right_Iris_58236_ID"
    ],
    "58237": [
        "Left_Iris_58237_ID"
    ],
    "58242": [
        "Right_Lens_58242_ID"
    ],
    "58243": [
        "Left_Lens_58243_ID"
    ],
    "58271": [
        "Right_Sclera_58271_ID"
    ],
    "58272": [
        "Left_Sclera_58272_ID"
    ],
    "58299": [
        "Right_Choroid_58299_ID"
    ],
    "58300": [
        "Left_Choroid_58300_ID"
    ],
    "58302": [
        "Right_Retina_58302_ID"
    ],
    "58303": [
        "Left_Retina_58303_ID"
    ],
    "58841": [
        "Right_Hyaloid_Canal_58841_ID"
    ],
    "58842": [
        "Left_Hyaloid_Canal_58842_ID"
    ],
    "59102": [
        "Right_lacrimal_gland_59102_ID"
    ],
    "59103": [
        "Left_lacrimal_gland_59103_ID"
    ],
    "59505": [
        "Right_major_alar_cartilage_59505_ID"
    ],
    "59506": [
        "Left_major_alar_cartilage_59506_ID"
    ],
    "59512": [
        "Right_lateral_nasal_cartilage_59512_ID"
    ],
    "59513": [
        "Left_lateral_nasal_cartilage_59513_ID"
    ],
    "59545": [
        "Right_lacrimal_sac_59545_ID"
    ],
    "59546": [
        "Left_lacrimal_sac_59546_ID"
    ],
    "59797": [
        "Left_Parotid_Gland_59797_ID",
        "Right_Parotid_Gland_59797_ID"
    ],
    "59798": [
        "Right_Parotid_Gland_59798_ID",
        "Left_Parotid_Gland_59798_ID"
    ],
    "59802": [
        "Right_Submandibular_Gland_59802_ID"
    ],
    "59803": [
        "Left_Submandibular_Gland_59803_ID"
    ],
    "59804": [
        "Right_Sublingual_Gland_59804_ID"
    ],
    "59805": [
        "Left_Sublingual_Gland_59805_ID"
    ],
    "59866": [
        "Right_Parotid_Duct_59866_ID"
    ],
    "59867": [
        "Left_Parotid_Duct_59867_ID"
    ],
    "59964": [
        "Right_Submandibular_Duct_59964_ID"
    ],
    "59965": [
        "Left_Submandibular_Duct_59965_ID"
    ],
    "60180": [
        "Right_osseous_labyrinth_60180_ID"
    ],
    "60181": [
        "Left_osseous_labyrinth_60181_ID"
    ],
    "60188": [
        "Right_Anterior_semicircular_canal_60188_ID"
    ],
    "60189": [
        "Left_Anterior_semicircular_canal_60189_ID"
    ],
    "60191": [
        "Right_Posterior_semicircular_canal_60191_ID"
    ],
    "60192": [
        "Left_Posterior_semicircular_canal_60192_ID"
    ],
    "60194": [
        "Right_Lateral_semicircular_canal_60194_ID"
    ],
    "60195": [
        "Left_Lateral_semicircular_canal_60195_ID"
    ],
    "60202": [
        "Right_Cochlea_60202_ID"
    ],
    "60203": [
        "Left_Cochlea_60203_ID"
    ],
    "61020": [
        "Right_Internal_Ear_61020_ID"
    ],
    "61021": [
        "Left_Internal_Ear_61021_ID"
    ],
    "61735": [
        "Right_external_acoustic_tube_61735_ID"
    ],
    "61736": [
        "Left_external_acoustic_tube_61736_ID"
    ],
    "61965": [
        "fornix_61965_ID"
    ],
    "62008": [
        "hypothalamus_62008_ID"
    ],
    "62033": [
        "Pineal_Gland_62033_ID"
    ],
    "62045": [
        "optic_chiasm_62045_ID"
    ],
    "64919": [
        "Right_Iliopsoas_64919_ID"
    ],
    "64920": [
        "Left_Iliopsoas_64920_ID"
    ],
    "65015": [
        "Left_Flexor_hallucis_longus_65015_ID",
        "Right_Flexor_hallucis_longus_65015_ID"
    ],
    "65019": [
        "Left_Tibialis_posterior_65019_ID",
        "Right_Tibialis_posterior_65019_ID"
    ],
    "65281": [
        "Right_long_thoracic_nerve_65281_ID"
    ],
    "65282": [
        "Left_long_thoracic_nerve_65282_ID"
    ],
    "65536": [
        "Right_lumbosacral_trunk_nerve_65536_ID"
    ],
    "65537": [
        "Left_lumbosacral_trunk_nerve_65537_ID",
        "Left_lumbosacral_trunk_65537_ID"
    ],
    "66321": [
        "Right_thoracodorsal_artery_66321_ID"
    ],
    "66322": [
        "right_thoracodorsal_artery_66322_ID",
        "left_thoracodorsal_artery_66322_ID"
    ],
    "67584": [
        "Left_nerve_of_pterygoid_canal_67584_ID",
        "Right_nerve_of_pterygoid_canal_67584_ID"
    ],
    "67944": [
        "cerebellum_67944_ID"
    ],
    "69316": [
        "Right_Brachiocephalic_trunk_69316_ID"
    ],
    "69490": [
        "Right_lateral_tarsal_artery_69490_ID"
    ],
    "69491": [
        "Left_lateral_tarsal_artery_69491_ID"
    ],
    "69494": [
        "Right_arcuate_artery_69494_ID"
    ],
    "69495": [
        "Left_arcuate_artery_69495_ID"
    ],
    "69514": [
        "Right_deep_plantar_artery_69514_ID"
    ],
    "69515": [
        "Right_deep_plantar_artery_69515_ID"
    ],
    "69516": [
        "Left_deep_plantar_artery_69516_ID"
    ],
    "69726": [
        "Calcaneal_branch_of_right_posterior_tibial_artery_69726_ID"
    ],
    "69727": [
        "Calcaneal_branch_of_left_posterior_tibial_artery_69727_ID"
    ],
    "70249": [
        "Right_femoral_artery_70249_ID"
    ],
    "70250": [
        "Left_femoral_artery_70250_ID"
    ],
    "70799": [
        "Right_dorsal_metacarpal_arteries_70799_ID"
    ],
    "70800": [
        "left_dorsal_metacarpal_arteries_70800_ID",
        "right_dorsal_metacarpal_arteries_70800_ID"
    ],
    "70801": [
        "left_dorsal_digital_arteries_70801_ID",
        "right_dorsal_digital_arteries_70801_ID",
        "Right_dorsal_digital_arteries_70801_ID",
        "Right_palmar_metacarpal_arteries_70801_ID"
    ],
    "70802": [
        "left_palmar_metacarpal_arteries_70802_ID",
        "right_palmar_metacarpal_arteries_70802_ID",
        "Right_common_palmar_digital_arteries_70802_ID"
    ],
    "70803": [
        "right_common_palmar_digital_arteries_70803_ID",
        "Right_proper_palmar_digital_arteries_70803_ID",
        "left_common_palmar_digital_arteries_70803_ID"
    ],
    "70804": [
        "left_proper_palmar_digital_arteries_70804_ID",
        "right_proper_palmar_digital_arteries_70804_ID",
        "left_common_palmar_digital_arteries_70804_ID"
    ],
    "70809": [
        "Set_of_Jejunal_arteries_70809_ID"
    ],
    "70810": [
        "Set_of_ileal_arteries_70810_ID"
    ],
    "70815": [
        "Perforating_arteries_of_left_deep_fibular_artery_70815_ID",
        "Perforating_arteries_of_right_deep_fibular_artery_70815_ID"
    ],
    "70889": [
        "Left_lumbar_vein_70889_ID",
        "Right_lumbar_vein_70889_ID"
    ],
    "70917": [
        "Right_palmar_digital_veins_70917_ID"
    ],
    "70918": [
        "right_palmar_digital_veins_70918_ID",
        "left_palmar_digital_veins_70918_ID"
    ],
    "70922": [
        "Right_distal_perforating_veins_70922_ID",
        "Perforating_veins_of_right_deep_femoral_artery_70922_ID",
        "Perforating_veins_of_left_deep_femoral_artery_70922_ID",
        "Left_distal_perforating_veins_70922_ID"
    ],
    "70927": [
        "Set_of_jejunal_veins_70927_ID"
    ],
    "70928": [
        "Set_of_ileal_veins_70928_ID"
    ],
    "71132": [
        "Gastrointestinal_Tract_71132_ID"
    ],
    "71211": [
        "Right_lateral_thoracic_vein_71211_ID"
    ],
    "71212": [
        "Left_lateral_thoracic_vein_71212_ID",
        "Right_lateral_thoracic_vein_71212_ID"
    ],
    "71214": [
        "Right_thoracodorsal_vein_71214_ID",
        "Left_thoracodorsal_vein_71214_ID"
    ],
    "71215": [
        "Right_thoracodorsal_vein_71215_ID"
    ],
    "71287": [
        "Muscles_of_the_Head_and_Neck_71287_ID"
    ],
    "71291": [
        "Muscles_of_the_Back_71291_ID"
    ],
    "71293": [
        "Muscles_of_the_Thorax_71293_ID"
    ],
    "71310": [
        "Left_Intertransversarii_71310_ID",
        "Right_Intertransversarii_71310_ID"
    ],
    "71398": [
        "Left_Radiate_Sternocostal_Ligaments_71398_ID",
        "Right_Radiate_Sternocostal_Ligaments_71398_ID"
    ],
    "71894": [
        "Right_carpal_bones_71894_ID",
        "Left_carpal_bones_71894_ID"
    ],
    "71898": [
        "Right_metacarpal_bones_of_hand_71898_ID",
        "Left_metacarpal_bones_of_hand_71898_ID"
    ],
    "71900": [
        "Phalanges_of_right_hand_71900_ID",
        "Phalanges_of_left_hand_71900_ID"
    ],
    "72063": [
        "Set_of_cervical_vertebrae_72063_ID"
    ],
    "72064": [
        "Set_of_thoracic_vertebrae_72064_ID"
    ],
    "72065": [
        "Set_of_lumbar_vertebrae_72065_ID"
    ],
    "72309": [
        "Right_Stylohyoid_Ligament_72309_ID"
    ],
    "72311": [
        "Left_Stylohyoid_Ligament_72311_ID"
    ],
    "72316": [
        "Set_of_intervertebral_discs_72316_ID"
    ],
    "72826": [
        "right_caudate_nucleus_72826_ID"
    ],
    "72827": [
        "left_caudate_nucleus_72827_ID"
    ],
    "72828": [
        "right_putamen_72828_ID"
    ],
    "72829": [
        "left_putamen_72829_ID"
    ],
    "72832": [
        "right_amygdaloid_body_72832_ID"
    ],
    "72833": [
        "left_amygdaloid_body_72833_ID"
    ],
    "72856": [
        "right_lateral_globus_pallidus_72856_ID"
    ],
    "72857": [
        "left_lateral_globus_pallidus_72857_ID"
    ],
    "72858": [
        "right_medial_globus_pallidus_72858_ID"
    ],
    "72859": [
        "left_medial_globus_pallidus_72859_ID"
    ],
    "74048": [
        "Right_stapes_74048_ID"
    ],
    "74049": [
        "Left_stapes_74049_ID"
    ],
    "74050": [
        "Right_Incus_74050_ID"
    ],
    "74051": [
        "Left_Incus_74051_ID"
    ],
    "74052": [
        "Right_malleus_74052_ID"
    ],
    "74053": [
        "Left_malleus_74053_ID"
    ],
    "74073": [
        "Right_Levatores_costarum_74073_ID"
    ],
    "74074": [
        "Left_Levatores_costarum_74074_ID"
    ],
    "74075": [
        "Right_Levatores_costarum_longi_74075_ID"
    ],
    "74076": [
        "Left_Levatores_costarum_longi_74076_ID"
    ],
    "74079": [
        "Right_Subcostales_74079_ID"
    ],
    "74080": [
        "Left_Subcostales_74080_ID"
    ],
    "74525": [
        "Occipital_74525_ID"
    ],
    "75150": [
        "Teeth_75150_ID"
    ],
    "75398": [
        "Superficial_dorsal_vein_of_penis_75398_ID"
    ],
    "75492": [
        "Right_common_plantar_digital_nerves_75492_ID"
    ],
    "75493": [
        "Left_common_plantar_digital_nerves_75493_ID"
    ],
    "76767": [
        "Anterior_cardiac_vein_76767_ID"
    ],
    "76829": [
        "Right_Zonula_Fibers_76829_ID",
        "Left_Zonula_Fibers_76829_ID"
    ],
    "77161": [
        "Intermediate_Hepatic_Vein_77161_ID"
    ],
    "77380": [
        "Right_popliteal_artery_77380_ID"
    ],
    "77381": [
        "Left_popliteal_artery_77381_ID"
    ],
    "77596": [
        "Hypogastric_nerve_77596_ID"
    ],
    "77949": [
        "Right_circumflex_scapular_vein_77949_ID"
    ],
    "77950": [
        "Right_circumflex_scapular_vein_77950_ID",
        "Left_circumflex_scapular_vein_77950_ID"
    ],
    "78023": [
        "Right_lateral_brachial_vein_78023_ID"
    ],
    "78024": [
        "right_lateral_brachial_vein_78024_ID",
        "left_lateral_brachial_vein_78024_ID"
    ],
    "78209": [
        "trunk_of_Hepatic_portal_vein_78209_ID"
    ],
    "78508": [
        "Right_tarsal_bones_78508_ID"
    ],
    "78509": [
        "Left_tarsal_bones_78509_ID"
    ],
    "78510": [
        "Right_metatarsal_bones_78510_ID"
    ],
    "79468": [
        "Right_accessory_meningeal_artery_79468_ID"
    ],
    "79469": [
        "Left_accessory_meningeal_artery_79469_ID"
    ],
    "82695": [
        "trunk_of_Hepatic_portal_vein_82695_ID"
    ],
    "82933": [
        "Right_Nerve_to_levator_ani_82933_ID"
    ],
    "82934": [
        "Left_Nerve_to_levator_ani_82934_ID"
    ],
    "85274": [
        "External_Urethral_Sphincter_85274_ID"
    ],
    "86233": [
        "Lymphatics_of_the_Upper_Limb_86233_ID"
    ],
    "86917": [
        "Muscles_of_the_Abdomen_86917_ID"
    ],
    "87217": [
        "Descending_aorta_thoracic_87217_ID",
        "Descending_thoracic_aorta_87217_ID"
    ],
    "228738": [
        "Muscles_of_the_Throat_228738_ID"
    ],
    "231317": [
        "Phalanges_of_the_right_foot_231317_ID"
    ],
    "231319": [
        "Phalanges_of_the_left_foot_231319_ID"
    ],
    "258714": [
        "right_thalamus_258714_ID"
    ],
    "258716": [
        "left_thalamus_258716_ID"
    ],
    "258847": [
        "Right_Calcaneal_Tendon__aka_Achilles_Tendon_258847_ID"
    ],
    "258848": [
        "Left_Calcaneal_Tendon__aka_Achilles_Tendon_258848_ID"
    ],
    "268668": [
        "Right_interosseous_recurrent_artery_268668_ID"
    ],
    "268669": [
        "right_interosseous_recurrent_artery_268669_ID",
        "left_interosseous_recurrent_artery_268669_ID"
    ]
};
;/**
 *  @namespace Manages network sockets to which remote clients can attach.
 */
(function () {
    "use strict";

    var HumanClients = Human.clients = {};

    /**
     * Number of remote clients connected to this engine
     * @type {number}
     */
    HumanClients.numConnections = 0;

    /**
     * Registers a client type
     * @param clazz
     */
    HumanClients.addClient = function (clientFn) {
        clientFn({
            connected: function () {
                HumanClients.numConnections++;
                Human.events.fire("clients.connected", {});
            },
            disconnected: function () {
                HumanClients.numConnections--;
                Human.events.fire("clients.disconnected", {});
            }
        });
    };

})();
;/**
 WebSocket messaging server
 */

(function () {
    "use strict";

    // Get socket server configs off URL.

    // Can't get these via Human.properties, because the socket connection must start up
    // as soon as Human fires a "loaded" event, which happens before any of the init scripts
    // execute, which is the earliest opportunity that we have for setting engine properties.

    // Socket needs to be started on "loaded" so that API can immediately send across calls
    // to do things like set canvas background color etc.

    // Only enable this code module if URL contains "socketEnabled=true".

    var socketEnabled = Human.request.getSearchParam("socketEnabled") === "true";

    if (!socketEnabled) {
        Human.log.info("Human.clients.webSocketClient", "WebSocket enabled: NO - socketEnabled=true was not found on URL.");
        return;
    }

    Human.log.info("Human.clients.webSocketClient", "WebSocket enabled: YES - socketEnabled=true was found on URL.");

    var socketServerURL = Human.request.getSearchParam("socketURL") || "https://api.biodigitalhuman.com";
    var socketServerPort = Human.request.getSearchParam("socketPort") || 443;
    var socketServerChannel = Human.request.getSearchParam("socketChannel") || "human";

    var socket = null;              // The WebSocket
    // TODO (Tarek): Human.processes no longer exists, so the queuing logic should be removed.
    var countProcesses = 0;         // Human busy when > 0
    var requestQueue = [];          // Buffers incoming requests while countProcesses > 0
    var requestQueuePumpInterval;   // Interval pumps request queue

    var connected = false;
    var error = null;
    var ready = false;

    // Relay all engine errors back to the client

    Human.events.on("error",
        function (e) {
            if (connected) {
                sendResponse({ error: e });
            }
            error = e;
        });

    Human.events.on("started",
        function () {
            if (connected) {
                sendResponse({ message: "ready" });
            }
            ready = true;
        });

    Human.events.on("loaded",
        function () {

            // Engine loaded

            Human.clients.numConnections++;
            Human.events.fire("clients.connected", {});

            Human.log.info("Human.clients.webSocketClient", "WebSocket server enabled.");

            // Load Socket.IO library

            Human.log.info("Human.clients.webSocketClient", "Loading Socket.IO Library...");

            loadSocketIO(function (io) {

                Human.log.info("Human.clients.webSocketClient", "Socket.IO library loaded.");

                // Start the socket server

                // Relay results of all engine RPC calls back to client

                Human.rpc.onResult(
                    function (key, value) {
                        var results = {};
                        results[key] = value;
                        sendResponse({ results: results });
                    });


                // Connect server to socket

                try {

                    socket = io.connect(socketServerURL + ":" + socketServerPort);

                    var socketConnected = false;

                    socket.on('connect',
                        function () {

                            // Server connected to socket

                            if (socketConnected) {
                                return;
                            }

                            socketConnected = true;

                            Human.log.info("Human.clients.webSocketClient", "Connected.");
                            Human.log.info("Human.clients.webSocketClient", "Subscribing");

                            // Subscribe server to channel

                            socket.emit('subscribe', socketServerChannel);
                        });

                    socket.on('status',
                        function (status) {
                              Human.log.info("[client " + socketServerURL + "] received status:" + status);
                        });

                    socket.on('message',
                        function (message) {

                            // Handle message from client

                            Human.log.info("Human.clients.webSocketClient", JSON.stringify(message));

                            if (message.action === "connect") {

                                // Client requests connection

                                Human.log.info("Human.clients.webSocketClient", "Client connected");

                                // Accept connection

                                socket.emit('sendreply', socketServerChannel, { message: "connected" });

                                // Then send any buffered notification of error or readiness

                                if (error) {
                                    socket.emit('sendreply', socketServerChannel, { message: "error", error: error });

                                } else if (ready) {
                                    socket.emit('sendreply', socketServerChannel, { message: "ready" });
                                }

                            } else if (message.call) {

                                // Client makes an RPC call

                                handleCall(message);
                            }
                        });

                } catch (e) {
                    Human.log.error("Human.clients.webSocketClient#start", "Error initializing socket: " + e);
                }
            });
        });


    function loadSocketIO(ok) {
        var socketIOLibraryURL = socketServerURL + ":" + socketServerPort + "/socket.io/socket.io.js";
        Human.log.info("[Socket] Loading Socket.IO library from " + socketIOLibraryURL);
        require([socketIOLibraryURL], function (io) {
            ok(io);
        });
        /*
        var el = document.createElement('script');
        el.type = 'text/javascript';
        el.src = socketIOLibraryURL;
        el.onload = function () {
            ok();
        };
        document.body.appendChild(el);
        */
    }

    function sendResponse(message) {
        try {
            socket.emit('sendreply', socketServerChannel, message);
        } catch (e) {
            Human.log.error("Human.clients.webSocketClient#sendResponse", "Error sending response: " + e);
        }
    }

    function handleCall(message) {

        var procName = message.call;

        // Execute camera commands immediately to avoid queue lag

        if (procName === "camera.pan" ||
            procName === "camera.orbit" ||
            procName === "camera.flyTo" ||
            procName === "camera.jumpTo" ||
            procName === "camera.zoom" ||
            procName === "camera.getZoom" ||

            // Allow procedures marked with connected param to execute immediately (they are not related to the Human)

            (message.params && message.params.connected)) {

            executeCall(message);

            return;
        }

        if (countProcesses === 0) {      // Execute immediately if Human not busy

            // Human not busy, execute call

            executeCall(message);

        } else {

            // Human busy, buffer the call

            requestQueue.push(message);

            if (!requestQueuePumpInterval) {

                // Start call queue pump if not already running

                requestQueuePumpInterval = setInterval(
                    function () {

                        if (requestQueue.length > 0 && countProcesses === 0) {
                            executeCall(requestQueue.shift());
                        }

                        if (requestQueue.length === 0) {

                            // Stop pump when queue empty

                            clearInterval(requestQueuePumpInterval);
                            requestQueuePumpInterval = null;
                        }
                    }, 20);
            }
        }
    }

    function executeCall(message) {
        try {
            Human.rpc.call(message.id, message.call, message.params);
        } catch (e) {
            Human.log.error("Human.clients.webSocketClient", "Error executing RPC call [callId: " + message.id + ", procedure: " + message.call + "]: " + e);
        }
    }
})();
;/**
 Window messaging

 */
Human.clients.addClient(
    function (cfg) {
        "use strict";

        var client;
        var clientOrigin;
        var responseQueue = [];
        var rpcQueue = [];
        // TODO (Tarek): Human.processes no longer exists, so the queuing logic should be removed.
        var countProcesses = 0; // Stalls rpcQueue when > 0
        var pQueueInterval;

        Human.events.on("started",
            function () {
                sendResponse({ message: "status", status: "ready" });
            });

        if (window.addEventListener) {

            // Relay errors back to client
            Human.events.on("error",
                function (error) {
                    sendResponse({ error: error });
                });

            // Relay any RPC procedure call results back to client
            Human.rpc.onResult(
                function (key, value) {
                    var results = {};
                    results[key] = Human.rpc.filterUnsafeProperties(value);
                    sendResponse({ results: results });
                });

            // Handle messages from client
            addEventListener("message",
                function (event) {
                    var msg;
                    try {
                        msg = JSON.parse(event.data);
                    } catch (e) {
                        Human.log.error("Human.clients.windowClient", "JSON parse failed on an incoming Web message: " + e.message || e);
                        return;
                    }
                    if (msg.action === "connect") {
                        // Connection request
                        if (!client) {
                            Human.log.info("Human.clients.windowClient", "Client connected");
                            cfg.connected();
                            client = event.source;
                            clientOrigin = event.origin;
                            sendResponse({ message: "connected" });
                            flushResponseQueue();
                        }
                    } else {
                        // RPC call
                        if (msg.call) {
                            handleCall(msg);
                        }
                    }
                }, false);
        } else {
            Human.log.error("Human.clients.windowClient", "Browser does not support cross-window messaging");
        }

        function sendResponse(json) {
            var message = JSON.stringify(json);
            if (!client) {
                responseQueue.push(message);
                return;
            }
            client.postMessage(message, clientOrigin);
        }

        function flushResponseQueue() {
            while (responseQueue.length > 0) {
                client.postMessage(responseQueue.pop(), clientOrigin);
            }
        }

        function handleCall(msg) {
            var procName = msg.call;
            // Execute camera commands immediately to avoid queue lag
            if (procName === "camera.pan" ||
                procName === "camera.orbit" ||
                procName === "camera.flyTo" ||
                procName === "camera.jumpTo" ||
                procName === "camera.zoom" ||
                //allow procedures marked with connected param to execute immediately (they are not related to the Human)
                (msg.params && msg.params.connected)) {
                executeCall(msg);
                return;
            }
            if (countProcesses === 0) {      // Execute immediately if Human not busy
                executeCall(msg);
            } else {
                rpcQueue.push(msg);        // Else enqueue
                if (!pQueueInterval) {
                    pQueueInterval = setInterval(
                        function () {
                            if (rpcQueue.length > 0 && countProcesses === 0) {
                                executeCall(rpcQueue.shift());
                            }
                            if (rpcQueue.length === 0) {
                                clearInterval(pQueueInterval);
                            }
                        }, 20);
                }
            }
        }

        function executeCall(msg) {
            if (!Human.rpc.windowClientEnabled) {
                return;
            }
            try {
                Human.rpc.call(msg.id, msg.call, msg.params);
                Human.rpc.log(msg.call);
            } catch (e) {
                Human.log.error("Human.clients.windowClient", "Error executing RPC call [callId: " + msg.id + ", procedure: " + msg.call + "]: " + e);
            }
        }

    });


;(function () {
    "use strict";

    var HumanCookies = Human.cookies = {};

//    /**
//     * Values of all available cookies
//     * @type {String:String}
//     */
//    HumanCookies.cookies = {};
//
//    // Get the document's cookies
//    var c = document.cookie.split(';');
//    var tokens;
//    for (var i = 0, len = c.length; i < len; i++) {
//        tokens = c[i].split('=');
//        if (tokens.length == 2) {
//            HumanCookies.cookies[tokens[0]] = tokens[1];
//        }
//    }
//
//    /**
//     * Sets or removes a cookie
//     *
//     * @memberof Human.cookies
//     * @param {String} name Cookie name
//     * @param {String} [value] Cookie value - clears the cookie when null or omitted
//     */
//    HumanCookies.setCookie = function (name, value) {
//        if (value == undefined || value == null) {
//            // Clear cookie
//            delete HumanCookies.cookies[name];
//        } else {
//            // Set cookie
//            HumanCookies.cookies[name] = value;
//        }
//        save.call(this);
//    };
//
//    // Saves cookies on the document
//    function save() {     // TODO: Deferred call on tick if called frequently?
//        var list = [];
//        var numCookies = 0;
//        for (var name in HumanCookies.cookies) {
//            if (HumanCookies.cookies.hasOwnProperty(name)) {
//                if (numCookies++ > 0) {
//                    list.push(";");
//                }
//                list.push(name);
//                list.push("=");
//                list.push(HumanCookies.cookies[name]);
//            }
//        }
//        document.cookie = list.join("");
//    }

    HumanCookies.setCookie = function (name, value, days) {
        var expires;

        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toGMTString();
        }
        else {
            expires = "";
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    };

    HumanCookies.getCookie = function (name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
            }
        }
        return null;
    };

    HumanCookies.eraseCookie = function (name) {
        HumanCookies.setCookie(name, "", -1);
    };
})();;/**
 * @namespace Provides methods for installing initialization scripts and resetting the engine.
 */
(function () {
    "use strict";

    var HumanInit = Human.init = {};

    var started = false;

    /**
     * Bookmark of Human's initial state. An full engine reset is performed by restoring this bookmark.
     * @type {{}}
     * @memberof Human.init
     */
    HumanInit.bookmark = {};

    /**
     * Bookmark of Human's initial camera state. A camera reset is performed by restoring this bookmark.
     * @type {{}}
     * @memberof Human.init
     */
    HumanInit.cameraBookmark = {};

    var urlParams = Human.request.getHashParams();
    var pluginsPath = location.origin + location.pathname.substring(0, location.pathname.lastIndexOf("/")) + "/lib/scenejs/plugins";
    var validateShaders = (urlParams.validateShaders === "true");
    var enableVAO = (urlParams.enableVAO !== "false");
    var enableInterleaving = (urlParams.enableInterleaving !== "false");

    // Configure SceneJS
    SceneJS.setConfigs({
        texturing: {
            waitForLoad: true // Set true to make objects wait for their material's textures to load
        },
        // Where SceneJS finds its plugin bundle
        pluginPath: pluginsPath,
        statusPopups: false, // Disable the default status popups
        validateShaders: validateShaders, // Validate shaders before drawing with them - debug mode only
        enableVAO: enableVAO, // Enable or disable the "OES_vertex_array_object" WebGL extension
        enableInterleaving: enableInterleaving // Enable or disable vertex array interleaving
    });

    /**
     * Saves engine state to restore to when {@link #reset} is called.
     * If the engine has multiple modules currently active, then the bookmark will capture only
     * the activation of the first module that was activated. For example, is we have two modules active,
     * say, male anatomy and healthy heart beat, then restoring the bookmark will put the engine back
     * into the state it was in right after loading, before the user selected a condition or
     * bookmark, or whatever additional content.
     */
    HumanInit.saveReset = function () {
        var bookmark = Human.bookmarks.capture();
        var modules = bookmark.modules;
        if (modules) {
            var active = modules.active;
            if (active && active.length > 1) {
                // Ensure only first active module will be reactivated when bookmark restored
                modules.active = [modules.active[0]];
            }
        }
        HumanInit.bookmark = bookmark;
        if (!!Human.timeline.activeRoot){
            // If engine loaded with a module.
            HumanInit.bookmark.camera = Human.timeline.activeRoot._chapters[0].camera.location;
        }

        HumanInit.bookmarkCamera = HumanInit.bookmark.camera;
    };

    /**
     * Resets Human state to how it was just after it started up, ie before the user modifies the
     * view, activates a module, or loads a bookmark.
     *
     * @name reset
     * @function
     * @param {Function} [ok] Callback which signals when reset complete
     * @memberof Human.init
     */
    HumanInit.reset = function (ok) {
        // Resets app by restoring its state to the
        // bookmark that was captured after startup
        if (!HumanInit.bookmark) {
            Human.log.error("Human.init.reset", "Bookmark for reset was not captured");
            if (ok) {
                ok();
            }
            return;
        }
        Human.view.lights.restoreDefaults();
        Human.bookmarks.restore(HumanInit.bookmark,
            function () {
                Human.events.fire("init.reset");
                if(ok) {
                    ok();
                }
            },
            function (err) {
                Human.log.error("Human.init.reset", "Reset failed: " + err);
                if (ok) {
                    ok();
                }
            });
    };

    /**
     * Resets Human camera state to how it was just after it started up, ie before the user modifies the
     * view, activates a module, or loads a bookmark.
     *
     * @name resetCamera
     * @function
     * @param {Function} [ok] Callback which signals when camera reset complete
     * @memberof Human.init
     */
    HumanInit.resetCamera = function (ok) {

        // try to reset to camera of current chapter
        var currentChapterLookat = Human.timeline.getCurrentChapterCamera();
        if (currentChapterLookat) {
            Human.view.camera.fly.flyTo(currentChapterLookat, ok);
            return;
        }

        // Try to reset to the initial camera position off the most recently activated module,
        // otherwise reset to the camera that was captured after the engine started up.

        var mostRecentModule;
        var module;
        var time = 0;
        var activeModules = Human.modules.activeModules;
        for (var moduleId in activeModules) {
            if (activeModules.hasOwnProperty(moduleId)) {
                module = activeModules[moduleId];
                if (module.camera && module.timeActivated > time) {
                    mostRecentModule = module;
                }
            }
        }
        if (mostRecentModule) {
            Human.view.camera.fly.flyTo(mostRecentModule.camera, ok);
            return;
        }

        // Reset to camera bookmarked after startup
        if (!HumanInit.bookmark) {
            Human.log.error("Human.init.resetCamera", "Bookmark for reset was not captured");
            if (ok) {
                ok();
            }
            return;
        }
        Human.view.camera.fly.flyTo(HumanInit.bookmark.camera, ok);
    };

    /** Reloads the page/frame that contains the engine
     * @function
     * @name reload
     * @memberof Human.init
     */
    HumanInit.reload = function () {
        window.location.reload(); // No point in chaining further commands
    };

    /** Init the engine
     *
     */
    HumanInit.init = function (ok) {
        // Initialize websocket for assets
        Human.assets.server.init();

        // Initialize SceneJS renderer, which initialized asynchronously because
        // it may have to pull in lazy-loaded plugins for extra scene node types.
        Human.renderer.init(function () {

            // Renderer ready and all engine JS scripts loaded
            Human.events.fire("loaded");

            if (ok) {
                ok();
            }
        });
    };

    /** Start the engine
     *
     */
    HumanInit.start = function () {
        started = true;
        HumanInit.saveReset();
        Human.events.fire("started");
    };

})();
;/**
 * Human.renderer
 *
 * @namespace Provides access to the SceneJS WebGL engine
 */
(function () {

    "use strict";

    var HumanRenderer = Human.renderer = {
        highlightColor: new Float32Array([1.5, 1.5, 0.5]),
        xrayBGColor: new Float32Array([0, 0, 0.1])
    };

    HumanRenderer.NULL_OBJECT_ID = "null-object";   // ID of invisible object at origin, used for anchoring things like labels to

    var scene;
    var sceneGlobalsDirty = false;

    var enableFog = false;
    var fogMode = SceneJS.DISPLAY_FLAGS.FOG_LINEAR;
    var fogDensity = 0.01;
    var fogStart = 0;
    var fogEnd = 1000;
    var fogMin = 0.0;
    var fogMax = 1.0;
    var fogColor = new Float32Array([1, 1, 1]);

    Human.properties.subscribe({
        propId: "highlight.color",
        value: HumanRenderer.highlightColor,
        callback: function (value) {
            HumanRenderer.highlightColor = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.enabled",
        value: enableFog,
        callback: function (value) {
            enableFog = value;
            sceneGlobalsDirty = true;

        }
    });

    Human.properties.subscribe({
        propId: "fog.mode",
        value: fogMode,
        callback: function (value) {
            fogMode = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.start",
        value: fogStart,
        callback: function (value) {
            fogStart = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.end",
        value: fogEnd,
        callback: function (value) {
            fogEnd = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.min",
        value: fogMin,
        callback: function (value) {
            fogMin = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.max",
        value: fogMax,
        callback: function (value) {
            fogMax = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.density",
        value: fogDensity,
        callback: function (value) {
            fogDensity = value;
            sceneGlobalsDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "fog.color",
        value: fogColor,
        callback: function (value) {
            fogColor = value;
            sceneGlobalsDirty = true;
        }
    });

    HumanRenderer.init = function (ok) {

        scene = HumanRenderer.graph.init();

        // Lost WebGL context testing
        // keep this here for quick check on how well that's handled

        var timeStarted = Date.now();
        var timeLast = timeStarted;
        var tick = 0;

        scene.on("tick",
            function () {

                if (sceneGlobalsDirty) {
                    updateSceneGlobals();
                }

                var timeNow = Date.now();

                Human.events.fire("tick", {
                    timeStarted: timeStarted,
                    timeLast: timeLast,
                    timeNow: timeNow,
                    tick: tick
                });

                timeLast = timeNow;
                tick++;
            });

        scene.on("render",
            function () {
                Human.events.fire("render");
            });

        scene.on("sleep", // Fired after SceneJS finds 3D view needs no refresh
            function () {
                Human.events.fire("Scene.Sleep");
            });

        if (ok) {
            ok();
        }
    };

    HumanRenderer.setFPS = function (fps) {
        scene.setFPS(fps);
    };

    HumanRenderer.updateDisplayForBG = function () {
        sceneGlobalsDirty = true;
    };

    /**
     * Pauses the renderer.
     *
     * <p>This actually pushes a 'pause' directive onto a stack. Only once the same number of pops are done
     * with {@link #popPause} will the renderer unpause again.</p>
     *
     * <p>You would normally do this when you want to do batches of content creation, to prevent the
     * renderer from slowing things down as it works to keeps the 3D view in synch. Then when you've
     * done all your creation, you'd unpause the renderer again.</p>
     */
    HumanRenderer.pushPause = function () {
        HumanRenderer._pauses = (!HumanRenderer._pauses) ? 1 : HumanRenderer._pauses + 1;
        if (HumanRenderer._pauses === 1) {
            scene.pause(true);
        }
    };

    /**
     * Un-pauses the renderer.
     *
     * <p>As described in {@link #pushPause}, this pops a pause directive that was made with that method. Only once the same
     * number of pops are done with this method will the renderer unpause again.</p>
     */
    HumanRenderer.popPause = function () {
        if (!HumanRenderer._pauses) {
            return;
        }
        if (--HumanRenderer._pauses === 0) {
            scene.pause(false);
            scene.renderFrame();   // Forces garbage collection
        }
    };


    HumanRenderer.pauseCompilation = function () {
        scene.pauseCompilation();
    };

    HumanRenderer.resumeCompilation = function () {
        scene.resumeCompilation();
    };

    /**
     * Fires callback as soon as current task count is zero
     */
    HumanRenderer.onTasksComplete = function (ok) {
        if (HumanRenderer._pauses !== undefined && HumanRenderer._pauses !== null && HumanRenderer._pauses > 0) {
            Human.log.error("Human.renderer.onTaskComplete", "Renderer deadlock: Human.renderer.pushPause has " +
                "paused renderer. Renderer needs to be unpaused in order to complete pending tasks.");
        }
        var numTasks = Human.renderer.getScene().getStatus().numTasks;
        if (!numTasks || numTasks === 0) {
            ok();
            return;
        }
        if (HumanRenderer.__checkLoaded) {
            throw "Human.renderer.onTasksComplete: already blocking";
        }
        HumanRenderer.__checkLoaded = window.setInterval(
            function () {
                var numTasks = Human.renderer.getScene().getStatus().numTasks;
                if (!numTasks || numTasks === 0) {
                    window.clearInterval(HumanRenderer.__checkLoaded);
                    HumanRenderer.__checkLoaded = null;
                    ok();
                }
            }, 200);
    };

    // Force compilation of the SceneJS scenegraph
    HumanRenderer.compile = function () {
        scene.compile();
    };

    /** Forces renderer to render a frame
     */
    HumanRenderer.forceRenderFrame = function () {
        scene.renderFrame({force: true});
    };

    var rayPickEnabled = false;

    /**
     * Enable or disable ray-picking mode
     * You'd only want ray picking enabled when you're actually going to do the sort of
     * picking that needs 3D intersection results, like attaching annotations. Otherwise
     * you'd want ray-picking off, for things like regular object selection.
     * @param enable
     */
    HumanRenderer.enableRayPick = function (enable) {
        rayPickEnabled = enable;
    };

    HumanRenderer.pick = function (canvasX, canvasY, rayPick) {
        if (!scene) {
            Human.log.error("Human.renderer.pick", "Engine not started, ignoring pick");
            return null;
        }
        return scene.pick(canvasX, canvasY, {rayPick: rayPick});
    };

    HumanRenderer.getScene = function () {
        return SceneJS.scene(Human.SCENE_ROOT_ID);
    };

    HumanRenderer.getContentRootNode = function () {
        return HumanRenderer.getNode(Human.CONTENT_ROOT_ID);
    };

    HumanRenderer.getNode = function (nodeId) {
        return scene.findNode(nodeId);
    };

    HumanRenderer.getLookAt = function () {
        return HumanRenderer.getNode(Human.LOOKAT_ID);
    };

    HumanRenderer.nodeExists = function (nodeId) {
        var node = scene.findNode(nodeId);
        return (node !== null && node !== undefined);
    };

    /**
     * Returns the 4x4 View transform matrix.
     * <p>Transform World-space coordinates by this matrix to obtain View-space coordinates.</p>
     */
    HumanRenderer.getViewMat = function () {
        return HumanRenderer.getNode(Human.LOOKAT_ID).getMatrix();
    };

    /**
     * Returns the 4x4 Projection transform matrix.
     * <p>Transform View-space coordinates by this matrix to obtain Canvas-space coordinates.</p>
     */
    HumanRenderer.getProjMat = function () {
        return HumanRenderer.getNode(Human.CAMERA_ID).getMatrix();
    };

    /**
    *    Check if a WebGL extension is supported on the client
    */
    HumanRenderer.checkWebGLExtension = function(extension) {
        return SceneJS.checkExtension(extension);
    };

    HumanRenderer.setXrayBGColor = function(color) {
        this.xrayBGColor.set(color);
        scene.setXrayBGColor(color[0], color[1], color[2]);
    };

    HumanRenderer.setXrayGlassFactor = function(glassFactor) {
        scene.setXrayGlassFactor(glassFactor);
    };

    HumanRenderer.setXrayMurkiness = function(murkiness) {
        scene.setXrayMurkiness(murkiness);
    };

    function updateSceneGlobals() {
        scene.setFogEnabled(enableFog);
        scene.setFogMode(fogMode);
        scene.setFogStart(fogStart);
        scene.setFogEnd(fogEnd);
        scene.setFogMin(fogMin);
        scene.setFogMax(fogMax);
        scene.setFogDensity(fogDensity);
        scene.setFogColor(fogColor[0], fogColor[1], fogColor[2]);

        sceneGlobalsDirty = false;
    }

})();
;(function() {
    "use strict";

    var contentRootID = Human.CONTENT_ROOT_ID;  // TODO: Get rid of Human.CONTENT_ROOT_ID, no need to make public now
    var libraryRootID = "assetLibraryRoot";

    var sceneRootNode;
    var contentRootNode;


    var NODE_ORDER_RANK = {
        xform:          1,
        properties:     2,
        texture:        3,
        material:       3,
        reflect:        3,
        fresnel:        3,
        billboard:      3,
        morphGeometry:  4,
        geometry:       5
    };

    var graph = Human.renderer.graph = {};

    /**
     * Root nodes of built-in subtrees.
     *
     * Insert core-shared asset nodes into this with:
     *
     * #insertNode( #rootNodes.library, myAssetNode );
     *
     * etc.
     *
     * @type {{String: SceneJS.Node}}
     */
    graph.rootNodes = {

        /**
         * Root node of the library subgraph.
         * Insert core-shared asset nodes into this with #insertNode( #libraryRootNode, myAssetNode );
         * @type {SceneJS.Library}
         */
        library: null,
    };

    // This allows for super sample anti-aliasing if anti-aliasing isn't available on the WebGL context
    graph.SSAA_MULTIPLIER = (function () {
        var ssaaParam = parseInt(Human.request.getSearchParam("forceSSAA"), 10);

        if (ssaaParam >= 1) {
            return ssaaParam;
        }

        var canvas = document.createElement("canvas");
        var gl = canvas.getContext("webgl", {antialias: true}) || canvas.getContext("experimental-webgl", {antialias: true});

        return gl && gl.getContextAttributes().antialias ? 1 : 2;
    })();

    // Create scene graph
    var SCENE_DEFINITION = {
        type: "scene",
        id: Human.SCENE_ROOT_ID,
        canvasId: Human.CANVAS_ID,
        // transparent canvas
        transparent: true,

        contextAttr: {

            // Default: false. If false, once the drawing buffer is presented as described in theDrawing Buffer
            // section, the contents of the drawing buffer are cleared to their default values. All elements of the
            // drawing buffer (color, depth and stencil) are cleared. If the value is true the buffers will not be
            // cleared and will preserve their values until cleared or overwritten by the author.
            // On some hardware setting the preserveDrawingBuffer flag to true can have significant performance implications.
            // http://code.google.com/p/chromium/issues/detail?id=82086
            preserveDrawingBuffer: false,
            antialias: true
        },

        nodes: [
            {type: "library", id: "assetLibraryRoot"},

            // Camera for projection
            {
                type: "camera",
                id: Human.CAMERA_ID,
                optics: { 
                    type: "perspective",
                    fov: 60, 
                    near: 0.01,
                    far: 400.0,
                    fovAxis: "y"
                },

                // Screen-space pan
                pan: {x: 0, y: 0, z: 0},

                nodes: [

                    // Illuminated annotation labels in their own frustum space
                    // Don't rely on SceneJS default lookat for label wires
                    {
                        type: "lookAt", eye: {x: 0.0, y: 0.0, z: 0.05}, look: {x: 0.0, y: 0, z: 0}, up: {y: 1.0},
                        nodes: [
                            {
                                type: "lights",
                                lights: [
                                    {
                                        mode: "dir",
                                        color: {r: 1.0, g: 1.0, b: 1.0},
                                        dir: {x: 0.0, y: 0.0, z: -1.0},
                                        diffuse: true, specular: true, space: "view"
                                    }
                                ],
                                nodes: [
                                    {type: "node", id: "annotation-labels"}
                                ]
                            }
                        ]
                    },

                    // Main view transform
                    {
                        // Camera attributes will be overwritten by Human.view.camera
                        type: "lookAt",
                        id: Human.LOOKAT_ID,
                        eye: {x: 0.0, y: 0.0, z: 55}, look: {x: 0.0, y: 0, z: 0}, up: {y: 1.0},
                        nodes: [

                            // Clip indicators
                            {
                                type: "properties",
                                id: Human.CLIP_INDICATORS_ATTACH_ID,
                                properties: {picking: false, layer: 10000}
                            },

                            // Clipping planes will be inserted here
                            // See ./view/clip/clip.js
                            {
                                id: "clips",
                                nodes: [

                                    // Annotation 3D occlusion test primitives are inserted here
                                    // See ./view/annotations/utils/occlusionQuery.js
                                    {
                                        id: "occlusionIndicators"
                                    },

                                    // Lights node will be inserted here, above "lights.subtree"
                                    // See ./view/lights/lights.js
                                    {
                                        id: "lights",
                                        nodes: [

                                            // Subnodes of lights
                                            {
                                                id: "lights.subtree",
                                                nodes: [

                                                    // Postprocessing nodes will be inserted here, above "effects.subtree"
                                                    // See ./view/effects/effects.js
                                                    {
                                                        id: "effect",
                                                        nodes: [

                                                            // Subnodes of effects
                                                            {
                                                                id: "effect.subtree",
                                                                nodes: [


                                                                    // Default material around content
                                                                    {
                                                                        type: "material", id: Human.MATERIAL_ROOT_ID,
                                                                        emit: 0, baseColor: { r: 0.9, g: 0.9, b: 0.9 },
                                                                        specularColor: { r: 0.9, g: 0.9, b: 0.9 }, specular: 0.9,
                                                                        shine: 100.0,
                                                                        nodes: [

                                                                            // Null objects - hack to give global labels something to bind to.
                                                                            // Note we avoid scaling transforms around the null object, because
                                                                            // those will distort the offset that is fed into the "rendered"
                                                                            // handler.
                                                                            // We have multiple null objects - one for labels, another for
                                                                            // annotations. For some reason those clobber each other when on
                                                                            // same null object.

                                                                            // Null object #1
                                                                            {
                                                                                type: "node", id: Human.renderer.NULL_OBJECT_ID,
                                                                                enableEvents: true,
                                                                                nodes: [
                                                                                    // Infintesimally small dummy triangle.
                                                                                    //
                                                                                    // Was getting SceneJS problems with primitives like "points"
                                                                                    // and "lines" where the lighting/shading states of other
                                                                                    // "triangles" geometries subsequent in the scene
                                                                                    // were not applied, ie. coming up black for some reason.
                                                                                    {
                                                                                        type: "geometry",
                                                                                        positions: [0, 0, 0, 0.1, 0.1, 0.1, 0.2, 0.2, 0.2],
                                                                                        indices: [0, 1, 2],
                                                                                        uv: [0, 0, 1, 0, 1, 1],
                                                                                        normals: [0, 1, 0, 0, 1, 0, 0, 1, 0], // Above error happens when normals missing
                                                                                        primitive: "triangles"

                                                                                    }
                                                                                ]
                                                                            },

                                                                            // Default flags at content root
                                                                            // Content attached here
                                                                            {
                                                                                type: "properties",
                                                                                id: contentRootID,
                                                                                properties: {
                                                                                    picking: true,
                                                                                    enabled: true,
                                                                                    specular: true,
                                                                                    backfaceLighting: true,
                                                                                    backfaceTexturing: true,
                                                                                    backfaces: true,
                                                                                    reflection: false
                                                                                }
                                                                            }
                                                                        ]
                                                                    },

                                                                    // Object Boundary - shown when flying. rotating. panning etc
                                                                    {
                                                                        type: "properties",
                                                                        id: "object-boundary-flags",
                                                                        properties: { enabled: false, transparent: true, clipping: false },
                                                                        nodes: [
                                                                            {
                                                                                type: "material",
                                                                                baseColor: {r: 0.0, g: 1.0, b: 0.0},
                                                                                specularColor: { r: 0.0, g: 1.0, b: 0.0 },
                                                                                emit: 1.0, alpha: 0.4,
                                                                                nodes: [
                                                                                    {
                                                                                        type: "style",
                                                                                        lineWidth: 1, // Thickness of boundary box wire
                                                                                        nodes: [
                                                                                            {
                                                                                                type: "geometry",
                                                                                                id: "object-boundary-geo",
                                                                                                positions: [
                                                                                                    1.0, 1.0, 1.0, 1.0, -1.0, 1.0,
                                                                                                    -1.0, -1.0, 1.0, -1.0, 1.0, 1.0,
                                                                                                    1.0, 1.0, -1.0, 1.0, -1.0, -1.0,
                                                                                                    -1.0, -1.0, -1.0, -1.0, 1.0, -1.0
                                                                                                ],
                                                                                                primitive: "lines",
                                                                                                indices: [
                                                                                                    0, 1, 1, 2, 2, 3, 3, 0, 4,
                                                                                                    5, 5, 6, 6, 7, 7, 4, 0, 4,
                                                                                                    1, 5, 2, 6, 3, 7
                                                                                                ]
                                                                                            }
                                                                                        ]
                                                                                    }
                                                                                ]
                                                                            }
                                                                        ]
                                                                    }
                                                                ]
                                                            }
                                                        ]
                                                    }
                                                ]
                                            }
                                        ]
                                    }
                                ]
                            }
                        ]
                    }
                ]
            }
        ]
    };

    graph.init = function() { // TODO: Why not build whole scene graph here?

        var simulateWebGLContextLost = Human.request.getSearchParam("testContextLost");

        sceneRootNode = SceneJS.createScene(SCENE_DEFINITION, {
            resolutionScaling: graph.SSAA_MULTIPLIER,
            simulateWebGLContextLost: !!simulateWebGLContextLost
        });

        if (simulateWebGLContextLost) {

            var interval = parseInt(simulateWebGLContextLost);

            // Simulate WebGL context loss on interval
            window.setInterval(
                function () {

                    //  alert("losing webgl context");
                    sceneRootNode.loseWebGLContext();

                }, interval * 1000);
        }

        contentRootNode = sceneRootNode.getNode(contentRootID);

        graph.rootNodes.library = sceneRootNode.getNode(libraryRootID);

        return sceneRootNode;
    };

    /**
     * Creates a subtree within this render graph. You can then call #insertNode to create nodes
     * within the subtree, or #destroySubtree to destroy the subtree.
     *
     * @param {SceneJS.Node} [parent] Optional leaf node belonging to a parent Human.sceneObject.
     * @returns {SceneJS.Node} Root of new subtree.
     */
    graph.createSubtree = function(parent, node) {

        // Eventually, we'll not create roots within roots, where the SceneJS subgraphs for Human objects will
        // be flat, ie. not nested within the SceneJS scene graph. Before we do that however, we need to manage the
        // nested coordinate spaces (ie multiplication of nested matrices) within Human, rather than rely on
        // SceneJS' inherited coordinate spaces, as we do currently.

        if (!contentRootNode) {
            throw "Not initialized - call #init first";
        }

        var rootNode;

        if (parent) {
            rootNode = parent.addNode(node);
        } else {
            rootNode = contentRootNode.addNode(node);
        }

        return rootNode;
    };

    /**
     * Inserts a SceneJS node into the given subtree, which must have been created earlier with #createSubtree.
     *
     * The subtree can either be one of the built-in subtrees in #rootNodes,
     * or one that was created earlier with #createSubtree.
     *
     * @param {SceneJS.Node} rootNode Root of subtree.
     * @param {SceneJS.Node | *} insertNode Node to insert, given as either instance or JSON config.
     * @returns {SceneJS.Node} Node that was newly inserted.
     */
    graph.insertNode = function(rootNode, insertNode) {

        if (insertNode instanceof SceneJS.Node) {
            if (insertNode.parent.type === "library") {
                insertNode.disconnect();
            } else {
                insertNode = {
                    type: insertNode.type,
                    coreId: insertNode.getCoreId()
                };
            }
        }

        var type = insertNode.type;
        var insertNodeScore = NODE_ORDER_RANK[type];

        var currentNode = rootNode;

        while(currentNode) {
            var currentNodeScore = NODE_ORDER_RANK[currentNode.type] ? NODE_ORDER_RANK[currentNode.type] : 0;

            if(insertNodeScore < currentNodeScore) {
                var parent = currentNode.parent;

                currentNode.disconnect();
                insertNode = parent.addNode(insertNode);

                insertNode.addNode(currentNode);

                return insertNode;
            } else if(currentNode.nodes.length === 0) {
                return currentNode.addNode(insertNode);
            }

            currentNode = currentNode.nodes[0];
        }
    };

    // Remove a node type from an object chain of SceneJS
    // NOTE(Tarek): Assumes no branching in SceneJS nodes!
    graph.detachNodes = function(rootNode, type) {

        var currentNode = rootNode;

        while(currentNode) {
            
            if(currentNode.type === type) {
                var parent = currentNode.parent;
                currentNode.splice();
                currentNode.destroy();
                currentNode = parent;
            }

            currentNode = currentNode.nodes[0];
        }
    };

    /**
     * Destroys the given subtree, which must have been created earlier with #createSubtree.
     * Also destroys all nodes that were inserted into the subtree with #insertNode.
     *
     * @param {SceneJS.Node} rootNode Root of subtree to destroy.
     */
    graph.destroySubtree = function(rootNode) {

        // For API pedantry make sure we don't destroy one of the built-in subtree roots
        var rootNodes = this.rootNodes;
        for (var key in rootNodes) {
            if (rootNodes.hasOwnProperty(key)) {
                if (rootNodes[key].id === rootNode.id) {
                    Human.log.warn("Human.renderer.graph.destroySubtree", "Tried to destroy one of the built-in root nodes");
                    return;
                }
            }
        }

        rootNode.destroy();
    };

})();
;/**
 * Human.renderer.bg
 *
 * @namespace Get and set the background color
 */
(function () {
    "use strict";

    var HumanRendererBG = Human.renderer.bg = {};
    var bgColor = null;

    HumanRendererBG.getBGColor = function () {
        var _bgColor = null;

        if (bgColor) {
            _bgColor = [];

            for (var i = 0; i < bgColor.length; i++) {
                _bgColor.push(bgColor[i]);
            }
        }

        return _bgColor;
    };

    HumanRendererBG.setBGColor = function (_bgColor) {
      if(Array.isArray(_bgColor)) {
        bgColor = _bgColor;
      }
    };

})();
;/**
 * Human.renderer.canvas
 *
 * @namespace Manages the WebGL canvas
 */
(function () {
    "use strict";

    var canvas = $("#" + Human.CANVAS_ID);
    var annotationCanvas = $("#" + Human.ANNOTATION_CANVAS_ID);
    document.getElementById("annotationCanvas").getContext('2d'); // ensures 2d context remains available.
    Human.renderer.canvas = {
        canvas: canvas,
        getCanvas: function() {
            return canvas;
        },
        annotationCanvas: annotationCanvas,
        getAnnotationCanvas: function() {
            return annotationCanvas;
        }
    };

    // HACK for UI compatibility
    Human.renderer.resize = resize;

    $(window).resize(resize);

    resize();

    function resize() {

        var canvasBody = canvas.parent();

        var canvasWidth = canvasBody.width();
        var canvasHeight = canvasBody.height();

        var ssaaMultiplier = Human.renderer.SSAA_MULTIPLIER;

        canvas.attr({
            width: canvasWidth * ssaaMultiplier,
            height: canvasHeight * ssaaMultiplier
        });
        canvas.css({ width: canvasWidth, height: canvasHeight });

        annotationCanvas.attr({ width: canvasWidth, height: canvasHeight });

        Human.events.fire("canvas.resized", {
            canvasWidth: canvasWidth,
            canvasHeight: canvasHeight
        });
    }

})();
;/**
 * Human.tasks
 *
 * @namespace Provides ability to schedule asynchronous tasks to a FIFO queue that is pumped on each frame.
 */
(function () {

    "use strict";

    var HumanTasks = Human.tasks = {};

    // How long in milliseconds we're allowed to spend in each frame
    // processing tasks scheduled with #scheduleTask
    var TASK_BUDGET_MSECS = 8;

    Human.events.on("tick",
        function () {

        var timeNow = Date.now();

        // Process as many enqueued tasks as we can
        // within the per-frame task budget

        HumanTasks._runScheduledTasks(timeNow + TASK_BUDGET_MSECS);
    });

    // Task queue, which is pumped on each frame;
    // tasks are pushed to it with calls to #schedule

    HumanTasks._taskQueue = [];

    /**
     * Schedule a task to run at a sunsequent frame.
     *
     * Internally, this pushes the task to a FIFO queue. Within each frame interval, we process the queue
     * for a certain period of time, popping tasks and running them. After each frame interval, tasks that did not
     * get a chance to run during the task are left in the queue to be run next time.
     *
     * @method schedule
     * @param {Function} callback Callback that runs the task.
     * @param {Object} [scope] Scope for the callback.
     */
    HumanTasks.scheduleTask = function (callback, scope) {
        HumanTasks._taskQueue.push(callback);
        HumanTasks._taskQueue.push(scope);
    };

    // Pops and processes tasks in the queue, until the
    // given number of milliseconds has elapsed.
    HumanTasks._runScheduledTasks = function (until) {

        var time = Date.now();
        var taskQueue = HumanTasks._taskQueue;
        var callback;
        var scope;

        while (taskQueue.length > 0 && time < until) {
            callback = taskQueue.shift();
            scope = taskQueue.shift();
            if (scope) {
                callback.call(scope);
            } else {
                callback();
            }
            time = Date.now();
        }
    };
})();;/** @namespace Holds functionality relating to the way the {@link Human.scene} is viewed.
 *
 */
(function() {
  "use strict";

  var view = Human.view = {};

  var modes = ["Highlight", "Xray", "Isolate"];
  
  view.currentMode = modes[0];
  
  view.setModeEnabled = function (mode) {
      mode = mode.toLowerCase();
      
      if(mode === 'isolate') {
          if (!Human.scene.anySelected()) {
              alert("Please select an object before Isolating.");
              return;
          }
      } 
    
      var _modes = modes.map(function (mode) {
          return mode.toLowerCase();
      });
      
      var enabledIndex = _modes.indexOf(mode);
      
      if(enabledIndex >= 0) {
          _modes.forEach(function (mode, i) {
              var enable = (enabledIndex === i);
              Human.view[mode].setEnabled(enable);
          });
      }
  };
})();;/**
 * @namespace Manages the camera
 */
(function () {
    "use strict";

    var HumanViewCamera = Human.view.camera = {};

    // Scene graph nodes, initialized when engine loaded
    var lookatNode = null;
    var cameraNode = null;

    // Used in some methods for distance calculations
    var eyeVec = vec3.create();
    var lookVec = vec3.create();
    var upVec = vec3.create();
    var panVec = vec3.create();
    var eyeVecNorm = vec3.create();
    var upVecNorm = vec3.create();
    var leftVec = vec3.create();
    var tempVec = vec3.create();
    var tempMat4 = mat4.create();

    /**
     Current eye position
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanViewCamera.eye = { x: 0, y: 0, z: -80 };

    /**
     Current point-of-interest
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanViewCamera.look = { x: 0, y: 0, z: 0 };

    /**
     Current "up" vector
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanViewCamera.up = { x: 0, y: 1, z: 0 };
    
    HumanViewCamera._pan = vec3.create();

    HumanViewCamera.lookDistance = 80;

    /**
     * Offset added to the "look" point in View-space, allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     * @type {{x: number, y: number, z: number}}
     */
    HumanViewCamera._screenPan = {x: 0, y: 0, z: 0 };

    HumanViewCamera._startcamera = {
      eye: { x: 0, y: 0, z: -80 },
      look: { x: 0, y: 0, z: 0 },
      up: { x: 0, y: 1, z: 0 }
    };

    // Schedules scene graph updates when true

    var lookatNodeDirty = false;
    var cameraNodeDirty = false;

    // True when no scene graph updates pending
    var rested = false;

    /**
     * When true, causes camera to ignore calls to pan or rotate.
     * This is set and unset by Human.camera.fly to stop the user from panning or rotating
     * the camera while flight is in progress, which screws things up.
     */
    HumanViewCamera.lock = false;

    /**
     Camera aspect ration
     @type {number}
     @readonly
     */
    HumanViewCamera.aspect = 1;

    /**
     Field-ov-view angle on Y-axis
     @type {number}
     @readonly
     */
    HumanViewCamera.fovy = 55;

    // Field-of-View angle in degrees
    Human.properties.subscribe({
        propId: "camera.optics.fov",
        value: HumanViewCamera.fovy,
        callback: function (value) {
            HumanViewCamera.fovy = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Distance to the near clipping plane
     @type {number}
     @readonly
     */
    HumanViewCamera.near = 0.1;

    // Distance to near clipping plane
    Human.properties.subscribe({
        propId: "camera.optics.near",
        value: 0.1,
        callback: function (value) {
            HumanViewCamera.near = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Distance to the near clipping plane
     @type {number}
     @readonly
     */
    HumanViewCamera.far = 5000;

    // Distance to far clipping plane
    Human.properties.subscribe({
        propId: "camera.optics.far",
        value: 5000,
        callback: function (value) {
            HumanViewCamera.far = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Minimum allowed distance between {@link #eye} and {@link #look}
     @type {number}
     @readonly
     */
    HumanViewCamera.minZoom = 0.01;

    /**
     Maximum allowed distance between {@link #eye} and {@link #look}
     @type {number}
     @readonly
     */
    HumanViewCamera.maxZoom = 150;

    // Zoom limits - distance between eye and look
    Human.properties.subscribe({
        propId: "camera.zoomLimits",
        value: {
            min: 0.01,
            max: 150
        },
        callback: function (value) {
            if (value.min < 0.01) {
                Human.log.error("Human.view.camera", "Property 'camera.zoomLimits.min' too small - should be >= 0.01");
                return;
            }
            if (value.min >= value.max) {
                Human.log.error("Human.view.camera", "Property 'camera.zoomLimits.min' should be less than camera.zoomLimits.max");
                return;
            }
            HumanViewCamera.minZoom = value.min;
            HumanViewCamera.maxZoom = value.max;
            lookatNodeDirty = true;
        }
    });

    // Gimbal lock constraint
    // When true, camera is "gimbal locked" and spins about model's Y axis
    var gimbalLockY = true;


    // When engine started
    Human.events.on(
        "loaded",
        function () {

            // Get scene graph nodes

            HumanViewCamera._lookatNode = lookatNode = Human.renderer.getNode(Human.LOOKAT_ID);
            HumanViewCamera._cameraNode = cameraNode = Human.renderer.getNode(Human.CAMERA_ID);

            // Initialise projection aspect ratio

            var optics = cameraNode.getOptics();

            HumanViewCamera.aspect = optics.aspect;
            HumanViewCamera.fovy = optics.fovy;

            // Schedule update of view and projection transforms for next tick

            lookatNodeDirty = true;
            cameraNodeDirty = true;

            // Camera not at rest now
            rested = false;

        });

    // Adjust camera aspect on canvas resize
    Human.events.on("canvas.resized",
        function (params) {
            HumanViewCamera.setAspect(params.canvasWidth / params.canvasHeight);
        });

    Human.events.on(
        "render",
        function () {

            if (lookatNodeDirty) {

                // View transform update scheduled for scene graph

                lookatNode.setEye(HumanViewCamera.eye);
                lookatNode.setLook(HumanViewCamera.look);
                lookatNode.setUp(HumanViewCamera.up);

                Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
                Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
                vec3.subtract(tempVec, eyeVec, lookVec);

                Human.events.fire("camera.updated", {

                    // Camera position
                    eye: HumanViewCamera.eye,
                    look: HumanViewCamera.look,
                    up: HumanViewCamera.up,

                    // Distance from viewpoint to point-of-interest
                    dist: Math.abs(vec3.length(tempVec))
                });

                // Camera not at rest now
                rested = false;

                // Scene camera position now up to date
                lookatNodeDirty = false;

            } else {

                // Else camera position now at rest

                if (!rested) {

                    rested = true;

                    Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
                    Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
                    vec3.subtract(tempVec, eyeVec, lookVec);

                    Human.events.fire("camera.rested", {

                        // Camera position
                        eye: HumanViewCamera.eye,
                        look: HumanViewCamera.look,
                        up: HumanViewCamera.up,

                        // Distance from viewpoint to point-of-interest
                        dist: Math.abs(vec3.length(tempVec))
                    });
                }
            }

            if (cameraNodeDirty) {

                // Update the scene graph

                cameraNode.setOptics({
                        type: "perspective",
                        fov: HumanViewCamera.fovy,
                        near: HumanViewCamera.near,
                        far: HumanViewCamera.far,
                        aspect: HumanViewCamera.aspect,
                        fovAxis: "y"
                    });
                cameraNode.setPan(HumanViewCamera._screenPan);

                // Scene projection now up to date
                cameraNodeDirty = false;
            }

        });

    /**
     Sets the position of the camera.

     @param params
     @param [params.eye]
     @param [params.look]
     @param [params.up]
     */
    HumanViewCamera.setLookAt = function (params) {
        var eye = params.eye || HumanViewCamera.eye;
        var look = params.look || HumanViewCamera.look;
        var up = params.up || HumanViewCamera.up;

        // Not constrained, set state and schedule scene update

        HumanViewCamera.eye = eye;
        HumanViewCamera.look = look;
        HumanViewCamera.up = up;

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        HumanViewCamera.lookDistance = vec3.distance(eyeVec, lookVec);

        if (!params.preservePan) {
            HumanViewCamera._pan[0] = HumanViewCamera._pan[1] = HumanViewCamera._pan[2] = 0;
        }

        lookatNodeDirty = true;
    };

    /**
     Returns the position of this camera.
     @returns {{eye: *, look: *, up: *}}
     */
    HumanViewCamera.getLookAt = function () {
        return {
            eye: HumanViewCamera.eye,
            look: HumanViewCamera.look,
            up: HumanViewCamera.up
        };
    };

    /**
     * Sets offset added to the "look" position in View-space, which allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     *
     * @param {{x: number, y: number, z: number}} screenPan The View-space pan vector
     */
    HumanViewCamera.setScreenPan = function (screenPan) {
        HumanViewCamera._screenPan.x = screenPan.x || 0;
        HumanViewCamera._screenPan.y = screenPan.y || 0;
        HumanViewCamera._screenPan.z = screenPan.z || 0;
        cameraNodeDirty = true;
    };

    /**
     * Gets offset that's added to the "look" point in View-space, which allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     *
     * @return {{x: number, y: number, z: number}} The View-space pan vector
     */
    HumanViewCamera.getScreenPan = function () {
        return HumanViewCamera._screenPan;
    };

    HumanViewCamera._reset = {
        eye: { x: HumanViewCamera.eye.x, y: HumanViewCamera.eye.y, z: HumanViewCamera.eye.z },
        look: { x: HumanViewCamera.look.x, y: HumanViewCamera.look.y, z: HumanViewCamera.look.z },
        up: { x: HumanViewCamera.up.x, y: HumanViewCamera.up.y, z: HumanViewCamera.up.z }
    };

    /**
     * Resets this camera to initial position
     */
    HumanViewCamera.reset = function () {
        HumanViewCamera.yaw = 0;
        HumanViewCamera.pitch = 90;
        HumanViewCamera._eye = { x: HumanViewCamera._reset.eye.x, y: HumanViewCamera._reset.eye.y, z: HumanViewCamera._reset.eye.z };
        HumanViewCamera._look = { x: HumanViewCamera._reset.look.x, y: HumanViewCamera._reset.look.y, z: HumanViewCamera._reset.look.z };
        HumanViewCamera._up = { x: HumanViewCamera._reset.up.x, y: HumanViewCamera._reset.up.y, z: HumanViewCamera._reset.up.z };
        HumanViewCamera._pan = { x: 0, y: 0, z: 0 };
        lookatNodeDirty = true;
    };


    /**
     * Rotate 'eye' about 'look', around the 'up' vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */

    HumanViewCamera.rotateY = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        vec3.subtract(eyeVec, eyeVec, HumanViewCamera._pan);
        vec3.subtract(lookVec, lookVec, HumanViewCamera._pan);

        // Get 'look' -> 'eye' vector
        vec3.subtract(eyeVec, eyeVec, lookVec);

        // Rotate 'eye' vector about 'up' vector
        mat4.fromRotation(tempMat4, angle * 0.0174532925, gimbalLockY ? Human.math.Y_AXIS : upVec);
        vec3.transformMat4(eyeVec, eyeVec, tempMat4);
        vec3.transformMat4(HumanViewCamera._pan, HumanViewCamera._pan, tempMat4);

        // Set eye position as 'look' plus 'eye' vector
        vec3.add(eyeVec, eyeVec, lookVec);

        if (gimbalLockY) {

            // Rotate 'up' vector about orthogonal vector
            vec3.transformMat4(upVec, upVec, tempMat4);
        }

        vec3.add(eyeVec, eyeVec, HumanViewCamera._pan);
        vec3.add(lookVec, lookVec, HumanViewCamera._pan);

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },

            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },

            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            },
            preservePan: true
        });
    };



    /**
     * Rotate 'eye' about 'look' around the Orthogonal Vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */

    HumanViewCamera.rotateX = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        vec3.subtract(eyeVec, eyeVec, HumanViewCamera._pan);
        vec3.subtract(lookVec, lookVec, HumanViewCamera._pan);

        // Get 'look' -> 'eye' vector
        vec3.subtract(eyeVec, eyeVec, lookVec);

        vec3.normalize(eyeVecNorm, eyeVec);
        vec3.normalize(upVecNorm, upVec);

        // Get orthogonal vector from 'eye' and 'up'
        vec3.cross(leftVec, eyeVecNorm, upVecNorm);

        // Rotate 'eye' vector about orthogonal vector
        mat4.fromRotation(tempMat4, angle * 0.0174532925, leftVec);
        vec3.transformMat4(eyeVec, eyeVec, tempMat4);
        vec3.transformMat4(HumanViewCamera._pan, HumanViewCamera._pan, tempMat4);

        // Set eye position as 'look' plus 'eye' vector
        vec3.add(eyeVec, eyeVec, lookVec);

        // Rotate 'up' vector about orthogonal vector
        vec3.transformMat4(upVec, upVec, tempMat4);

        vec3.add(eyeVec, eyeVec, HumanViewCamera._pan);
        vec3.add(lookVec, lookVec, HumanViewCamera._pan);

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },

            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },

            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            },
            preservePan: true
        });
    };

    /**
     * Pans the camera along X and Y axis.
     * Applies constraints added with {@link #addConstraint}.
     * @param pan The pan vector
     */

    var eyeVec2 = vec3.create();

    HumanViewCamera.pan = function (pan) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        // Get eye, look and up as arrays
        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        vec3.subtract(eyeVec2, eyeVec, lookVec);

        // Building this pan vector
        panVec[0] = panVec[1] = panVec[2] = 0;

        if (pan.x !== undefined) {

            // Pan along orthogonal vector to 'look' and 'up'

            vec3.normalize(eyeVecNorm, eyeVec2);
            vec3.normalize(upVecNorm, upVec);

            var left = vec3.cross(leftVec, eyeVec2, upVec);
            vec3.normalize(left, vec3.cross(leftVec, eyeVec2, upVec));

            vec3.scale(tempVec, left, pan.x);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        if (pan.y !== undefined) {

            // Pan along 'up' vector
            vec3.normalize(upVecNorm, upVec);

            vec3.scale(tempVec, upVecNorm, pan.y);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        if (pan.z !== undefined) {

            // Pan along 'eye'- -> 'look' vector

            vec3.normalize(eyeVecNorm, eyeVec);

            vec3.scale(tempVec, eyeVecNorm, pan.z);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        vec3.add(eyeVec, eyeVec, panVec);
        vec3.add(lookVec, lookVec, panVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },
            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },
            preservePan: true
        });

        vec3.add(HumanViewCamera._pan, HumanViewCamera._pan, panVec);
    };

    /** Sets the projection aspect ratio
     */
    HumanViewCamera.setAspect = function (aspect) {
        HumanViewCamera.aspect = aspect;
        cameraNodeDirty = true;
    };

    /**
     Positions camera to look at the scene from along the -X axis.
     */
    HumanViewCamera.viewRight = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: -dist, y: elev, z: 0 },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the +X axis.
     */
    HumanViewCamera.viewLeft = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: dist, y: elev, z: 0 },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the +Z axis.
     */
    HumanViewCamera.viewPosterior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: elev, z: -dist },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the -Z axis.
     */
    HumanViewCamera.viewAnterior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: elev, z: dist },
            up: {x: 0, y: 1, z: 0 }
        });

    };

    /**
     Positions camera to look at the scene from along the +Y axis.
     */
    HumanViewCamera.viewSuperior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: -dist + elev, z: 0 },
            up: {x: 0, y: 0, z: 1 }
        });

    };

    /**
     Positions camera to look at the scene from along the +Y axis.
     */
    HumanViewCamera.viewInferior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: dist + elev, z: 0 },
            up: {x: 0, y: 0, z: -1 }
        });

    };

    /**
     * Increments/decrements zoom factor, ie. distance between eye and look.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @param delta
     */
    HumanViewCamera.zoom = function (delta) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        vec3.subtract(eyeVec, eyeVec, lookVec);            // Get vector from eye to look
        var lenLook = Math.abs(vec3.length(eyeVec));    // Get len of that vector
        var newLenLook = Math.abs(lenLook + delta);         // Get new len after zoom

        if (HumanViewCamera.minZoom && HumanViewCamera.maxZoom) {

            var f = (lenLook / HumanViewCamera.maxZoom) * 0.6;

            delta = (40 * delta) * f;

            newLenLook = Math.abs(lenLook + delta);

            if (newLenLook < HumanViewCamera.minZoom) {
                newLenLook = HumanViewCamera.minZoom;

            } else if (newLenLook > HumanViewCamera.maxZoom) {
                newLenLook = HumanViewCamera.maxZoom;
            }
        }

        vec3.normalize(eyeVecNorm, eyeVec);  // Get normalised vector
        vec3.scale(eyeVec, eyeVecNorm, newLenLook);
        vec3.add(eyeVec, lookVec, eyeVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },

            preservePan: true
        });
    };

    /**
     * Sets the zoom as a factor indicating a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @param {Number} zoomFactor The factor
     */
    HumanViewCamera.setZoom = function (zoomFactor) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        vec3.subtract(eyeVec, eyeVec, lookVec);  // Get vector from eye to look
        vec3.normalize(eyeVecNorm, eyeVec);  // Get normalised vector
        vec3.scale(eyeVec, eyeVecNorm, HumanViewCamera.minZoom + (1.0 - zoomFactor) * (HumanViewCamera.maxZoom - HumanViewCamera.minZoom));

        vec3.add(eyeVec, lookVec, eyeVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },
            preservePan: true
        });
    };

    /**
     * Returns the zoom as a factor indicating a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * @return {Number} The zoom factor
     */
    HumanViewCamera.getZoom = function () {

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        vec3.subtract(eyeVec, eyeVec, lookVec);            // Get vector from eye to look
        var lenLook = Math.abs(vec3.length(eyeVec));    // Get len of that vector

        return 1 - (((lenLook - HumanViewCamera.minZoom) / HumanViewCamera.maxZoom));
    };


    /**
     * Sets the zoom via a percentage factor which indicates a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @deprecated
     * @param {Number} zoomPercent The percentage factor
     */
    HumanViewCamera.setZoomPercent = function (zoomPercent) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        vec3.subtract(eyeVec, eyeVec, lookVec);  // Get vector from eye to look
        vec3.normalize(eyeVecNorm, eyeVec);  // Get normalised vector

        vec3.scale(eyeVec, eyeVecNorm, HumanViewCamera.minZoom + (100.0 - zoomPercent) * 0.01 * (HumanViewCamera.maxZoom - HumanViewCamera.minZoom));

        HumanViewCamera.setLookAt({
            eye: {
                x: lookVec[0] + eyeVec[0],
                y: lookVec[1] + eyeVec[1],
                z: lookVec[2] + eyeVec[2]
            }
        });
    };

    /**
     * @deprecated
     */
    HumanViewCamera.getZoomPercent = function () {

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        vec3.subtract(eyeVec, eyeVec, lookVec);            // Get vector from eye to look
        var lenLook = Math.abs(vec3.length(eyeVec));    // Get len of that vector

        return 100 - (((lenLook - HumanViewCamera.minZoom) / HumanViewCamera.maxZoom) * 100);
    };
})();
;/**
 * @namespace Manages camera curve path, an array of 3d cubic bezier curves
 */
(function () {
    "use strict";

    Human.view.camera.CurvePath = function() {
        var curves = [];

        var numPoints, numCurves;

        var pathLength = 0;

        var tempVec3 = vec3.create();

        var Bezier = Human.math.bezier;

        /** Build the curves array.
         * param {[Human.math.vec3]} points
         */
        this.init = function(points) {
            curves = [];
            pathLength = 0;
            numPoints = points.length;
            numCurves = numPoints - 1;

            if(numPoints < 2) {
                // invalid
                Human.log.error('curvePath init no enough points');
            }

            // used to compute control points at edge
            var startPoint = vec3.create();
            var endPoint = vec3.create();

            vec3.subtract(tempVec3, points[0], points[1]);
            vec3.scale(tempVec3, tempVec3, 0.25);
            vec3.add(startPoint, points[0], tempVec3);

            vec3.subtract(tempVec3, points[numPoints - 1], points[numPoints - 2]);
            vec3.scale(tempVec3, tempVec3, 0.25);
            vec3.add(endPoint, points[numPoints - 1], tempVec3);

            var i;
            var p00, p0, p1, p11;   // 4 interpolate points
            var b0;
            var b1 = vec3.create();
            var b2 = vec3.create();
            var b3;   // 4 control points for one cubic bezier curve
            for(i = 1; i < numPoints; ++i) {
                p0 = points[i-1];
                p1 = points[i];
                b0 = p0;
                b3 = p1;

                // b1 = b0 + ((p1 - p00) * 0.25);
                if ( i <= 1) {
                    vec3.subtract(tempVec3, p0, startPoint);
                } else {
                    p00 = points[i-2];
                    vec3.subtract(tempVec3, p1, p00);
                    vec3.scale(tempVec3, tempVec3, 0.25);
                }
                vec3.add(b1, b0, tempVec3);

                // b2 = b3 - ((p2 - p0) * 0.25);
                if ( i >= numPoints - 1) {
                    vec3.subtract(tempVec3, endPoint, p1);
                } else {
                    p11 = points[i+1];
                    vec3.subtract(tempVec3, p11, p0);
                    vec3.scale(tempVec3, tempVec3, 0.25);
                }
                vec3.subtract(b2, b3, tempVec3);

                curves.push(new Bezier(
                    b0[0], b0[1], b0[2],
                    b1[0], b1[1], b1[2],
                    b2[0], b2[1], b2[2],
                    b3[0], b3[1], b3[2]
                ));
            }

            // calculate curve path total length by summing up length of each segment
            for(i = 0; i < numCurves; ++i) {
                pathLength += curves[i].length();
            }

        };

        /**
         * t: 0-1
         */

        this.getPosition = function(t) {
            var p = this.getParameter(t);

            return {position: curves[p.i].compute(p.t01), i: p.i, t01: p.t01};
        };

        /**
         * i: 0 , numPoints - 2
         */
        this.getParameter = function(t) {
            var i, t01;
            t01 = t * (numPoints-1);
            t01 = Human.math.clamp(t01, 0, numPoints - 1);

            i = Math.floor(t01);
            if (i >= numPoints - 1) {
                i -= 1;
            }

            t01 -= i;

            return {i: i, t01: t01};
        };

        /**
         *
         */
        this.getPathLength = function() {
            return pathLength;
        };
    };
})();
;/**
 * @namespace Manages camera flights
 */
(function () {
    "use strict";

    var fly = Human.view.camera.fly = {};

    // TODO: delete this, for tweaking only
    fly.flyTimeScale = 1;
    fly.cylindricalView = false;
    fly.cylindricalOnly = false;
    fly.cylindricalRotationLerpMin = Math.PI / 6;
    fly.cylindricalRotationLerpMax = Math.PI / 2;
    fly.cylindricalRadiusLerpMin = 0.2;
    fly.cylindricalRadiusLerpMax = 1.0;

    var stopFOV = 55;

    var callbacks = [];
    var animation = null;

    var eyeCurvePath = new Human.view.camera.CurvePath();
    var lookCurvePath = new Human.view.camera.CurvePath();

    Human.events.on("tick",
        function () {
            if (animation) {
                animation.update(Date.now());
            }
        });

    fly.cancelAnimation = function () {
        if (animation) {
            //animation._onComplete(animation);
            finishAnimation();
            animation = null;
        }
    };

    /** Initiates camera flight along a catmull rom spline
     *
     * <p>This method can be called again at any time during a fly-to to initiate a new flight
     * that replaces any already in progress.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {[Object]} [params.points]
     * @param {*} [params.points[].eye] (alias position) Eye position to fly to
     * @param {*} [params.points[].look] (alias look) Look vector to fly to
     * @param {Number} [params.velocity] Camera flight velocity factor - default is 1.0
     * @param {Boolean} [params.constrainUp]
     * @param {Boolean} [params.easeIn]
     * @param {Boolean} [params.easeOut]
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.view.camera.fly
     */
    fly.flyAlongCurvePath = function (params, ok, error) {

        ok = ok || function () {
        };
        error = error || function (msg) {
            Human.log.error("Human.view.camera.fly.flyAlongCurvePath", msg);
            ok();
        };

        if(!params) {
            error("params must be defined");
            ok();
        }

        var velocity = params.velocity !== undefined ? params.velocity : 1;


        var eyePoints = [];
        var lookPoints = [];
        var upVecs = [];

        var i, len;
        for(i = 0, len = params.points.length; i < len; ++i) {
            eyePoints.push(Human.math.vec3ObjToArray(params.points[i].eye || params.points[i].position));
            lookPoints.push(Human.math.vec3ObjToArray(params.points[i].look || params.points[i].target));
            upVecs.push(Human.math.vec3ObjToArray(params.points[i].up));
        }

        eyeCurvePath.init(eyePoints);
        lookCurvePath.init(lookPoints);

        flyAlongCurvePath({
            eyeCurvePath: eyeCurvePath, lookCurvePath: lookCurvePath, upVecs: upVecs,
            velocity: velocity, constrainUp: params.constrainUp,
            easeIn: params.easeIn,
            easeOut: params.easeOut
        }, ok);

    };

    function flyAlongCurvePath(params, ok) {

        Human.view.camera.lock = true;

        // Keep callbacks already registered so
        // that their owners still get completion
        if (ok) {
            callbacks.push(ok);
        }
        params = params || {};

        // Replace old animation if one existing
        animation = new Human.view.camera.fly.CurvePathAnimation({
            //mode: 'curvePath',
            eyeCurvePath: params.eyeCurvePath,
            lookCurvePath: params.lookCurvePath,
            upVecs: params.upVecs,
            velocity: params.velocity,
            constrainUp: params.constrainUp,
            easeIn: params.easeIn,
            easeOut: params.easeOut,

            onComplete: finishAnimation
        });

        animation.update(Date.now());
    }

    /** Initiates camera flight to the given target
     *
     * <p>This method can be called again at any time during a fly-to to initiate a new flight
     * that replaces any already in progress.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {String} [params.objectId] Scene object to fly to, given by ID
     * @param {*} [params.boundary] Boundary to fly to
     * @param {*} [params.eye] Eye position to fly to, used in conjunction with params.look
     * @param {*} [params.look] Look vector to fly to, used in conjunction with params.eye
     * @param {Number} [params.animationDuration] Time in seconds that it takes the camera to arrive at its target - default is null, overrides velocity when given.
     * @param {Number} [params.velocity] Camera flight velocity factor - default is 1.0, overridden by animationDuration.
     * @param {Number} [params.arc] Camera flight arc factor - 0.0 for no arc, 1.0 for maximum arc - default is 0.0
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.view.camera.fly
     */
    fly.flyTo = function (params, ok, error) {
        var object, boundary, objectId;

        ok = ok || function () {
        };
        error = error || function (msg) {
            Human.log.error("Human.view.camera.fly", msg);
            ok();
        };

        if (params.objectId) {

            objectId = params.objectId;
            object = Human.scene.objects[objectId];
            if (!object) {
                error("No scene object found for the given ID: '" + objectId + "'");
                return;
            }
            boundary = Human.scene.getBoundary({ objectId: objectId });
            if (boundary) {
                flyTo({
                        target: { boundary: boundary },
                        arc: params.arc,
                        backOff: params.backOff,
                        cylindricalView: params.cylindricalView,
                        animationDuration: params.animationDuration,
                        velocity: params.velocity,
                        easeIn: params.easeIn,
                        easeOut: params.easeOut
                    },
                    ok);
            } else {
                ok();
            }
        } else if (params.boundary) {

            boundary = params.boundary;
            flyTo({
                target: { boundary: boundary },
                arc: params.arc,
                backOff: params.backOff,
                cylindricalView: params.cylindricalView,
                animationDuration: params.animationDuration,
                velocity: params.velocity,
                easeIn: params.easeIn,
                easeOut: params.easeOut
            }, ok);

        }  else if (params.eye || params.look) {

            flyTo({
                    target: { eye: params.eye, look: params.look, up: params.up },
                    arc: params.arc,
                    backOff: params.backOff,
                    animationDuration: params.animationDuration,
                    velocity: params.velocity,

                    // Want to animate "up" vector, which we don't animate by default
                    // in order to preserve camera's upwards orientation while flying
                    constrainUp: false,

                    cylindricalView: params.cylindricalView,
                    easeIn: params.easeIn,
                    easeOut: params.easeOut
                },
                ok);

        } else {

            // Fly to default position

            flyTo({
                    target: {
                        eye: { x: 0.0, y: 6.0, z: -70.0 },
                        look: { x: 0.0, y: 0.0, z: 0 },
                        up: {x: 0.0, y: 1.0, z: 0.0}
                    },
                    arc: params.arc,
                    backOff: params.backOff,
                    cylindricalView: params.cylindricalView,
                    animationDuration: params.animationDuration,
                    velocity: params.velocity,
                    easeIn: params.easeIn,
                    easeOut: params.easeOut
                },
                ok);
        }
    };

    function flyTo(params, ok) {

        Human.view.camera.lock = true;

        // Keep callbacks already registered so
        // that their owners still get completion
        if (ok) {
            callbacks.push(ok);
        }
        params = params || {};
        // Replace old animation if one existing
        animation = new Human.view.camera.fly.Animation({
            animationDuration: params.animationDuration,
            velocity: params.velocity,
            target: params.target, arc: params.arc, backOff: params.backOff,
            constrainUp: params.constrainUp,
            onComplete: finishAnimation,
            cylindricalView: params.cylindricalView,
            easeIn: params.easeIn,
            easeOut: params.easeOut
        });
        animation.update(Date.now());
    }

    function finishAnimation() {
        animation = null;
        while (callbacks.length > 0) {
            callbacks.pop()();
        }
        Human.view.camera.lock = false;
    }

    /** Jumps camera to the given target
     *
     * <p>Terminates any camera flight in progress and signals its completion.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {String} [params.objectId] Scene object to fly to, given by ID
     * @param {*} [params.boundary] Boundary to fly to
     * @param {*} [params.eye] Eye position to fly to, used in conjunction with params.look
     * @param {*} [params.look] Look vector to fly to, used in conjunction with params.eye
     * @param {Number} [params.backOff] Camera back-off factor in range of [0..1], when 0 is close (default), 1 is far
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.view.camera.fly
     */
    fly.jumpTo = function (params, ok, error) {
        var object, boundary, objectId;

        ok = ok || function () {
        };

        error = error || function (msg) {
            Human.log.error("Human.view.camera.fly", msg);
            ok();
        };

        var target;

        if (params.objectId) {

            // Boundary of scene object, found by ID

            objectId = params.objectId;
            object = Human.scene.objects[objectId];
            if (!object) {
                error("No scene object found for the given ID: '" + objectId + "'");
                return;
            }
            boundary = Human.scene.getBoundary({ objectId: objectId });

            if (boundary) {
                target = {
                    target: {
                        boundary: boundary
                    },
                    backOff: params.backOff
                };
            }

        } else if (params.boundary) {

            target = jumpToBoundary(params);

        } else if (params.eye || params.look) {

            // Given eye point and look vector

            if (!params.eye && !params.look) {
                error("incomplete parameter configuration: both 'eye' and 'look' expected");
                return;
            }
            target = {
                target: {
                    eye: params.eye,
                    look: params.look,
                    up: params.up
                }
            };

        }  else {

            // Default position

            target = {
                target: {
                    eye: { x: 0.0, y: 6.0, z: -70.0 },
                    look: { x: 0.0, y: 0.0, z: 0 },
                    up: {x: 0.0, y: 1.0, z: 0.0}
                },
                backOff: params.backOff
            };
        }

        if (target) {

            finishAnimation();

            if (target.target.boundary) {
                target.target.stopFOV = stopFOV || target.target.stopFOV;
                Human.view.camera.fly.jumpTo(target.target);
            } else {
                Human.view.camera.setLookAt(target.target);
            }
        }

        ok();
    };

    /*
    * Force cancellation of currently running animation.
    */
    fly.cancel = finishAnimation;

    function jumpToBoundary(params) {
        // Given boundary
        var backOff = params.backOff || 0;
        if (backOff < 0) {
            backOff = 0;
        } else if (backOff > 1) {
            backOff = 1;
        }
        backOff = 1 - backOff;

        var cameraLook = Human.math.vec3ObjToArray(Human.view.camera.look);
        var cameraEye = Human.math.vec3ObjToArray(Human.view.camera.eye);
        var vec = vec3.create();

        vec3.subtract(vec, cameraEye, cameraLook);
        vec3.normalize(vec, vec);

        var boundary = params.boundary;
        var boundaryCenter = Human.math.getBoundaryCenter(boundary);
        var stopFOV = params.stopFOV;
        var lenVec = vec3.length(vec);
        var diag = Human.math.getBoundaryDiag(boundary);
        var len = Math.abs((diag / (1.0 + (backOff * 0.8))) / Math.tan(stopFOV / 2));  /// Tweak this to set final camera distance on arrival
        var sca = len / lenVec;

        vec3.scale(vec, vec, sca);
        vec3.add(vec, boundaryCenter, vec);

        return {
            target: {
                eye: {
                    x: vec[0],
                    y: vec[1],
                    z: vec[2]
                },
                look: {
                    x: boundaryCenter[0],
                    y: boundaryCenter[1],
                    z: boundaryCenter[2]
                },
                up: {
                    x: 0,
                    y: 1,
                    z: 0
                }
            }
        };
    }

})();
;/**
 * @class Interpolates a {@link Human.view.camera} along a curved path from current position to look at a
 * target region of space.
 * @private
 *
 */
(function () {
    "use strict";

    var velocity = 1.0;
    var stopFOV = 55;

    var tempVec = vec3.create();
    // For cyliner coordinate
    var eye1Cylinder = vec3.create();
    var eye2Cylinder = vec3.create();

    /**
     * Returns a value t between 0 and 1, eye2 = (1-t) * translation_eye2 + t * cylindrical_eye2 (nlerp)
     * @private
     */
    function getCylindricalAndTranslationBlendFactor(rotation, radius) {
        var fly = Human.view.camera.fly;
        var t1 = Human.math.clamp((rotation - fly.cylindricalRotationLerpMin) / (fly.cylindricalRotationLerpMax - fly.cylindricalRotationLerpMin), 0, 1);
        var t2 = Human.math.clamp((radius - fly.cylindricalRadiusLerpMin) / (fly.cylindricalRadiusLerpMax - fly.cylindricalRadiusLerpMin), 0, 1);
        return Math.min(t1,t2);
    }

    /**
     * @private
     */
    Human.view.camera.fly.Animation = function (cfg) {
        var target = cfg.target;

        var cylindricalView = cfg.cylindricalView !== undefined ? cfg.cylindricalView : Human.view.camera.fly.cylindricalView;

        this.arc = cylindricalView ? (cfg.arc === undefined ? 1.0 : cfg.arc) : 0;

        this.easeIn = !!cfg.easeIn;
        this.easeOut = cfg.easeOut !== false;

        // When true, we'll not change the camera's "up" vector
        //this.constrainUp = cfg.constrainUp !== false;
        this.constrainUp = cfg.constrainUp === undefined ? false : cfg.constrainUp;

        if (!target) {
            Human.log.error("Human.view.camera.fly.Animation config missing: target");
            if (cfg.onComplete) {
                cfg.onComplete();
            }
            return;
        }
        // Initial camera state
        var camera = Human.view.camera;
        this._look1 = Human.math.vec3ObjToArray(camera.look);
        this._eye1 = Human.math.vec3ObjToArray(camera.eye);
        this._up1 = Human.math.vec3ObjToArray(camera.up);

        vec3.subtract(tempVec, this._eye1, this._look1);

        // this._vec : dir from look1 to eye1
        this._vec = vec3.create();
        vec3.normalize(this._vec, tempVec);

        // Back-off factor in range of [0..1], when 0 is close, 1 is far
        var backOff = cfg.backOff || 0;
        if (backOff < 0) {
            backOff = 0;
        } else if (backOff > 1) {
            backOff = 1;
        }
        backOff = 1 - backOff;
        // Final camera state
        if (target.boundary) {
            // Zooming to look and eye computed from boundary
            var boundary = target.boundary;
            var dist = target.dist || 2.5;
            // ?? : this._vec is normalized, this might be changed to lenVec = 1
            var lenVec = Math.abs(vec3.length(this._vec));
            var diag = Human.math.getBoundaryDiag(boundary);
            var len = Math.abs((diag / (1.0 + (backOff * 0.8))) / Math.tan(stopFOV / 2));  /// Tweak this to set final camera distance on arrival
            var sca = (len / lenVec) * dist;
            this._look2 = Human.math.getBoundaryCenter(boundary);
            if (target.offset) {
                this._look2[0] += target.offset[0];
                this._look2[1] += target.offset[1];
                this._look2[2] += target.offset[2];
            }

            // calculate this._eye2
            var cylindricalOnly = Human.view.camera.fly.cylindricalOnly;

            if (cylindricalView) {
                this.arc = 1;
                Human.math.cartesianToCylindrical(this._look1, eye1Cylinder);   //use eye1Cylinder as a tempVec for cylindrical coordinate of look1
                Human.math.cartesianToCylindrical(this._look2, eye2Cylinder);   //use eye2Cylinder as a tempVec for cylindrical coordinate of look2
                var rotation = Human.math.getShortRotation(eye1Cylinder[1], eye2Cylinder[1]);
                var radius = eye2Cylinder[0];
                var t = getCylindricalAndTranslationBlendFactor(Math.abs(rotation), radius);

                if(!cylindricalOnly) {
                    eye2Cylinder[0] = sca;  //look2 -> eye2
                    eye2Cylinder[2] = 0;
                    this._eye2 = Human.math.cylindricalToCartesian(eye2Cylinder);  // this._eye2 used as tempVec here

                    //blend with original look dir
                    vec3.scale(tempVec, this._vec, sca);
                    Human.math.lerpVec3(t, 0, 1, tempVec, this._eye2, tempVec);
                    vec3.normalize(tempVec, tempVec);
                    vec3.scale(tempVec, tempVec, sca);
                    vec3.add(this._eye2, this._look2, tempVec);
                } else {
                    eye2Cylinder[0] = eye2Cylinder[0] + sca;
                    this._eye2 = Human.math.cylindricalToCartesian(eye2Cylinder);
                }

            } else {
                vec3.scale(tempVec, this._vec, sca);
                this._eye2 = vec3.add(vec3.create(), this._look2, tempVec);
            }


            this._up2 = vec3.create();

            if (this.constrainUp) {
                this._up2[0] = camera.up.x;
                this._up2[1] = camera.up.y;
                this._up2[2] = camera.up.z;
            } else if (target.up) {
                this._up2[0] = target.up.x || 0;
                this._up2[1] = target.up.y || 0;
                this._up2[2] = target.up.z || 0;
            } else {
                this._up2[1] = 1;
            }

        } else {
            // Zooming to specific look and eye points
            var look = target.look;
            var eye = target.eye;
            var up = target.up;
            var cameraEye = Human.view.camera.eye;
            var cameraLook = Human.view.camera.look;
            var cameraUp = Human.view.camera.up;
            this._look2 = vec3.create();
            this._eye2 = vec3.create();
            this._up2 = vec3.create();

            if (look) {
                this._look2[0] = look.x || 0;
                this._look2[1] = look.y || 0;
                this._look2[2] = look.z || 0;
            } else {
                this._look2[0] = cameraLook.x;
                this._look2[1] = cameraLook.y;
                this._look2[2] = cameraLook.z;
            }

            if (eye) {
                this._eye2[0] = eye.x || 0;
                this._eye2[1] = eye.y || 0;
                this._eye2[2] = eye.z || 0;
            } else {
                this._eye2[0] = cameraEye.x;
                this._eye2[1] = cameraEye.y;
                this._eye2[2] = cameraEye.z;
            }

            if (up && !this.constrainUp) {
                this._up2[0] = up.x || 0;
                this._up2[1] = up.y || 0;
                this._up2[2] = up.z || 0;
            } else {
                this._up2[0] = cameraUp.x;
                this._up2[1] = cameraUp.y;
                this._up2[2] = cameraUp.z;
            }

        }

        // Distance to travel
        vec3.subtract(tempVec, this._look2, this._look1);
        var lookDist = Math.abs(vec3.length(tempVec));

        vec3.subtract(tempVec, this._eye2, this._eye1);

        // simple lerp straight line distance
        var eyeDist = Math.abs(vec3.length(tempVec));

        // Curve animation setup
        if (this.arc > 0.0) {
            Human.math.cartesianToCylindrical(this._eye1, eye1Cylinder);
            Human.math.cartesianToCylindrical(this._eye2, eye2Cylinder);

            // dist = (r1 + r2) * radian
            var shortRotation = Human.math.getShortRotation(eye1Cylinder[1], eye2Cylinder[1]);
            var v = (eye1Cylinder[0] + eye2Cylinder[0]) * Math.abs(shortRotation);
            var h = eye2Cylinder[2] - eye1Cylinder[1];
            var cylinderDist = Math.sqrt( v*v + h*h );
            eyeDist = (1 - this.arc) * eyeDist + this.arc * cylinderDist;
        }

        this._dist = lookDist > eyeDist ? lookDist : eyeDist;

        if (cfg.animationDuration) {
            this._animationDuration = cfg.animationDuration * 1000; // Duration in millisecs internally
        } else {
            this._animationDuration = Human.view.camera.fly.flyTimeScale * 1000.0 * ((this._dist / ((cfg.velocity || velocity) * 200.0)) + 1); // extra seconds to ensure arrival
        }

        // Completion callback
        this._onComplete = cfg.onComplete;
    };


    /** Update the interpolation to push the next state to the bound {@link Human.view.camera}
     */

    var eyeVec = vec3.create();
    var lookVec = vec3.create();

    Human.view.camera.fly.Animation.prototype.update = function (time) {
        if (this._time1 === undefined) {
            this._time1 = time;
            this._time2 = this._time1 + this._animationDuration;
        }

        if (this._done || time > this._time2) {
            if (!this._done) {
                Human.view.camera.setLookAt({
                    look: Human.math.vec3ArrayToObj(this._look2),
                    eye: Human.math.vec3ArrayToObj(this._eye2),
                    up:  Human.math.vec3ArrayToObj(this._up2)
                });
            }
            this._done = true;
            this._onComplete(this);
            return;
        }
        var t = (time - this._time1) / this._animationDuration;

        var easedTime;
        if (this.easeIn && this.easeOut) {
            easedTime = Human.math.easeInOut(t, 0, 1, 1);
        } else if (this.easeIn) {
            easedTime = Human.math.easeIn(t, 0, 1, 1);
        } else if (this.easeOut) {
            easedTime = Human.math.easeOut(t, 0, 1, 1);
        } else {
            easedTime = t;
        }

        Human.math.lerpVec3(easedTime, 0, 1, this._look1, this._look2, lookVec);

        if (this.arc > 0.0) {
            Human.math.lerpVec3Cylindrical(easedTime, 0, 1, eye1Cylinder, eye2Cylinder, tempVec);
            Human.math.cylindricalToCartesian(tempVec, eyeVec);

            if (this.arc < 1.0) {
                // simple lerp of eye
                Human.math.lerpVec3(
                    easedTime,
                    0,
                    1,
                    this._eye1,
                    this._eye2,
                    tempVec); // Destination

                // blend the curved animation with lerp animation
                Human.math.lerpVec3(this.arc, 0, 1, tempVec, eyeVec, eyeVec);
            }

        } else {
            // simple lerp of eye
            Human.math.lerpVec3(
                easedTime,
                0,
                1,
                this._eye1,
                this._eye2,
                eyeVec); // Destination
        }

        if (this.constrainUp) {

            // Interpolating "eye" and "look" but not "up"

            Human.view.camera.setLookAt({
                look: Human.math.vec3ArrayToObj(lookVec),
                eye: Human.math.vec3ArrayToObj(eyeVec)
            });

        } else {

            // Interpolating "eye", "look" and "up"

            var up = Human.math.lerpVec3(easedTime, 0, 1, this._up1, this._up2, []);

            Human.view.camera.setLookAt({
                look: Human.math.vec3ArrayToObj(lookVec),
                eye: Human.math.vec3ArrayToObj(eyeVec),
                up:  Human.math.vec3ArrayToObj(up)
            });
        }
    };

    Human.view.camera.fly.Animation.prototype.stop = function () {
    };
})();
;/**
 * @class Interpolates a {@link Human.view.camera} along an array of bezier curves (curve path)
 * @private
 *
 */
(function () {
    "use strict";

    var velocity = 1.0;
    //var stopFOV;

    var up1 = vec3.create();

    Human.properties.subscribe({
        propId: "camera.flyCurvePath",
        value: {
            velocity: 1.0,
        },
        callback: function (value) {
            velocity = value.velocity || 1.0;
        }
    });

    /**
     * @private
     */
    Human.view.camera.fly.CurvePathAnimation = function (cfg) {

        this.easeIn = !!cfg.easeIn;
        this.easeOut = cfg.easeOut !== false;

        // When true, we'll not change the camera's "up" vector
        this.constrainUp = cfg.constrainUp === undefined ? false : cfg.constrainUp;

        this._eyeCurvePath = cfg.eyeCurvePath;
        this._lookCurvePath = cfg.lookCurvePath;
        this._upVecs = cfg.upVecs;

        var camera = Human.view.camera;

        var t = 1;
        var p = this._lookCurvePath.getParameter(t);
        var i = p.i;
        this._look2 = Human.math.vec3ObjToArray(this._lookCurvePath.getPosition(t).position);
        this._eye2 = Human.math.vec3ObjToArray(this._eyeCurvePath.getPosition(t).position);
        this._up2 = this.constrainUp ? Human.math.vec3ObjToArray(camera.up) : this._upVecs[i+1];

        // Distance to travel
        var eyeLength = this._eyeCurvePath.getPathLength();
        var lookLength = this._lookCurvePath.getPathLength();

        this._dist = Math.max(eyeLength, lookLength);

        // Duration of travel
        this._duration = Human.view.camera.fly.flyTimeScale * 1000.0 * ((this._dist / ((cfg.velocity || velocity) * 200.0)) + 1); // extra seconds to ensure arrival

        // Completion callback
        this._onComplete = cfg.onComplete;
    };


    /** Update the interpolation to push the next state to the bound {@link Human.view.camera}
     */

    Human.view.camera.fly.CurvePathAnimation.prototype.update = function (time) {
        if (this._time1 === undefined) {
            this._time1 = time;
            this._time2 = this._time1 + this._duration;
        }

        if (this._done || time > this._time2) {
            if (!this._done) {
                Human.view.camera.setLookAt({
                    look: Human.math.vec3ArrayToObj(this._look2),
                    eye: Human.math.vec3ArrayToObj(this._eye2),
                    up:  Human.math.vec3ArrayToObj(this._up2)
                });
            }
            this._done = true;
            this._onComplete(this);
            return;
        }
        var t = (time - this._time1) / this._duration;
        var easedTime;
        if (this.easeIn && this.easeOut) {
            easedTime = Human.math.easeInOut(t, 0, 1, 1);
        } else if (this.easeIn) {
            easedTime = Human.math.easeIn(t, 0, 1, 1);
        } else if (this.easeOut) {
            easedTime = Human.math.easeOut(t, 0, 1, 1);
        } else {
            easedTime = t;
        }

        var look = this._lookCurvePath.getPosition(easedTime).position;
        var eye = this._eyeCurvePath.getPosition(easedTime).position;

        if (this.constrainUp) {

            // Interpolating "eye" and "look" but not "up"
            Human.view.camera.setLookAt({
                look: look,
                eye: eye
            });

        } else {

            // Interpolating "eye", "look" and "up"
            var p = this._lookCurvePath.getParameter(easedTime);
            Human.math.lerpVec3(p.t01, 0, 1, this._upVecs[p.i], this._upVecs[p.i+1], up1);

            Human.view.camera.setLookAt({
                look: look,
                eye: eye,
                up:  Human.math.vec3ArrayToObj(up1)
            });


        }
    };

})();
;/**
 * @namespace Manages a box-shaped boundary indicator in the 3d view
 */
(function () {
    "use strict";

    var HumanViewBoundary = Human.view.boundary = {};

    var flagsNode;
    var geoNode;
    var ready = false;
    var showing = false;

    Human.events.on(
        "loaded",
        function () {
            flagsNode = Human.renderer.getNode("object-boundary-flags");
            geoNode = Human.renderer.getNode("object-boundary-geo");
            ready = true;
        });

    /**
     * Updates the boundary indicator
     *
     *
     * <pre>
     *     Examples:
     *
     * var boundary = { xmin: -10, ymin: -2, zmin: -123, xmax: 20, ymax: 100, zmax: 23 };
     *
     * setBoundary(boundary)          // Set up new boundary, dont change visibility status
     *
     * boundary = { xmin: -40, ymin: -100, zmin: -33, xmax: 20, ymax: 200, zmax: 450 };
     *
     * setBoundary(boundary, true)    // Set up new boundary, make visible
     *
     * setBoundary(false)             // Keep boundary setup, make invisible
     * setBoundary(true)              // Keep boundary setup, make visible
     * </pre>
     * @memberof Human.view.boundary
     */
    HumanViewBoundary.setBoundary = function () {
        if (!ready) {
            return;
        }
        if (arguments.length === 0) {
            HumanViewBoundary.reset();
            return;
        }
        var boundary;
        var enable;
        if (arguments.length === 1) {
            if (typeof arguments[0] === "boolean") {
                enable = !!arguments[0];
                HumanViewBoundary._showBoundary(enable);
            } else {
                boundary = arguments[0];
                HumanViewBoundary._setBoundaryExtents(boundary);
            }
        } else {
            boundary = arguments[0];
            enable = arguments[1];
            HumanViewBoundary._setBoundaryExtents(boundary);
            HumanViewBoundary._showBoundary(enable);
        }
    };
    
    HumanViewBoundary._setBoundaryExtents = (function () {
        var positions = new Float32Array(24);
        return function (boundary) {

            flagsNode.setEnabled(showing);

            var xmin = boundary.xmin;
            var ymin = boundary.ymin;
            var zmin = boundary.zmin;
            var xmax = boundary.xmax;
            var ymax = boundary.ymax;
            var zmax = boundary.zmax;

            positions[0] = xmax;
            positions[1] = ymax;
            positions[2] = zmax;
            positions[3] = xmax;
            positions[4] = ymin;
            positions[5] = zmax;
            positions[6] = xmin;
            positions[7] = ymin;
            positions[8] = zmax;
            positions[9] = xmin;
            positions[10] = ymax;
            positions[11] = zmax;
            positions[12] = xmax;
            positions[13] = ymax;
            positions[14] = zmin;
            positions[15] = xmax;
            positions[16] = ymin;
            positions[17] = zmin;
            positions[18] = xmin;
            positions[19] = ymin;
            positions[20] = zmin;
            positions[21] = xmin;
            positions[22] = ymax;
            positions[23] = zmin;

            geoNode.setPositions(positions);
        };
    })();

    HumanViewBoundary._showBoundary = function (doShow) {
        if (showing === doShow) {
            return;
        }
        flagsNode.setEnabled(doShow);
        showing = doShow;
    };

    /** Clears the boundary indicator. Makes it invisible and zero size.
     * @memberof Human.view.boundary
     */
    HumanViewBoundary.reset = function () {
        HumanViewBoundary._setBoundaryExtents({ xmin:0, ymin:0, zmin:0, xmax:0, ymax:0, zmax:0 });
        HumanViewBoundary._showBoundary(false);
    };
})();
;/** @namespace Manages the Tooltips view mode
 */
(function () {
    "use strict";

    var tooltips = Human.view.tooltips = {};

    var enabled = true;
    var tooltipId = null;
    var labelElement;               // Single tooltip element

    var enabledAnatomyLabels = {};  // Currently visible labels from Human.view.labels - don't tooltip

    Human.events.on("loaded",
        function () {
            var containerSelector = "#" + Human.CONTAINER_ID;
            $(containerSelector).append("<div id=\"objectToolTip\" style=\"display: none;\" class=\"objectTooltip\">XXXX</div>");
            labelElement = $("#objectToolTip");
            tooltips._hide();
        });

    // Destroy tooltip when object destroyed
    Human.events.on("scene.objectDestroyed", // Destroy label when object destroyed
        function (params) {
            if (labelElement && tooltipId) {
                if (params.objectId === tooltipId) {
                    tooltips._hide();
                }
            }
        });

    // Destroy tooltip when object disabled
    Human.events.on("scene.objectsShown",
        function (params) {
            if (labelElement && tooltipId) {
                if (params.enabledObjectsUpdate[tooltipId] === false) {      // Newly enabled/disabled objects
                    tooltips._hide();
                }
            }
        });

    // Track the currently labelled anatomy objects so we don't tooltip them
    Human.events.on("labels.updated", // Don't tooltip over labelled object
        function (params) {
            enabledAnatomyLabels = params.enabledLabels;
            if (tooltipId && enabledAnatomyLabels[tooltipId]) {
                //tooltips._hide();
            }
        });

    Human.events.on("camera.updated", function () {
        if (labelElement && tooltipId) {
            tooltips._hide();
        }
    });

    tooltips.setTooltip = function (params) {
        var objectId = params.objectId;
        if (objectId) {  // Only tooltip anatomy objects
            if (labelElement) {
                if (tooltipId) {
                    tooltips._hide();
                }
                tooltips._show(params);
            }
        }
    };

    tooltips.clearTooltip = function () {
        if (labelElement && tooltipId) {
            tooltips._hide();
        }
    };

    /**
     * Show tooltip on object at given canvas coordinates
     */
    tooltips._show = function (params) {
        if (!enabled) {
            return;
        }
        var title;
        if (params.objectId) {
            tooltipId = params.objectId;
            if (enabledAnatomyLabels[tooltipId]) {
                tooltips._hide();
                return;
            }
            var object = Human.scene.objects[params.objectId];
            title = object.displayName;
        }
        title = params.title || title;
        labelElement.css({
            "left": params.canvasX + 10,
            "top": params.canvasY + 0
        });
        labelElement.text(title);
        labelElement.show();
    };

    /**
     * Hide tooltip if shown
     */
    tooltips._hide = function () {
        if (!tooltipId || !labelElement) {
            return;
        }
        labelElement.hide();
        tooltipId = null;
    };

    tooltips.getEnabled = function () {
        return enabled;
    };

    tooltips.setEnabled = function (enable) {
        if (enabled !== enable) {
            if (!enable) {
                tooltips._hide();
            }
            enabled = enable;
        }
        Human.events.fire("tooltips.toggled", {
            enabled: enabled
        });
    };
})();






;/**
 * @namespace Manages labels on objects in {@link Human.scene}
 *
 * <p>Observes updates to the currently selected anatomy object set and maintains
 * a set of labels for the currently selected objects.</p>
 *
 */
(function () {
    "use strict";

    var HumanViewLabels = Human.view.labels = {};

    HumanViewLabels.enabled = true;

    var labels = {};
    var numLabels = 0;

    Human.events.on(
        "loaded",
        function () {
            HumanViewLabels.clearLabels();
        });

    // When a labeled scene object is destroyed, ensure that the label is also destroyed
    Human.events.on(
        "scene.objectDestroyed",
        function (params) {
            if (HumanViewLabels.enabled) {
                if (numLabels > 0) {
                    var objectId = params.objectId;
                    if (labels[objectId]) {
                        HumanViewLabels._destroyLabel(objectId);
                        var enabledLabelsUpdate = {};
                        enabledLabelsUpdate[objectId] = false;
                        Human.events.fire("labels.updated", {
                            enabledLabels:labels
                        });
                    }
                }
            }
        });

    // When a labeled scene object is deselected, ensure that the label is destroyed
    Human.events.on(
        "scene.objectsSelected",
        function (params) {
            if (HumanViewLabels.enabled) {
                if (numLabels > 0) {
                    var objects = params.selectedObjectsUpdate; // Newly selected/deselected objects
                    var anatomyObjects = Human.scene.objects;
                    for (var objectId in objects) {
                        if (objects.hasOwnProperty(objectId)) {
                            if (anatomyObjects[objectId].objects.length === 0) {  // Leaf object
                                if (objects[objectId] === false) {   // Object deselected, destroy label
                                    if (labels[objectId]) {
                                        HumanViewLabels._destroyLabel(objectId);
                                    }
                                }
                            }
                        }
                    }
                    Human.events.fire("labels.updated", {
                        enabledLabels:labels
                    });
                }
            }
        });

    // When a labeled scene object is hidden, ensure that the label is destroyed
    Human.events.on(
        "scene.objectsShown",
        function (params) {
            if (HumanViewLabels.enabled) {
                if (numLabels > 0) {
                    var objects = params.enabledObjectsUpdate;  // Newly enabled/disabled objects
                    for (var objectId in objects) {
                        if (objects.hasOwnProperty(objectId)) {
                            if (objects[objectId] === false) { // Object disabled, destroy label
                                if (labels[objectId]) {
                                    HumanViewLabels._destroyLabel(objectId);
                                }
                            }
                        }
                    }
                    Human.events.fire("labels.updated", {
                        enabledLabels:labels
                    });

                }
            }
        });

    HumanViewLabels._destroyLabel = function (objectId) {
        var label = labels[objectId];
        if (label) {
            label.destroy();
            delete labels[objectId];
            numLabels--;
        }
    };

    /**
     * Creates a label on an object in {@link Human.scene}
     * @memberof Human.view.labels
     * @param params
     */
    HumanViewLabels.createLabel = function (params) {
        var objectId = params.objectId;
        var object = Human.scene.objects[objectId];
        if (!object) { // Not likely
            Human.log.warn("Human.view.labels.createLabel", "Scene object not found: '" + objectId + "'");
            return;
        }
        if (params.replace) {
            HumanViewLabels._clearLabels();
        }
        if (!object.displayName) {
            Human.log.warn("Human.view.labels.createLabel", "Scene object has no displayName: '" + objectId + "'");
            return;
        }
        var offset = params.offset || object.getCenter();
        labels[objectId] = new Human.view.labels.Label({
            labelId:objectId,
            text:object.displayName,
            style:null, // Default style
            offset:offset,
            nodeId:objectId,
            objectId:objectId,
            enabled:HumanViewLabels.enabled,
            onHide:function () {
                HumanViewLabels._destroyLabel(objectId);
            }
        });
        Human.events.fire("labels.updated", {
            enabledLabels:labels
        });
        numLabels++;
    };

    /**
     * Clears all labels currently in {@link Human.scene}
     * @memberof Human.view.labels
     */
    HumanViewLabels.clearLabels = function () {
        if (numLabels > 0) {
            HumanViewLabels._clearLabels();
            Human.events.fire("labels.updated", {
                enabledLabels:labels
            });
        }
    };

    HumanViewLabels._clearLabels = function () {
        for (var labelId in labels) {
            if (labels.hasOwnProperty(labelId)) {
                HumanViewLabels._destroyLabel(labelId);
            }
        }
        numLabels = 0;
    };

    /** Enables or disables Label mode
     * <p>Disabling will remove all labels.</p>
     * @memberof Human.view.labels
     * @param {Boolean} enable Enables or disables Label mode
     */
    HumanViewLabels.setEnabled = function (enable) {
        if (HumanViewLabels.enabled === enable) {
            return;
        }
        HumanViewLabels.enabled = enable;
        if (!enable) {
            // Destroy all labels when disabled
            HumanViewLabels._clearLabels();
        }
        Human.events.fire("labels.toggled", {
            enabled:enable
        });
    };

    /** Queries whether or not Label mode is enabled
     * @memberof Human.view.labels
     * @returns true if Label mode enabled else false
     */
    HumanViewLabels.getEnabled = function () {
        return HumanViewLabels.enabled;
    };

})();







;(function () {
    "use strict";

    var container;
    var labels = {};
    var canvasWidth;
    var canvasHeight;

    Human.events.on("loaded",
        function () {
            container = $("#container");

            var canvas = $(Human.renderer.canvas.getCanvas());
            canvasWidth = canvas.width();
            canvasHeight = canvas.height();
        });

    Human.events.on("loaded",
        function () {
            Human.renderer.getNode(Human.renderer.NULL_OBJECT_ID).onRendered = function (event) {
                for (var labelId in labels) {
                    if (labels.hasOwnProperty(labelId)) {
                        labels[labelId]._onRender(event);
                    }
                }
            };
        });

    Human.events.on("canvas.resized",
        function (params) {
            canvasWidth = params.canvasWidth;
            canvasHeight = params.canvasHeight;
        });

    /**
     * A label within {@link Human.view.labels}.
     * @param cfg
     * @constructor
     * @private
     */
    Human.view.labels.Label = function (cfg) {

        this.nodeId = cfg.nodeId;               // Always have nodeId
        this.objectId = cfg.objectId;
        this.animationId = cfg.animationId;
        this.offset = cfg.offset;               // Optional
        this.shown = cfg.shown;
        this.enabled = cfg.enabled;

        this._style = cfg.style || "labelStyleDefault";

        if (cfg.labelId) {
            this.labelId = cfg.labelId;
        } else if (this.animationId) {  // Animation label
            this.labelId = "a." + this.objectId;
        } else if (this.objectId) { // Object label
            this.labelId = "o." + this.objectId;
        } else {
            this.labelId = "n." + this.nodeId;
        }

        /* add class (right, left, bottom or top) according to where the label arrow should appear
          relative to the elemtn */
        this._labelElement = jQuery([
            '<div id="',
            this.labelId,
            '" class="label-container right hidden">',
            '<div class="label-container-header ',
            this.style,
            '">',
            '<span>',
            cfg.text,
            '</span>',
            '<img src="img/shim.gif" alt="Close" class="icon-close icon-inverse" />',
            '<div class="label-toggle-secondary icon-expand"></div>',
            '<ul class="options"></ul>',
            '</div>',
            '</div>'
        ].join(""));

        container.append(this._labelElement);

        this._elementWidth = this._labelElement.width();
        this._elementHeight = this._labelElement.height();

        var self = this;

        this._onRender = function (event) {
            self.updatePos({
                canvasPos:event.getCanvasPos(self.offset),
                viewPos: event.getViewPos(self.offset)
            });
        };

        labels[this.labelId] = this;

        var $closeBtn = this._labelElement.find(".icon-close");
        $closeBtn.click(function () {
            cfg.onHide();
        });

        // build options
        var $labelOptions = this._labelElement.find(".options");
        var $optionsToggle = this._labelElement.find(".label-toggle-secondary");
        $labelOptions.hide();
        $optionsToggle.hide();
        var annotations = Human.view.annotations.getAnnotations({ objectId: this.objectId, type: "secondary" });
        var hasSecondary = Object.keys(annotations).length > 0;
        // toggle label option
        if (hasSecondary) {
            var annotationsShownCount = 0;
            var setAnnotationToggle = function (shown) {
                if (shown) {
                    $optionShowPins.text("Hide Pins");
                }
                else {
                    $optionShowPins.text("Show Pins");
                }
            };
            var setAnnotationShown = function (shown) {
                if (shown === true) {
                    annotationsShownCount++;
                }
                else if (annotationsShownCount > 0) {
                    annotationsShownCount--;
                }
                setAnnotationToggle(annotationsShownCount !== 0);
            };
            var annotationChecked = false;
            var initAnnotationCheck = function () {
                if (annotationChecked === true) {
                    return;
                }
                annotationsShownCount = 0;
                for (var id in annotations) {
                    if (annotations.hasOwnProperty(id)) {
                        var annotation = annotations[id];
                        annotation.label.on("shown", setAnnotationShown);
                        if (annotation.label.shown === true) {
                            annotationsShownCount++;
                        }
                    }
                }
                setAnnotationToggle(annotationsShownCount !== 0);
            };

            var $optionShowPins = $("<li />");
            $optionShowPins.click(function () {
                var shown = annotationsShownCount !== 0;
                var objects = {};
                objects[self.objectId] = !shown;
                // set annotations
                Human.view.annotations.setLabelsShown({
                    objects: objects,
                    type: "secondary",
                    replace: true
                });
            });
            // lazy loaded check
            $optionsToggle.click(function () {
                if (annotationChecked !== true) {
                    initAnnotationCheck();
                    annotationChecked = true;
                }
            });
            $labelOptions.append($optionShowPins);
        }
        // label options available
        if ($labelOptions.children().length > 0) {
            // remove main close btn
            $closeBtn.hide();
            // add close btn option
            var $hideBtn = $("<li />");
            $hideBtn.text("Hide Label");
            $hideBtn.click(function () {
                cfg.onHide();
            });
            $labelOptions.append($hideBtn);
            // setup options toggle
            $optionsToggle.click(function () {
                if ($labelOptions.is(":visible")) {
                    $labelOptions.hide();
                    $optionsToggle.attr("class", "icon-expand");
                }
                else {
                    $labelOptions.show();
                    $optionsToggle.attr("class", "icon-collapse");
                }
            });
            $optionsToggle.show();
        }
    };

    Human.view.labels.Label.prototype.updatePos = function (params) {
        var x = params.canvasPos[0];
        var y = params.canvasPos[1] + 40;
        var z = params.viewPos[2];

        if (z > 0) { // Behind point of projection
            if (this.shown) {
                this.setShown(false);
            }
            return;
        }

        x = Math.max(20, Math.min(x, canvasWidth - this._elementWidth - 10));
        y = Math.max(10, Math.min(y, canvasHeight - this._elementHeight - 10));

        this._labelElement.css({
            "left":x,
            "top":y
        });
        if (!this.shown) {
            this.setShown(true);
        }
    };

    Human.view.labels.Label.prototype.update = function (params) {
        var x = params.canvasPos.x;
        var y = params.canvasPos.y;
        if (y <= 0) {                    // Just clip to top - overlap with menus is only issue, other borders OK
            if (this.shown) {
                this.setShown(false);
            }
        } else {
            this._labelElement.css({
                "left":x,
                "top":y + 40
            });
            if (params.style) {
                if (this._style) {
                    this._labelElement.removeClass(this._style);
                }
                this._labelElement.addClass(params.style);
                this._style = params.style;
            }
            if (!this.shown) {
                this.setShown(true);
            }
        }
    };

    Human.view.labels.Label.prototype.setShown = function (doShow) {
        if (this.shown === doShow) {
            return;
        }
        if (doShow && this.enabled) {
            this._labelElement.show();
        } else {
            this._labelElement.hide();
        }
        this.shown = doShow;
    };

    Human.view.labels.Label.prototype.setEnabled = function (enable) {
        if (this.enabled !== enable) {
            if (this.shown && enable) {
                this._labelElement.show();
            } else {
                this._labelElement.hide();
            }
            this.enabled = enable;
        }
    };

    Human.view.labels.Label.prototype.destroy = function () {
        delete labels[this.labelId];
        if (this.shown) {
            this.setShown(false);
        }
        if (this._labelElement) {
            this._labelElement.remove();
            this._labelElement = null;
        }
    };

})();
;/**
 * @namespace Manages Highlight mode
 */
(function () {
    "use strict";

    var HumanViewHighlight = Human.view.highlight = {};

    HumanViewHighlight.enabled = true;
    var dirty = false;

    function pickCallback(object, event) {
        if (!object) {
            return;
        }

        var spaceDown = event.spaceDown;
        var ctrlDown = event.ctrlDown;
        var objects;

        Human.view.annotations.setLabelsShown({
            objects: {},
            type: "secondary",
            replace: true
        });
        if (spaceDown) {
            // SPACE key down
            objects = {};
            objects[object.objectId] = true;
            Human.view.annotations.setLabelsShown({
                objects: objects,
                type: "secondary"
            });
            return;
        }

        if (ctrlDown) {
            // ALT key down
            objects = {};
            objects[object.objectId] = false;
            Human.view.annotations.setLabelsShown({
                objects: objects,
                type: "secondary"
            });
            return;
        }

        var selected = !!Human.scene.selectedObjects[object.objectId];

        Human.scene.setSelectedObjects({
            objectId: object.objectId,
            select: !selected, // Deselect if currently selected
            replace: !Human.view.pick.multiEnabled
        });

        // Scene object picked
        if (!selected) {
            Human.view.labels.createLabel({ objectId: object.objectId, afterDelay: true, replace: true });
        }

    }

    Human.events.on(
        "loaded",
        function () {
            HumanViewHighlight.setEnabled(true); // Notifies of initial state
        });

    Human.events.on(
        "scene.objectsSelected",
        function () {
            dirty = HumanViewHighlight.enabled;
        });

    Human.events.on(
        "tick", // Lazy-highlight when flagged for next render frame
        function () {
            if (dirty) {
                highlight(HumanViewHighlight.enabled);
                dirty = false;
            }
        });

    function highlight(doHighlight) {
        var object, objectId;
        if (!doHighlight || Human.utils.isEmpty(Human.scene.selectedObjects)) {
            for (objectId in Human.scene.objects) { // De-highlight an highlighted objects
                if (Human.scene.objects.hasOwnProperty(objectId) && HumanViewHighlight.neutral) {
                    HumanViewHighlight.neutral(Human.scene.objects[objectId]);
                }
            }
        } else {
            for (objectId in Human.scene.objects) { // Highlight only selected objects
                if (Human.scene.objects.hasOwnProperty(objectId)) {
                    object = Human.scene.objects[objectId];
                    if (object) {
                        if (Human.scene.selectedObjects.hasOwnProperty(objectId)) {
                            if (HumanViewHighlight.foreground){
                                HumanViewHighlight.foreground(object);
                            }
                        } else if (HumanViewHighlight.background) {
                            HumanViewHighlight.background(object);
                        }
                    }
                }
            }
        }
    }

    HumanViewHighlight.setEnabled = function (enable) {
        if (HumanViewHighlight.enabled !== enable) {
            dirty = true;
        }
        
        HumanViewHighlight.enabled = enable;

        Human.events.fire("highlight.toggled", { enabled: HumanViewHighlight.enabled });
        if (HumanViewHighlight.enabled) {
            Human.view.currentMode = 'Highlight';
            Human.view.pick.onSingleClick = pickCallback;
        } else if (Human.view.pick.onSingleClick === pickCallback) {
            Human.view.pick.onSingleClick = null;
        }
    };

    HumanViewHighlight.getEnabled = function () {
        return HumanViewHighlight.enabled;
    };

    HumanViewHighlight.foreground = function(object) {
        if (HumanViewHighlight.onForeground) {
            HumanViewHighlight.onForeground(object);
        }
    };

    HumanViewHighlight.background = function(object) {
        if (HumanViewHighlight.onBackground) {
            HumanViewHighlight.onBackground(object);
        }
    };

    HumanViewHighlight.neutral = function(object) {
        if (HumanViewHighlight.onNeutral) {
            HumanViewHighlight.onNeutral(object);
        }
    };

    ///////////////////////////////////////////
    // Highlight functions can be overridden 
    // by the application
    ///////////////////////////////////////////



    HumanViewHighlight.onForeground = function(object) {
        var color = Human.renderer.highlightColor;
        object.setTintColor(color[0], color[1], color[2]);
    };

    HumanViewHighlight.onBackground = function(object) {
        object.setTintColor(1, 1, 1);
    };

    HumanViewHighlight.onNeutral = function(object) {
        object.setTintColor(1, 1, 1);
    };


})();
;/**
 * @namespace manages Isolation mode
 */
(function () {
    "use strict";

    var HumanViewIsolate = Human.view.isolate = {}; 

    HumanViewIsolate.enabled = false;
    var dirty = true;

    function pickCallback(object) {
        if (!object) {
            return;
        }

        Human.view.labels.createLabel({ objectId: object.objectId, afterDelay: true, replace: true });
    }

    Human.events.on(
        "loaded",
        function () {
            HumanViewIsolate.enabled = false;
            dirty = false;
        });

    Human.events.on(
        "tick",
        function () {
            if (dirty) {
                // Lazy-isolate when flagged for next render frame
                Human.scene.setShowSelectedObjects(HumanViewIsolate.enabled);
                for (var objectId in Human.scene.selectedObjects) { // Highlight only selected objects
                    if (Human.scene.selectedObjects.hasOwnProperty(objectId)) {
                        Human.view.highlight.neutral(Human.scene.selectedObjects[objectId]);
                    }
                }
                dirty = false;
            }
        });

    Human.events.on(
        "scene.objectsSelected",
        function () {
            dirty = HumanViewIsolate.enabled;
        });

    HumanViewIsolate.setEnabled = function (enable) {
        if (HumanViewIsolate.enabled !== enable) {
            dirty = true;
        }
        
        HumanViewIsolate.enabled = enable;
        
        if(HumanViewIsolate.enabled) {
            Human.view.currentMode = 'Isolate';
            // Multi-pick doesn't make sense in Isolate mode
            Human.view.pick.setSinglePickEnabled(true);
            Human.view.pick.setMultiPickEnabled(false);
            Human.view.pick.onSingleClick = pickCallback;
        } else if (Human.view.pick.onSingleClick === pickCallback) {
            Human.view.pick.onSingleClick = null;
        }
        Human.events.fire("isolate.toggled", { enabled:HumanViewIsolate.enabled });
    };

    HumanViewIsolate.getEnabled = function () {
        return HumanViewIsolate.enabled;
    };

})();
;/**
 * @namespace Manages Dissection mode
 *
 * Can undo and redo dissections, forgets history when enable status changes.
 */
(function () {
    "use strict";

    var dissect = Human.view.dissect = {};

    dissect.enabled = false;  // Disable by default
    var undoStack = [];
    var redoStack = [];

    function pickCallback(object) {
        if (object) {
            Human.view.dissect.dissect(object.objectId);
        }
    }

    Human.events.on(
        "loaded",
        function () {
            dissect.enabled = false;
        });

    /**
     * Enable/disable dissection and notify
     */
    dissect.setEnabled = function (enable) {
        
        dissect.enabled = enable;

        if (enable) {
            Human.view.pick.onSingleClick = pickCallback;
        } else if (Human.view.pick.onSingleClick === pickCallback) {
            Human.view.pick.onSingleClick = null;
        }
        
        Human.events.fire("dissect.toggled", { enabled:dissect.enabled });
    };

    dissect.getEnabled = function () {
        return dissect.enabled;
    };

    /**
     * Dissect an object
     * Causes the object to be disabled (hidden) within the 3D scene
     * @param objectId
     */
    dissect.dissect = function (objectId) {
        if (!dissect.enabled) {
            return;
        }
        redoStack.length = 0;
        undoStack.push(objectId);
        var objects = {};
        objects[objectId] = false;
        Human.scene.setEnabledObjects({
            objectIds:objects
        });
    };

    /**
     * Undo last dissection
     */
    dissect.undo = function () {
        if (!dissect.enabled) {
            //return;
        }
        if (undoStack.length) {
            var objectId = undoStack.pop();
            var objects = {};
            objects[objectId] = true;
            Human.scene.setEnabledObjects({
                objectIds:objects
            });
            redoStack.unshift(objectId);
        }
    };

    /**
     * Redo last dissection
     */
    dissect.redo = function () {
        if (!dissect.enabled) {
            return;
        }
        var objectId;
        var objects;
        if (redoStack.length) {
            objectId = redoStack.shift();
            objects = {};
            objects[objectId] = false;
            Human.scene.setEnabledObjects({
                objects:objects
            });
            undoStack.push(objectId);
        }
    };

    dissect.reset = function () {
        redoStack.length = 0;
        undoStack.length = 0;
    };
})();
;/**
 * @namespace View mode in which annotations can be pinned to objects in {@link Human.scene}.
 */
(function () {
    "use strict";

    var HumanViewAnnotations = Human.view.annotations = {};

    var ID_PREFIX = "__a";

    /**
     * Pool of internally-managed annotation IDs, for annotations that are created without user-supplied IDs.
     * Such annotations are typically created from picking a scene object, while IDs are supplied on annotations
     * that are loaded with bookmarks, conditions etc.
     *
     * @type {Human.utils.IDPool}
     */
    var idPool = new Human.utils.IDPool({
        prefix: ID_PREFIX
    });

    /**
     * True when annotation mode is enabled
     * @type {boolean}
     */
    HumanViewAnnotations.enabled = false;

    /**
     * True when annotations are visible
     * @type {boolean}
     */
    HumanViewAnnotations.shown = true;

    /**
     * The annotations
     * @type {{String:Human.view.annotations.Annotation}}
     */
    HumanViewAnnotations.annotations = {};

    /**
     * Annotations on each scene object
     * @type {{String:Human.view.annotations.Annotation}}
     */
    HumanViewAnnotations.objectAnnotations = {};

    // Annotation currently being created, not yet saved
    HumanViewAnnotations.unsavedAnnotation = null;

    (function() {

        // When forced, minimal layout is always active.
        // When enabled, minimal layout is active only while the canvas size is below the given minimum.

        var minCanvasSize = [992, 992];
        var enabled = false;
        var forced = false;
        var active = false;

        HumanViewAnnotations.getMinimalActive = function () {
            if (forced) {
                return true;
            }
            if (!enabled) {
                return false;
            }
            var canvas = Human.renderer.canvas.annotationCanvas[0];
            return (canvas.width <= minCanvasSize[0] || canvas.height <= minCanvasSize[1]);
        };

        HumanViewAnnotations.setMinimalMinCanvasSize = function (width, height) {
            minCanvasSize = [width, height];
            update();
        };

        HumanViewAnnotations.setMinimalEnabled = function (value) {
            enabled = value;
            update();
        };

        HumanViewAnnotations.getMinimalEnabled = function () {
            return enabled;
        };

        HumanViewAnnotations.setMinimalForced = function (value) {
            forced = value;
            update();
        };

        HumanViewAnnotations.getMinimalForced = function () {
            return forced;
        };

        Human.events.on("canvas.resized", update);

        function update() {
            var activate = HumanViewAnnotations.getMinimalActive();
            if (activate !== active) {
                for (var annotationId in HumanViewAnnotations.annotations) {
                    if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                        var annotation = HumanViewAnnotations.annotations[annotationId];
                        annotation.setMinimal(activate);
                        annotation.pin.setMinimal(activate);
                        annotation.label.setMinimal(activate);
                    }
                }
                active = activate;
            }
        }
    })();

    /**
     * Enable or disables annotation mode, in which annotations may be created
     * @memberof Human.view.annotations
     * @param {boolean} enable True to enable, false to disable
     */
    HumanViewAnnotations.setEnabled = function (enable) {
        if (HumanViewAnnotations.enabled !== enable) {
            HumanViewAnnotations.enabled = enable;
            Human.events.fire("annotations.toggled", {enabled: enable});
        }

        if (HumanViewAnnotations.enabled) {
            Human.view.pick.onSingleClick = null;
        }
    };

    var pausedTimeline = false;
    var pausedFreeAnimations = false;

    HumanViewAnnotations.beginCreation = function () {
        if (Human.timeline.playing) {
            Human.timeline.playing = false;
            pausedTimeline = true;
        }

        if (Human.timeline.playfree) {
            Human.timeline.playfree = false;
            pausedFreeAnimations = true;
        }
    };

    HumanViewAnnotations.endCreation = function () {
        if (pausedTimeline) {
            Human.timeline.playing = true;
        }

        if (pausedFreeAnimations) {
            Human.timeline.playfree = true;
        }

        pausedTimeline = false;
        pausedFreeAnimations = false;
    };

    /**
     * Creates an annotation on an {@link Human.scene.Object} in {@link Human.scene}.
     *
     * @memberof Human.view.annotations
     * @param {*} params
     * @param {String} [params.annotationId] ID to assign to the annotation, generated internally if omitted.
     * @param {String} params.objectId ID of an {@link Human.scene.Object} in {@link Human.scene}.
     * @param {String} [params.type] Type of annotation, "default" by default.
     * @param {Boolean} [params.saved] True if we are reloading a previously saved annotation
     * @param {Boolean} [params.shown] True to show the annotation initially - default true
     * @param {String} params.title Title for annotation label
     * @param {String} params.description Text for annotation description in label
     * @param {[Number, Number, Number]} params.pos World-space position of annotation pin
     * @param {[Number, Number, Number]} params.dir 3D vector indicating direction the pin is pointing
     * @param {[Number, Number]} [params.labelOffset] 3D vector indicating offset of label in canvas-space
     * @param {Number} [params.primitiveIndex] Index of triangle in mesh.
     * @param {[Number, Number, Number]} [params.barycentric] Barycentric coordinate within triangle.
     * @returns {Human.view.annotations.Annotation} The new annotation, or null if error occurred, in which case the error is logged
     */
    HumanViewAnnotations.createAnnotation = function (params) {

        var object;

        if (params.objectId) {
            object = Human.scene.objects[params.objectId];
            if (!object) {
                Human.log.warn("Human.view.annotations.createAnnotation", "Scene object not found: '" + params.objectId + "'");
            }
        }

        // If annotation already being created, reuse that one
        if (HumanViewAnnotations.unsavedAnnotation) {
            params.title = HumanViewAnnotations.unsavedAnnotation.label.$titleField.val();
            params.description = HumanViewAnnotations.unsavedAnnotation.label.$descriptionField.val();
            params.objectId = HumanViewAnnotations.unsavedAnnotation.object ? HumanViewAnnotations.unsavedAnnotation.object.objectId : null;

            HumanViewAnnotations.unsavedAnnotation.destroy();
            HumanViewAnnotations.unsavedAnnotation = null;
        }

        if (params.annotationId) {
            if (params.annotationId.toString().slice(0, ID_PREFIX.length) === ID_PREFIX) {  // ID was system created. Don't need to keep.
                params.annotationId = idPool.getId();
            } else if (HumanViewAnnotations.annotations[params.annotationId]) {
                Human.log.error("Human.view.annotations.createAnnotation", "Annotation with this ID already exists: '" + params.annotationId + "'");
                return null;
            }
        } else {
            params.annotationId = idPool.getId();
        }

        var annotation = new Human.view.annotations.Annotation(object, params);

        HumanViewAnnotations.annotations[params.annotationId] = annotation;

        addObjectLookup(annotation);

        HumanViewAnnotations.unsavedAnnotation = params.saved ? null : annotation;

        annotation.setAnnotationsShown(HumanViewAnnotations.shown);

        annotation.on("picked",
            function () {
                Human.events.fire("annotations.picked", {
                    annotationId: annotation.annotationId
                });
            });

        annotation.label.on("mouseClick",
            function () {
                Human.events.fire("annotations.mouseClick", {
                    annotationId: annotation.annotationId
                });
            });

        annotation.label.on("mouseEnter",
            function (params) {
                if (annotation.object) {
                    highlightObject(annotation.object, true);
                }
                Human.events.fire("annotations.mouseEnter", params);
            });

        function highlightObject(object, highlight) {
            object.setHighlight(highlight);
            for (var i = 0, len = object.objects.length; i < len; i++) {
                highlightObject(object.objects[i], highlight);
            }
        }

        annotation.label.on("mouseLeave",
            function (params) {
                if (annotation.object) {
                    highlightObject(annotation.object, false);
                }
                Human.events.fire("annotations.mouseLeave", params);
            });

        annotation.label.on("mouseDown",
            function (params) {
                Human.events.fire("annotations.mouseDown", params);
            });

        annotation.label.on("mouseUp",
            function (params) {
                Human.events.fire("annotations.mouseUp", params);
            });

        annotation.on("saved",
            function () {
                if (HumanViewAnnotations.unsavedAnnotation && HumanViewAnnotations.unsavedAnnotation.annotationId === annotation.annotationId) {
                    HumanViewAnnotations.endCreation();
                    notify("annotations.created", annotation);
                    HumanViewAnnotations.animations.addAnnotation(annotation);
                } else {
                    notify("annotations.updated", annotation);
                }
                HumanViewAnnotations.unsavedAnnotation = null;
            });

        annotation.on("destroyed",
            function () {

                // De-highlight the annotation's object

                if (annotation.object) {
                    highlightObject(annotation.object, false);
                }

                HumanViewAnnotations.unsavedAnnotation = null;
                delete HumanViewAnnotations.annotations[annotation.annotationId];
                removeObjectLookup(annotation);
                HumanViewAnnotations.endCreation();
                HumanViewAnnotations.animations.removeAnnotation(annotation);
                Human.events.fire("annotations.destroyed", {
                    annotationId: annotation.annotationId
                });
            });

        if (params.saved) {
            this.endCreation();
            notify("annotations.created", annotation);
            this.animations.addAnnotation(annotation);
            HumanViewAnnotations.unsavedAnnotation = null;
        } else {
            this.beginCreation();
            Human.events.fire("annotations.creating", {
                annotationId: annotation.annotationId
            });
        }

        return annotation;
    };

    function addObjectLookup(annotation) {
        if (annotation.object) {
            var object = annotation.object;
            var objAnnots = HumanViewAnnotations.objectAnnotations[object.objectId];
            if (!objAnnots) {
                objAnnots = HumanViewAnnotations.objectAnnotations[object.objectId] = {
                    annotations: {},
                    numAnnotations: 0
                };
            }
            objAnnots.annotations[annotation.annotationId] = annotation;
            objAnnots.numAnnotations++;
        }
    }

    function removeObjectLookup(annotation) {
        if (annotation.object) {
            var object = annotation.object;
            var objAnnots = HumanViewAnnotations.objectAnnotations[object.objectId];
            if (objAnnots) {
                var a = objAnnots.annotations[annotation.annotationId];
                if (a) {
                    delete objAnnots.annotations[annotation.annotationId];
                    if (--objAnnots.numAnnotations === 0) {
                        delete HumanViewAnnotations.objectAnnotations[object.objectId];
                    }
                }
            }
        }
    }

    function notify(event, annotation) {
        Human.events.fire(event, {
            annotationId: annotation.id || annotation.annotationId,
            type: annotation.type,
            styleId: annotation.styleId,
            objectId: annotation.object ? annotation.object.objectId : null,
            title: annotation.label.title,
            description: annotation.label.description,
            pos: annotation.pin.pos,
            pinVec: annotation.pin.dir
        });
    }

    /**
     * Batch updates dimension properties of all annotation labels
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.updateDimensions = function () {
        for (var annotationId in HumanViewAnnotations.annotations) {
            if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                HumanViewAnnotations.annotations[annotationId].label.updateWidth();
            }
        }
    };

    /**
     * Control display of all annotation labels
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.setShown = function (shown) {
        if (HumanViewAnnotations.shown !== shown) {
            for (var annotationId in HumanViewAnnotations.annotations) {
                if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                    HumanViewAnnotations.annotations[annotationId].setAnnotationsShown(shown);
                }
            }
            HumanViewAnnotations.shown = shown;
            Human.events.fire("annotations.shown", {shown: shown});
        }
    };

    /**
     * Control display of all annotation labels for a given object
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.showByObjectId = function (objectId) {
        var objectLookUp = HumanViewAnnotations.objectAnnotations[objectId];
        if (objectLookUp) {
            var annotations = objectLookUp.annotations;
            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {

                    var annotation = annotations[annotationId];

                    annotation.checkObjectVisible();
                    annotation.setShown(annotation.getObjectVisible());
                }
            }
        }
    };

    /**
     * Destroy annotations for a given object
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.destroyByObjectId = function (objectId) {
        var objectLookUp = HumanViewAnnotations.objectAnnotations[objectId];
        if (objectLookUp) {
            var annotations = objectLookUp.annotations;
            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotations[annotationId].destroy();
                }
            }
        }
    };

    /**
     * Destroys all annotations.
     * @param [options]
     * @param [options.keepModuleAnnotations=false] When true, does not clear annotations that were loaded by modules.
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.clearAnnotations = function (options) {
        options = options || {};
        var keepModuleAnnotations = !!options.keepModuleAnnotations;
        HumanViewAnnotations.unsavedAnnotation = null;
        var annotation;
        for (var annotationId in HumanViewAnnotations.annotations) {
            if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                annotation = HumanViewAnnotations.annotations[annotationId];
                if (!keepModuleAnnotations || !annotation.moduleId) {
                    annotation.destroy();
                }
            }
        }
    };

    /**
     Queries annotations, with optional restrictions

     <p>Examples:</p>

     <pre>

     // Get a list of annotations for the Bones of the Head
     Human.view.annotations.getAnnotations({
        objectId: "maleAdult-Bones_of_the_Head"
     });

     // Get a list of secondary annotations for the Diaphragm
     Human.view.annotations.getAnnotations({
        objectId: "maleAdult-Diaphragm_13295",
        type: "secondary"
     });

     </pre>

     @param params
     @param [params.objectId] Object ID of the object to restrict annotation search
     @param [params.type] The type of annotation to restrict the search
     @returns {*}
     */
    HumanViewAnnotations.getAnnotations = function (params) {
        var _annotations = {};
        var searchAnnotations = HumanViewAnnotations.annotations;
        // restrict by object id
        if (params.objectId) {
            if (HumanViewAnnotations.objectAnnotations.hasOwnProperty(params.objectId)) {
                searchAnnotations = HumanViewAnnotations.objectAnnotations[params.objectId].annotations;
            }
            else {
                searchAnnotations = {};
            }
        }
        var type = params.type;
        for (var annotationId in searchAnnotations) {
            if (searchAnnotations.hasOwnProperty(annotationId)) {
                var annotation = searchAnnotations[annotationId];
                // restrict by type
                if (!type || type === annotation.type) {
                    _annotations[annotationId] = annotation;
                }
            }
        }
        return _annotations;
    };

    /**
     Convenience method which opens or closes labels on annotations,
     either per their IDs and/or the IDs of their scene objects.

     <p>Examples:</p>

     <pre>

     // Close labels on all annotations on the male frontal bone

     Human.view.annotations.setLabelsShown({
        objects: {
            "maleAdult-Frontal_bone_52734": false
        }
     });

     // Open labels on all annotations on the male frontal bone
     // Close labels on all other annotations

     Human.view.annotations.setLabelsShown({
        objects: {
            "maleAdult-Frontal_bone_52734": true
        },
        replace: true
     });

     // Hide one annotation and show another
     // Close labels on all other annotations

     Human.view.annotations.setLabelsShown({
        annotations: {
            "foo": false,
            "bar": true
        },
        replace: true
     });

     </pre>

     @param params
     @param [params.annotations] Map of annotation IDs to flags
     @param [params.objects] Map of object IDs to flags
     @param [params.replace] True to close labels on all other annotations - default false
     @param [params.type] When object IDs given, open/close only the annotations of this type on those objects
     */
    HumanViewAnnotations.setLabelsShown = function (params) {

        // Annotations we'll open labels for
        var updates = {};

        var type = params.type;
        var annotation, flags;
        var annotationId;
        var open;

        if (params.annotations) {

            // Show hide labels of given annotations
            // optionally filter on type

            flags = params.annotations;
            for (annotationId in flags) {
                if (flags.hasOwnProperty(annotationId)) {
                    annotation = HumanViewAnnotations.annotations[annotationId];
                    if (annotation) {
                        if (!type || type === annotation.type) {
                            updates[annotationId] = flags[annotationId];
                        }
                    }
                }
            }

        } else if (params.objects) {

            // Show/hide labels for annotations on target objects
            // optionally filter on type

            flags = params.objects;
            for (var objectId in flags) {
                if (flags.hasOwnProperty(objectId)) {
                    var object = Human.scene.objects[objectId];
                    if (object) {
                        var objectAnnotations = HumanViewAnnotations.objectAnnotations[objectId];
                        if (objectAnnotations) {
                            open = flags[objectId];
                            for (annotationId in objectAnnotations.annotations) {
                                if (objectAnnotations.annotations.hasOwnProperty(annotationId)) {
                                    annotation = objectAnnotations.annotations[annotationId];
                                    if (!type || type === annotation.type) {
                                        updates[annotationId] = open;
                                    }
                                }
                            }
                        }
                    }
                }
            }

        } else if (params.type) {

            // Show/hide labels of annotations of given type

            open = params.shown !== false;
            for (annotationId in HumanViewAnnotations.annotations) {
                if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                    annotation = HumanViewAnnotations.annotations[annotationId];
                    if (annotation) {
                        if (!type || type === annotation.type) {
                            updates[annotationId] = open;
                        }
                    }
                }
            }
        }

        if (params.replace) {

            // Close all other annotations

            for (annotationId in HumanViewAnnotations.annotations) {
                if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                    if (!updates[annotationId]) {
                        annotation = HumanViewAnnotations.annotations[annotationId];

                        // When closing or opening annotations of a given type on an object,
                        // ensure that we don't change the state of other annotations not matching the given type.

                        if (!type || type === annotation.type) {
                            annotation.pin.setShown(false);
                            annotation.label.setShown(false);
                        }
                    }
                }
            }
        }

        // Open the labels for the annotations we specified
        for (annotationId in updates) {
            if (updates.hasOwnProperty(annotationId)) {
                var shown = updates[annotationId];
                annotation = HumanViewAnnotations.annotations[annotationId];
                annotation.pin.setShown(shown);
                annotation.label.setShown(shown);
            }
        }
    };

    /**
     * Batch update of an annotation's state, fires an "annotations.updated".
     * This is intended for use by the API via RPC.
     * @param annotationId
     * @param params
     */
    HumanViewAnnotations.updateAnnotation = function (annotationId, params) {
        var annotation = HumanViewAnnotations.annotations[annotationId];
        if (annotation) {
            var label = annotation.label;
            if (params.title && params.title !== label.title) {
                label.setTitle(params.title);
            }
            if (params.description && params.description !== label.description) {
                label.setDescription(params.description);
            }
            // TODO: Other state updates as we need them for the API...
            notify("annotations.updated", annotation);
        }
    };

    var canvas, context, lastx1, lasty1, lastx2, lasty2;

    Human.events.on("loaded", function () {
        canvas = Human.renderer.canvas.annotationCanvas[0];
        context = canvas.getContext('2d');
    });

    var canvasStyles = {
        outerPin: {
            radius: 4.25,
            fillStyle: 'rgb(255,255,255)',
            lineWidth: 1,
            strokeStyle: 'rgb(204,204,204)'
        },
        innerPin: {
            radius: 1.75,
            fillStyle: 'rgb(153,0,0)'
        },
        wire: {
            lineWidth: 1,
            strokeStyle: 'rgb(204,204,204)'
        }
    };

    HumanViewAnnotations.setCanvasStyles = function (styles) {
        for (var prop in canvasStyles) {
            if (canvasStyles.hasOwnProperty(prop) && styles.hasOwnProperty(prop)) {
                Human.utils.apply(styles[prop], canvasStyles[prop]);
            }
        }
    };

    HumanViewAnnotations.drawWire = function (x1, y1, x2, y2) {
        if (!context) {
            return;
        }

        if (lastx1 !== undefined) {
            context.clearRect(lastx1, lasty1, lastx2, lasty2);
        }

        HumanViewAnnotations.clearWire();

        if (x1 !== x2 && y1 !== y2) {
            context.beginPath();
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
            context.lineWidth = canvasStyles.wire.lineWidth;
            context.strokeStyle = canvasStyles.wire.strokeStyle;
            context.stroke();

            lastx1 = x1;
            lasty1 = y1;
            lastx2 = x2;
            lasty2 = y2;
        }

        var outerPin = canvasStyles.outerPin;

        drawCircle(x1, y1, outerPin.radius, outerPin.fillStyle, outerPin.strokeStyle, outerPin.lineWidth);

        var innerPin = canvasStyles.innerPin;

        drawCircle(x1, y1, innerPin.radius, innerPin.fillStyle, innerPin.strokeStyle, innerPin.lineWidth);
    };

    HumanViewAnnotations.clearWire = function () {
        context.clearRect(0, 0, canvas.width, canvas.height);
    };

    function drawCircle(x, y, radius, fill, stroke, lineWidth) {
        context.fillStyle = fill;
        context.lineWidth = lineWidth;
        context.strokeStyle = stroke;

        context.beginPath();
        context.arc(x, y, radius, 0, 2 * Math.PI);

        if (fill) {
            context.fill();
        }

        if (stroke) {
            context.stroke();
        }
    }

})();







;(function() {
    "use strict";

    /**
     * @class An annotation within {@link Human.view.annotations}
     * @param [object]
     * @param cfg
     * @constructor
     */
    Human.view.annotations.Annotation = function (object, cfg) {

        var self = this;

        // Call parent class Human.Component init
        this._init();

        /** Module that loaded this annotation, if loaded by a module
         * @type {string}
         */
        this.moduleId = cfg.moduleId;

        /** Type of this annotation.
         *
         * @type {string}
         */
        this.type = cfg.type || "default";

        /** ID of this annotation, unique within {@link Human.view.annotations}
         * @type {String}
         */
        this.annotationId = cfg.annotationId;

        /**
         * Whether or not annotations are globally enabled
         * @type {boolean}
         */
        this.annotationsShown = Human.view.annotations.shown;

        /**
         * True when this annotation was configured with a 'labelOffset'.
         */
        this.draggable = !!cfg.labelOffset;

        /**
         * True when this annotation is hidden when its pin is occluded by another object.
         * @type {boolean}
         */
        this.occludable = cfg.occludable !== false && !!cfg.pos;

        /**
         * True when this annotation should animate with the object it's attached to.
         * @type {boolean}
         */
        this.followsObject = cfg.followsObject !== false && !!object;

        /* DOM order should be Label, Wire, Pin for CSS */

        /** The label for this annotation
         * @type {Human.view.annotations.Label}
         */

        cfg.offset = cfg.labelOffset; // Label needs 'offset'

        this.label = new Human.view.annotations.Label(this, cfg);

        /** The wire for this annotation
         */
        this.wire = $('<div class="annotationWire"></div>').appendTo('#container');

        /** The pin for this annotation
         * @type {Human.view.annotations.Pin}
         */
        this.pin = new Human.view.annotations.Pin(this, cfg.annotationId, cfg);

        /** True when this annotation is saved
         * @type {boolean}
         */
        this.saved = (cfg.saved !== undefined && cfg.saved !== null) ? cfg.saved : false;

        // Toggle label visibility when pin picked
        this.pin.on("picked",
            function () {
                if (!self.label.saved) {
                    alert("Please save or cancel annotation before hiding label");
                    return;
                }
                if (!Human.view.annotations.getMinimalActive()) {
                    self.label.setShown(!self.label.shown);
                    _showWire(
                        !Human.view.annotations.getMinimalActive() &&
                        self.annotationsShown &&
                        !self.label.culled &&
                        self.label.shown &&
                        self.pin.shown &&
                        self.getObjectVisible());
                }
                self.publish("picked", true, true);
            });

        // Toggle label visibility when pin picked
        this.label.on("saved",
            function () {
                self.publish("saved", self.saved = true);
            });

        // Toggle label visibility when pin picked
        this.label.on("delete",
            function () {
                self.destroy();
            });

        var _showWire = function (show) {
            if (show) {
                self.wire.show();
            } else {
                self.wire.hide();
            }
        };

        // These events influence whether to show or hide the wire

        // These events influence whether to show or hide the wire
        this.pin.on("enabled", function (enabled) {
            _showWire(
                !Human.view.annotations.getMinimalActive() &&
                self.annotationsShown &&
                enabled &&
                !self.label.culled &&
                self.label.shown &&
                self.pin.shown &&
                self.getObjectVisible());
        });

        this.label.on("shown", function (shown) {
            _showWire(
                !Human.view.annotations.getMinimalActive() &&
                self.annotationsShown && // All annotations visible
                self.pin.enabled &&  // ie. Object visible
                !self.label.culled && // Pin inside view
                shown &&
                self.pin.shown &&
                self.getObjectVisible());
        });

        this.label.on("culled", function (culled) {
            _showWire(
                !Human.view.annotations.getMinimalActive() &&
                self.annotationsShown &&
                self.pin.enabled &&
                !culled &&
                self.label.shown &&
                self.pin.shown &&
                self.getObjectVisible());
        });

        this.label.on("annotationsShown", function () {
            _showWire(
                !Human.view.annotations.getMinimalActive() &&
                self.annotationsShown &&
                self.pin.enabled &&
                !self.label.culled &&
                self.label.shown &&
                self.pin.shown &&
                self.getObjectVisible());
        });

        //TODO: write code for occlusion
        this.pin.on("occluded", function (occluded) {
            //ensure no opacity when occluded
            //not setting show / hide for simplicity
            if(occluded) {
                self.wire.css('opacity', '0');
            }
        });

        this.on("objectVisible", function () {
            _showWire(
                !Human.view.annotations.getMinimalActive() &&
                self.annotationsShown &&
                self.pin.enabled &&
                !self.label.culled &&
                self.label.shown &&
                self.pin.shown &&
                self.getObjectVisible());
        });

        /** The scene object this annotation is attached to
         * @type {Human.scene.Object}
         */
        this.object = null;

        this.objectVisible = null;

        if (object) {

            this.setObject(object);
            this.checkObjectVisible();

            if (!cfg.pos) {
                // No pin position was given, so position pin at center of object
                this.pin.setPos(object.getCenter());
            }
        }

        // Behaviours
        if (cfg.on) {
            var on = cfg.on;
            if (on.mouseClick) {
                this.label.on("mouseClick",
                    function () {
                        Human.rpc.call(null, on.mouseClick.call, on.mouseClick);
                    });
            }
        }
    };

    Human.utils.extend(Human.view.annotations.Annotation, Human.Component);

    Human.view.annotations.Annotation.prototype.setMinimal = function (minimal) {
        this._minimal = minimal;
        if (
            !Human.view.annotations.getMinimalActive() &&
            this.annotationsShown &&
            !this.label.culled &&
            this.label.shown &&
            this.pin.shown &&
            this.getObjectVisible()
        ) {
            this.wire.show();
        } else {
            this.wire.hide();
        }
    };

    /**
     * Reassigns annotation to an object
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.setObject = function (object) {
        this.publish("object", this.object = object);
    };


    /**
     * Checks if an annotation's object is visible on the canvas
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.checkObjectVisible = function () {
        if (this.object) {
            this.objectVisible = this.object.shown && this.object.isRenderable();
            this.publish("objectVisible", this.objectVisible);
        }
    };

    Human.view.annotations.Annotation.prototype.getObjectVisible = function () {
        return this.objectVisible === null ? true : this.objectVisible;
    };


    /**
     * Notifies this annotation on change to global toggle of annotation visibilities
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.setAnnotationsShown = function (annotationsShown) {
        this.annotationsShown = annotationsShown;
        this.pin.setAnnotationsShown(annotationsShown);
        this.label.setAnnotationsShown(annotationsShown);
    };

    /**
     * Control display of this annotation
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.setShown = function (shown) {
        this.pin.setShown(shown);
        this.label.setShown(shown);
    };

    /**
     * Destroys this annotation
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.destroy = function () {
        this.pin.destroy();
        this.label.destroy();
        this.wire.remove();

        this.publish("destroyed", true);
    };
})();

;(function() {
    "use strict";


    /**
     * @class A pin belonging to an {@link Human.view.Annotation}
     * @param cfg
     * @constructor
     */
    Human.view.annotations.Pin = function (annotation, id, cfg) {

        var containerSelector = $("#container");

        // Call parent class Human.Component init
        this._init();

        this._id = id;

        /** The {@link Human.view.Annotation} to which this pin belongs
         * @type {Human.view.Annotation}
         */
        this.annotation = annotation;

        /**
         * Whether or not annotations are globally enabled
         * @type {boolean}
         */
        this.annotationsShown = Human.view.annotations.shown;

        /**
         * Whether or not this pin is enabled
         * @type {boolean}
         */
        this.enabled = cfg.enabled !== false;

        /**
         * Whether or not this pin is shown
         * @type {boolean}
         */
        this.shown = cfg.shown !== false;

        /**
         * Whether or not this pin is culled
         * @type {boolean}
         */
        this.culled = false;

        /**
         * World-space position at which this pin is attached to its object.
         * @type {[Number, Number, Number]}
         */
        this.pos = vec3.create();

        if (cfg.pos) {
            this.pos[0] = cfg.pos[0];
            this.pos[1] = cfg.pos[1];
            this.pos[2] = cfg.pos[2];
        }

        /**
         * The index of the triangle to which this annotation belongs.
         * @type {Number}
         */
        this.primitiveIndex = cfg.primitiveIndex;

        /**
         * Barycentric coordinates of this annotation within its triangle.
         * @type {[Number, Number, Number]}
         */
        this.barycentric = vec3.create();

        if (cfg.barycentric) {
            this.barycentric[0] = cfg.barycentric[0];
            this.barycentric[1] = cfg.barycentric[1];
            this.barycentric[2] = cfg.barycentric[2];
        } else {
            this.barycentric[0] = this.barycentric[1] = this.barycentric[2] = 1/3;
        }

        this.viewPos = vec4.create();

        /**
         * Whether or not this pin is occluded
         * @type {boolean}
         */
        this.occluded = false;

        /**
         * Direction this pin points
         * @type {[Number, Number, Number]}
         */
        this.dir = cfg.dir || [0, 0, -1];

        this._element = $('<div></div>'); // We'll apply class in #setMinimal()

        this.setPos(cfg.pos || [0, 0, 0]);
        this.setDir(cfg.dir || [0, 0, 0]);

        this.setAnnotationsShown(Human.view.annotations.shown);
        this.setEnabled((cfg.enabled !== undefined && cfg.enabled !== null) ? cfg.enabled : true);
        this.setShown((cfg.shown !== undefined && cfg.shown !== null) ? cfg.shown : true);
        this.setCulled(!!cfg.culled);
        this.setOpacity(1.0);
        this.setMinimal(Human.view.annotations.getMinimalActive());

        containerSelector.append(this._element);

        this._element.click(this.pick.bind(this));
    };

    Human.utils.extend(Human.view.annotations.Pin, Human.Component);

    /**
     * Notifies this pin of change to global enable of annotation visibilities
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} annotationsShown True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setAnnotationsShown = function (annotationsShown) {
        this._showElement(annotationsShown && this.enabled && this.shown && !this.culled && !this.occluded && this.annotation.getObjectVisible());
        this.publish("enabled", this.annotationsShown = annotationsShown);
    };

    /**
     * Sets whether or not this pin is enabled
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} enabled True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setEnabled = function (enabled) {
        this._showElement(this.annotationsShown && enabled && this.shown && !this.culled && !this.occluded && this.annotation.getObjectVisible());
        this.publish("enabled", this.enabled = enabled);
    };

    /**
     * Sets whether or not this pin is shown
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} shown True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setShown = function (shown) {
        this._showElement(this.annotationsShown && this.enabled && shown && !this.culled && !this.occluded && this.annotation.getObjectVisible());
        this.publish("shown", this.shown = shown);
    };

    Human.view.annotations.Pin.prototype._showElement = function (shown) {
        if (shown) {
            this._element.show();
        } else {
            this._element.hide();
        }
    };

    /**
     * Culls this pin to given rectangle extents - pin is culled if it falls outside
     * @param {Number} xmin
     * @param {Number} ymin
     * @param {Number} xmax
     * @param {Number} ymax
     */
    Human.view.annotations.Pin.prototype.cullToRectangle = function (xmin, ymin, xmax, ymax) {
        var canvasPos = this.canvasPos;
        if (!canvasPos) {
            return;
        }
        this.setCulled(canvasPos[0] < xmin || canvasPos[0] > xmax || canvasPos[1] < ymin || canvasPos[1] > ymax);
        return this.culled;
    };

    /**
     * Sets whether or not this pin is culled
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} culled True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setCulled = function (culled) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !culled && !this.occluded && this.annotation.getObjectVisible());
        this.publish("culled", this.culled = culled);
    };

    /**
     * Transforms pin to View and Canvas space.
     */

    var projPos = vec4.create();

    Human.view.annotations.Pin.prototype.transform = function (viewMat, projMat, canvas) {
        vec3.transformMat4(this.viewPos, this.pos, viewMat);
        this.viewPos[3] = 1; // Need homogeneous 'w' for perspective division
        vec4.transformMat4(projPos, this.viewPos, projMat);
        var x = projPos[0];
        var y = projPos[1];
        var w = projPos[3];
        this.canvasPos = [(1 + x / w) * canvas.width / 2, (1 - y / w) * canvas.height / 2];
        this._element.css({ "left": this.canvasPos[0], "top": this.canvasPos[1] });
    };

    /**
     * Sets whether or not this pin is occluded
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} occluded True if occluded
     */
    Human.view.annotations.Pin.prototype.setOccluded = function (occluded) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !this.culled && !occluded && this.annotation.getObjectVisible());
        this.publish("occluded", this.occluded = occluded);
    };

    /**
     * Sets the pin's angle between it's "direction" and the direction towards the eye
     * @memberof Human.view.annotations.Pin
     * @param {number} viewAngle The angle in degrees
     */
    Human.view.annotations.Pin.prototype.setViewAngle = function (viewAngle) {
        this.publish("angle", this.viewAngle = viewAngle);
    };

    /**
     * Sets the pin's angle between direction and
     * @memberof Human.view.annotations.Pin
     * @param {number} opacity Opacity factor in range [0..1]
     */
    Human.view.annotations.Pin.prototype.setOpacity = function (opacity) {
        this._element.css({ "opacity": this.opacity = opacity });
        this.publish("opacity", opacity);
    };

    /**
     * Sets pin position in World-space coordinates
     * @memberof Human.view.annotations.Pin
     * @param {[Number, Number, Number]} pos World-space position
     */
    Human.view.annotations.Pin.prototype.setPos = function (pos) {
        this.pos[0] = pos[0];
        this.pos[1] = pos[1];
        this.pos[2] = pos[2];
        this.publish("pos", this.pos);
    };

    /**
     * Sets pin direction
     * @memberof Human.view.annotations.Pin
     * @param {[Number, Number, Number]} dir Pin direction vector
     */
    Human.view.annotations.Pin.prototype.setDir = function (dir) {
        this.publish("dir", this.dir = dir);
    };

    Human.view.annotations.Pin.prototype.setMinimal = function (minimal) {
        this._element.attr("class", minimal ? 'annotationPinLarge' : 'annotationPin');
    };

    /**
     * Notifies this pin that it has been picked
     * @memberof Human.view.annotations.Pin
     * @private
     */
    Human.view.annotations.Pin.prototype.pick = function () {
        this.publish("picked", true, true);
    };

    /**
     * Destroys this pin
     * @memberof Human.view.annotations.Pin
     * @private
     */
    Human.view.annotations.Pin.prototype.destroy = function () {
        this._element.remove();
        this.publish("destroyed", true);
    };
})();
;(function (Human, $) {
    "use strict";

    /**
     * @class A label belonging to a {@link Human.view.Pin}
     * @param {Human.view.annotations.Annotation} annotation Owner annotation
     * @param {{}} cfg Configs
     * @constructor
     */
    var Label = Human.view.annotations.Label = function (annotation, cfg) {
        this._init(); // Call parent class Human.Component init

        this.annotation = annotation;
        this.saved = !!cfg.saved;
        this._minimal = Human.view.annotations.getMinimalActive();

        this.offset = cfg.offset || [70, 70];


        this.offset2 = [this.offset[0], this.offset[1]];


        this.offset2 = [this.offset[0], this.offset[1]];

        var editable = true;

        var editing = this.editing = editable && !this.saved;

        var initialClass = this.saved ? '' : 'new';
        var editableClass = editable ? 'editable' : '';
        var editingClass = editing ? 'editing' : '';
        // layout class
        var layoutType = Human.view.annotations.layouts.activeLayout;
        var layoutClass = layoutType ? layoutType : '';
        var initialClasses = [initialClass, editableClass, editingClass, layoutClass].join(' ');

        var $container = $('#container');

        this.$element = $([
            '<div class="annotationContainer">',
            '<div class="annotationTitle clearfix">', //holds title elements
            '<input type="text" placeholder="">',
            '<h1></h1>',
            '<button class="annotationSave"></button>',
            '<button class="annotationDelete"></button>',
            '</div>',
            '<div class="annotationDescription">', //holds descriptions elements
            '<textarea placeholder=""></textarea>',
            '<p></p>',
            '</div>',
            '<div class="embedContainer"></div>',
            '</div>'
        ].join(''));

        //Select annotation components
        this.$titleContainer = this.$element.find('.annotationTitle');
        this.$title = this.$element.find('h1');
        this.$description = this.$element.find('p');
        this.$titleField = this.$element.find('input');
        this.$descriptionField = this.$element.find('textarea');
        // select buttons
        this.$deleteBtn = this.$element.find('.annotationDelete');
        this.$saveBtn = this.$element.find('.annotationSave');

        _initFieldMaxLength(this.$titleField, 100);
        _initFieldMaxLength(this.$descriptionField, 300); //set length constraints

        this.setTitle(cfg.title || '');
        this.setDescription(cfg.description || ''); //set initial values

        //set initial classes and add to DOM
        this.$element.addClass(initialClasses).appendTo($container);

        this.bindHandlers(editable);

        //Set these states after this.$element is defined
        this.setAnnotationsShown(Human.view.annotations.shown);
        this.setEnabled(cfg.enabled !== false);
        this.setShown(cfg.labelShown !== false);
        this.setCulled(!!cfg.culled);
        this.setOccluded(!!cfg.occluded);

        if (cfg.embed) {
            this.setEmbed(cfg.embed); //support for nested widget
        }

        this.setOffset(cfg.offset || [70, -70]);

        this.updateWidth();
    };

    Human.utils.extend(Human.view.annotations.Label, Human.Component);

    Label.prototype.bindHandlers = function (editable) {
        var self = this,
            $document = $(document);

        var globalSet = function (e) {
            //listen for a click outside the container to cancel editing
            var $target = $(e.target);
            var outsideClick = $target.closest('.annotationContainer').length === 0;

            if (outsideClick) {

                if (self.$titleField.val() || self.$descriptionField.val()) { // save non-empty annotation
                    self.save();
                    $document.off('click.set-annotation'); //turn it off
                } else { //delete empty annotation
                    //
                    if (self.pos) {
                        self.delete();
                        $document.off('click.set-annotation');
                    }
                }
            }
        };

        var setUIPosition = function () {
            var annotation = self.annotation;
            if (annotation.pin) {
                var pin = annotation.pin;
                var label = annotation.label;
                var wirePos1 = pin.canvasPos || [];
                var side = (label.offset[0] < 0);
                var labelPos = [wirePos1[0] + label.offset[0], wirePos1[1] + label.offset[1]];
                if (side) {
                    // Wire attaches to right side,
                    // shift label to the left to accommodate
                    labelPos[0] -= label.getWidth();
                }
                self.setPos(labelPos);
            }
        };

        // capture default font
        var titleFont = getElementFont(self.$titleField);
        var descriptionFont = getElementFont(self.$descriptionField);
        var showPlaceholderWidth = getTextWidth("Description", descriptionFont);

        // set description placeholder
        var setDescriptionUI = function (stripHtml) {
            var title = self.$titleField.val();
            var titleWidth = getTextWidth(title, titleFont, stripHtml);
            // show placeholder when wide enough
            if (title !== "" && titleWidth >= showPlaceholderWidth) {
                self.$descriptionField.attr("placeholder", "Description");
            }
            else {
                self.$descriptionField.attr("placeholder", "");
            }
        };

        var setTitleUI = function (stripHtml) {
            var title = self.$titleField.val();
            var description = self.$descriptionField.val();
            var lines = description.split('\n');
            var descWidth = getTextWidth(lines[0] + "X", descriptionFont, stripHtml);
            var containerMaxWidth = parseInt(self.$element.css("max-width"), 10);
            var maxWidth = containerMaxWidth + '' === 'NaN' ? 200 : containerMaxWidth;
            var width = getTextWidth(title + "X", titleFont, stripHtml);//+ 8;

            var targetWidth = Math.max(width, descWidth);
            targetWidth = Math.min(targetWidth, maxWidth);
            self.$titleContainer.css("width", targetWidth + "px");
            self.$titleField.css("width", targetWidth + "px");
            self.$descriptionField.css("width", targetWidth + "px");

            // set css
            if (title === "" && description === "") {
                if (!self.$element.hasClass("empty")) {
                    self.$element.addClass("empty");
                }
            }
            else {
                self.$element.removeClass("empty");
            }
            setUIPosition();
        };

        var setTextUI = function (stripHtml) {
            setTitleUI(stripHtml);
            setDescriptionUI(stripHtml);
        };

        // track UI handlers
        self.on("title", function () {
            setTextUI(true);
        });

        self.$titleField.on("keypress focus", function () {
            setTextUI(!editable);
        });

        self.$descriptionField.on("keypress focus", function () {
            setTextUI(!editable);
        });

        if (editable && this.editing) {
            //allow setting of newly created annotation on a global click
            $document.on('click.set-annotation', function (e) {
                globalSet(e);
            });
            // focus on title
            self.$titleField.focus();

            // Required for IE/Edge
            Human.utils.async(function () {
                self.$titleField.focus();
            });
        }

        self.on("mouseClick", function (params) {
            var $target = $(params.e.target);
            // enter edit on title header selection
            var titleSelected = $target.is(self.$titleContainer) || self.$titleContainer.has($target).length !== 0;
            if (editable && !self.editing && titleSelected) {

                self.editing = true;

                //give textarea same height as current description
                self.$descriptionField.height(self.$description[0].offsetHeight);

                self.$element.addClass('editing');
                // focus on title
                self.$titleField.focus();

                self.publish("edit", true, true);
                self.publish('updateWidth', true, true);

                $document.on('click.set-annotation', function (e) {
                    globalSet(e);
                });
            }
        });

        self.$descriptionField.blur(function (e) {
            globalSet(e);
        });

        self.$deleteBtn.click(function (e) {
            e.preventDefault();

            self.delete();
        });

        self.$saveBtn.click(function (e) {
            e.preventDefault();

            self.save();
        });

        // track mouse position
        var mouseX = 0;
        var mouseY = 0;
        // track mouse movement
        var trackMouseEvent = function (e) {
            mouseX = e.clientX;
            mouseY = e.clientY;
        };

        //Bind simple publishing to Label object
        self.$element.mouseenter(function (e) {
            self.publish("mouseEnter", {
                annotationId: self.annotation.annotationId,
                e: e
            }, true);
            trackMouseEvent(e);
        });

        self.$element.mouseleave(function (e) {
            self.publish("mouseLeave", {
                annotationId: self.annotation.annotationId,
                e: e
            }, true);
            trackMouseEvent(e);
        });

        self.$element.mousedown(function (e) {
            self.publish("mouseDown", {
                annotationId: self.annotation.annotationId,
                x: e.clientX,
                y: e.clientY,
                e: e
            }, true);
            trackMouseEvent(e);
        });

        self.$element.mouseup(function (e) {
            var clientX = e.clientX;
            var clientY = e.clientY;
            self.publish("mouseUp", {
                annotationId: self.annotation.annotationId,
                x: clientX,
                y: clientY,
                e: e
            }, true);
            // click
            if (mouseX === clientX && mouseY === clientY) {
                self.publish("mouseClick", {
                    annotationId: self.annotation.annotationId,
                    x: clientX,
                    y: clientY,
                    e: e
                }, true);
            }
            trackMouseEvent(e);
        });

        //On any human event that changes the Label object's width, update layout
        self.on('updateWidth', this._redrawWireConnection.bind(this));
    };

    Label.prototype.save = function () {
        this.editing = false;

        this.setTitle(this.$titleField.val());
        this.setDescription(this.$descriptionField.val());

        this.$element.removeClass('new editing');

        this.publish("saved", this.saved = true);
        this.publish('updateWidth', true, true);
    };

    Label.prototype.delete = function () {
        this.publish("delete", true, true);
    };

    /**
     * Sets the 2D canvas offset of the label from the pin. default value is [0,0].
     * @memberof Human.view.annotations.Label
     * @param {Array of Number} [offset=[0,0]] Canvas-space 2D offset
     */
    Label.prototype.setOffset = function (offset) {

        this.offset[0] = offset[0];
        this.offset[1] = offset[1];

        this.offset2[0] = offset[0];
        this.offset2[1] = offset[1];

        this.publish("offset", this.offset);
    };

    /**
     * Notifies this label on change to global toggle of annotation visibilities
     * @memberof Human.view.annotations.Label
     * @param {Boolean} annotationsShown True to show, false to hide
     */
    Label.prototype.setAnnotationsShown = function (annotationsShown) {
        this._showElement(annotationsShown && this.enabled && !this._minimal && this.shown && !this.culled && !this.occluded  && this.annotation.getObjectVisible());
        this.publish("annotationsShown", this.annotationsShown = annotationsShown);
    };

    /**
     * Sets whether or not this label is enabled
     * @memberof Human.view.annotations.Label
     * @param {Boolean} enabled True to show, false to hide
     */
    Label.prototype.setEnabled = function (enabled) {
        this._showElement(this.annotationsShown && enabled && !this._minimal && this.shown && !this.culled && !this.occluded && this.annotation.getObjectVisible());
        this.publish("enabled", this.enabled = enabled);
    };

    Label.prototype.setMinimal = function (minimal) {
        this._minimal = minimal;
        this._showElement(this.annotationsShown && this.enabled && !this._minimal && this.shown && !this.culled && !this.occluded && this.annotation.getObjectVisible());
    };

    /**
     * Sets whether or not this label is shown
     * @memberof Human.view.annotations.Label
     * @param {Boolean} shown True to show, false to hide
     */
    Label.prototype.setShown = function (shown) {
        this._showElement(this.annotationsShown && this.enabled && !this._minimal && shown && !this.culled && !this.occluded && this.annotation.getObjectVisible());
        if (this.shown !== shown) {
            this.shown = shown;
            this.publish("shown", this.shown);
        }
    };

    /**
     * Sets whether or not this label is culled
     * @memberof Human.view.annotations.Label
     * @param {Boolean} culled True to show, false to hide
     */
    Label.prototype.setCulled = function (culled) {
        this._showElement(this.annotationsShown && this.enabled && !this._minimal && this.shown && !culled && !this.occluded && this.annotation.getObjectVisible());
        this.publish("culled", this.culled = culled);
    };

    /**
     * Sets whether or not this label is occluded
     * @memberof Human.view.annotations.Label
     * @param {Boolean} occluded True if occluded
     */
    Label.prototype.setOccluded = function (occluded) {
        this._showElement(this.annotationsShown && this.enabled && !this._minimal && this.shown && !this.culled && !occluded && this.annotation.getObjectVisible());
        this.publish("occluded", this.occluded = occluded);
    };

    /**
     * Sets the label's opacity
     * @memberof Human.view.annotations.Label
     * @param {number} opacity Opacity factor in range [0..1]
     */
    Label.prototype.setOpacity = function (opacity) {
        this.$element.css({"opacity": this.opacity = opacity});
        this.publish("opacity", opacity);
    };

    Label.prototype._showElement = function (shown) {
        if (shown) {
            this.$element.css("display", "inline-block");
        } else {
            this.$element.hide();
        }
    };

    /**
     * Sets the title
     * @memberof Human.view.annotations.Label
     * @param {String} title Title text
     */
    Label.prototype.setTitle = function (title) {
        this.$titleField.val(title);
        this.$title.html(title);
        this.publish("title", this.title = title);
    };

    /**
     * Sets the description
     * @memberof Human.view.annotations.Label
     * @param {String} description Description text
     */
    Label.prototype.setDescription = function (description) {
        this.$descriptionField.val(description);
        this.$description.html(description);
        this.publish("description", this.description = description);
    };

    /**
     * Sets the embed window
     * @memberof Human.view.annotations.Label
     * @param {Object} embed Embedded config data
     */
    Label.prototype.setEmbed = function (embed) {
        var params = ['ui-all=false']; //enforce no ui elements in this mode

        for (var key in embed) {
            if (embed.hasOwnProperty(key)) {
                params.push(key + '=' + embed[key]);
            }
        }

        var url = '/embedded.html?' + params.join('&');
        var iframe = '<iframe src="' + url + '" width="150" height="150" border="0"></iframe>';

        this.$element.addClass('annotationEmbed');
        this.$element.find('.embedContainer').append(iframe).show();

        this.publish('embed', this.embed = embed);
    };

    /**
     * Sets the DOM-space position of this label
     * @memberof Human.view.annotations.Label
     * @param {[Number, Number]} pos DOM-space label position
     * @param {Boolean} horizontal Indicates horizontal property set
     */
    Label.prototype.setPos = function (pos, horizontal) {
        if (horizontal) {
            pos[1] = pos[1] - this.$titleContainer[0].offsetHeight;
        }

        this.$element.css({left: pos[0] + 'px', top: pos[1] + 'px'});
        this.publish("pos", this.pos = pos);
    };

    /**
     * Sets the side of the canvas this label is on,
     * as well its wire connection position
     * @memberof Human.view.annotations.Label
     * @param {String} side 'left' or 'right'
     */
    Label.prototype.setSide = function (side) {
        this.side = side;
        this.$element.removeClass('left right').addClass(side);

        this.connectionPoint = [ //set the point where the wire will meet the label
            this.pos[0] + (side === 'left' ? this.getWidth() : 0),
            this.pos[1] + this.$titleContainer[0].offsetHeight
        ];
    };

    /**
     * Gets the top of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Top of label
     */
    Label.prototype.getTop = function () {
        return this.$element[0].offsetTop;
    };

    /**
     * Gets the bottom of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Bottom of label
     */
    Label.prototype.getBottom = function () {
        return this.$element[0].offsetTop + this.getHeight();
    };

    /**
     * Gets the height of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Height of label
     */
    Label.prototype.getHeight = function () {
        return this.$element[0].offsetHeight;
    };

    /**
     * Gets the width of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Width of label
     */
    Label.prototype.getWidth = function () {
        return this.$element[0].offsetWidth;
    };

    /**
     * Synchs the width property of this label with it's DOM outer width
     * @memberof Human.view.annotations.Label
     */
    Label.prototype.updateWidth = function () {
        this.width = this.getWidth();
    };

    Label.prototype._redrawWireConnection = function () {
        this.updateWidth();
        Human.view.annotations.layouts.redrawLayout();
    };

    /**
     * Destroys this label
     * @memberof Human.view.annotations.Label
     * @private
     */
    Label.prototype.destroy = function () {
        this.$element.remove();
        this.publish("destroyed", true);
    };

    //Private Utilities
    var _initFieldMaxLength = function ($element, maxLength) {
        if (maxLength && maxLength > 0) {
            $element.attr("maxlength", maxLength);

            $element.keyup(function (e) {
                if (e.keyCode === 13) { // ignore ENTER
                    return;
                } else if ($element.val().length >= maxLength) {
                    alert('Maximum characters allowed (' + maxLength + ')');
                }
            });
        }
    };

    // Text Utilities
    var textMeasureCanvas;
    // measures text's width in DOM
    var getTextWidth = function (text, font, _stripHtml) {
        textMeasureCanvas = textMeasureCanvas || document.createElement("canvas");

        var context = textMeasureCanvas.getContext("2d");
        context.font = font;

        if(_stripHtml) {
            text = stripHtml(text);
        }

        var metrics = context.measureText(text);

        return metrics.width;
    };

    var stripHtml = function (text) {
        var div = document.createElement("div");
        div.innerHTML = text;
        return div.innerText;
    };

    var getElementFont = function (element) {
        return $(element).css("font");
    };

})(Human, jQuery);
;(function() {
    "use strict";

    var animationsList = [];
    var unrenderable = [];

    var dirty = false;
    var canvas;

    var Animations = Human.view.annotations.animations = {
        animations: {},
        numAnimations: 0
    };

    Human.events.on("loaded",
        function () {
            canvas = Human.renderer.canvas.annotationCanvas[0];
        });

    Animations.addAnnotation = function(annotation) {

        if (!annotation.object) {
            return;
        }

        if (!annotation.object.isRenderable()) {
            unrenderable.push(annotation);
            return;
        }

        this.createAnimation(annotation);
    };

    Animations.createAnimation = function(annotation) {
        var object = annotation.object;
        var morphingAnnotation = object.morph && object.geometry && annotation.pin.primitiveIndex;

        if (morphingAnnotation) {
            var offset = annotation.label.offset;

            this.animations[annotation.annotationId] = new MorphAnimation({
                object: object,
                morph: object.morph,
                geometry: object.geometry,
                annotation: annotation,
                offset: [offset[0], offset[1]]
            });
        } else {
            this.animations[annotation.annotationId] = new XformAnimation({
                object: object,
                annotation: annotation
            });
        }

        dirty = true;
    };

    Animations.addObject = function(object) {
        var annotations = Human.view.annotations.getAnnotations({ objectId: object.objectId });

        for (var annotationId in annotations) {
            if (annotations.hasOwnProperty(annotationId)) {
                this.addAnnotation(annotations[annotationId]);
            }
        }
    };

    Animations.removeAnnotation = function(annotation) {

        if (this.animations[annotation.annotationId]) {

            delete this.animations[annotation.annotationId];

            dirty = true;
        }
    
    };

    Human.events.on("tick",
        function () {
            var i, len;

            if (unrenderable.length > 0) {
                for (i = 0, len = unrenderable.length; i < len; ++i) {
                    if (unrenderable[i].object.isRenderable()) {
                        Animations.createAnimation(unrenderable[i]);
                        unrenderable[i] = null;
                    }
                }

                Human.utils.filterInPlace(unrenderable, function (a) { return a !== null; });
            }

            if (dirty) {

                // Lazy-rebuild fast iteration array

                Animations.numAnimations = 0;

                for (var annotationId in Animations.animations) {
                    if (Animations.animations.hasOwnProperty(annotationId)) {
                        animationsList[Animations.numAnimations++] = Animations.animations[annotationId];
                    }
                }

                dirty = false;
            }

            if (Animations.numAnimations > 0) {

                for (i = 0; i < Animations.numAnimations; i++) {
                    animationsList[i].update();
                }

                Human.view.annotations.layouts.redrawLayout();
            }
        });

    var worldToModel = mat4.create();

    function XformAnimation(cfg) {
        this._annotation = cfg.annotation;
        this._object = cfg.object;

        this._pinPos = vec3.create();
        this._pinPos.set(this._annotation.pin.pos);

        mat4.invert(worldToModel, this._object.getWorldMatrix());
        vec3.transformMat4(this._pinPos, this._pinPos, worldToModel);
    }


    var pos = vec3.create();

    XformAnimation.prototype.update = function () {

        var annotation = this._annotation;

        if (!annotation.pin.shown) {

            // Don't animate hidden pins
            return;
        }

        vec3.transformMat4(pos, this._pinPos, this._object.getWorldMatrix());

        annotation.pin.setPos(pos);
    };

    // Vertices of each triangle
    var a = vec3.create();
    var b = vec3.create();
    var c = vec3.create();

    function MorphAnimation(cfg) {

        var morph = cfg.morph;
        var geometry = cfg.geometry;
        var annotation = cfg.annotation;
        var pin = annotation.pin;

        this._object = cfg.object;
        this._morph = morph;
        this._annotation = annotation;
        this._times = morph.getKeys();
        this._targets = [];

        // Caches last time frame after each call to #update()
        this._index1 = 0;
        this._index2 = 1;

        // True when looping
        this._loop = !!cfg.loop;

        this._pickPos = vec3.create();

        this._pinPos = vec3.create();
        mat4.invert(worldToModel, this._object.getWorldMatrix());
        vec3.transformMat4(this._pinPos, annotation.pin.pos, worldToModel);

        this._offset = [
            annotation.label.offset[0],
            annotation.label.offset[1]
        ];

        var self = this;

        annotation.label.on("offset", function (offset) {
            self._offset = offset;
        });


        // Using the barycentric position, find the target cartesian
        // pin position at each morph target, which we'll tween
        // within to animate the pin in synch with the morph.

        var i;
        var len;
        var mTargets = this._morph.getTargets();
        var positions;
        var primitiveIndex = pin.primitiveIndex;
        var indices = geometry.getIndices();
        var ia = indices[primitiveIndex];
        var ib = indices[primitiveIndex + 1];
        var ic = indices[primitiveIndex + 2];
        var barycentric = pin.barycentric;
        var cartesian;

        for (i = 0, len = mTargets.length; i < len; i++) {

            positions = mTargets[i].positions;

            a[0] = positions[(ia * 3)];
            a[1] = positions[(ia * 3) + 1];
            a[2] = positions[(ia * 3) + 2];

            b[0] = positions[(ib * 3)];
            b[1] = positions[(ib * 3) + 1];
            b[2] = positions[(ib * 3) + 2];

            c[0] = positions[(ic * 3)];
            c[1] = positions[(ic * 3) + 1];
            c[2] = positions[(ic * 3) + 2];

            cartesian = barycentricToCartesian(barycentric, a, b, c, vec3.create());

            this._targets.push(cartesian);
        }

        this._pickPos[0] = this._pinPos[0];
        this._pickPos[1] = this._pinPos[1];
        this._pickPos[2] = this._pinPos[2];
    }

    /**
     * Updates this animation, updating the value of #pos.
     */
    var avgCanvasPos = vec2.create();
    var canvasPos = vec2.create();

    MorphAnimation.prototype.update = function () {

        var annotation = this._annotation;

        if (!annotation.pin.shown) {

            // Don't animate hidden pins
            return;
        }

        var time = this._morph.getFactor();

        if (this._targets.length < 2) {
            return;
        }

        if (time === undefined) {
            time = this._times[0];
        }

        var firstTime = this._times[0];
        var lastTime = this._times[this._times.length - 1];

        if (!this._loop) {

            // Clamp time to range
            // Return clamped value

            if (time <= firstTime) {
                return this._targets[0];

            } else if (time >= lastTime) {
                return this._targets[this._targets.length - 1];
            }

        } else {

            // Wrap time within range

            time = this._times[0] + (time % (lastTime - firstTime));
        }

        // Wind on to enclosing time frame

        // Wind backwards or forwards to find enclosing frame

        while (this._times[this._index1] > time) {
            this._index1--;
            this._index2--;
        }

        while (this._times[this._index2] < time) {
            this._index1++;
            this._index2++;
        }

        // Interpolate

        Human.math.lerpVec3(
            time,

            this._times[this._index1],
            this._times[this._index2],

            this._targets[this._index1],
            this._targets[this._index2],

            this._pinPos);

        vec3.transformMat4(this._pinPos, this._pinPos, this._object.getWorldMatrix());

        annotation.pin.setPos(this._pinPos);

        this._transform(this._pickPos, avgCanvasPos);
        this._transform(this._pinPos, canvasPos);

        annotation.label.offset2[0] = this._offset[0] - (canvasPos[0] - avgCanvasPos[0]);
        annotation.label.offset2[1] = this._offset[1] - (canvasPos[1] - avgCanvasPos[1]);
    };

    var viewPos = vec4.create();
    var projPos = vec4.create();

    MorphAnimation.prototype._transform = function (worldPos, canvasPos) {
        var viewMat = Human.renderer.getViewMat();
        var projMat = Human.renderer.getProjMat();

        vec3.transformMat4(viewPos, worldPos, viewMat);

        viewPos[3] = 1; // Need homogeneous 'w' for perspective division

        vec4.transformMat4(projPos, viewPos, projMat);

        var x = projPos[0];
        var y = projPos[1];
        var w = projPos[3];

        canvasPos[0] = (1 + x / w) * canvas.width / 2;
        canvasPos[1] = (1 - y / w) * canvas.height / 2;

        return canvasPos;
    };

    /**
     * Gets the cartesian position of a barycentric coordinate within a triangle.
     */
    function barycentricToCartesian(barycentric, a, b, c, cartesian) {
        var u = barycentric[0];
        var v = barycentric[1];
        var w = barycentric[2];
        cartesian[0] = a[0] * u + b[0] * v + c[0] * w;
        cartesian[1] = a[1] * u + b[1] * v + c[1] * w;
        cartesian[2] = a[2] * u + b[2] * v + c[2] * w;
        return cartesian;
    }

})();
;/**
 * @namespace Pins annotations on anatomy objects while automatically determining their pin direction vectors from the eye position.
 */
(function () {
    "use strict";

    var placer = Human.view.annotations.placer = {};
    var eyePosVec = vec3.create();

    /**
     * Places a fresh annotation at the given World-space position, with pin pointing towards the eye position.
     *
     * <p>The annotation:</p>
     * <ul>
     *     <li>will have empty strings for title and description,</li>
     *      <li>have an initially visible pin and label, and</li>
     *      <li>will be in an unsaved state.</li>
     * </ul>
     *
     * @param {{}} params Placement params
     * @param {String} params.objectId ID of an {@link Human.scene.Object} in {@link Human.scene}.
     * @param {[Number, Number, Number]} params.pos World-space position of annotation pin
     * @param {[Number, Number]} params.mouseDownPos Canvas-space position of mouse click when placing annotation with click-drag-release
     * @param {[Number, Number]} params.labelOffset Canvas-space offset of label from pin
     * @param {Boolean} params.mouseDownPos True when we are also currently positioning the label with the mouse, as we create this annotation
     * @param {[Number, Number, Number]} params.dir 3D vector indicating direction the pin is pointing
     */
    placer.placeAnnotation = function (params) {

        var eyePos = Human.view.camera.eye;

        eyePosVec[0] = eyePos.x;
        eyePosVec[1] = eyePos.y;
        eyePosVec[2] = eyePos.z;

        var eyeVec = vec3.create();

        vec3.subtract(eyeVec, eyePosVec, params.pos);

        Human.view.annotations.createAnnotation({
            objectId: params.objectId,
            title: params.title || "",
            description: params.description || "",
            pos: params.pos,
            mouseDownPos: params.mouseDownPos,
            dir: eyeVec,
            enabled: true,
            shown: true,
            labelShown: true,
            labelOffset: params.labelOffset,
            saved: (params.saved !== undefined && params.saved !== null) ? params.saved : false
        });
    };

})();







;/**
 * @namespace Renders an annotation onto a 2D canvas
 */
(function () {
    "use strict";

    var LABEL_TITLE_FONT_SIZE = 14;
    var LABEL_DESCRIPTION_FONT_SIZE = 12;
    var LABEL_TEXT_ALIGN = "left";
    var PIN_OUTER_RADIUS = 5.0;
    var PIN_INNER_RADIUS = 2.0;

    var renderer = Human.view.annotations.renderer = {};

    /**
     * Renders the annotation, labels, pin, etc... to the canvas object
     *
     * @param {{}} params Rander params
     * @param {Object} params.annotation An {@link Human.view.annotations.Annotation} in {@link Human.view}.
     * @param {Object} params.canvasData Canvas data
     * @param {String} params.bgColor Background color
     */
    renderer.render = function (params) {

        var annotation = params.annotation;
        var canvasData = params.canvasData;
        var bgColor = params.bgColor;

        var context = canvasData.context;
        var label = annotation.label;
        var pin = annotation.pin;
        var connectionPoint = label.connectionPoint;
        var scaleX = canvasData.scaleX;
        var scaleY = canvasData.scaleY;
        var pinX = pin.canvasPos[0] * scaleX;
        var pinY = pin.canvasPos[1] * scaleY;

        var labelShown = label.enabled && label.shown && !label.occluded && !label.culled;

        if (labelShown) {

            var labelX = label.pos[0] * scaleX;
            var connectX = connectionPoint[0] * scaleX;
            var connectY = connectionPoint[1] * scaleY;

            var labelWidth = Math.min((canvasData.width - labelX - 10), label.width * scaleX); //cap max-width

            //set font color based on background
            context.fillStyle = bgColor === 'white' ? "rgb(0, 0, 0)" : "rgb(255, 255, 255)";
            // set text align
            context.textAlign = LABEL_TEXT_ALIGN;

            // scale font to canvas
            var titleFontSize = Math.round(LABEL_TITLE_FONT_SIZE * scaleX);
            var descriptionFontSize = Math.round(LABEL_DESCRIPTION_FONT_SIZE * scaleX);

            // write title
            var getLines = function (context, text, maxWidth) {
                var words = text.split(' ');
                var line = '';
                var lines = [];

                for (var n = 0; n < words.length; n++) {
                    var testLine = line + words[n];
                    var metrics = context.measureText(testLine);
                    if (metrics.width > maxWidth && n > 0) {
                        lines.push(line);
                        line = words[n] + ' ';
                    } else {
                        line = testLine + ' ';
                    }
                }

                lines.push(line);
                return lines;
            };

            //Multi-line text drawing offset from leader line
            var renderText = function (text, fontSize, bold, startOffset) {
                var lineHeight = fontSize * 1.25;
                context.font = (bold ? "bold " : "") + fontSize + "px Arial";

                var lines = getLines(context, text || "", labelWidth);
                var startY = connectY + startOffset(lines, lineHeight);

                for (var i = 0; i < lines.length; i++) {
                    context.fillText(lines[i], labelX, startY + (lineHeight * i));
                }
            };

            renderText(label.title, titleFontSize, true, function (lines, lineHeight) {
                return -(lines.length - 1) * lineHeight - (lineHeight / 2);
            });
            // write description
            renderText(label.description, descriptionFontSize, false, function (lines, lineHeight) {
                return lineHeight;
            });

            //Draw wire (w/ title underline)
            // Need wire a bit more visible than pin
            var wireOpacity = pin.opacity;
            // +0.4;

            context.strokeStyle = "rgba(204, 204, 204, " + wireOpacity + ")";
            context.beginPath();

            context.moveTo(pinX, pinY);
            context.lineTo(connectX, connectY); //wire

            var underlineEnd = label.side === 'left' ? -labelWidth : labelWidth;
            context.lineTo(connectX + underlineEnd, connectY); //underline

            //context.closePath();
            context.stroke();
        }

        var drawCircle = function (radius, color, stroke) {
            context.fillStyle = color;
            context.beginPath();
            context.arc(pinX, pinY, radius, 0, 2 * Math.PI);
            context.fill();

            if (stroke) {
                stroke();
            }
        };

        var outerRadius = PIN_OUTER_RADIUS * scaleX;
        var innerRadius = PIN_INNER_RADIUS * scaleX;

        // draw pin
        drawCircle(outerRadius, 'rgb(255, 255, 255)', function () {
            context.lineWidth = 1;
            context.strokeStyle = 'rgb(204, 204, 204)';
            context.stroke();
        });
        drawCircle(innerRadius, 'rgb(153,0,0)');
    };

})();;/**
 * @namespace Annotation layout manager.
 *
 * <p>Strategies are plugged into this to provide various types of layout for annotation labels.</p>
 *
 * <p>The active layout is bound to the "annotation.layout.type" property.</p>
 */
(function () {
    "use strict";

    var HumanViewAnnotationsLayouts = Human.view.annotations.layouts = {};

    var layouts = {};
    var activeLayout;

    HumanViewAnnotationsLayouts.activeLayout = null;

    HumanViewAnnotationsLayouts.getLayout = function (layout) {
      return layouts[layout];
    };

    // Get annotation canvas when engine loaded
    Human.events.on(
        "loaded",
        function () {

            var canvas = Human.renderer.canvas.annotationCanvas[0];
            if (!canvas) {
                Human.log.error("Human.view.annotations.layouts", "DOM element not found: 'annotationCanvas'");
                return;
            }

            var context = canvas.getContext('2d');
            if (!context) {
                Human.log.error("Human.view.annotations.layouts", "Failed to get 2D canvas context");
                return;
            }

            // Select any layout required in configs
            Human.properties.subscribe({
                propId: "annotations.layout.type",
                value: "columns",  // HACK
                callback: function (value) {
                    //if (value != "") {
                        HumanViewAnnotationsLayouts._selectLayout(value);
                   // }
                }
            });

            // Update dirty layout on each renderer tick
            Human.events.on(
                "tick",
                function () {
                    if (activeLayout && canvas && context) {
                        activeLayout.layout(canvas, context);
                    }
                });
        });

    function layoutDirty() {
        if (activeLayout) {
            activeLayout.setDirty();
        }
    }

    // Layout dirty whenever camera moves
    Human.events.on(
        "camera.updated",
        function () {
            layoutDirty();
        });

    // Layout dirty whenever canvas resizes
     Human.events.on(
         "canvas.resized",
         function () {
            layoutDirty();
        });

    // Layout dirty whenever an annotation is created
    Human.events.on(
        "annotations.creating",
        function (params) {
            setLayoutEvents(params);
        });

    // Layout dirty whenever clip planes updated
    Human.events.on(
        "clip.updated",
        function () {
            layoutDirty();
        });

    // Layout dirty whenever scene object visibilities updated
    Human.events.on(
        "scene.objectsShown",
        function () {
            layoutDirty();
        });

    // Layout dirty whenever an annotation is loaded from a bookmark
    Human.events.on(
        "annotations.created",
        function (params) {
            setLayoutEvents(params);
        });

    var setLayoutEvents = function (params) {
        Human.events.onEvent("annotations.shown", layoutDirty);
        var annotation = Human.view.annotations.annotations[params.annotationId];
        annotation.on("object", layoutDirty);
        annotation.pin.on("enabled", layoutDirty);
        annotation.pin.on("shown", layoutDirty);
        annotation.label.on("shown", layoutDirty);
        annotation.label.on("edit", layoutDirty);
        annotation.label.on("saved", layoutDirty);
        annotation.label.on("cancel", layoutDirty);
        annotation.label.on("destroyed", layoutDirty);
        layoutDirty();
    };

    /**
     * Adds a layout strategy.
     * @param {String} type The layout type name
     * @param {{}} layout The layout strategy
     */
    HumanViewAnnotationsLayouts.addLayoutType = function (type, layout) {
        if (layouts[type]) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout already added: '" + type + "'");
            return;
        }
        if (!layout.setEnabled) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout strategy does not have a 'setEnabled' method");
            return;
        }
        if (!layout.setDirty) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout strategy does not have a 'setDirty' method");
            return;
        }
        if (!layout.layout) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout strategy does not have a 'layout' method");
            return;
        }
        layouts[type] = layout;
        if (!activeLayout) {
            HumanViewAnnotationsLayouts._selectLayout(type); // Select first added by default
        }
    };

    /**
     * Activates a layout type.
     * Bound to a config property (see above)
     * @param {String} type The layout type name
     * @private
     */
    HumanViewAnnotationsLayouts._selectLayout = function (type) {

        // HACK alias names - want to use "columns" instead of "columns-v2"
        if (type === "columns-v2") {
            type = "columns";
        }

        Human.log.info("Human.view.annotations.layouts._selectLayout", "Selecting label type: '" + type + "'");
        if (!layouts[type]) {
            Human.log.error("Human.view.annotations.layouts._selectLayout", "Layout not found: '" + type + "'");
            return;
        }
        if (activeLayout === type) {
            // Already active
            return;
        }
        if (activeLayout) {
            activeLayout.setEnabled(false);
        }
        activeLayout = layouts[type];
        activeLayout.setEnabled(true);
        activeLayout.setDirty();
        HumanViewAnnotationsLayouts.activeLayout = type;
    };

    /**
     * Redraw the active layout.
     */
    HumanViewAnnotationsLayouts.redrawLayout = layoutDirty;

})();;/**
 * @namespace Annotation layout strategy which lays the labels out in left and right columns
 */
Human.view.annotations.layouts.addLayoutType(
    "columns",

    (function () {
        "use strict";

        var HumanViewAnnotations = Human.view.annotations;
        var ColumsLayout = {};

        // Margins config
        var margins;

        Human.properties.subscribe({
            propId: "annotations.margins",
            value: {
                top: 50,
                left: 50,
                right: 50,
                bottom: 50
            },
            callback: function (value) {
                margins = value;
            }
        });

        // Width of labels
        var maxLabelWidth;

        Human.properties.subscribe({
            propId: "annotations.labelWidth",
            value: 150,
            callback: function (value) {
                maxLabelWidth = value;
            }
        });

        // Horizontal lines flag
        var horizontalLines = false;

        Human.properties.subscribe({
            propId: "annotations.horizontalLines",
            value: horizontalLines,
            callback: function (value) {
                horizontalLines = value;
                dirty = true;
            }
        });

        // Angle beyond which labels are occluded
        var occludedAngle = 100;

        // Angle beyond which labels are faded
        var fadeoutAngle = 80;

        var enabled = false;
        var dirty = true;

        var leftColumn = [];
        var lenLeftColumn = 0;
        var rightColumn = [];
        var lenRightColumn = 0;

        var layoutCanvasWidth;
        var layoutCanvasHeight;

        /** Notifies this layout that it's enabled
         *
         * @param {boolean} enable True to enable, else false
         */
        ColumsLayout.setEnabled = function (enable) {
            enabled = enable;
            dirty = true;
        };

        /** Notifies this layout that will need to rebuild itself
         */
        ColumsLayout.setDirty = function () {
            dirty = true;
        };

        /**
         * Refreshes this layout.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        ColumsLayout.layout = function (canvas, context) {

            if (!dirty) {
                return;
            }

            context.clearRect(0, 0, canvas.width, canvas.height);

            if (!HumanViewAnnotations.shown) {
                // Annotations globally hidden
                dirty = false;
                return;
            }

            lenLeftColumn = 0;
            lenRightColumn = 0;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var pin;
            var label;
            var left;

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();

            var boundary = getCanvasModelBoundary(canvas, context, viewMat, projMat);

            if (Human.request.getSearchParam("showBoundary")) {
                context.beginPath();
                context.rect(boundary.xmin, boundary.ymin, boundary.xmax - boundary.xmin, boundary.ymax - boundary.ymin);
                context.lineWidth = 2;
                context.strokeStyle = 'black';
                context.stroke();
            }

            // Assign annotations to left and right columns
            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    pin = annotation.pin;
                    label = annotation.label;

                    // Skip over hidden annotations

                    if (!pin.shown || !pin.enabled) {
                        continue;
                    }

                    if (!label.shown && !pin.shown) {
                        continue;
                    }

                    // Transform pin into View and Canvas space
                    pin.transform(viewMat, projMat, canvas);

                    // Test if pin is "hidden" on a backface, ie. pointing away from eye
                    var angle = getPinViewAngle(pin);

                    pin.setViewAngle(angle);

                    var occluded = angle < -occludedAngle || angle > occludedAngle;

                    pin.setOccluded(occluded);

                    var opacity;

                    if (angle >= fadeoutAngle) {
                        opacity = 1 - ((angle - fadeoutAngle) / (occludedAngle - fadeoutAngle));
                        if (opacity < 0) {
                            opacity = 0;
                        }
                    } else {
                        opacity = 1.0;
                    }

                    pin.setOpacity(opacity);
                    label.setOpacity(opacity);

                    // Cull pins outside canvas extents.
                    // For API user convenience, want to update cull status on all pins,
                    // including those not enabled and/or not shown
                    pin.cullToRectangle(margins.left, 0, canvas.width - margins.right - maxLabelWidth, canvas.height);

                    // Cull label in synch with pin
                    if (pin.culled !== label.culled) {
                        label.setCulled(pin.culled);
                    }

                    // Synch label with pin's occlusion status
                    if (pin.occluded !== label.occluded) {
                        label.setOccluded(pin.occluded);
                    }

                    // If label visible, add to left or right column
                    // Label is visible only if pin enabled, shown, not culled and label shown
                    if (pin.enabled && pin.shown && !pin.culled && !pin.occluded && label.shown) {
                        left = (annotation.pin.viewPos[0] < 0);
                        if (left) {
                            leftColumn[lenLeftColumn++] = annotation;
                        } else {
                            rightColumn[lenRightColumn++] = annotation;
                        }
                    }
                }
            }

            // Sort columns by pin positions on Y-axis
            sortColumn(leftColumn, lenLeftColumn);
            sortColumn(rightColumn, lenRightColumn);

            // Lay the columns out
            layoutColumn(canvas, context, boundary, leftColumn, lenLeftColumn, -1);
            layoutColumn(canvas, context, boundary, rightColumn, lenRightColumn, +1);

            // Retain canvas dimensions for when we might render to snapshot
            layoutCanvasWidth = canvas.width;
            layoutCanvasHeight = canvas.height;

            dirty = false;
        };

        var projPos = vec4.create();

        function getCanvasModelBoundary(canvas, context, viewMat, projMat) {

            // Get boundary of visible leaf objects

            var enabled = Human.scene.enabledObjects;
            var b;
            var worldBox;
            var worldPos;

            var x;
            var y;
            var w;

            var canvasBox = {
                xmin: Number.POSITIVE_INFINITY,
                ymin: Number.POSITIVE_INFINITY,
                xmax: Number.NEGATIVE_INFINITY,
                ymax: Number.NEGATIVE_INFINITY
            };

            for (var objectId in enabled) {
                if (enabled.hasOwnProperty(objectId)) {

                    var object = enabled[objectId];

                    if (object.numSubObjects === 0) {

                        b = object.getBoundary();

                        worldBox = [
                            [b.xmin, b.ymin, b.zmin],
                            [b.xmax, b.ymin, b.zmin],
                            [b.xmax, b.ymax, b.zmin],
                            [b.xmin, b.ymax, b.zmin],
                            [b.xmin, b.ymin, b.zmax],
                            [b.xmax, b.ymin, b.zmax],
                            [b.xmax, b.ymax, b.zmax],
                            [b.xmin, b.ymax, b.zmax]
                        ];

                        for (var i = 0; i < 8; i++) {

                            worldPos = worldBox[i];

                            vec3.transformMat4(projPos, worldBox[i], viewMat);

                            if (projPos[2] > 0.1) {

                                // Skip points that are outside the front clip plane

                                continue;
                            }

                            projPos[3] = 1; // Need homogeneous 'w' for perspective division

                            vec4.transformMat4(projPos, projPos, projMat);

                            x = projPos[0];
                            y = projPos[1];
                            w = projPos[3];

                            x = (1 + x / w) * canvas.width / 2;
                            y = (1 - y / w) * canvas.height / 2;

                            if (x < 0 || y < 0 || x > canvas.width || y > canvas.height) {

                                // Skip points that project off the canvas

                                continue;
                            }

                            if (canvasBox.xmin > x) {
                                canvasBox.xmin = x;
                            }

                            if (canvasBox.ymin > y) {
                                canvasBox.ymin = y;
                            }

                            if (canvasBox.xmax < x) {
                                canvasBox.xmax = x;
                            }

                            if (canvasBox.ymax < y) {
                                canvasBox.ymax = y;
                            }
                        }
                    }
                }
            }

            return canvasBox;
        }


        var eyeVec = vec3.create();

        function getPinViewAngle(pin) {
            var eyePos = Human.view.camera.eye;

            eyeVec[0] = eyePos.x;
            eyeVec[1] = eyePos.y;
            eyeVec[2] = eyePos.z;

            vec3.subtract(eyeVec, eyeVec, pin.pos);
            var dot = vec3.dot(eyeVec, pin.dir);
            var lenEyeVec = vec3.length(eyeVec);
            var lenPinVec = vec3.length(pin.dir);
            var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
            return angle;
        }

        function sortColumn(column, len) { // Faster than native JS sort - no callback and less GC
            var temp;
            var min;
            for (var out = 0; out < len - 1; out++) {
                min = out;
                for (var inn = out; inn < len; inn++) {
                    if (column[inn].pin.canvasPos[1] < column[min].pin.canvasPos[1]) { //If max greater => new max
                        min = inn;
                    }
                }
                temp = column[out];
                column[out] = column[min];
                column[min] = temp;
            }
        }

        function layoutColumn(canvas, context, boundary, column, len, side) {
            // Find X position as the closest point possible to the model's
            // current canvas-space boundary, clamped to margins
            var x = (side < 0) ?
                Math.max(margins.left, boundary.xmin - maxLabelWidth - 50) :
                Math.min(canvas.width - margins.right - maxLabelWidth, boundary.xmax);

            var topMargin = Math.max(margins.top, boundary.ymin);
            var bottomMargin = Math.min(margins.bottom, boundary.ymax);
            var y = topMargin;
            var yRange = canvas.height - topMargin - bottomMargin;
            var yInc = yRange / len;
            var annotation;
            var pin, label, wire;

            for (var i = 0; i < len; i++) {
                annotation = column[i];

                pin = annotation.pin;
                label = annotation.label;
                wire = annotation.wire;

                // Draw wire
                var pinX = pin.canvasPos[0];
                var pinY = pin.canvasPos[1];

                // Position the label
                label.setPos([x, horizontalLines ? pinY : y], horizontalLines);
                //sets side & connectionPoint relative to position
                label.setSide(side < 0 ? 'left' : 'right');

                var connection = label.connectionPoint;

                var wireLength = Math.sqrt((Math.pow(connection[0] - pinX, 2) + Math.pow(connection[1] - pinY, 2)));

                var wireAngle;

                if (horizontalLines) {
                    wireAngle = side < 0 ? 0 : 180;
                } else {
                    wireAngle = Math.atan2(pinY - connection[1], pinX - connection[0]) * 180 / Math.PI;
                }

                wire.css({
                    width: wireLength + 'px',
                    left: connection[0] + 'px',
                    top: connection[1] + 'px',
                    opacity: pin.opacity,

                    '-webkit-transform': 'rotate(' + wireAngle + 'deg)',
                    '-moz-transform': 'rotate(' + wireAngle + 'deg)',
                    '-ms-transform': 'rotate(' + wireAngle + 'deg)',
                    '-o-transform': 'rotate(' + wireAngle + 'deg)',
                    transform: 'rotate(' + wireAngle + 'deg)'
                });

                y += yInc;
            }
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        ColumsLayout.snapshot = function (canvas, context, bgColor) {

            if (!HumanViewAnnotations.shown) {
                // Annotations globally hidden
                return;
            }

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates
            //from layout canvas to snapshot canvas
            var scaleX = snapshotCanvasWidth / layoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / layoutCanvasHeight;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    if (annotation.pin.enabled && !annotation.pin.occluded) {

                        label = annotation.label;

                        if (label.shown) {
                            HumanViewAnnotations.renderer.render({
                                annotation: annotation,
                                canvasData: canvasData,
                                bgColor: bgColor
                            });
                        }
                    }
                }
            }
        };

        return ColumsLayout;
    })());
;/**
 * @namespace Annotation layout strategy which arranges the labels on wires that radiate outwards.
 */
Human.view.annotations.layouts.addLayoutType(
    "radial",

    (function () {
        "use strict";

        var HumanViewAnnotations = Human.view.annotations;
        var RadialLayout = {};

        // Gap between edge of canvas and labels
        var labelMargins = 100;

        // Width of labels
        var labelWidth = 200;

        var enabled = false;
        var dirty = true;

        var leftColumn = [];
        var lenLeftColumn = 0;
        var rightColumn = [];
        var lenRightColumn = 0;

        var layoutCanvasWidth;
        var layoutCanvasHeight;


        /** Notifies this layout that it's enabled
         *
         * @param {boolean} enable True to enable, else false
         */
        RadialLayout.setEnabled = function (enable) {
            enabled = enable;
            dirty = true;
        };

        /** Notifies this layout that will need to rebuild itself
         */
        RadialLayout.setDirty = function () {
            dirty = true;
        };

        /**
         * Refreshes this layout.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        RadialLayout.layout = function (canvas, context) {

            if (!dirty) {
                return;
            }

            lenLeftColumn = 0;
            lenRightColumn = 0;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var pin;
            var label;
            var left;

            // Assign annotations to left and right columns
            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    pin = annotation.pin;
                    label = annotation.label;

                    // Cull pins outside canvas extents.
                    // For API user convenience, want to update cull status on all pins,
                    // including those not enabled and/or not shown
                    pin.cullToRectangle(0, 0, canvas.width, canvas.height);

                    // Cull label with pin
                    if (pin.culled !== label.culled) {
                        label.setCulled(pin.culled);
                    }

                    // If label visible, add to left or right column
                    // Label is visible only if pin enabled, shown, not culled and label shown
                    if (pin.enabled && pin.shown && !pin.culled && label.shown) {
                        if (annotation.pin.viewPos) { // Might not have been obtained (ie. pin rendered) yet
                            left = (annotation.pin.viewPos[0] < 0);
                            if (left) {
                                leftColumn[lenLeftColumn++] = annotation;
                            } else {
                                rightColumn[lenRightColumn++] = annotation;
                            }
                        }
                    }
                }
            }

            // Sort columns by pin positions on Y-axis
            sortColumn(leftColumn, lenLeftColumn);
            sortColumn(rightColumn, lenRightColumn);

            context.clearRect(0, 0, canvas.width, canvas.height);

            // Lay the columns out
            layoutColumn(canvas, context, leftColumn, lenLeftColumn, labelMargins);
            layoutColumn(canvas, context, rightColumn, lenRightColumn, canvas.width - labelMargins - labelWidth);

            // Retain canvas dimensions for when we might render to snapshot
            layoutCanvasWidth = canvas.width;
            layoutCanvasHeight = canvas.height;

            dirty = false;
        };

        function sortColumn(column, len) { // Faster than native JS sort - no callback and less GC
            var temp;
            var min;
            for (var out = 0; out < len - 1; out++) {
                min = out;
                for (var inn = out; inn < len; inn++) {
                    if (column[inn].pin.pos[1] > column[min].pin.pos[1]) { //If max greater => new max
                        min = inn;
                    }
                }
                temp = column[out];
                column[out] = column[min];
                column[min] = temp;
            }
        }

        function layoutColumn(canvas, context, column, len, x) {
            var canvasHalfX = canvas.width / 2.0;
            var yRange = canvas.height;
            var yInc = yRange / len;
            var y = 50;
            var annotation;
            var pin;

            var label;
            for (var i = 0; i < len; i++) {
                annotation = column[i];
                pin = annotation.pin;
                label = annotation.label;

                // Position the label
                label.setPos([x, y]);

                // Draw wire
                context.strokeStyle = "rgb(0, 0, 100)";
                context.beginPath();
                context.moveTo(pin.canvasPos[0], pin.canvasPos[1]);
                if (x < canvasHalfX) {
                    context.lineTo(x + label.getWidth(), y);
                } else {
                    context.lineTo(x, y);
                }
                context.closePath();
                context.stroke();

                y += yInc;
            }
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        RadialLayout.snapshot = function (canvas, context) {

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates 
            //from layout canvas to snapshot canvas
            var scaleX = snapshotCanvasWidth / layoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / layoutCanvasHeight;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    if (annotation.pin.enabled) {

                        label = annotation.label;

                        if (label.shown) {
                            HumanViewAnnotations.renderer.render({
                                annotation: annotation,
                                canvasData: canvasData
                            });
                        }
                    }
                }
            }
        };

        return RadialLayout;
    })());
;/**
 * @namespace Annotation layout strategy which floats the labels directly over their pin positions
 */
Human.view.annotations.layouts.addLayoutType(
    "floating",

    (function () {
        "use strict";

        var HumanViewAnnotations = Human.view.annotations;
        var FloatingLayout = {};

        // Width of labels
        var maxLabelWidth;

        Human.properties.subscribe({
            propId: "annotations.labelWidth",
            value: 120,
            callback: function (value) {
                maxLabelWidth = value;
            }
        });

        var enabled = false;
        var dirty = true;

        var layoutCanvasWidth;
        var layoutCanvasHeight;

        // Angle at which to decide whether or not a pin is occluded
        var occludedPinAngle = 90;

        /** Notifies this layout that it's enabled
         *
         * @param {boolean} enable True to enable, else false
         */
        FloatingLayout.setEnabled = function (enable) {
            enabled = enable;
            dirty = true;
        };

        /** Notifies this layout that will need to rebuild itself
         */
        FloatingLayout.setDirty = function () {
            dirty = true;
        };

        /**
         * Refreshes this layout.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        FloatingLayout.layout = function (canvas) {

            if (!dirty) {
                return;
            }

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var pin;
            var label;

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    pin = annotation.pin;
                    label = annotation.label;

                    // Transform pin into View and Canvas space
                    pin.transform(viewMat, projMat, canvas);

                    // Test if pin is "hidden" on a backface, ie. pointing away from eye
                    var angle = getPinViewAngle(pin);
                    pin.setViewAngle(angle);
                    var occluded = angle < -90 || angle > 90;
                    pin.setOccluded(occluded);

                    // Set translucency in proportion to
                    // how much pin points away from eye
                    var opacity = ((0 - 1) * (angle - 0)) / (occludedPinAngle - 0) + 1;
                    if (opacity < 0) {
                        opacity = 0;
                    }
                    pin.setOpacity(opacity);
                    label.setOpacity(opacity + 0.5);

                    // Cull pins outside canvas extents.
                    // For API user convenience, want to update cull status
                    // on all pins, including those not enabled and/or not shown
                    pin.cullToRectangle(0, 0, canvas.width, canvas.height);

                    // Cull label in synch with pin
                    if (pin.culled !== label.culled) {
                        label.setCulled(pin.culled);
                    }

                    // Synch label with pin's occlusion status
                    if (pin.occluded !== label.occluded) {
                        label.setOccluded(pin.occluded);
                    }

                    // Position label is shown
                    // Label is visible only if pin enabled, shown, not culled and label shown
                    if (pin.enabled && pin.shown && !pin.culled && !pin.occluded && label.shown) {
                        label.setPos(pin.canvasPos);
                    }
                }
            }

            // Save canvas dimensions for snapshots
            layoutCanvasWidth = canvas.width;
            layoutCanvasHeight = canvas.height;

            dirty = false;
        };

        var eyeVec = vec3.create();

        function getPinViewAngle(pin) {
            var eyePos = Human.view.camera.eye;

            eyeVec[0] = eyePos.x;
            eyeVec[1] = eyePos.y;
            eyeVec[2] = eyePos.z;

            vec3.subtract(eyeVec, eyeVec, pin.pos);
            var dot = vec3.dot(eyeVec, pin.dir);
            var lenEyeVec = vec3.length(eyeVec);
            var lenPinVec = vec3.length(pin.dir);
            var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
            return angle;
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        FloatingLayout.snapshot = function (canvas, context) {

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates
            //from layout canvas to snapshot canvas
            var scaleX = snapshotCanvasWidth / layoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / layoutCanvasHeight;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    if (annotation.pin.enabled && !annotation.pin.occluded) {
                        label = annotation.label;
                        if (label.shown) {
                            HumanViewAnnotations.renderer.render({
                                annotation: annotation,
                                canvasData: canvasData
                            });
                        }
                    }
                }
            }
        };

        return FloatingLayout;
    })());
;/**
 * @namespace Annotation layout strategy which lays the labels out in left and right columns
 */
Human.view.annotations.layouts.addLayoutType(
    "draggable",

    (function () {
        "use strict";

        var HumanViewAnnotations = Human.view.annotations;
        var Layout = {};

        // Margins config
        var margins;

        Human.properties.subscribe({
            propId: "annotations.margins",
            value: {
                top: 50,
                left: 50,
                right: 50,
                bottom: 50
            },
            callback: function (value) {
                margins = value;
            }
        });

        // Angle beyond which labels are occluded
        var occludedAngle = 100;

        // Angle beyond which labels are faded
        var fadeoutAngle = 80;

        // True when this layout strategy is enabled
        var enabled = false;

        // True when the whole layout needs to be rebuilt
        var dirty = true;

        // Set to an annotation when we just need to update the layout of that annotation label
        var dirtyAnnotation = null;

        // Save canvas dimensions after doing each layout,
        // Used when rendering the snapshot, which is always preceded by a layout.

        var lastLayoutCanvasWidth;
        var lastLayoutCanvasHeight;


        /** Notifies this layout that it's enabled
         *
         * @param {Boolean} enable True to enable, else false
         */
        Layout.setEnabled = function (enable) {

            enabled = enable;

            dirty = true;
        };


        // Annotation label drag behaviours

        (function () {

            // Annotation who's label we're currently dragging
            var annotation;

            // Previous mouse position while dragging
            var lastX = -1;
            var lastY = -1;


            Human.events.on("annotations.mouseDown",
                function (params) {

                    if (!enabled) {
                        return;
                    }

                    annotation = HumanViewAnnotations.annotations[params.annotationId];

                    lastX = params.x;
                    lastY = params.y;
                });

            $('body').mousemove(
                function (e) {

                    if (!enabled) {
                        return;
                    }

                    if (annotation) {

                        var x = e.clientX;
                        var y = e.clientY;

                        var offset = annotation.label.offset;

                        annotation.label.setOffset([
                            offset[0] + x - lastX,
                            offset[1] + y - lastY
                        ]);

                        lastX = x;
                        lastY = y;

                        dirtyAnnotation = annotation;
                    }
                });

            $('body').mouseup(
                function () {

                    if (!enabled) {
                        return;
                    }

                    annotation = null;
                });
        })();


        /**
         * Indicate that layout needs to be rebuilt
         */
        Layout.setDirty = function () {
            dirty = true;
        };

        Layout.layout = (function() {
            
            var lastMinimal = false;
            
            return function (canvas) {
                if (HumanViewAnnotations.getMinimalActive()) {
                    Layout._minimalLayout.doLayout(canvas);
                    lastMinimal = true;
                } else {
                    if (lastMinimal) {
                        Layout._minimalLayout.cleanup(); // ie. Hide the single label
                        lastMinimal = false;
                    }
                    Layout._normalLayout.doLayout(canvas);
                }
            };
        })();

        Layout._minimalLayout = new (function () {

            var openAnnotationId = null;
            var queryAnnotations = [];

            var label = $([
                '<div id="singleAnnotation" class="annotationContainer">',
                '<div class="annotationTitle clearfix">', //holds title elements
                '<input type="text" placeholder="">',
                '<h1></h1>',
                '<button id="closeSingleAnnotation" class="annotationDelete" style="visibility: visible;"></button>',
                '</div>',
                '<div class="annotationDescription">', //holds descriptions elements
                '<textarea placeholder=""></textarea>',
                '<p></p>',
                '</div>',
                '<div class="embedContainer"></div>',
                '</div>'
            ].join(''));

            label.appendTo(document.body);
            label.hide();

            var labelTitle = label.find('h1');
            var labelDesc = label.find('p');
            var closeButton = label.find("#closeSingleAnnotation");

            closeButton.click(hideLabel);

            function setLabelPos(canvasPos) {
                label.css({left: canvasPos[0] + 'px', top: canvasPos[1] + 'px'});
            }

            function populateLabel(title, desc) {
                labelTitle.html(title);
                labelDesc.html(desc);
            }

            function showLabel() {
                label.show();
                setLabelPos([20, 20]);
            }

            function hideLabel() {
                label.hide();
            }

            // Show single label when a pin clicked in minimal mode.
            // Hide label when that pin is clicked again.
            Human.events.onEvent("annotations.picked", function (e) {
                if (!HumanViewAnnotations.getMinimalActive()) {
                    return;
                }
                if (openAnnotationId === e.annotationId) {
                    hideLabel();
                    openAnnotationId = null;
                    return;
                }
                openAnnotationId = e.annotationId;
                var annotation = HumanViewAnnotations.annotations[openAnnotationId];
                var label = annotation.label;
                populateLabel(label.title, label.description);
                showLabel();
            });

            // Hide single label when exiting minimal mode by expanding the canvas
            Human.events.on("canvas.resized", function() {
                if (!HumanViewAnnotations.getMinimalActive()) {
                    if (openAnnotationId) {
                        hideLabel();
                        openAnnotationId = null;
                    }
                }
            });

            // Hide single label when it belongs to annotation that's destroyed
            Human.events.onEvent("annotations.destroyed", function (e) {
                if (openAnnotationId === e.annotationId) {
                    openAnnotationId = null;
                    hideLabel();
                }
                // dirty = true;
            });

            var getPinViewAngle = (function () {

                var eyeVec = vec3.create();

                return function (pin) {
                    var eyePos = Human.view.camera.eye;
                    vec3.subtract(eyeVec, [eyePos.x, eyePos.y, eyePos.z], pin.pos);
                    var dot = vec3.dot(eyeVec, pin.dir);
                    var lenEyeVec = vec3.length(eyeVec);
                    var lenPinVec = vec3.length(pin.dir);
                    var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
                    return angle;
                };
            })();

            this.cleanup = function() {
                hideLabel();    
            };
            
            this.doLayout = function (canvas) {

                if (!dirty && !dirtyAnnotation) {

                    // Rebuild not needed
                    return;
                }

                var viewMat = Human.renderer.getViewMat();
                var projMat = Human.renderer.getProjMat();
                var annotations, annotation, annotationId;
                queryAnnotations.length = 0;

                if (dirty) {

                    annotations = HumanViewAnnotations.annotations;

                    // Refresh layout for all annotations

                    if (!HumanViewAnnotations.shown) {

                        // Annotations are currently globally hidden
                        dirty = false;
                        return;
                    }

                    // Update states of all annotations

                    for (annotationId in annotations) {
                        if (annotations.hasOwnProperty(annotationId)) {

                            annotation = annotations[annotationId];

                            if (layoutAnnotation(annotation, viewMat, projMat, canvas)) {

                                if (annotation.occludable) {

                                    // Schedule an occlusion query for pin position

                                    queryAnnotations.push(annotation);

                                } else {
                                    renderAnnotation(annotation);
                                }
                            }
                        }
                    }

                    // Save canvas dimensions after doing each layout,
                    // Used when rendering the snapshot, which is always preceded by a layout.

                    lastLayoutCanvasWidth = canvas.width;
                    lastLayoutCanvasHeight = canvas.height;

                    dirty = false;

                } else {

                    // Refresh layout for a single annotation

                    annotations = {};
                    annotations[dirtyAnnotation.annotationId] = dirtyAnnotation;

                    if (layoutAnnotation(dirtyAnnotation, viewMat, projMat, canvas)) {

                        // Schedule an occlusion query for pin position

                        if (dirtyAnnotation.occludable) {

                            // Schedule an occlusion query for pin position

                            queryAnnotations.push(dirtyAnnotation);
                        } else {
                            renderAnnotation(dirtyAnnotation);
                        }
                    }

                    dirtyAnnotation = null;
                }

                // Do occlusion query

                HumanViewAnnotations.occlusionQuery.runQuery(queryAnnotations, renderAnnotation);
            };

            function layoutAnnotation(annotation, viewMat, projMat, canvas) {

                var pin = annotation.pin;
                var canvasHeight = canvas.height;
                var canvasWidth = canvas.width;

                if (!pin.shown || !pin.enabled) {
                    return;
                }

                pin.transform(viewMat, projMat, canvas);

                var angle = getPinViewAngle(pin);

                pin.setViewAngle(angle);

                var opacity;

                if (angle >= fadeoutAngle) {
                    opacity = 1 - ((angle - fadeoutAngle) / (occludedAngle - fadeoutAngle));
                    if (opacity < 0) {
                        opacity = 0;
                    }
                } else {
                    opacity = 1.0;
                }

                pin.setOpacity(opacity);
                pin.cullToRectangle(margins.left, 0, canvasWidth - margins.right, canvasHeight);

                if (pin.culled) {
                    return false;
                }

                return true;
            }

            function renderAnnotation(annotation) {
                if (annotation.id === openAnnotationId) {
                    showLabel();
                }
            }

        })();

        Layout._normalLayout = new (function () {

            var queryAnnotations = [];

            var getPinViewAngle = (function () {

                var eyeVec = vec3.create();

                return function (pin) {
                    var eyePos = Human.view.camera.eye;
                    vec3.subtract(eyeVec, [eyePos.x, eyePos.y, eyePos.z], pin.pos);
                    var dot = vec3.dot(eyeVec, pin.dir);
                    var lenEyeVec = vec3.length(eyeVec);
                    var lenPinVec = vec3.length(pin.dir);
                    var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
                    return angle;
                };
            })();

            function layoutAnnotation(annotation, viewMat, projMat, canvas) {

                var pin = annotation.pin;
                var label = annotation.label;

                var canvasHeight = canvas.height;
                var canvasWidth = canvas.width;


                // Skip over hidden annotations

                if (!pin.shown || !pin.enabled) {

                    // Label pin not shown, skip annotation
                    return;
                }

                if (!pin.shown) {

                    // Label and pin not shown, skip annotation
                    return;
                }

                // Transform annotation pin position by view and projection transforms
                pin.transform(viewMat, projMat, canvas);

                // Get angle between pin and eye vector
                var angle = getPinViewAngle(pin);

                pin.setViewAngle(angle);

                // Set annotation opacity according to the pin-eye angle
                var opacity;

                if (angle >= fadeoutAngle) {
                    opacity = 1 - ((angle - fadeoutAngle) / (occludedAngle - fadeoutAngle));
                    if (opacity < 0) {
                        opacity = 0;
                    }
                } else {
                    opacity = 1.0;
                }

                pin.setOpacity(opacity);
                label.setOpacity(opacity);

                // Clip pins outside canvas extents.
                // For API user convenience, we update the cull status
                // on ALL pins including those not enabled and/or not shown

                pin.cullToRectangle(margins.left, 0, canvasWidth - margins.right, canvasHeight);

                // Cull label in synch with pin
                if (pin.culled !== label.culled) {
                    label.setCulled(pin.culled);
                }

                if (pin.culled) {

                    // Pin outside canvas, so now culled
                    return false;
                }

                return true;
            }

            function renderAnnotation(annotation) {

                var pin = annotation.pin;
                var label = annotation.label;
                var wire = annotation.wire;

                var wirePos1 = pin.canvasPos;

                var side = (label.offset[0] < 0);

                var labelPos = [wirePos1[0] + label.offset[0], wirePos1[1] + label.offset[1]];

                if (side) {
                    // Wire attaches to right side,
                    // shift label to the left to accommodate
                    labelPos[0] -= label.getWidth();
                }

                label.setPos(labelPos);

                // Sets side & connectionPoint relative to position
                label.setSide(side ? 'left' : 'right');

                var connection = label.connectionPoint;

                var wireLength = Math.sqrt((Math.pow(connection[0] - wirePos1[0], 2) + Math.pow(connection[1] - wirePos1[1], 2)));

                var wireAngle;

                wireAngle = Math.atan2(connection[1] - wirePos1[1], connection[0] - wirePos1[0]) * 180 / Math.PI;

                // Position the wire
                wire.css({
                    width: wireLength + 'px',
                    left: wirePos1[0] + 'px',
                    top: wirePos1[1] + 'px',
                    opacity: pin.opacity,

                    '-webkit-transform': 'rotate(' + wireAngle + 'deg)',
                    '-moz-transform': 'rotate(' + wireAngle + 'deg)',
                    '-ms-transform': 'rotate(' + wireAngle + 'deg)',
                    '-o-transform': 'rotate(' + wireAngle + 'deg)',
                    transform: 'rotate(' + wireAngle + 'deg)'
                });
            }

            this.doLayout = function (canvas) {

                if (!dirty && !dirtyAnnotation) {

                    // Rebuild not needed
                    return;
                }

                var viewMat = Human.renderer.getViewMat();
                var projMat = Human.renderer.getProjMat();
                var annotations, annotation, annotationId;
                queryAnnotations.length = 0;

                if (dirty) {

                    annotations = HumanViewAnnotations.annotations;

                    // Refresh layout for all annotations

                    if (!HumanViewAnnotations.shown) {

                        // Annotations are currently globally hidden
                        dirty = false;
                        return;
                    }

                    // Update states of all annotations

                    for (annotationId in annotations) {
                        if (annotations.hasOwnProperty(annotationId)) {

                            annotation = annotations[annotationId];

                            if (layoutAnnotation(annotation, viewMat, projMat, canvas)) {

                                if (annotation.occludable) {

                                    // Schedule an occlusion query for pin position

                                    queryAnnotations.push(annotation);

                                } else {
                                    renderAnnotation(annotation);
                                }
                            }
                        }
                    }

                    // Save canvas dimensions after doing each layout,
                    // Used when rendering the snapshot, which is always preceded by a layout.

                    lastLayoutCanvasWidth = canvas.width;
                    lastLayoutCanvasHeight = canvas.height;

                    dirty = false;

                } else {

                    // Refresh layout for a single annotation

                    annotations = {};
                    annotations[dirtyAnnotation.annotationId] = dirtyAnnotation;

                    if (layoutAnnotation(dirtyAnnotation, viewMat, projMat, canvas)) {

                        // Schedule an occlusion query for pin position

                        if (dirtyAnnotation.occludable) {

                            // Schedule an occlusion query for pin position

                            queryAnnotations.push(dirtyAnnotation);
                        } else {
                            renderAnnotation(dirtyAnnotation);
                        }
                    }

                    dirtyAnnotation = null;
                }

                // Do occlusion query

                HumanViewAnnotations.occlusionQuery.runQuery(queryAnnotations, renderAnnotation);
            };
        })();

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * Renders the annotations that are visible and not occluded.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        Layout.snapshot = function (canvas, context, bgColor) {

            if (!HumanViewAnnotations.shown) {
                // Annotations globally hidden
                return;
            }

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates
            //from layout canvas to snapshot canvas

            var scaleX = snapshotCanvasWidth / lastLayoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / lastLayoutCanvasHeight;

            var annotations = HumanViewAnnotations.annotations;
            var annotation;
            var pin;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {

                    annotation = annotations[annotationId];
                    pin = annotation.pin;

                    if (pin.enabled && pin.shown && !pin.occluded) {

                        // Render annotation pins even if labels are hidden

                        HumanViewAnnotations.renderer.render({
                            annotation: annotation,
                            canvasData: canvasData,
                            bgColor: bgColor
                        });
                    }
                }
            }
        };

        return Layout;

    })());
;/**
 * @namespace Activates "draggable" layout manager whenever possible
 */
(function () {
    "use strict";

    Human.events.on("bookmarks.restored", tryActivateDraggable);

    Human.events.on("modules.activated", tryActivateDraggable);

    Human.events.on("modules.deactivated", tryActivateDraggable);

    function tryActivateDraggable(evt) {
        if (moduleAnnotationsLayoutSet(Human.modules.modules[evt.moduleId])) {
            return;
        }

        var layout = canActivateDraggable() ? "draggable": "columns-v2";
        Human.properties.set({ "annotations.layout.type": layout });
    }

    function canActivateDraggable() {
      /*
      annotations are draggable if they have a labelOffset property, and not otherwise.
      */
        var annotations = Human.view.annotations.annotations;
        var chapters = Human.timeline.chapters;
        var annotationId;
        var chapterId;
        for (annotationId in annotations) {
            if (annotations.hasOwnProperty(annotationId)) {
                if (!annotations[annotationId].draggable) {
                    return false;
                }
            }
        }
        for (chapterId in chapters) {
            if (chapters.hasOwnProperty(chapterId)) {
                annotations = chapters[chapterId].annotations || {};
                for (annotationId in annotations) {
                    if (annotations.hasOwnProperty(annotationId)) {
                        if (!annotations[annotationId].draggable) {
                            return false;
                        }
                    }
                }
            }
        }
        // check activeRoot._chapters
        var result = true;
        if (!!Human.timeline.activeRoot){
          Human.timeline.activeRoot._chapters.forEach(function(chapter){
            var annotation;
            var annotationIdx;
            for (annotationIdx=0; annotationIdx < chapter.annotations.length; annotationIdx++){
              annotation = chapter.annotations[annotationIdx];
              if (!annotation.hasOwnProperty("labelOffset")){
                result = false;
              }
            }
          });
        }
        
        return result;
    }

    function moduleAnnotationsLayoutSet(module) {
        if (!module) {
            return false;
        }
        if (module.annotationsLayout) {
            return true;
        }
        if (module.properties && module.properties["annotations.layout.type"]) {
            return true;
        }
        return false;
    }

})();
;/**
 @namespace tests if annotations atr occluded by objects in the 3D scene.

 <pre>

 // First register some positions with the query:

 var query = Human.view.annotations.occlusionQuery;

 query.clear();

 query.addAnnotation( Human.view.annotations.annotations["a1"] );
 query.addAnnotation( Human.view.annotations.annotations["a2"] );
 query.addAnnotation( Human.view.annotations.annotations["a3"] );
 query.addAnnotation( Human.view.annotations.annotations["a4"] );

 // Run a query to update the occlusion status of the annotations:

 query.doQuery();

 // Log the new occlusion status of each annotation:

 var result;

 for (var i = 0; i < query.lenResult; i++) {

        result = query.result[i];

        annotation = result.annotation;

        if (!result.occluded) {

                // Visible

        } else {
                // Occluded
        }
  }

 </pre>

 */
(function () {

    "use strict";

    var OcclusionQuery = Human.view.annotations.occlusionQuery = {};

    // SceneJS node where we keep 3D position indicators
    var rootNode;
    var canvas;

    // Points to query occlusion status of. These are added
    // with #addAnnotation and cleared after each call to #doQuery
    var points = [];
    var numPoints = 0;

    /**
     * Results of the last occlusion query.
     * @type {Array}
     */
    OcclusionQuery.result = [];

    /**
     * Number of query results.
     * @type {number}
     */
    OcclusionQuery.lenResult = 0;


    // Once the 3D scene is ready, get the scene node
    // where we'll graft the 3D spheres

    Human.events.on("loaded",
        function () {
            rootNode = Human.renderer.getNode("occlusionIndicators");
            canvas = Human.renderer.canvas.canvas[0];
        });

    // Angle beyond which labels are occluded
    var occludedAngle = 100;

    var TICKS_PER_QUERY = 6;

    var dirty = true;
    var ticks = TICKS_PER_QUERY;

    var queryAnnotations = [];
    var renderCallback = null;
    var viewMat, projMat;
    var canvasWidth, canvasHeight;

    Human.events.on("tick", function() {
        ticks++;
        if (dirty && ticks >= TICKS_PER_QUERY && queryAnnotations.length > 0) {
            viewMat = Human.renderer.getViewMat();
            projMat = Human.renderer.getProjMat();
            canvasWidth = canvas.width;
            canvasHeight = canvas.height;
            _runQuery();
            dirty = false;
            ticks = 0;
        }
    });

    OcclusionQuery.runQuery = function(annotations, render) {
        queryAnnotations = annotations || [];
        renderCallback = render || null;
        dirty = true;

        queryAnnotations.forEach(function(annotation) {
            if (!annotation.pin.occluded) {
                renderCallback(annotation);
            }
        });
    };

    function _runQuery() {
        var i, len;

        OcclusionQuery.clear();

        for (i = 0, len = queryAnnotations.length; i < len; i++) {
            OcclusionQuery.addAnnotation(queryAnnotations[i]);
        }

        OcclusionQuery.doQuery();

        var annotations = Human.view.annotations.annotations;
        var result = OcclusionQuery.result;
        var lenResult = OcclusionQuery.lenResult;
        var annotation, pin, label, r;

        for (i = 0; i < lenResult; i++) {
            r = result[i];
            annotation = annotations[r.annotationId];
            pin = annotation.pin;
            label = annotation.label;
            if (r.occluded) {
                pin.setOccluded(true);
                label.setOccluded(true);

            } else {
                pin.setOccluded(false);
                label.setOccluded(false);

                if (renderCallback) {
                    renderCallback(annotation);
                }
            }
        }
    }



    /**
     * Clears occlusion query results.
     */
    OcclusionQuery.clear = function () {

        for (var i = 0; i < numPoints; i++) {
            points[i].point.setShown(false);
        }

        numPoints = 0;
    };

    /**
     * Adds an annotation to include in the occlusion query.
     *
     * The next call to #doQuery will perform an occlusion query for each
     * annotation that was added by this method, and will put the results
     * for each annotation in the #results array.
     *
     * The annotation will be forgotten after the next #doQuery call.
     *
     * @returns {*}
     */

    var cameraPos = vec3.create();
    var worldPos = vec3.create();
    var offset = vec3.create();
    var canvasPos = vec2.create();

    OcclusionQuery.addAnnotation = function (annotation) {

        var pin = annotation.pin;
        var label = annotation.label;

        // Get angle between pin and eye vector
        var angle = getPinViewAngle(pin);

        pin.setViewAngle(angle);

        // Pin is occluded when it points away from the eye
        var occluded = angle < -occludedAngle || angle > occludedAngle;

        pin.setOccluded(occluded);

        if (pin.occluded !== label.occluded) {
            label.setOccluded(occluded);
        }

        if (occluded) {
            return;
        }

        var object = annotation.object;
        var eye = Human.view.camera.eye;
        var clipping = (object && !object.clippable) ? false : true;

        worldPos.set(pin.pos);

        cameraPos[0] = eye.x;
        cameraPos[1] = eye.y;
        cameraPos[2] = eye.z;

        vec3.subtract(offset, cameraPos, worldPos);
        var l = vec3.length(offset);
        vec3.normalize(offset, offset);
        vec3.scale(offset, offset, Math.min(l * 0.1, 0.5));
        vec3.add(worldPos, worldPos, offset);

        world2Canvas(worldPos, viewMat, projMat, canvasWidth, canvasHeight, canvasPos);

        // Register annotation for query

        var point = points[numPoints] || (points[numPoints] = {

                // Inputs canvas coordinates
                x: 0, y: 0,

                // Outputs pixel color at the given coordinates
                r: 0, g: 0, b: 0, a: 0,

                // Sphere for occlusion point in 3D view
                point: new Point(),

                // True when occluded
                occluded: false
            });

        point.annotation = annotation;

        point.x = canvasPos[0];
        point.y = canvasPos[1];

        point.point.setWorldPos(worldPos);

        point.point.setShown(true);

        point.point.setClipping(clipping);

        // Reset query result for the annotation

        var result = OcclusionQuery.result[numPoints] || (OcclusionQuery.result[numPoints] = {
                annotationId: null,
                occluded: false
            });

        result.annotationId = annotation.annotationId;
        result.occluded = false;

        numPoints++;
    };

    /**
     * Performs an occlusion query for each query annotation.
     *
     * The query results are then available in #results.
     *
     * Clears the query annotations.
     *
     */
    OcclusionQuery.doQuery = function () {

        if (numPoints === 0) {
            return;
        }

        var opaqueOnly = true; // Ignore transparent pixels

        Human.renderer.getScene().readPixels(points, numPoints, opaqueOnly);

        var point;

        for (var i = 0; i < numPoints; i++) {

            // Get occlusion state of object, put into result array

            point = points[i];

            OcclusionQuery.result[i].occluded = !(point.r === 0 && point.g === 0 && point.b === 255);

            // Hide the 3D pin indicator
            // This will schedule another render (after next engine "tick"), unfortunately

            point.point.setShown(false);
        }

        OcclusionQuery.lenResult = numPoints;

        // Clear the query points

        numPoints = 0;

    };

    /**
     * Returns angle indicating how much the given annotation pin points away from the eye,
     * where 0 indicates that it points directly at the eye, while 180 indicates that it points directly away.
     *
     * @param pin
     * @returns {number}
     */

    var eyeVec = vec3.create();

    function getPinViewAngle(pin) {
        var eyePos = Human.view.camera.eye;
        vec3.subtract(eyeVec, [eyePos.x, eyePos.y, eyePos.z], pin.pos);
        var dot = vec3.dot(eyeVec, pin.dir);
        var lenEyeVec = vec3.length(eyeVec);
        var lenPinVec = vec3.length(pin.dir);
        var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
        return angle;
    }

    var pos = vec4.create();

    function world2Canvas(worldPos, viewMat, projMat, canvasWidth, canvasHeight, result) {
        vec3.transformMat4(pos, worldPos, viewMat);
        pos[3] = 1; // Need homogeneous 'w' for perspective division
        vec4.transformMat4(pos, pos, projMat);
        var x = pos[0];
        var y = pos[1];
        var w = pos[3];
        result[0] = (1 + x / w) * canvasWidth / 2;
        result[1] = (1 - y / w) * canvasHeight / 2;
    }

    /**
     * Renders a point within the 3D view
     *
     * @constructor
     */
    function Point() {

        this._flags = rootNode.addNode({
            type: "properties",
            properties: {
                enabled: false,
                clipping: true,
                picking: false
            }
        });

        this._material = this._flags.addNode({
            type: "material",
            color: {r: 0, g: 0, b: 1},
            specularColor: {r: 0, g: 0, b: 0},
            emitColor: {r: 0, g: 0, b: 1},
            emit: 1
        });

        this._translate = this._material.addNode({
            type: "translate",
            x: 0,
            y: 0,
            z: 0
        });

        this._geometry = this._translate.addNode({
            type: "geometry",
            primitive: "points",
            coreId: "__occludePoint",
            positions: [0, 0, 0],
            pointSize: 3
        });
    }

    Point.prototype.setShown = function (shown) {
        this._flags.setEnabled(!!shown);
    };

    Point.prototype.setClipping = function (clipping) {
        this._flags.setClipping(!!clipping);
    };

    Point.prototype.setWorldPos = function (worldPos) {
        this._translate.setXYZ({
            x: worldPos[0],
            y: worldPos[1],
            z: worldPos[2]
        });
    };

    Point.destroy = function () {
        this._flags.destroy();
    };
})();
;/** @namespace Manages X-Ray view mode
 */
(function () {
    "use strict";

    var HumanViewXray = Human.view.xray = {};

    HumanViewXray.enabled = false;
    var dirty = true;

    function pickCallback(object) {
        if (!object) {
            return;
        }

        var selected = !!Human.scene.selectedObjects[object.objectId];

        Human.scene.setSelectedObjects({
            objectId: object.objectId,
            select: !selected, // Deselect if currently selected
            replace: !Human.view.pick.multiEnabled
        });

        // Scene object picked
        if (!selected) {
            Human.view.labels.createLabel({ objectId: object.objectId, afterDelay: true, replace: true });
        }

    }

    Human.events.on(
        "loaded",
        function () {
            HumanViewXray.enabled = false;
            dirty = false;
        });

    Human.events.on(
        "scene.objectsSelected",
        function () { // Schedule xray for next frame when object selection changes
            if (HumanViewXray.enabled) {
                dirty = true;
            }
        });

    Human.events.on(
        "tick",
        function () {// Apply pending xray for next frame
            if (dirty) {
                xray(HumanViewXray.enabled);
                dirty = false;
            }
        });

    // Applies XRay to enabled model objects, making selected
    // objects opaque and the rest transparent
    function xray(enabled) {
        var model = Human.scene;
        var objects = model.objects;
        var object;
        for (var objectId in objects) { // De-highlight highlighted objects
            if (objects.hasOwnProperty(objectId)) {
                object = objects[objectId];
                if (enabled) { // Do X-ray
                    if (Human.scene.selectedObjects[object.objectId]) { // Opaque
                        object.setXRay(false);
                        object.setHighlight(false);
                    } else { // X-ray
                        object.setXRay(true);
                    }
                } else { // Undo X-ray
                    object.setXRay(false);
                }
            }
        }
    }

    HumanViewXray.setEnabled = function (enable) {
        if (HumanViewXray.enabled !== enable) {
            HumanViewXray.enabled = enable;
            dirty = true;
        }
        Human.events.fire("xray.toggled", { enabled:enable });
        if (HumanViewXray.enabled) {
            Human.view.currentMode = 'Xray';
            Human.view.pick.onSingleClick = pickCallback;
        } else if (Human.view.pick.onSingleClick === pickCallback) {
            Human.view.pick.onSingleClick = null;
        }
        xray(enable);
    };

    HumanViewXray.getEnabled = function () {
        return HumanViewXray.enabled;
    };

})();
;/** @namespace Manages picking of {@link Human.scene.Object}s in the {@link Human.scene}.
 */
(function () {
    "use strict";

    var HumanViewPick = Human.view.pick = {
        // Callbacks can be overridden by the application
        onSingleClick: null,
        onDoubleClick: function(object) {
            if (object) {
                Human.scene.setSelectedObjects({
                    objectId: object.objectId,
                    select: true, // Deselect if currently selected
                    replace: HumanViewPick.singleEnabled,
                });
                Human.view.labels.createLabel({ objectId: object.objectId, afterDelay: true, replace: true });

                Human.view.camera.fly.flyTo({
                    boundary: Human.scene.getBoundary({ objects: Human.scene.selectedObjects }),
                });
            } else if (!Human.view.xray.enabled) {
                Human.scene.setSelectedObjects({
                    select: false,
                    replace: true
                });
            }
        },
        onHover: function(object, event) {
            if (!object) {
                return;
            }

            var tootipTitle = object.displayName;
            var canvasX = event.canvasPos[0];
            var canvasY = event.canvasPos[1];

            if (object.regionMap) {
                var hit = Human.renderer.pick(canvasX, canvasY, false, true);
                var regionMapId, pixelColor;

                if (hit) {
                    if (regionsPickAll) {
                        regionMapId = null;
                    } else {
                        regionMapId = object.regionMap.regionMapId;
                        event.regionMapId = regionMapId;
                    }

                    pixelColor = hit.color;
                    Human.assets.regionMaps.highlightRegion({
                        regionColor: pixelColor,
                        regionMapId: regionMapId,
                        highlight: true
                    });

                    if (hit.regionData.name) {
                        tootipTitle = hit.regionData.name;
                    }
                }
            }

            Human.view.tooltips.setTooltip({
                objectId: object.objectId,
                canvasX: canvasX, canvasY: canvasY,
                title: tootipTitle
            });
        },
        onQuery: null
    };

    HumanViewPick.singleEnabled = true;
    HumanViewPick.multiEnabled = false;

    /**
     * Always get 3D intersection point when picking.
     * API can set this true so that it always gets the 3D point in "pick.picked" events.
     * @type {boolean}
     */
    var alwaysRayPick = false;

    var regionsPickAll = false;

    // Whether picking changes visibility of objects
    Human.properties.subscribe({
        propId: "pick.regions.pickAll",
        value: regionsPickAll,
        callback: function (value) {
            regionsPickAll = value;
        }
    });

    Human.events.on(
        "loaded", // Pick enabled by default
        function () {
            HumanViewPick.setSinglePickEnabled(true); // Notifies of initial state
            HumanViewPick.setMultiPickEnabled(false);
        });

    /** Enables or disables single-pick mode
     * @memberof Human.view.pick
     * @param {Boolean} enable Enables or disables single-pick mode
     */
    HumanViewPick.setSinglePickEnabled = function (enable) {
        if (HumanViewPick.singleEnabled !== enable) {
            HumanViewPick.singleEnabled = enable;
        }
        if (enable) {
            if (HumanViewPick.multiEnabled) {
                HumanViewPick.multiEnabled = false;
            }
            Human.events.fire("pick.multi.toggled", { enabled: HumanViewPick.multiEnabled });
        }
        Human.events.fire("pick.single.toggled", { enabled: HumanViewPick.singleEnabled });
    };

    /** Queries whether or not single-pick mode is enabled
     * @memberof Human.view.pick
     * @returns true if single-pick mode enabled else false
     */
    HumanViewPick.getSinglePickEnabled = function () {
        return HumanViewPick.singleEnabled;
    };

    /** Enables or disables multi-pick mode
     * @memberof Human.view.pick
     * @param {Boolean} enable Enables or disables multi-pick mode
     */
    HumanViewPick.setMultiPickEnabled = function (enable) {
        if (HumanViewPick.multiEnabled !== enable) {
            HumanViewPick.multiEnabled = enable;
        }
        if (enable) {
            if (HumanViewPick.singleEnabled) {
                HumanViewPick.singleEnabled = false;
            }
            Human.events.fire("pick.single.toggled", { enabled: HumanViewPick.singleEnabled });
        }
        Human.events.fire("pick.multi.toggled", { enabled: HumanViewPick.multiEnabled });
    };

    /** Queries whether or not multi-pick mode is enabled
     * @memberof Human.view.pick
     * @returns true if multi-pick mode enabled else false
     */
    HumanViewPick.getMultiPickEnabled = function () {
        return HumanViewPick.multiEnabled;
    };

    HumanViewPick.hoverPick = function (params) {
        return HumanViewPick._pick(params, true, false, false, alwaysRayPick, params.regionPick);
    };

    HumanViewPick.hoverOff = function () {
        Human.view.tooltips.clearTooltip();
    };

    HumanViewPick.pick = function (params) {
        return HumanViewPick._pick(params, false, false, false, alwaysRayPick, params.regionPick);
    };

    HumanViewPick.doublePick = function (params) {
        return HumanViewPick._pick(params, false, true, false, alwaysRayPick, params.regionPick);
    };

    HumanViewPick.queryPick = function (params) {
        return HumanViewPick._pick(params, false, false, true, params.rayPick || alwaysRayPick, params.regionPick);
    };

    /**
     * Performs a pick at the given X,Y canvas coordinates
     * @memberof Human.view.pick
     * @param params
     * @param {Number} params.canvasX Canvas X-coordinate
     * @param {Number} params.canvasY Canvas Y-coordinate
     * @param {Boolean} params.mouseDownLeft True when left mouse key is down
     * @param {Boolean} params.mouseDownRight True when right mouse key is down
     * @param {Boolean} params.spaceDown True when SPACE key is down
     * @param {Boolean} params.ctrlDown True when ALT key is down
     * @param {Boolean} hover Set true to do a hover-pick
     * @param {Boolean} doubleClick Set true to do a "double click" pick
     * @return
     */
    HumanViewPick._pick = function (params, hover, doubleClick, query, rayPick, regionPick) {

        var canvasX = params.canvasX;
        var canvasY = params.canvasY;
        var mouseDownLeft = params.mouseDownLeft;
        var mouseDownRight = params.mouseDownRight;
        var spaceDown = params.spaceDown;
        var ctrlDown = params.ctrlDown;
        var hit, object;

        //If test condition has been started. Disable selection of object
        if (Human.scene.checkTestStarted) { // TODO: Code smell!
            return;
        }

        Human.assets.regionMaps.highlightRegion(null);

        hit = Human.renderer.pick(canvasX, canvasY, rayPick, regionPick) || null;

        var event = {
            mouseDownLeft: mouseDownLeft,
            mouseDownRight: mouseDownRight,
            ctrlDown: ctrlDown,
            spaceDown: spaceDown,
        };

        if (hit) {
            object = findNamedObject(hit.name);
            event = Human.utils.apply(hit, event);
            if (object) {
              event.objectId = object.objectId;

              if (object.regionMap) {
                  hit = Human.renderer.pick(canvasX, canvasY, rayPick, true);
                  
                  if (hit) {
                      event.regionMapId = object.regionMap.regionMapId;
                      event = Human.utils.apply(event, hit);
                  }
              }
            }
        }

        if (hover) {
            event.mode = "hover";
            if (this.onHover) {
                this.onHover(object, event);
            }
            if (object) {
                Human.events.fire("pick.hoverPicked", event);
            }
        } else if (query) {
            event.mode = "query";
            if (this.onQuery) {
                this.onQuery(object, event);
            }
        } else if (doubleClick) {
            event.mode = "doubleClick";
            if (this.onDoubleClick) {
                this.onDoubleClick(object, event);
            }
        } else if (this.onSingleClick) {
            event.mode = "singleClick";
            this.onSingleClick(object, event);
        }

        if (object) {
            Human.events.fire("pick.picked", event);
        } else {
            Human.events.fire("pick.missed", event);
        }

        return event;
    };

    // Given an object ID, find the first object on path to root, including that object,
    // that was given an explicit ID, as opposed to one that was internally generated for the object.
    function findNamedObject(objectId) {
        var object = Human.scene.objects[objectId];
        while (object && object.anonymous) {
            object = object.parent;
        }
        return object;
    }
})();
;/**
 * @namespace Manages clip planes for cross-section views
 */
(function () {
    "use strict";

    var HumanViewClip = Human.view.clip = {};

    HumanViewClip.LEFT = "left";
    HumanViewClip.RIGHT = "right";
    HumanViewClip.TOP = "top";
    HumanViewClip.BOTTOM = "bottom";
    HumanViewClip.FRONT = "front";
    HumanViewClip.BACK = "back";

    var ready = false;
    var enabled = false;

    var clipsNode;

    // True whenever scene objects have been selected or deselected
    var objectSelectionDirty;

    // Boundary and center of currently-visible objects
    var sceneBoundary;

    // True whenever scene objects have shown or hidden
    var sceneBoundaryDirty = true;

    // True while SceneJS clips node is active
    var active = false;

    HumanViewClip.clips = {};

    HumanViewClip.selectedClip = null;

    Human.events.on(
        "loaded",
        function () {
            enabled = false;

            var libraryNode = Human.renderer.getNode("assetLibraryRoot");
            if (!libraryNode) {
                Human.log.error("Human.view.clip.createClipsNode", "Scene node not found: 'assetlibraryRoot'");
                return;
            }

            clipsNode = libraryNode.addNode({
                type: "clips",
                clips: [
                    {mode: "disabled", x: -1.0, y: 0.0, z: 0.0}, // left
                    {mode: "disabled", x: 1.0, y: 0.0, z: 0.0}, // right
                    {mode: "disabled", x: 0.0, y: -1.0, z: 0.0}, // bottom
                    {mode: "disabled", x: 0.0, y: 1.0, z: 0.0}, // top
                    {mode: "disabled", x: 0.0, y: 0.0, z: -1.0}, // front
                    {mode: "disabled", x: 0.0, y: 0.0, z: 1.0} // back
                ]
            });

            // Create clipping planes

            createClip({
                index: 0,
                type: HumanViewClip.LEFT,
                clipId: HumanViewClip.LEFT
            });

            createClip({
                index: 1,
                type: HumanViewClip.RIGHT,
                clipId: HumanViewClip.RIGHT
            });

            createClip({
                index: 2,
                type: HumanViewClip.TOP,
                clipId: HumanViewClip.TOP
            });

            createClip({
                index: 3,
                type: HumanViewClip.BOTTOM,
                clipId: HumanViewClip.BOTTOM
            });

            createClip({
                index: 4,
                type: HumanViewClip.FRONT,
                clipId: HumanViewClip.FRONT
            });

            createClip({
                index: 5,
                type: HumanViewClip.BACK,
                clipId: HumanViewClip.BACK
            });

            // Updates are sent to front plane by default
            HumanViewClip.selectClip("front");

        });

    function createClip(params) {

        params.onUpdate = function (clip) {
            HumanViewClip._onUpdate(clip);
        };

        HumanViewClip.clips[params.clipId] = new Human.view.clip.Plane(params);
    }

    HumanViewClip._onUpdate = function (clip) {
        var clips = {};
        clips["" + clip.index] = {
            x: clip.x,
            y: clip.y,
            z: clip.z,
            dist: clip.dist,
            mode: clip.clipping ? "inside" : "disabled"
        };
        clipsNode.setClips(clips);
    };

    Human.events.on(
        "tick",
        function () {
            if (objectSelectionDirty) {
                HumanViewClip._updateClipForIsolatedObjects();
                objectSelectionDirty = false;
            }

        });

    // Toggle clipability of currently selected objects
    HumanViewClip._updateClipForIsolatedObjects = function () {
        var objects = Human.scene.objects;
        var selectedObjects = Human.scene.selectedObjects;

        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                objects[objectId].setClippable(!!selectedObjects[objectId] ? false : true);
            }
        }
    };

    // Hide visible clip planes again whenever the renderer goes back to sleep
    Human.events.on(
        "Scene.Sleep",
        function () {
            var plane;
            for (var clipId in HumanViewClip.clips) {
                if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                    plane = HumanViewClip.clips[clipId];
                    if (plane.state === Human.view.clip.Plane.STATE_VISIBLE) {
                        if (plane.framesUntilHide > 0) {
                            plane.framesUntilHide--;
                        } else {
                            Human.view.clip.setClip({
                                clipId: plane.clipId,
                                state: Human.view.clip.Plane.STATE_CLIPPING
                            });
                        }
                    }
                }

            }
        });

    Human.events.on(
        "scene.objectsSelected",
        function () {
            objectSelectionDirty = true;
        });

    Human.events.on(
        "scene.objectsShown",
        function () {
            sceneBoundaryDirty = true;
            for (var clipId in HumanViewClip.clips) {
                if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                    var clip = HumanViewClip.clips[clipId];
                    if (clip.state !== Human.view.clip.Plane.STATE_DORMANT) {
                        HumanViewClip._configureClip(clip);
                    }
                }
            }
        });

    /**
     * Update state of a clipping plane.
     */
    HumanViewClip.setClip = function (params) {
        var clip;
        if (!params.clipId) {
            if (HumanViewClip.selectedClip) {
                clip = HumanViewClip.selectedClip;
            } else {
                Human.log.error("Human.view.clip.setClip", "Parameter expected: 'clipId'");
                return;
            }
        } else {
            clip = HumanViewClip.clips[params.clipId];
            if (!clip) {
                Human.log.error("Human.view.clip.setClip", "Clip plane not found: '" + params.clipId + "'");
                return;
            }
        }

        if (params.state &&
            params.state !== Human.view.clip.Plane.STATE_DORMANT &&
            params.state !== Human.view.clip.Plane.STATE_ACTIVE &&
            params.state !== Human.view.clip.Plane.STATE_CLIPPING &&
            params.state !== Human.view.clip.Plane.STATE_VISIBLE) {
            Human.log.error("Human.view.clip.setClip", "State not recognized: '" + params.state + "'");
            return;
        }

        var oldState = clip.state;
        var newState = params.state || oldState;

        switch (newState) {
            case Human.view.clip.Plane.STATE_DORMANT:

                clip._setClipping(false);
                clip._setVisible(false);

                break;

            case Human.view.clip.Plane.STATE_ACTIVE:

                HumanViewClip._configureClip(clip, params);

                clip._setClipping(false);
                clip._setVisible(false);

                break;

            case Human.view.clip.Plane.STATE_CLIPPING:

                clip._setClipping(true);
                clip._setVisible(false);

                switch (oldState) {
                    case Human.view.clip.Plane.STATE_DORMANT:
                        HumanViewClip._configureClip(clip, params);
                        break;

                    default:
                        if (params.progress !== undefined) {
                            clip._setProgress(params.progress);
                        }
                }
                break;

            case Human.view.clip.Plane.STATE_VISIBLE:

                clip._setClipping(true);
                clip._setVisible(true);

                switch (oldState) {
                    case Human.view.clip.Plane.STATE_DORMANT:
                        HumanViewClip._configureClip(clip, params);
                        break;

                    default:
                        if (params.progress !== undefined) {
                            clip._setProgress(params.progress);
                        }
                }
                break;
        }

        clip.state = newState;

        // Notify of new clip plane state
        Human.events.fire("clip.updated", {
            clipId: clip.clipId,
            state: clip.state, // "dormant", "active", "clipping", "visible"
            progress: clip.progress // "left", "right", "top", "bottom", "front", "back"
        });

        // Activate clips node only if clipping is now visibly in effect
        // otherwise disable it
        activateClipsIfNeeded();
    };

    HumanViewClip._configureClip = function (clip, params) {

        params = params || {};

        //  if (!params.pos) {

        if (sceneBoundaryDirty) {
            sceneBoundary = Human.scene.getBoundary({
                objects: Human.scene.enabledObjects
            });
            sceneBoundaryDirty = false;
        }
        //  }


        var xCenter = (sceneBoundary.xmin + sceneBoundary.xmax) * 0.5;
        var yCenter = (sceneBoundary.ymin + sceneBoundary.ymax) * 0.5;
        var zCenter = (sceneBoundary.zmin + sceneBoundary.zmax) * 0.5;

        var pos;
        var dir;
        var size;
        var range;

        switch (clip.type) {

            case HumanViewClip.LEFT:

                pos = {
                    x: sceneBoundary.xmax,
                    y: yCenter,
                    z: zCenter
                };
                dir = {
                    y: 1,
                    angle: -90.0
                };
                size = {
                    x: (sceneBoundary.zmax - sceneBoundary.zmin),
                    y: (sceneBoundary.ymax - sceneBoundary.ymin)
                };
                range = {
                    min: sceneBoundary.xmin,
                    max: sceneBoundary.xmax
                };
                break;

            case HumanViewClip.RIGHT:

                pos = {
                    x: sceneBoundary.xmin,
                    y: yCenter,
                    z: zCenter
                };
                dir = {
                    y: 1,
                    angle: 90.0
                };
                size = {
                    x: (sceneBoundary.zmax - sceneBoundary.zmin),
                    y: (sceneBoundary.ymax - sceneBoundary.ymin)
                };
                range = {
                    min: sceneBoundary.xmin,
                    max: sceneBoundary.xmax
                };
                break;

            case HumanViewClip.FRONT:

                pos = {
                    x: xCenter,
                    y: yCenter,
                    z: sceneBoundary.zmin
                };
                dir = {
                    y: 1,
                    angle: 0.0
                };
                size = {
                    x: (sceneBoundary.xmax - sceneBoundary.xmin),
                    y: (sceneBoundary.ymax - sceneBoundary.ymin)
                };
                range = {
                    min: sceneBoundary.zmin,
                    max: sceneBoundary.zmax
                };
                break;

            case HumanViewClip.BACK:

                pos = {
                    x: -xCenter,
                    y: yCenter,
                    z: sceneBoundary.zmax
                };
                dir = {
                    y: 1,
                    angle: 180.0
                };
                size = {
                    x: (sceneBoundary.xmax - sceneBoundary.xmin),
                    y: (sceneBoundary.ymax - sceneBoundary.ymin)
                };
                range = {
                    min: sceneBoundary.zmin,
                    max: sceneBoundary.zmax
                };
                break;

            case HumanViewClip.TOP:

                pos = {
                    x: xCenter,
                    y: sceneBoundary.ymax,
                    z: zCenter
                };
                dir = {
                    x: 1,
                    angle: 90.0
                };
                size = {
                    x: (sceneBoundary.xmax - sceneBoundary.xmin),
                    y: (sceneBoundary.zmax - sceneBoundary.zmin)
                };
                range = {
                    min: sceneBoundary.ymin,
                    max: sceneBoundary.ymax
                };
                break;

            case HumanViewClip.BOTTOM:

                pos = {
                    x: xCenter,
                    y: sceneBoundary.ymin,
                    z: zCenter
                };
                dir = {
                    x: 1,
                    angle: -90.0
                };
                size = {
                    x: (sceneBoundary.xmax - sceneBoundary.xmin),
                    y: (sceneBoundary.zmax - sceneBoundary.zmin)
                };
                range = {
                    min: sceneBoundary.ymin,
                    max: sceneBoundary.ymax
                };
                break;

            default:

                // TODO: Align to vectored position on sphere when no pos given

                pos = params.pos;
                dir = params.dir;
                size = params.size;
                range = params.range;
                break;
        }

        clip._setPos(pos);
        clip._setDir(dir);
        clip._setRange(range);
        clip._setSize(size);

        if (params.progress !== undefined) {
            clip._setProgress(params.progress);
        }

    };

    // Activates the clips node if any clip planes are in effect, otherwise deactivates it
    function activateClipsIfNeeded() {
        var plane;
        for (var clipId in HumanViewClip.clips) {
            if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                plane = HumanViewClip.clips[clipId];
                if (plane.state !== Human.view.clip.Plane.STATE_DORMANT && plane.progress !== 0) {
                    activateClipsNode();
                    return;
                }
            }
        }
        deactivateClipsNode();
    }

    // Moves the clips node from the dormant "library" part of the scene graph
    // into the "live" part so that it then clips the 3D scene
    function activateClipsNode() {

        // Human.log.info("activating");

        if (active) {
            return;
        }

        // Insert clips node above content root
        var contentRootNode = Human.renderer.getNode("clips");
        var parent = contentRootNode.parent;
        var children = parent.disconnectNodes();
        clipsNode.disconnect();
        clipsNode.addNodes(children);
        parent.addNode(clipsNode);

        active = true;

        for (var i = 0, len = Human.scene.rootObjects.length; i < len; i++) {
            Human.scene.rootObjects[i].traverseDown(enableBackfaces);
        }
        
        Human.events.fire("clips.activated");
    }

    // Moves the clips node from the "live" part of the scene graph
    // back into the dormant "library" part so that it then no longer clips the 3D scene
    function deactivateClipsNode() {

        if (!active) {
            return;
        }

        // Extract clips node from scene graph,
        // moving its children up to its parent
        clipsNode.splice();

        // Insert clips node into scene graph's library subgraph
        var libraryNode = Human.renderer.getNode("assetLibraryRoot");

        if (!libraryNode) {
            Human.log.error("Human.view.clip.deactivateClipsNode", "Scene node not found: 'assetlibraryRoot'");
            return;
        }

        libraryNode.addNode(clipsNode);

        active = false;

        for (var i = 0, len = Human.scene.rootObjects.length; i < len; i++) {
            Human.scene.rootObjects[i].traverseDown(disableBackfaces);
        }

        Human.events.fire("clips.deactivated");
    }

    /**
     * Selects a clip as the default fallback for setClip.
     * Call with null to stop using the clip plane.
     */
    HumanViewClip.selectClip = function (clipId) {
        var clip;
        if (clipId) {
            clip = HumanViewClip.clips[clipId];
            if (!clip) {
                Human.log.error("Human.view.clip.selectClip", "Clip plane not found: '" + clipId + "'");
                return;
            }
        }
        HumanViewClip.selectedClip = clip;
    };

    /**
     * Reset cross-sections to dormant state
     */
    HumanViewClip.reset = function () {
        var clip;
        for (var clipId in HumanViewClip.clips) {
            if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                clip = HumanViewClip.clips[clipId];
                HumanViewClip.setClip({
                    clipId: clip.clipId,
                    state: Human.view.clip.Plane.STATE_DORMANT
                });
                HumanViewClip._configureClip(clip); // Reset clips' position, dir, progress etc
            }
        }

        if (ready) {
            HumanViewClip.selectClip("front");
        }

        Human.events.fire("CrossSections.Reset");
    };

    function enableBackfaces(object) {
        if (object.isLeaf()) {
            object.setBackfaces(true);
        }
    }

    function disableBackfaces(object) {
        if (object.isLeaf()) {
            object.setBackfaces(false);
        }
    }
})();;(function () {
    // jshint camelcase: false, newcap: false
    // ^ Have to turn these off because of SceneJS variables.

    "use strict";

    // Cached transform matrices

    var clipMat = mat4.create(); // Transforms SceneJS clipping planes
    var BOTTOM_LEFT_CLIP = vec3.fromValues(-1, -1, 0);
    var BOTTOM_RIGHT_CLIP = vec3.fromValues(1, -1, 0);
    var TOP_RIGHT_CLIP = vec3.fromValues(1, 1, 0);

    Human.view.clip.Plane = function (cfg) {

        this.index = cfg.index;

        this.clipId = cfg.clipId;
        this.type = cfg.type;
        this.state = Human.view.clip.Plane.STATE_DORMANT;
        this.framesUntilHide = 1;  // Number of SLEEPS this frame is allowed to remain in STATE_VISIBLE

        // Position of center of clipping plane
        var pos = cfg.pos || {};
        this.pos = {
            x: pos.x || 0.0,
            y: pos.y || 0.0,
            z: pos.z || 0.0
        };

        // vector indicating direction of clipping plane
        var dir = cfg.dir || {};
        this.dir = {
            x: dir.x || 0.0,
            y: dir.y || 0.0,
            z: dir.z || 0.0,
            angle: dir.angle || 0.0
        };

        // Width and height of clipping plane indicator
        var size = cfg.size || {};
        this.size = {
            x: size.x || 10.0,
            y: size.y || 10.0
        };

        // Range of movement of clipping plane
        var range = cfg.range || {};
        this.range = {
            min: range.min || 0.0,
            max: range.max || 0.0
        };

        // Factor in range [0..1] indicating progress of clipping plane within its movement range
        this.progress = 0;

        // SceneJS node IDs
        var indicatorFlagsId = cfg.clipId + ".indicator.flags";
        var indicatorXFormId = cfg.clipId + ".indicator.xf";

        // True when clipping plane indicator is visible
        this.visible = cfg.visible || false;

        // True when clipping plane is clipping
        this.clipping = cfg.clipping || false;

        this._onUpdate = cfg.onUpdate;

        // Build SceneJS subgraph for clip plane indicator
        Human.renderer.getNode(Human.CLIP_INDICATORS_ATTACH_ID).addNode({
            type: "properties",
            id: indicatorFlagsId,

            properties: {
                enabled: this.visible,
                transparent: true,
                backfaces: true,
                clipping: false,
                picking: false
            },

            nodes: [
                {
                    type: "xform",
                    id: indicatorXFormId,

                    nodes: [

                        // Solid plane inner
                        {
                            type: "material",
                            emit: 0.9,
                            baseColor: {r: 0.3, g: 0.3, b: 0.4},
                            specularColor: {r: 0.3, g: 0.3, b: 0.4},
                            specular: 0.0,
                            shine: 100.0,
                            alpha: 0.2,

                            nodes: [
                                {
                                    type: "geometry/plane",
                                    width: 2.0,
                                    height: 2.0
                                }
                            ]
                        },

                        // Plane outline
                        {
                            type: "material",
                            emit: 0.9,
                            baseColor: {r: 0.3, g: 0.3, b: 0.4},
                            specularColor: {r: 0.3, g: 0.3, b: 0.4},
                            specular: 0.0,
                            shine: 100,
                            alpha: 0.9,

                            nodes: [
                                {
                                    type: "geometry",
                                    primitive: "lines",
                                    positions: [
                                        1.0, 1.0, 1.0,
                                        1.0, -1.0, 1.0,
                                        -1.0, -1.0, 1.0,
                                        -1.0, 1.0, 1.0,
                                        1.0, 1.0, -1.0,
                                        1.0, -1.0, -1.0,
                                        -1.0, -1.0, -1.0,
                                        -1.0, 1.0, -1.0
                                    ],
                                    indices: [0, 1, 1, 2, 2, 3, 3, 0]
                                }
                            ]
                        }
                    ]
                }
            ]
        });

        this.indicatorFlagsNode = Human.renderer.getNode(indicatorFlagsId);
        this.indicatorXFormNode = Human.renderer.getNode(indicatorXFormId);

        this._updatePosition();
    };

    var a = vec3.create();
    var b = vec3.create();
    var c = vec3.create();
    var normal = vec3.create();
    var rotationMat = mat4.create();
    var scalingMat = mat4.create();

    var tempVec3a = vec3.create();
    var tempVec3b = vec3.create();

    Human.view.clip.Plane.prototype._updatePosition = function () {

        var move = (this.progress * (this.range.max - this.range.min));
        var pos = [this.pos.x, this.pos.y, this.pos.z];

        switch (this.type) {
            case Human.view.clip.BACK:
                pos[2] = this.range.max - move;
                break;
            case Human.view.clip.FRONT:
                pos[2] = this.range.min + move;
                break;
            case Human.view.clip.LEFT:
                pos[0] = this.range.max - move;
                break;
            case Human.view.clip.RIGHT:
                pos[0] = this.range.min + move;
                break;
            case Human.view.clip.TOP:
                pos[1] = this.range.max - move;
                break;
            case Human.view.clip.BOTTOM:
                pos[1] = this.range.min + move;
                break;
        }

        mat4.fromTranslation(clipMat, pos);
        mat4.fromRotation(rotationMat, this.dir.angle * Math.PI / 180.0, [this.dir.x, this.dir.y, this.dir.z]);
        mat4.fromScaling(scalingMat, [this.size.x * 0.5, this.size.y * 0.5, 0]);

        mat4.multiply(clipMat, clipMat, rotationMat);
        mat4.multiply(clipMat, clipMat, scalingMat);

        this.indicatorXFormNode.setElements(clipMat);

        vec3.transformMat4(a, BOTTOM_LEFT_CLIP, clipMat);
        vec3.transformMat4(b, BOTTOM_RIGHT_CLIP, clipMat);
        vec3.transformMat4(c, TOP_RIGHT_CLIP, clipMat);

        vec3.subtract(tempVec3a, b, a);
        vec3.normalize(tempVec3a, tempVec3a);

        vec3.subtract(tempVec3b, b, c);
        vec3.normalize(tempVec3b, tempVec3b);

        vec3.cross(normal, tempVec3a, tempVec3b);
        vec3.normalize(normal, normal);

        var dist = vec3.dot(normal, a);

        this.x = normal[0];
        this.y = normal[1];
        this.z = normal[2];
        this.dist = dist;

        this._onUpdate(this);
    };

    /** States a Plane can be in
     */
    Human.view.clip.Plane.STATE_DORMANT = "dormant";    // Existing but not associated with selected objects
    Human.view.clip.Plane.STATE_ACTIVE = "active";      // Associated with selected objects but not clipping them
    Human.view.clip.Plane.STATE_CLIPPING = "clipping";  // Clipping the selected objects
    Human.view.clip.Plane.STATE_VISIBLE = "visible";    // Clipping and visible

    /**
     * Updates the position of this clipping plane.
     * Called from Human.view.Clip
     */
    Human.view.clip.Plane.prototype._setPos = function (pos) {
        pos = pos || {};
        this.pos = {
            x: pos.x || 0.0,
            y: pos.y || 0.0,
            z: pos.z || 0.0
        };
        this._updatePosition();
    };

    /**
     * Updates the direction of this clipping plane.
     * Called from Human.view.Clip
     */
    Human.view.clip.Plane.prototype._setDir = function (dir) {
        dir = dir || {};
        this.dir = {
            x: dir.x || 0.0,
            y: dir.y || 0.0,
            z: dir.z || 0.0,
            angle: dir.angle || 0.0
        };
        this._updatePosition();
    };

    /**
     * Updates the range of movement of this clipping plane.
     * Called from Human.view.Clip
     */
    Human.view.clip.Plane.prototype._setRange = function (range) {
        range = range || {};
        this.range = {
            min: range.min || 0.0,
            max: range.max || 0.0
        };
        this._updatePosition();
    };

    /** Updates the progress of this clipping plane
     * Called from Human.view.Clip
     * @param progress Factor in range [0..1]
     */
    Human.view.clip.Plane.prototype._setProgress = function (progress) {
        if (this.progress === progress) {
            return;
        }
        if (progress < 0.0) {
            progress = 0.0;
            this._setClipping(false);
        } else if (progress > 1.0) {
            progress = 1.0;
            this._setClipping(false);
        } else {
            this._setClipping(true);
        }
        this.progress = progress;
        this._updatePosition();
    };

    /** Width and height of indicator for this clipping plane
     * Called from Human.view.Clip
     * @param size
     */
    Human.view.clip.Plane.prototype._setSize = function (size) {
        size = size || {};
        this.size = {
            x: size.x || 10.0,
            y: size.y || 10.0
        };
        this._updatePosition();
    };

    /** Shows of hides the indicator for this clipping plane
     * Called from Human.view.Clip
     * @param visible
     */
    Human.view.clip.Plane.prototype._setVisible = function (visible) {
        this.framesUntilHide = visible ? 1 : 0;
        if (this.visible === visible) {
            return;
        }

        this.indicatorFlagsNode.setEnabled(visible);
        this.visible = visible;
    };

    /** Sets the mode for this clipping plane
     * Called from Human.view.Clip
     * @param mode
     */
    Human.view.clip.Plane.prototype._setMode = function (mode) {
        if (this.mode === mode) {
            return;
        }
        this.mode = mode;
        this._onUpdate(this);
    };

    /** Sets whether or not this clipping plane is clipping
     * Called from Human.view.Clip
     * @param clipping
     */
    Human.view.clip.Plane.prototype._setClipping = function (clipping) {
        if (this.clipping === clipping) {
            return;
        }
        this.clipping = clipping;
        this._onUpdate(this);
    };

})();

;/**

 @namespace Dynamic lighting support

 <p>Usage:</p>

 <pre>

 // Add some lights

 Human.view.lights.addLight({
                lightId: "light0",
                displayName: "Default ambient",
                description: "Default ambient light source",
                params: {
                    mode: "ambient",
                    color: { r: 0.15, g: 0.15, b: 0.15 },
                    diffuse: true
                }
            });

 Human.view.lights.addLight({
                lightId: "light1",
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 0.15, g: 0.15, b: 0.2 },
                    dir: { x: -0.3, y: 0.4, z: 0.5 },
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

 Human.view.lights.addLight({
                lightId: "light2",
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "point",
                    color: { r: 1.3, g: 1.3, b: 1.2 },
                    pos: { x: -1.0, y: 0.0, z: 1.0},
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

 // Enable and disable lights in a batch

 Human.view.lights.setEnabled({
        lights: {
            "light0": true,
            "light1": true,
            "light2": false
        },
        replace: true // Disable all previously active lights
 });

 // Set light parameters in a batch

 Human.view.lights.setParams({
        "light0": {
            dir: { x: 0.2, y: 0.1, z: -0.2
        },
        "light2": {
            pos: { x: 0, y: 10, z: -20,
            color: { r: .9, g: 0.2, b: 1.0 }
        }
    });

 // Remove a light

 Human.view.lights.removeLight("light0");

 </pre>
 */
(function () {
    "use strict";

    var HumanViewLights = Human.view.lights = {};

    /**
     * Lights mapped to their IDs
     *
     * @type {{String:Human.view.lights.Light}}
     */
    HumanViewLights.lights = {};

    /**
     * Default lights should be stored for re-enabling after custom
     * lights are disabled.
    */
    HumanViewLights.defaultLightIds = [];

    // True when lights in the scene graph need to be rebuilt
    var dirty = false;

    // Create default lights once engine code has loaded, all enabled
    Human.events.on("loaded",
        function () {

            // Need exactly one ambient light
            HumanViewLights.addLight({
                lightId: 'light0',
                enabled: true,
                displayName: 'Default ambient',
                description: 'Default ambient light source',
                params: {
                    mode: 'ambient',
                    color: {
                        r: 0.2,
                        g: 0.2,
                        b: 0.2,
                        diffuse: true
                    }
                }
            });

            HumanViewLights.addLight({
                lightId: 'light1',
                enabled: true,
                displayName: 'Default directional',
                description: 'Default directional light source',
                params: {
                    mode: 'dir',
                    dir: {
                        x: 1.0,
                        y: 0.0,
                        z: -0.5
                    },
                    color: {
                        r: 0.1,
                        g: 0.1,
                        b: 0.2
                    },
                    diffuse: true,
                    specular: true,
                    space: 'view'
                }
            });

            HumanViewLights.addLight({
                lightId: 'light2',
                enabled: true,
                displayName: 'Default directional',
                description: 'Default directional light source',
                params: {
                    mode: 'dir',
                    dir: {
                        x: -1,
                        y: 0.0,
                        z: 1.0
                    },
                    color: {
                        r: 0.55,
                        g: 0.5,
                        b: 0.5
                    },
                    diffuse: true,
                    specular: true,
                    space: 'view'
                }
            });

            HumanViewLights.addLight({
                lightId: 'light3',
                enabled: true,
                displayName: 'Default directional',
                description: 'Default directional light source',
                params: {
                    mode: 'dir',
                    dir: {
                        x: 0.25,
                        y: 0.0,
                        z: -1.0
                    },
                    color: {
                        r: 0.9,
                        g: 0.9,
                        b: 0.9
                    },
                    diffuse: true,
                    specular: false,
                    space: 'view'
                }
            });

            HumanViewLights.defaultLightIds.push('light0');
            HumanViewLights.defaultLightIds.push('light1');
            HumanViewLights.defaultLightIds.push('light2');
            HumanViewLights.defaultLightIds.push('light3');

        });

    // Lazy-rebuild the lights in the scene graph on next tick
    Human.events.on("tick",
        function () {
            HumanViewLights.compile();
        });

    /**
     * Adds a light
     * @param params
     */
    HumanViewLights.addLight = function (params) {
        var light = new Human.view.lights.Light(params);
        HumanViewLights.lights[params.lightId] = light;
        light.on("enabled",
            function () {
                dirty = true;
            });
        dirty = true;
    };

    /**
     * Removes a light
     * @param lightId ID of light to remove
     */
    HumanViewLights.removeLight = function (lightId) {
        if (HumanViewLights.lights[lightId]) {
            delete HumanViewLights.lights[lightId];
            dirty = true;
        }
    };

    /**
     * Removes all lights
     */
    HumanViewLights.removeAllLights = function () {
        HumanViewLights.lights = {};
        dirty = true;
    };

    /**
     * Enables or disables one or more lights
     *
     * <p>Examples:</p>
     *
     * <pre>
     *
     *  Human.view.lights.setEnabled({
     *      lightId: "myLight",
     *      enable: true
     *  });
     *
     *  Human.view.lights.setEnabled({
     *      lights: {
     *          "myLight": true,
     *          "myOtherlight": false
     *      },
     *      replace: true // Disable any lights that are previously enabled
     *  });
     * </pre>
     * @param params
     */
    HumanViewLights.setEnabled = function (params) {
        // Option to replace the set of enabled lights
        if (params.replace) {
            HumanViewLights.clearEnabled();
        }
        var lightId;
        var light;
        var val;
        if (params.lightId) {
            lightId = params.lightId;
            light = HumanViewLights.lights[lightId];
            if (!light) {
                Human.log.error("Human.view.lights.setEnabled", "Light not found: " + lightId);
                return;
            }
            val = !!params.enable;
            if (light.enabled !== val) {
                light.enabled = val;
                dirty = true;
            }
        } else if (params.lights) {
            var lights = params.lights;
            for (lightId in lights) {
                if (lights.hasOwnProperty(lightId)) {
                    light = HumanViewLights.lights[lightId];
                    if (!light) {
                        Human.log.error("Human.view.lights.setEnabled", "Light not found: " + lightId);
                        continue;
                    }
                    val = !!lights[lightId];
                    if (light.enabled !== val) {
                        light.enabled = val;
                        dirty = true;
                    }
                    if (val && typeof val !== "boolean") {
                        // Light params given
                        light.setParams(val);
                    }
                }
            }
        }
    };

    /**
     * Disables all lights
     */
    HumanViewLights.clearEnabled = function () {
        for (var lightId in HumanViewLights.lights) {
            if (HumanViewLights.lights.hasOwnProperty(lightId)) {
                HumanViewLights.lights[lightId].setEnabled(false);
                dirty = true;
            }
        }
    };

    /**
     * Sets parameters for lights
     * @param params
     */
    HumanViewLights.setParams = function (params) {
        var light;
        for (var lightId in params) {
            if (params.hasOwnProperty(lightId)) {
                light = HumanViewLights.lights[lightId];
                if (!light) {
                    Human.log.error("Human.view.lights.setParams", "Light not found: " + lightId);
                    continue;
                }
                light.setParams(params[lightId]);
            }
        }
    };

    /* Restore Defaults (currently only one set of defaults)
    */
    HumanViewLights.restoreDefaults = function(){
        var params = {
            lights: {},
            replace: true
        };

        HumanViewLights.defaultLightIds.forEach(function(id){
            params.lights[id] = true;
        });
        HumanViewLights.setEnabled(params);
    };

    HumanViewLights.compile = function() {

        if (!dirty) {
            return;
        }

        var scene = Human.renderer.getScene();

        // Get lights container node
        var container = scene.getNode("lights");
                
                // Get subtree of that, which contains the scene content
        var subtree = scene.getNode("lights.subtree");

        // Disconnect scene content
        subtree.disconnect();

        // Blow away lights node
        container.removeNodes();

        // Accumulate enabled light sources in array
        var _lights = [];
        var light;
        var lightId;

        for (lightId in HumanViewLights.lights) {
            if (HumanViewLights.lights.hasOwnProperty(lightId)) {

                light = HumanViewLights.lights[lightId];

                if (light.enabled) {
                    if (light.params) {
                        _lights.push(light.params || {});
                    }
                }
            }
        }

        // Rebuild light node

        var node = container.addNode({
            type: "lights",
            lights: _lights.slice(0),
            nodes: [
                {
                    id: "lightsSubTree"
                }
            ]
        });

        // Link light elements back to the node
        // to assist with dynamic update

        var count = 0;

        for (lightId in HumanViewLights.lights) {
            if (HumanViewLights.lights.hasOwnProperty(lightId)) {
                light = HumanViewLights.lights[lightId];
                light.node = node;
                light.index = count++;
            }
        }


        scene.getNode("lightsSubTree").addNode(subtree);

        dirty = false;
    };

})();
;(function() {
    "use strict";


    /**
     * @class A rendering post-light within {@link Human.view.lights}
     * @param cfg
     * @constructor
     */
    Human.view.lights.Light = function (cfg) {

        // Call parent class Human.Component init
        this._init();

        /**
         * Display name for this light
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /**
         * Description of this light
         * @type {String}
         */
        this.description = cfg.description;

        /** ID of this light, unique within {@link Human.view.lights}
         * @type {String}
         */
        this.lightId = cfg.lightId;

        /**
         * True when light is enabled
         * @type {boolean}
         */
        this.enabled = !!cfg.enabled;

        /**
         * Light parameters
         * @type {{}}
         */
        this.params = cfg.params || {};

        /**
         * Target scene node for this light, non-null while the light is active.
         * @type {SceneJS.Node}
         */
        this.node = null;

        /**
         * Index of light on the target scene node, valid while light active
         * @type {number}
         */
        this.index = 0;
    };

    Human.utils.extend(Human.view.lights.Light, Human.Component);

    /**
     * Enables or disables this light
     * @memberof Human.view.lights.Light
     */
    Human.view.lights.Light.prototype.setEnabled = function (enabled) {
        this.publish("enabled", this.enabled = enabled);
    };


    /**
     * Configures this light
     * @memberof Human.view.lights.Light
     */
    Human.view.lights.Light.prototype.setParams = function (params) {
        Human.utils.apply(params, this.params);
        if (this.node) {
            // Light is currently enabled, update its scene node
            var p = {};
            p["" + this.index] = params;
            this.node.setLights(p);
        }
    };

})();




;/**

 Post-effect pipeline

 <pre>

 //----------------------------------------------------------------------------
 // Build the pipeline
 //----------------------------------------------------------------------------

 // Add depth-of-field blur
 Human.view.effects.addEffect({
                effectId: "dof",                // Unique ID to assign
                type: "postprocess/dof",        // SceneJS node to use for this effect
                displayName: "Depth-of-field",
                description: "Simulates photographic depth-of-field",
                params: {
                    texelSize: 0.00022,             // Size of one texel (1 / width, 1 / height)
                    blurCoeff: 0.0084,	            // Calculated from the blur equation, b = ( f * ms / N )
                    autofocus: true                 // Automatically synch focusDist to "cameras/pickFlyOrbit"
                }
            });

 // Film grain effect
 Human.view.effects.addEffect({
                effectId: "filmGrain",
                type: "postprocess/filmGrain",
                displayName: "Film Grain",
                description: "Film grain noise"
            });

 // Sepia effect
 Human.view.effects.addEffect({
                effectId: "sepia",
                type: "postprocess/sepia",
                displayName: "Sepia",
                description: "Sepia color filter"
            });

 //----------------------------------------------------------------------------
 // Enable effects
 //----------------------------------------------------------------------------

 // Enable "sepia" and "dof", disable "filmGrain"
 Human.view.effects.setEnabled({
                effectIds: {
                    "sepia": true,
                    "dof": true,
                    "filmGrain": false
                },
                replace: true
        });

 //----------------------------------------------------------------------------
 // Set effect parameters
 //----------------------------------------------------------------------------

 // Set parameters for depth-of-field effect
 Human.view.effects.setParams({
        "dof": {
            "PPM": 100000,
            "blurCoeff" : 0.001
        }
    });
 </pre>
 */
(function () {
    "use strict";

    var HumanViewEffects = Human.view.effects = {};

    /**
     * Effects in the order in which they will be applied
     *
     * @type {[Human.view.effects.Effect]}
     */
    HumanViewEffects.pipeline = [];

    /**
     * Effects mapped to their IDs
     *
     * @type {{String:Human.view.effects.Effect}}
     */
    HumanViewEffects.effects = {};


    // True when effects pipeline in the
    // scene graph needs to be rebuilt
    var dirty = false;

    // Set up the effects pipeline once the engine code has loaded
    Human.events.on("loaded",
        function () {

            // These must be added in the order in which they
            // should be applied with respect to one another

            // Depth-of-field blur
            HumanViewEffects.addEffect({
                effectId: "dof",                // Unique ID to assign
                type: "postprocess/dof",        // SceneJS node to use for this effect
                displayName: "Depth-of-field",
                description: "Simulates photographic depth-of-field",

                // Effect parameters
                params: {
                    texelSize: 0.00022,             // Size of one texel (1 / width, 1 / height)
                    blurCoeff: 0.0084,	            // Calculated from the blur equation, b = ( f * ms / N )
                    ppm: 10000.0,
                    autofocus: true                 // Automatically synch focusDist to "cameras/pickFlyOrbit"
                }
            });

            // Sepia effect
            HumanViewEffects.addEffect({
                effectId: "sepia",
                type: "postprocess/sepia",
                displayName: "Sepia",
                description: "Sepia color filter"
            });

            // Scanlines effect
            HumanViewEffects.addEffect({
                effectId: "scanlines",
                type: "postprocess/scanlines",
                displayName: "Scanlines",
                description: "Scan lines pattern"
            });

            // Film grain effect
            HumanViewEffects.addEffect({
                effectId: "filmGrain",
                type: "postprocess/filmGrain",
                displayName: "Film Grain",
                description: "Film grain noise"
            });

            // Technicolor effect
            HumanViewEffects.addEffect({
                effectId: "technicolor",
                type: "postprocess/technicolor",
                displayName: "Technicolor",
                description: "Technicolor color filter"
            });

            // Oculus Rift
            HumanViewEffects.addEffect({
                effectId: "oculusRift",
                type: "effects/oculusRift",
                displayName: "Oculus Rift",
                description: "View using Oculus Rift",
                params: {
                    eyeSep: 20.6,
                    focalLength: 27
                }
            });

            // Stereo
            HumanViewEffects.addEffect({
                effectId: "stereo",
                type: "effects/stereo",
                displayName: "Stereo",
                description: "View in stereo"
            });

            // Anaglyph
            HumanViewEffects.addEffect({
                effectId: "anaglyph",
                type: "effects/anaglyph",
                displayName: "Anaglyph 3D",
                description: "View in Anaglyph 3D"
            });
        });

    // Lazy-rebuild the effect nodes in the scene graph
    Human.events.on("tick",
        function () {
            HumanViewEffects.compile();
        });

    /**
     * Adds a effect
     * @param params
     * @returns {Human.view.effects.Effect}
     */
    HumanViewEffects.addEffect = function (params) {
        var effect = new Human.view.effects.Effect(params);
        HumanViewEffects.effects[params.effectId] = effect;
        HumanViewEffects.pipeline.unshift(effect);
        effect.on("enabled",
            function () {
                dirty = true;
            });
        dirty = true;
    };

    /**
     * Enables or disables effects
     *
     * <p>Examples:</p>
     *
     * <pre>
     *
     *  Human.view.effects.setEnabled({
     *      effectId: "dof",
     *      enable: true
     *  });
     *
     *  Human.view.effects.setEnabled({
     *      effectIds: {
     *          "dof": true,
     *          "blur": false
     *      }
     *  });
     * </pre>
     * @param params
     */
    HumanViewEffects.setEnabled = function (params) {

        var effectId;

        // Option to replace the set of enabled effects
        if (params.replace) {
            for (var i = 0, len = HumanViewEffects.pipeline.length; i < len; i++) {
                HumanViewEffects.pipeline[i].enabled = false;
            }
        }
        var effect;
        if (params.effectId) {
            effectId = params.effectId;
            effect = HumanViewEffects.effects[effectId];
            if (!effect) {
                Human.log.error("Human.view.effects.setEnabled", "Effect not found: " + effectId);
                return;
            }
            effect.enabled = !!params.enable;
        } else if (params.effectIds) {
            var effectIds = params.effectIds;
            var val;
            for (effectId in effectIds) {
                if (effectIds.hasOwnProperty(effectId)) {
                    effect = HumanViewEffects.effects[effectId];
                    if (!effect) {
                        Human.log.error("Human.view.effects.setEnabled", "Effect not found: " + effectId);
                        continue;
                    }
                    val = effectIds[effectId];
                    effect.enabled = !!val;
                    if (val && typeof val !== "boolean") {
                        // Effect params given
                        effect.setParams(val);
                    }
                }
            }
        }
        dirty = true;
    };

    /**
     * Disables all effects
     */
    HumanViewEffects.clearEnabled = function () {
        for (var i = 0, len = HumanViewEffects.pipeline.length; i < len; i++) {
            HumanViewEffects.pipeline[i].enabled = false;
        }
        dirty = true;
    };

    /**
     * Sets parameters for effects
     * @param params
     */
    HumanViewEffects.setParams = function (params) {
        var effect;
        for (var effectId in params) {
            if (params.hasOwnProperty(effectId)) {
                effect = HumanViewEffects.effects[effectId];
                if (!effect) {
                    Human.log.error("Human.view.effects.setParams", "Effect not found: " + effectId);
                    continue;
                }
                effect.setParams(params[effectId]);
            }
        }
    };

    function createEffectCallback(effect) {
        return function (node) {
            effect.node = node;
        };
    }

    // -------- DEFAULTS -------
    var defaultEffects = {
      anaglyph: false,
      dof: false,
      filmGrain: false,
      oculusRift: false,
      scanlines: false,
      sepia: false,
      stereo: false,
      technicolor: false
    };

    HumanViewEffects.getDefaults = function(){
      return Human.utils.shallowClone(defaultEffects);
    };

    HumanViewEffects.compile = function () {

        if (!dirty) {
            return;
        }

        // Get effects container node
        var scene = Human.renderer.getScene();
        scene.getNode("effect",
            function (container) {
                // Get subtree of that, which contains the scene content
                scene.getNode("effect.subtree",
                    function (subtree) {
                        // Disconnect scene content
                        subtree.disconnect();
                        // Blow away effect nodes
                        container.removeNodes();
                        // Rebuild effect nodes
                        var effect;
                        var json = {
                            nodes: []
                        };
                        var node = json;
                        for (var i = 0, len = HumanViewEffects.pipeline.length; i < len; i++) {
                            effect = HumanViewEffects.pipeline[i];
                            if (effect.enabled) {
                                var child = Human.utils.applyIf(effect.params, {
                                    type: effect.type,
                                    id: "__effects." + effect.effectId,
                                    nodes: []
                                });
                                node.nodes.push(child);
                                node = child;

                                // Save scene node on effect for param updates
                                // See {@link Human.effects.Effect#setParams}
                                scene.getNode("__effects." + effect.effectId,
                                    createEffectCallback(effect));
                            } else {

                                // No scene nodes exist for disabled effects
                                effect.node = null;
                            }
                        }
                        // Append scene content to lowest effect node, thus applying
                        // all the effects to it, in order of each effect on the path
                        // up to the scene root
                        node.nodes.push({ id: "effectsSubTree" });
                        container.addNode(json);
                        scene.getNode("effectsSubTree",
                            function (leaf) {
                                leaf.addNode(subtree);
                            });
                    });
            });
        dirty = false;
    };

})();
;(function() {
    "use strict";


    /**
     * @class A rendering post-effect within {@link Human.view.effects}
     * @param cfg
     * @constructor
     */
    Human.view.effects.Effect = function (cfg) {

        // Call parent class Human.Component init
        this._init();

        /** ID of this effect, unique within {@link Human.view.effects}
         * @type {String}
         */
        this.effectId = cfg.effectId;

        /** Type name of this effect
         * @type {String}
         */
        this.type = cfg.type;

        /**
         * Display name for this effect
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /**
         * Description of this effect
         * @type {String}
         */
        this.description = cfg.description;

        /**
         *
         * @type {boolean}
         */
        this.enabled = false;

        /**
         * Effect parameters
         * @type {{}}
         */
        this.params = cfg.params || {};

        /**
         * Scene node for this effect, non-null while the effect is active.
         * @type {SceneJS.Node}
         */
        this.node = null;
    };

    Human.utils.extend(Human.view.effects.Effect, Human.Component);

    /**
     * Enables or disables this effect
     * @memberof Human.view.effects.Effect
     */
    Human.view.effects.Effect.prototype.setEnabled = function (enabled) {
        this.publish("enabled", this.enabled = enabled);
    };


    /**
     * Configures this effect
     * @memberof Human.view.effects.Effect
     */
    Human.view.effects.Effect.prototype.setParams = function (params) {
        Human.utils.apply(params, this.params);
        if (this.node) {
            // Effect is currently active, update its scene node
            this.node.set(params);
        }
    };

})();
;/**
 * @namespace Manages Highlight mode
 */
(function () {

    "use strict";

    var HumanViewExplode = Human.view.explode = {};

    // How many units each object moves per second when exploding
    var speed = 0.5;

    // Objects currently being exploded
    var objects = [];

    // Map of objects currently being exploded, used to prevent duplicates when building explode list
    var addedObjects = {};

    // Memento of initial transform state for each exploding object
    var origins = [];

    // Memento of initial World-space center of each exploding object
    var centers = [];

    // Vector for each object, indicating direction of movement during explosion
    var vectors = [];

    // Number of objects currently exploding
    var numObjects = 0;

    // World-space center of all exploding objects
    var xCenter = 0;
    var yCenter = 0;
    var zCenter = 0;

    // Current explosion factor
    var xFactor = 0.0;
    var yFactor = 0.0;
    var zFactor = 0.0;

    // Target explosion factor we may be animating towards
    var xFactorTarget;
    var yFactorTarget;
    var zFactorTarget;

    // True when scene objects have been created or destroyed,
    // indicates that we need to add or remove explosion state accordingly, on next animation frame
    var objectsDirty = true;

    // Current explosion status

    var COLLAPSED = 0;      // Objects are at their original positions, ie. explosion is collapsed
    var EXPLODING = 1;      // Objects are at some point between original positions and fully-exploded positions
    var EXPLODED = 2;       // Objects are at fully-exploded positions

    var status = COLLAPSED;

    // True when EXPLODING and we need to recompute
    // the exploding object positions for the next frame
    var explodeDirty = false;

    var objectSpaceVector = vec3.create();

    Human.events.on("scene.objectsShown",
        function () {
            HumanViewExplode.reset();
        });

    // Reset exploding objects back to their initial positions
    // whenever we play or scrub the timeline.

    Human.events.on("timeline.played",
        function () {
            if (status === EXPLODING || status === EXPLODED) {
                HumanViewExplode.reset();
            }
        });

    Human.events.on("timeline.scrubbed",
        function () {
            if (status === EXPLODING || status === EXPLODED) {
                HumanViewExplode.reset();
            }
        });

    Human.events.on("tick",
        function (params) {

            if (explodeDirty) {

                if (objectsDirty) {

                    // Objects were created or destroyed
                    // Add or remove explosion state accordingly

                    getObjects();
                }

                // Update the explosion animation

                var elapsedSecs = (params.timeNow - params.timeLast) * 0.001;

                var delta = elapsedSecs * speed;

                var xSign = (xFactorTarget - xFactor) < 0 ? -1 : 1;
                var ySign = (yFactorTarget - yFactor) < 0 ? -1 : 1;
                var zSign = (zFactorTarget - zFactor) < 0 ? -1 : 1;

                xFactor += delta * xSign;
                yFactor += delta * ySign;
                zFactor += delta * zSign;


                // Clamp explosion factor on each axis

                var maxReached = 0;
                var minReached = 0;

                if (xSign > 0 && xFactor > xFactorTarget) {
                    xFactor = xFactorTarget;
                    maxReached++;

                }

                if (xSign < 0 && xFactor < 0) {
                    xFactor = 0;
                    minReached++;
                }

                if (ySign > 0 && yFactor > yFactorTarget) {
                    yFactor = yFactorTarget;
                    maxReached++;

                }

                if (ySign < 0 && yFactor < 0) {
                    yFactor = 0;
                    minReached++;
                }

                if (zSign > 0 && zFactor > zFactorTarget) {
                    zFactor = zFactorTarget;
                    maxReached++;

                }

                if (zSign < 0 && zFactor < 0) {
                    zFactor = 0;
                    minReached++;
                }

                // Explosion is finished if we just clamped the explosion factors on all three axis,
                // ie. no axis is still animating

                if (maxReached === 3) {
                    status = EXPLODED;
                    explodeDirty = false;

                } else if (minReached === 3) {
                    status = COLLAPSED;
                    explodeDirty = false;
                }

                // Update the positions of the exploding objects
                // Each object is positioned at the end of its
                // explosion vector, multiplied by the explosion factors

                // When COLLAPSED, the explosion vectors will be zero length,
                // which sets the objects back at their initial positions

                var origin;
                var vector;

                for (var i = 0; i < numObjects; i++) {
                    var object = objects[i];
                    var worldToObject = object.getWorldToObjectMatrix();
                    origin = origins[i];
                    vector = vectors[i];

                    objectSpaceVector[0] = vector[0] * xFactor;
                    objectSpaceVector[1] = vector[1] * yFactor;
                    objectSpaceVector[2] = vector[2] * zFactor;
                    vec3.transformMat4(objectSpaceVector, objectSpaceVector, worldToObject);

                    objects[i].setTransform({
                        translate: {
                            x: origin.x + objectSpaceVector[0],
                            y: origin.y + objectSpaceVector[1],
                            z: origin.z + objectSpaceVector[2]
                        }
                    });
                }

                // notify of eplode updated
                Human.events.fire("explode.updated", {
                    scale: Math.round((xFactor + yFactor + zFactor) / 3),
                    speed: speed
                });
            }
        });


    // For each visible scene object:
    //
    // - Set up explosion vectors
    // - Save World-space origin
    // - Save initial translation, to apply when resetting the explosion
    //
    function getObjects() {

        clearObjects();

        var objectId;
        var object;
        var origin;
        var center;
        var vector;
        var translate;

        xCenter = 0;
        yCenter = 0;
        zCenter = 0;

        for (objectId in Human.scene.enabledObjects) {

            if (Human.scene.enabledObjects.hasOwnProperty(objectId)) {

                object = Human.scene.enabledObjects[objectId];

                if (object.objects.length === 0) {

                    while (object && object.anonymous) {
                        object = object.parent;
                    }

                    if (object && object.parent && !isObjectAdded(object)) {

                        objects[numObjects] = object;
                        addedObjects[object.objectId] = object;

                        origin = origins[numObjects];
                        translate = object.translate || {
                            x: 0,
                            y: 0,
                            z: 0
                        };

                        if (!origin) {
                            origin = origins[numObjects] = {
                                x: translate.x,
                                y: translate.y,
                                z: translate.z
                            };
                        } else {
                            origin.x = translate.x;
                            origin.y = translate.y;
                            origin.z = translate.z;
                        }

                        center = object.getCenter();

                        xCenter += center[0];
                        yCenter += center[1];
                        zCenter += center[2];

                        centers[numObjects] = center;

                        numObjects++;
                    }
                }
            }
        }

        if (numObjects > 1) { // Can't explode one object away from itself

            xCenter /= numObjects;
            yCenter /= numObjects;
            zCenter /= numObjects;

            for (var i = 0; i < numObjects; i++) {

                center = centers[i];
                object = objects[i];

                if (!vectors[i]) {
                    vectors[i] = [0,0,0];
                }

                vector = vec3.normalize(vectors[i], [center[0] - xCenter, center[1] - yCenter, center[2] - zCenter]);

                vectors[i] = vector;
            }
        }

        objectsDirty = false;
    }

    function isObjectAdded(object) {
        while (object) {
            if (addedObjects[object.objectId]) {
                return true;
            }
            object = object.parent;
        }
        return false;
    }

    function clearObjects() {
        for (var i = 0; i < numObjects; i++) {
            delete addedObjects[objects[i].objectId];
        }
        numObjects = 0;
    }

    /**
     * Explodes the currently visible scene objects
     *
     * @param [params=[]] Explosion parameters
     * @param [params.scale=2.0] Explosion scale - for each object, the initial position will be multiplied by this to find the final position.
     * @param [params.speed=1.0] Explosion speed - how much the explosion scale grows per second.
     */
    HumanViewExplode.explode = function (params) {

        params = params || {};

        var scale = params.scale;

        if (!Human.utils.isArray(scale)) {

            scale = scale || 0.0;

            if (scale < 0.0) {
                scale = 0.0;
            }

            xFactorTarget = scale;
            yFactorTarget = scale;
            zFactorTarget = scale;

        } else {

            xFactorTarget = scale[0];
            yFactorTarget = scale[1];
            zFactorTarget = scale[2];
        }

        if (xFactorTarget < 0.0) {
            xFactorTarget = 0.0;
        }

        if (yFactorTarget < 0.0) {
            yFactorTarget = 0.0;
        }

        if (zFactorTarget < 0.0) {
            zFactorTarget = 0.0;
        }

        speed = params.speed || 1.0;

        if (speed < 0.0) {
            speed = 1.0;
        }

        Human.timeline.stop();

        status = EXPLODING;

        explodeDirty = true;
    };

    /**
     * Resets the explosion back to initial state, with no animation.
     */
    HumanViewExplode.reset = function () {

        // Reset explosion parameters

        xFactor = 0;
        yFactor = 0;
        zFactor = 0;

        xFactorTarget = 0;
        yFactorTarget = 0;
        zFactorTarget = 0;

        // Restore each exploding object to initial position

        if (numObjects) {
            this._resetPositions();
        }

        // Stop explosion

        status = COLLAPSED;

        // Clear the list of exploding objects

        clearObjects();

        // We'll need to rebuild the list
        // next time we do an explode

        objectsDirty = true;

        explodeDirty = false;

        // fire reset statee
        Human.events.fire("explode.reseted", {
            scale: 0,
            speed: speed
        });
    };

    /**
     * Restores initial transform state of each exploding object
     */
    HumanViewExplode._resetPositions = function () {

        var origin;

        for (var i = 0; i < numObjects; i++) {

            origin = origins[i];

            objects[i].setTransform({
                translate: origin
            });
        }
    };

})();
;/**
 * @namespace
 */
(function () {
    "use strict";

    var HumanInput = Human.input = {
        mouseHoverDelay: 500,
        mouseOrbitRate: 0.4,
        mousePanRate: 0.2,
        mouseZoomRate: 0.5,
        keyboardOrbitRate: 140, 
        keyboardPanRate:  40,
        keyboardZoomRate: 15,
        touchOrbitRate: 0.3, 
        touchPanRate:  0.2,
        touchZoomRate: 0.05,
        cameraFriction: 0.85
    };

    var canvas = Human.renderer.canvas.annotationCanvas;
    var domCanvas = canvas[0];
    var handlers = [];
    var tickSubs = [];
    var keyDownSubs = {};
    var keyUpSubs = {};
    var mouseDownSubs = [];
    var mouseUpSubs = [];
    var mouseClickSubs = [];
    var mouseDoubleClickSubs = [];
    var mouseMoveSubs = [];
    var mouseWheelSubs = [];
    var resetSubs = [];
    var enabled = true;

    // TOUCH
    var touchStartSubs = [];
    var touchMoveSubs = [];
    var touchEndSubs = [];
    var touchTapSubs = [];
    var touchDoubleTapSubs = [];
    var TAP_INTERVAL = 150;
    var DBL_TAP_INTERVAL = 325;
    var TAP_DISTANCE_THRESHOLD = 4;

    var $document = jQuery(document);

    $document.ready(function () {
        // Disable context menu throughout document.
        $document.bind("contextmenu", function (event) {
            //Well, except for the snapshot image and text fields.
            if (event.target.id !== "snapshotPanelImage" &&
                event.target.type !== "input" &&
                event.target.type !== "email" &&
                event.target.type !== "text" &&
                event.target.type !== "textarea") {
                return false;
            }
        });
    });

    // Context given to each handler
    var ctx = {

        // True when ALT down
        altDown: false,

        // True when CTL down
        ctrlDown: false,

        // Flag for each key currently down
        keyDown: [],

        // Subscribe to periodic engine tick event
        onTick: function (fn) {
            tickSubs.push(fn);
        },

        // Subscribe to key down event
        onKeyDown: function (keys, fn) {
            var key;
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                (keyDownSubs[key] || (keyDownSubs[key] = [])).push(fn);
            }
        },

        // Subscribe to key up event
        onKeyUp: function (keys, fn) {
            var key;
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                (keyUpSubs[key] || (keyUpSubs[key] = [])).push(fn);
            }
        },

        // Subscribe to mouse down event
        onMouseDown: function (fn) {
            mouseDownSubs.push(fn);
        },

        // Subscribe to mouse up event
        onMouseUp: function (fn) {
            mouseUpSubs.push(fn);
        },

        // Subscribe to mouse click event
        onMouseClick: function (fn) {
            mouseClickSubs.push(fn);
        },

        // Subscribe to mouse doubleClick event
        onMouseDoubleClick: function (fn) {
            mouseDoubleClickSubs.push(fn);
        },

        // Subscribe to mouse move event
        onMouseMove: function (fn) {
            mouseMoveSubs.push(fn);
        },

        // Subscribe to mouse wheel event
        onMouseWheel: function (fn) {
            mouseWheelSubs.push(fn);
        },

        // Subscribe to reset
        onReset: function (fn) {
            resetSubs.push(fn);
        },

        // Subscribe to touch start
        onTouchStart: function (fn) {
            touchStartSubs.push(fn);
        },

        // Subscribe to touch move
        onTouchMove: function (fn) {
            touchMoveSubs.push(fn);
        },

        // Subscribe to touch end
        onTouchEnd: function (fn) {
            touchEndSubs.push(fn);
        },

        // Subscribe to touch tap
        onTouchTap: function (fn) {
            touchTapSubs.push(fn);
        },
        onTouchDoubleTap: function (fn) {
            touchDoubleTapSubs.push(fn);
        }
    };

    var lastTime = null;
    Human.events.on(
        "tick",
        function () {
            if (!enabled) {
                lastTime = null;
                return;
            }
            var time = Date.now() / 1000;
            if (lastTime !== null) {
                var elapsed = time - lastTime;
                for (var i = 0, len = tickSubs.length; i < len; i++) {
                    tickSubs[i](time, elapsed);
                }
            }
            lastTime = time;
        });

    document.addEventListener("keydown",
        function (e) {
            if (!enabled) {
                return;
            }
            if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                ctx.ctrlDown = e.ctrlKey || e.keyCode === 17 || e.metaKey; // !important, treat Windows or Mac Command Key as ctrl
                ctx.altDown = e.altKey || e.keyCode === 18;
                ctx.keyDown[e.keyCode] = true;
                var code = e.keyCode;
                var subs = keyDownSubs[code];
                if (subs) {
                    for (var i = 0, len = subs.length; i < len; i++) {
                        subs[i](code);
                    }
                }
            }
        }, true);

    document.addEventListener("keyup",
        function (e) {
            if (!enabled) {
                return;
            }
            if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                if (e.ctrlKey || e.keyCode === 17) {
                    ctx.ctrlDown = false;
                }
                if (e.altKey || e.keyCode === 18) {
                    ctx.altDown = false;
                }
                ctx.keyDown[e.keyCode] = false;
                var code = e.keyCode;
                var subs = keyUpSubs[code];
                if (subs) {
                    for (var i = 0, len = subs.length; i < len; i++) {
                        subs[i](code);
                    }
                }
            }
        });

    canvas.mousedown(
        function (e) {
            switch (e.which) {
                case 1: // Left button
                    ctx.mouseDownLeft = true;
                    break;
                case 2: // Middle/both buttons
                    ctx.mouseDownMiddle = true;
                    break;
                case 3: // Right button
                    ctx.mouseDownRight = true;
                    break;
                default:
                    break;
            }
            var coords = getClickCoordsWithinElement(e);
            ctx.mouseDownX = coords.x;
            ctx.mouseDownY = coords.y;
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseDownSubs.length; i < len; i++) {
                mouseDownSubs[i](x, y);
            }
        });

    canvas.mouseup(
        function (e) {
            switch (e.which) {
                case 1: // Left button
                    ctx.mouseDownLeft = false;
                    break;
                case 2: // Middle/both buttons
                    ctx.mouseDownMiddle = false;
                    break;
                case 3: // Right button
                    ctx.mouseDownRight = false;
                    break;
                default:
                    break;
            }
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseUpSubs.length; i < len; i++) {
                mouseUpSubs[i](x, y);
            }
        });

    canvas.click(
        function (e) {
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseClickSubs.length; i < len; i++) {
                mouseClickSubs[i](x, y);
            }
        });

    canvas.dblclick(
        function (e) {
            switch (e.which) {
                case 1: // Left button
                    ctx.mouseDownLeft = false;
                    ctx.mouseDownRight = false;
                    break;
                case 2: // Middle/both buttons
                    ctx.mouseDownMiddle = false;
                    break;
                case 3: // Right button
                    ctx.mouseDownLeft = false;
                    ctx.mouseDownRight = false;
                    break;
                default:
                    break;
            }
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseDoubleClickSubs.length; i < len; i++) {
                mouseDoubleClickSubs[i](x, y);
            }
        });

    canvas.mousemove(
        function (e) {
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseMoveSubs.length; i < len; i++) {
                mouseMoveSubs[i](x, y);
            }
        });

    canvas.bind("mousewheel",
        function (event, d) {
            for (var i = 0, len = mouseWheelSubs.length; i < len; i++) {
                mouseWheelSubs[i](event, d / Math.abs(d));
            }
        });

    Human.properties.subscribe({
        propId: "ui.mouseWheel.capture",
        value: true,
        callback: function (value) {
            // stop mousewheel propagation upwards to any parent windows
            $document[value ? 'on' : 'off']("mousewheel.capture", captureEvent);
        }
    });

    function captureEvent(event) {
        // constrain to canvas elements
        if ($(event.target).is("canvas")) {
            event.stopPropagation();
            event.preventDefault();
        }
    }

    function getClickCoordsWithinElement(event) {
        var coords = { x: 0, y: 0 };
        if (!event) {
            event = window.event;
            coords.x = event.x;
            coords.y = event.y;
        }
        else {
            var element = event.target;
            var totalOffsetLeft = 0;
            var totalOffsetTop = 0;

            while (element.offsetParent) {
                totalOffsetLeft += element.offsetLeft;
                totalOffsetTop += element.offsetTop;
                element = element.offsetParent;
            }
            coords.x = event.pageX - totalOffsetLeft;
            coords.y = event.pageY - totalOffsetTop;
        }
        return coords;
    }

    var blockUI = {
        EVENTS: 'mousedown mouseup keydown keypress',
        handler: function () {
            return false;
        },
        block: function () {
            $('<div class="block-ui"></div>')
                .css({
                    position: 'absolute',
                    top: 0,
                    left: 0,
                    width: '100%',
                    height: '100%',
                    'z-index': 1000
                })
                .appendTo('body');

            $document.on(this.EVENTS, this.handler);
        },
        unblock: function () {
            $('body > .block-ui').remove();

            $document.off(this.EVENTS, this.handler);
        }
    };

    /**
     * Add a handler
     * @param handler
     */
    HumanInput.addHandler = function (Handler) {
        handlers.push(new Handler(ctx));
    };

    /**
     * Enables or disables user input
     */
    HumanInput.setEnabled = function (enable) {
        if (enabled !== enable) {
            if (enable) {
                // Block/unblock UI
                blockUI.unblock();
            } else {
                // Invisible overlay because our progress bar would be dimmed otherwise
                blockUI.block();
            }
            enabled = enable;
            Human.events.fire(enable ? "inputEnabled" : "inputDisabled", {});
        }
    };

    /* Touch Support */

    var touchStartTime;
    var activeTouches = [];
    var tapStartPos = vec2.create();
    var tapStartTime = -1;
    var lastTapTime = -1;

    domCanvas.addEventListener("touchstart", function(event) {
        var touches = event.touches;
        var changedTouches = event.changedTouches;

        var i, len;

        touchStartTime = Date.now();
        
        if (touches.length === 1 && changedTouches.length === 1) {
            tapStartTime = touchStartTime;
            tapStartPos[0] = touches[0].pageX;
            tapStartPos[1] = touches[0].pageY;
        } else {
            tapStartTime = -1;
        }
        

        while (activeTouches.length < touches.length) {
            activeTouches.push(vec2.create());
        }

        for (i = 0, len = touches.length; i < len; ++i) {
            activeTouches[i][0] = touches[i].pageX;
            activeTouches[i][1] = touches[i].pageY;
        }

        activeTouches.length = touches.length;

        function preventPageDefaults() {
            event.preventDefault();
            event.stopPropagation();
        }

        for (i = 0, len = touchStartSubs.length; i < len; ++i) {
            touchStartSubs[i](activeTouches, preventPageDefaults);
        }
    });

    domCanvas.addEventListener("touchmove", function(event) {
        var touches = event.touches;
        var i, len;

        for (i = 0, len = touches.length; i < len; ++i) {
            activeTouches[i][0] = touches[i].pageX;
            activeTouches[i][1] = touches[i].pageY;
        }

        function preventPageDefaults() {
            event.preventDefault();
            event.stopPropagation();
        }

        for (i = 0, len = touchMoveSubs.length; i < len; ++i) {
            touchMoveSubs[i](activeTouches, preventPageDefaults);
        }

    });

    domCanvas.addEventListener("touchend", function(event) {
        var currentTime = Date.now();
        var touches = event.touches;
        var changedTouches = event.changedTouches;

        var i, len;

        function preventPageDefaults() {
            event.preventDefault();
            event.stopPropagation();
        }

        // process tap
        if (touches.length === 0 && changedTouches.length === 1) {
            if (tapStartTime > -1 && currentTime - tapStartTime < TAP_INTERVAL) {
                // check for dbl tap
                if (lastTapTime > -1 && tapStartTime - lastTapTime < DBL_TAP_INTERVAL) {
                    for (i = 0, len = touchDoubleTapSubs.length; i < len; ++i) {
                        touchDoubleTapSubs[i](changedTouches[0].pageX, changedTouches[0].pageY, preventPageDefaults);
                    }
                    lastTapTime = -1;
                } else if (vec2.distance(activeTouches[0], tapStartPos) < TAP_DISTANCE_THRESHOLD) {
                    lastTapTime = currentTime;
                    for (i = 0, len = touchTapSubs.length; i < len; ++i) {
                        touchTapSubs[i](changedTouches[0].pageX, changedTouches[0].pageY, preventPageDefaults);
                    }
                }
                tapStartTime = -1;
            }
        }
        
        for (i = 0, len = touches.length; i < len; ++i) {
            activeTouches[i][0] = touches[i].pageX;
            activeTouches[i][1] = touches[i].pageY;
        }

        activeTouches.length = touches.length;

        for (i = 0, len = touchEndSubs.length; i < len; ++i) {
            touchEndSubs[i](activeTouches, preventPageDefaults);
        }
    });

    // Key codes

    HumanInput.KEY_BACKSPACE = 8;
    HumanInput.KEY_TAB = 9;
    HumanInput.KEY_ENTER = 13;
    HumanInput.KEY_SHIFT = 16;
    HumanInput.KEY_CTRL = 17;
    HumanInput.KEY_ALT = 18;
    HumanInput.KEY_PAUSE_BREAK = 19;
    HumanInput.KEY_CAPS_LOCK = 20;
    HumanInput.KEY_ESCAPE = 27;
    HumanInput.KEY_PAGE_UP = 33;
    HumanInput.KEY_PAGE_DOWN = 34;
    HumanInput.KEY_END = 35;
    HumanInput.KEY_HOME = 36;
    HumanInput.KEY_LEFT_ARROW = 37;
    HumanInput.KEY_UP_ARROW = 38;
    HumanInput.KEY_RIGHT_ARROW = 39;
    HumanInput.KEY_DOWN_ARROW = 40;
    HumanInput.KEY_INSERT = 45;
    HumanInput.KEY_DELETE = 46;
    HumanInput.KEY_NUM_0 = 48;
    HumanInput.KEY_NUM_1 = 49;
    HumanInput.KEY_NUM_2 = 50;
    HumanInput.KEY_NUM_3 = 51;
    HumanInput.KEY_NUM_4 = 52;
    HumanInput.KEY_NUM_5 = 53;
    HumanInput.KEY_NUM_6 = 54;
    HumanInput.KEY_NUM_7 = 55;
    HumanInput.KEY_NUM_8 = 56;
    HumanInput.KEY_NUM_9 = 57;
    HumanInput.KEY_A = 65;
    HumanInput.KEY_B = 66;
    HumanInput.KEY_C = 67;
    HumanInput.KEY_D = 68;
    HumanInput.KEY_E = 69;
    HumanInput.KEY_F = 70;
    HumanInput.KEY_G = 71;
    HumanInput.KEY_H = 72;
    HumanInput.KEY_I = 73;
    HumanInput.KEY_J = 74;
    HumanInput.KEY_K = 75;
    HumanInput.KEY_L = 76;
    HumanInput.KEY_M = 77;
    HumanInput.KEY_N = 78;
    HumanInput.KEY_O = 79;
    HumanInput.KEY_P = 80;
    HumanInput.KEY_Q = 81;
    HumanInput.KEY_R = 82;
    HumanInput.KEY_S = 83;
    HumanInput.KEY_T = 84;
    HumanInput.KEY_U = 85;
    HumanInput.KEY_V = 86;
    HumanInput.KEY_W = 87;
    HumanInput.KEY_X = 88;
    HumanInput.KEY_Y = 89;
    HumanInput.KEY_Z = 90;
    HumanInput.KEY_LEFT_WINDOW = 91;
    HumanInput.KEY_RIGHT_WINDOW = 92;
    HumanInput.KEY_SELECT_KEY = 93;
    HumanInput.KEY_NUMPAD_0 = 96;
    HumanInput.KEY_NUMPAD_1 = 97;
    HumanInput.KEY_NUMPAD_2 = 98;
    HumanInput.KEY_NUMPAD_3 = 99;
    HumanInput.KEY_NUMPAD_4 = 100;
    HumanInput.KEY_NUMPAD_5 = 101;
    HumanInput.KEY_NUMPAD_6 = 102;
    HumanInput.KEY_NUMPAD_7 = 103;
    HumanInput.KEY_NUMPAD_8 = 104;
    HumanInput.KEY_NUMPAD_9 = 105;
    HumanInput.KEY_MULTIPLY = 106;
    HumanInput.KEY_ADD = 107;   // numeric keypad
    HumanInput.KEY_SUBTRACT = 109;  // numeric keypad
    HumanInput.KEY_DECIMAL_POINT = 110;
    HumanInput.KEY_DIVIDE = 111;
    HumanInput.KEY_F1 = 112;
    HumanInput.KEY_F2 = 113;
    HumanInput.KEY_F3 = 114;
    HumanInput.KEY_F4 = 115;
    HumanInput.KEY_F5 = 116;
    HumanInput.KEY_F6 = 117;
    HumanInput.KEY_F7 = 118;
    HumanInput.KEY_F8 = 119;
    HumanInput.KEY_F9 = 120;
    HumanInput.KEY_F10 = 121;
    HumanInput.KEY_F11 = 122;
    HumanInput.KEY_F12 = 123;
    HumanInput.KEY_NUM_LOCK = 144;
    HumanInput.KEY_SCROLL_LOCK = 145;
    HumanInput.KEY_SEMI_COLON = 186;
    HumanInput.KEY_EQUAL_SIGN = 187;
    HumanInput.KEY_EQUAL_SIGN_FIREFOX = 61;
    HumanInput.KEY_DASH_FIREFOX = 173;
    HumanInput.KEY_COMMA = 188;
    HumanInput.KEY_DASH = 189;
    HumanInput.KEY_PERIOD = 190;
    HumanInput.KEY_FORWARD_SLASH = 191;
    HumanInput.KEY_GRAVE_ACCENT = 192;
    HumanInput.KEY_OPEN_BRACKET = 219;
    HumanInput.KEY_BACK_SLASH = 220;
    HumanInput.KEY_CLOSE_BRAKET = 221;
    HumanInput.KEY_SINGLE_QUOTE = 222;
    HumanInput.KEY_SPACE = 32;

})();
;/**
 * Handles mouse drags
 *
 * On mouse down:
 *
 *      if not in annotation mode
 *          orbit camera
 *
 *      else
 *          if object picked
 *
 *              create an annotation with a "mouseDownPos" attribute,
 *              which signifies to the "draggable" layout manager that
 *              the annotation was just now created by a mousedown event.
 *
 *              The layout manager will then track any subsequent
 *              mousemove events until the next mouseup, to update the
 *              label offset as the user drags the mouse.
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var draggingLabel = false;

        var x1 = null;
        var y1 = null;

        var object, objectId;
        var hit;

        var annotations = Human.view.annotations;

        ctx.onMouseClick(function (x, y) {

            if (!draggingLabel) {

                x1 = x;
                y1 = y;

                if (annotations.enabled) {

                    hit = Human.view.pick.queryPick({
                        canvasX: x,
                        canvasY: y,
                        rayPick: true
                    });

                    if (hit) {

                        objectId = hit.name;
                        object = Human.scene.objects[objectId];

                        if (object) {
                            draggingLabel = true;

                            Human.view.annotations.drawWire(x, y, x, y);

                            hit.objectId = objectId;
                            hit.pos = hit.worldPos;

                            Human.events.fire("annotations.pinning", hit);
                            Human.view.annotations.beginCreation();
                        }

                    }
                }

            } else {

                objectId = hit.name;
                object = Human.scene.objects[objectId];

                if (object) {

                    var eye = Human.view.camera.eye;

                    var eyeVec = new Float32Array(3);

                    eyeVec[0] = eye.x - hit.worldPos[0];
                    eyeVec[1] = eye.y - hit.worldPos[1];
                    eyeVec[2] = eye.z - hit.worldPos[2];

                    vec3.normalize(eyeVec, eyeVec);

                    Human.view.annotations.createAnnotation({
                        objectId: objectId,
                        title: "",
                        description: "",
                        pos: hit.worldPos,
                        dir: eyeVec,
                        primitiveIndex: hit.primitiveIndex,
                        barycentric: hit.barycentric,
                        enabled: true,
                        shown: true,
                        labelShown: true,
                        labelOffset: [x - hit.canvasPos[0], y - hit.canvasPos[1] - 30],
                        saved: false
                    });
                }

                Human.view.annotations.clearWire();

                hit = false;
                draggingLabel = false;
            }
        });

        ctx.onMouseMove(function (x, y) {
            if (draggingLabel) {
                Human.view.annotations.drawWire(x1, y1, x, y);
            }
        });

    });
;(function () {
    "use strict";

    var cameraRotateX = Human.view.camera.rotateX;
    var cameraRotateY = Human.view.camera.rotateY;

    var rotateVx = 0;
    var rotateVy = 0;
    var panVx = 0;
    var panVy = 0;
    var vZoom = 0;

    var EPSILON = 0.001;

    // --------Mouse-----------

    /**
     * Pans or orbits camera with mouse drags
     */

    var mouseCameraOrbit = true;

    Human.properties.subscribe({
        propId: "input.mouseOrbitPan",
        value: "orbit",
        callback: function (value) {
            mouseCameraOrbit = value === "orbit";
        }
    });

    Human.events.on("tick", function () {
        var friction = Human.input.cameraFriction;

        rotateVx *= friction;
        rotateVy *= friction;

        if (Math.abs(rotateVx) < EPSILON) {
            rotateVx = 0;   
        }

        if (Math.abs(rotateVy) < EPSILON) {
            rotateVy = 0;   
        }

        if (rotateVx !== 0) {
            cameraRotateX(rotateVx);
        }

        if (rotateVy !== 0) {
            cameraRotateY(rotateVy);
        }

        panVx *= friction;
        panVy *= friction;

        if (Math.abs(panVx) < EPSILON) {
            panVx = 0;   
        }

        if (Math.abs(panVy) < EPSILON) {
            panVy = 0;   
        }

        if (panVx !== 0 || panVy !== 0) {
            var f = Math.max(Human.view.camera.lookDistance / 80, 0.01);
            Human.view.camera.pan({
                x: panVx * f,
                y: panVy * f
            });
        }

        vZoom *= friction;

        if (Math.abs(vZoom) < EPSILON) {
            vZoom = 0;   
        }

        if (vZoom !== 0) {
            Human.view.camera.zoom(vZoom);
        }


    });

    Human.input.addHandler(
        function (ctx) {

            var lastX;
            var lastY;
            var xDelta = 0;
            var yDelta = 0;
            var down = false;

            ctx.onMouseDown(function (x, y) {
                // Only left mouse down starts pan/orbit
                down = true;
                lastX = x;
                lastY = y;
            });

            ctx.onMouseUp(function () {
                down = (ctx.mouseDownLeft || ctx.mouseDownMiddle || ctx.mouseDownRight);
            });

            ctx.onMouseMove(function (x, y) {
                if (down) {
                    xDelta += (x - lastX) * Human.input.mouseOrbitRate;
                    yDelta += (y - lastY) * Human.input.mouseOrbitRate;
                    lastX = x;
                    lastY = y;
                }
            });

            ctx.onTick(function () {
                if (Math.abs(xDelta) > 0 || Math.abs(yDelta) > 0) {

                    // When in pan mode, shift-drag should orbit, when in orbit mode, shift-drag should pan.
                    var switchMode =  ctx.keyDown[Human.input.KEY_SHIFT] ||
                        ctx.mouseDownMiddle ||
                        (ctx.mouseDownLeft && ctx.mouseDownRight);

                    var mode = switchMode ? !mouseCameraOrbit : mouseCameraOrbit;

                    if (mode) {

                        // Orbiting

                        rotateVy = -xDelta * Human.input.mouseOrbitRate;
                        rotateVx = yDelta * Human.input.mouseOrbitRate;

                    } else {
                        panVx = xDelta * Human.input.mousePanRate;
                        panVy = yDelta * Human.input.mousePanRate;
                    }


                    xDelta = 0;
                    yDelta = 0;
                }
            });
        });

    /**
     * Zoom camera with mouse wheel
     */

    var cameraZoomMouseWheelEnabled = true;

    Human.properties.subscribe({
        propId: "ui.zoom.mouseWheel.enabled",
        value: cameraZoomMouseWheelEnabled,
        callback: function (value) {
            cameraZoomMouseWheelEnabled = !!value;
        }
    });

    Human.input.addHandler(
        function (ctx) {

            var altDown = false;

            ctx.onKeyDown([
                    Human.input.KEY_ALT
                ],
                function () {
                    altDown = true;
                });

            ctx.onKeyUp([
                    Human.input.KEY_ALT
                ],
                function () {
                    altDown = false;
                });

            ctx.onMouseWheel(function (event, d) {

                if (!cameraZoomMouseWheelEnabled) {
                    return;
                }

                if (altDown) { // ALT is used for exploding with mousewheel
                    return;
                }

                vZoom = -d * Human.input.mouseZoomRate;
            });
        });







    // ---------Keyboard-----------

    /**
     * Orbits camera with keyboard
     */
    Human.input.addHandler(
        function (ctx) {

            ctx.onTick(
                function (time, elapsed) {
                    if (!ctx.ctrlDown && !ctx.altDown) {
                        var left = ctx.keyDown[Human.input.KEY_LEFT_ARROW];
                        var right = ctx.keyDown[Human.input.KEY_RIGHT_ARROW];
                        var up = ctx.keyDown[Human.input.KEY_UP_ARROW];
                        var down = ctx.keyDown[Human.input.KEY_DOWN_ARROW];
                        if (left || right || up || down) {
                            var yaw = 0;
                            var pitch = 0;
                            if (right) {
                                yaw = -elapsed * Human.input.keyboardOrbitRate;
                            } else if (left) {
                                yaw = (elapsed * Human.input.keyboardOrbitRate);
                            }
                            if (down) {
                                pitch = -(elapsed * Human.input.keyboardOrbitRate);
                            } else if (up) {
                                pitch = (elapsed * Human.input.keyboardOrbitRate);
                            }
                            if (Math.abs(yaw) > Math.abs(pitch)) {
                                pitch = null;
                            } else {
                                yaw = null;
                            }

                            rotateVy = yaw;
                            rotateVx = pitch;
                        }
                    }
                });
        });

    /**
     * Pans camera with keyboard
     */
    Human.input.addHandler(
        function (ctx) {

            ctx.onTick(
                function (time, elapsed) {
                    if (!ctx.ctrlDown && !ctx.altDown) {
                        var w = ctx.keyDown[Human.input.KEY_W];
                        var s = ctx.keyDown[Human.input.KEY_S];
                        var a = ctx.keyDown[Human.input.KEY_A];
                        var d = ctx.keyDown[Human.input.KEY_D];
                        if (w || s || a || d) {
                            var x = 0;
                            var y = 0;

                            if (s) {
                                y = elapsed * Human.input.keyboardPanRate;
                            } else if (w) {
                                y = -elapsed * Human.input.keyboardPanRate;
                            }
                            if (d) {
                                x = elapsed * Human.input.keyboardPanRate;
                            } else if (a) {
                                x = -elapsed * Human.input.keyboardPanRate;
                            }
                            
                            panVx = x;
                            panVy = y;
                        }
                    }
                });
        });

    /**
     * Zooms camera with keyboard
     */
    Human.input.addHandler(
        function (ctx) {

            ctx.onTick(
                function (time, elapsed) {
                    if (!ctx.ctrlDown && !ctx.altDown) {
                        var z = ctx.keyDown[Human.input.KEY_ADD] ||
                            ctx.keyDown[Human.input.KEY_EQUAL_SIGN] ||
                            ctx.keyDown[Human.input.KEY_EQUAL_SIGN_FIREFOX];
                        var x = ctx.keyDown[Human.input.KEY_SUBTRACT] ||
                            ctx.keyDown[Human.input.KEY_DASH] ||
                            ctx.keyDown[Human.input.KEY_DASH_FIREFOX];
                        if (z || x) {
                            var delta = z ? -(elapsed * Human.input.keyboardZoomRate) : elapsed * Human.input.keyboardZoomRate;
                            vZoom = delta;
                        }
                    }
                });
        });

    /**
     * Selects predefined camera with keyboard
     */
    Human.input.addHandler(
        function (ctx) {
            ctx.onKeyDown([
                Human.input.KEY_NUM_1,
                Human.input.KEY_NUM_2,
                Human.input.KEY_NUM_3,
                Human.input.KEY_NUM_4,
                Human.input.KEY_NUM_5,
                Human.input.KEY_NUM_6
            ],
                function (key) {
                    if (!ctx.ctrlDown && !ctx.altDown) {
                        var camera = Human.view.camera;
                        if (key === Human.input.KEY_NUM_1) {
                            camera.viewAnterior();
                        } else if (key === Human.input.KEY_NUM_2) {
                            camera.viewPosterior();
                        } else if (key === Human.input.KEY_NUM_3) {
                            camera.viewRight();
                        } else if (key === Human.input.KEY_NUM_4) {
                            camera.viewLeft();
                        } else if (key === Human.input.KEY_NUM_5) {
                            camera.viewSuperior();
                        } else if (key === Human.input.KEY_NUM_6) {
                            camera.viewInferior();
                        }
                    }
                });
        });




    //-----------Touch-------------

    /**
     * Touch to interact with the camera
     */
    Human.input.addHandler(
        function (ctx) {
            
            var lastTouches = [];
            var numTouches = 0;

            var touch1Vec = vec2.create();
            var touch2Vec = vec2.create();

            var MODE_CHANGE_TIMEOUT = 50;
            var MODE_NONE   = 0;
            var MODE_ROTATE = 1;
            var MODE_PAN    = 1 << 1;
            var MODE_ZOOM   = 1 << 2;
            var currentMode = MODE_NONE;
            var transitionTime = Date.now();

            function checkMode(mode) {
                var currentTime = Date.now();

                if (currentMode === MODE_NONE) {
                    currentMode = mode;
                    return true;
                }

                if (currentMode === mode) {
                    return currentTime - transitionTime > MODE_CHANGE_TIMEOUT;
                }

                currentMode = mode;
                transitionTime = currentTime;                
                return false;
            }

            ctx.onTouchStart(function (touches) {
                while (lastTouches.length < touches.length) {
                    lastTouches.push(vec2.create());
                }

                for (var i = 0, len = touches.length; i < len; ++i) {
                    lastTouches[i][0] = touches[i][0];
                    lastTouches[i][1] = touches[i][1];
                }

                currentMode = MODE_NONE;
                numTouches = touches.length;
            });

            // camera rotation
            ctx.onTouchMove(function (touches, preventPageDefaults) {
                if (numTouches === 1) {
                    preventPageDefaults();

                    if (checkMode(MODE_ROTATE)) {
                        var deltaX = touches[0][0] - lastTouches[0][0];
                        var deltaY = touches[0][1] - lastTouches[0][1];
                        var rotateX = deltaX * Human.input.touchOrbitRate;
                        var rotateY = deltaY * Human.input.touchOrbitRate;
                        rotateVx = rotateY;
                        rotateVy = -rotateX;
                    }
                } else if (numTouches === 2) {
                    preventPageDefaults();
                    vec2.sub(touch1Vec, touches[0], lastTouches[0]);
                    vec2.sub(touch2Vec, touches[1], lastTouches[1]);
                    
                    var panning = vec2.dot(touch1Vec, touch2Vec) > 0;
                    
                    if (panning && checkMode(MODE_PAN)) {
                        vec2.sub(touch1Vec, touches[0], lastTouches[0]);
                        panVx = touch1Vec[0] * Human.input.touchPanRate;
                        panVy = touch1Vec[1] * Human.input.touchPanRate;
                    } 

                    if (!panning && checkMode(MODE_ZOOM)) {
                        var d1 = vec2.distance(touches[0], touches[1]);
                        var d2 = vec2.distance(lastTouches[0], lastTouches[1]);

                        vZoom = (d2 - d1) * Human.input.touchZoomRate;
                    }
                }
                
                for (var i = 0; i < numTouches; ++i) {
                    lastTouches[i][0] = touches[i][0];
                    lastTouches[i][1] = touches[i][1];
                }  
            });

            ctx.onTouchEnd(function (touches) {
                for (var i = 0, len = touches.length; i < len; ++i) {
                    lastTouches[i][0] = touches[i][0];
                    lastTouches[i][1] = touches[i][1];
                }
                
                currentMode = MODE_NONE;
                numTouches = touches.length;
            });

        });


})();
;Human.input.addHandler(
    function (ctx) {
        "use strict";

        var lastX = null;
        var lastY = null;
        var tolerance = 4; // Pixels
        var timeout = null;
        var mouseDown = false;

        ctx.onReset(function () {
            reset();
        });

        function reset() {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            lastX = null;
            lastY = null;
            Human.view.pick.hoverOff();
        }

        ctx.onMouseMove(function (x, y) {
            if (mouseDown) {
                return;
            }
            if (lastX !== null) {
                if (Math.abs(x - lastX) > tolerance || Math.abs(y - lastY) > tolerance) {
                    reset();
                } else {
                    if (timeout) {
                        clearTimeout(timeout);
                        timeout = null;
                    }
                    Human.view.pick.hoverOff();
                    timeout = setTimeout(
                        function () {
                            Human.view.pick.hoverPick({ canvasX: x, canvasY: y });
                            clearTimeout(timeout);
                            timeout = null;
                            lastX = null;
                            lastY = null;
                        }, Human.input.mouseHoverDelay );
                }
            }
            lastX = x;
            lastY = y;
        });

        ctx.onMouseDown(function () {
            reset();
            mouseDown = true;
        });

        ctx.onMouseUp(function (x, y) {
            lastX = x;
            lastY = y;
            mouseDown = false;
        });
    });;Human.input.addHandler(
    function (ctx) {
        "use strict";

        var lastX = null;
        var lastY = null;
        var tolerance = 4;
        var picked = false;
        var doubleClicked = false;
        var mouseDownLeft = false;
        var mouseDownRight = false;
        var spaceDown = false;
        var ctrlDown = false;
        var rDown = false;
        var pickX;
        var pickY;

        ctx.onKeyDown([
                Human.input.KEY_SHIFT
            ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.CTRL) {
                    switch (key) {
                        case Human.input.KEY_SHIFT:
                            Human.view.pick.setMultiPickEnabled(true);
                            break;
                    }
                }
            });

        ctx.onKeyUp([
                Human.input.KEY_SHIFT
            ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.CTRL) {
                    switch (key) {
                        case Human.input.KEY_SHIFT:
                            Human.view.pick.setSinglePickEnabled(true);
                            break;
                    }
                }
            });

        ctx.onKeyDown([
                Human.input.KEY_SPACE
            ],
            function () {
                spaceDown = true;
            });

        ctx.onKeyUp([
                Human.input.KEY_SPACE
            ],
            function () {
                spaceDown = false;
            });

        ctx.onKeyDown([
                Human.input.KEY_CTRL
            ],
            function () {
                ctrlDown = true;
            });

        ctx.onKeyUp([
                Human.input.KEY_CTRL
            ],
            function () {
                ctrlDown = false;
            });

        ctx.onKeyDown([
                Human.input.KEY_R
            ],
            function () {
                rDown = true;
            });

        ctx.onKeyUp([
                Human.input.KEY_R
            ],
            function () {
                rDown = false;
            });

        ctx.onMouseDown(function (x, y) {
            lastX = x;
            lastY = y;
            mouseDownLeft = ctx.mouseDownLeft;
            mouseDownRight = ctx.mouseDownRight;
        });

        ctx.onMouseUp(function (x, y) {
            if (Math.abs(lastX - x) < tolerance && Math.abs(lastY - y) < tolerance) {
                pickX = x;
                pickY = y;
                picked = true;
            }
        });

        ctx.onMouseDoubleClick(function (x, y) {
            if (Math.abs(lastX - x) < tolerance && Math.abs(lastY - y) < tolerance) {
                pickX = x;
                pickY = y;
                picked = true;
                doubleClicked = true;
                mouseDownLeft = ctx.mouseDownLeft;
                mouseDownRight = ctx.mouseDownRight;
            }
        });

        ctx.onTick(function () {
            if (picked) {
                var params = {
                    canvasX: pickX,
                    canvasY: pickY,
                    mouseDownLeft: mouseDownLeft,
                    mouseDownRight: mouseDownRight,
                    spaceDown: spaceDown,
                    ctrlDown: ctrlDown,
                    regionPick: rDown
                };
                if (doubleClicked) {
                    Human.view.pick.doublePick(params);
                } else {
                    Human.view.pick.pick(params);
                }
                picked = false;
                doubleClicked = false;
                lastX = null;
                lastY = null;
            }
        });
    });
;Human.input.addHandler(
    function (ctx) {
        "use strict";

        // picking
        ctx.onTouchTap(function (x, y, preventPageDefaults) {
            preventPageDefaults();
            Human.view.pick.pick({ canvasX: x, canvasY: y });
        });

        // double picking
        ctx.onTouchDoubleTap(function (x, y, preventPageDefaults) {
            preventPageDefaults();
            Human.view.pick.doublePick({ canvasX: x, canvasY: y });
        });
    });
;/**
 * Selects view mode with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        ctx.onKeyDown([
            Human.input.KEY_R,
            Human.input.KEY_T,
            Human.input.KEY_I,
            Human.input.KEY_Y,
            Human.input.KEY_Z,
            Human.input.KEY_C
        ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    switch (key) {
                        case  Human.input.KEY_R:
                            Human.rpc.call(null, "highlight.setEnabled", { enable: true });
                            break;
                        case  Human.input.KEY_T:
                            Human.rpc.call(null, "xray.setEnabled", { enable: true });
                            break;
                        case  Human.input.KEY_I:
                            Human.rpc.call(null, "isolate.setEnabled", { enable: true });
                            break;
                    }
                }

                if (ctx.ctrlDown && !ctx.altDown) {
                    switch (key) {
                        case Human.input.KEY_Y:
                            Human.view.dissect.redo();
                            break;

                        case Human.input.KEY_Z:
                            Human.view.dissect.undo();
                            break;

                        case Human.input.KEY_R:
                            Human.init.reset();
                            break;

                    }
                }
            });
    });
;/**
 * Moves active cross-section with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var moveRate = 10.0;
        var clipPlaneShownByThis = null;
        var timeLast;

        ctx.onTick(
            function (time) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    var m = ctx.keyDown[Human.input.KEY_M];
                    var n = ctx.keyDown[Human.input.KEY_N];
                    if (m || n) {
                        if (!Human.view.clip.selectedClip) {
                            return;
                        }
                        if (timeLast) {
                            var elapsed = (time - timeLast) / 1000.0; // Scale to seconds
                            var z;
                            if (n) {
                                z = elapsed * moveRate;
                            } else if (m) {
                                z = -elapsed * moveRate;
                            }
                            var clip = Human.view.clip.selectedClip;
                            if (!clip.shown) {
                                clipPlaneShownByThis = clip.clipId;
                            }
                            Human.view.clip.setClip({
                                state: Human.view.clip.Plane.STATE_VISIBLE,
                                progress: clip.progress + z
                            });
                            return true; // Updated
                        }

                        timeLast = time;
                    } else {
                        timeLast = null;
                        if (clipPlaneShownByThis) {
                            Human.view.clip.setClip({
                                clipId: clipPlaneShownByThis,
                                state: Human.view.clip.Plane.STATE_CLIPPING
                            });
                            clipPlaneShownByThis = null;
                        }
                    }
                }
            });
    });;/**
* Toggles the dissect state
*/
Human.input.addHandler(
    function (ctx) {
        "use strict";

        // track keyboard enable state
        var enabledOnKeyPress = false;

        ctx.onKeyDown([
            Human.input.KEY_X
        ],
            function () {
                if (ctx.ctrlDown && !ctx.altDown && !enabledOnKeyPress) {
                    Human.view.dissect.setEnabled(true);
                    enabledOnKeyPress = true;
                }
            });
        ctx.onKeyUp([
            Human.input.KEY_X
        ],
            function () {
                if (enabledOnKeyPress) {
                    Human.view.dissect.setEnabled(false);
                    Human.view.xray.setEnabled(Human.view.xray.enabled);
                    Human.view.highlight.setEnabled(Human.view.highlight.enabled);
                    enabledOnKeyPress = false;
                }
            });
    });
;/**
 * Resets engine to the state it was in after it fired "started"
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        ctx.onKeyDown([
            Human.input.KEY_R
        ],
            function () {
                if (ctx.keyDown[Human.input.KEY_SHIFT]) {
                    var confirmText = 'This will reset to the initial view. Are you sure you want to continue?';

                    if(confirm(confirmText)) {
                        ctx.keyDown[Human.input.KEY_SHIFT] = false;
                        Human.init.reset();
                    }
                }
            });
    });;(function () {
    "use strict";

    var enabled = Human.request.getSearchParam("explode") === "true";
    var altDown = false;

    var scale = 0;
    var lastTime = 0;

    Human.input.addHandler(
        function (ctx) {

            ctx.onKeyDown([
                    Human.input.KEY_ALT
                ],
                function () {
                    altDown = true;
                });

            ctx.onKeyUp([
                    Human.input.KEY_ALT
                ],
                function () {
                    altDown = false;
                });


            ctx.onMouseWheel(function (event, d) {

                if (!enabled) {
                    return;
                }

                if (!altDown) {
                    return;
                }

                var t = event.timeStamp * 0.001;

                //var speed = (lastTime > 0) ? (1.0 / (t - lastTime)) * 0.01 : 1.0;

                lastTime = t;

                scale += d * 1.0;

                if (scale < 0.0) {
                    scale = 0.0;
                }

                Human.view.explode.explode({ scale: scale, speed: 10 });
            });

        });

})();;/**
 * @namespace The 3D scene, consisting of a hierarchy of {@link Human.scene.Object}s.
 */
(function () {
    "use strict";

    var HumanScene = Human.scene = {};

    // TODO: What is this doing here!?
    HumanScene.checkTestStarted = false;	//Control variable to enable/disable the label feature.

    /** Array of root objects
     *
     * @type {Array}
     * @memberof Human.scene
     */
    HumanScene.rootObjects = [];

    /**
     * A map of objects by ID for each model that's currently loaded
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.modelObjects = {};

    /** All objects by ID
     *
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.objects = {};

    /** All objects by FMA ID
     *
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.objectsByFMAID = {};

    /**
     * For each distinct object meta tag, a map of object IDs to object instances.
     *
     * Eg.
     *
     * <pre>
     * {
     *     "head": {
     *          "maleAdult_frontal_bone": <object>,
     *          "maleAdult_mandible": <object>
     *     },
     *     "skeleton": {
     *          "maleAdult_frontal_bone": <object>,
     *          "maleAdult_mandible": <object>
     *     },
     *     "digestion": {
     *          "maleAdult_mandible": <object>
     *     }
     * }
     * </pre>
     * @type {{}}
     */
    HumanScene.objectsForTags = {};

    /** Count of all objects in scene
     *
     * @type {number}
     * @memberof Human.scene
     */
    HumanScene.numObjects = 0;

    HumanScene._boundary = null;

    /**
     * @memberof Human.scene
     * @type {Array}
     */
    HumanScene.center = [0, 0, 0];

    /**
     * Map of flags for the currently visible objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
    HumanScene.enabledObjects = {};           // Enabled objects

    /**
     * Map of flags for the currently selected objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
    HumanScene.selectedObjects = {};          // Selected objects, which are not neccessarily enabled

    /**
     * True when only the currently selected objects are allowed to be visible
     * @memberof Human.scene
     * @type {boolean}
     */
    HumanScene.showSelectedObjects = false;   // When true, only selected objects shown, else all shown
    
    HumanScene.enableSolidObjects = true;   

    /**
     * Map of flags for the currently xrayed objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
     //NOTE[XRAY]
    //HumanScene.xrayObjects = {};

    HumanScene.alwaysEnabledObjects = {};     // Objects that cannot be disabled
    HumanScene._leavesCache = {};

    /**
     * Creates an object
     *
     * <p>Object is not yet enabled or selected</p>
     *<pre>
     * createObject({
     *
     *      // All objects, leaf and branch
     *
     *      moduleId:         "maleAdult",
     *      objectId:         "Left_posterior_auricular_artery_49626",
     *      displayName:    "Left Posterior Auricular Artery"
     *      parentObjectId: "Anatomy",
     *
     *      // Leaf objects only:
     *
     *      materialId:     "bloodsupply01_blinn43SG",
     *      geometryId:     "Left_posterior_auricular_artery_49626Shape",
     *      attachObjectId : "the-scene-root" | undefined,
     *      pickable:       true,
     *      layerName:      "Muscular_System"
     *
     *      flags: {
     *          transparency:       0.2,
     *          pickable:           false,
     *          renderPriority:     0 | null
     *      }
     * });
     * </pre>
     *
     * @memberof Human.scene
     * @private
     */

    HumanScene.createObject = function (params) {

        if (!params.objectId) {
            Human.log.error("Scene.createObject", "Param expected: objectId");
            return;
        }

        // Can't have duplicate object or fmaId's
        if (HumanScene.objects[params.objectId]) {
            Human.log.error("Scene.createObject", "Param: objectId already in use");
            return;
        }

        var parent = params.parentObjectId ? HumanScene.objects[params.parentObjectId] : null;
        var modelId = params.modelId;

        // Inherit metatags from parent object

        params.tags = params.tags || [];

        var tags = parent ? HumanScene._inheritTags(params.tags, parent) : params.tags;

        params.modelId = modelId;
        params.parent = parent;
        params.attachNodeId = Human.CONTENT_ROOT_ID;
        params.level = parent ? parent.level + 1 : 0;
        params.tags = tags;

        var object = new Human.scene.Object(params);

        HumanScene.objects[params.objectId] = object;
        if (object.fmaId) {
            HumanScene.objectsByFMAID[object.fmaId] = object;
        }
        if (parent) {
            parent.__addObject(object);
        } else {
            HumanScene.rootObjects.push(object); // Register on roots map
        }

        (HumanScene.modelObjects[modelId] = HumanScene.modelObjects[modelId] || {})[params.objectId] = object;

        HumanScene._registerObjectForTags(object);

        HumanScene.numObjects++;

        HumanScene._boundary = null; // Now needs lazy-recompute

        // Publish object creation
        Human.events.fire("scene.objectCreated", {
            moduleId: params.moduleId,
            modelId: modelId,
            objectId: object.objectId,
            name: object.displayName,
            description: object.description,
            displayName: object.displayName,
            fmaId: object.fmaId,
            tags: object.tags,
            parentObjectId: parent ? parent.objectId : null
        });

        if (params.shown !== undefined) {
            object.show(params.shown);
            if (params.shown) {
                HumanScene.enabledObjects[params.objectId] = object;
            }
        }

        return object;
    };

    HumanScene._inheritTags = function(childTags, parentObject) {
        var tags = childTags || [];
        var parentTags = parentObject.tags;
        var tag;
        var parentTag;
        var inheritTags = [];
        if (tags) {
            for (var i = 0, leni = parentTags.length; i < leni; i++) {
                parentTag = parentTags[i];
                var inherit = true;
                for (var j = 0, lenj = tags.length; j < lenj; j++) {
                    tag = tags[j];
                    if (tag === parentTag) {
                        inherit = false;
                    }
                }
                if (inherit) {
                    inheritTags.push(parentTag);
                }
            }
            return tags.concat(inheritTags);
        } else {
            return tags;
        }
    };

    HumanScene._registerObjectForTags = function(object) {
        var tags = object.tags;
        var tag;
        var tagObjects;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagObjects = HumanScene.objectsForTags[tag];
            if (!tagObjects) {
                tagObjects = HumanScene.objectsForTags[tag] = {};
            }
            tagObjects[object.objectId] = object;
        }
    };

    HumanScene._deregisterObjectForTags = function (object) {
        var tags = object.tags;
        var tag;
        var tagObjects;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagObjects = HumanScene.objectsForTags[tag];
            if (tagObjects) {
                delete tagObjects[object.objectId];
            }
        }
    };

    /** Returns the {@link Human.scene.Object} corresponding to the given object ID
     * @memberof Human.scene
     */
    HumanScene.getObject = function (objectId) {
        var object = HumanScene.objects[objectId];
        if (!object) {
            Human.log.error("Human.scene.getObject", "Scene object not found: '" + objectId + "'");
        }
        return object;
    };

    HumanScene.xray = function(options) {
        options = options || {};
        var enable = options.enable !== false;
        var exclude = options.exclude || {};

        var objectIds = this.getLeaves();
        var object;
        for (var i = 0, len = objectIds.length; i < len; ++i) {
            object = Human.scene.objects[objectIds[i]];
            if (enable) { // Do X-ray
                if (exclude[object.objectId]) { // Opaque
                    object.setXRay(false);
                    object.setHighlight(false);
                } else { // X-ray
                    object.setXRay(true);
                }
            } else { // Undo X-ray
                object.setXRay(false);
                object.setOpacity(1);
            }
        }
    };

    /**
     * Enable or disable some or all objects
     * @memberof Human.scene
     */
    HumanScene.setEnabledObjects = function (params) {

        var enabledObjects = HumanScene.enabledObjects;
        var selectedObjects = HumanScene.selectedObjects;

        var objects = params.objects || params.objectIds;
        var objectId;

        var enabledObjectsUpdate = {};
        var selectedObjectsUpdate = {};

        var notifyEnabled = false;
        var notifySelected = false;

        var fetchAssets = params.fetchAssets;
        var needsAssets = [];

        /* Clear all selected objects if replacing the selected set
         */
        if (params.replace) {
            for (objectId in enabledObjects) {
                if (enabledObjects.hasOwnProperty(objectId)) {


                    // TODO ability to override this optimization

                    enabledObjects[objectId].numEnabledSubObjects = 0;
                    delete enabledObjects[objectId];

                    enabledObjectsUpdate[objectId] = false;

                    if (selectedObjects.hasOwnProperty(objectId)) {
                        selectedObjects[objectId]._selectedSubObjects = 0;
                        delete selectedObjects[ objectId ];
                        selectedObjectsUpdate[objectId] = false;

                        notifySelected = true;
                    }

                    HumanScene._updateObjectVisibility(objectId);

                    notifyEnabled = true;
                }
            }
        }

        /* Build object ID->flag map for trees rooted by given objects
         */
        HumanScene._getEnabledFlagsinSubtreeForObjectMap(objects, enabledObjectsUpdate);

        /* Enable map of objects
         */
        for (objectId in enabledObjectsUpdate) {
            if (enabledObjectsUpdate.hasOwnProperty(objectId)) {
                if (enabledObjectsUpdate[objectId]) {

                    var object = HumanScene.objects[objectId];

                    if (fetchAssets && object.isLeaf() && !object.isRenderable()) {
                        needsAssets.push(object);
                    }

                    if (!enabledObjects[objectId]) {
                        enabledObjects[objectId] = HumanScene.objects[objectId];
                        HumanScene._updateObjectVisibility(objectId);

                        enabledObjectsUpdate[objectId] = true;

                        notifyEnabled = true;
                    }
                } else {

                    if (enabledObjects[objectId]) {

                        delete enabledObjects[objectId];

                        /* Selection of an object forces enabling of it
                         * if it's currently disabled
                         */
                        if (selectedObjects[objectId]) {
                            if (!selectedObjectsUpdate) {
                                selectedObjectsUpdate = {};
                            }
                            delete selectedObjects[objectId];  // Disabling forces deselection
                            selectedObjectsUpdate[objectId] = false;
                        }

                        HumanScene._updateObjectVisibility(objectId);

                        enabledObjectsUpdate[objectId] = false;

                        notifyEnabled = true;
                    }
                }
            }
        }

        if (needsAssets.length > 0) {
            Human.scene.graph.attachAssetSetsToSubtree(needsAssets);
        }

        if (notifyEnabled) {
            Human.events.fire("scene.objectsShown", {    // Post-notify
                enabledObjectsUpdate: enabledObjectsUpdate,
                showSelectedObjects: HumanScene.showSelectedObjects
            });
        }

        if (notifySelected) {
            Human.events.fire("scene.objectsSelected", {
                selectedObjectsUpdate: selectedObjectsUpdate,
                showSelectedObjects: HumanScene.showSelectedObjects
            });
        }
    };

    /**
     * Builds enabled flags for objects in given map of enabled flags,
     * in order of objects' level in anatomy hierarchy
     */
    HumanScene._getEnabledFlagsinSubtreeForObjectMap = function (objects, objectFlags) {
        var buckets = HumanScene._sortObjectIDsIntoLevelBuckets(objects);
        var bucket;
        var objectId;
        // Iterate buckets in order, accumulate enabled flags for each object
        for (var i = 0, len = buckets.length; i < len; i++) {
            bucket = buckets[i];
            if (bucket) {
                for (var j = 0, len2 = bucket.length; j < len2; j++) {
                    objectId = bucket[j];
                    HumanScene._getEnabledFlags(objectId, !!objects[objectId], objectFlags);
                }
            }
        }
    };

    /**
     * Sorts given map of object IDs into buckets ordered by ascending
     * order of object levels in anatomy hierarchy
     */
    HumanScene._sortObjectIDsIntoLevelBuckets = function (objectIds) {
        var objectId;
        var buckets = [];
        var bucket;
        var object;
        var level;
        for (objectId in objectIds) {
            if (objectIds.hasOwnProperty(objectId)) {
                object = HumanScene.objects[objectId];
                if (object) {
                    level = object.level;
                    bucket = buckets[level] || (buckets[level] = []);
                    bucket.push(objectId);
                }
            }
        }
        return buckets;
    };

    HumanScene._getEnabledFlags = function (objectId, flag, objectFlags) {
        // Start at the root then go down to leaves and recursively update flags upwards
        // Won't neeed to worry about updating parents
        objectFlags = objectFlags || {};
        var object = HumanScene.objects[objectId];

        if (!object || object._destroyed) {
            return objectFlags;
        }

        var objFlags = HumanScene._getEnabledFlagsInSubtreeForObject(objectId, flag, objectFlags);

        // Happens when grandchildren and descendents' flags are updated, but not parents'
        for (var parent = object.parent; object, parent; object = object.parent, parent = parent.parent) {
            if (parent && flag) {
                if (parent.parent) {
                    object.numEnabledSubObjects = object.numEnabledSubObjects || 0;

                    // Add enabled siblings to count -- see if already have another enabled sibling
                    var enabledSib = 0;
                    for (var i = 0; i < parent.objects.length; i++ ) {
                        if (parent.objects[i].objectId === object.objectId) {
                            continue;
                        }
                        if (objectFlags[parent.objects[i].objectId]) {
                            enabledSib++;
                        }
                    }

                    // Only need to recurse and update ancestors once -- first enabled sibling already took care of that
                    if ((parent.numEnabledSubObjects + enabledSib) === (object.numEnabledSubObjects + 1)) {
                        HumanScene._updateAncestorSubObjects(parent.parent, flag);
                    } else {
                        break;
                    }
                }
            } else if (parent && !flag) {
                // Now if disabling parents -- then update their subobj count
                if (parent.parent) {
                    object.numEnabledSubObjects = object.numEnabledSubObjects || 0;

                    if (parent.numEnabledSubObjects === object.numEnabledSubObjects) {
                        HumanScene._updateAncestorSubObjects(parent.parent, flag, objFlags);
                    }
                }
            }
        }

        return objFlags;
    };

    HumanScene._getEnabledFlagsInSubtreeForObject = function(objectId, flag, objectFlags) {
        var object = HumanScene.objects[objectId];

        if (!object || object._destroyed) {
            return objectFlags;
        }

        objectFlags[objectId] = flag;

        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._getEnabledFlagsInSubtreeForObject(objects[i].objectId, flag, objectFlags);
        }

        // Set flags for parents
        var objectEnabled = HumanScene.enabledObjects[objectId];
        if (object.parent) {
            for (var parent = object.parent; parent; parent = parent.parent) {  // Get flags on path to root
                if (parent.numEnabledSubObjects === undefined || parent.numEnabledSubObjects === null) {
                    parent.numEnabledSubObjects = 0;
                }
                if (flag) {
                    if (!objectEnabled) {
                        if (++parent.numEnabledSubObjects === 1) {
                            objectFlags[parent.objectId] = true;
                        }
                    }
                } else {
                    if (objectEnabled) {
                        if (--parent.numEnabledSubObjects === 0) {
                            objectFlags[parent.objectId] = false;
                        }
                    }
                }
            }
        }
        return objectFlags;
    };

    HumanScene._updateAncestorSubObjects = function (ancestor, flag, objectFlags) {
        if (ancestor && flag) {
            ancestor.numEnabledSubObjects++;
            HumanScene._updateAncestorSubObjects(ancestor.parent, flag, objectFlags);
        } else if (ancestor && !flag) {
            if (HumanScene.enabledObjects[ancestor.objectId]) {
                if (--ancestor.numEnabledSubObjects === 0) {
                    objectFlags[ancestor.objectId] = false;
                }
            }
            HumanScene._updateAncestorSubObjects(ancestor.parent, flag, objectFlags);
        }
    };

    /**
     * Select or disable some or all objects
     * @memberof Human.scene
     */
    HumanScene.setSelectedObjects = function (params) {
        var objects = params.objects || params.objectIds || {};
        var objectId;
        var object;

        var selectedObjectsUpdate = {};


        if (params.objectId) {

            // Selecting a single object

            // Verify object exists
            object = HumanScene.objects[params.objectId];
            if (!object) {
                Human.log.error("Human.scene.setSelectedObjects", "Scene object not found: '" + params.objectId + "'");
                return;
            }

            var select = !!params.select;

            // Unselect all currently selected objects if replacing the selected set
            if (params.replace) {
                for (objectId in HumanScene.selectedObjects) {
                    if (HumanScene.selectedObjects.hasOwnProperty(objectId)) {

                        object = HumanScene.selectedObjects[objectId];
                        object._selectedSubObjects = 0;
                        delete HumanScene.selectedObjects[ objectId ];

                        if (object.selected) {
                            object.select(false);
                        }

                        // Hide object if selected objects are currently visible
                        if (HumanScene.showSelectedObjects) {
                            if (object.shown) {
                                object.show(false);
                            }
                        }

                        selectedObjectsUpdate[objectId] = false;
                    }
                }
            }

            HumanScene._getObjectSelectedFlagsInSubtree(params.objectId, select, selectedObjectsUpdate);

        } else {

            // Selection/deselecting multiple objects

            // Unselect all currently selected objects if replacing the selected set
            if (params.replace) {
                for (objectId in HumanScene.selectedObjects) {
                    if (HumanScene.selectedObjects.hasOwnProperty(objectId)) {
                        object = HumanScene.selectedObjects[ objectId ];
                        object._selectedSubObjects = 0;
                        if (object.selected) {
                            object.select(false);
                        }
                        delete HumanScene.selectedObjects[ objectId ];
                        selectedObjectsUpdate[objectId] = false;
                        HumanScene._updateObjectVisibility(objectId);
                    }
                }
            }

            // Build object ID->flag map for trees rooted by given objects
            HumanScene._getSelectedFlagsInSubtreeForObjectMap(objects, selectedObjectsUpdate);

        } // Multiple select


        /* Defined as soon as disabled object becomes enabled as it is
         * selected - we'll notify of new enables if this is defined
         */
        var enabledObjectsUpdate;

        /* Enable map of objects
         */
        for (objectId in selectedObjectsUpdate) {
            if (selectedObjectsUpdate.hasOwnProperty(objectId)) {
                object = HumanScene.objects[objectId];
                if (selectedObjectsUpdate[objectId]) {
                    if (!HumanScene.selectedObjects[objectId]) {

                        HumanScene.selectedObjects[objectId] = object;

                        /* Selection of an object forces enabling of it
                         * if it's currently disabled
                         */
                        if (!HumanScene.enabledObjects[objectId]) {
                            if (!enabledObjectsUpdate) {
                                enabledObjectsUpdate = {};
                            }
                            enabledObjectsUpdate[objectId] = true;
                            HumanScene.enabledObjects[objectId] = object;
                        }

                        var show = !!HumanScene.enabledObjects[objectId];

                        if (HumanScene.showSelectedObjects) {
                            show = show && !!HumanScene.selectedObjects[objectId];
                        }

                        if (object.shown !== show) {
                            object.show(show);
                        }

                        if (!object.selected) {
                            object.select(true);
                        }

                        //HumanScene._updateObjectVisibility(objectId);

                        selectedObjectsUpdate[objectId] = true;


                    }
                } else {

                    if (HumanScene.selectedObjects[objectId]) {

                        delete HumanScene.selectedObjects[objectId];      // Deselection leaves object enabled

                        HumanScene._updateObjectVisibility(objectId);

                        if (object.selected) {
                            object.select(false);
                        }

                        selectedObjectsUpdate[objectId] = false;
                    }
                }
            }
        }


        /* Notify of new object enables/disables
         */
        if (enabledObjectsUpdate) {

            Human.events.fire("scene.objectsShown", {
                enabledObjectsUpdate: enabledObjectsUpdate,
                showSelectedObjects: HumanScene.showSelectedObjects
            });
        }

        /* Notify of new object selections/deselections
         */
        Human.events.fire("scene.objectsSelected", {
            selectedObjectsUpdate: selectedObjectsUpdate,
            showSelectedObjects: HumanScene.showSelectedObjects
        });
    };


    /** Builds selected and enabled flags for object enabled flags in given map in order of objects' level in anatomy hierarchy
     */
    HumanScene._getSelectedFlagsInSubtreeForObjectMap = function (objects, objectFlags) {
        var buckets = HumanScene._sortObjectIDsIntoLevelBuckets(objects);
        var bucket;
        var objectId;
        // Iterate buckets in order, accumulate enabled flags for each object
        for (var i = 0, len = buckets.length; i < len; i++) {
            bucket = buckets[i];
            if (bucket) {
                for (var j = 0, len2 = bucket.length; j < len2; j++) {
                    objectId = bucket[j];
                    HumanScene._getObjectSelectedFlagsInSubtree(objectId, !!objects[objectId], objectFlags);
                }
            }
        }
    };

    HumanScene._getObjectSelectedFlagsInSubtree = function (objectId, flag, objectFlags) {
        objectFlags = objectFlags || {};
        var object = HumanScene.objects[objectId];
        if (!object || object._destroyed) {
            return objectFlags;
        }
        objectFlags[objectId] = flag;
        // Set flags for parents
        var objectSelected = HumanScene.selectedObjects[objectId];
        var objectEnabled = HumanScene.enabledObjects[objectId];
        if (object.parent) {
            for (var parent = object.parent; parent; parent = parent.parent) {  // Get flags on path to root
                if (parent.numEnabledSubObjects === undefined || parent.numEnabledSubObjects === null) {
                    parent.numEnabledSubObjects = 0;
                }
                if (parent._selectedSubObjects === undefined || parent._selectedSubObjects === null) {
                    parent._selectedSubObjects = 0;
                }
                if (flag) {
                    if (!objectSelected) {
                        if (++parent._selectedSubObjects === 1) {
                            objectFlags[parent.objectId] = true;
                        }
                    }
                    if (!objectEnabled) {
                        parent.numEnabledSubObjects++;
                    }
                } else {
                    if (objectSelected) {
                        if (--parent._selectedSubObjects <= 0) {
                            parent._selectedSubObjects = 0; // Safety?
                            objectFlags[parent.objectId] = false;
                        }
                    }
                }
            }
        }
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._getObjectSelectedFlagsInSubtree(objects[i].objectId, flag, objectFlags);
        }
        return objectFlags;
    };

    HumanScene.anySelected = function (leaves) {
        var object;
        for (var key in HumanScene.selectedObjects) {
            if (HumanScene.selectedObjects.hasOwnProperty(key)) {
                object = HumanScene.selectedObjects[key];
                if (leaves) {
                    if (object.numSubObjects === 0) {
                        return true;
                    }
                } else {
                    return true;
                }
            }
        }
        return false;
    };

    /**
     * Sets whether or not to show only the objects that are selected and enabled
     * @memberof Human.scene
     * @param showSelected
     */
    HumanScene.setShowSelectedObjects = function (showSelected) {
        HumanScene.showSelectedObjects = showSelected;
        var object;
        var show;
        for (var objectId in HumanScene.objects) {
            if (HumanScene.objects.hasOwnProperty(objectId)) {
                object = HumanScene.objects[objectId];
                show = !!HumanScene.enabledObjects[objectId];
                if (HumanScene.showSelectedObjects) {
                    show = show && !!HumanScene.selectedObjects[objectId];
                }
                if (object.shown !== show) {
                    object.show(show);
                }
            }
        }
    };

    HumanScene._updateObjectVisibility = function (objectId) {
        var object = HumanScene.objects[objectId];
        var show = !!HumanScene.enabledObjects[objectId];
        if (HumanScene.showSelectedObjects) {
            show = show && !!HumanScene.selectedObjects[objectId];
        }
        if (object.shown !== show) {
            object.show(show);
        }
    };

    /**
     * Returns the IDs of leaf objects within the given tree
     * @param objectId
     * @memberof Human.scene
     */
    HumanScene.getLeaves = function (objectId) {
        var objectIdList = HumanScene._leavesCache[ objectId ];
        if (!objectIdList) {
            objectIdList = [];
            if (objectId) {
               var object = HumanScene.objects[objectId];
               if (object) {
                   HumanScene._getLeaves([object], objectIdList);
               } 
           } else {
                HumanScene._getLeaves(Human.scene.rootObjects, objectIdList);
           }
            
            HumanScene._leavesCache[ objectId ] = objectIdList;
        }
        return objectIdList;
    };

    HumanScene._getLeaves = function (objects, objectIdList) {
        var object;
        for (var i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            if (object.objects.length === 0) { // Leaf
                objectIdList.push(object.objectId);
            } else {
                HumanScene._getLeaves(object.objects, objectIdList);
            }
        }
    };

    /**
     * Returns the IDs of visible leaf objects within the given tree
     * @param objectId
     * @memberof Human.scene
     */
    HumanScene.getEnabledLeaves = function (objectId) {
        var objectIdList = [];
        if (objectId) {
            var object = HumanScene.objects[objectId];
            if (object) {
                HumanScene._getEnabledLeaves([object], objectIdList);
            }
        } else {
            HumanScene._getEnabledLeaves(Human.scene.rootObjects, objectIdList);
        }
        return objectIdList;
    };

    HumanScene._getEnabledLeaves = function (objects, objectIdList) {
        var object;
        for (var i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            if (object.objects.length === 0) { // Leaf
                if (HumanScene.enabledObjects.hasOwnProperty(object.objectId)) {
                    objectIdList.push(object.objectId);
                }
            } else {
                HumanScene._getEnabledLeaves(object.objects, objectIdList);
            }
        }
    };

    HumanScene._getKeys = function (map, val) {
        var keys = {};
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                key[key] = val;
            }
        }
        return keys;
    };

    /** Destroys an object and all sub-objects
     */
    HumanScene.destroyObject = function (objectId) {
        var object = HumanScene.objects[objectId];
        if (!object || object._destroyed) {
            return;
        }
        var o, i, len;
        for (i = 0, len = HumanScene.rootObjects.length; i < len; i++) {
            if (HumanScene.rootObjects[i].objectId === objectId) {
                HumanScene.rootObjects.splice(i, 1);
                break;
            }
        }
        delete HumanScene.objects[objectId];                              // Delete object
        if (object.fmaId) {
            delete HumanScene.objectsByFMAID[object.fmaId];
        }

        // Update enabled object counts at higher objects
        // When a higher object has an enabled object count, and this object is enabled, decrement the count
        if (HumanScene.enabledObjects[objectId]) {
            for (o = object.parent; o; o = o.parent) { // Blow away leaves caches on path to root
                if (o.numEnabledSubObjects !== undefined && o.numEnabledSubObjects !== null) {
                    o.numEnabledSubObjects--;
                }
            }
        }

        // Update selected object counts at higher objects
        // When a higher object has a selected object count, and this object is selected, decrement the count
        if (HumanScene.selectedObjects[objectId]) {
            for (o = object.parent; o; o = o.parent) { // Blow away leaves caches on path to root
                if (o._selectedSubObjects !== undefined && o._selectedSubObjects !== null) {
                    o._selectedSubObjects--;
                }
            }
        }

        delete HumanScene.selectedObjects[objectId];                      // Delete from selected objects
        delete HumanScene.enabledObjects[objectId];                       // Delete from enabled objects

        HumanScene.numObjects--;
        if (object.parent) {
            object.parent._removeObject(objectId);
        }
        var children = object.objects.slice(0); // Avoid modification during removals
        for (i = 0, len = children.length; i < len; i++) {
            HumanScene.destroyObject(children[i].objectId);
        }
        object._destroy();
        object._destroyed = true;

        delete HumanScene.modelObjects[object.modelId][object.objectId];

        HumanScene._deregisterObjectForTags(object);

        // Will need to recompute leaf object cache
        HumanScene._leavesCache = {};

        // Will need to lazy-recompute boundary
        HumanScene._boundary = null;

        Human.events.fire("scene.objectDestroyed", { objectId: objectId });
    };


    /**
     *
     * @param [params]
     * @param [params.objectId] ID of single object
     * @param [params.objectIds] Array of object IDs
     * @param [params.objects] Map of IDs to objects
     * @returns {*}
     */
    HumanScene.getBoundary = function (params) {

        params = params || {};

        var object;

        if (params.objectId) {

            // Requesting boundary of single object

            object = Human.scene.objects[params.objectId];

            if (object) {
                return object.getBoundary();

            } else {

                // Object not found, log warning and return boundary of entire scene

                Human.log.warn("Human.scene.getBoundary", "Scene object not found: '" + params.objectId + "'");

                return this.getBoundary();
            }
        }

        // Requesting boundary of either all objects or some specified objects
        // Prepare result boundary

        if (!HumanScene._boundary) {

            // Lazy-create boundary

            HumanScene._boundary = {
                xmin: 100000, ymin: 100000, zmin: 100000, xmax: -100000, ymax: -100000, zmax: -100000
            };

        } else {

            // Reset boundary for expansion

            HumanScene._boundary.xmin = 100000;
            HumanScene._boundary.ymin = 100000;
            HumanScene._boundary.zmin = 100000;
            HumanScene._boundary.xmax = -100000;
            HumanScene._boundary.ymax = -100000;
            HumanScene._boundary.zmax = -100000;
        }

        var objectId;
        var boundary = HumanScene._boundary;
        var gotBoundary = false;
        var b;

        if (params.objectIds) {

            // Requesting boundary of multiple objects given as array of IDs

            var objectIds = params.objectIds;

            for (var i = 0, len = objectIds.length; i < len; i++) {

                object = HumanScene.objects[objectIds[i]];

                if (object && object.objects.length === 0) { // Leaf object

                    b = object.getBoundary();

                    if (b.xmin < boundary.xmin) {
                        boundary.xmin = b.xmin;
                    }
                    if (b.ymin < boundary.ymin) {
                        boundary.ymin = b.ymin;
                    }
                    if (b.zmin < boundary.zmin) {
                        boundary.zmin = b.zmin;
                    }
                    if (b.xmax > boundary.xmax) {
                        boundary.xmax = b.xmax;
                    }
                    if (b.ymax > boundary.ymax) {
                        boundary.ymax = b.ymax;
                    }
                    if (b.zmax > boundary.zmax) {
                        boundary.zmax = b.zmax;
                    }

                    gotBoundary = true;
                }
            }

        } else if (params.objects) {

            // Requesting boundary of an ID-map of objects

            var objects = params.objects;

            for (objectId in objects) {

                if (objects.hasOwnProperty(objectId) && !!HumanScene.objects[objectId]) {

                    object = HumanScene.objects[objectId];

                    if (object.objects.length === 0) { // Leaf object

                        b = object.getBoundary();

                        if (b.xmin < boundary.xmin) {
                            boundary.xmin = b.xmin;
                        }
                        if (b.ymin < boundary.ymin) {
                            boundary.ymin = b.ymin;
                        }
                        if (b.zmin < boundary.zmin) {
                            boundary.zmin = b.zmin;
                        }
                        if (b.xmax > boundary.xmax) {
                            boundary.xmax = b.xmax;
                        }
                        if (b.ymax > boundary.ymax) {
                            boundary.ymax = b.ymax;
                        }
                        if (b.zmax > boundary.zmax) {
                            boundary.zmax = b.zmax;
                        }

                        gotBoundary = true;
                    }
                }
            }

        } else  {

            // Requesting boundary of all objects

            objects = HumanScene.objects;

            for (objectId in objects) {

                if (objects.hasOwnProperty(objectId)) {

                    object = objects[objectId];

                    if (object.objects.length === 0) { // Leaf object

                        b = object.getBoundary();

                        if (b.xmin < boundary.xmin) {
                            boundary.xmin = b.xmin;
                        }
                        if (b.ymin < boundary.ymin) {
                            boundary.ymin = b.ymin;
                        }
                        if (b.zmin < boundary.zmin) {
                            boundary.zmin = b.zmin;
                        }
                        if (b.xmax > boundary.xmax) {
                            boundary.xmax = b.xmax;
                        }
                        if (b.ymax > boundary.ymax) {
                            boundary.ymax = b.ymax;
                        }
                        if (b.zmax > boundary.zmax) {
                            boundary.zmax = b.zmax;
                        }

                        gotBoundary = true;
                    }
                }
            }
        }


        return gotBoundary ? boundary : {
            xmin: -100, ymin: -100, zmin: -100, xmax: 100, ymax: 100, zmax: 100
        };
    };

    // Single scene-graph traversal to set all properties, defaulting to parent properties.
    // Also has to fire event with published changes.
    HumanScene.setObjectProperties = function(instructions){
        instructions = instructions || {};

        var overrides = {};
        var selectedChanges = {};   // objects that have changed selected property value
        var selectedObjects = {};   // objects where selected is true
        var shownChanges = {};      // objects that have changed shown property value
        var shownObjects = {};      // objects where shown = true

        //NOTE[XRAY]
        // var xRayChanges = {};       // objects that have changed xray value
        // var xRayObjects = {};

        // Perform update on all objects in scene-graph through downward traversal
        var rootObjects = Human.scene.rootObjects;

        function setProperties(object){
            overrides = instructions[object.objectId] || {};

            // merge with inherited properties from parent
            if (object.parent){
                overrides = Human.scene.sets.union(object.parent.getProperties(), overrides);

                // special handling of glass factor, as it is not needed to be inherited
                overrides.glassFactor = object.glassFactor;
                overrides.murkiness = object.murkiness;
            }

            // Register changes to 'selected' property;
            if (overrides.hasOwnProperty("selected") && object.selected !== overrides.selected){
                // 'selected' property has changed
                selectedChanges[object.objectId] = overrides.selected;
            }

            // Register changes to 'shown' property
            if (overrides.hasOwnProperty("shown") && object.shown !== overrides.shown){
                shownChanges[object.objectId] = overrides.shown;
            }

            //NOTE[XRAY]
            // if (overrides.hasOwnProperty("xray") && object.xray !== overrides.xray){
            //     xRayChanges[object.objectId] = overrides.xray;
            // }

            // register shown and selected objects
            if (overrides.shown){
                shownObjects[object.objectId] = object;
                HumanScene.enabledObjects[object.objectId] = object;
            } else {
                delete HumanScene.enabledObjects[object.objectId];
            }

            if (overrides.selected){
                selectedObjects[object.objectId] = object;
                HumanScene.selectedObjects[object.objectId] = object;
            } else {
                delete HumanScene.selectedObjects[object.objectId];
            }

            //NOTE[XRAY]
            // if (overrides.xray){
            //     xRayObjects[object.objectId] = object;
            // }

            // Do the Update
            object.setProperties(overrides);
        }

        for (var i = 0, len = rootObjects.length; i < len; i++) {
            rootObjects[i].traverseDown(setProperties);
        }

        // Update and Publish Selected Objects
        Human.scene.selectedObjects = selectedObjects;

        // Publish xray objects
        //NOTE[XRAY]
        //Human.scene.xrayObjects = xRayObjects;

        Human.events.fire("scene.objectsSelected", {
          selectedObjectsUpdate: selectedChanges,
          showSelectedObjects: HumanScene.showSelectedObjects
        });

        Human.events.fire("scene.objectsShown", {
          enabledObjectsUpdate: shownChanges,
          showSelectedObjects: HumanScene.showSelectedObjects
        });

        // Human.events.fire("scene.objectsXray", {
        //     xrayObjectsUpdate: xRayChanges
        // });

    };

})();
;(function () {
    "use strict";

    /**
     * @class An object within {@link Human.scene}
     * @param cfg
     * @constructor
     */
    Human.scene.Object = function (cfg) {
        /** ID of model that contains this object
         *
         * @type {modelId|*}
         */
        this.modelId = cfg.modelId;

        /** Unique ID of this object
         * @type {String}
         */
        this.objectId = cfg.objectId;

        /** True when this object was not explicitly assigned an ID and has one that's internally generated.
         * @type {String}
         */
        this.anonymous = cfg.anonymous;

        /** FMA ID
         * @type {String}
         */
        this.fmaId = cfg.fmaId;

        /** Z-sorting layer
         * @type {*}
         */
        this.layer = cfg.layer;

        /** Long display name
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /** Detailed description
         * @type {String}
         */
        this.description = cfg.description;

        /** Parent object
         * @type @link Human.scene.Object
         */
        this.parent = cfg.parent;

        /** True when this object is shown
         * @type {*|Boolean}
         */
        this.shown = false;

        /** True when this object is selected
         * @type {*|Boolean}
         */
        this.selected = false;

        /** Level in anatomy object hierarchy
         * @type {Number}
         */
        this.level = cfg.level;

        /** True when this object may be picked
         *  @type {Boolean}
         */
        this.pickable = true;

        /** True when this object may be clipped
         *  @type {Boolean}
         */
        this.clippable = true;

        /** True when this object is X-rayed
         *  @type {Boolean}
         */
        this.xray = false;

        // opacity is 1 if completely opaque
        this.opacity = 1.0;

        /** When transparent, this controls the degree of "facing ratio" effect, which is
         * where the object becomes more opaque towards the edges.
         * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
         *  @type {Number}
         */
        this.glassFactor = 1.0;
        /** When transparent, this controls the degree of "murkiness" effect.
         * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
         *  @type {Number}
         */
        this.murkiness = 1.0;

        /** True when this object is highlighted
         *  @type {Boolean}
         */
        this.highlight = false;
        this.saturation = 0;
        this.contrast = 1;
        this.brightness = 0;

        /** True when this object may show backfaces.
         *  @type {Boolean}
         */
        this.backfaces = false;

        // Vertex winding order
        this.windingOrder = "ccw";

        /** Anatomy region metatags
         *
         * @type {Array of String}
         */
        this.tags = cfg.tags;

        /** Number of sub-objects
         *  @type {Number}
         */
        this.numSubObjects = 0;

        /** Number of sub-objects that have finished loading
         *  @type {Number}
         */
        this.numSubObjectsLoaded = 0;

        /** Number of sub-objects that are visible. Initialized by Human.scene.setEnabled.
         * @type {number}
         */
        this.numEnabledSubObjects = 0;

        /** Sub-objects
         *  @type {[Human.scene.Object]}
         */
        this.objects = [];

        // Asset to use for boundary rebuild
        this._boundedAsset = null;

        this.reflectedX = false;
        this.reflectedY = false;
        this.reflectedZ = false;
        this._worldToObjectMatrix = mat4.create();

        //
        this._boundaryDirty = true;

        this.geometryId  = cfg.geometryId;
        this.materialId  = cfg.materialId;
        this.transformId = cfg.transformId;
        this.morphId     = cfg.morphId;

        this.attachedAssets = {};
        this._pendingAssets = {};

        var flags;

        // Root of scene subgraph for this object

        // Modelling transform - both group and leaf objects have these

        if (this.transformId) {
            this._transformNode = Human.renderer.graph.createSubtree(this._getParentContainerNode(), {
                type: "xform",
            });
            // Initial transform
            this.pivot = {x: 0, y: 0, z: 0};
            this.translate = {x: 0, y: 0, z: 0};
            this.scale = {x: 1, y: 1, z: 1};
            this.rotate = {x: 0, y: 0, z: 0};
        } else {
            this._transformNode = null;
            this.pivot = null;
            this.translate = null;
            this.scale = null;
            this.rotate = null;
        }

        // Eventually, we'll not create roots within roots, where the SceneJS subgraphs for Human objects will
        // be flat, ie. not nested within the SceneJS scene graph. Before we do that however, we need to manage the
        // nested coordinate spaces (ie multiplication of nested matrices) within Human, rather than rely on
        // SceneJS' inherited coordinate spaces, as we do currently.
        this._rootNode = this._childNodeContainer = this._transformNode;

        /** Material attached to this object
         *  @type {**}
         */
        this.material = null;
        this.region = null;

        if (this.geometryId || this.morphId || cfg.geometry || cfg.morph) {

            // Flags

            flags = this.getDefaultFlags();

            this._xrayBackfaces = false;

            flags.enabled = false;
            flags.pickable = true;
            flags.solid = Human.scene.enableSolidObjects;
            flags.layer = cfg.layer || 0;
            flags.name = cfg.objectId || "noname";
            flags.xray = false;
            flags.highlight = false;
            flags.opacity = 1.0;
            flags.glassFactor = this.glassFactor;
            flags.murkiness = this.murkiness;
            flags.xrayEnabled = true;

            if (this._rootNode) {
                this._propertiesNode = Human.renderer.graph.insertNode(this._rootNode, {
                    type: "properties",
                    properties: flags
                });
            } else {
                this._propertiesNode = this._rootNode = Human.renderer.graph.createSubtree(this._getParentContainerNode(), {
                    type: "properties",
                    properties: flags
                });
            }

            // Region map

            if (cfg.regionMap) {
                this.regionMap = cfg.regionMap;

                Human.renderer.graph.insertNode(this._rootNode, {
                    type: "regionMap",
                    coreId: cfg.regionMap.node.getCoreId()
                });
            }

            this._boundedAsset = cfg.morph ? cfg.morph : cfg.geometry;

        } // if (geometry || morph)

        // Notify parent that child has been added
        if (this.parent) {
            this.parent._subObjectReady(this);
        }

        // Both branch and leaf nodes can have transform assets

        if (cfg.pivot || cfg.translate || cfg.scale || cfg.rotate) {
            // Initial transform
            this.pivot = cfg.pivot ? Human.utils.apply(cfg.pivot, {x: 0, y: 0, z: 0}) : {x: 0, y: 0, z: 0};
            this.translate = cfg.translate ? Human.utils.apply(cfg.translate, {x: 0, y: 0, z: 0}) : {x: 0, y: 0, z: 0};
            this.scale = cfg.scale ? Human.utils.apply(cfg.scale, {x: 1, y: 1, z: 1}) : {x: 1, y: 1, z: 1};
            this.rotate = cfg.rotate ? Human.utils.apply(cfg.rotate, {x: 0, y: 0, z: 0}) : {x: 0, y: 0, z: 0};
            this._buildMatrix();
        }

        if (this._propertiesNode) {
            this._propertiesNode.setSolidColor(cfg.capColor ||  { r: 0.7, g: 0.7, b: 0.7 });
        }
    };

    /////////////////////////////////////////
    // Applying assets to this object
    /////////////////////////////////////////

    var ASSET_HANDLERS = {
        geometry: function(object, asset) {
            object.geometry = Human.renderer.graph.insertNode(object._rootNode, asset.geometry);
            object._boundedAsset = asset;
            object._boundaryDirty = true;
        },
        morph: function(object, asset) {
            // Needs to be original node (not shared core)
            // Otherwise morph annotations don't work
            object.morph = asset.morphGeometry;

            Human.renderer.graph.insertNode(object._rootNode, asset.morphGeometry);

            // Needs to be original node (not shared core)
            // Otherwise event not fired.
            asset.morphGeometry.onFrameUpdate = function () {
                object._boundaryDirty = true;
            };

            object._boundedAsset = asset;
            object._boundaryDirty = true;

            Human.view.annotations.animations.addObject(object);
        },
        material: function(object, asset) {
            object.material = asset;

            if (asset.textures) {
                var textures = asset.textures;

                var iTexture;
                var lenTextures;
                for (iTexture = 0, lenTextures = textures.length; iTexture < lenTextures; iTexture++) {
                    if (textures[iTexture]) {
                        Human.renderer.graph.insertNode(object._rootNode, {
                            type: "texture",
                            coreId: textures[iTexture].getCoreId()
                        });
                    }
                }
            }

            if (asset.material) {
                Human.renderer.graph.insertNode(object._rootNode, asset.material);
            }

            if (asset.flags) {
                var flags = Human.utils.apply(asset.flags, object._propertiesNode.getProperties());

                if (flags.frontface) {
                    object.windingOrder = flags.frontface;
                }

                object._propertiesNode.setProperties(flags);
            }

            if (asset.reflection) {
                Human.renderer.graph.insertNode(object._rootNode, asset.reflection);
            }

            if (asset.fresnels) {
                var fresnels = asset.fresnels;
                for (var type in fresnels) {
                    if (fresnels.hasOwnProperty(type)) {
                        Human.renderer.graph.insertNode(object._rootNode, fresnels[type]);
                    }
                }
            }

            if (asset.glassFactor !== undefined) {
                object.setGlassFactor(asset.glassFactor);
            }

            if (asset.murkiness !== undefined) {
                object.setMurkiness(asset.murkiness);
            }

        },
        transform: function(object, asset) {
            object._transform = asset;

            if (asset.scale.x < 0) {
                object.setReflectedX(true);
            }

            if (asset.scale.y < 0) {
                object.setReflectedY(true);
            }

            if (asset.scale.z < 0) {
                object.setReflectedZ(true);
            }

            // Update transform immediately from transform asset
            updateTransform();

            // Update whenever the asset changes
            asset.onUpdated = updateTransform;

            function updateTransform() {
                object.pivot = asset.pivot;
                object.translate = asset.translate;
                object.scale = asset.scale;
                object.rotate = asset.rotate;

                object._buildMatrix();
            }
        }
    };

    var RENDER_ASSETS = {
        geometry: true,
        material: true,
        transform: true
    };

    Human.scene.Object.prototype.attachAsset = function (type, asset) {
        if (RENDER_ASSETS[type] && this.isLeaf()) {
            this._attachRenderAsset(type, asset);
        } else {
            ASSET_HANDLERS[type](this, asset);
            this.attachedAssets[type] = true;
        }
    };

    Human.scene.Object.prototype.detachAsset = function (type) {

        switch (type) {
            case "geometry":
                Human.renderer.graph.detachNodes(this._rootNode, "geometry");
                this.geometry = null;
                this._boundedAsset = null;
                this._boundaryDirty = true;
                Human.assets.putAsset(this.geometryId);
            break;
            case "material":
                Human.renderer.graph.detachNodes(this._rootNode, "material");
                Human.renderer.graph.detachNodes(this._rootNode, "fresnel");
                Human.renderer.graph.detachNodes(this._rootNode, "texture");
                this.material = null;
                Human.assets.putAsset(this.materialId);
            break;
            case "transform":
                // Don't detach transform node, since it's the root of the subtree
                this.setTransform({
                    translate: {x: 0, y: 0, z: 0},
                    rotate: {x: 0, y: 0, z: 0},
                    scale: {x: 1, y: 1, z: 1},
                    pivot: {x: 0, y: 0, z: 0}
                });
                this._transform = null;
                this.setReflectedX(false);
                this.setReflectedY(false);
                this.setReflectedZ(false);
                Human.assets.putAsset(this.transformId);
            break;
            case "morph":
                Human.renderer.graph.detachNodes(this._rootNode, "morph");
                this.morph = null;
                this._boundedAsset = null;
                this._boundaryDirty = true;
                Human.assets.putAsset(this.morphId);
            break;
        }

        this.attachedAssets[type] = false;
    };

    Human.scene.Object.prototype._attachRenderAsset = function (type, asset) {
        if (this.isRenderable()) {
            ASSET_HANDLERS[type](this, asset);
            this.attachedAssets[type] = true;
            return;
        }

        this.attachedAssets[type] = true;
        this._pendingAssets[type] = asset;

        if (this.isRenderable()) {
            // Just became renderable!

            var pendingAssets = this._pendingAssets;

            for (var pendingType in pendingAssets) {
                if (pendingAssets.hasOwnProperty(pendingType)) {
                    ASSET_HANDLERS[pendingType](this, pendingAssets[pendingType]);
                }
            }

            this._pendingAssets = {};

            Human.view.annotations.showByObjectId(this.objectId);

            Human.events.fire("scene.objectRenderable", {
                objectId: this.objectId
            });
        }
    };

    Human.scene.Object.prototype.isRenderable = function () {
        return !!(this.attachedAssets.geometry && this.attachedAssets.material &&
                    (this.attachedAssets.transform || !this.transformId));
    };

    Human.scene.Object.prototype.isLeaf = function () {
        return !this.objects || this.objects.length === 0;
    };

    // Notifies objects on path to root that geometry sub-object has loaded.
    Human.scene.Object.prototype._subObjectReady = function (object) {
        this.numSubObjectsLoaded++;
        this._boundaryDirty = true;
        if (this.numSubObjects > 0 && this.numSubObjects === this.numSubObjectsLoaded) {
            // This is a group object and all its sub-objects have loaded
            if (this.parent) {
                // Notify parent
                this.parent._subObjectReady(this);
            }
        }
        // Relay notifications from sub-objects
        if (this.parent) {
            // Notify parent
            this.parent._subObjectReady(object);
        }
    };

    /**
     * Sets modelling transformation for this object
     *
     * @param {*} params Transform
     * @param {*} params.pivot Pivot point
     * @param {*} params.translate Translation vector
     * @param {*} params.scale Scaling vector
     * @param {*} params.rotate Rotation vectors
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setTransform = function (params) {

        if (this._transform) {

            // This object has a transform asset, so direct the update to that.

            // The transform asset will then fire an 'updated' event back at this object,
            // triggering the matrix rebuild.

            this._transform.set(params);
            return;
        }

        if (this.pivot === null) {
            this.pivot = {x: 0, y: 0, z: 0};
            this.translate = {x: 0, y: 0, z: 0};
            this.rotate = {x: 0, y: 0, z: 0};
            this.scale = {x: 1, y: 1, z: 1};
        }

        // Otherwise, update the transform parameters on this object and rebuild the matrix.
        // @deprecated


        if (params.pivot) {
            if (params.pivot.x !== undefined) {
                this.pivot.x = params.pivot.x;
            }
            if (params.pivot.y !== undefined) {
                this.pivot.y = params.pivot.y;
            }
            if (params.pivot.z !== undefined) {
                this.pivot.z = params.pivot.z;
            }
        }

        if (params.translate) {
            if (params.translate.x !== undefined) {
                this.translate.x = params.translate.x;
            }
            if (params.translate.y !== undefined) {
                this.translate.y = params.translate.y;
            }
            if (params.translate.z !== undefined) {
                this.translate.z = params.translate.z;
            }
        }

        if (params.scale) {
            if (params.scale.x !== undefined) {
                this.scale.x = params.scale.x;
            }
            if (params.scale.y !== undefined) {
                this.scale.y = params.scale.y;
            }
            if (params.scale.z !== undefined) {
                this.scale.z = params.scale.z;
            }
        }

        if (params.rotate) {
            if (params.rotate.x !== undefined) {
                this.rotate.x = params.rotate.x;
            }
            if (params.rotate.y !== undefined) {
                this.rotate.y = params.rotate.y;
            }
            if (params.rotate.z !== undefined) {
                this.rotate.z = params.rotate.z;
            }
        }

        this._buildMatrix();
    };



    var pivotMat = mat4.create();
    var scaleMat = mat4.create();
    var translateMat = mat4.create();
    var rotateZMat = mat4.create();
    var rotateYMat = mat4.create();
    var rotateXMat = mat4.create();
    var tempMat = mat4.create();

    Human.scene.Object.prototype._buildMatrix = function () {
        var pivot = this.pivot;
        var translate = this.translate;
        mat4.fromTranslation(pivotMat, [-pivot.x, -pivot.y, -pivot.z]);
        var scale = this.scale;
        mat4.fromScaling(scaleMat, [scale.x, scale.y, scale.z]);
        mat4.fromTranslation(translateMat, [translate.x + pivot.x, translate.y + pivot.y, translate.z + pivot.z]);
        var rotate = this.rotate;
        mat4.fromRotation(rotateZMat, rotate.z * Math.PI / 180.0, Human.math.Z_AXIS);
        mat4.fromRotation(rotateYMat, rotate.y * Math.PI / 180.0, Human.math.Y_AXIS);
        mat4.fromRotation(rotateXMat, rotate.x * Math.PI / 180.0, Human.math.X_AXIS);
        mat4.identity(tempMat);
        mat4.multiply(tempMat, pivotMat, tempMat);
        mat4.multiply(tempMat, scaleMat, tempMat);
        mat4.multiply(tempMat, rotateXMat, tempMat);
        mat4.multiply(tempMat, rotateYMat, tempMat);
        mat4.multiply(tempMat, rotateZMat, tempMat);
        mat4.multiply(tempMat, translateMat, tempMat);
        this.matrix = tempMat;
        this.getTransformNode().setElements(this.matrix);

        this._setBoundaryDirty();
    };

    Human.scene.Object.prototype.getTransformNode = function () {
        this._transformNode = this._transformNode || this._initTransformNode();

        return this._transformNode;
    };

    Human.scene.Object.prototype._initTransformNode = function() {

        var children = [];

        if (this._rootNode) {
            this._rootNode.disconnect();
            children.push(this._rootNode);
        }

        this._gatherChildRootNodes(children);

        this._transformNode = Human.renderer.graph.createSubtree(this._getParentContainerNode(), {
            type: "xform"
        });

        this._transformNode.addNodes(children);

        this._rootNode = this._childNodeContainer = this._transformNode;

        return this._transformNode;
    };

    Human.scene.Object.prototype._getParentContainerNode = function() {
        var parent = this.parent;

        while (parent) {
            if (parent._childNodeContainer) {
                return parent._childNodeContainer;
            }

            parent = parent.parent;
        }

        return null;
    };

    Human.scene.Object.prototype._gatherChildRootNodes = function(children) {
        var objects = this.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            var object = objects[i];
            if (object._rootNode) {
                object._rootNode.disconnect();
                children.push(object._rootNode);
            } else {
                object._gatherChildRootNodes(children);
            }
        }
    };

    Human.scene.Object.prototype._setBoundaryDirty = function () {
        this._boundaryDirty = true;
        this._setSubBoundaryDirty();
        this._setAncestorBoundaryDirty();
    };

    // Returns true if this object is in a negatively-scaled coordinate space
    // where the scaling may be done by this object's transform, or a transform
    // on a parent.
    Human.scene.Object.prototype.reflectedTransform = function () {
        var negatedAxes = 0;
        if (this.reflectedX) {
            ++negatedAxes;
        }
        if (this.reflectedY) {
            ++negatedAxes;
        }
        if (this.reflectedZ) {
            ++negatedAxes;
        }

        return negatedAxes % 2 === 1;
    };

    Human.scene.Object.prototype._setAncestorBoundaryDirty = function () {
        for (var parent = this.parent; parent && !parent._boundaryDirty; parent = parent.parent) {
            parent._boundaryDirty = true;
        }
    };

    Human.scene.Object.prototype._setSubBoundaryDirty = function () {
        var child;
        for (var i = 0, len = this.objects.length; i < len; i++) {
            child = this.objects[i];
            if (!child._boundaryDirty) {
                child._boundaryDirty = true;
                child._setSubBoundaryDirty();
            }

        }
    };

    Human.scene.Object.prototype._checkFlippedWinding = function () {
        if (this._propertiesNode) {
            var flip = this.reflectedTransform();
            var defaultWinding = this.windingOrder;
            var flippedWinding = this.windingOrder === "ccw" ? "cw" : "ccw";
            this._propertiesNode.setFrontface(flip ? flippedWinding : defaultWinding);
        }

    };

    /**
     * Returns this object's World-space boundary
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Object.prototype.getBoundary = function () {
        if (this._boundaryDirty) {
            this._rebuildBoundary();
        }
        return this._boundary;
    };

    /**
     * Returns this object's World-space matrix
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Object.prototype.getWorldMatrix = function () {
        if (this._transformNode) {
            return this._transformNode.getWorldMatrix();
        }

        var parentXform = this._getParentContainerNode();

        if (parentXform) {
            return parentXform.getWorldMatrix();
        }

        return mat4.create();
    };

    /**
     * Returns inverse of all ancestor transforms
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Object.prototype.getWorldToObjectMatrix = function () {
        mat4.invert(this._worldToObjectMatrix, this.parent.getWorldMatrix());

        return this._worldToObjectMatrix;
    };

    /**
     * Gets this object's World-space boundary center
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.getCenter = function () {
        if (this._boundaryDirty) {
            this._rebuildBoundary();
        }
        return this._center;
    };

    Human.scene.Object.prototype._rebuildBoundary = function () {
        if (!this._boundaryDirty) {
            return;
        }

        var i, len;

        // Initial inside-out boundary, ready to expand to fit geometry or sub-objects
        this._boundary = {
            xmin: 1000000.0,
            ymin: 1000000.0,
            zmin: 1000000.0,
            xmax: -1000000.0,
            ymax: -1000000.0,
            zmax: -1000000.0
        };
        // Expand boundary to enclose world-space boundaries of any
        // geometry and morph assets that are referenced by this object
        if (this._boundedAsset) {
            var matrix = this.getWorldMatrix();
            var axisBoundary;
            var worldBoundary;
            var boundedAsset = this._boundedAsset;
            if (typeof boundedAsset.updateBoundary === "function") {
                boundedAsset.updateBoundary();
            }
            axisBoundary = boundedAsset.axisBoundary;
            if (axisBoundary) {
                worldBoundary = this._getBoundary(axisBoundary, matrix);
                this._expandBoundary(this._boundary, worldBoundary);
            }
        }
        // Expand boundary to enclose sub-objects
        var object;
        for (i = 0, len = this.objects.length; i < len; i++) {
            object = this.objects[i];
            if (object._boundaryDirty) {
                object._rebuildBoundary();
            }
            this._expandBoundary(this._boundary, object._boundary);
        }
        // Find center of boundary
        this._center = [
            (this._boundary.xmax + this._boundary.xmin) * 0.5,
            (this._boundary.ymax + this._boundary.ymin) * 0.5,
            (this._boundary.zmax + this._boundary.zmin) * 0.5
        ];
        this._boundaryDirty = false;
    };

    var position = vec3.create();

    // Get minimal boundary enclosing the given vertex array
    Human.scene.Object.prototype._getBoundary = function (endPoints, matrix) {
        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var x, y, z;
        var min = new Float32Array(endPoints.buffer, 0, 3);
        var max = new Float32Array(endPoints.buffer, 12, 3);
        for (var i = 0; i < 8; i++) {
            position[0] = i & 1 ? min[0] : max[0];
            position[1] = i & 2 ? min[1] : max[1];
            position[2] = i & 4 ? min[2] : max[2];
            vec3.transformMat4(position, position, matrix);
            x = position[0];
            y = position[1];
            z = position[2];

            if (x < xmin) {
                xmin = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (z < zmin) {
                zmin = z;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y > ymax) {
                ymax = y;
            }
            if (z > zmax) {
                zmax = z;
            }
        }
        return {xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax};
    };

    Human.scene.Object.prototype._expandBoundary = function (a, b) {
        if (a.xmin > b.xmin) {
            a.xmin = b.xmin;
        }
        if (a.ymin > b.ymin) {
            a.ymin = b.ymin;
        }
        if (a.zmin > b.zmin) {
            a.zmin = b.zmin;
        }
        if (a.xmax < b.xmax) {
            a.xmax = b.xmax;
        }
        if (a.ymax < b.ymax) {
            a.ymax = b.ymax;
        }
        if (a.zmax < b.zmax) {
            a.zmax = b.zmax;
        }
    };

    /** Add a child object and notify super-objects
     */
    Human.scene.Object.prototype.__addObject = function (object) {
        this.objects.push(object);
        this._subObjectAdded(object);
    };

    /**
     * Notitify nodes on path to root that child object created.
     * Each object counts how many geometry sub-objects are created.
     *
     * NOTE - All objects are created before any of them start to load,
     * so there should be no race condition between this method and _subObjectReady.
     */
    Human.scene.Object.prototype._subObjectAdded = function (object) {
        this.numSubObjects++;
        this._boundaryDirty = true;
        if (this.parent) {
            this.parent._subObjectAdded(object);
        }
    };

    /**
     * Show/hide this object
     * Only has effect on leaf objects, ignored on branch objects
     * @param {Boolean} doShow Flag specifying whether or not to show
     * @private
     */
    Human.scene.Object.prototype.show = function (doShow) {
        if (this.shown !== doShow) {
            if (this._propertiesNode) {
                this._propertiesNode.setEnabled(doShow);
            }
            this.shown = doShow;

            Human.view.annotations.showByObjectId(this.objectId);

            if(this.isLeaf()) {
                var eventName = "scene.object" + (this.shown ? "Shown" : "Hidden");

                Human.events.fire(eventName, {
                    objectId: this.objectId
                });
            }
        }
    };


    /**
     * Select/deselect this object
     * @param {Boolean} doSelect Flag specifying whether or not to select
     * @private
     */
    Human.scene.Object.prototype.select = function (doSelect) {
        if (this.selected !== doSelect) {
            this.selected = doSelect;

            if(this.isLeaf()) {
                var eventName = "scene.object" + (this.selected ? "Selected" : "Deselected");

                Human.events.fire(eventName, {
                    objectId: this.objectId
                });
            }
        }
    };


    /**
     * Set degree of transparency of this object - sets property, but only does something if this object has scene content
     *
     * @param {Number} opacity Degree of transparency between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setOpacity = function (opacity) {
        if (this._propertiesNode) {
            this._propertiesNode.setProperties({opacity: opacity});
            this.opacity = opacity;
        }

    };

    /**
     * Set whether or not object appears X-rayed
     * Only has effect on leaf objects, ignored on branch objects
     * @param {boolean} xray True to make object appear X-rayed
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setXRay = function (xray) {
        this.setXRayColors(xray);
        this.xray = xray;
    };

    /*
    *  Use xray colors without changing object "xray" flag
    */
    Human.scene.Object.prototype.setXRayColors = function (xray) {
        if (this._propertiesNode) {
            this._propertiesNode.setProperties({
                xray: xray,
                backfaces: !xray && this.backfaces
            });
        }
    };

    /** When transparent, this sets the degree of "facing ratio" effect, which is
     * where the object becomes more opaque towards the edges.
     * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} glassFactor Degree of effect between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setGlassFactor = function (glassFactor) {
        this.glassFactor = glassFactor;
        if (this._propertiesNode) {
            this._propertiesNode.setProperties({glassFactor: glassFactor});
        }
    };

    /** When transparent, this sets the degree of "murkiness" effect.
     * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} murkiness Degree of effect between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setMurkiness = function (murkiness) {
        this.murkiness = murkiness;
        if (this._propertiesNode) {
            this._propertiesNode.setProperties({murkiness: murkiness});
        }
    };

    /**
     * Sets whether or not this object is pickable
     * Only has effect on leaf objects, ignored on branch objects
     * @param pickable
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setPickable = function (pickable) {
        if (this.pickable !== pickable) {
            if (this._propertiesNode) {
                this._propertiesNode.setPicking(pickable);
            }
            this.pickable = pickable;
        }
    };

    /**
     * Sets whether or not this object is clippable
     * Only has effect on leaf objects, ignored on branch objects
     * @param clippable
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setClippable = function (clippable) {
        if (this.clippable !== clippable) {
            if (this._propertiesNode) {
                this._propertiesNode.setClipping(clippable);
            }
            this.clippable = clippable;
        }
    };

    /**
     * Sets whether or not this object is highlighted - only affects leaf objects
     * @param highlight
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setHighlight = function (highlight) {
        if (this._propertiesNode) {
            if (highlight) {
                var color = Human.renderer.highlightColor;
                this.setTintColor(color[0], color[1], color[2]);
            } else {
                this.setTintColor(1, 1, 1);
            }
            this.highlight = highlight;
        }
    };

    // Default = (1, 1, 1)
    Human.scene.Object.prototype.setTintColor = function (r, g, b) {
        if (this._propertiesNode) {
            this._propertiesNode.setProperties({tintColor: {
                r: r,
                g: g,
                b: b
            }});
        }
    };

    // Default = 0
    Human.scene.Object.prototype.setSaturation = function (saturation) {
        if (this._propertiesNode && this.saturation !== saturation) {
            this._propertiesNode.setProperties({saturation: saturation});
            this.saturation = saturation;
        }
    };

    // Default = 0
    Human.scene.Object.prototype.setContrast = function (contrast) {
        if (this._propertiesNode && this.contrast !== contrast) {
            this._propertiesNode.setProperties({contrast: contrast});
            this.contrast = contrast;
        }
    };

    // Default = 0
    Human.scene.Object.prototype.setBrightness = function (brightness) {
        if (this._propertiesNode && this.brightness !== brightness) {
            this._propertiesNode.setProperties({brightness: brightness});
            this.brightness = brightness;
        }
    };


    /**
     * Sets whether or not this object shows backfaces.
     * Only has effect on leaf objects, ignored on branch objects
     * @param backfaces
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setBackfaces = function (backfaces) {
        if (this.backfaces !== backfaces) {
            if (this._propertiesNode) {
                this._propertiesNode.setBackfaces(!this.xray && backfaces);
            }
            this.backfaces = backfaces;
        }
    };

    Human.scene.Object.prototype.setReflectedX = function (reflected) {
        this.reflectedX = reflected;

        for (var i = 0, len = this.objects.length; i < len; ++i) {
            this.objects[i].setReflectedX(reflected);
        }

        this._checkFlippedWinding();
    };

    Human.scene.Object.prototype.setReflectedY = function (reflected) {
        this.reflectedY = reflected;

        for (var i = 0, len = this.objects.length; i < len; ++i) {
            this.objects[i].setReflectedY(reflected);
        }

        this._checkFlippedWinding();
    };

    Human.scene.Object.prototype.setReflectedZ = function (reflected) {
        this.reflectedZ = reflected;

        for (var i = 0, len = this.objects.length; i < len; ++i) {
            this.objects[i].setReflectedZ(reflected);
        }

        this._checkFlippedWinding();
    };

    Human.scene.Object.prototype._destroy = function () {
        if (this._destroyed) {
            return;
        }

        // Implicitly destroys all the render graph nodes created with Human.renderer.graph.insertNode.
        // No effect if subtree node already destroyed.
        if (this._rootNode) {
            Human.renderer.graph.destroySubtree(this._rootNode);
        }

        Human.view.annotations.destroyByObjectId(this.objectId);
    };

    Human.scene.Object.prototype._removeObject = function (objectId) {
        for (var i = 0, len = this.objects.length; i < len; i++) {
            if (this.objects[i].objectId === objectId) {
                this.objects.splice(i, 1);
                // Update subObj count in parent and ancestors
                this._subObjectRemoved();
                return;
            }
            this._setBoundaryDirty();
        }
    };

    Human.scene.Object.prototype._subObjectRemoved = function () {
        this.numSubObjects--;
        // TODO:// LATER -- FIX OTHER BUGS FIRST
        // if (this.parent) {
        //     this.parent._updateAncestorSubObj();
        // }
    };

    // ------------------ EXPLICIT DEFAULTS -----------------------------------
    var defaultProperties = {
        "shown": {setter: Human.scene.Object.prototype.show, value: false, keyable: true, type:"boolean"},
        "selected": {setter: Human.scene.Object.prototype.select, value: false, keyable: false, type:"boolean"},
        "pickable": {setter: Human.scene.Object.prototype.setPickable, value: true, keyable: false, type:"boolean"},
        "backfaces": {setter: Human.scene.Object.prototype.setBackfaces, value: false, keyable: false, type:"boolean"},
        "glassFactor": {setter: Human.scene.Object.prototype.setGlassFactor, value: 0.0, keyable: false, type:"number"},
        "murkiness": {setter: Human.scene.Object.prototype.setMurkiness, value: 1.0, keyable: false, type:"number"},
        "opacity": {setter: Human.scene.Object.prototype.setOpacity, value: 1.0, keyable: true, type:"number"}
    };

    //NOTE[XRAY]
    //"xray": {setter: Human.scene.Object.prototype.setXRay, value:false, keyable:false, type:"boolean"}


    var defaultPropertyKeys = Object.keys(defaultProperties);

    Human.scene.Object.prototype.getDefaultFlags = function () {
        return {
            picking: this.pickable,
            enabled: false,
            specular: true,
            backfaces: false,
            reflection: true,
            solid: Human.scene.enableSolidObjects
        };
    };

    Human.scene.Object.prototype.getDefaultProperties = function(){
        var result = {};

        for (var i = 0, len = defaultPropertyKeys.length; i < len; i++) {
            var prop = defaultPropertyKeys[i];
            result[prop] = defaultProperties[prop].value;
        }

        return result;
    };

    Human.scene.Object.prototype.getProperties = function(){
        var self = this;
        var result = {};

        for (var i = 0, len = defaultPropertyKeys.length; i < len; i++) {
            var prop = defaultPropertyKeys[i];
            result[prop] = self[prop];
        }

        return result;
    };

    // Set properties of an individual object ONLY. No traversal.
    Human.scene.Object.prototype.setProperties = function(overrides){
        overrides = overrides || {};
        var self = this;
        var target;
        var pvalue;

        for (var i = 0, len = defaultPropertyKeys.length; i < len; i++) {
            var prop = defaultPropertyKeys[i];
            target = defaultProperties[prop];
            pvalue = overrides[prop] !== undefined ? overrides[prop] : target.value;

            if (self[prop] !== pvalue){
                target.setter.call(self, pvalue);
            }
        }
    };



    // -----------------  QUICK AND DIRTY TRAVERSAL ---------------------------

    Human.scene.Object.prototype.traverseUp = function(callback){
        callback(this);
        if (this.parent) {
            this.parent.traverseUp(callback);
        }
    };

    Human.scene.Object.prototype.traverseDown = function(callback){
        callback(this);
        for (var i = 0, len = this.objects.length; i < len; i++) {
            this.objects[i].traverseDown(callback);
        }
    };

    Human.scene.Object.prototype.getLeafObjects = function(callback){
        var leafObjects = [];

        this.traverseDown(function (child) {
            if(child.isLeaf()) {
                leafObjects.push(child);

                if(callback) {
                    callback(child);
                }
            }
        });

        return leafObjects;
    };

    Human.scene.Object.prototype.getRenderableObjects = function(callback){
        var leafObjects = [];

        this.traverseDown(function (child) {
            if(child.isRenderable()) {
                leafObjects.push(child);

                if(callback) {
                    callback(child);
                }
            }
        });

        return leafObjects;
    };

})();
;/** Set Operations and Getters on key-value maps
 * Compares membership of keys between two maps.
 * Returns a new map.
 *
 * Membership is determined by map key by defualt.
 * Optional function to return the value associated with member key in final set; if null
 * the key-value pair will be ignored entirely.
 * Function can return 'null' (and only null) to override otherwise matching keys.
 *
 * NOTES:
 *   - If using objectIds as keys, assume that the objectds have been globalized.
 *   - Assumes set arguemnts are hash-maps (objects with no non-native function properties).
 *   - Assumes maps are not hierarchical i.e. each map value is a simple key-value map with native value types.
 *   - No assumption that values have to have the same properties.
 *   - Presrve optional selector functions where appropriate.
 *   - Support values of type "boolean" and of type "objects"
 *
 * TODO: We could consider making the below functions prototypes of a custom Human Object Set class.
 *  That way we could do operation chaining.
 *
 * TODO: Expand "*" placeholders if present.
 *
 * TODO: Make sure the original sets aren't being altered.
*/
(function () {
    "use strict";
    var sets = Human.scene.sets = {};

    // -------------- DEFAULTS ----------------------------------------------
    // Prefer item2 if it exists;
    var defaultSelector = function(item1, item2){
      // Allow for item1, item2 to be of type "booleans" as well as of type "objects".
      var ignoreValues = [null, undefined];
      if (ignoreValues.indexOf(item2) < 0) {
        return item2;
      }
      else if (ignoreValues.indexOf(item1) < 0){
        return item1;
      }
      else {
        return null;
      }
    };

    // Check for item in set keys.
    var defaultSetMembership = function(item, key){
      return (key === item)? true : false;
    };

    // --------------- GETTERS -----------------------------------------------

    /** Get list of all keys.
     * Returns a list of unique keys.
     * Optional Selector to filter keys.
    */
    sets.keys = function(aset, fnSelector){
      fnSelector = fnSelector || false;
      var oKeys = Object.keys(aset);

      var result = [];
      if (!fnSelector){
        result = oKeys; // return all keys
      } else {
        oKeys.forEach(function(key){
          if (fnSelector(key)){
            result.push(key);
          }
        });
      }
      return result;
    };


    /** Get subset of keys containing a regular expression
     * Returns a list of keys satisfying a regular expression.
    */
    sets.filterKeys = function(aset, regexp){
      var pattern;
      var result = [];
      // Ensure regular expression
      if (regexp instanceof RegExp){
        pattern = regexp;
      } else {
        try {
          pattern = new RegExp(regexp);
        }
        catch (err){
          return {};
        }
      }

      var isok = function(key){
        return pattern.test(key);
      };

      result = sets.keys(aset).filter(isok);
      return result;

    };

    /** Get list of keys where value satisfied a condition
     * fnCondition(value) returns true if value satisfies some condition.
    */
    sets.keysWhere = function(aset, fnCondition){
      var result = [];
      for (var key in aset){
        if (aset.hasOwnProperty(key)){
          if (fnCondition(aset[key])){
            result.push(key);
          }
        }
      }
      return result;
    };

    /** Get membership status of key in set.
     * Returns true/false if key is a member of aset.
    */
    sets.hasKey = function(aset, key){
      var keys = sets.keys(aset);
      if (keys.indexOf(key)>=0){
        return true;
      } else {
        return false;
      }
    };

    /** Return Iterator over key,value pairs of set
    */
    sets.getSetIterator = function(set){

      var index = 0, keys = sets.keys(set), length = keys.length;

      return {
        next: function(){
            var item;
            if (!this.hasNext()){ return null;}
            var key = keys[index];
            item = {"key":key,"value":set[key]};
            index ++;
            return item;
        },
        hasNext: function(){ return index < length;},
        rewind: function(){index=0; return set[keys[0]];},
        current: function(){
          return set[keys[index]];
        }
      };
    };

    /** Get list of all values
     * Returns a list of values for each unique key in set.
     * The order of values will match the order of keys.
    */
    sets.values = function(aset){
      var keys = sets.keys(aset);
      var result = [];
      keys.forEach(function(key){
        result.push(aset[key]);
      });
      return result;
    };

    /** Get list of keys in EITHER set1 OR set2
     * NOTE: http://stackoverflow.com/questions/1723168/what-is-the-fastest-or-most-elegant-way-to-compute-a-set-difference-using-javasc
    */
    sets.jointKeys = function(set1, set2){
      var h = {}, f = function (v) { h[v] = true; };
      var keySet1 = sets.keys(set1);
      var keySet2 = sets.keys(set2);
      keySet1.forEach(f);
      keySet2.forEach(f);
      return sets.keys(h);
    };

    /** Get list of intersecting keys in BOTH set1 AND set2
    */
    sets.commonKeys = function(set1, set2){
      var h = {};
      var keySet1 = sets.keys(set1);
      var keySet2 = sets.keys(set2);
      keySet1.forEach(function(v){ h[v] = 1; });
      keySet2.forEach(function(v){ h[v] = (h[v] || 0) + 1; });
      return sets.keysWhere(h, function(v){ return v>1? true : false;});
    };

    /** Get list of keys IN set1 but NOT in set2
    */
    sets.uniqueKeys = function(set1, set2){
      var h = {};
      var f1 = function(v){h[v] = 1;};
      var f2 = function(v){h[v] = 0;};
      var keySet1 = sets.keys(set1);  // order matters
      var keySet2 = sets.keys(set2);  // set 2 comes after set 1!!
      keySet1.forEach(f1);
      keySet2.forEach(f2);
      return sets.keysWhere(h, function(v){return v>0? true: false;});
    };

    //--------------------- SET OPERATIONS -------------------------------------

    /** Get union of key-value pairs
     * Returns new key-value map with keys jointly in set1 and set2
     *
     * Optional Argument: fnSelector() function
     *  - selector = function(itemSet1,itemSet2);
     *  - returns value made from properties of itemSet1 and itemSet2
    */
    sets.union = function(set1, set2, fnSelector){
      var uKeys, union = {};
      var ph = null; // placeholder

      // Setup default selector function.
      if (!fnSelector){
        fnSelector = defaultSelector;
      }

      // Get joint keys and set the desired value to each key.
      uKeys = sets.jointKeys(set1, set2);
      uKeys.forEach(function(key){
        ph = fnSelector(set1[key], set2[key]);
        if (ph !== null){
          union[key] =  ph;
        }
      });
      return union;
    };

    /** Get intersection of key-value pairs
    */
    sets.intersection = function(set1, set2, fnSelector){
      var iKeys, intersection = {}, ph = null;
      if (!fnSelector){
        fnSelector = defaultSelector;
      }

      // Get intersecting keys and the preferred value;
      iKeys = sets.commonKeys(set1, set2);
      iKeys.forEach(function(key){
        ph = fnSelector(set1[key], set2[key]);
        if (ph !== null) {
          intersection[key] = ph;
        }
      });
      return intersection;
    };

    /** Get elements in set1 that are NOT in set 2
    * fnSelector can return null to prohibit key-value pair.
    */
    sets.difference = function(set1, set2, fnSelector){
      var unqKeys = sets.uniqueKeys(set1, set2), ph=null;
      if (!fnSelector){
        fnSelector = defaultSelector;
      }
      var uniqueToSet1 = {};
      unqKeys.forEach(function(key){
        ph = fnSelector(set1[key]);
        if (ph !== null){
          uniqueToSet1[key] = ph;
        }
      });
      return uniqueToSet1;
    };

    /** Ask if item is contained in set
     * fnSatisfy(item, key, value): returns true if item satisfied a condition.
     *   Default tests membership of key in set.
    */
    sets.isin = function(item, set1, fnSatisfy){
      if (!fnSatisfy){
        fnSatisfy = defaultSetMembership;
      }

      var found = false;
      var setIter = sets.getSetIterator(set1);
      var kvp;
      while (setIter.hasNext() && !found){
        kvp = setIter.next();
        found = fnSatisfy(item, kvp.key, kvp.value);
      }
      return found;
    };

    // -------------------- SET OPERATIONS ON Directed Acyclic Graphs ----------
    // TODO: Expand the set operations to consider hierarchical sets in a Directed Acyclic Graph.


  })();
;(function() {
    "use strict";

    var graph = Human.scene.graph = {};

    // Store attached assets by type for a given sesssion
    var attachedAssets = {};
    var numRequestedAssets = 0;
    var numAttachedAssets = 0;

    var anonymousObjectCount = 0;

    var typesToDetach = {}; // HACK to selectively detach assets from tree

    // Load objects into scene from the scene defintion
    graph.buildSceneGraph = function(scene, stateId) {
        var rootObjects = [];
        anonymousObjectCount = 0;

        buildGraph(scene, null, stateId, rootObjects);
        return rootObjects;
    };

    // Simple Graph Construction from fully specified scene graph
    graph.buildGraph = function(objects, parent) {
        // Exit if no objects
        if (!objects) {
            return;
        }
        var object, humanObject;
        for (var i = 0; i < objects.length; i++) {
            object = objects[i];
            object.anonymous = false;

            // Anonymous objects
            if (!object.objectId) {
                object.objectId = parent.objectId + anonymousObjectCount++;
                object.anonymous = true;
            }

            humanObject = createHumanObject(object, parent);

            if (humanObject === null) {
                continue;
            }
            
            if (object.hasOwnProperty("objects")){
                graph.buildGraph(object.objects, humanObject);
            }
        }

    };

    function createHumanObject(object, parent) {

        var objectId = object.objectId;

        var geometryId = object.geometryId || null;
        var morphId = object.morphId || null;
        var materialId = object.materialId || null;
        var transformId = object.transformId || null;
        var regionMapId = object.regionMapId || null;

        // TODO: Support Anonymous Object

        // Do not overwrite existing objects
        if (Human.scene.objects[objectId]) {
            return null;
        }

        // Inherit parent layer if necessary
        if (object.layer === undefined) {
            object.layer = parent ? parent.layer : 0;
        }

        object.objectId = objectId;

        object.parent = parent;
        object.parentObjectId = parent ? parent.objectId : null;
        object.materialId = materialId;
        object.geometryId = geometryId;
        object.morphId = morphId;
        object.transformId = transformId;
        object.regionMapId = regionMapId; //TODO[EM]:Disable region-map while not officially supported?
        object.tags = object.tags || [];
        object.capColor = inherit("capColor", object, parent);
        object.modelId = object.objectId.split("-")[0];

        var sceneObject = Human.scene.createObject(object);

        if (object.opacity !== undefined) {
            sceneObject.setOpacity(object.opacity);
        }

        if (object.shown !== undefined) {
            sceneObject.show(object.shown);
        }

        return sceneObject;
    }


    /* Gather asset ids from a portion of the scene graph
     *
     *  return value format format:
     *      {
     *          "geometry": {
     *              "geometryId1": [target_object_id, ...],
     *              "geometryId2": [target_object_id, ...]
     *              // etc...
     *          }
     *          // etc...
     *      }
     *
     *  Result can be provided to gradually gather asset Ids over several
     *  calls.
     */

    graph.gatherAssetIdsFromObject = function(objects, types, result) {

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        types = types || ["geometry", "material", "transform", "morph"];

        result = result || {};

        for (var i = 0, len = objects.length; i < len; i++) {
            gatherAssetIdsFromObject(objects[i], types, result);
        }

        return result;
    };

    graph.attachAssetsToObject = function(objects, types, ok) {
        if (typeof types === "function") {
            ok = types;
            types = null;
        }

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        types = types || ["geometry", "material", "transform", "morph"];

        var assetsLoading = 0;

        function done() {
            if (--assetsLoading === 0 && ok) {
                ok();
            }
        }

        for (var i = 0, len = objects.length; i < len; i++) {
            var assetIds = graph.gatherAssetIdsFromObject(objects[i], types);
            assetsLoading++;
            graph.attachAssets(assetIds, done);
        }
    };

    /**
    *   This function encapsulates a common loading pattern where
    *   where assets are meant to be loaded in "phases" (e.g.
    *   geometry, transforms, materials first, then morphs later).
    *   By default, the phases will be:
    *   - Phase 1: geometry, materials, transforms
    *   - Phase 2: morphs
    *
    *   It will load subtrees of the argument objects and traverses up
    *   up the scenegraph from those objects to properly load hierarchical
    *   transforms.
    *
    *   Arguments:
    *   [array of objects]  objects     The roots of subtrees to attach assets to.
    *   [array of arrays]   typeSets    Groups of types to load per phase (e.g. [[["geometry", "material", "transform"], ["morph"]])
    *   [function]          ok          Callback function to call after each phase.
    *
    *   Note that the callback function is called after each phase, so
    *   it will be called multiple times. At each phase, the following arguments
    *   are passed to the callback function:
    *   [object]            typesLoaded A map of the asset types that were loaded.
    *   [number]            i           The index of the current phase
    *   [boolean]           done        Is this the last phase?
    */
    graph.attachAssetSetsToSubtree = function(objects, typeSets, ok) {
        if (typeof typeSets === "function") {
            ok = typeSets;
            typeSets = null;
        }

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        typeSets = typeSets || [["geometry", "material", "transform"], ["morph"]];

        var assetObjects = {};
        var orderedAssetObjects = [];
        var leafObjects = {};
        var objectId, object;

        function registerLeaf(leaf) {
            leafObjects[leaf.objectId] = leaf;
        }

        function registerObjectId(object) {
            if(!assetObjects[object.objectId]) {
                orderedAssetObjects.push(object);
                assetObjects[object.objectId] = true;
            }
        }

        for (var i = 0; i < objects.length; i++) {
            objects[i].getLeafObjects(registerLeaf);
        }

        for (objectId in leafObjects) {
            if (leafObjects.hasOwnProperty(objectId)) {
                object = leafObjects[objectId];

                if (object) {
                    // Traverse up for transforms
                    object.traverseUp(registerObjectId);
                }
            }
        }

        attachTypeSets(orderedAssetObjects, typeSets, 0, ok);
    };

    function attachTypeSets(assetObjects, typeSets, phase, ok) {
        var typeSet = typeSets.shift();

        attachTypeSet(assetObjects, typeSet, function () {
            if(ok) {
                var typesLoaded = {};
                for (var i = 0, len = typeSet.length; i < len; i++) {
                    typesLoaded[typeSet[i]] = true;
                }
                ok(typesLoaded, phase, !typeSets.length);
            }

            if(typeSets.length) {
                attachTypeSets(assetObjects, typeSets, phase + 1, ok);
            }
        });
    }

    function attachTypeSet(assetObjects, typeSet, ok) {
        var numObjects = assetObjects.length;
        var object;

        if (numObjects === 0) {
            if (ok) {
                Human.utils.async(ok);
            }
            return;
        }

        function done() {
            if (--numObjects === 0 && ok) {
                ok();
            }
        }

        for (var i = 0, len = numObjects; i < len; i++) {
            object = assetObjects[i];

            graph.attachAssetsToObject(object, typeSet, done);
        }
    }

    /** This function Loads the asset from Object Server.
    *   Then applies the asset to the Scene Graph
    */
    graph.attachAssets = function(assetIds, ok) {
        var assetsLoading = 0;

        function done() {
            if (--assetsLoading === 0 && ok) {
                ok();
            }
        }

        var keys = Object.keys(assetIds);

        if (keys.length === 0) {
            if (ok) {
                Human.utils.async(ok);
            }
            return;
        }

        for (var i = 0, len = keys.length; i < len; i++) {
            var type = keys[i];
            var typeAssets = assetIds[type];

            if (!typeAssets) {
                return;
            }

            for (var assetId in typeAssets) {
                if (typeAssets.hasOwnProperty(assetId)) {
                    var targetObjects = typeAssets[assetId];

                    assetsLoading++;
                    getAsset(assetId, type, targetObjects, done);
                }
            }
        }
    };

    /**
     * Removes assets from target objects.
     * @param objectIds
     */
    graph.destroySubtree = function(objects) {

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        var i;
        var len;
        var object;

        for (i = 0, len = objects.length; i < len; i++) {
            object = objects[i];

            object.traverseDown(destroyAssets);

            Human.scene.destroyObject(object.objectId);
        }
    };

    /**
     * Removes assets  of type specified in assetTypes from tree. Does not modify the tree itself.
     * @param objectIds
     */
    graph.unloadSubtree = function(objects, assetTypes, ok) {

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        var i;
        var len;
        var object;

        // Configure types to detach
        typesToDetach = {};
        if (assetTypes.indexOf("geometries")>=0){
            typesToDetach.geometryId = true;
        }
        if (assetTypes.indexOf("transforms")>=0){
            typesToDetach.transformId = true;
        }
        if (assetTypes.indexOf("morphs")>=0){
            typesToDetach.morphId = true;
        }
        if (assetTypes.indexOf("materials")>=0){
            typesToDetach.materialId = true;
        }

        if (assetTypes.indexOf("morph")>=0) {
          typesToDetach.morphId = true;
        }

        for (i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            object.traverseDown(destroyAssets);
        }
        if (ok){
            ok();
        }
    };

    function destroyAssets(child) {
        // HACK Configured by scoped variable "typesToDetach"
        if (typesToDetach.geometryId) {
            child.detachAsset("geometry");
        }

        if (typesToDetach.materialId) {
            child.detachAsset("material");
        }

        if (typesToDetach.transformId) {
            child.detachAsset("transform");
        }

        if (typesToDetach.morphId) {
            child.detachAsset("morph");
        }
    }

    function buildGraph(objects, parent, stateId, rootObjects) {
        if (!objects) {
            return;
        }

        if(!Array.isArray(objects)) {
            objects = [objects];
        }

        var humanObject;

        for(var i = 0; i < objects.length; i++) {
            var object = objects[i];

            object.anonymous = false;

            if (!object.objectId) {
                if (!parent) {
                    buildGraph(object.objects, null, stateId, rootObjects);
                    continue;
                }

                object.objectId = parent.objectId + anonymousObjectCount++;
                object.anonymous = true;
            }

            humanObject = createObject(object, parent, stateId);

            if (humanObject === null) {
                continue;
            }

            if (parent === null) {
                rootObjects.push(humanObject);
            }

            buildGraph(object.objects, humanObject, stateId, rootObjects);
        }
    }

    function gatherAssetIdsFromObject(object, types, assetIds) {

        for (var i = 0, len = types.length; i < len; i++) {
            var type = types[i];

            if (!object.attachedAssets[type]) {

                var assetId = object[type + "Id"];
                var assetList;

                if(assetId) {
                    assetIds[type] = assetIds[type] || {};

                    assetList = assetIds[type][assetId] = assetIds[type][assetId] || [];
                    assetList.push(object.objectId);
                }
            }
        }

        return assetIds;
    }

    function assetAttachStart() {
        Human.events.fire("graph.assetAttach.start");
    }

    function assetAttachProgress(assetId, type, targetObjects, nullAsset) {
        numAttachedAssets++;

        Human.events.fire("graph.assetAttach.progress", {
            assetId: assetId,
            targetObjects: targetObjects,
            assetType: type,
            nullAsset: nullAsset
        });

        if(!attachedAssets[type]) {
            attachedAssets[type] = [];
        }

        if(!nullAsset) {
            attachedAssets[type].push(assetId);
        }

        if(numRequestedAssets === numAttachedAssets) {
            assetAttachFinish();
        }
    }

    function assetAttachFinish() {
        Human.events.fire("graph.assetAttach.finish", attachedAssets);

        attachedAssets = {};
        numRequestedAssets = 0;
        numAttachedAssets = 0;
    }

    function getAsset(assetId, type, targetObjects, ok) {
        if(numRequestedAssets === 0) {
            assetAttachStart();
        }

        numRequestedAssets++;

        Human.assets.getAsset(assetId, type, function(asset) {

            if (asset) {
                for (var i = 0, len = targetObjects.length; i < len; i++) {
                    var objectId = targetObjects[i];
                    var object = Human.scene.objects[objectId];

                    if(object) {
                        object.attachAsset(type, asset);
                    }
                }
            }

            assetAttachProgress(assetId, type, targetObjects, !asset);

            ok(asset);
        });
    }

    function createObject(object, parent, stateId) {

        var objectId = object.objectId;

        var geometryId = object.geometryId || null;
        var morphId = object.morphId || null;
        var materialId = object.materialId || null;
        var transformId = object.transformId || null;
        var regionMapId = object.regionMapId || null;

        // Only add stateId to assets if they are not already prefixed
        if (stateId) {
            var stateIdObjectPrefix = stateId + "-";
            var stateIdAssetPrefix = stateId + "/";

            // UGH! Need to use old-style anonymous objectIds for bookmarks!
            if (objectId.indexOf(stateIdObjectPrefix) !== 0 || object.anonymous) {
                objectId = stateIdObjectPrefix + objectId;
            }
            if (geometryId && geometryId.indexOf(stateIdAssetPrefix) !== 0) {
                geometryId = stateIdAssetPrefix + geometryId;
            }
            if (morphId && morphId.indexOf(stateIdAssetPrefix) !== 0) {
                morphId = stateIdAssetPrefix + morphId;
            }
            if (materialId && materialId.indexOf(stateIdAssetPrefix) !== 0) {
                materialId = stateIdAssetPrefix + materialId;
            }
            if (transformId && transformId.indexOf(stateIdAssetPrefix) !== 0) {
                transformId = stateIdAssetPrefix + transformId;
            }
            if (regionMapId && regionMapId.indexOf(stateIdAssetPrefix) !== 0) {
                regionMapId = stateIdAssetPrefix + regionMapId;
            }
        }

        if (Human.scene.objects[objectId]) {
            return null;
        }

        if (object.layer === undefined) {
            object.layer = parent ? parent.layer : 0;
        }

        object.objectId = objectId;
        object.modelId = stateId;
        object.parent = parent;
        object.parentObjectId = parent ? parent.objectId : null;
        object.materialId = materialId;
        object.geometryId = geometryId;
        object.morphId = morphId;
        object.transformId = transformId;
        object.regionMapId = regionMapId;
        object.tags = object.tags || [];
        object.capColor = inherit("capColor", object, parent);

        var sceneObject = Human.scene.createObject(object);

        if (object.opacity !== undefined) {
            sceneObject.setOpacity(object.opacity);
        }

        return sceneObject;
    }

    function inherit(prop, object, parent) {
        if (parent) {
            if (object[prop] !== undefined && object[prop] !== null) {
                return object[prop];
            }
            return parent[prop];

        }
        return object[prop];
    }

})();
;/**
* @namespace Control of the master root timeline
* This namespace interfaces with the root timeline object.
*
* Responsibilities:
*     - Play chapters on tick events
*     - Issue and store play commands by specifying start and end conditions.
*             -- next chapter, previous chapter
*             -- start conditions: start time, start chapter id, start chpater index
*             -- end conditions: end time, end chapter id, end chapter index, number of chapters.
*
*     - Play state
*             -- playing, not playing (paused, stopped)
*     - Scrubbing
*             -- scrub to specific time in global timeline
*
* NOTE: Looping
* Any play block (set of time defined by time1 and time2) can be instructed to loop. The
* intention to loop is set via the HumanTimeline.play() command arguments. However, for backwards
* compatibility with some existing apps/widgets/content, single chapters can declare themselves to loop
* from the chapter definition directly. In this very specific edge case, we will use that loop property.
*
*
*
*
* TODO: Eventually animations should be loaded DIRECTLY into the leaf timelines. Now they are added to animations, then from animations
* into the leaf timeline. This is just easier for the time being.
*/

(function () {
    "use strict";

    //local namespace
    var HumanTimeline = Human.timeline = {};

    // Timelines Library
    HumanTimeline.animations = {};    // original animation assets
    HumanTimeline.leafTimelines = {};
    HumanTimeline.branchTimelines = {};
    HumanTimeline.rootTimelines = {};
    HumanTimeline.activeRoot = null;

    // Play Configuration
    HumanTimeline.FRAME_LENGTH = 0.033;
    HumanTimeline.TIME_CONSTANT = 1/1000;
    HumanTimeline.borderConditions = {
        start: {which: "second", direction: HumanTimeline.direction},
        middle: {which: "both", direction: HumanTimeline.direction},
        end: {which: "first", direction: HumanTimeline.direction}
    };


    // Play State Controls
    HumanTimeline.playing = false;          // true if use wants to play a block of root timeline.
    HumanTimeline.playfree = true;          // true if user wishes to play free animations
    HumanTimeline._lastWorldTime = 0.0;
    HumanTimeline._time1 = 0.0;             // time at start of play block
    HumanTimeline._time2 = 0.0;             // time at end of play block
    HumanTimeline._freeTime = 0.0;          // free time
    HumanTimeline.time = 0.0;               // current time; t1 <= t <= t2
    HumanTimeline.playQueue = [];           // Array of play instructions to be played in order.
    HumanTimeline.loop = false;             // Loops over entire t1-t2 play-block if true
    HumanTimeline.scale = 1.0;              // factor by which to advance time with tick (positive or negative).
    HumanTimeline.direction = "forwards";   // forwards if scale > 0 and "backwards" if scale < 0

    // Bookmark parameters
    HumanTimeline._playParams = null;
    HumanTimeline._scrubParams = null;


    // Backwards Comaptibitlity.
    HumanTimeline.chapters = {};      // Generated by root on timeline.updated event

    // TICK variables
    var root, timeNow, diff, dilation, bc;

    // ------------------------  LOADING AND REGISTERING ASSETS ---------------------------------------------------

    /** Registers an animation on the timeline
    * @memberof Human.timeline
    * @private
    */
    HumanTimeline.addAnimation = function (animationId, animation) {
        if (!animation.update) {
            Human.log.error("Human.timeline.addAnimation", "Param expected: update");
            return;
        }
        if (HumanTimeline.animations[animationId]) {
            HumanTimeline.removeAnimation(animationId);
        }
        HumanTimeline.animations[animationId] = animation;
        Human.events.fire("Timeline.Loaded");
    };

    /** Destroy animation(s) - either a specific animation, all animations associated with a given object,
    * or all animations indiscriminately
    * @memberof Human.timeline
    * @private
    */
    HumanTimeline.removeAnimation = function (animationId) {
        var animation = HumanTimeline.animations[animationId];
        if (!animation) {
            Human.log.warn("Human.timeline.removeAnimation", "Animation not found: " + animationId);
            return;
        }
        delete HumanTimeline.animations[animationId];
        if (animation.destroy) {
            animation.destroy(); // Destroy animation
        }

        if (Human.utils.isEmpty(HumanTimeline.animations)){
            Human.events.fire("Timeline.Empty");
        }

    };

    //  ----------------------- CLOCK TICK HANDLING ---------------------------------------------------------------
    // Return True if time is at the end of a play-block, False otherwise
    // Returns global time at which playblock ends.
    var getEndTime = function(){
        return (HumanTimeline.direction === "forwards")? HumanTimeline._time2 : HumanTimeline._time1;
    };

    // Returns global time at which playblock starts.
    var getStartTime = function(){
        return (HumanTimeline.direction === "forwards")? HumanTimeline._time1 : HumanTimeline._time2;
    };

    var playEnded = function(){
        var ref = getEndTime();
        if (HumanTimeline.time === ref){
            return true;
        } else{
            return false;
        }
    };

    // Return True if time is at the start of a play-block, False otherwise
    var playStarted = function(){
        var ref = getStartTime();
        if (HumanTimeline.time === ref){
            return true;
        } else{
            return false;
        }
    };

    /** Rules for root update on border times.
    * This only needs to be changed when the driection is set.
    *
    * "first/second" refers to the left/right branch at a border relative to root timeline.
    * "start/end" refers to time relative to the viewer.
    * "forwards/backwards" refers to left-to-right (and vice versa) relative to the root timeline.
    *
    * Example: first branch from the forwards direction is the same as the
    * second branch from the backwards direction, and vice versa.
    */
    var setBorderConditions = function(direction){
        var result = {};
        var coef = (direction === "backwards")? -1.0: 1.0;
        var validDirections = ["forwards", "backwards"];

        // validation
        if (validDirections.indexOf(direction) < 0){
            Human.log.warn("timeline.setBorderConditions", "invalid direction :" + direction);
            return null;
        }

        result.start = {which:"second", direction: direction};
        result.middle = {which: "both", direction: direction};
        result.end = {which: "first", direction: direction};

        HumanTimeline.direction = direction;
        HumanTimeline.borderConditions = result;
        HumanTimeline.scale = coef * Math.abs(HumanTimeline.scale);
    };


    HumanTimeline.initTransparencies = function(){
        Human.log.error("timeline.initTransparencies() is deprecated and no longer required for loading");
    };

    Human.events.on( "tick", function () {
        // Manage global time --------------------------------------
        root = HumanTimeline.activeRoot;
        if (root === null || root === undefined){
            return;
        }
        timeNow = (new Date()).getTime();
        diff = (timeNow - HumanTimeline._lastWorldTime) * HumanTimeline.TIME_CONSTANT;
        dilation = diff/HumanTimeline.FRAME_LENGTH;
        HumanTimeline._lastWorldTime = timeNow;
        if (HumanTimeline.time > HumanTimeline._time2) {
            HumanTimeline.time = HumanTimeline._time2;
        }
        else if (HumanTimeline.time < HumanTimeline._time1) {
            HumanTimeline.time = HumanTimeline._time1;
        }

        // Free Animations ------------------------------------------
        if (HumanTimeline.playfree){
            root.updateFreeAnimations(HumanTimeline._freeTime);
            HumanTimeline._freeTime += HumanTimeline.scale * dilation * HumanTimeline.FRAME_LENGTH;
        }


        // Branch Timelines ----------------------------------------------
        /**
        * Boundary conditions: Often a play block is the duration of a chapter.
        * At boundaries, the global time points to end/start times on two consecutive
        * branch timelines. Rules specified in the bounary condition dictate
        * whether both are played or just one and which one.
        *
        */
        if (HumanTimeline.playing){

            // Boundary conditions and play permissions
            bc = HumanTimeline.borderConditions.middle; //default
            var toPlay = true;
            if (playEnded()){
                if (HumanTimeline.loop === true){
                    // loop
                    bc = HumanTimeline.borderConditions.start;
                    HumanTimeline.time = getStartTime();
                } else {
                    // stop playing
                    bc = HumanTimeline.borderConditions.end;
                    toPlay = false;
                }
            } else if (playStarted()){
                bc = HumanTimeline.borderConditions.start;
            }

            // Play and adjust Play State based on time.
            root.update(HumanTimeline.time, bc);
            if (toPlay){
                HumanTimeline.playing = true;
                Human.events.fire("timeline.playing", {
                    time: HumanTimeline.time
                });
                HumanTimeline.time += HumanTimeline.scale * dilation * HumanTimeline.FRAME_LENGTH;
            }
            else {
                HumanTimeline.playing = false;
                Human.events.fire("timeline.stopped", {
                    time: HumanTimeline.time
                });
            }
        } // end handling of branch update

    }); // END TICK EVENT

    // Manage play queue:
    Human.events.on("timeline.stopped",function(){
        HumanTimeline.playQueue.shift();
        if (HumanTimeline.playQueue.length>0){
            var nextPlay = HumanTimeline.playQueue[0];
            HumanTimeline._play(nextPlay);
        } else {
            Human.events.fire("timeline.paused",{time:Human.timeline.time});
        }
    });

    // ------------------------- PLAY COMMANDS ----------------------------------------------------------------------
    HumanTimeline.parsePlayInstruction = function(params){
        params = params || {};
        var root = params.root || HumanTimeline.activeRoot;
        var direction = "forwards";              // play direction (relative to root);
        root.getTimeFrame();
        var _startCondition;
        var _endCondition;
        var _firstBranch;           // first branch to be played
        var _firstTime;             // time1 (branch local time)
        var _lastBranch;            // last branch to be played
        var _lastTime;              // time2 (branch local time)
        var _t1 = null;                    // first time of time window
        var _t2 = null;                    // last time of time windo
        var _t = null;                     // first time to play
        var align = (params.hasOwnProperty("align"))? params.align : true;
        var startPriorityQueue = ["nextChapter" ,"prevChapter","startChapterId","startTime"];
        var endPriorityQueue = ["nextChapter","prevChapter", "finishChapterId","finishTime", "numChapters"];
        var temp = null;
        var loop = false;
        HumanTimeline._playParams = params;

        _startCondition = filterPriority(startPriorityQueue, params)[0] || "default";
        _endCondition = filterPriority(endPriorityQueue, params)[0] || "default";

        // Get branch, time for start and end conditions
        switch(_startCondition){
            case "nextChapter":
            // Play next chapter from start to finish in forwards order
            _firstTime = 0.0;
            _firstBranch = root.getNeighborChapter(root._nowBranch, "next");
            break;
            case "prevChapter":
            // Play the previous chapter from start to finish in forwards order
            _firstTime = 0.0;
            _firstBranch = root.getNeighborChapter(root._nowBranch, "previous");
            break;
            case "startChapterId":
            // play chapter by id and catch invalid ids
            _firstTime = 0.0;
            _firstBranch = root.getBranch({id: params.startChapterId});
            if (Human.utils.isEmpty(_firstBranch)){
                Human.log.warn("timeline.play", "Invalid chapter id: "+ params.startChapterId);
                return;
            }
            break;
            case "startTime":
            // start at specified time (default to 0)
            temp = root.mapGlobalTime(params.startTime, {tie: "later"});
            _firstBranch = temp.branch;
            _firstTime = temp.time;
            break;
            case "default":
            _firstBranch = root._chapters[0];
            _firstTime = 0.0;
        }

        switch(_endCondition){
            case "nextChapter":
            // play to the end of the target branch
            _lastBranch = _firstBranch;
            _lastTime = _lastBranch.getTimeFrame().lastTime;
            break;
            case "prevChapter":
            // play to the end of the target branch
            _lastBranch = _firstBranch;
            _lastTime = _lastBranch.getTimeFrame().lastTime;
            break;
            case "finishChapterId":
            // play chapter by id and catch invalid ids
            _lastBranch = root.getBranch({id: params.finishChapterId});
            if (Human.utils.isEmpty(_lastBranch)){
                Human.log.warn("timeline.play", "Invalid chapter id: "+ params.finishChapterId);
                return;
            }
            _lastTime = _lastBranch.getTimeFrame().lastTime;
            break;
            case "finishTime":
            // start at specified time (default to end). Edge case if finish time is 0.
            if (params.finishTime === 0){
                _lastBranch = root._chapters[0];
                _lastTime = 0.0;
            } else{
                var which = {tie: "earlier"};
                temp = root.mapGlobalTime(params.finishTime, which);
                _lastBranch = temp.branch;
                _lastTime = temp.time;
            }
            break;
            case "numChapters":
            // play up to numChapters or last chapter
            var startIndex = root.whereIsBranch(_firstBranch, {chapters:true});
            var numRemaining = root._chapters.length - startIndex;
            var numChapters = params.numChapters || 1;
            numChapters = Math.min(numChapters, numRemaining);
            _lastBranch = root._chapters[startIndex + numChapters - 1];
            _lastTime = _lastBranch.getTimeFrame().lastTime;
            break;
            case "default":
            _lastBranch = root._chapters[root._chapters.length - 1];
            _lastTime = "end";
        }

        // Convert to world time and check for forwards/backwards direction
        _t1 = root.mapBranchTime(_firstBranch, _firstTime);
        _t2 = root.mapBranchTime(_lastBranch, _lastTime);
        if (_t1 <= _t2){
            // play t1 -> t2 in forwards direction
            direction = "forwards";
            _t = _t1;
        }
        else {
            // play new t2 -> t1 in backwards direction
            temp = _t1;
            _t1 = _t2;
            _t2 = temp;
            _t = _t2;
            direction = "backwards";
        }

        // Account for alignment to start/end of chapter
        if (align) {
            if (direction === "forwards") {
                _t1 = root.mapBranchTime(_firstBranch, 0);
                _t2 = root.mapBranchTime(_lastBranch, "end");
            } else if (direction === "backwards") {
                _t1 = root.mapBranchTime(_lastBranch, 0);
                _t2 = root.mapBranchTime(_firstBranch, "end");
            }
        }

        /** Looping property
        * Priority goes to params.loop.
        * If not set in params, and only a single whole chapter is meant to be played
        * we will use the chapter's loop property.
        */
        if (params.loop === true){
            loop = true;
        }
        else {
            var singleStarts = ["startChapterId","nextChapter","prevChapter"];
            var singleEnds = ["numChapters", "nextChapter", "finishChapterId"];
            if (singleStarts.indexOf(_startCondition) >= 0){
                if (singleEnds.indexOf(_endCondition) >= 0){
                    if (_firstBranch.id === _lastBranch.id){
                        loop = _firstBranch.animation.loop;
                    }
                }
            }
        }

        return {
            "t": _t,
            "t1":_t1,
            "t2":_t2,
            "loop": loop,
            "direction": direction
        };
    };

    /** PLAY QUEUE
    @param {{}} params Play parameters
    @param {Number} [params.prevChapter] True play previous chapter
    @param {Number} [params.nextChapter] True play next chapter
    @param {Number} [params.startTime] Time in seconds to start playing at
    @param {Number} [params.finishTime] Time in seconds to stop playing at
    @param {String} [params.startChapterId] ID of chapter to start playing at
    @param {String} [params.finishChapterId] ID of chapter to stop playing at
    @param {String} [params.numChapters] Number of chapters to play before stopping
    */
    HumanTimeline.play = function(params){
        params = params || {};

        if (params.queue && HumanTimeline.playing) {
            // Flagged to enqueue, currently playing
            HumanTimeline.playQueue.push(params);
        } else {
            // Kill queue, play immediately
            HumanTimeline.playQueue = [params];
            HumanTimeline._play(params);
        }
    };

    // Sets up play block via play state controls
    /**
    * Parameters:
    * @param {Number}  [params.prevChapter] True play previous chapter
    * @param {Number}  [params.nextChapter] True play next chapter
    * @param {boolean} [params.align] True (default) _time1,_time2 align with border times. Otherwise, use passed times.
    * @param {string}  [params.startChapterId]
    * @param {string}  [params.finishChapterId]
    * @param {Number}  [params.startTime]
    * @param {Number}  [params.finishTime]
    * @param {integer} [params.numChapters] number of chapters in forwards direction.
    * @param {boolean} [params.loop]
    *
    * TODO: Consider having both align left and align right.
    *
    * NOTE: This will support playing time backwards, but will not support playing chapters forwrds in
    * reverse order. One should issue use existing play parameters and the playQueue to do that.
    *
    * Backwards Conditions (playing time backwards) when ...
    *   startTime > finishTime (global)
    *   startChapter.idx > finishChapter.idx (root queue order)
    *   startTime > finishChpater.starttime (global)
    *   finishTime < startChapter.startTime (global)
    */
    HumanTimeline._play = function(params){
        var playparams = HumanTimeline.parsePlayInstruction(params || {});

        // Update Timeline Play State and Parameters
        HumanTimeline._time1 = playparams.t1;
        HumanTimeline._time2 = playparams.t2;
        HumanTimeline.time = playparams.t;
        HumanTimeline.loop = playparams.loop;
        setBorderConditions(playparams.direction);

        // Prepare for tick event
        HumanTimeline.playing = true;
        HumanTimeline._lastWorldTime = (new Date()).getTime();
        Human.events.fire("timeline.played", {
            time: HumanTimeline.time
        });

    };

    // Filter parameters for start and end conditions
    var filterPriority = function(priorityQue, optionsMap){
        var okeys = Object.keys(optionsMap);
        var filterfunc = function(pqItem){
            return okeys.indexOf(pqItem)>=0;
        };
        return priorityQue.filter(filterfunc);
    };

    /** Stop the timeline.
    */
    HumanTimeline.stop = function(){

        // play state variables
        HumanTimeline.playing = false;
        HumanTimeline.playQueue = [];

        // Human events
        Human.events.fire("timeline.stopped",{
            time: HumanTimeline.time
        });
    };

    /** Scrub to specific time on global timeline
    * @param.time            : global time to scrub to
    * @param.borderCondition : instructions for handling playing a border.
    * @param.chapterId       : move to the start of the specified chapterId
    * TODO:@params.playAudio     : False (default) to suppress audio publishing while scrubbing
    *
    * This function will also update play block to encompass desired time for
    * proper "unpausing" or resume play. Resets out-of-bounds scrub to play current
    * chapter.
    */
    HumanTimeline.scrub = function(params){
        var root = HumanTimeline.activeRoot;
        var time = 0;
        var bc = {which: "first", direction:"forwards"};
        var target;

        HumanTimeline.playQueue = [];
        HumanTimeline._scrubParams = params; // copy for bookmarks

        // Infer the desired global time based on parameters
        if (params.hasOwnProperty("time")){
            time = params.time;
        } else if (params.hasOwnProperty("chapterId")) {
            var branch = root.getBranch({id:params.chapterId});
            if (!!branch){
                time = root.mapBranchTime(branch, 0);
                bc = {which:"second", direction:"forwards"};
            } else {
                // in case of failure
                time = HumanTimeline.time;
            }

        }
        else {
            time = HumanTimeline.time;
        }
        if (params.hasOwnProperty("borderCondition")){
            var _bc = params.borderCondition;
            var _which = ["first","both","second"];
            var _direction = ["forwards","backwards"];
            if (_which.indexOf(_bc.which) >= 0){
                bc.which = _bc.which;
            }
            if (_direction.indexOf(_bc.direction) >= 0){
                bc.direction = _bc.direction;
            }
        }

        if (time === 0.0){
            bc = {which: "second", direction: "forwards"};
        } else if (time === root.getTimeFrame.lastTime){
            bc = {which: "first", direction:"forwards"};
        }

        // Update play block if scrub time is out of bounds
        if (time < HumanTimeline._time1 || time > HumanTimeline._time2) {
            target = root.mapGlobalTime(time, bc);
            HumanTimeline._time1 = root.mapBranchTime(target.branch, 0.0);
            HumanTimeline._time2 = root.mapBranchTime(target.branch, "end");
        }

        // Manage Play State
        HumanTimeline.playing = false;

        // Determine Boundary Condition
        HumanTimeline.time = time;
        root.update(time, bc);
        Human.events.fire("timeline.scrubbed", {
            time: HumanTimeline.time
        });
    };

    /** Go to next chronological chapter, respecting properties.prevNextMode
    *
    * prevNextMode is set per chapter.
    * two modes are currently supported:
    * play :
    *     -- play current chapter forwards and step into next chapter if next chapter not looping
    *     -- play next chapter and loop, if next chapter is looping
    * scrub :
    *     -- scrub directly to start of next
    *
    * TODO: Override currently looping chapter so that it finishes.
    * TODO: Properly handle border-condition instead of stepping 0.001 seconds into chapter.
    *
    * HACK: The behavior of 'prevNextMode' is not uniquely determined, depends on the property
    * of the next chapter. This is bad, but is needed for backwards compatibility.
    */
    HumanTimeline.next = function(){
        var root = HumanTimeline.activeRoot;
        var prevNextMode = Human.properties.properties["timeline.prevNextMode"];
        var nowBranch = root._nowBranch;
        var nextBranch = root.getNeighborChapter(nowBranch,"next");

        // Cancel if on last chapter.
        if (root.isLast(nowBranch)){
            Human.log.warn("timeline.next", "can't proceed beyond last chapter");
            return;
        }

        //TODO: Use boundary condition here
        var finishTime = root.mapBranchTime(nowBranch,"end") + 0.001;

        if (prevNextMode === "play"){
            var playParams;
            if (nextBranch.animation.loop){
                playParams = {
                    startTime: root.mapBranchTime(nextBranch,0),
                    align: true,
                    finishTime: root.mapBranchTime(nextBranch, "end"),
                    loop: nextBranch.animation.loop,
                    queue: false
                };
            } else {
                // Play rest of this chapter forwards and just enter into next chapter
                playParams = {
                    startTime : HumanTimeline.time,
                    align: false,
                    finishTime : finishTime,
                    loop: false,
                    queue: true
                };
            }

            HumanTimeline.play(playParams);
        } else {
            // Default is to scrub
            HumanTimeline.scrub({
                time: finishTime
            });
        }

    };

    /** Go to previous chronological chapter, respecting properties.prevNextMode
    *
    * prevNextMode is set per chapter.
    * two modes are currently supported:
    * play :
    *     -- play previous chapter backwards
    * scrub :
    *     -- scrub directly to start of previous chapter
    */
    HumanTimeline.prev = function(){
        var root = HumanTimeline.activeRoot;
        var prevNextMode = Human.properties.properties["timeline.prevNextMode"];
        var nowBranch = root._nowBranch;

        // Cancel if on first chapter.
        if (root.isFirst(nowBranch)){
            Human.log.warn("timeline.next", "can't go to chapter before first chapter");
            return;
        }

        var prevChapter = root.getNeighborChapter(nowBranch, "previous");
        // TODO: Use boundary condition here
        var finishTime = root.mapBranchTime(prevChapter, "start") + 0.001;
        var playParams;
        if (prevNextMode === "play") {
            if (nowBranch.animation.loop) {
                // When current chapter is looping, go to start of previous chapter
                playParams = {
                    startTime: root.mapBranchTime(prevChapter,"start"),
                    align: true,
                    finishTime: root.mapBranchTime(prevChapter,"end"),
                    loop: prevChapter.animation.loop,
                    queue: false
                };
            } else {
                // play previous chapter backwards
                playParams = {
                    startTime: root.mapBranchTime(prevChapter, "end"),
                    align: false,
                    finishTime: root.mapBranchTime(prevChapter, "start"),
                    loop: false,
                    queue: false
                };
            }
            HumanTimeline.play(playParams);
        } else {
            // Default is to scrub
            HumanTimeline.scrub({
                time: finishTime
            });
        }
    };

    // ------------------------- BOOKMARKING -------------------------------------------------------------------------

    /**
    * Gets a bookmark of the timeline's current playing state. This does not bookmark the content
    * currently loaded within the timeline, so when restoring the bookmark, ensure that all the currently-loaded
    * animations and chapters are loaded first.
    * @memberof Human.timeline
    * @return The bookmark, which may be given to {@link Human.timeline.setBookmark} to restore it
    * @private
    */
    HumanTimeline.getBookmark = function(){
        var bookmarkParams = {};

        // bookmark root timeline if it exists:
        if (!!Human.timeline.activeRoot){
            bookmarkParams.rootName = Human.timeline.activeRoot.id;
        }

        // bookmark play parameters
        if (HumanTimeline.playing){
            bookmarkParams.play = HumanTimeline._playParams;
            if (bookmarkParams.play.root) {
              delete bookmarkParams.play.root;
            }
        } else {
            bookmarkParams.scrub = HumanTimeline._scrubParams;
        }
        return bookmarkParams;
    };

    /**
    * Sets timeline's playing state to given bookmark. Assumes that the animations and chapters
    * that were on the timeline when the bookmark was captured are currently loaded.
    * @memberof Human.timeline
    * @param {*} bookmark The bookmark
    * @private
    */
    HumanTimeline.setBookmark = function(bookmark){
        if (!!bookmark.rootName && HumanTimeline.rootTimelines.hasOwnProperty(bookmark.rootName)){
            HumanTimeline.activeRoot = HumanTimeline.rootTimelines[bookmark.rootName];
        } else if (!!bookmark.modules && !!bookmark.modules.activeModules) {
            // Search for appropriate root timeline form bookmark's active modules.
            var candidateTimelines = bookmark.modules.activeModules;
            candidateTimelines = candidateTimelines.filter(function(item){
                return Human.timeline.rootTimelines.hasOwnProperty(item);
            });
            if (candidateTimelines.length > 1){
                candidateTimelines = candidateTimelines.filter(function(item){
                    return !Human.modules.isBaseModule(item);
                });
            }
            var rootName = candidateTimelines[0];
            Human.timeline.activeRoot = Human.timeline.rootTimelines[rootName];
        } else {
            Human.log.warn("Human.timeline.setBookmark: Unable to set appropriate root timeline");
        }
    };

    // ------------------------- BACKWARDS COMPATIBILITY -------------------------------------------------------------

    /** Backwards Compatiiblity: Pause()
    * Same as stop but with different human event.
    */
    HumanTimeline.pause = function(){
        HumanTimeline.playing = false;

        // Human events
        Human.events.fire("timeline.paused", {
            time: HumanTimeline.time
        });
    };

    /** Backwards Compatibility: Unpause()
    * Play rest of current chapter (and only current chapter).
    */
    HumanTimeline.unpause = function(){
        var playParams = {
            startTime: HumanTimeline.time,
            numChapters : 1,
            loop: HumanTimeline.activeRoot._nowBranch.animation.loop
        };

        HumanTimeline.play(playParams);

        // Human Events
        Human.events.fire("timeline.unpaused", {
            time: HumanTimeline.time
        });
    };

    HumanTimeline.playFreeAnimations = function(){
        HumanTimeline.playfree = true;
    };

    HumanTimeline.pauseFreeAnimations = function(){
        HumanTimeline.playfree = false;
    };

    HumanTimeline.getTimeFrame = function(){
        if (Human.utils.isEmpty(HumanTimeline.activeRoot)){
            return 0.0;
        } else {
            return HumanTimeline.activeRoot.getTimeFrame();
        }
    };

    //Get the current chapter's start camera position
    HumanTimeline.getCurrentChapterCamera = function(){
        return Human.timeline.activeRoot._nowBranch.getCamera(0.0);
    };

    // Preserve play parameter naming conventions from older versions
    HumanTimeline._convertPlayParams = function(params){
        var result = params;
        if (params.hasOwnProperty("endTime")){
            result.finishTime = result.endTime;
        }
        if (params.hasOwnProperty("endChapterId")){
            result.finishChapterId = params.endChapterId;
        }

        return result;

    };

    // Query State of Timeline
    HumanTimeline.query = function () {

        if (!HumanTimeline.activeRoot){
            return {};
        }
        var chapters = HumanTimeline.activeRoot._assembleQueryChapters();
        return {
            chapters: chapters,
            time: HumanTimeline.time,
            timeFrame: HumanTimeline.getTimeFrame(),
            playing: HumanTimeline.playing,
            paused: !HumanTimeline.playing
        };
    };

    /** Destroy Chapter Sets: chapterSetId = moduleId
    * Don't destroy base anatomy chapter sets unless specifically requested.
    */
    HumanTimeline.destroyChapterSet = function(chapterSetId){
        HumanTimeline.stop();
        if (HumanTimeline.rootTimelines.hasOwnProperty(chapterSetId)){
            HumanTimeline.rootTimelines[chapterSetId].destroy();
        } else if (!!chapterSetId){
            // Destroy all root timelines except base anatomy
            // TODO: Scene Reset (default properties)
            for (var rtid in HumanTimeline.rootTimelines){
                if (HumanTimeline.rootTimelines.hasOwnProperty(rtid)){
                    if (!Human.modules.isBaseModule(rtid)){
                        HumanTimeline.rootTimelines[rtid].destroy();
                    }
                }
            }
        } else {
            // invalid chapterset id
            Human.log.warn("timeline.destoryChapterSet","Invalid argument: " + chapterSetId);
        }
    };

    Human.events.on("timeline.chapters.updated", function(chapters){
      var idx = 0;
      var id;
      HumanTimeline.chapters = {};
      if (HumanTimeline.activeRoot === null){
        return;
      }
      for (idx=0; idx<chapters.length; idx++){
        id = HumanTimeline.activeRoot._chapters[idx].id;
        HumanTimeline.chapters[id] = chapters[idx];
      }

    });

})();
;(function () {
    "use strict";

    /**
     * A tween animation on the {@link Human.timeline}.
     *
     * @param cfg {*}
     * @param cfg.tweens {{}}
     */
    Human.timeline.TweenAnimation = function (cfg) {

        this._options = cfg.options || { };

        this._tweens = cfg.tweens;

        this.timeline = cfg.timeline;

        /**
         * First key for this tween animation
         */
        this.firstTime = 1000000;

        /**
         * Last key for this tween animation
         */
        this.lastTime = -1000000;

        // Calculate time frame

        var tween;
        for (var i = 0, len = this._tweens.length; i < len; i++) {

            tween = this._tweens[i];

            if (tween.firstTime < this.firstTime) {
                this.firstTime = tween.firstTime;
            }

            if (tween.lastTime > this.lastTime) {
                this.lastTime = tween.lastTime;
            }
        }
    };

    /**
     * Updates this animation for the given time.
     *
     * @param {{}} ctx The animation context
     * @param {Number} time Current timeline time in seconds
     */
    Human.timeline.TweenAnimation.prototype.update = function (ctx, time) {
        for (var i = 0, len = this._tweens.length; i < len; i++) {
            this._tweens[i].update(ctx, time);
        }
    };

    /**
     * Destroys this animation.
     */
    Human.timeline.TweenAnimation.prototype.destroy = function () {
        var tween;
        for (var i = 0, len = this._tweens.length; i < len; i++) {
            tween = this._tweens[i];
            if (tween.destroy) {
                tween.destroy();
            }
        }
    };

})();
;(function () {
    "use strict";

    /**
     * A Human.timeline.Tween interpolates one or more attributes of some target engine element.
     *
     * A Tween is configured with a "control", which is a strategy object which which feeds the Tween's output
     * into the engine element.
     *
     * We also configure a Tween with "targets", each of which is a set of values to assign to attributes of the
     * engine element, at some instant in time.
     *
     * For each attribute that appears among the targets, the Tween will create within itself a Human.utils.LerpAttr,
     * which will animate that attribute through its target values.
     *
     * Whenever the Tween is updated with the current time, it updates each of its LerpAttr, then feeds the
     * aggregate set of outputs of those LerpAttr into the engine element, via the control strategy.
     *
     * For example:
     *
     * <pre>
     *     var lerp = new Human.timeline.Tween({
     *
     *          // Control the Human.view.Camera
     *
     *          control: new Human.timeline.CameraControl(),
     *
     *          // Sequence of target value sets, in this case each containing values for "eye", "look" and "up"
     *          // attributes to set on the Human.view.Camera. This will create three Human.utils.LerpAttr instances
     *          // within this Human.timeline.Tween, each in charge of interpolating one of these three attributes.
     *
     *          targets: [
     *              {
     *                  eye:  { x: 0, y: 0, z: -100 },
     *                  look: { x: 0, y: 0, z: 0 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              },
     *              {
     *                  eye:  { x: 10, y: 22, z: -10 },
     *                  look: { x: 0, y: 0, z: 20 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              }
     *          ],
     *
     *          // A time for each target
     *
     *          keys: [
     *              0,
     *              15
     *          ]
     *      });
     * </pre>
     *
     *
     *
     * @param cfg
     * @param cfg.keys Time for each target
     * @param cfg.targets Set of attribute values for each target
     * @param cfg.control Strategy to set the animated values on target engine element
     */
    Human.timeline.Tween = function (cfg) {

        // Adapter which controls the thing we're tweening
        // eg. a Human.timeline.CameraControl
        this._control = cfg.control;

        // Array of Human.utils.LerpAttr
        this._tweenList = [];

        var tweenMap = {};
        var target;
        var key;
        var attr;
        var targetAttr;
        var tween;
        var tweenAttr;

        // Create tweens

        for (var i = 0, len = cfg.targets.length; i < len; i++) {

            target = cfg.targets[i];
            key = cfg.keys[i];

            // Nested "attr" issue
            if (Human.utils.isObject(target.attr) && hasNestedObjects(target.attr)) {
                target = target.attr;
            }

            //Create a Tween for each attribute ("translate", "rotate" etc.) in target.
            // Each tween will contain a sub-tween for each of its target's elements ("x", "y" etc.)

            attr = target;

            for (var attrName in attr) {
                if (attr.hasOwnProperty(attrName)) {

                    targetAttr = attr[attrName];
                    tween = tweenMap[attrName];

                    if (!tween) { // Lazy-create

                        tweenAttr = this._control.attr[attrName];
                      //  if (!tweenAttr) {
                      //      Human.log.error("Human.timeline.Tween", "Attribute expected on control strategy: " + attrName);
                      //      continue;
                      //  }
                        tween = new Human.timeline.TweenAttr(tweenAttr, cfg.options);
                        tweenMap[attrName] = tween;
                        this._tweenList.push(tween);
                    }

                    tween.addTarget(key, targetAttr);
                }
            }
        }

        /**
         * First key for this tween
         */
        this.firstTime = cfg.keys[0];

        /**
         * Last key for this tween
         */
        this.lastTime = cfg.keys[cfg.keys.length - 1];
    };

    Human.timeline.Tween.prototype._run = function (ctx, time) {

        var countUpdated = 0;
        var tweenList = this._tweenList;

        // Update each tween
        for (var j = 0, len = tweenList.length; j < len; j++) {
            if (tweenList[j].update(ctx, time)) {
                countUpdated++;
            }
        }

        return countUpdated;
    };

    Human.timeline.Tween.prototype.query = function (ctx, time) {
        this._run(ctx, time);

        return this._control.attr;
    };

    /**
     * Updates this tween for the given time.
     *
     * @param {{}} ctx Animation context
     * @param {Number} time Time in seconds
     */
    Human.timeline.Tween.prototype.update = function (ctx, time) {
        // Update control if any tween was updated
        if (this._run(ctx, time) > 0) {
            this._control.update(ctx);
        }
    };

    function hasNestedObjects(obj) {
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop) && !Human.utils.isObject(obj[prop])) {
                return false;
            }
        }

        return true;
    }

})();
;/**
 * Tweens a set of attributes
 *
 * <p>Usage:</p>
 *
 * <pre>
 *     var lerp = new Human.timeline.TweenAttr({ x: 0, y: 0, z: 0 });
 *
 *     lerp.addTarget(1, { x: 0, y: 10, z: 1 });
 *     lerp.addTarget(2, { x: 5, y: 0, z: 0 });
 *     lerp.addTarget(4, { x: 10, y: 0, z: 1 });
 *
 *     var animationContext = {};
 *
 *     lerp.update(animationContext, 3);
 *
 * </pre>
 *
 * @param {{String:Object}} attr The attribute values to interpolate.
 * @param {{String:Object}} options Interpolation options
 * @param {Boolean} [options.loop] Flag indicating whether interpolation loops within the targets
 * @param {Number} [options.timeOffset] Time offset to add to time at each target given to {@link #addTarget}
 */

(function() {
    "use strict";

    Human.timeline.TweenAttr = function (attr, options) {

        /**
         * The attributes that are interpolated. This is the output of this interpolator.
         */
        this.attr = attr;

        this.attrNames = null;

        options = options || {};

        /**
         * A time in seconds for each target.
         */
        this.keys = [];

        /**
         * The targets - a list of target values for each attribute.
         *
         * <p>For example, if the attributes were {x,y,z}, then it would be this sort of thing:</p>
         *
         * <pre>
         * {
         *     "x": [32, 4, -23],
         *     "y": [-2, 40, 133],
         *     "z": [34, 0, 21]
         * }
         * </pre>
         */
        this.attrTargetLists = {};

        this._tweens = [];

        // Caches indexes of the pair of targets that the enclose the last time value given to #update
        this._key1 = 0;
        this._key2 = 1;

        // Caches the time values at the first and last keys, plus the range between them
        this._firstKey = null;
        this._lastKey = null;
        this._keyDiff = null;

        // True when this interpolator loops
        this._loop = !!options.loop;

        // Optional time offset to add to times given to #addTarget
        this._timeOffset = options.timeOffset || 0;

        // True when we need to re-pad the target lists
        this._paddingDirty = true;
    };

    /**
     * Adds a target to this Tween.
     *
     * <p>Example:</p>
     *
     * <pre>
     *     // Add a target at 4 seconds
     *     addTarget(4, { "x": 0, "y": 0, "z": -10 });
     * </pre>
     *
     * @param {Number} time Time in seconds for the target
     * @param {{String: Object}} attr Attribute values for the target
     */
    Human.timeline.TweenAttr.prototype.addTarget = function (time, attr) {

        time += this._timeOffset;

        // Add key time

        this.keys.push(time);

        var i = this.keys.length - 1;

        var targetList;
        var padded;
        var val;
        var j;
        var prev;

        for (var name in attr) {

            if (attr.hasOwnProperty(name)) {

                targetList = this.attrTargetLists[name];

                if (!targetList) {

                    if (this.keys.length > 1) {
                        throw "First target in tween must contain a value for each animated attribute on target";
                    }

                    targetList = this.attrTargetLists[name] = [];
                }

                val = attr[name];

                targetList[i] = val;
                if (typeof val !== "number") {
                    getCurve(val, time, targetList[i - 1], this.keys[i - 1]);
                }

                if (i > 0) {

                    padded = false;
                    j = i - 1;

                    while (!padded && j >= 0) {

                        prev = targetList[j];

                        // ? never hit ?
                        if (prev === undefined && prev === null) {
                            targetList[j] = val;
                            j--;
                        } else {
                            padded = true;
                        }
                    }
                }
            }
        }

        // Find key range

        if (this._firstKey === null || this._firstKey > time) {
            this._firstKey = time;
        }

        if (this._lastKey === null || this._lastKey < time) {
            this._lastKey = time;
        }

        this._keyDiff = this._lastKey - this._firstKey;

        this._paddingDirty = false;
    };


    Human.timeline.TweenAttr.prototype._padTargets = function () {

        var name;
        var attrTargetLists = this.attrTargetLists;
        var targetList;
        var numKeys = this.keys.length;
        var val;

        for (name in attrTargetLists) {

            if (attrTargetLists.hasOwnProperty(name)) {

                targetList = attrTargetLists[name];

                if (targetList.length === numKeys) {
                    continue;
                }

                val = targetList[targetList.length - 1];

                while (targetList.length < numKeys) {
                    targetList.push(val);
                }
            }
        }

        this._paddingDirty = false;
    };


    /**
     * Drives the interpolation factor on this Tween
     *
     * <p>Example:</p>
     *
     * <pre>
     * update(3.2);
     * </pre>
     *
     * @param {*} ctx Animation context
     * @param {Number} time Current timeline time in seconds
     * @return {Boolean} True if any attribute in {@link #attr} was modified
     */
    Human.timeline.TweenAttr.prototype.update = function (ctx, time) {

        if (this._paddingDirty) {
            this._padTargets();
        }

        var keys = this.keys;

        var names = this.attrNames ? this.attrNames : this.attrNames = Object.keys(this.attrTargetLists);

        if (this._loop) {

            time = this._firstKey + (time % this._keyDiff);

        } else {

            if (time < keys[0]) {
                this._key1 = 0;
                this._key2 = 1;
                this._clampToTarget(names, 0);
                return true;
            }

            if (time > keys[keys.length - 1]) {
                this._key1 = keys.length - 2;
                this._key2 = this._key1 + 1;
                this._clampToTarget(names, this.keys.length - 1);
                return true;
            }
        }

        while (keys[this._key1] > time) {
            this._key1--;
            this._key2--;
        }

        while (keys[this._key2] < time) {
            this._key1++;
            this._key2++;
        }

        var attrTargetLists = this.attrTargetLists;
        var key1 = this._key1;
        var key2 = this._key2;
        var targetList;
        var target1;
        var val;
        var attr = this.attr;
        var updated = false;
        var i, len, name;


        for (i = 0, len = names.length; i < len; i++) {

            name = names[i];
            targetList = attrTargetLists[name];
            target1 = targetList[key1];
            if (typeof target1 !== "number") {
                target1 = target1.value;
            }
            if (typeof targetList[key2] === "number") {
                val = lerp(time, keys[key1], keys[key2], target1, targetList[key2]);
            } else {
                val = bezier(time, targetList[key2]);
            }

            attr[name] = val;
            updated = true;
        }

        return updated;
    };

    /**
     * Sets the output (#attr) to the values of the target at the given index
     */
    Human.timeline.TweenAttr.prototype._clampToTarget = function (names, time) {
        var attr = this.attr;
        var attrTargetLists = this.attrTargetLists;
        var attrVal;
        var i, len, name;

        for (i = 0, len = names.length; i < len; i++) {
            name = names[i];
            attrVal = attrTargetLists[name][time];
            if (typeof attrVal !== "number") {
                attrVal = attrVal.value;
            }
            attr[name] = attrVal;
        }
    };

    function getCurve(target, time, prevTarget, prevTime) {
        if (typeof prevTarget !== "number") {
            prevTarget = prevTarget.value;
        }
        
        // generate bezier class
        var cp = target.controlPoints;
        var steps = Math.floor((time - prevTime) * 50);
        
        // x - t, y - attr value
        target.bezier = new Human.math.bezier(
            prevTime, prevTarget, 
            cp.x[0], cp.y[0], 
            cp.x[1], cp.y[1],
            time, target.value
            );
        target.lookUp = target.bezier.getLUT(steps);
    }

    function lerp(time, key1, key2, target1, target2) {
        var delta = (time - key1) / (key2 - key1);

        var w = target2 - target1;
        var offs = delta * w;

        return target1 + offs;
    }

    // get attr val from bezier curve lookUp
    function bezier(time, target) {
        var lookUp = target.lookUp;
        var low = 0;
        var high = lookUp.length - 1;
        var mid, sample1, sample2;

        if (time <= lookUp[low].x) {
            return lookUp[low].y;
        }

        if (time >= lookUp[high].x) {
            return lookUp[high].y;
        }

        while (low <= high) {
            mid = Math.floor((low + high) / 2);
            sample1 = lookUp[mid];
            sample2 = lookUp[mid + 1];

            if (sample1.x <= time && sample2.x >= time) {
                return lerp(time, sample1.x, sample2.x, sample1.y, sample2.y);
            } else if (sample1.x > time) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
    }

})();
;(function () {
    "use strict";

    var BEFORE = 1;     // Alpha before first key
    var START = 2;      // At first key
    var AFTER = 3;     // Alpha after last key
    var RUNNING = 4;    // Found keys before and after alpha

    /**
     * A Human.timeline.Switch animates one or more attributes of some target engine element along sequences
     * of discrete values.
     *
     * A Switch is configured with a "control", which is a strategy object which which feeds the Switch's output
     * into the engine element.
     *
     * We also configure a Switch with "targets", each of which is a set of values to assign to attributes of the
     * engine element, at some instant in time.
     *
     * Example:
     *
     * <pre>
     *     var tween = new Human.timeline.Switch({
     *
     *          // Control a Human.scene.object
     *
     *          control: new Human.timeline.ObjectControl(),
     *
     *          // Sequence of target value sets, in this case each containing values for "eye", "look" and "up"
     *          // attributes to set on the Human.view.Camera. This will create three Human.utils.LerpAttr instances
     *          // within this Human.timeline.Switch, each in charge of interpolating one of these three attributes.
     *
     *          targets: [
     *              {
     *                  eye:  { x: 0, y: 0, z: -100 },
     *                  look: { x: 0, y: 0, z: 0 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              },
     *              {
     *                  eye:  { x: 10, y: 22, z: -10 },
     *                  look: { x: 0, y: 0, z: 20 },
     *                  eye:  { x: 0, y: 1, z: 0 }
     *              }
     *          ],
     *
     *          // A time for each target
     *
     *          keys: [
     *              0,
     *              15
     *          ]
     *      });
     * </pre>
     *
     *
     *
     * @param cfg
     * @param cfg.keys Time for each target
     * @param cfg.targets Set of attribute values for each target
     * @param cfg.control Strategy to set the animated values on target engine element
     */
    Human.timeline.Switch = function (cfg) {

        this._keys = cfg.keys;
        this._targets = cfg.targets;
        this._control = cfg.control;
        this._options = cfg.options || {};
        this._key = 0;
        this._lastKey = null;

        /**
         * First key for this tween
         */
        this.firstTime = cfg.keys[0];

        /**
         * Last key for this tween
         */
        this.lastTime = cfg.keys[cfg.keys.length - 1];
    };

    Human.timeline.Switch.prototype.query = function (ctx, time) {
        this._findTarget(time);
        return this._targets[this._key];
    };

    /**
     * Updates this tween for the given time
     *
     * @param {{}} ctx Animation context
     * @param {Number} time Time in seconds
     */
    Human.timeline.Switch.prototype.update = function (ctx, time) {

        var state = this._findTarget(time);

        switch (state) {
            case BEFORE:

                //this._clampToFrame(0);
                return;

            case START:
                break;

            case AFTER:
                break;
        }

        // if (this._lastKey !== this._key) {
        //     this._control.attr = this._targets[this._key];
        //     this._control.update(ctx);
        //     this._lastKey = this._key;
        // }

        // TODO: Check for necessity to change based on attribute comparison NOT on which key fired last
        // last fired key could have been in another chapter, and visibility is reset each chapter. 
        this._control.attr = this._targets[this._key];
        this._control.update(ctx);
        this._lastKey = this._key;
    };

    /**
     * Finds the index of the key/target for the given time value
     * @param time
     * @returns {number}
     * @private
     */
    Human.timeline.Switch.prototype._findTarget = function (time) {

        if (time < this._keys[0]) {
            this._key = 0;
            return BEFORE;
        }

        if (time === this._keys[0]) {
            this._key = 0;
            return START;
        }

        if (time > this._keys[this._keys.length - 1]) {
            this._key = this._keys.length - 1;
            return AFTER;
        }

        while (this._keys[this._key] > time) {
            this._key--;
        }

        while (this._keys[this._key + 1] !== undefined && this._keys[this._key + 1] !== null && this._keys[this._key + 1] < time) {
            this._key++;
        }

        return RUNNING;
    };

})();
;(function () {
    "use strict";

    /**
     * Controls the state of {@link Human.view.camera}.
     */
    Human.timeline.CameraControl = function () {

        /**
         * Camera attribute values.
         * These are set by the tween, which subsequently applies them to the camera with a call to #update()
         */
        this.attr = {
            up: { x: 0, y: 1, z: 0 },
            eye: { x: 0, y: 0, z: 0 },
            look: { x: 0, y: 0, z: 0 }
        };
    };

    /**
     * Sets this control's attribute values on the target camera
     * @returns {Boolean} True if the attribute was updated
     */
    Human.timeline.CameraControl.prototype.update = function (ctx) {

        // Don't update if camera animation is disabled

        if (ctx.cameraEnabled !== false) {
            Human.view.camera.setLookAt(this.attr);
            return true;
        }
    };

})();

;(function () {
    "use strict";

    /**
     * Controls the attributes of a material
     */
    Human.timeline.MaterialControl = function (params) {

        this._materialId = params.modelId + "/" + params.materialId;
        this.attr = {};

        // Backwards Compatibility: Nested Attribute
        if (params.attributes.hasOwnProperty("attr")){
            params.attributes = params.attributes.attr;
        }

        var attr;
        /**
         * Material attribute values.
         * These are set by the tween, which subsequently applies them to the material with a call to #update()
         * A Material should be able to have more than one control for different attributes. The desired attribute to control will be registered per instance of the material control.
         *
         * Backwards Compatibility:
         * The engine used to expect all the material properties (color, specular) to be tweened together. It makes more sense to support independent tweening attributes. However, for existing content, we must still support content that includes simultaneous attribute tweens on color and specular.
         */
        var defaultBaseColor = {
             r: 0,
             g: 0,
             b: 0,
             a: 1
         };

        var defaultSpecularColor = {
             r: 1.0,
             g: 1.0,
             b: 1.0
         };

        var defaultEmitColor = {
             r: 0.0,
             g: 0.0,
             b: 0.0
         };

        var defaultAlphaColor = {float:1};


        for (attr in params.attributes){
            if (params.attributes.hasOwnProperty(attr)){
                if (attr === "baseColor"){
                    this.attr.baseColor = defaultBaseColor;
                } else if (attr === "specularColor") {
                    this.attr.specularColor = defaultSpecularColor;
                } else if (attr === "emitColor") {
                    this.attr.emitColor = defaultEmitColor;
                } else if (attr === "alphaColor") {
                    this.attr.alphaColor = defaultAlphaColor;
                }
            }
        }
    };

    /**
     * Sets this control's attribute values on the target material
     * @returns {Boolean} True if the attribute was updated
     */
    Human.timeline.MaterialControl.prototype.update = function () {

        // Lazy-locate the target material
        // This is here so that we're not dependent on the material being loaded in advance

        var material = Human.assets.materials.materials[this._materialId];

        if (!material) {

            // Material not found

            if (!this._targetMissing) {

                // Warn once only

                Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find material: " + this._materialId);
                this._targetMissing = true;
            }

            return;
        }

        if (material.material) {

            var materialNode = material.material;
            var attr = this.attr;

            if (attr.baseColor) {
                materialNode.setBaseColor(attr.baseColor);
            }

            if (attr.specularColor) {
                materialNode.setSpecularColor(attr.specularColor);
            }

            if (attr.emitColor) {
                materialNode.setEmitColor(attr.emitColor);
            }

            if (attr.alphaColor) {
                // not an rgb, but an alpha value
                materialNode.setAlpha(attr.alphaColor.float);
            }

            return true;
        }
    };

})();
;(function () {
    "use strict";

    /**
     * Controls the state of a scene object
     */
    Human.timeline.ObjectControl = function (params) {

        var objectId = params.objectId;

        if (objectId.indexOf(".") < 0 && objectId.indexOf("-") < 0) {

            // Relative ID of object within this model
            objectId = params.modelId + "-" + params.objectId;

        } // Otherwise absolute ID of object in another model

        this._objectId = objectId;

        /**
         * Object attribute values.
         * These are set by the tween, which subsequently applies them to the object with a call to #update()
         */
        this.attr = {

            // A "virtual attribute" on the target Object

            attr: {
            }
        };
    };

    /**
     * Sets this control's attribute values on the target object
     */
    Human.timeline.ObjectControl.prototype.update = function () {

        // Lazy-locate the target object
        // This is here so that we're not dependent on the object existing in advance

        var object = Human.scene.objects[this._objectId];

        if (!object) {

            // Object not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.warn("Human.timeline.TweenAnimation", "'lerp:objectAttr' tween can't find object: " + this._objectId);
                this._targetMissing = true;
            }
            return;
        }

        // Don't update the object if there is a currently-active
        // chapter that makes it invisible
        var oinchapter = Human.timeline.activeRoot._nowBranch.synchronization[this._objectId];
        if (!oinchapter || oinchapter.shown !== false){
            updateObject(object, this.attr.attr);
        }

        return;
    };

    // Sets object visibilities via Human.scene.setEnabled, so we can track
    // the object visibility states as required for isolate etc.
    var setObjectVisibility = (function() {

        var update = {}; // Batching the updates so that we don't get a stream of "scene.objectsShown" events
        var dirty = false;

        Human.events.on("tick", function() {
            if (dirty) {
                Human.scene.setEnabledObjects({
                    objectIds: update,
                    replace: false
                });
                update = {};
                dirty = false;
            }
        });

        function needsUpdate(object, enabled) {
            var enabledObjects = Human.scene.enabledObjects;

            var objectEnabled = !!enabledObjects[object.objectId];
            if (object.isLeaf() && objectEnabled !== enabled) {
                return true;
            }
            if (enabled) {
                if (object.numSubObjects !== object.numEnabledSubObjects) {
                    return true;
                }
                while (object) {
                    if (objectEnabled !== enabled) {
                        return true;
                    }
                    object = object.parent;
                }
            } else  {
                if (object.numEnabledSubObjects > 0) {
                    return true;
                }
            }
            return false;
        }

        return function (object, enabled) {
            if (!needsUpdate(object, enabled)) {
                return;
            }
            update[object.objectId] = enabled;
            dirty = true;
        };
    })();

    /**
     * Recursively sets attributes on objects in the given subtree
     */
    function updateObject(object, attr) {

        if (attr.opacity !== undefined && attr.opacity !== null) {
            object.setOpacity(attr.opacity);
        }

        if (attr.pickable !== undefined && attr.pickable !== null) {
            object.setPickable(attr.pickable);
        }

        if (attr.shown !== undefined && attr.shown !== null) {
            setObjectVisibility(object, attr.shown);
        }

        if (object.objects.length > 0) {
            var objects = object.objects;
            for (var i = 0, len = objects.length; i < len; i++) {
                updateObject(objects[i], attr);
            }
        }
    }

})();
;(function () {
    "use strict";

    /**
     * Controls a scene object's transform
     */
    Human.timeline.ObjectTransformControl = function (params) {

        var objectId = params.objectId;
        var initial = params.initial;

        if (objectId.indexOf(".") < 0 && objectId.indexOf("-") < 0) {

            // Relative ID of object within this model
            objectId = params.modelId + "-" + params.objectId;

        } // Otherwise absolute ID of object in another model

        this._objectId = objectId;

        /**
         * Object's transform attribute values.
         * These are set by the tween, which subsequently applies them to the object's transform with a call to #update()
         */

        var attr = this.attr = {};

        ["translate", "rotate", "scale", "pivot"].forEach(function(xform) {
            var val = xform === "scale" ? 1 : 0;

            if (initial[xform] !== undefined) {
                attr[xform] = {};

                if (initial[xform].x !== undefined) {
                    attr[xform].x = val;
                }

                if (initial[xform].y !== undefined) {
                    attr[xform].y = val;
                }

                if (initial[xform].z !== undefined) {
                    attr[xform].z = val;
                }
            }
        });
    };

    /**
     * Sets this control's attribute values on the target object's transform
     */
    Human.timeline.ObjectTransformControl.prototype.update = function () {

        // Lazy-locate the target object
        // This is here so that we're not dependent on the object existing in advance

        var object = Human.scene.objects[this._objectId];

        if (!object) {

            // Object not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.warn("Human.timeline.ObjectTransformControl", "Can't find object: " + this._objectId);
                this._targetMissing = true;
            }

            return;
        }

        // Don't update the object if there is a currently-active
        // chapter that makes it invisible
        //TODO: Do we need to prevent transform update if object is not shown?
        // var shown = Human.timeline.showObjects[this._objectId];
        var shown = true;
        if (shown !== undefined && shown !== null && shown !== true) {
            return;
        }

        object.setTransform(this.attr);
    };

})();
;(function () {
    "use strict";

    /**
     * Manipulates the texture of a material in a Material Module
     */
    Human.timeline.TextureControl = function (params) {

        this._material = params.modelId + "/" + params.materialId;

        if (params.targetLayer === undefined || params.targetLayer === null) {
            Human.log.error("Human.timeline.TweenAnimation", "'texture' tween attribute expected: 'targetLayer'");
            return;
        }

        this._targetLayer = params.targetLayer;

        /**
         * Material texture layer attribute values.
         * These are set by the tween, which subsequently applies them to the texture layer with a call to #update()
         */
        this.attr = {
            rotate: {z: 0},
            translate: {x: 0, y: 0},
            scale: {x: 1, y: 1},
            blend: {factor: 1.0}
        };
    };

    /**
     * Sets this control's attribute values on the target material's texture
     */
    Human.timeline.TextureControl.prototype.update = function () {

        // Lazy-locate the target material
        // This is here so that we're not dependent on the material being loaded in advance

        var material = Human.assets.materials.materials[this._material];

        if (!material) {

            // Material not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find material: " + this._material);
                this._targetMissing = true;
            }

            return;
        }

        // Update the material texture layer

        var textures = material.textures;

        if (this._targetLayer >= 0 && this._targetLayer < textures.length) {

            var texture = textures[this._targetLayer];
            var attr = this.attr;

            if (attr.scale) {
                texture.setScale(attr.scale);
            }

            if (attr.translate) {
                texture.setTranslate(attr.translate);
            }

            if (attr.rotate !== undefined && attr.rotate !== null) {
                texture.setRotate(attr.rotate.z);
            }

            if (attr.blend !== undefined && attr.blend !== null) {
                texture.setBlendFactor(attr.blend.factor);
            }
        }
    };


})();
;(function () {
    "use strict";

    /**
     * Controls the attributes of a material
     */
    Human.timeline.FresnelControl = function (params) {

        this._materialId = params.modelId + "/" + params.materialId;
        this._fresnelType = params.fresnelType;

        // Backwards Compatibility: Convert baseFresnel to colorFresnel
        if (this._fresnelType === "baseFresnel"){
            this._fresnelType = "colorFresnel";
        }

        // Fresnel attribute values.
        // These are set by the tween, which subsequently applies them to the fresnel with a call to #update()
        //
        this.attr = {
            bias: {
                edge: 0.0,
                center: 0.7,
                power: 1.0
            },
            edge: {
                r: 0.8,
                g: 0.7,
                b: 0.7
            },
            center: {
                r: 0.05,
                g: 0.05,
                b: 0.09
            }
        };
    };

    /**
     * Sets this control's attribute values on the target material
     * @returns {Boolean} True if the attribute was updated
     */
    Human.timeline.FresnelControl.prototype.update = function () {

        if (!this._fresnel) {

            // Lazy-locate the target material
            // This is here so that we're not dependent on the material being loaded in advance

            var material = Human.assets.materials.materials[this._materialId];

            if (!material) {

                // Material not found

                if (!this._materialMissing) {

                    // Warn once only

                    Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find material: " + this._materialId);
                    this._materialMissing = true;
                }

                return;
            }


            // Get color channel, eg "emitFresnel" -> "emit"
            var type = this._fresnelType.length <= 7 ? this._fresnelType : this._fresnelType.substring(0, this._fresnelType.length - 7);

            this._fresnel = material.fresnels[type];

            if (!this._fresnel) {

                // Fresnel not found

                if (!this._fresnelMissing) {

                    // Warn once only

                    Human.log.error("Human.timeline.TweenAnimation", "'material' tween can't find fresnel type: " + this._fresnelType);
                    this._fresnelMissing = true;
                }

                return;
            }
        }

        // TODO: Avoid needlessly resetting each attribute?

        var bias = this.attr.bias;

        this._fresnel.setEdgeBias(bias.edge);
        this._fresnel.setCenterBias(bias.center);
        this._fresnel.setPower(bias.power);
        this._fresnel.setEdgeColor(this.attr.edge);
        this._fresnel.setCenterColor(this.attr.center);

        return true;
    };

})();
;(function () {
    "use strict";

    /**
     * Controls the state of a scene object
     */
    Human.timeline.ParticleSystemControl = function (params) {

        this.particleSystemId = params.particleSystemId;

        /**
         * Object attribute values.
         * These are set by the tween, which subsequently applies them to the object with a call to #update()
         */
        this.attr = {

            attr: {
            }
        };

        this._targetMissing = false;
    };

    /**
     * Sets this control's attribute values on the target object
     */
    Human.timeline.ParticleSystemControl.prototype.update = function () {

        // Lazy-locate the target object
        // This is here so that we're not dependent on the object existing in advance

        var ps = Human.particles.systems[this.particleSystemId];

        if (!ps) {

            // Object not found
            // Warn once only

            if (!this._targetMissing) {
                Human.log.warn("Human.timeline.SwitchAnimation", "'switch:particleSystem' can't find object: " + this.particleSystemId);
                this._targetMissing = true;
            }
            return;
        }

        // Don't update the object if there is a currently-active
        // chapter that makes it invisible
        if (Human.timeline.activeRoot._nowBranch.particleSystems.indexOf(this.particleSystemId) > -1) {
            var attr = this.attr.attr;

            if (attr.enable === true) {
                ps.enable();
            }

            if (attr.enable === false) {
                ps.disable();
            }

            if (attr.emissionAverage !== undefined) {
                ps.emissionAverage = attr.emissionAverage;
            }

            if (attr.emissionVariance !== undefined) {
                ps.emissionVariance = attr.emissionVariance;
            }

        }
    };

})();
;/**
 * @namespace Auto-plays the timeline after a period of user inactivity
 */
(function () {
    "use strict";

    var timeout = null;

    var enabled = false;
    var autoPlaying = false;

    Human.properties.subscribe({
        propId: "timeline.autoPlay.enabled",
        value: enabled,
        callback: function (value) {
            enabled = !!value;

            if(enabled) {
              startCountdown();
            } else {
              autoPlaying = false;
            }
        }
    });

    var timeoutSecs = 10;

    var type = "play";

    var types = {

        play: function () {
            Human.timeline.play({
                startTime: Human.timeline.time
            });
        },

        'chapter-rotate': function () {
            var _wait = 5000;

            var _rotate = function () {
                if(!autoPlaying) {
                    return;
                }

                var startX = Human.view.camera.eye.x;
                var i = 0;
                var _interval = 20;

                var rotateInt = setInterval(function () {
                    if(!autoPlaying) {
                        clearInterval(rotateInt);
                    }

                    Human.view.camera.rotateY(0.5);


                    var diff = Math.abs(startX - Human.view.camera.eye.x);

                    if((diff <= 0.005 && i > _interval * 5) || i > _interval * 40) {
                        clearInterval(rotateInt);
                        setTimeout(_play, _wait);
                    }

                    i++;
                }, _interval);
            };

            var _play = function () {
                if(!autoPlaying) {
                    return;
                }

                //go to beginning if at end
                if(Human.timeline.time === Human.timeline.getTimeFrame().lastTime) {
                    Human.timeline.scrub({ time: 0 });
                    setTimeout(_rotate, _wait);
                } else {
                    Human.timeline.next();
                }

                Human.events.once('timeline.stopped', function () {
                    setTimeout(_rotate, _wait);
                });
            };

            _play();

        }

    };

    Human.properties.subscribe({
        propId: "timeline.autoPlay.type",
        value: type,
        callback: function (value) {
            type = value;
        }
    });

    // Start countdown when engine starts

    Human.events.on("started",
        function () {
            startCountdown();
        });

    // Start countdown when timeline stops

    Human.events.on("timeline.stopped",
        function () {
            startCountdown();
        });

    // (Re)start countdown when user interacts with the UI

    var listeners = {};

    listen("mousedown");
    listen("keydown");
    listen('mousewheel');

    function listen(type) {
        $(document).bind(type,
            listeners[type] = function () {
                autoPlaying = false;
                startCountdown();
            });
    }

    function startCountdown() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }

        if (!enabled) {
            return;
        }

        timeout = setTimeout(function () {
            if (enabled && !Human.timeline.playing && !autoPlaying) {
                autoPlaying = true;

                var method = types[type] || types.play;
                method();
            }
        }, timeoutSecs * 1000);
    }

})();
;/** Leaf timeline
 * Direct controller of animation assets (morphs and tweens)
 * Animations can come from model (state folder) or tween/morph creator functions.
 * Free Animations will be registered here, but played/updated by root.
 * Options to ignore animated camera.
 */
(function(){
    "use strict";

    var Leaf = Human.timeline.LeafTimeline = function (name, params) {
        
        var self = this;
        params = params || {};
        self.level = "leaf";			     // Identifies the kind of timeline
        self.id = name;                // use required 'name' arguemnt
        self.animations = {};          // all animations (free and timeline)
        self.timelineAnimations = {};  // controlled by branch timelines
        self.freeAnimations = {};		   // always update on tick.
        self.cameraTween = null;       // Null or first camera tween in animations.

        //Camera Controls
        self.animationCtx = {
            cameraEnabled: true			//Default is to allow animation camera tweens to play if present
        };

        //Register With Timeline Controller
        Human.timeline.leafTimelines[self.id] = self;
    };

    /**
     * Attaches animation to leaf.
     * Animation object is a collection of tween/morph objects
     */
    Leaf.prototype.addAnimation = function (animationId, animation) {
        var self = this;
        // Validate
        if (!animation) {
            Human.log.error("LeafTimeline.addAnimation", "null or undefined animation object");
            return;
        }

        if (!animation.update) {
            //All animations must come with update() function
            Human.log.error("LeafTimeline.addAnimation", "Param expected: update");
            return;
        }

        // Replace and attach
        if (self.animations[animationId]) {
            self.removeAnimation(animationId);
        }
        self.animations[animationId] = animation;


        // Attach to free or timeline
        if (animation.timeline === false) {
            // Free
            self.freeAnimations[animationId] = animation;

        } else {
            // Controlled
            self.timelineAnimations[animationId] = animation;
        }

        //Look for and register first camera tween object
        if (!self.cameraTween) {

            var found = false;
            var i;
            var len;
            var tweens = animation._tweens || [];
            var tween;
            var CameraControl = Human.timeline.CameraControl;

            for (i = 0, len = tweens.length; i < len && !found; i++) {
                tween = tweens[i];
                if (tween._control) {
                    if (tween._control instanceof CameraControl) {
                        found = true;
                        self.cameraTween = tween;
                    }
                }
            }
        }

        Human.events.fire("Timeline.Loaded");
    };

    /**
     * Destroy animation (all tweens/morphs associated)
     */
    Leaf.prototype.removeAnimation = function (animationId) {
        var self = this;
        var animation = self.animations[animationId];

        // Validate
        if (!animation) {
            Human.log.warn("Human.timeline.LeafTimeline.removeAnimation", "Animation not found: " + animationId);
            return;
        }


        // Remove from free and controlled collections
        if (animationId in self.freeAnimations) {
            delete self.freeAnimations[animationId];
        } else {
            delete self.timelineAnimations[animationId];
        }
        delete self.animations[animationId];

        // Destroy animaton (tween/morph prototype function)
        if (animation.destroy) {
            animation.destroy();
        }
    };

    /**
     * Returns maximum time frame in the collection of animations.
     */
    Leaf.prototype.getTimeFrame = function () {
        var self = this;
        var anyAnimations = false;
        var max = 0;
        var timeFrame;
        var lastTime;
        var timelineAnimations = self.timelineAnimations; // OPTIMIZATION: avoid dereference each iteration

        // Count all controlled Animations
        for (var animationId in  timelineAnimations) {
            if (timelineAnimations.hasOwnProperty(animationId)) {

                anyAnimations = true;
                lastTime = timelineAnimations[animationId].lastTime;
                max = Math.max(max, lastTime);
            }
        }

        // Result
        timeFrame = {
            firstTime: 0.0,
            lastTime: max
        };

        return timeFrame;
    };

    /**
     * Calls the update() function on all constituent timelines for the passed time.
     * @param boolean cameraEnabled  Whether to play camera tween or not
     */
    Leaf.prototype.update = function (cameraEnabled, time, params) {
        var self = this;
        params = params || {};

        // Defaults to play camera tween unless told not to.
        var ctx = {
            cameraEnabled: cameraEnabled === false ? cameraEnabled : self.animationCtx.cameraEnabled
        };

        var timelineAnimations = self.timelineAnimations; // OPTIMIZATION: avoid dereference each iteration
        var animation;

        // Update all timeline Animations to given time
        for (var animationId in timelineAnimations) {
            if (timelineAnimations.hasOwnProperty(animationId)) {

                //TODO: patch to make up for dynamic camera tweens having different update interface
                animation = timelineAnimations[animationId];

                if (animation.type === "lerp:camera") {
                    //tween returned by flyTo() function -- dynamic tween
                    animation.update(time);
                } else {
                    animation.update(ctx, time);
                }
            }
        }
    };

    /** Remove references to Animations
     */
    Leaf.prototype.destroy = function () {
        var self = this;
        self.animations = {};
        self.freeAnimations = {};
        self.timelineAnimations = {};
        self.cameraTween = null;
        delete Human.timeline.leafTimelines[self.id];
    };

    /* Unload Animation type from
     */
    Leaf.prototype.unload = function(assetType) {
        var self = this;
        var targetType = (assetType==="tweens")? Human.timeline.TweenAnimation: Human.assets.morphs.Animation;
        var animationId;
        for (animationId in self.animations){
            if (self.animations.hasOwnProperty(animationId)){
                if (self.animations[animationId] instanceof targetType){
                    delete self.animations[animationId]; // delete here
                    Human.timeline.removeAnimation(animationId); // delete from timeline
                }
            }
        }

    };

    /** Get camera of timeline at specific time
     * Leaf timelines should only have one or zero cameras
     * Returns camera info at time t if camera exists otherwise null.
     */
    Leaf.prototype.getCamera = function (time) {
        var self = this;
        if (self.cameraTween === null || self.cameraTween === undefined) {
            return null;
        }
        return self.cameraTween.query(self.cameraTween._control, time);
    };

})();
;/** Branch timeline
 * Branch timelines control updates to leaf timelines.
 * Can reference as many leaf-timelines as desired.
 * Should not map to two-different times on the same leaf.
 * INITIALIZATION - Special Handling of First Update to ensure all branches are independent.
 *    - Connfigurable initialization with default to clear and start with chapter data.
 *
 * Concerns:
 *    - Camera Animation:
 *      Engine can only handle one camera tween because there is only one Camera
 *      object. Theoretically, however, each branch map can point to one
 *      or more leaftimlines with a camera path. We currently have to stick with
 *      one; arbitrarily chosen to be the first one encountered.
 *      TODO: Tack and Obey "timeline.chapterCameraPath" property.
 *
 * TODO: Make this inherit from "chapter" data object?
*/
(function(){
    "use strict";

    var Branch = Human.timeline.BranchTimeline = function(humanChapter) {
        var self = this;  // self refers to a specific chapter branch timeline object.
        self._onEndOptions = ["loop", "freeze"]; //options for any constituent timelines after it has ended
        self.level = "branch";
        self.timeRange = null;

        self.id = humanChapter.id;
        self.maps = {};                    // Unique map components to map from branch timeline to child timelines - for animations
        humanChapter.timelineMap.forEach(function(map, idx){
          self.makeMapComponent(map, idx);
        });

        self.media = {};
        for (var clipMap in humanChapter.media){
            if (humanChapter.media.hasOwnProperty(clipMap)){
                self.addClip(clipMap, humanChapter.media[clipMap]);
            }
        }

        //TODO[PostRelease] - group info fields into single info object in humanChapter
        self.info = {
            displayName: humanChapter.displayName || "",
            description: humanChapter.description || ""
        };
        self.synchronization = humanChapter.synchronization;
        self.properties = humanChapter.properties || {};
        self.annotations = humanChapter.annotations || [];
        self.hotspots = humanChapter.hotspots || [];

        // TODO[PostRelease] - group options into options block in humanChapter
        self.options = humanChapter.options || {};
        if (humanChapter.hasOwnProperty("xray")){
          self.options.xray = humanChapter.xray;
        }

        self.camera = {};
        // TODO[PostRelease] - redefine humanChapter.camera to be action/location/screenPan in the data
        if (humanChapter.camera){
            self.camera = humanChapter.camera;
        }
        else {
            if (humanChapter.jumpTo){
                self.camera.action = "jumpTo";
                self.camera.location = humanChapter.jumpTo;
                if (humanChapter.jumpTo.hasOwnProperty("screenPan")){
                  self.camera.screenPan = humanChapter.jumpTo.screenPan;
                }
            } else if (humanChapter.flyTo) {
                self.camera.action = "flyTo";
                self.camera.location = humanChapter.flyTo;
                if (humanChapter.flyTo.hasOwnProperty("screenPan")){
                  self.camera.screenPan = humanChapter.flyTo.screenPan;
                }
            }
            if (humanChapter.options && humanChapter.options.screenPan){
                self.camera.screenPan = humanChapter.options.screenPan;
            } else if (humanChapter.hasOwnProperty("screenPan")){
                self.camera.screenPan = humanChapter.screenPan;
            }
        }

        //TODO[PostRelease] - group animation options into animation block in humanChapter
        self.animation = {"loop":false};
        if (humanChapter.loop){
            self.animation.loop = true;
        }

        //TODO[PostRelease] - should we copy default background to chapter background if not defined?
        self.background = humanChapter.background || {};

        self.effects = humanChapter.effects;

        // Bookkeeping Variables - track initialization progress
        self.firstUpdate = true;          // on first update we want to force the camera into correct position
        self.initializedCamera= false;
        self.initializedAnnotations = false;
        self.initializedProperties = false;
        self.initializedGraph = false;
        self.initializedHotspots = false;
        self.initializedParticles = false;


        // Custom Data
        self.customData = humanChapter.customData || {};
        self.particleSystems = self.customData.particleSystems || [];

        // Translations for displayName and description
        self.translations = self.translations || {};

        //Register with Timeline
        Human.timeline.branchTimelines[self.id] = self;
    };

    // Branch Media Clips
    Branch.prototype.addClip = function (clipMap, clip) {
        var self = this;
        if (self.media.hasOwnProperty(clipMap)) {
            delete self.media[clipMap];
        }

        // NOTE[EM] - fullUrl is a require clip property
        // if (!clip.hasOwnProperty("fullUrl")){
        //     clip.fullUrl = Human.media[clip.streamType].clips[clip.clipId].fullUrl;
        // }

        var mclip = {"data": clip, "published": false};

        mclip.publish = function () {
            Human.events.fire(clip.streamType + ".suggestedClipInfo", this.data);
            Human.events.fire(clip.streamType + ".suggestedClips", [this.data.clipId], true);
            this.published = true;
        };

        mclip.update = function (time) {
            if (this.data.time1 <= time && time <= this.data.time2) {
                if (!this.published) {
                    this.publish();
                }
            }
        };

        self.media[clipMap] = mclip;

    };

    // Branch Timeline Maps
    Branch.prototype.makeMapComponent = function (mapData, idx) {
        var self = this;
        var map = {};
        map.mapId = mapData.data.timeline + "_" + idx;
        map.start = mapData.start;
        map.end = mapData.end;
        map.data = mapData.data;

        if (Human.timeline.leafTimelines.hasOwnProperty(mapData.data.timeline)){
          map.data.timeline = Human.timeline.leafTimelines[mapData.data.timeline];
        } else {
          var _leaf = new Human.timeline.LeafTimeline(mapData.data.timeline);
          // map.data.timeline = Human.timeline.leafTimelines.dummy;
          map.data.timeline = _leaf;
        }

        // Create mapping function childTime = f(branchTime) : map.calcChildTime()
        var m;
        var b;
        if (map.data.fit) {
            // y = mx+b;
            var dy = map.data.end - map.data.start;
            var dx = map.end - map.start;
            m = dy / dx;
            b = map.data.start;
            map.calcChildTime = function (branchTime) {
                return m * (branchTime - map.start) + b;
            };
        }
        else {
            //y = mx + b;  x can be offset by where in time the map starts.
            m = 1.0;    //by definition
            b = map.data.start;
            if (map.data.onEnd === "freeze") {
                map.calcChildTime = function (branchTime) {
                    var y = m * (branchTime - map.start) + b;
                    return Math.min(y, map.data.end);
                };
            }
            else if (map.data.onEnd === "loop") {
                map.calcChildTime = function (branchTime) {
                    //SawTooth Function
                    var period = map.data.end - map.data.start;
                    var x = (branchTime - map.start);
                    return x - (period * Math.floor(x / period)) + b;
                };
            }
            else {
                Human.log.warn("WARNING: invalid onEnd property for branch timeline map data.");
            }
        }

        self.maps[map.mapId] = map;

        self.timeRange = self.getTimeFrame(); // update time range in case new map has changed it.
    };

    // Get All Branch Audio Clips
    Branch.prototype._getAudio = function () {
        var self = this;
        var audioClips = [];
        for (var clipId in self.media) {
            if (self.media.hasOwnProperty(clipId)) {
                if (self.media[clipId].data.streamType === "audio") {
                    audioClips.push(self.media[clipId].data);
                }
            }
        }
        return audioClips;
    };

    // Get start and end time of the entire branch
    Branch.prototype.getTimeFrame = function () {
        var self = this;
        var longestTime = 0.0;
        for (var amapId in self.maps) {
            if (self.maps.hasOwnProperty(amapId) && self.maps[amapId].end > longestTime) {
                longestTime = self.maps[amapId].end;
            }
        }
        if (longestTime === 0.0) {
            longestTime = 2.0;//Default time frame.
        }
        var _timeFrame = {
            firstTime: 0.0,
            lastTime: longestTime
        };
        return _timeFrame;
    };

    // Get Camera Eye/Look/Up Location data
    Branch.prototype.getCamera = function (time) {
        var self = this;
        if (time === "end") {
            time = self.getTimeFrame().lastTime;
        } else if (time === "start") {
            time = 0.0;
        }

        // If camera is tweened query the camera tween: Return eye/look/up
        var cameraLocation = self.getAnimatedCamera(time);
        if (cameraLocation) {
            cameraLocation.screenPan = cameraLocation.screenPan || self.options.screenPan;
            return cameraLocation;
        }

        // If chapter has camera property
        if (!Human.utils.isEmpty(self.camera)) {
            cameraLocation = self.camera.location;
            cameraLocation.screenPan = self.options.screenPan;
            return cameraLocation;
        }

        // Otherwise Use Default
        var defaultCamera = Human.view.camera._startcamera; //Fallback if no other methods found
        defaultCamera.screenPan = self.options.screenPan;
        return defaultCamera;
    };

    // Get the Eye/Look/Up from Camera tween, Null if DNE
    Branch.prototype.getAnimatedCamera = function (time) {
        var self = this;
        var timeRange = self.getTimeFrame();

        //cast time
        if (time === "start" || time < timeRange.startTime) {
            time = timeRange.startTime;
        } else if (time === "end" || time === "last" || time > timeRange.lastTime) {
            time = timeRange.lastTime;
        }

        var cameraMap = self.whichCameraMap(0);

        if (cameraMap === null || cameraMap === undefined) {
            return null;
        } else if (time >= cameraMap.start && time <= cameraMap.end) {
            var childTimeline = cameraMap.data.timeline;
            var childtime = cameraMap.calcChildTime(time);
            var camera = childTimeline.getCamera(childtime);
            if (camera !== null && camera !== undefined) {
                return camera;
            }
        } else {
            return null;
        }
    };

    Branch.prototype.whichCameraMap = function (time) {
        var self = this;
        var targetMaps = self.whichMaps(time);
        var idx;
        for (idx=0; idx<targetMaps.length; idx++){
            if (!!targetMaps[idx].map.data.timeline.cameraTween){
                return targetMaps[idx].map;
            }
        }
        //return null if current branch does not have an animated camera tween in its data
        return null;
    };

    Branch.prototype.reset = function () {
        var self = this;
        self.firstUpdate = true;
        self.initializedGraph = false;
        self.initializedCamera = false;
        self.initializedHotspots = false;
        self.initializedProperties = false;
        self.initializedAnnotations = false;
        self.initializedParticles = false;

        // Reset media objects
        var media = self.media;
        var key;
        var mediaObj;

        // VERIFY: I'm assuming that each item in self.media is an object with a 'published' property
        for (key in media) {
            if (media.hasOwnProperty(key)) {
                mediaObj = media[key];
                mediaObj.published = false;
            }
        }
    };

    Branch.prototype.whichMaps = function (time) {
        var self = this;
        var theMapIds = [];
        var result = [];

        if (time === "start") {
            time = 0.0;
        } else if (time === "end") {
            time = self.getTimeFrame().lastTime;
        }


        for (var mapId in self.maps) {
            if (self.maps.hasOwnProperty(mapId)) {
                var map = self.maps[mapId];
                if (time >= map.start && time <= map.end) {
                    theMapIds.push(mapId);
                }
            }
        }

        //Prefer "keepCamera" over "camera"
        // TODO[EM]: Safe to delete?
        // if (theMapIds.indexOf("transitionCamera") >= 0) {
        //     var ci = theMapIds.indexOf("camera");
        //     if (ci !== null && ci !== undefined) {
        //         theMapIds.splice(ci, 1);
        //     }
        // }

        theMapIds.every(function (mapId) {
            var map = self.maps[mapId];
            var o = {map: map};
            if (map.data.timeline.level === "leaf") {
                o.camera = true;
                result.push(o);
            } else {
                o.camera = false;
                result.unshift(o);
            }
            return true;
        });

        return result;

    };

    Branch.prototype.getChildLeafTimelines = function (time) {
        var self = this;
        var maps = self.whichMaps(time);
        var result = {};
        maps.every(function (d) {
            var leaf = d.map.data.timeline.id;
            var leafTime = d.map.calcChildTime(time);
            result[leaf] = leafTime;
            return true;
        });
        return result;
    };

    Branch.prototype.getUniqueLeafTimelines = function () {
        var self= this;
        var result = {};
        for (var mapid in self.maps) {
            if (self.maps.hasOwnProperty(mapid)) {
                var map = self.maps[mapid];
                result[map.data.timeline.id] = map.data.timeline;
            }
        }
        return result;
    };

    Branch.prototype.initCamera = function(time, ok) {
        /**
         * Update camera if (a) no camera tween, and (b) not ignored
         */
        var self = this;
        var cameraMap = self.whichCameraMap(time);
        if (!cameraMap && ! self.camera.ignore) {
            if (self.camera.screenPan) {
                Human.view.camera.setScreenPan(self.camera.screenPan);
            }
            if (self.camera.action === "flyTo") {
                Human.view.camera.fly.flyTo(self.camera.location, ok);
            }
            else {
                Human.view.camera.fly.jumpTo(self.camera.location, ok);
            }

        } else if (!!cameraMap) {
          if (self.camera.action === "flyTo") {
              Human.view.camera.fly.flyTo(self.getCamera(time), ok);
          }
          else {
              Human.view.camera.fly.jumpTo(self.getCamera(time), ok);
          }
        }
        else if (ok) {
            ok();
        }
    };

    Branch.prototype.initAnnotations = function(annotations) {
        var self = this;
        //clear all annotations
        Human.view.annotations.clearAnnotations();

        //add ones defined in chapter
        annotations.forEach(function (annotation, i) {
            var annotationId = "___" + self.id + "." + i;
            
            if (!annotation.pos && annotation.objectId) {
                var object = Human.scene.objects[annotation.objectId];
                annotation.pos = object.getCenter();
            }
            
            annotation.annotationId = annotationId;
            annotation.title = annotation.title || "";
            annotation.description = annotation.description || "";
            annotation.dir = annotation.pinVec || annotation.dir;
            annotation.type = annotation.type || "default";
            annotation.enabled = annotation.type !== "secondary";
            annotation.shown = annotation.type !== "secondary";
            annotation.labelShown = annotation.type !== "secondary";
            annotation.labelOffset = annotation.labelOffset || null;
            annotation.saved = true;

            Human.view.annotations.createAnnotation(annotation);
        });
    };

    Branch.prototype.initGraph = function(synchronization){
        // Single-traversal object property setting procedure
        Human.scene.setObjectProperties(synchronization);
    };

    Branch.prototype.initProperties = function(){
        var self = this;
        //xray mode - option
        if (self.options.xray === true) {
            Human.rpc.call(null, "xray.setEnabled", {enable: true});
        } else {
            Human.rpc.call(null, "highlight.setEnabled", {enable: true});
        }

        Human.properties.applyDefaults();

        //All other properties
        Human.properties.set(self.properties);

        //Effects
        Human.view.effects.setEnabled({effectIds: self.effects, replace: true});
    };

    Branch.prototype.initParticles = function(){
        for (var i = 0, len = this.particleSystems.length; i < len; ++i) {
            Human.particles.enable(this.particleSystems[i]);
        }
    };

    Branch.prototype.init = function(time, params, ok){
        var self = this;
        // book keeping
        Human.events.fire("timeline.chapters.activate.start",{chapterId: self.id});
        self.timeRange = self.getTimeFrame();

        // configurable initialization update
        if (params.camera) {
            self.initializedCamera = true;
            self.initCamera(time, params.cameraCallback || function(){});
        }

        if (params.graph) {
            self.initializedGraph = true;
            self.initGraph(self.synchronization);
        }

        if (params.annotations) {
            self.initializedAnnotations = true;
            self.initAnnotations(self.annotations);
        }

        if (params.properties) {
            self.initializedProperties = true;
            self.initProperties();
        }

        if (params.particles) {
            Human.particles.disableAll();
            Human.particles.resetAll();
            self.initializedParticles = true;
            self.initParticles();
        }

        if (ok){
            ok();
        }
        Human.events.fire("timeline.chapters.activate.finish",{chapterId: self.id});
    };

    Branch.prototype.uninit = function(params,ok){
        //TODO[EM]: How to restore properties?
        //TODO[EM]: How to restore camera?
        var self = this;
        Human.events.fire("timeline.chapter.deactivate.start");
        self.initGraph({});
        self.initAnnotations([]);
        //self.initCamera();
        if (ok){
            ok();
        }
        Human.events.fire("timeline.chapter.deactivate.finish");
    };

    Branch.prototype.update = function (time, params, ok) {
        params = params || {};
        var self = this;
        // Handle first update
        if (self.firstUpdate) {
            self.firstUpdate = false;

            if (!params.hasOwnProperty("camera")){
                params.camera = !self.initializedCamera;
            }
            if (!params.hasOwnProperty("annotations")){
                params.annotations = !self.initializedAnnotations;
            }
            if (!params.hasOwnProperty("properties")){
                params.properties = !self.initializedProperties;
            }
            if (!params.hasOwnProperty("graph")){
                params.graph = !self.initializedGraph;
            }
            if (!params.hasOwnProperty("particles")){
                params.particles = !self.initializedParticles;
            }
            self.init(time, params, function(){});
        }
        self._update2(time);

        if (ok){
            ok();
        }
    };

    Branch.prototype._update2 = function (time) {
        var self = this;
        if (self.timeRange === null || self.timeRange === undefined) {
            self.timeRange = self.getTimeFrame();
        }

        var timeRange = self.timeRange;

        if (time === "start" || time < timeRange.startTime) {
            time = timeRange.startTime;
        } else if (time === "end" || time === "last" || time > timeRange.lastTime) {
            time = timeRange.lastTime;
        }


        //update timeline maps
        var mapsData = self.whichMaps(time);

        mapsData.forEach(function (d) {
            var map = d.map;
            var cam = d.camera;
            var childTimeline = map.data.timeline;
            var childTime = map.calcChildTime(time);
            childTimeline.update(cam, childTime);
            return true;
        });

        //update media clips
        for (var mediaId in self.media) {
            if (self.media.hasOwnProperty(mediaId)) {
                self.media[mediaId].update(time);
            }
        }
    };

    Branch.prototype.destroy = function(){
        var self = this;
        // Destroys leaf timelines
        var uniqueLeaves = self.getUniqueLeafTimelines();
        for (var leafId in uniqueLeaves){
            if (uniqueLeaves.hasOwnProperty(leafId) && leafId !=="dummy" ) {
                uniqueLeaves[leafId].destroy();
            }
        }
        delete Human.timeline.branchTimelines[self.id];
    };
})();
;/** Root timeline
 * Construction modalities:
 *  - Constructed by module, chapters added by module, build when done
 *
 * Responsibilities:
 *     - manage global time and playing of chapters
 *     - building a global timeline from branches
 *             -- build chapters and manage chapter queue
 *     - managing play status at borders between chapters
 *             -- chapter | chapter boundary
 *     - mapping global (root) to local (branch) times and back
 *     - editing queue
 *             -- add chapters
 *             -- delete chapters
 *             -- reorder chapters
 *
 * Concerns:
 *    - Intuitive control of camera.
 *
 */
(function(){
    "use strict";

    var Root = Human.timeline.RootTimeline = function (moduleId, params) {
        params = params || {};
        var self = this;

        // Variables
        self.id = moduleId;
        self.level = 'root';
        self.animationOptions = {}; // loop:true/false
        self._theQueue = [];      //Master Sequence of All Branch Timelines in the scene registered to be played; can NOT contain empty timelines.
        self._chapters = [];      //Only chapter branches in order
        self._times = [];         // the times corresponding to starts of constituent branch timelines.
        self._timeFrame = null;
        self.freeAnimations = {};

        // Variables: For Update
        self._firstUpdate = true;
        self._prevBranch = null;
        self._prevTime = null;
        self._nowBranch = null;
        self._nowTime = null;
    };

    /** Global Animation Options
     * Set and validate animation options from the 'data' object.
     * Replaces existing animation options.
     * Options that are only referenced at the start and end of global timeline.
     * Note, that rebuilding the root will force a start.
     */
    Root.prototype.setAnimationOptions = function (data, params) {
        var self = this;
        params = params || {};

        // Backwards Compatibility: animation property from module
        if (data.animation) {
            self.animationOptions = data.animation;
        }

        // TODO: Unspecified other options
    };

    /** Add Chapter Branch
     * Add a chapter to the chapters array.
     * @branch: a valid branch timeline object
     * @params.position : (integer) position in the queue.
     * @params.rebuild :  (boolean) specifying wheter to rebuild root after adding chapter.
     *
     * Generally, params.rebuild=false while loader is adding chapters to root and only true on the last chapter.
     */
    Root.prototype.addChapter = function (branch, params) {
        var self = this;
        params = params || {};
        var rebuild = (params.hasOwnProperty("rebuild")) ? params.rebuild : true;
        var position = params.position || self._chapters.length;

        if (position < 0 || position > self._chapters.length) {
            Human.log.warn("RootTimeline.addChapter(): Invalid index " + position + "position");
        }

        // Add to array
        self._chapters.splice(position, 0, branch);
        if (rebuild) {
            self.build();
        }
    };

    // Activate the Root and Step
    // TODO[EM]: How should we handle the time config? Don't like that it's part of init()
    Root.prototype.activate = function(time, config, ok){
        var self = this;
        Human.timeline.activeRoot = self;
        var branchInfo = self.mapGlobalTime(time, {which : "second", direction : "forwards"});

        // Fire Event and Inform Listeners
        Human.events.fire("timeline.chapters.updated", self._assembleChaptersUpdated());

        Human.events.fire("timeline.timeFrame.updated", {
            firstTime: self._timeFrame.firstTime,
            lastTime: self._timeFrame.lastTime
        });

        Human.timeline.stop();

        Human.timeline.activeRoot.update(time, {
          which: 'second', direction: 'forwards'
        });

        Human.timeline.time = time;
        Human.timeline._time1 = time;
        Human.timeline._time2 = time;
        Human.timeline._freeTime = time;

        branchInfo.branch.init(branchInfo.time, config, ok);
    };

    // Deactive the Root
    Root.prototype.deactivate = function(config, ok){
        var self = this;
        if (Human.timeline.activeRoot === null) {
          return;
        }
        if (Human.timeline.activeRoot.id === self.id){
            // Fire Event and Inform Listeners
            Human.events.fire("timeline.chapters.updated", []);
            Human.events.fire("timeline.timeFrame.updated", {
                firstTime: 0,
                lastTime: 0
            });
            Human.timeline.activeRoot = null;
            Human.timeline.stop();
            Human.timeline.time = 0;
            Human.timeline._time1 = 0;
            Human.timeline._time2 = 0;
            Human.timeline._freeTime = 0.0;
            self._nowBranch.uninit(config, ok);
        }
    };

    /** --------------------------- HELPER AND QUERY FUNCTIONS ------------------------------
     */

    /** Get unique descendent leaf timeline
     * Return : {leafId: leafTimeline}
     */
    Root.prototype.getDescendentLeaves = function () {
        var self = this;
        var result = {};
        self._chapters.forEach(function (chapter) {
            var leafReferences = chapter.getChildLeafTimelines(0);
            for (var leafid in leafReferences) {
                if (leafReferences.hasOwnProperty(leafid)) {
                    if (!result.hasOwnProperty(leafid)) {
                        result[leafid] = Human.timeline.leafTimelines[leafid];
                    }
                }
            }
        });

        return result;
    };

    /** Get time frame (duration) of the root Timeline
     */
    Root.prototype.getTimeFrame = function (params) {
        var self = this;
        params = params || {};
        var end = 0.0;
        var sequence = self._chapters;

        // Sum up time of all branches in sequence
        sequence.forEach(function (branch) {
            end += branch.getTimeFrame().lastTime;
        });

        return {
            firstTime: 0.0,
            lastTime: end
        };
    };

    /** Get the index of branch.id in the root queue or optionally the chapters list.
     * Return null if not found
     */
    Root.prototype.whereIsBranch = function (branch, params) {
        var self = this;
        params = params || {};

        var idx = 0, found = false;
        var branchIndex = null;
        var sequence = [];
        if (params.chapters === true) {
            sequence = self._chapters;
        } else {
            // search whole timeline by default
            sequence = self._theQueue;
        }
        while (!found && idx < sequence.length) {
            found = (sequence[idx].id === branch.id) ? true : false;
            if (!found) {
                idx++;
            } else {
                branchIndex = idx;
            }
        }
        return branchIndex;
    };

    /** Get Branch from Que based on one property
     * @param.id : default, retrieve branch with specific id
     */
    Root.prototype.getBranch = function (params) {
        var self = this;
        params = params || {};
        var key, value, found = false, i = 0, branch = {};

        if (Human.utils.isEmpty(params)) {
            return null;
        } else if (Object.keys(params).length > 1) {
            Human.log.warn("timeline.RootTimeline.getBranch", "too many parameters, using only the first.");
        }

        // Search information
        key = Object.keys(params)[0];
        value = params[key];

        while (!found && i < (self._theQueue.length)) {
            branch = self._theQueue[i];
            if (self._theQueue[i][key] === value) {
                found = true;
            }
            i++;
        }

        var result;
        if (found) {
            result = branch;
        } else {
            result = null;
        }
        return result;
    };

    /** map global time TO local time on branch.
     * Returns object : {
        branch: branchTimeline,   # reference to corresponding branch timeline
        time: float,              # corresponding local time on branch
        index: integer            # the index of the branch in the reference sequence
     }
     *
     * @params.tie = "earlier"/"later" if take earlier/later branch in a border case
     * @params.which = "first/second"
     * @params.direction = "forwards/backwards"
     *
     * In the event of a tie, this function references either (a) the tie parameter, or
     * (b) the border condition which/direction parameters to pick the right target branch.
     *
     * Border cases include any time that can point to two branches.
     * By convention, the first and last branches border eachother. Therefore,
     * time 0 will point to lastBranch (as the "earlier" branch), and the first
     * branch (as the "later" branch).
     */
    Root.prototype.mapGlobalTime = function (time, params) {
        var self = this;
        params = params || {};

        // parameter checking
        if (time === "end") {
            time = self.getTimeFrame().lastTime;
        } else if (time === "start") {
            time = 0.0;
        }

        // parameter constraining
        if (time < 0) {
            time = 0;
        } else if (time > self.getTimeFrame().lastTime) {
            time = self.getTimeFrame().lastTime;
        }

        // tie handling and border conditions
        var tie = "earlier"; // default
        if (params.tie){
            tie = params.tie;
        } else if (params.which && params.direction){
            if (params.direction === "forwards"){
                if (params.which === "second"){
                    tie = "later";
                } else {
                    tie = "earlier";
                }
            } else if (params.direction === "backwards") {
                if (params.which === "first"){
                    tie = "later";
                } else {
                    tie = "earlier";
                }
            }
        }



        var result = {
            branch: null,
            time: null,
            index: null
        };

        var borderIndex = self._times.indexOf(time);
        if (borderIndex >= 0) {
            // Border Case: Use tie-breaker option
            var branchIndex = (tie !== "later") ? (borderIndex - 1) : borderIndex;
            branchIndex = (branchIndex < 0) ? self._theQueue.length - 1 : branchIndex;      // use last as "before first"
            branchIndex = (branchIndex >= self._times.length - 1) ? 0 : branchIndex;      // use first as "after last"

            result.branch = self._theQueue[branchIndex];
            result.time = (tie !== "later") ? (time - self._times[branchIndex]) : 0.0;
            result.index = branchIndex;
        }
        else {
            var neighbors = Human.utils.binarySearch(self._times, time);
            result.branch = self._theQueue[neighbors.index1]; // branch corresponding to left hand neighbor
            result.time = time - neighbors.value1;
            result.index = neighbors.index1;
        }
        return result;
    };

    /** map branch local time TO global time
     */
    Root.prototype.mapBranchTime = function (branch, branchTime, params) {
        var self = this;
        params = params || {};
        var worldTime = 0.0;
        var branchIndex = self.whereIsBranch(branch);
        if (branchTime === "end") {
            branchTime = branch.getTimeFrame().lastTime;
        }
        else if (branchTime === "start") {
            branchTime = 0.0;
        }

        if (branchIndex === null) {
            worldTime = null;
        } else {
            worldTime = self._times[branchIndex] + branchTime;
        }
        return worldTime;
    };

    /** Get the chapter-branch of the neighboring branch at specified time
     * @which = "next"/"previous" chapter in sequence
     *
     * @param {now} [branch object, or time float]
     * @param {params.tie} Which branch to use as current branch on border case.
     * Return null if no valid chapter exists;
     */
    Root.prototype.getNeighborChapter = function (now, which, params) {
        var self = this;
        params = params || {};

        var currentBranch = null;
        var currentIndex = null;
        which = (which === "previous") ? "previous" : "next";
        if (now instanceof Human.timeline.BranchTimeline) {
            currentBranch = now;
        } else if (typeof(now) === "number") {
            var tie = (params.tie === "later") ? "later" : "earlier";
            currentBranch = self.mapGlobalTime(now, {tie: tie});
        } else {
            Human.log.warn("timeline.root.getNeighborChapter", "invalid 'now' argument :" + JSON.stringify(now));
            return null;
        }

        currentIndex = self.whereIsBranch(currentBranch);


        // Edge Cases
        if (currentIndex === 0 && which === "previous") {
            return null;
        } else if (currentIndex === self._theQueue.length - 1 && which === "next") {
            return null;
        }

        // search up/down (maximum of two branches away in any direction)
        var idx = currentIndex;
        if (which === "next") {
            idx++;
        } else {
            idx--;
        }

        // return chapter branch
        return self._theQueue[idx];
    };

    /** Return True if branch is first chapter
     */
    Root.prototype.isFirst = function (branch) {
        var self = this;
        if (branch.id === self._theQueue[0].id) {
            return true;
        } else {
            return false;
        }
    };

    /** Return True if chapter is last chapter
     */
    Root.prototype.isLast = function (branch) {
        var self = this;
        var idx = self._theQueue.length - 1;
        if (branch.id === self._theQueue[idx].id) {
            return true;
        } else {
            return false;
        }
    };
    //-----------------------------  BUILD FUNCTIONS ----------------------------------------
    /** Add Free Animations to Global Timeline
     * Animations tagged to be not on the timeline will be added to
     * the global timeline and will not respond to play/stop status.
     *
     * This function will add all free animations in any descendent leaf timelines
     */
    Root.prototype.buildFreeAnimations = function (params) {
        var self = this;
        params = params || {};
        var leaves = self.getDescendentLeaves();
        for (var leafId in leaves) {
            if (leaves.hasOwnProperty(leafId)) {
                var _fa = leaves[leafId].freeAnimations;
                for (var _fai in _fa) {
                    if (_fa.hasOwnProperty(_fai) && !self.freeAnimations.hasOwnProperty(_fai)) {
                        self.freeAnimations[_fai] = _fa[_fai];
                    }
                }
            }
        }
    };

    /** Build queue
     * The Queue is the ordered list of all chapters that
     * collectively constitue the global timeline.
     *
     * Also populate time (and border times)
     */
    Root.prototype.buildQueue = function (params) {
        var self = this;
        params = params || {};
        self._theQueue = [];
        var cumTime = 0.0; // keep track of cumulative time
        self._times = [cumTime];

        self._chapters.forEach(function (chapter) {
            cumTime += chapter.getTimeFrame().lastTime;
            self._theQueue.push(chapter);
            self._times.push(cumTime);
        });
    };

    /** Build Root Timeline
     */
    Root.prototype.build = function (params) {
        var self = this;
        params = params || {};
        self._theQueue = [];
        self._times = [];
        self.buildFreeAnimations();
        self.buildQueue();

        // Register with replacement
        if (Human.timeline.rootTimelines[self.id]) {
            delete Human.timeline.rootTimelines[self.id];
        }
        Human.timeline.rootTimelines[self.id] = self;

        self._timeFrame = self.getTimeFrame();


        // (Re Set current now-branch and now-time
        if (self._nowBranch === null) {
            self._nowBranch = self._theQueue[0];
            self._nowTime = 0.0;
            self._prevBranch = self._nowBranch;
            self._prevTime = 0.0;
        } else if (self.whereIsBranch(self._nowBranch) === null) {
            self._nowBranch = self._theQueue[0];
            self._nowTime = 0.0;
            if (self._prevBranch === null) {
                self._prevBranch = self._nowBranch;
                self._prevTime = self._nowTime;
            } else if (self.whereIsBranch(self._prevBranch) === null) {
                self._prevBranch = self._nowBranch;
                self._prevTime = self._nowTime;
            }
        }

        Human.events.fire("timeline.chapters.updated", self._assembleChaptersUpdated());

        Human.events.fire("timeline.timeFrame.updated", {
            firstTime: self._timeFrame.firstTime,
            lastTime: self._timeFrame.lastTime
        });
    };

    /** Destroy
     * Soft Deletions of branch timelines
     */
    Root.prototype.destroy = function () {
        var self = this;
        // Remove branches
        self._theQueue.forEach(function (branch) {
            if (Human.timeline.branchTimelines.hasOwnProperty(branch.id)) {
                branch.destroy();
            }
        });

        // Remove from roots and as active root
        if (Human.timeline.rootTimelines.hasOwnProperty(self.id)) {
            delete Human.timeline.rootTimelines[self.id];
        }
    };

    //------------------------------  ACTION FUNCTIONS -----------------------------------------
    Root.prototype.updateFreeAnimations = function (time) {
        var self = this;
        for (var fid in self.freeAnimations) {
            if (self.freeAnimations.hasOwnProperty(fid)) {
                self.freeAnimations[fid].update({cameraEnabled: false}, time);
            }
        }

        var particleSystems = self._nowBranch.particleSystems;

        for (var i = 0, len = particleSystems.length; i < len; ++i) {
            Human.particles.update(particleSystems[i], time);
        }
    };

    // update the root timeline at the specified global time.
    Root.prototype.update = function (time, params, ok) {
        var self = this;
        params = params || {};
        var borderCondition = {}, toUpdate = [];
        if (typeof(ok) !== "function"){
            ok = function(){};
        }

        // Default parameter handling
        borderCondition = {which: "both", direction: "forwards"};
        if (params.hasOwnProperty("which")) {
            borderCondition.which = params.which;
        }
        if (params.hasOwnProperty("direction")) {
            borderCondition.direction = params.direction;
        }

        // Check for valid time
        if (time < 0) {
            time = 0;
            Human.log.warn("Time violates lower bound. Updating to time = 0.0");
        }
        else if (time > self._timeFrame.lastTime) {
            time = self._timeFrame.lastTime;
            Human.log.warn("Time violates upper bound. Updating to time = " + time);
        }

        // get list of mapped branches and their local times to update.
        toUpdate = self._getBranchesToUpdate(time, borderCondition);

        // Check for first update
        if (self._firstUpdate) {
            self._nowBranch = toUpdate[0].branch;
            self._nowTime = toUpdate[0].time;
            self._firstUpdate = false;
        }

        // udpate mapped branches in order
        var chaptersFirstUpdate = false;
        toUpdate.forEach(function (item) {
            self._prevBranch = self._nowBranch;
            self._prevTime = self._nowTime;
            chaptersFirstUpdate = item.branch.firstUpdate;
            self._nowBranch = item.branch;
            self._nowTime = item.time;
            item.branch.update(item.time, {}, ok); // TODO[EM]: Some optional overrides to first upddate

            /** Notify that new chapter has been entered the first time
             * Ideally, the chapter-branch itself could do the notification,
             * but for backwards compatibility the UI wants to know which chapter
             * in the context of the whole root timeline has fired.
             */
            if (chaptersFirstUpdate) {
                Human.events.fire("timeline.chapters.activated", self._assembleChaptersActivated());
            }

        });

        // reset previous branch if necessary.
        if (self._prevBranch.id !== self._nowBranch.id) {
            self._prevBranch.reset();
        }

    };

    /** Return an array of the local information (branch, timeline) to be updated
     *   based on global time and border Condition.
     */
    Root.prototype._getBranchesToUpdate = function (time, borderCondition) {
        var self = this;
        if (self._times.indexOf(time) >= 0) {
            return self._getBorderBranches(time, borderCondition);
        } else {
            return [self.mapGlobalTime(time, {tie: "earlier"})];
        }
    };

    /** Return one or more of the branches at specified boder time.
     */
    Root.prototype._getBorderBranches = function (time, borderCondition) {
        var self = this;
        var _left = self.mapGlobalTime(time, {tie: "earlier"});
        var _right = self.mapGlobalTime(time, {tie: "later"});
        var order = [_left, _right]; // default is to play in forwards order

        // Modify the "order" based on border Condition
        if (borderCondition.direction === "backwards") {
            order = [_right, _left];
        }
        if (borderCondition.which === "first") {
            order.splice(1, 1);
        } else if (borderCondition.which === "second") {
            order.splice(0, 1);
        }
        return order;
    };

    // ------------------------------ EVENT INFORMATION ----------------------------------------
    /** This function returns the object to be sent with timeline.chapters.updated
     * The result is a list of chapter blocks, each of which contains
     * the chapter's global start time, duration, displayName, description, and index.
     */
    Root.prototype._assembleChaptersUpdated = function () {
        var self = this;
        var result = [];
        var i;
        var len;
        var chapters = self._chapters;
        var branch;
        var block;

        for (i = 0, len = chapters.length; i < len; i++) {
            branch = chapters[i];
            block = {
                chapterId: branch.id,
                time: self.mapBranchTime(branch, 0.0),
                duration: branch.getTimeFrame().lastTime,
                displayName: branch.info.displayName,
                description: branch.info.description,
                loop: branch.animation.loop,
                index: i
            };
            result.push(block);
        }

        return result;
    };

    /** This function returns the object to be sent with timeline.chapters.activated
     * events, which are fired on every update.
     *
     */
    Root.prototype._assembleChaptersActivated = function () {
        var self = this;
        var result = {};
        result.oldChapterIndex = self.whereIsBranch(self._prevBranch, {chapters: true}); // index of old chapter in sequence of chapters
        result.newChapterIndex = self.whereIsBranch(self._nowBranch, {chapters: true}); // index of new chapter in sequence of chapters
        result.time = self.mapBranchTime(self._nowBranch, self._nowTime);
        result.loop = self._nowBranch.animation.loop || false;
        return result;
    };

    /** This function returns per-chapter information for all chapters needed by timeline.query
     */
    Root.prototype._assembleQueryChapters = function () {
        var self = this;
        var result = [];
        var i;
        var len;
        var chapters = self._chapters;
        var branch;

        for (i = 0, len = chapters.length; i < len; i++) { // OPTIMIZATION: Don't use GC-collected callback
            branch = chapters[i];

            result.push({
                chapterId: branch.id,
                time: self.mapBranchTime(branch, 0.0),
                displayName: branch.info.displayName,
                description: branch.info.description,
                type: "branch",
                tags: branch.tags || [],
                annotations: branch.annotations,
                hotspots: null,
                flyTo: branch.camera.location,
                active: (self._nowBranch.id === branch.id), // OPTIMIZATION: Remove redundant conditional
                sounds: branch._getAudio(),
                translations: branch.translations || null
            });
        }

        return result;
    };

})();
;(function() {
    "use strict";

    var idCounter = 0;

    var Particles = Human.particles = {
        creators: {},
        updaters: {},
        constraints: {},
        shapes: {},
        systems: {}
    };

    Particles.parse = function(json) {
        for (var i = 0, len = json.length; i < len; ++i) {
            parseSystem(json[i]);
        }
    };

    Particles.update = function(id, time) {
        Particles.systems[id].update(time);
    };

    Particles.updateAll = function(time) {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.update(id, time);
            }
        }
    };

    Particles.enable = function(id) {
        Particles.systems[id].enable();
    };

    Particles.enableAll = function() {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.enable(id);
            }
        }
    };

    Particles.disable = function(id) {
        Particles.systems[id].disable();
    };

    Particles.disableAll = function() {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.disable(id);
            }
        }
    };

    Particles.reset = function(id) {
        Particles.systems[id].reset();
    };

    Particles.resetAll = function() {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.reset(id);
            }
        }
    };

    Particles.destroy = function(id) {
        if (Particles.systems[id]) {
            Particles.systems[id].destroy();
            delete Particles.systems[id];
        }
    };

    Particles.destroyAll = function() {
        for (var id in Particles.systems) {
            if (Particles.systems.hasOwnProperty(id)) {
                Particles.destroy(id);
            }
        }
    };

    function parseSystem(json) {
        var id = json.id || ("ps" + idCounter++);
        var numParticles = json.numParticles;
        var options = {
            objectId: json.objectId,
            properties: json.properties,
            material: json.material
        };
        var creators = [];
        var updaters = [];
        var constraints = [];

        var creatorDefs = json.creators || [];
        var updaterDefs = json.updaters || [];
        var constraintDefs = json.constraints || [];

        var trapIdCounter = 0;
        var shape = null;
        var shapeDirection = null;
        var s, shapeType;

        var i, len, type;
        var c, u;
        for (i = 0, len = creatorDefs.length; i < len; ++i) {
            c = creatorDefs[i];
            type = c.type;

            creators.push(new Particles.creators[type](c));

            if (type === "Lifetime") {
                options.lifetimes = true;
            } else if (type === "SolidColor") {
                options.colors = true;
            }
        }

        for (i = 0, len = updaterDefs.length; i < len; ++i) {
            u = updaterDefs[i];
            var updater = null;
            var path = null;
            type = u.type;


            if (u.shape) {
                s = u.shape;
                shapeType = s.type;

                shape = new Particles.shapes[shapeType](s);
                shapeDirection = s.direction || "in";
            }

            updater = new Particles.updaters[type](u);

            if (type === "AgeColorBlend") {
                options.colors = true;
                options.lifetimes = true;
            } else if (type === "Path") {
                path = updater;
                var nodes = u.nodes;
                for (var j = 0; j < nodes.length; ++j) {
                    updater.addNode(nodes[j]);
                }
                options.paths = true;
            }

            if (shape) {
                updater.shape = shape;
                updater.shapeDirection = shapeDirection;
            }

            updaters.push(updater);
        }

        for (i = 0, len = constraintDefs.length; i < len; ++i) {
            c = constraintDefs[i];
            type = c.type;

            var trapId;

            if (c.shape) {
                s = c.shape;
                shapeType = s.type;

                shape = new Particles.shapes[shapeType](s);
                shapeDirection = s.direction || "in";
            }

            if (c.trap) {
                trapId = trapIdCounter++;
                options.traps = true;
            } else {
                trapId = -1;
            }

            switch (type) {
                case "LifetimeKill":
                case "LifetimeStop":
                    constraints.push(new Particles.constraints[type]());
                    break;

                case "PathKill":
                case "PathRadius":
                case "PathStop":
                    constraints.push(new Particles.constraints[type](path));
                    break;

                case "ShapeBounce":
                case "ShapeStop":
                case "ShapeKill":
                    constraints.push(new Particles.constraints[type](shape, shapeDirection, trapId));
                    break;

            }
        }

        var ps = new Particles.ParticleSystem(numParticles, options);
        ps.creators = creators;
        ps.updaters = updaters;
        ps.constraints = constraints;

        if (json.emissionAverage) {
            ps.emissionAverage = json.emissionAverage;
        }

        if (json.emissionVariance) {
            ps.emissionVariance = json.emissionVariance;
        }

        if (json.maxSpeed) {
            ps.maxSpeed = json.maxSpeed;
        }

        if (json.pointSize) {
            ps.pointSize(json.pointSize);
        }

        Particles.systems[id] = ps;
    }
})();
;(function() {
    "use strict";

    var tempPosition = new Float32Array(3);
    var tempVelocity = new Float32Array(3);
    var tempColor    = new Uint8Array(4);

    var ParticleSystem = Human.particles.ParticleSystem = function ParticleSystem(maxNumParticles, options) {
        options = options || {};
        
        var objectId = options.objectId;
        var material = options.material;
        var properties = options.properties || {};
        var hasColors = !!options.colors;
        var hasLifetimes = !!options.lifetimes;
        var hasPaths = !!options.paths;
        var hasTraps = !!options.traps;
        var parentNode = null;
        

        this.activeParticlesBegin = 0;
        this.numParticles = 0;
        this.maxSpeed = 0;
        this.maxNumParticles = maxNumParticles;
        this.attributes = {
            stopped: new Array(maxNumParticles),
            dead: new Array(maxNumParticles),
            positions: new Float32Array(maxNumParticles * 3),
            velocities: new Float32Array(maxNumParticles * 3),
            colors: hasColors ? new Uint8Array(this.maxNumParticles * 4) : null,
            lifetimes: hasLifetimes ? new Float32Array(this.maxNumParticles) : null,
            ages: hasLifetimes ? new Float32Array(this.maxNumParticles) : null,
            paths: hasPaths ? new Uint8Array(this.maxNumParticles) : null,
            traps: hasTraps ? new Uint32Array(this.maxNumParticles) : null
        };

        if (objectId) {
            var object = Human.scene.objects[objectId];
            if (object) {
                parentNode = object.getTransformNode();
            }
        }

        if (!parentNode) {
            parentNode = Human.renderer.getContentRootNode();
        }

        this.rootNode = null;
        this.properties = null;
        this.material = null;
        this.geometry = null;

        var node;

        properties.enabled = false;
        properties.picking = false;

        this.rootNode = this.properties = node = parentNode.addNode({
            type: "properties",
            properties: properties
        });

        if (material) {
            material.type = "material";
            this.material = node = node.addNode(material);
        }

        this.geometry = node.addNode({
            type: "geometry",
            positions: this.attributes.positions,
            colors: this.attributes.colors,
            primitive: "points"
        });
        

        this.enabled = false;

        this.emissionAverage = 1;
        this.emissionVariance = 0;
        this.creators = [];
        this.updaters = [];
        this.constraints = [];
        this.previousTime = null;
    };

    ParticleSystem.prototype.pointSize = function(size) {
        this.geometry.setPointSize(size);
    };

    ParticleSystem.prototype.update = function(time) {
        if (!this.enabled) {
            return;
        }
        
        var max = Math.max;
        var min = Math.min;
        var sqrt = Math.sqrt;
        var floor = Math.floor;
        var rand = Math.random;

        this.previousTime = this.previousTime || time;
        var delta = min(time - this.previousTime, 0.04);

        var attributes = this.attributes;
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var hasAges = !!ages;

        var maxSpeed = this.maxSpeed * delta;
        var maxSpeed2 = maxSpeed * maxSpeed;

        var i, j, vi, len;


        if (this.numParticles < this.maxNumParticles) {
            var emissionAverage = this.emissionAverage * delta;
            var emissionVariance = this.emissionVariance * delta;

            var count = max(emissionAverage + rand() * 2 * emissionVariance - emissionVariance, 0);

            if (count >= 1) {
                count = floor(count);
            } else {
                count = rand() < count ? 1 : 0;
            }

            var endEmit = min(this.numParticles + count, this.maxNumParticles);

            for (i = this.numParticles; i < endEmit; ++i) {
                vi = i * 3;

                positions[vi]     = 0;
                positions[vi + 1] = 0;
                positions[vi + 2] = 0;

                velocities[vi]     = 0;
                velocities[vi + 1] = 0;
                velocities[vi + 2] = 0;

                attributes.dead[i] = false;
                attributes.stopped[i] = false;
                
                if (attributes.paths) {
                    attributes.paths[i] = 0;
                }

                if (attributes.traps) {
                    attributes.traps[i] = 0;
                }
            }

            
            for (j = 0, len = this.creators.length; j < len; ++j) {
                this.creators[j].create(this.numParticles, endEmit, attributes);
            }
            
            this.numParticles = endEmit;
        }

        for (j = 0, len = this.updaters.length; j < len; ++j) {
            this.updaters[j].update(this.activeParticlesBegin, this.numParticles, attributes, delta);
        }

        for (i = this.activeParticlesBegin; i < this.numParticles; ++i) {
            vi = i * 3;

            tempVelocity[0] = velocities[vi] * delta;
            tempVelocity[1] = velocities[vi + 1] * delta;
            tempVelocity[2] = velocities[vi + 2] * delta;

            if (maxSpeed2 > 0) {
                var speed2 = tempVelocity[0] * tempVelocity[0] + tempVelocity[1] * tempVelocity[1] + tempVelocity[2] * tempVelocity[2];

                if (speed2 > maxSpeed2) {
                    var speed = sqrt(speed2);
                    var ratio = maxSpeed / speed;
                    tempVelocity[0] *= ratio;
                    tempVelocity[1] *= ratio;
                    tempVelocity[2] *= ratio;

                    velocities[vi]     = tempVelocity[0];
                    velocities[vi + 1] = tempVelocity[1];
                    velocities[vi + 2] = tempVelocity[2];
                }
            }

            positions[vi]     += tempVelocity[0];
            positions[vi + 1] += tempVelocity[1];
            positions[vi + 2] += tempVelocity[2];

            if (hasAges && ages[i] < lifetimes[i]) {
                ages[i] = min(ages[i] + delta, lifetimes[i]);
            }
        }

        for (j = 0, len = this.constraints.length; j < len; ++j) {
            this.constraints[j].constrain(this.activeParticlesBegin, this.numParticles, attributes);
        }

        var stopped = attributes.stopped;
        var dead = attributes.dead;
        for (i = this.activeParticlesBegin; i < this.numParticles; ++i) {
            if (dead[i]) {
                this.kill(i);
                --i;
            } else if (stopped[i]) {
                this.stop(i);
            }
        }
            

        this.geometry.setPositions(attributes.positions.subarray(0, this.numParticles * 3));
        if (attributes.colors) {
            this.geometry.setColors(attributes.colors.subarray(0, this.numParticles * 4));
        }

        if (this.numParticles > 0) {
            this.properties.setEnabled(true);
        } else {
            this.properties.setEnabled(false);
        }
        
        this.previousTime = time;
    };

    ParticleSystem.prototype.kill = function(i) {
        var attributes = this.attributes;
        var vi = i * 3;
        var ci = i * 4;
        var li = i;
        var vEnd = (this.numParticles - 1) * 3;
        var cEnd = (this.numParticles - 1) * 4;
        var lEnd = this.numParticles - 1;

        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var colors = attributes.colors;
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var paths = attributes.paths;
        var dead = attributes.dead;
        var stopped = attributes.stopped;
        var traps = attributes.traps;

        positions[vi] = positions[vEnd];
        positions[vi + 1] = positions[vEnd + 1];
        positions[vi + 2] = positions[vEnd + 2];

        velocities[vi] = velocities[vEnd];
        velocities[vi + 1] = velocities[vEnd + 1];
        velocities[vi + 2] = velocities[vEnd + 2];

        dead[li] = dead[lEnd];
        stopped[li] = stopped[lEnd];

        if (colors) {
            colors[ci] = colors[cEnd];
            colors[ci + 1] = colors[cEnd + 1];
            colors[ci + 2] = colors[cEnd + 2];
            colors[ci + 3] = colors[cEnd + 3];
        }
        
        if (lifetimes) {
            ages[li] = ages[lEnd];
            lifetimes[li] = lifetimes[lEnd];
        } 

        if (paths) {
            paths[li] = paths[lEnd];
        }

        if (traps) {
            traps[li] = traps[lEnd];
        }  

        this.numParticles--;
    };

    ParticleSystem.prototype.stop = function(i) {
        var attributes = this.attributes;
        var vi = i * 3;
        var ci = i * 4;
        var li = i;
        var vBegin = this.activeParticlesBegin * 3;
        var cBegin = this.activeParticlesBegin * 4;
        var lBegin = this.activeParticlesBegin;

        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var colors = attributes.colors;
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var paths = attributes.paths;
        var stopped = attributes.stopped;
        var traps = attributes.traps;

        tempPosition[0] = positions[vBegin];
        tempPosition[1] = positions[vBegin + 1];
        tempPosition[2] = positions[vBegin + 2];

        positions[vBegin]     = positions[vi]    ;
        positions[vBegin + 1] = positions[vi + 1];
        positions[vBegin + 2] = positions[vi + 2];

        positions[vi]     = tempPosition[0];
        positions[vi + 1] = tempPosition[1];
        positions[vi + 2] = tempPosition[2];

        tempVelocity[0] = velocities[vBegin];
        tempVelocity[1] = velocities[vBegin + 1];
        tempVelocity[2] = velocities[vBegin + 2];

        velocities[vBegin]     = velocities[vi]    ;
        velocities[vBegin + 1] = velocities[vi + 1];
        velocities[vBegin + 2] = velocities[vi + 2];

        velocities[vi]     = tempVelocity[0];
        velocities[vi + 1] = tempVelocity[1];
        velocities[vi + 2] = tempVelocity[2];

        if (colors) {
            tempColor[0] = colors[cBegin];
            tempColor[1] = colors[cBegin + 1];
            tempColor[2] = colors[cBegin + 2];
            tempColor[3] = colors[cBegin + 3];

            colors[cBegin]     = colors[ci];
            colors[cBegin + 1] = colors[ci + 1];
            colors[cBegin + 2] = colors[ci + 2];
            colors[cBegin + 3] = colors[ci + 3];

            colors[ci]     = tempColor[0];
            colors[ci + 1] = tempColor[1];
            colors[ci + 2] = tempColor[2];
            colors[ci + 3] = tempColor[3];
        }
        
        var tmp;
        if (lifetimes) {
            tmp = ages[lBegin];
            ages[lBegin] = ages[li];
            ages[li] = tmp;

            tmp = lifetimes[lBegin];
            lifetimes[lBegin] = lifetimes[li];
            lifetimes[li] = tmp;
        } 

        if (paths) {
            tmp = paths[lBegin];
            paths[lBegin] = paths[li];
            paths[li] = tmp;
        } 

        if (traps) {
            tmp = traps[lBegin];
            traps[lBegin] = traps[li];
            traps[li] = tmp;
        }  

        stopped[li] = false;

        this.activeParticlesBegin++;
    };

    ParticleSystem.prototype.reset = function() {
        this.numParticles = 0;
        this.activeParticlesBegin = 0;
    };

    ParticleSystem.prototype.enable = function() {
        this.properties.setEnabled(true);
        this.enabled = true;
    };

    ParticleSystem.prototype.disable = function() {
        this.properties.setEnabled(false);
        this.enabled = false;
    };

    ParticleSystem.prototype.destroy = function() {
        this.rootNode.destroy();
    };
})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var DirectionalVelocity = Human.particles.creators.DirectionalVelocity = function(options) {
        this.directionAverage = new Float32Array(options.directionAverage);
        this.directionVariance = options.directionVariance || 0;
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
    
        vec3.normalize(this.directionAverage, this.directionAverage);
    };

    DirectionalVelocity.prototype.create = function(begin, end, attributes) {
        
        var velocities = attributes.velocities;

        var rand = Math.random;
        var norm = vec3.normalize;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            var acceleration = this.forceAverage + rand() * 2 * this.forceVariance - this.forceVariance;

            direction[0] = this.directionAverage[0] + rand() * 2 * this.directionVariance - this.directionVariance;
            direction[1] = this.directionAverage[1] + rand() * 2 * this.directionVariance - this.directionVariance;
            direction[2] = this.directionAverage[2] + rand() * 2 * this.directionVariance - this.directionVariance;

            norm(direction, direction);

            velocities[vi]     = direction[0] * acceleration;
            velocities[vi + 1] = direction[1] * acceleration;
            velocities[vi + 2] = direction[2] * acceleration;
        }
        
    };

})();
;(function() {
    "use strict";

    var Lifetime = Human.particles.creators.Lifetime = function(options) {
        this.average = options.average;
        this.variance = options.variance || 0;
    };

    Lifetime.prototype.create = function(begin, end, attributes) {
        
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;

        var rand = Math.random;

        for (var i = begin; i < end; ++i) {
            ages[i] = 0;
            lifetimes[i] = this.average;
            if (this.variance > 0) {
                lifetimes[i] += rand() * 2 * this.variance - this.variance;
            } 
        }
        
    };

})();
;(function() {
    "use strict";

    var PointPosition = Human.particles.creators.PointPosition = function(options) {
        this.position = new Float32Array(options.position);
    };

    PointPosition.prototype.create = function(begin, end, attributes) {
        
        var positions = attributes.positions;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            positions[vi]     = this.position[0];
            positions[vi + 1] = this.position[1];
            positions[vi + 2] = this.position[2];
        }
        
    };

})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var RandomVelocity = Human.particles.creators.RandomVelocity = function(options) {
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
    };

    RandomVelocity.prototype.create = function(begin, end, attributes) {
        
        var velocities = attributes.velocities;

        var rand = Math.random;
        var norm = vec3.normalize;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            var acceleration = this.forceAverage;

            if (this.forceVariance > 0) {
                acceleration += rand() * 2 * this.forceVariance - this.forceVariance;
            }

            direction[0] = rand() * 2 - 1;
            direction[1] = rand() * 2 - 1;
            direction[2] = rand() * 2 - 1;

            norm(direction, direction);

            velocities[vi]     = direction[0] * acceleration;
            velocities[vi + 1] = direction[1] * acceleration;
            velocities[vi + 2] = direction[2] * acceleration;
        }
        
    };

})();
;(function() {
    "use strict";

    var position = vec3.create();

    var SpherePosition = Human.particles.creators.SpherePosition = function(options) {
        this.translate = null;
        this.xform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();

            Human.math.buildRotationScaleMat3(this.xform, options.rotate, options.scale);
        }
    };

    SpherePosition.prototype.create = function(begin, end, attributes) {

        var positions = attributes.positions;

        var rand = Math.random;
        var PI = Math.PI;
        var sin = Math.sin;
        var cos = Math.cos;
        
        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            var phi = rand() * PI;
            var theta = rand() * PI * 2;

            var r = rand();

            position[0] = r * sin(phi) * sin(theta);
            position[1] = r * cos(phi);
            position[2] = r * sin(phi) * cos(theta);

            if (this.xform) {
                vec3.transformMat3(position, position, this.xform);
            }

            if (this.translate) {
                position[0] += this.translate[0];
                position[1] += this.translate[1];
                position[2] += this.translate[2];
            }

            positions[vi]     = position[0];
            positions[vi + 1] = position[1];
            positions[vi + 2] = position[2];
        }
        
    };

})();
;(function() {
    "use strict";

    var position = vec3.create();

    var CubePosition = Human.particles.creators.CubePosition = function(options) {
        this.translate = null;
        this.xform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();

            Human.math.buildRotationScaleMat3(this.xform, options.rotate, options.scale);
        }
    };

    CubePosition.prototype.create = function(begin, end, attributes) {

        var positions = attributes.positions;
        
        var rand = Math.random;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            position[0] = rand() - 0.5;
            position[1] = rand() - 0.5;
            position[2] = rand() - 0.5;

            if (this.xform) {
                vec3.transformMat3(position, position, this.xform);
            }

            if (this.translate) {
                position[0] += this.translate[0];
                position[1] += this.translate[1];
                position[2] += this.translate[2];
            }

            positions[vi]     = position[0];
            positions[vi + 1] = position[1];
            positions[vi + 2] = position[2];
        }
        
    };

})();
;(function() {
    "use strict";

    var position = vec3.create();

    var CylinderPosition = Human.particles.creators.CylinderPosition = function(options) {
        this.translate = null;
        this.xform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();

            Human.math.buildRotationScaleMat3(this.xform, options.rotate, options.scale);
        }
    };

    CylinderPosition.prototype.create = function(begin, end, attributes) {

        var positions = attributes.positions;

        var rand = Math.random;
        var PI = Math.PI;
        var sin = Math.sin;
        var cos = Math.cos;
        
        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            var theta = rand() * PI * 2;
            var r = rand();
            var y = rand() * 2 - 1;

            position[0] = r * cos(theta);
            position[1] = y;
            position[2] = r * sin(theta);

            if (this.xform) {
                vec3.transformMat3(position, position, this.xform);
            }

            if (this.translate) {
                position[0] += this.translate[0];
                position[1] += this.translate[1];
                position[2] += this.translate[2];
            }

            positions[vi]     = position[0];
            positions[vi + 1] = position[1];
            positions[vi + 2] = position[2];
        }
        
    };

})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var BrownianMotion = Human.particles.updaters.BrownianMotion = function(options) {
        this.frequency = options.frequency;
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
        this.shape = null;
        this.shapeDirection = "in";
    };

    BrownianMotion.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var rand = Math.random;
        var norm = vec3.normalize;
        var hasShape = !!this.shape;

        var frequency = this.frequency * delta;
        var forceAverage = this.forceAverage * delta;
        var forceVariance = this.forceVariance * delta;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            if (rand() < frequency) {
                var vi = i * 3;

                var acceleration = forceAverage;

                if (forceVariance > 0) {
                    acceleration += rand() * 2 * forceVariance - forceVariance;
                }

                direction[0] = rand() * 2 - 1;
                direction[1] = rand() * 2 - 1;
                direction[2] = rand() * 2 - 1;

                norm(direction, direction);

                velocities[vi]     += direction[0] * acceleration;
                velocities[vi + 1] += direction[1] * acceleration;
                velocities[vi + 2] += direction[2] * acceleration;
            }
        }
        
    };

})();
;(function() {
    "use strict";

    var Friction = Human.particles.updaters.Friction = function(options) {
        this.friction = 1 - options.friction;
        this.shape = null;
        this.shapeDirection = "in";
    };

    Friction.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var hasShape = !!this.shape;

        var friction = Math.pow(this.friction, delta);

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var vi = i * 3;

            velocities[vi] *= friction;
            velocities[vi + 1] *= friction;
            velocities[vi + 2] *= friction;
        }
        
    };

})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var UniformForce = Human.particles.updaters.UniformForce = function(options) {
        this.directionAverage = new Float32Array(options.directionAverage);
        this.directionVariance = options.directionVariance || 0;
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
        this.shape = null;
        this.shapeDirection = "in";
    
        vec3.normalize(this.directionAverage, this.directionAverage);
    };

    UniformForce.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var rand = Math.random;
        var norm = vec3.normalize;
        var hasShape = !!this.shape;

        var forceAverage = this.forceAverage * delta;
        var forceVariance = this.forceVariance * delta;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var vi = i * 3;

            var acceleration = forceAverage;

            if (forceVariance > 0) {
                acceleration += rand() * 2 * forceVariance - forceVariance;
            }

            direction[0] = this.directionAverage[0];
            direction[1] = this.directionAverage[1];
            direction[2] = this.directionAverage[2];

            if (this.directionVariance) {
                direction[0] += rand() * 2 * this.directionVariance - this.directionVariance;
                direction[1] += rand() * 2 * this.directionVariance - this.directionVariance;
                direction[2] += rand() * 2 * this.directionVariance - this.directionVariance;
            
                norm(direction, direction);
            }

            velocities[vi]     += direction[0] * acceleration;
            velocities[vi + 1] += direction[1] * acceleration;
            velocities[vi + 2] += direction[2] * acceleration;
        }
    };

})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var RadialForce = Human.particles.updaters.RadialForce = function(options) {
        this.position = new Float32Array(options.position);
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
        this.shape = null;
        this.shapeDirection = "in";
    };

    RadialForce.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var rand = Math.random;
        var norm = vec3.normalize;
        var hasShape = !!this.shape;

        var forceAverage = this.forceAverage * delta;
        var forceVariance = this.forceVariance * delta;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var vi = i * 3;
            var acceleration = forceAverage;

            if (forceVariance) {
                acceleration += rand() * 2 * forceVariance - forceVariance;
            }

            direction[0] = positions[vi]     - this.position[0];
            direction[1] = positions[vi + 1] - this.position[1];
            direction[2] = positions[vi + 2] - this.position[2];

            norm(direction, direction);

            velocities[vi]     += direction[0] * acceleration;
            velocities[vi + 1] += direction[1] * acceleration;
            velocities[vi + 2] += direction[2] * acceleration;
        }
    };

})();
;(function() {
    "use strict";

    var AgeColorBlend = Human.particles.updaters.AgeColorBlend = function(options) {
        this.colors = options.colors;

        for (var i = 0, len = this.colors.length; i < len; ++i) {
            this.colors[i] = new Uint8Array(this.colors[i]);
        }
        
        this.shape = null;
        this.shapeDirection = "in";
    };

    AgeColorBlend.prototype.update = function(begin, end, attributes) {
        
        var positions = attributes.positions;
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var colors = attributes.colors;
        var hasShape = !!this.shape;
        var numIntervals = this.colors.length - 1;

        var floor = Math.floor;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var ci = i * 4;
            var index = (ages[i] / lifetimes[i]) * numIntervals;
            var idx1 = floor(index);
            var idx2 = idx1 + 1;

            var color1 = this.colors[idx1];
            var color2 = this.colors[idx2] || this.colors[idx1];

            var factor = index - idx1;
            var oneMinus = 1 - factor;
            colors[ci]     = oneMinus * color1[0] + factor * color2[0];
            colors[ci + 1] = oneMinus * color1[1] + factor * color2[1];
            colors[ci + 2] = oneMinus * color1[2] + factor * color2[2];
            colors[ci + 3] = oneMinus * color1[3] + factor * color2[3];
        }
        
    };

})();
;(function () {
    "use strict";

    var tempPosition = new Float32Array(3);
    var tempVelocity = new Float32Array(3);
    var tempVec3 = new Float32Array(3);


    var Path = Human.particles.updaters.Path = function Path() {
        this.nodes = [];
        this.shape = null;
        this.shapeDirection = "in";
    };

    Path.prototype.addNode = function(node) {
        
        node.first = this.nodes.length === 0;
        node.position = new Float32Array(node.position);
        node.forceVariance = node.forceVariance || 0;
        this.nodes.push(node);

        if (node.first) {
            node.vec = null;
            node.dir = null;
            node.length = null;
        } else {
            var prevNode = this.nodes[this.nodes.length - 2];
            node.vec = vec3.subtract(vec3.create(), node.position, prevNode.position);
            node.dir = vec3.normalize(vec3.create(), node.vec);
            node.length = vec3.length(node.vec);
        }  
    };

    Path.prototype.updateNode = function(i, nodeData) {
        var node = this.nodes[i];

        if (nodeData.position) {
            node.position = nodeData.position;

            if (!node.first) {
                var prevNode = this.nodes[i - 1];
                vec3.subtract(node.vec, node.position, prevNode.position);
                vec3.normalize(node.dir, node.vec);
                node.length = vec3.length(node.vec);
            }  

            if (i < this.nodes.length - 1) {
                var nextNode = this.nodes[i + 1];
                vec3.subtract(nextNode.vec, nextNode.position, node.position);
                vec3.normalize(nextNode.dir, nextNode.vec);
                nextNode.length = vec3.length(nextNode.vec);
            }
        }

        if (nodeData.radius) {
            node.radius = nodeData.radius;
        }

        if (nodeData.forceAverage) {
            node.forceAverage = nodeData.forceAverage;
        }
    };

    Path.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var paths = attributes.paths;
        var hasShape = !!this.shape;

        var rand = Math.random;
        var dist = vec3.distance;
        var norm = vec3.normalize;
        var sub = vec3.subtract;
        var dot = vec3.dot;
        var length = vec3.length;
        var scale = vec3.scale;

        var node;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            node = this.nodes[paths[i]];
            if (!node) {
                continue;
            }

            var vi = i * 3;

            tempPosition[0] = positions[vi];
            tempPosition[1] = positions[vi + 1];
            tempPosition[2] = positions[vi + 2];

            var pathDir;

            if (node.first) {
                if (dist(tempPosition, node.position) < node.radius) {
                    paths[i]++;
                    node = this.nodes[paths[i]];
                    if (!node) {
                        continue;
                    }
                }

                pathDir = sub(tempVec3, node.position, tempPosition);
                norm(pathDir, pathDir);
                
            } else {
                var prevNode = this.nodes[paths[i] - 1];
                var diff = sub(tempVec3, tempPosition, prevNode.position);
                var proj = dot(diff, node.dir);

                if (proj > node.length) {
                    paths[i]++;
                    node = this.nodes[paths[i]];
                    if (!node) {
                        continue;
                    }

                    tempVelocity[0] = velocities[vi];    
                    tempVelocity[1] = velocities[vi + 1];
                    tempVelocity[2] = velocities[vi + 2];

                    var speed = length(tempVelocity);
                    scale(tempVelocity, node.dir, speed);

                    velocities[vi]     = tempVelocity[0];
                    velocities[vi + 1] = tempVelocity[1];
                    velocities[vi + 2] = tempVelocity[2];
                }

                pathDir = node.dir;
            }

            var forceAverage = node.forceAverage * delta;
            var forceVariance = node.forceVariance * delta;

            var acceleration = forceAverage;

            if (forceVariance > 0) {
                acceleration += rand() * 2 * forceVariance - forceVariance;
            }

            velocities[vi]     += pathDir[0] * acceleration;
            velocities[vi + 1] += pathDir[1] * acceleration;
            velocities[vi + 2] += pathDir[2] * acceleration;

        }

    };
})();
;(function() {
    "use strict";

    var direction = new Float32Array(3);

    var Gravity = Human.particles.updaters.Gravity = function(options) {
        this.position = new Float32Array(options.position);
        this.radius = options.radius;
        this.forceAverage = options.forceAverage;
        this.forceVariance = options.forceVariance || 0;
        this.shape = null;
        this.shapeDirection = "in";
    };

    Gravity.prototype.update = function(begin, end, attributes, delta) {
        
        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var rand = Math.random;
        var max = Math.max;
        var length = vec3.length;
        var hasShape = !!this.shape;

        var forceAverage = this.forceAverage * delta;
        var forceVariance = this.forceVariance * delta;

        for (var i = begin; i < end; ++i) {

            if (hasShape && !this.shape[this.shapeDirection](positions, i)) {
                continue;
            }

            var vi = i * 3;
            var acceleration = forceAverage;

            if (forceVariance) {
                acceleration += rand() * 2 * forceVariance - forceVariance;
            }

            direction[0] = this.position[0] - positions[vi];
            direction[1] = this.position[1] - positions[vi + 1];
            direction[2] = this.position[2] - positions[vi + 2];

            var distance = max(length(direction), this.radius);

            direction[0] /= distance;
            direction[1] /= distance;
            direction[2] /= distance;

            acceleration /= distance * distance;

            velocities[vi]     += direction[0] * acceleration;
            velocities[vi + 1] += direction[1] * acceleration;
            velocities[vi + 2] += direction[2] * acceleration;
        }
    };

})();
;(function() {
    "use strict";

    var LifetimeKill = Human.particles.constraints.LifetimeKill = function() {
    };

    LifetimeKill.prototype.constrain = function(begin, end, attributes) {
        
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var dead = attributes.dead;

        for (var i = begin; i < end; ++i) {
            if (ages[i] >= lifetimes[i]) {
                dead[i] = true;
            }
        }
        
    };

})();;(function() {
    "use strict";

    var LifetimeStop = Human.particles.constraints.LifetimeStop = function() {
    };

    LifetimeStop.prototype.constrain = function(begin, end, attributes) {
        
        var ages = attributes.ages;
        var lifetimes = attributes.lifetimes;
        var stopped = attributes.stopped;

        for (var i = begin; i < end; ++i) {
            if (ages[i] >= lifetimes[i]) {
                stopped[i] = true;
            }
        }
        
    };

})();
;(function() {
    "use strict";

    var ShapeKill =  Human.particles.constraints.ShapeKill = function ShapeKill(shape, direction, trapId) {
        this.shape = shape;
        this.direction = direction;

        if (trapId >= 0) {
            this.trap = true;
            this.trapMask = 1 << trapId;
        } else {
            this.trap = false;
            this.trapMask = 0;
        }
    };

    ShapeKill.prototype.constrain = function(begin, end, attributes) {

        var positions = attributes.positions;
        var dead = attributes.dead;
        var traps = attributes.traps;
        
        var trap = this.trap;
        var mask = this.trapMask;
        
        for (var i = begin; i < end; ++i) {
            if (this.shape[this.direction](positions, i)) {
                if (trap && (traps[i] & mask) === 0) {
                    continue;
                }

                dead[i] = true;
            } else if (trap) {
                traps[i] |= mask;
            }
            
        }
    };

})();
;(function() {
    "use strict";

    var ShapeStop =  Human.particles.constraints.ShapeStop = function ShapeStop(shape, direction, trapId) {
        this.shape = shape;
        this.direction = direction;

        if (trapId >= 0) {
            this.trap = true;
            this.trapMask = 1 << trapId;
        } else {
            this.trap = false;
            this.trapMask = 0;
        }
    };

    ShapeStop.prototype.constrain = function(begin, end, attributes) {

        var positions = attributes.positions;
        var stopped = attributes.stopped;
        var traps = attributes.traps;

        var trap = this.trap;
        var mask = this.trapMask;
        
        for (var i = begin; i < end; ++i) {
            if (this.shape[this.direction](positions, i)) {
                if (trap && (traps[i] & mask) === 0) {
                    continue;
                }

                stopped[i] = true;
            } else if (trap) {
                traps[i] |= mask;
            }
            
        }
    };

})();
;(function() {
    "use strict";

    var tempPosition = new Float32Array(3);
    var tempVec3 = new Float32Array(3);
    var tempVec3b = new Float32Array(3);
    var tempVec3c = new Float32Array(3);
    var tempVec3d = new Float32Array(3);

    var PathRadius = Human.particles.constraints.PathRadius = function PathRadius(path) {
        this.nodes = path.nodes;
    };

    PathRadius.prototype.constrain = function(begin, end, attributes) {

        var positions = attributes.positions;
        var paths = attributes.paths;

        var norm = vec3.normalize;
        var sub = vec3.subtract;
        var dot = vec3.dot;
        var length = vec3.length;
        var scale = vec3.scale;

        for (var i = begin; i < end; ++i) {
            var vi = i * 3;

            if (paths[i] < 1) {
                continue;
            }

            var node = this.nodes[paths[i]];

            if (!node) {
                continue;
            }

            tempPosition[0] = positions[vi];
            tempPosition[1] = positions[vi + 1];
            tempPosition[2] = positions[vi + 2];

            var prevNode = this.nodes[paths[i] - 1];
            var diff = sub(tempVec3, tempPosition, prevNode.position);
            var proj = dot(diff, node.dir);

            var positionProj = scale(tempVec3b, node.dir, proj);
            var positionPerp = sub(tempVec3c, diff, positionProj);
            var dist = length(positionPerp);

            if (dist > node.radius) {
                norm(positionPerp, positionPerp);
                var correct = scale(tempVec3d, positionPerp, node.radius - dist);
                positions[vi]     += correct[0];
                positions[vi + 1] += correct[1];
                positions[vi + 2] += correct[2];
            }
        }        

    };
})();;(function() {
    "use strict";


    var PathKill = Human.particles.constraints.PathKill = function PathKill(path) {
        this.nodes = path.nodes;
    };

    PathKill.prototype.constrain = function(begin, end, attributes) {

        var numNodes = this.nodes.length;
        var paths = attributes.paths;
        var dead = attributes.dead;

        for (var i = begin; i < end; ++i) {
            if (paths[i] >= numNodes) {
                dead[i] = true;
            }
        }        

    };
})();;(function() {
    "use strict";


    var PathStop = Human.particles.constraints.PathStop = function PathStop(path) {
        this.nodes = path.nodes;
    };

    PathStop.prototype.constrain = function(begin, end, attributes) {

        var numNodes = this.nodes.length;
        var paths = attributes.paths;
        var stopped = attributes.stopped;

        for (var i = begin; i < end; ++i) {
            if (paths[i] >= numNodes) {
                stopped[i] = true;
            }
        }        

    };
})();;(function() {
    "use strict";

    var tempVelocity = new Float32Array(3);
    var tempVec3 = new Float32Array(3);
    var tempVec3b = new Float32Array(3);

    var surfacePosition = new Float32Array(3);
    var surfaceNormal = new Float32Array(3);

    var ShapeBounce =  Human.particles.constraints.ShapeBounce = function ShapeBounce(shape, direction, trapId) {
        this.shape = shape;
        this.direction = direction;

        if (trapId >= 0) {
            this.trap = true;
            this.trapMask = 1 << trapId;
        } else {
            this.trap = false;
            this.trapMask = 0;
        }
    };

    ShapeBounce.prototype.constrain = function(begin, end, attributes) {

        var positions = attributes.positions;
        var velocities = attributes.velocities;
        var traps = attributes.traps;

        var trap = this.trap;
        var mask = this.trapMask;

        var sub = vec3.subtract;
        var dot = vec3.dot;
        var length = vec3.length;
        var scale = vec3.scale;
        
        for (var i = begin; i < end; ++i) {
            if (this.shape[this.direction](positions, i)) {
                if (trap && (traps[i] & mask) === 0) {
                    continue;
                }

                var vi = i * 3;

                this.shape.surfaceProjection(positions, i, surfacePosition, surfaceNormal);
                positions.set(surfacePosition, vi);

                tempVelocity[0] = velocities[vi];
                tempVelocity[1] = velocities[vi + 1];
                tempVelocity[2] = velocities[vi + 2];

                var speed = length(tempVelocity);
                
                tempVelocity[0] /= speed;
                tempVelocity[1] /= speed;
                tempVelocity[2] /= speed;

                var dotN = dot(tempVelocity, surfaceNormal);
                var scaledN = scale(tempVec3, surfaceNormal, 2 * dotN);
                var reflect = sub(tempVec3b, tempVelocity, scaledN);
                scale(reflect, reflect, speed);

                velocities[vi]     = reflect[0]; 
                velocities[vi + 1] = reflect[1]; 
                velocities[vi + 2] = reflect[2];
            } else if (trap) {
                traps[i] |= mask;
            }
        }
    };

})();
;(function () {
    "use strict";

    var position = vec3.create();

    var Sphere = Human.particles.shapes.Sphere = function(options) {
        this.translate = null;
        this.xform = null;
        this.inverseXform = null;
        this.normalXform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();
            this.inverseXform = mat3.create();
            this.normalXform = mat3.create();

            Human.math.buildRotationScaleMat3(this.xform, options.rotate, options.scale);
            mat3.invert(this.inverseXform, this.xform);
            mat3.transpose(this.normalXform, this.inverseXform);
        }
    };

    Sphere.prototype.in = function(positions, i) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x * x + y * y + z * z <= 1;
    };

    Sphere.prototype.out = function(positions, i) {
        var vi = i * 3;
        
        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x * x + y * y + z * z >= 1;
    };

    Sphere.prototype.surfaceProjection = function(positions, i, position, normal) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }


        vec3.normalize(position, position);
        normal.set(position);

        if (this.xform) {
            vec3.transformMat3(position, position, this.xform);
            vec3.transformMat3(normal, normal, this.normalXform);
            vec3.normalize(normal, normal);
        }

        if (this.translate) {
            position[0] += this.translate[0];
            position[1] += this.translate[1];
            position[2] += this.translate[2];
        }
    };



})();
;(function () {
    "use strict";

    var tempPosition = new Float32Array(3);
    var perp = new Float32Array(3);
    var xform = mat3.create();

    var Plane = Human.particles.shapes.Plane = function(options) {
        var translate = options.translate || Human.math.VEC3_ZEROS;
        var rotate = options.rotate || Human.math.VEC3_ZEROS;

        this.normal = new Float32Array([0, 1, 0]);
        Human.math.buildRotationScaleMat3(xform, rotate, null);
        vec3.transformMat3(this.normal, this.normal, xform);

        this.distance = vec3.dot(translate, this.normal);
    };

    Plane.prototype.in = function(positions, i) {
        var vi = i * 3;

        var x = positions[vi];
        var y = positions[vi + 1];
        var z = positions[vi + 2];

        var nx = this.normal[0];
        var ny = this.normal[1];
        var nz = this.normal[2];

        return x * nx + y * ny + z * nz <= this.distance;
    };

    Plane.prototype.out = function(positions, i) {
        var vi = i * 3;

        var x = positions[vi];
        var y = positions[vi + 1];
        var z = positions[vi + 2];

        var nx = this.normal[0];
        var ny = this.normal[1];
        var nz = this.normal[2];

        return x * nx + y * ny + z * nz >= this.distance;
    };

    Plane.prototype.surfaceProjection = function(positions, i, position, normal) {
        var vi = i * 3;

        tempPosition[0] = positions[vi];
        tempPosition[1] = positions[vi + 1];
        tempPosition[2] = positions[vi + 2];

        normal[0] = this.normal[0];
        normal[1] = this.normal[1];
        normal[2] = this.normal[2];

        vec3.scale(perp, normal, this.distance - vec3.dot(tempPosition, normal));
        vec3.add(position, tempPosition, perp);
    };



})();
;(function () {
    "use strict";

    var position = vec3.create();

    var Cube = Human.particles.shapes.Cube = function(options) {
        this.translate = null;
        this.xform = null;
        this.inverseXform = null;
        this.normalXform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();
            this.inverseXform = mat3.create();
            this.normalXform = mat3.create();

            Human.math.buildRotationScaleMat3(this.xform, options.rotate, options.scale);
            mat3.invert(this.inverseXform, this.xform);
            mat3.transpose(this.normalXform, this.inverseXform);
        }
    };

    Cube.prototype.in = function(positions, i) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x >= -0.5 && x <= 0.5 && 
               y >= -0.5 && y <= 0.5 && 
               z >= -0.5 && z <= 0.5;
    };

    Cube.prototype.out = function(positions, i) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x <= -0.5 || x >= 0.5 || 
               y <= -0.5 || y >= 0.5 || 
               z <= -0.5 || z >= 0.5;
    };

    Cube.prototype.surfaceProjection = function(positions, i, position, normal) {
        var vi = i * 3;
        var abs = Math.abs;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        var left = abs(x + 0.5);
        var right = abs(x - 0.5);
        var bottom = abs(y + 0.5);
        var top = abs(y - 0.5);
        var back = abs(z + 0.5);
        var front = abs(z - 0.5);

        if (left < right && left < bottom && left < top && left < back && left < front) {
            x = -0.5;

            normal[0] = -1;
            normal[1] = 0;
            normal[2] = 0;
        } else if (right < bottom && right < top && right < back && right < front) {
            x = 0.5;

            normal[0] = 1;
            normal[1] = 0;
            normal[2] = 0;
        } else if (bottom < top && bottom < back && bottom < front) {
            y = -0.5;
            
            normal[0] = 0;
            normal[1] = -1;
            normal[2] = 0;
        } else if (top < back && top < front) {
            y = 0.5;

            normal[0] = 0;
            normal[1] = 1;
            normal[2] = 0;
        } else if (back < front) {
            z = -0.5;
            
            normal[0] = 0;
            normal[1] = 0;
            normal[2] = -1;
        } else {
            z = 0.5;

            normal[0] = 0;
            normal[1] = 0;
            normal[2] = 1;
        }
        
        if (x < -0.5) {
            x = -0.5;
        } else if (x > 0.5) {
            x = 0.5;
        }

        if (y < -0.5) {
            y = -0.5;
        } else if (y > 0.5) {
            y = 0.5;
        }

        if (z < -0.5) {
            z = -0.5;
        } else if (z > 0.5) {
            z = 0.5;
        }

        position[0] = x;
        position[1] = y;
        position[2] = z;

        if (this.xform) {
            vec3.transformMat3(position, position, this.xform);
            vec3.transformMat3(normal, normal, this.normalXform);
            vec3.normalize(normal, normal);
        }

        if (this.translate) {
            position[0] += this.translate[0];
            position[1] += this.translate[1];
            position[2] += this.translate[2];
        }
    };



})();
;(function () {
    "use strict";

    var position = vec3.create();

    var Cylinder = Human.particles.shapes.Cylinder = function(options) {
        this.translate = null;
        this.xform = null;
        this.inverseXform = null;
        this.normalXform = null;

        if (options.translate) {
            this.translate = new Float32Array(options.translate);
        }

        if (options.scale || options.rotate) {
            this.xform = mat3.create();
            this.inverseXform = mat3.create();
            this.normalXform = mat3.create();

            Human.math.buildRotationScaleMat3(this.xform, options.rotate, options.scale);
            mat3.invert(this.inverseXform, this.xform);
            mat3.transpose(this.normalXform, this.inverseXform);
        }
    };

    Cylinder.prototype.in = function(positions, i) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x * x + z * z <= 1 && y >= -1 && y <= 1;
    };

    Cylinder.prototype.out = function(positions, i) {
        var vi = i * 3;
        
        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];

        return x * x + z * z >= 1 || y <= -1 || y >= 1;
    };

    Cylinder.prototype.surfaceProjection = function(positions, i, position, normal) {
        var vi = i * 3;

        position[0] = positions[vi];
        position[1] = positions[vi + 1];
        position[2] = positions[vi + 2];

        if (this.translate) {
            position[0] -= this.translate[0];
            position[1] -= this.translate[1];
            position[2] -= this.translate[2];
        }

        if (this.inverseXform) {
            vec3.transformMat3(position, position, this.inverseXform);
        }

        var x = position[0];
        var y = position[1];
        var z = position[2];
        var r, r2;

        if (y < -1) {
            normal[0] = 0;
            normal[1] = -1;
            normal[2] = 0;
        } else if (y > 1) {
            normal[0] = 0;
            normal[1] = 1;
            normal[2] = 0;
        } else {
            r2 = x * x + z * z;
            r = Math.sqrt(r2);
            normal[0] = x / r;
            normal[1] = 0;
            normal[2] = z / r;
            
        }

        if (y < -1) {
            y = -1;
        }

        if (y > 1) {
            y = 1;
        }

        r2 = r2 || (x * x + z * z);
        if (r2 > 1) {
            r = r || Math.sqrt(r);
            x /= r;
            z /= r;
        }

        position[0] = x;
        position[1] = y;
        position[2] = z;

        if (this.xform) {
            vec3.transformMat3(position, position, this.xform);
            vec3.transformMat3(normal, normal, this.normalXform);
            vec3.normalize(normal, normal);
        }

        if (this.translate) {
            position[0] += this.translate[0];
            position[1] += this.translate[1];
            position[2] += this.translate[2];
        }
    };



})();
;/**
 * @namespace Engine media (videos, audio etc).
 */
Human.media = Human.media || {};;/**
 * @namespace Generic container for streaming media clips
 *
 * NOTE: Clips are now registered by the chapter that wants to play clips.
 * Clip data is still stored with the state folder, but the chapter publishes the clip by id
 *
 */
Human.media.Clips = function (streamType) {
    "use strict";

    var self = this;

    this._streamType = streamType;

    /** Clips mapped to IDs
     */
    this.clips = {};

    /** Clips ordered by their timeline times
     *
     * @type {Array}
     */
    this.clipsList = [];

    /** Clips grouped into libraries
     */
    this.libraries = {};

    /**
     * IDs of clips that are currently "suggested", where those clips have time1 and time2 properties
     * that interesect the current timeline scrubber.
     * @type {Array}
     */
    this.suggestedClips = [];

    Human.events.fire(this._streamType + ".clips", self.clipsList, true);

    //get clip by id
    self.getClipById = function(clipid){
      var result = null;
      this.clipsList.forEach(function(clip){
        if (clip.clipId === clipid){
          result = clip;
        }
      });
      return result;
    };

    /**
     * Creates a clips library
     * NOTE: from state folder
     *
     * @param {String} libraryId Unique library ID
     * @param {[{}]} clips Clips within the library
     */
    this.createLibrary = function (libraryId, clips) {

        if (this.libraries[libraryId]) {

            // Tolerate reload of same library
            Human.log.warn("Human.media." + this._streamType + ".createLibrary", "Library already loaded: " + libraryId);
            return;
        }

        var parts = libraryId.split("/");
        var modelId = parts[0];
        var subasset = parts[1];

        var library = this.libraries[libraryId] = {
            libraryId: libraryId,
            clips: {}
        };

        var p;
        var clip;

        // Create clips
        for (var i = 0, len = clips.length; i < len; i++) {
            p = clips[i];

            // Validate each clip
            if (!p.clipId) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: clipId");
                continue;
            }
            // if (!p.displayName) {
            //     Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: displayName");
            //     continue;
            // }
            if (!p.type) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: type");
                continue;
            }
            if (!p.src) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: src");
                continue;
            }
            if (p.time1 === undefined || p.time1 === null) {
                //Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: time1 - defaulting to 0 seconds");
                p.time1 = null;
            }
            if (p.time2 === undefined || p.time2 === null) {
                //Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: time2 - defaulting to 0 seconds");
                p.time2 = null;
            }
            if (this.clips[p.clipId]) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip 'clipId' clashes with another clip: '" + p.clipId + "' - replacing existing clip");
            }

            var fullURL = [modelId, this._streamType, subasset, p.src].join("/");

            clip = {
                clipId: p.clipId,
                modelId: modelId,
                streamType: this._streamType,
                subasset: subasset,
                displayName: p.displayName,
                description: p.description || "",
                time1: p.time1,
                time2: p.time2,
                type: p.type || "",
                src: p.src,
                fullUrl: fullURL,
                alternatives: p.alternatives || [],
                length: p.length || 0,
                suggested: false,
                status: "closed"
            };

            // Register clip against library
            library.clips[p.clipId] = clip;

            // Add clip to ID map
            this.clips[p.clipId] = clip;
        }

        // Rebuild time-ordered clip list from ID map
        this._rebuildClipList();
    };

    /** Rebuilds time-ordered clip list and exports it via event
     * @private
     */
    this._rebuildClipList = function () {
        this.clipsList = [];
        for (var clipId in this.clips) {
            if (this.clips.hasOwnProperty(clipId)) {
                this._insertClipIntoList(this.clipsList, this.clips[clipId]);
            }
        }
        // Publish new clip list
        Human.events.fire(this._streamType + ".clips", this.clipsList, true);
    };

    /**
     * Inserts a clip into list of clips ordered by time
     * @private
     */
    this._insertClipIntoList = function (list, clip) {
        if (list.length === 0) {
            // First clip in list
            list.push(clip);
        } else {
            // Find place and insert
            var v;
            for (var j = list.length - 1; j >= 0; j--) {
                v = list[j];
                if (v.time1 < clip.time1) {
                    list.splice(j + 1, 0, clip);
                    return;
                }
            }
            // Clip is earliest - insert at front of list
            list.splice(0, 0, clip);
        }
    };

    /**
     * Destroys a clips library
     * @param libraryId
     */
    this.destroyLibrary = function (libraryId) {
        var lib = this.libraries[libraryId];
        if (!lib) {
            // Tolerate missing library
            Human.log.warn("Human.media." + this._streamType + ".destroyLibrary", "Library not found: " + libraryId);
            return;
        }
        for (var clipId in lib.clips) {
            if (lib.clips.hasOwnProperty(clipId)) {
                delete this.clips[clipId];
                Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "destroyed" });
            }
        }
        delete this.libraries[libraryId];

        // Rebuild time-ordered clip list from remaining clips in ID map
        this._rebuildClipList();
    };

    /**
     * Opens a clip
     * @param clipId
     */
    this.open = function (clipId, ok) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "open" }, true);
        ok();
    };

    /**
     * Plays a clip
     * @param clipId
     */
    this.play = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "playing" }, true);
    };

    /**
     * Scrubs a clip to the given time
     * @param clipId
     * @param time
     */
    this.scrub = function (clipId, time) {
        Human.events.fire(this._streamType + ".scrubbed", { clipId: clipId, time: time });
    };

    /**
     * Pauses a clip
     * @param clipId
     */
    this.pause = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "paused" }, true);
    };

    /**
     * Stops a clip
     * @param clipId
     */
    this.stop = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "stopped" }, true);
    };

    /**
     * Closes a clip
     * @param clipId
     */
    this.close = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "closed" }, true);
    };

    /**
     * Destroys all clip libraries
     */
    this.reset = function () {
        for (var libraryId in this.libraries) {
            if (this.libraries.hasOwnProperty(libraryId)) {
                this.destroyLibrary(libraryId);
            }
        }
    };
};
;/**
 * @namespace Audio clips
 */
Human.media.audio= new Human.media.Clips("audio");;/**
 * @namespace Video clips
 */
Human.media.videos = new Human.media.Clips("videos");;
(function () {
    "use strict";

    var HumanActions = Human.actions = {};
    
    HumanActions._actions = {};

    Human.events.on("loaded",
        function () {

            // Alternative entry point for Human.actions._doAction via data-human-action attribute

            $(document).on('click', '[data-human-action]', function () {
                var $el = $(this);
                var action = $el.attr('data-human-action');
                var args = $el.attr('data-arguments');

                if (action) {
                    HumanActions._doAction([action, args]);
                }
            });
        });
    
    /** Registers an action handler.
     *
     * @param actionId
     * @param callback
     */
    HumanActions.addAction = function (actionId, callback) {
        HumanActions._actions[actionId] = callback;
    };

    /** Fires an action handler
     *
     * @param actionStr
     * @private
     */
    HumanActions._doAction = function (data) {
        var tokens;
        
        if(typeof data === 'string') {
            tokens = data.split("?");
            
            if (tokens.length === 0) {
                Human.log.error("Human.actions._parse", "Parsed invalid action link: " + data + "(ignoring)");
                return;
            }
        } else {
            tokens = data;
        }

        var actionId = tokens[0];

        var action = HumanActions._actions[actionId];

        if (!action) {
            Human.log.error("Human.actions._doAction", "Parsed invalid action link - action not found: " + actionId + " (ignoring)");
            return;
        }

        var actionParams = {};

        // Parse params
        var p = tokens[1];
        if (p) {
            var keyVals = p.split("&");
            var keyVal;
            for (var i = 0, len = keyVals.length; i < len; i++) {
                keyVal = keyVals[i].split("=");
                actionParams[keyVal[0]] = keyVal[1];
            }
        }

        // When action callbacks fail, they can just throw exceptions rather than go to the trouble
        // of logging and recovering. Then we can nicely log those in context of the action and recover.
        try {
            action(actionParams);
        } catch (e) {
            Human.log.error("Human.actions._doAction", "Action '" + actionId + "' threw an exception: " + e);
        }
    };

    /** Parses markdown into HREFs that fire action handlers that were registered with {@link #addAction}.
     *
     * @param markdown
     * @returns {*}
     */
    HumanActions.parse = function (markdown) {
        return markdown.replace(/\[\[([^|]*?)\|(.*?)\]\]/g, '<a href="javascript:Human.actions._doAction(\'$1\')">$2</a>');
    };

})();;/**
 * @namespace Engine asset libraries.
 * @private
 */

(function() {
    "use strict";

    var assets = Human.assets = {
        loadedAssets: {},
        nullAssets: {}
    };

    // Defaults to adding an "s" to type
    var ASSET_MODULES = {
        geometry: "geometries",
        audio: "audio",
        videos: "video"
    };

    var assetUseCounts = {};
    var libUseCounts = {};
    var libModules = {}; // For each library remembers the module that loaded it, so the module can unload again
    var nullLibs = {};

    var assetCallbacks = {};

    var requestedAssets = 0;
    var receivedAssets = 0;

    assets.getAsset = function (assetId, type, ok) {
        if (assets.nullAssets[assetId]) {

            if (ok) {
                Human.utils.async(function () {
                    ok(null);
                });
            }

            return;
        }

        if (assets.loadedAssets[assetId] === "LOADING") {

            if (ok) {
                assetCallbacks[assetId].push(ok);
            }

            return;
        }

        if (assets.loadedAssets[assetId]) {

            assetAcquired(assetId);

            if (ok) {
                Human.utils.async(function () {
                    ok(assets.loadedAssets[assetId]);
                });
            }

            return;
        }

        if (requestedAssets === 0) {
            assetLoadStart();
        }

        requestedAssets++;

        assets.loadedAssets[assetId] = "LOADING";
        assetCallbacks[assetId] = [];

        if (ok) {
            assetCallbacks[assetId].push(ok);
        }

        assets.server.getAsset(type, assetId, function (asset) {
            assetLoadProgress(assetId, type);

            if (!asset || asset === assets.server.TIMEOUT) {

                if (!asset) {
                    assets.nullAssets[assetId] = true;
                } else {

                }

                assets.loadedAssets[assetId] = null;

                var callbacks = assetCallbacks[assetId];

                for (var i = 0, len = callbacks.length; i < len; i++) {
                    callbacks[i](null);
                }

                delete assetCallbacks[assetId];

                return;

            }

            var module = Human.assets[getModuleName(type)];

            try {

                module.parseAsset(assetId, asset, function(asset) {
                    assets.loadedAssets[assetId] = asset;
                    assetAcquired(assetId);

                    var callbacks = assetCallbacks[assetId];

                    for (var i = 0, len = callbacks.length; i < len; i++) {
                        callbacks[i](asset);
                    }

                    delete assetCallbacks[assetId];
                });
            } catch (e) {
                Human.log.error("Error parsing asset: " + assetId + " - " + e.message);
                assets.loadedAssets[assetId] = null;
                assets.nullAssets[assetId] = true;

                var callbacks = assetCallbacks[assetId];

                for (var i = 0, len = callbacks.length; i < len; i++) {
                    callbacks[i](null);
                }

                delete assetCallbacks[assetId];
            }
        });
    };

    function assetLoadStart() {
        Human.events.fire("assets.load.start");
        Human.stats.loadSequence.assetsRequested = Human.timer.now();
        Human.stats.loadTimes.preAsset = Human.stats.loadSequence.assetsRequested - Human.stats.loadSequence.startTime;
    }

    function assetLoadProgress(assetId, type) {
        receivedAssets++;

        Human.events.fire("assets.load.progress", {
            assetId: assetId,
            assetType: type,
            requestedAssets: requestedAssets,
            receivedAssets: receivedAssets
        });

        if(receivedAssets === requestedAssets) {
            assetLoadFinish();
        }
    }

    function assetLoadFinish() {
        Human.events.fire("assets.load.finish");

        requestedAssets = 0;
        receivedAssets = 0;

        Human.stats.loadSequence.assetsLoaded = Human.timer.now();
        Human.stats.loadTimes.assetDownload = Human.stats.loadSequence.assetsLoaded - Human.stats.loadSequence.assetsRequested;
    }

    assets.getAssetLibrary = function (type, dir, libId, fileName, params, ok) {

        if (nullLibs[libId]) {
            Human.utils.async(ok);
            return;
        }

        if (libUseCounts[libId]) {

            libAcquired(libId);
            Human.utils.async(ok);

            return;
        }

        assets.server.getAssetLibrary(dir, libId, fileName, function(data) {
            var module;

            if (!data) {
                nullLibs[libId] = true;

                if (ok) {
                    ok();
                }

                return;
            }


            if (libUseCounts[libId]) {

                libAcquired(libId);

                if (ok) {
                    ok();
                }
                return;
            }

            if (type === "animation") {
                if (data.format === "binary") {
                    if (ok) {
                        ok();
                    }
                    return;
                }
                module = Human.assets.tweens;
            } else {
                module = Human.assets[getModuleName(type)];
            }


            if (module) {
                // TODO: Do we need a semaphore to prevent concurrent asynch load of same library?

                module.parseLibrary(libId, data, params, function() {

                    libAcquired(libId);

                    libModules[libId] = module;

                    if (ok) {
                        ok();
                    }
                });

            } else {
                Human.log.error("Unknown asset library type: " + type);
                if (ok) {
                    ok();
                }
            }
        });
    };

    /**
     * Release an asset library that was acquired previously by #getAssetLibrary.
     * Deletes the lib when its use count count has then become zero.
     * Assumes that the library has completely loaded; don't call this while library is still loading.
     *
     * @param {String} libId ID of the asset library to release.
     */
    assets.putAssetLibrary = function(libId) {

        if (libUseCounts[libId] === undefined) { // Not currently loaded
            return;
        }

        if (--libUseCounts[libId] <= 0) {

            // Last reference released, destroy lib and use count

            delete assetUseCounts[libId];

            // Delegate asset unloading to module

            var module = libModules[libId];

            if (module && module.unloadLibrary) {
                module.unloadLibrary(libId);
            }

            delete libModules[libId];
        }
    };

    /**
     * Release an assets that was acquired previously by #getAsset.
     *
     * Deletes the asset when its use count count has then become zero.
     *
     * @param {String} assetId ID of the asset to release.
     */
    assets.putAsset = function (assetId) {

        if (assetUseCounts[assetId] === undefined) {
            return;
        }

        if (--assetUseCounts[assetId] <= 0) {

            // Last reference released, destroy asset and use count
            var asset = assets.loadedAssets[assetId];
            var module = Human.assets[getModuleName(asset.type)];
            module.destroyAsset(assetId);

            delete assets.loadedAssets[assetId];
            delete assetUseCounts[assetId];
        }
    };

    // Indicates that an asset library has been acquired, incrementing its use count.
    //
    function libAcquired(libId) {
        if (libUseCounts[libId] === undefined) {
            libUseCounts[libId] = 1;
            return;
        }
        libUseCounts[libId]++;
    }

    // Indicates that an asset has been acquired, incrementing its use count.
    //
    function assetAcquired(assetId) {
        if (assetUseCounts[assetId] === undefined) {
            assetUseCounts[assetId] = 1;
            return;
        }
        assetUseCounts[assetId]++;
    }

    function getModuleName(type) {
        return ASSET_MODULES[type] || type + "s";
    }

})();
;(function() {
    "use strict";

    var assetServer = Human.assets.server = {
        TIMEOUT: 1
    };

    var COMPRESSED_ASSETS = true;

    var TIMEOUT = 120000; //ms

    // Callbacks to be run when the socket opens.
    var openCallbacks = [];

    // Callbacks to be run when a message is received.
    // Organized by asset ID.
    var messageCallbacks = {};

    var requestQueue = [];

    // Defaults to adding an "s" to type
    var URL_BASE = {
        geometry: "geometry"
    };

    var moduleDefinitions = {};
    var stateIndexes = {};

    var lastNetworkTime;

    var assetDomain;
    var socket;
    var socketURL;

    var assetServerInitialized = false;

    Human.properties.subscribe({
        propId: "assetDomain",
        value: "assets-human.biodigital.com",
        callback: function (value) {
            assetDomain = value;
        }
    });

    assetServer.init = function () {
        if(assetServerInitialized) {
            return;
        }

        var socketProtocol = window.location.protocol === "https:" ? "wss:" : "ws:";

        socketURL = socketProtocol + "//" + assetDomain + "/assets/ws" + (COMPRESSED_ASSETS ? 3 : 2);

        socket = createSocket();

        setInterval(function() {

            socketSend();

            var now = Date.now();

            if (now - lastNetworkTime > TIMEOUT) {
                for (var assetId in messageCallbacks) {
                    if (messageCallbacks.hasOwnProperty(assetId)) {
                        Human.log.error("Server timeout on asset: " + assetId);
                        var callbacks = messageCallbacks[assetId];

                        for (var i = 0, len = callbacks.length; i < len; i++) {
                            callbacks[i](assetServer.TIMEOUT);
                        }
                        delete messageCallbacks[assetId];
                    }
                }
            }

        }, 100);

        assetServerInitialized = true;
    };

    assetServer.cacheModuleDefinition = function(moduleId, moduleDefinition) {
        if (moduleDefinitions[moduleId]) {
            return;
        }

        if (moduleDefinition) {
            moduleDefinitions[moduleId] = JSON.stringify(moduleDefinition);
            return;
        }

        assetServer.getModuleDefinition(moduleId);
    };

    assetServer.getModuleDefinition = function (moduleName, ok, error) {
        if (moduleDefinitions[moduleName]) {
            if (ok) {
                ok(JSON.parse(moduleDefinitions[moduleName]));
            }
            return;
        }

        Human.stats.loadSequence.moduleRequest = Human.timer.now();
        Human.stats.loadTimes.preModule = Human.stats.loadSequence.moduleRequest - Human.stats.loadSequence.startTime;

        $.ajax({
            dataType: "text",
            url: "/content/modules/" + moduleName,
            success: function (moduleDefinition) {
                jsonDownloadSize(moduleName, moduleDefinition);

                moduleDefinitions[moduleName] = moduleDefinition;

                Human.stats.loadSequence.moduleLoaded = Human.timer.now();
                Human.stats.loadTimes.moduleDownload = Human.stats.loadSequence.moduleLoaded - Human.stats.loadSequence.moduleRequest;

                if (ok) {
                    ok(JSON.parse(moduleDefinition));
                }
            },
            error: function (xhr, textStatus, errorThrown) {
                Human.events.fire("net.error", {
                    id: moduleName,
                    type: "modules",
                    status: xhr.status,
                    statusText: xhr.statusText
                });

                if (error) {
                    error(errorThrown);
                }
            }
        });
    };

    assetServer.cacheStateIndex = function(stateId, index) {
        if (stateIndexes[stateId]) {
            return;
        }

        if (index) {
            stateIndexes[stateId] = JSON.stringify(index);
            return;
        }

        $.ajax({
            dataType: "text",
            url: "/content/states/" + stateId + "/index?v=" + Human.VERSION + "&locale=" + Human.locale,
            success: function (index) {
                jsonDownloadSize(stateId + "/index", index);
                stateIndexes[stateId] = index;
            }
        });
    };

    assetServer.getStateIndex = function(stateId, ok, error) {
        if (stateIndexes[stateId]) {
            if (ok) {
                ok(JSON.parse(stateIndexes[stateId]));
            }
            return;
        }

        $.ajax({
            dataType: "text",
            url: "/content/states/" + stateId + "/index?v=" + Human.VERSION + "&locale=" + Human.locale,
            // NOTE: state index not cached here because it caused GC issues in Chrome.
            success: function(index) {
                jsonDownloadSize(stateId + "/index", index);
                ok(JSON.parse(index));
            },
            error: error
        });
    };

    assetServer.getAnimationManifest = function(libId, ok, error) {
        var parts = libId.split("/");

        $.ajax({
            dataType: "text",
            url: "/content/states/" + parts[0] + "/animations/" + parts[1] + "/manifest",
            success: function(manifest) {
                jsonDownloadSize(libId, manifest);
                ok(JSON.parse(manifest));
            },
            error: error
        });
    };

    assetServer.getAsset = function(type, id, ok) {
        var parts = id.split("/");
        var stateId = parts[0];
        var assetId = parts[1];
        var key = parts[2];
        var assetURI = stateId + "/" + (URL_BASE[type] || type + "s") + "/" + assetId;
        if (key) {
            assetURI += "/" + key;
        }

        if (messageCallbacks[assetURI]) {
            messageCallbacks[assetURI].push(ok);
            return;
        }

        messageCallbacks[assetURI] = [ok];

        requestQueue.push(assetURI);
    };

    assetServer.getAssetLibrary = function (dir, libId, fileName, ok) {
        var parts = libId.split("/");

        $.ajax({
            dataType: "json",
            url: "/content/states/" + parts[0] + "/" + dir + "/" + parts[1] + "/" + fileName,
            success: ok,
            error: function() {
                Human.log.error("Asset library not found: " + libId);
                ok(null);
            }
        });
    };

    function createSocket() {
        var socket = new WebSocket(socketURL);

        socket.binaryType = "arraybuffer";

        socket.addEventListener("open", function() {
            socket.send(JSON.stringify({ open: "sesame!" }));

            for (var i = 0, len = openCallbacks.length; i < len; i++) {
                openCallbacks[i]();
            }

            openCallbacks.length = 0;
        });

        socket.addEventListener("close", function(event) {
            Human.log.log("Socket closed", event.code, event.reason);
        });

        socket.addEventListener("error", function() {
            Human.log.error("Socket error");
        });

        socket.addEventListener("message", function(response) {

            var data = response.data;
            var asset;
            var assetId;

            lastNetworkTime = Date.now();

            if (typeof data === "string") {

                // Non-data "message received" signal
                if (data === "\uD83C\uDF7A") {
                    return;
                }


                var json = JSON.parse(data);
                assetId = json.id;
                
                jsonDownloadSize(assetId, data);

                if (json.error) {
                    Human.log.error("Asset not found: " + assetId);
                    asset = null;
                } else if (!json.asset) {
                    Human.log.error("Null asset: " + assetId);
                    asset = null;
                } else {
                    asset = json.asset;
                }


            } else {

                /*
                 Geometry or morph

                 bytes   : info
                 [0.. 3]: uint32; file type identifer (= 0x11)
                 [4.. 7]: uint32; byte-length of padded asset id
                 [8..11]: uint32; byte-length of padded morph keys JSON
                 [12..15]: uint32; byte-length of positions array
                 [16..19]: uint32; byte-length of normals array
                 [20..23]: uint32; byte-length of indices array
                 [24..27]: uint32; byte-length of uv array
                 [28..43]: unit32[4]; unused, reserved for future use
                 [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
                 [  ..  ]: text; morph key JSON (tail-padded with 0x20)
                 [  ..  ]: float32[]; positions array
                 [  ..  ]: float32[]; normals array
                 [  ..  ]: int32[];   indices array
                 [  ..  ]: float32[]; uv array
                 */


                asset = data;

                var index = new DataView(asset);

                var fileType = index.getUint32(0, true);

                var assetIdStart, assetIdSize;

                if (fileType === 0x11) {
                    assetIdSize = new Uint32Array(asset, 0, 2)[1];
                    assetIdStart = 11 * Uint32Array.BYTES_PER_ELEMENT;
                } else {
                    assetIdSize = index.getUint32(4, true);
                    assetIdStart = index.getUint32(12, true);
                }


                assetId = Human.utils.atos(asset, assetIdStart, assetIdSize).trim();
                
                binaryDownloadSize(assetId, data);
            }

            var callbacks = messageCallbacks[assetId];

            if (callbacks) {
                for (var i = 0, len = callbacks.length; i < len; i++) {
                    callbacks[i](asset);
                }
                delete messageCallbacks[assetId];
            }
        });

        return socket;
    }

    function socketSend() {

        if (requestQueue.length === 0) {
            return;
        }

        lastNetworkTime = Date.now();

        if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({
                assets: requestQueue
            }));
            requestQueue.length = 0;
            return;
        }

        openCallbacks.push(function() {
            socket.send(JSON.stringify({
                assets: requestQueue
            }));
            requestQueue.length = 0;
        });

        if (socket.readyState === WebSocket.CLOSING || socket.readyState === WebSocket.CLOSED) {
            socket = createSocket();
        }
    }

    function jsonDownloadSize(id, str) {
        if (Human.stats.trackingDownloadSize) {
            var size = Human.utils.textGzipSize(str);
            Human.stats.jsonDownloadSizes[id] = size;
            Human.stats.jsonDownloadTotal += size;
        }
    }

    function binaryDownloadSize(id, data) {
        if (Human.stats.trackingDownloadSize) {
            var size = Human.utils.binaryGzipSize(data);
            Human.stats.geometryDownloadSizes[id] = size;
            Human.stats.geometryDownloadTotal += size;
        }
    }

})();
;/**
 * @namespace Geometry libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsGeometries = Human.assets.geometries = {};

    /** All geometries
     */
    HumanAssetsGeometries.geometries = {};

    var INDEX_TYPE_MAP = {
        "1": Uint8Array,
        "2": Uint16Array,
        "4": Uint32Array
    };

    // Holds all SceneJS nodes for geometries
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Geometry library"
            });
        });

    HumanAssetsGeometries.parseAsset = function(geometryId, asset, ok) {

        var fileType = new Uint32Array(asset, 0, 1)[0];

        var cfg = {
            geometry: {
                primitive: 'triangles'
            },
            compressed: (fileType !== 0x11)
        };

        if (!cfg.compressed) {
            parseRawGeometry(asset, cfg);
        } else {
            parseCompressedGeometry(asset, cfg);
        }

        ok(HumanAssetsGeometries.createGeometry(geometryId, cfg));
    };

    /** Creates a geometry within an existing geometries library
     * @param libraryId ID of library
     * @param geometryId ID for new geometry, globally unique among geometries in all libraries
     * @param params Geometry params - geometry, texture, flags
     */
    HumanAssetsGeometries.createGeometry = function (geometryId, params) {
        if (HumanAssetsGeometries.geometries[geometryId]) {
            Human.log.error("Human.assets.geometries.createGeometry", "Geometry already loaded: " + geometryId);
            return;
        }
        if (!params.geometry) {
            Human.log.error("Human.assets.geometries.createGeometry", "Mandatory attribute 'geometryId' expected on geometry: " + geometryId);
            return;
        }
        params.geometry.type = "geometry";
        var geometry = {
            //   materialId: params.materialId, // HACK while materialId can be on geometries
            geometry: libRoot.addNode(params.geometry),
            type: "geometry",
            compressed: params.compressed
        };
        // Boundary and center
        if (params.boundary) {
            var boundary = params.boundary;
            geometry.boundary = boundary;
            geometry.center = [
                (boundary.xmax + boundary.xmin) * 0.5,
                (boundary.ymax + boundary.ymin) * 0.5,
                (boundary.zmax + boundary.zmin) * 0.5
            ];
            geometry.axisBoundary = new Float32Array([
                boundary.xmin, boundary.ymin, boundary.zmin,
                boundary.xmax, boundary.ymax, boundary.zmax]);
        }
        HumanAssetsGeometries.geometries[geometryId] = geometry;

        return geometry;
    };

    HumanAssetsGeometries.getCompressionStats = function() {
        var stats = {
            compressed: 0,
            uncompressed: 0
        };

        for (var geometryId in HumanAssetsGeometries.geometries) {
            if (HumanAssetsGeometries.geometries.hasOwnProperty(geometryId)) {
                if (HumanAssetsGeometries.geometries[geometryId].compressed) {
                    stats.compressed++;
                } else {
                    stats.uncompressed++;
                }
            }
        }

        return stats;
    };

    /**
     * Destroys a geometries library
     * @param libraryId
     */
    HumanAssetsGeometries.destroyAsset = function (geometryId) {
        if (geometryId) {
            var geometry = HumanAssetsGeometries.geometries[geometryId];
            geometry.geometry.destroy();
            delete HumanAssetsGeometries.geometries[geometryId];
        } else {
            HumanAssetsGeometries.reset();
        }
    };

    /** Destroys all geometry libraries
     */
    HumanAssetsGeometries.reset = function () {
        for (var geometryId in HumanAssetsGeometries.geometries) {
            if (HumanAssetsGeometries.geometries.hasOwnProperty(geometryId)) {
                HumanAssetsGeometries.destroyAsset(geometryId);
            }
        }
    };

    function parseRawGeometry(asset, cfg) {
        /*
         Geometry format

         bytes   : info
         [0.. 3]: uint32; file type identifer (= 0x11)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph keys JSON
         [12..15]: uint32; byte-length of positions array
         [16..19]: uint32; byte-length of normals array
         [20..23]: uint32; byte-length of indices array
         [24..27]: uint32; byte-length of uv array
         [28..43]: unit32[4]; unused, reserved for future use
         [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
         [  ..  ]: text; morph key JSON (tail-padded with 0x20)
         [  ..  ]: float32[]; positions array
         [  ..  ]: float32[]; normals array
         [  ..  ]: int32[];   indices array
         [  ..  ]: float32[]; uv array
         */

         var index = new Uint32Array(asset, 0, 11);

         var assetIdSize = index[1];
         var keysSize = index[2];
         var positionsSize = index[3];
         var normalsSize = index[4];
         var indicesSize = index[5];
         var uvsSize = index[6];
         // var unused = index[7 ... 10];

         var assetIdStart = 11  * Uint32Array.BYTES_PER_ELEMENT;
         var keysStart = assetIdStart + assetIdSize;
         var positionsStart = keysStart + keysSize;
         var normalsStart = positionsStart + positionsSize;
         var indicesStart = normalsStart + normalsSize;
         var uvsStart = indicesStart + indicesSize;



         var numVertices = 0;

         if (positionsSize > 0) {
             cfg.geometry.positions = new Float32Array(asset, positionsStart, positionsSize / Float32Array.BYTES_PER_ELEMENT);
             cfg.boundary = getBoundary(cfg.geometry.positions);
             numVertices = cfg.geometry.positions.length / 3;
         }

         if (normalsSize > 0) {
             cfg.geometry.normals = new Float32Array(asset, normalsStart, normalsSize / Float32Array.BYTES_PER_ELEMENT);
         }

         if (uvsSize > 0) {
             cfg.geometry.uv = new Float32Array(asset, uvsStart, uvsSize / Float32Array.BYTES_PER_ELEMENT);
         }

         if (indicesSize > 0) {
             cfg.geometry.indices = new Uint32Array(asset, indicesStart, indicesSize / Uint32Array.BYTES_PER_ELEMENT);
             if (numVertices <= 256) {
                 cfg.geometry.indices = new Uint8Array(cfg.geometry.indices);
             } else if (numVertices <= 65536) {
                 cfg.geometry.indices = new Uint16Array(cfg.geometry.indices);
             }
         }
    }

    var positionScaleMat = mat4.create();
    var positionTranslateMat = mat4.create();
    var uvScaleMat = mat3.create();
    var uvTranslateMat = mat3.create();

    function parseCompressedGeometry(asset, cfg) {
        /*
        # HEADER
         [0.. 3]: uint32; file type identifier (= 0x12)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph JSON
        [12..15]: uint32; data segment offset (e.g. where DATA starts)
        [16..19]: uint32; indices offset
        [20..23]: uint32; byte-length of positions array
        [24..27]: uint32; byte-length of normals array
        [28..31]: uint32; byte-length of indices array
            [32]: uchar; byte-length of positions matrix elements (= 24)
            [33]: uchar; size (bytes) of indices type (e.g. 1, 2, 4)
            [34]: uchar; # of uv sets
            [35]: unused
        (36..39): uint32; byte-length of array for uv set 1
          ... repeat for uvs
        (  ..  ): uint32; byte-length of array for uv set n
            (  ): uchar; byte-length of uv set 1 matrix elements (= 16)
          ... repeat for uvs
            (  ): uchar; byte-length of uv set n matrix elements (= 16)
        (  ..  ): padding to align DATA to uint32; "unused" is obviated by data offset

        # DATA
        [  ..  ]: quad-char[]/text; asset id (tail-padded with empty spaces, e.g. 0x20)
        [  ..  ]: quad-char[]/text; morph JSON (tail-padded; includes extra info)
        [  ..  ]: float32[]; positions matrix elements
        (  ..  ): float32[]; uv set 1 matrix elements
          ... repeat for uvs
        (  ..  ): float32[]; uv set n matrix elements
        [  ..  ]: uint16[]; quantized positions array
        (  ..  ): uint16[]; quantized uv set 1 array
          ... repeat for uvs
        (  ..  ): uint16[]; quantized uv set n array
        (  ..  ): signed char[]; oct-encoded normals array
        (  ..  ): padding to align indices to uint32, which will work for all sizes
        (  ..  ): indices_t[]; indices array
        */

        var index = new DataView(asset);

        var assetIdSize = index.getUint32(4, true);
        var morphDataSize = index.getUint32(8, true);
        var dataOffset = index.getUint32(12, true);
        var indexOffset = index.getUint32(16, true);
        var positionsSize = index.getUint32(20, true);
        var normalsSize = index.getUint32(24, true);
        var indicesSize = index.getUint32(28, true);
        var positionDecodeSize = index.getUint16(32, true);
        var indexType = index.getUint8(34);
        var uvCount = index.getUint8(35);

        var uvIndex = new Array(uvCount);

        var bytePos, i;

        for (i = 0, bytePos = 36; i < uvCount; i++, bytePos += 6) {
            uvIndex[i] = {
                uvSize: index.getUint32(bytePos, true),
                uvDecodeSize: index.getUint16(bytePos + 4, true)
            };
        }

        // Start at position transform data
        bytePos = dataOffset + assetIdSize + morphDataSize;

        if (positionDecodeSize > 0) {
            cfg.positionTranslate = new Float32Array(asset, bytePos, 3);
            cfg.positionScale = new Float32Array(asset, bytePos + 12, 3);

            mat4.fromScaling(positionScaleMat, cfg.positionScale);
            mat4.fromTranslation(positionTranslateMat, cfg.positionTranslate);
            cfg.geometry.positionDecodeMat = mat4.create();

            mat4.multiply(cfg.geometry.positionDecodeMat, positionTranslateMat, positionScaleMat);

            bytePos += positionDecodeSize;
        }

        if (uvCount > 0) {
            cfg.geometry.uvDecodeMats = new Array(uvCount);
            cfg.uvTranslates = new Array(uvCount);
            cfg.uvScales = new Array(uvCount);

            for (i = 0; i < uvCount; i++) {
                var uvTranslate = cfg.uvTranslates[i] = new Float32Array(asset, bytePos, 2);
                var uvScale = cfg.uvScales[i] = new Float32Array(asset, bytePos + 8, 2);

                mat3.fromScaling(uvScaleMat, uvScale);
                mat3.fromTranslation(uvTranslateMat, uvTranslate);
                cfg.geometry.uvDecodeMats[i] = mat3.create();

                mat3.multiply(cfg.geometry.uvDecodeMats[i], uvTranslateMat, uvScaleMat);

                bytePos += uvIndex[i].uvDecodeSize;
            }
        }

        if (positionsSize > 0) {
            cfg.geometry.positions = new Uint16Array(asset, bytePos, positionsSize / Uint16Array.BYTES_PER_ELEMENT);
            cfg.boundary = getBoundary(cfg.geometry.positions, cfg.positionScale, cfg.positionTranslate);

            bytePos += positionsSize;
        }

        if (uvCount > 0) {
            cfg.geometry.uvs = new Array(uvCount);

            for (i = 0; i < uvCount; i++) {
                cfg.geometry.uvs[i] = new Uint16Array(asset, bytePos, uvIndex[i].uvSize / Uint16Array.BYTES_PER_ELEMENT);
                bytePos += uvIndex[i].uvSize;
            }
        }

        if (normalsSize > 0) {
            cfg.geometry.normals = new Int8Array(asset, bytePos, normalsSize / Int8Array.BYTES_PER_ELEMENT);
            bytePos += normalsSize;
        }

        if (indicesSize > 0) {
            var IndexType = INDEX_TYPE_MAP[indexType];
            cfg.geometry.indices = new IndexType(asset, indexOffset, indicesSize / IndexType.BYTES_PER_ELEMENT);
        }
    }

    var defaultTranslate = vec3.fromValues(0, 0, 0);
    var defaultScale = vec3.fromValues(1, 1, 1);

    // Get minimal boundary enclosing the given array
    function getBoundary(positions, scale, translate) {
        scale = scale || defaultScale;
        translate = translate || defaultTranslate;
        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var x, y, z;
        for (var i = 0, len = positions.length - 2; i < len; i += 3) {
            x = positions[i] * scale[0] + translate[0];
            y = positions[i + 1] * scale[1] + translate[1];
            z = positions[i + 2] * scale[2] + translate[2];

            if (x < xmin) {
                xmin = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (z < zmin) {
                zmin = z;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y > ymax) {
                ymax = y;
            }
            if (z > zmax) {
                zmax = z;
            }
        }
        return { xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax };
    }

})();
;
/**
 * @namespace Material libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsMaterials = Human.assets.materials = {};

    /** All materials
     */
    HumanAssetsMaterials.materials = {};

    // Holds all SceneJS nodes for materials
    var libRoot;

    var EMBEDDED = false;
    var DXT_SUPPORTED = false;
    var PVRTC_SUPPORTED = false;
    var ETC1_SUPPORTED = false;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type:"library",
                data: "Materials library"
            });

            DXT_SUPPORTED = Human.renderer.checkWebGLExtension("WEBGL_compressed_texture_s3tc");
            PVRTC_SUPPORTED = Human.renderer.checkWebGLExtension("WEBGL_compressed_texture_pvrtc");
            ETC1_SUPPORTED = Human.renderer.checkWebGLExtension("WEBGL_compressed_texture_etc1");
        });

    HumanAssetsMaterials.parseAsset = function(materialId, asset, ok) {
        var parts = materialId.split("/");
        var libId = parts[1].split(".")[0];
        var imagePath = "/content/states/" + parts[0] + "/materials/" + libId + "/";

        HumanAssetsMaterials.createMaterial(materialId, parseManifest(asset, imagePath), ok);
    };

    /** Given a state ID and a relative material ID, attempts to find the material within the libraries
     * @param materialId Relative material ID, ie. not prefixed by libraryId
     */
    HumanAssetsMaterials.findMaterial = function (materialId) {
        var material = HumanAssetsMaterials.materials[materialId];

        if (material) {
            return material;
        } else {
            return null;
        }
    };

    /** Creates a material within an existing materials library
     * @param libraryId ID of library
     * @param materialId ID for new material, globally unique among materials in all libraries
     * @param params Material params - material, reflection, texture, flags
     */
    HumanAssetsMaterials.createMaterial = function (materialId, params, ok) {
        if (HumanAssetsMaterials.materials[materialId]) {
            Human.log.warn("Human.assets.materials.createMaterial", "Material already loaded: " + materialId);
            return;
        }
        var material = {
            type: "material",
            textureCompressionStats: {
                compressed: 0,
                uncompressed: 0
            }
        };
        if (params.material) {
            material.material = libRoot.addNode({
                type: "material",
                baseColor: params.material.baseColor,
                specularColor: params.material.specularColor,
                emitColor: params.material.emitColor,
                shine: params.material.shine,
                alpha: params.material.alpha,
                emit: params.material.emit
            });
            material.glassFactor = params.material.glassFactor !== undefined && params.material.glassFactor !== null ? params.material.glassFactor : 1.0;
            material.murkiness = params.material.murkiness !== undefined && params.material.murkiness !== null ? params.material.murkiness : 1.0;

            // Fresnels

            var fresnel;
            var edge;
            var center;

            // Base color Fresnel

            if (params.material.baseFresnel) {

                fresnel = params.material.baseFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge : {r: 1, g: 1, b: 1};
                center = fresnel.center !== undefined ? fresnel.center : {r: 0, g: 0, b: 0};

                material.fresnels.color = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "color",
                    edgeBias: fresnel.biasEdge,
                    centerBias: fresnel.biasCenter,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center,
                    blendMode: fresnel.blendMode
                });
            }

            // Alpha Fresnel

            if (params.material.alphaFresnel) {

                fresnel = params.material.alphaFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge : 0;
                center = fresnel.center !== undefined ? fresnel.center  : 1;

                material.fresnels.alpha = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "alpha",
                    edgeBias: fresnel.biasEdge,
                    centerBias: fresnel.biasCenter,
                    power: fresnel.power || 1,
                    edgeColor: {
                        r: edge,
                        g: edge,
                        b: edge
                    },
                    centerColor: {
                        r: center,
                        g: center,
                        b: center
                    },
                    blendMode: fresnel.blendMode
                });
            }

            // Reflection Fresnel

            if (params.material.reflectionFresnel) {

                fresnel = params.material.reflectionFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge : 1;
                center = fresnel.center !== undefined ? fresnel.center  : 0;

                material.fresnels.reflect = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "reflect",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: {
                        r: edge,
                        g: edge,
                        b: edge
                    },
                    centerColor: {
                        r: center,
                        g: center,
                        b: center
                    },
                    blendMode: fresnel.blendMode
                });
            }

            // Specular Fresnel

            if (params.material.specularFresnel) {

                fresnel = params.material.specularFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge  : {r: 0, g: 0, b: 0};
                center = fresnel.center !== undefined ? fresnel.center : {r: 1, g: 1, b: 1};

                material.fresnels.specular = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "specular",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center,
                    blendMode: fresnel.blendMode
                });
            }

            // Emit Fresnel

            if (params.material.emitFresnel) {

                fresnel = params.material.emitFresnel;

                material.fresnels = material.fresnels || {};

                edge = fresnel.edge !== undefined ? fresnel.edge  : {r: 0, g: 0, b: 0};
                center = fresnel.center !== undefined ? fresnel.center : {r: 1, g: 1, b: 1};

                material.fresnels.emit = libRoot.addNode({
                    type: "fresnel",
                    applyTo: "emit",
                    centerBias: fresnel.biasCenter,
                    edgeBias: fresnel.biasEdge,
                    power: fresnel.power || 1,
                    edgeColor: edge,
                    centerColor: center,
                    blendMode: fresnel.blendMode
                });
            }

        } else {
            material.glassFactor = 1.0;
            material.murkiness = 1.0;
        }

        if (params.reflection) { // Reflection asset
            material.reflection = libRoot.addNode({
                type: "reflect",
                coreId: params.reflection.getCoreId() // Share core with reflection scene node
            });
        }

        var depthMask;
        var layer;
        if (params.flags && params.flags.flags.skybox) {
            depthMask = false;
            layer = Number.MIN_SAFE_INTEGER;
        }

        if (params.flags) {
            material.flags = {
                backfaces: params.flags.flags.backfaces,
                frontface: params.flags.flags.frontface,
                solid: (Human.scene.enableSolidObjects ? params.flags.flags.solid : false),
                skybox: params.flags.flags.skybox,
                billboard: params.flags.flags.billboard,
                depthMask: depthMask,
                layer: layer
            };
        }

        loadTextures(material, params, function() {
            HumanAssetsMaterials.materials[materialId] = material;

            ok(material);
        });
    };

    var texturesRequested = 0;
    function loadTextures(material, params, ok) {
        if (!params.texture) {
            ok();
            return;
        }

        if (texturesRequested === 0) {
            Human.stats.loadSequence.texturesRequested = Human.timer.now();
            Human.stats.loadTimes.preTexture = Human.stats.loadSequence.texturesRequested - Human.stats.loadSequence.startTime;
        }

        var texture = params.texture;
        var layers = texture.layers;
        var layer;

        var numTextures = layers.length;
        texturesRequested += numTextures;

        material.textures = new Array(numTextures);

        function done() {
            if (--texturesRequested === 0) {
                Human.stats.loadSequence.texturesLoaded = Human.timer.now();
                Human.stats.loadTimes.textureDownload = Human.stats.loadSequence.texturesLoaded - Human.stats.loadSequence.texturesRequested;
            }
            if (--numTextures === 0) {
                ok();
            }
        }

        for (var i = 0, len = numTextures; i < len; i++) {
            layer = layers[i];

            if (layer.blendMode === "add") {
                layer.blendMode = "over";
            }

            if (layer.compressedSrc) {
                Human.utils.getBinary(
                    layer.compressedSrc,
                    getCompressedTextureCallback(layer, material, i, done),
                    getCompressedTextureErrorCallback(layer, material, i, done)
                );
            } else {
                getImageTexture(layer, material, i, done);
            }
        }
    }



    function getCompressedTextureCallback(layer, material, index, ok) {
        return function(data) {
            if (Human.stats.trackingDownloadSize) {
                var size = Human.utils.binaryGzipSize(data);
                Human.stats.textureDownloadSizes[layer.compressedSrc] = size;
                Human.stats.textureDownloadTotal += size;
            }

            layer.type = "texture";
            layer.compressedImage = data;
            layer.uri = null;
            material.textures[index] = libRoot.addNode(layer);
            material.textureCompressionStats.compressed++;
            ok();
        };
    }

    function getCompressedTextureErrorCallback(layer, material, i, ok) {
        return function() {
            Human.log.error("Compressed texture not found: " + layer.compressedSrc);
            Human.log.error("Falling back to image: " + layer.uri);
            layer.compressedSrc = null;
            getImageTexture(layer, material, i, ok);
        };
    }

    function getImageTexture(layer, material, i, ok) {
        var img = new Image();
        img.onload = getImageCallback(img, layer, material, i, ok);
        img.onerror = getImageErrorCallback(layer.uri, ok);
        img.src = layer.uri;
        layer.uri = null;
        layer.src = null;
    }

    function getImageCallback(img, layer, material, index, ok) {
        return function() {
            layer.type = "texture";
            layer.image = img;
            material.textures[index] = libRoot.addNode(layer);
            material.textureCompressionStats.uncompressed++;
            ok();
        };
    }

    function getImageErrorCallback(uri, ok) {
        return function() {
            Human.log.error("Texture image not found: " + uri);
            ok();
        };
    }

    HumanAssetsMaterials.getTextureCompressionStats = function () {
        var stats = {
            compressed: 0,
            uncompressed: 0
        };

        for (var materialId in HumanAssetsMaterials.materials) {
            if (HumanAssetsMaterials.materials.hasOwnProperty(materialId)) {
                stats.compressed += HumanAssetsMaterials.materials[materialId].textureCompressionStats.compressed;
                stats.uncompressed += HumanAssetsMaterials.materials[materialId].textureCompressionStats.uncompressed;
            }
        }

        return stats;
    };

    /**
     * Destroys a materials library
     * @param libraryId
     */
    HumanAssetsMaterials.destroyAsset = function (materialId) {
        // Also check for "" libraries, otherwise will run into circular dependency with reset
        if (materialId) {
            var material = HumanAssetsMaterials.materials[materialId];

            for (var type in material) {
                if (material.hasOwnProperty(type) && typeof material[type].destroy === "function") {
                    material[type].destroy();
                }
            }

            delete HumanAssetsMaterials.materials[materialId];
        } else {
            HumanAssetsMaterials.reset();
        }
    };

    /** Destroys all material libraries
     */
    HumanAssetsMaterials.reset = function () {
        for (var materialId in HumanAssetsMaterials.materials) {
            if (HumanAssetsMaterials.materials.hasOwnProperty(materialId)) {
                HumanAssetsMaterials.destroyAsset(materialId);
            }
        }
    };

    function parseManifest(node, path, material) {
        material = material || {};
        var i, len;

        if (node.id) {
            node.id = null; // Don't let SceneJS create a node with this ID - would cause ID clash
        }
        switch (node.type) {
            case  "texture":
                var layer;
                for (i = 0, len = node.layers.length; i < len; i++) {
                    layer = node.layers[i];
                    layer.uri = layer.uri || layer.src;
                    if (!layer.uri) {
                        layer.uri = ".";
                        Human.log.error("Human.assets.materials.parseManifest", "Texture layer with no 'uri' or 'src' property");
                    } else {
                        if (!EMBEDDED) {
                            layer.uri = path + layer.uri;
                        }
                        if (DXT_SUPPORTED || PVRTC_SUPPORTED || ETC1_SUPPORTED) {
                            compressLayer(layer);
                            layer.compressedSrc += "?v=" + Human.VERSION;
                        } else {
                            layer.uri += "?v=" + Human.VERSION;
                        }
                    }

                    layer.preloadURI = layer.preloadURI || layer.preloadSrc;
                    if (layer.preloadURI) {
                        if (EMBEDDED) {
                            // (bas) these were changed to absolute uris
                            layer.preloadURI += "?v=" + Human.VERSION;
                        } else {
                            layer.preloadURI = path + layer.preloadURI + "?v=" + Human.VERSION;
                        }
                    }

                    // In SceneJS V3.0, texture blendMode has changed from "add" to "multiply".
                    // Some of our materials for texture have black base color, which worked fine with "add",
                    // but not with "multiply", so we'll default to "add" here.
                    layer.blendMode = layer.blendMode || "add";
                }
                if (material) {
                    material.texture = node;
                }
                break;

            case "material":
                if (material) {
                    material.material = node;
                    if (node.reflectionId) {
                        var reflectionId = node.reflectionId;
                        var reflections = Human.assets.reflections;
                        var assetId = reflections.exportedReflectionIds[reflectionId];
                        if (!assetId) {
                            Human.log.error("Human.assets.materials.parseManifest", "Reflection not found: " + reflectionId);
                        } else {
                            var reflection = Human.assets.reflections.reflections[assetId];
                            if (reflection) {
                                material.reflection = reflection.node;
                            } else {
                                Human.log.error("Human.assets.materials.parseManifest", "Reflection not found: " + reflectionId);
                            }
                        }
                    }
                }
                break;

            case "flags":
                if (material) {
                    material.flags = node;
                }
                break;
        }
        if (node.nodes) {
            for (i = 0, len = node.nodes.length; i < len; i++) {
                parseManifest(node.nodes[i], path, material);
            }
            node.nodes = null;
        }
        return material;
    }

    function compressLayer(layer) {
        var baseSrc = layer.uri.replace(/(\.jpg|\.jpeg|\.png)$/, "");

        if (DXT_SUPPORTED) {
            layer.compressedSrc = baseSrc + "-dxt1.dds";
            layer.containerFormat = "dds";
            return;
        }

        if (PVRTC_SUPPORTED) {
            layer.compressedSrc = baseSrc + "-pvrtc.pvr";
            layer.containerFormat = "pvr";
            return;
        }

        if (ETC1_SUPPORTED) {
            layer.compressedSrc = baseSrc + "-etc1.pvr";
            layer.containerFormat = "pvr";
            return;
        }
    }
})();;/**
 * @namespace Region libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsRegionMaps = Human.assets.regionMaps = {};

    /** All region maps
     */
    HumanAssetsRegionMaps.maps = {};

    /** Region maps grouped into libraries
     */
    HumanAssetsRegionMaps.libraries = {};

    // Holds all SceneJS nodes for regions
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Region Map library" // For debugging
            });
        });

    /** Creates a regions library
     * @param libraryId Unique library ID
     */
    HumanAssetsRegionMaps.createLibrary = function (libraryId) {
        if (HumanAssetsRegionMaps.libraries[libraryId]) {
            Human.log.warn("Human.assets.regionMaps.createLibrary", "Region map library already loaded: " + libraryId);
            return;
        }
        HumanAssetsRegionMaps.libraries[libraryId] = {
            // Root scene node for each library means we can blow away scene nodes
            // for a library in one shot by destroying the root
            node: libRoot.addNode({
                type: "library",
                data: "libraryId = " + libraryId // For debugging
            }),
            libraryId: libraryId,
            maps: {}
        };
    };

    /** Creates a region within an existing regions library
     * @param libraryId ID of library
     * @param regionId ID for new region, globally unique among regions in all libraries
     * @param params Region params - region, texture, flags
     */
    HumanAssetsRegionMaps.createRegion = function (libraryId, regionMapId, params) {
        var library = HumanAssetsRegionMaps.libraries[libraryId];
        if (!library) {
            Human.log.error("Human.assets.regions.createRegion", "Region library not found: " + libraryId);
            return;
        }
        if (HumanAssetsRegionMaps.maps[regionMapId]) {
            Human.log.warn("Human.assets.regions.createRegion", "Region already loaded: " + regionMapId);
            return;
        }
        var regionMap = {
            node: library.node.addNode({
                type: "regionMap",
                src: params.src,
                mode: params.mode || "highlight",
                regionData: params.regions,
                highlightFactor: params.highlightFactor || { r: 1.2, g: 1.2, b: 1.2 },
                hideAlpha: params.hideAlpha || 0.0
            }),
            regionMapId: regionMapId
        };
        HumanAssetsRegionMaps.maps[regionMapId] = regionMap;
        library.maps[regionMapId] = regionMap;
    };

    /**

     @param color Color to look for
     @param [regionId=null] Optional region ID - searches all regions when omitted
     @param highlight Boolean flag to highlight or unhighlight
     @returns {*}
     */
    HumanAssetsRegionMaps.highlightRegion = function (params) {
        params = params || {};
        
        var regionColor = params.regionColor;
        var regionMapId = params.regionMapId;
        var highlight = params.highlight;
        var regionMap;

        var regionMaps = HumanAssetsRegionMaps.maps;
        if (!regionMapId) {
            for (regionMapId in regionMaps) {
                if (regionMaps.hasOwnProperty(regionMapId)) {
                    regionMap = regionMaps[regionMapId];
                    if (highlight) {
                        regionMap.node.setRegionColor(regionColor);
                    } else {
                        regionMap.node.setRegionColor({ r: -1, g: -1, b: -1 });
                    }
                }
            }
            return;
        }

        regionMap = regionMaps[regionMapId];
        if (highlight) {
            regionMap.node.setRegionColor(regionColor);
        } else {
            regionMap.node.setRegionColor({ r: -1, g: -1, b: -1 });
        }
    };

    /**
     * Destroys a regions library
     * @param libraryId
     */
    HumanAssetsRegionMaps.destroyLibrary = function (libraryId) {
        if (libraryId || libraryId === "") {
            var lib = HumanAssetsRegionMaps.libraries[libraryId];
            if (!lib) {
                Human.log.warn("Human.assets.regions.destroyLibrary", "Region library not found: " + libraryId);
                return;
            }
            lib.node.destroy(); // Blow away scene subgraph
            for (var regionMapId in lib.maps) {
                if (lib.maps.hasOwnProperty(regionMapId)) {
                    delete HumanAssetsRegionMaps.maps[regionMapId];
                }
            }
            delete HumanAssetsRegionMaps.libraries[libraryId];
        } else {
            HumanAssetsRegionMaps.reset();
        }
    };

    /** Destroys all region libraries
     */
    HumanAssetsRegionMaps.reset = function () {
        for (var libraryId in HumanAssetsRegionMaps.libraries) {
            if (HumanAssetsRegionMaps.libraries.hasOwnProperty(libraryId)) {
                HumanAssetsRegionMaps.destroyLibrary(libraryId);
            }
        }
    };
})();;(function() {
    "use strict";


    /**
     * @namespace Loads regions into {@link Human.view.regions}
     * @private
     * @type {Loader}
     */
    Human.assets.regionMaps.loader = new Human.utils.Loader();

    Human.assets.regionMaps.loader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localLibraryId = libraryId;
        var globalLibraryId = modelId + "." + libraryId;

        Human.net.getRegionsLibrary(
            localLibraryId,
            function (manifest) {
                Human.assets.regionMaps.createLibrary(globalLibraryId);
                var imagesPath = Human.net.getRegionsDir(localLibraryId);
                var region;
                var src;
                for (var regionId in manifest) {
                    if (manifest.hasOwnProperty(regionId)) {
                        region = manifest[regionId];
                        src = region.src;
                        if (!src) {
                            Human.log.error("Human.assets.regionMaps.loader", "Region property missing: src");
                            continue;
                        }
                        region.src = imagesPath + src.substring(src.lastIndexOf("/") + 1) + "?v=" + Human.VERSION;
                        Human.assets.regionMaps.createRegion(globalLibraryId, globalLibraryId + "." + regionId, region);
                    }
                }
                // Subsequently-loaded materials will need our regions to exist, so render a frame
                // to force the creation of the regions' nodes in the scene graph
                Human.renderer.compile();
                ok();
            },
            function (errMsg) {
                error("failed to load manifest file for regions library '" + localLibraryId + "': " + errMsg);
            });
    };


    Human.assets.regionMaps.loader._unload = function (globalLibraryId) {
        Human.assets.regionMaps.destroyLibrary(globalLibraryId);
    };
})();
;/**
 * @namespace Transform libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsTransforms = Human.assets.transforms = {};

    /** All transforms
     */
    HumanAssetsTransforms.transforms = {};


    /** Creates a transform within an existing transforms library
     * @param libraryId ID of library
     * @param transformId ID for new transform, globally unique among transforms in all libraries
     * @param params Transform params
     */
    HumanAssetsTransforms.parseAsset = function (transformId, asset, ok) {
        if (HumanAssetsTransforms.transforms[transformId]) {
            Human.log.warn("Human.assets.transforms.createTransform", "Transform already loaded, not reloading: " + transformId);
            return;
        }
        var transform = new Human.assets.transforms.Transform(asset);
        HumanAssetsTransforms.transforms[transformId] = transform;

        ok(transform);
    };

    /** Given a relative transform ID, attempts to find the transform within the libraries
     * @param transformId Relative transform ID, ie. not prefixed by libraryId
     */
    HumanAssetsTransforms.findTransform = function (transformId) {
        var transform = HumanAssetsTransforms.transforms[transformId];
        if (transform) {
            return transform;
        } else {
            return null;
        }
    };

    /**
     * Destroys a transforms library
     * @param libraryId
     */
    HumanAssetsTransforms.destroyAsset = function (transformId) {
        if (transformId) {
            delete HumanAssetsTransforms.transforms[transformId];
        } else {
            HumanAssetsTransforms.reset();
        }
    };

    /** Destroys all transform libraries
     */
    HumanAssetsTransforms.reset = function () {
        for (var transformId in HumanAssetsTransforms.transforms) {
            if (HumanAssetsTransforms.transforms.hasOwnProperty(transformId)) {
                HumanAssetsTransforms.destroyAsset(transformId);
            }
        }
    };
})();
;(function() {
    "use strict";

    /**
     * A transformation asset with a {@link Human.assets.transforms}.
     * @param cfg
     * @constructor
     */
    Human.assets.transforms.Transform = function (cfg) {

        this.type = "transform";

        // Defaults
        this.pivot = { x: 0, y: 0, z: 0 };
        this.translate = { x: 0, y: 0, z: 0 };
        this.scale = { x: 1, y: 1, z: 1 };
        this.rotate = { x: 0, y: 0, z: 0 };

        this.onUpdated = null;

        // Initialize
        this.set(cfg);
    };

    /**
     * Sets the transforms.
     */
    Human.assets.transforms.Transform.prototype.set = function (params) {

        if (params.pivot) {
            if (params.pivot.x !== undefined) {
                this.pivot.x = params.pivot.x;
            }
            if (params.pivot.y !== undefined) {
                this.pivot.y = params.pivot.y;
            }
            if (params.pivot.z !== undefined) {
                this.pivot.z = params.pivot.z;
            }
        }

        if (params.translate) {
            if (params.translate.x !== undefined) {
                this.translate.x = params.translate.x;
            }
            if (params.translate.y !== undefined) {
                this.translate.y = params.translate.y;
            }
            if (params.translate.z !== undefined) {
                this.translate.z = params.translate.z;
            }
        }

        if (params.scale) {
            if (params.scale.x !== undefined) {
                this.scale.x = params.scale.x;
            }
            if (params.scale.y !== undefined) {
                this.scale.y = params.scale.y;
            }
            if (params.scale.z !== undefined) {
                this.scale.z = params.scale.z;
            }
        }

        if (params.rotate) {
            if (params.rotate.x !== undefined) {
                this.rotate.x = params.rotate.x;
            }
            if (params.rotate.y !== undefined) {
                this.rotate.y = params.rotate.y;
            }
            if (params.rotate.z !== undefined) {
                this.rotate.z = params.rotate.z;
            }
        }

        if (this.onUpdated) {
            this.onUpdated();
        }
    };

})();

;/**
 * @namespace Morph libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsMorphs = Human.assets.morphs = {};

    /** All morphs
     */
    HumanAssetsMorphs.morphs = {};


    // Holds all SceneJS nodes for morphs
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Morphs library"
            });
        });

    HumanAssetsMorphs.parseAsset = function(morphId, asset, ok) {

        var morph;

        var fileType = new Uint32Array(asset, 0, 1)[0];

        if (fileType === 0x11) {
            morph = parseRawMorph(asset);
        } else {
            morph = parseCompressedMorph(asset);
        }


        ok(
            Human.assets.morphs.createMorph(morphId, morph)
        );
    };

    /** Given a relative morph ID, attempts to find the morph within the libraries
     * @param morphId Relative morph ID, ie. not prefixed by libraryId
     */
    HumanAssetsMorphs.findMorph = function (morphId) {
        var morph = HumanAssetsMorphs.morphs[morphId];

        if (morph) {
            return morph;
        } else {
            return null;
        }
    };

    /** Creates a material within an existing morphs library
     * @param libraryId ID of library
     * @param morphId ID for new material, globally unique among morphs in all libraries
     * @param params Material params - material, texture, flags

     */

    var defaultPositionTranslate = vec3.fromValues(0, 0, 0);
    var defaultPositionScale = vec3.fromValues(1, 1, 1);

    HumanAssetsMorphs.createMorph = function (morphId, params) {

        var morph = HumanAssetsMorphs.morphs[morphId];

        if (morph) {
            Human.log.warn("Human.assets.morphs.createMorph", "Morph already loaded: " + morphId);
            return morph;
        }

        morph = {
            type: "morph",
            boundary: null,
            center: null,
            axisBoundary: null,
            _frameDirty: true,
            positionTranslates: params.positionTranslates,
            positionScales: params.positionScales,
            updateBoundary: function getBoundary() {
                if (!this._frameDirty) {
                    return;
                }

                var boundary = {
                    xmin: 100000,
                    ymin: 100000,
                    zmin: 100000,
                    xmax: -100000,
                    ymax: -100000,
                    zmax: -100000
                };

                var currentFrame = this.morphGeometry.getCurrentFrame();
                var key1 = currentFrame.key1;
                var key2 = currentFrame.key2;
                var positions1 = currentFrame.target1.positions;
                var positions2 = currentFrame.target2.positions;
                var factor = currentFrame.factor;

                var positionScale1, positionTranslate1, positionScale2, positionTranslate2;

                if (this.positionTranslates && this.positionScales) {
                    positionTranslate1 = this.positionTranslates[key1];
                    positionScale1 = this.positionScales[key1];
                    positionTranslate2 = this.positionTranslates[key2];
                    positionScale2 = this.positionScales[key2];
                } else {
                    positionTranslate1 = defaultPositionTranslate;
                    positionScale1 = defaultPositionScale;
                    positionTranslate2 = defaultPositionTranslate;
                    positionScale2 = defaultPositionScale;
                }

                var x1, y1, z1;
                var x2, y2, z2;
                var x, y, z;
                for (var i = 0, len = positions1.length - 2; i < len; i += 3) {
                    x1 = positions1[i] * positionScale1[0] + positionTranslate1[0];
                    y1 = positions1[i + 1] * positionScale1[1] + positionTranslate1[1];
                    z1 = positions1[i + 2] * positionScale1[2] + positionTranslate1[2];
                    x2 = positions2[i] * positionScale2[0] + positionTranslate2[0];
                    y2 = positions2[i + 1] * positionScale2[1] + positionTranslate2[1];
                    z2 = positions2[i + 2] * positionScale2[2] + positionTranslate2[2];

                    if (typeof x1 === "number" && typeof y1 === "number" && typeof z1 === "number" &&
                        typeof x2 === "number" && typeof y2 === "number" && typeof z2 === "number") {
                        x = x1 + factor * (x2 - x1);
                        y = y1 + factor * (y2 - y1);
                        z = z1 + factor * (z2 - z1);

                        boundary.xmin = Math.min(boundary.xmin, x);
                        boundary.ymin = Math.min(boundary.ymin, y);
                        boundary.zmin = Math.min(boundary.zmin, z);
                        boundary.xmax = Math.max(boundary.xmax, x);
                        boundary.ymax = Math.max(boundary.ymax, y);
                        boundary.zmax = Math.max(boundary.zmax, z);
                    }

                }

                this.boundary = boundary;
                this.axisBoundary = new Float32Array([
                    boundary.xmin, boundary.ymin, boundary.zmin,
                    boundary.xmax, boundary.ymax, boundary.zmax
                ]);
                this.center = [
                    (boundary.xmax + boundary.xmin) * 0.5,
                    (boundary.ymax + boundary.ymin) * 0.5,
                    (boundary.zmax + boundary.zmin) * 0.5
                ];

                this._frameDirty = false;
            }
        };
        if (params.morphGeometry) {
            params.morphGeometry.type = "morphGeometry";
            morph.morphGeometry = libRoot.addNode(params.morphGeometry);
            morph.morphGeometry.onUpdate = function() {
                morph._frameDirty = true;
            };
        }

        morph.updateBoundary();

        var animation = new Human.assets.morphs.Animation();
        var keys = params.morphGeometry.keys;

        animation.addMorph(keys[0], keys[keys.length - 1],
            function (factor) {
                morph.morphGeometry.setFactor(factor);
            });

        animation.calculateTimeFrame();

        Human.timeline.addAnimation(morphId, animation);

        var stateId = morphId.split("/")[0];
        var leaf = Human.timeline.leafTimelines[stateId] || new Human.timeline.LeafTimeline(stateId);

        leaf.addAnimation(morphId, animation); // add to leaf

        HumanAssetsMorphs.morphs[morphId] = morph;
        return morph;
    };

    /**
     * Destroys a morph library
     * @param libraryId
     */
    HumanAssetsMorphs.destroyAsset = function (morphId) {
        if (morphId) {
            var morph = HumanAssetsMorphs.morphs[morphId];
            if (!morph) {
                Human.log.warn("Human.assets.morphs.destroyMorph", "Morph not found: " + morphId);
                return;
            }
            morph.morphGeometry.destroy(); // Blow away scene subgraph

            delete HumanAssetsMorphs.morphs[morphId];
        } else {
            HumanAssetsMorphs.reset();
        }
    };

    /** Destroys all morph libraries
     */
    HumanAssetsMorphs.reset = function () {
        for (var morphId in HumanAssetsMorphs.morphs) {
            if (HumanAssetsMorphs.morphs.hasOwnProperty(morphId)) {
                HumanAssetsMorphs.destroyAsset(morphId);
            }
        }
    };

    function parseRawMorph(asset) {
        /*

         Morph format

         bytes   : info
         [0.. 3]: uint32; file type identifer (= 0x11)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph keys JSON
         [12..15]: uint32; byte-length of positions array
         [16..19]: uint32; byte-length of normals array
         [20..23]: uint32; byte-length of indices array
         [24..27]: uint32; byte-length of uv array
         [28..43]: unit32[4]; unused, reserved for future use
         [  ..  ]: text; asset id (tail-padded with empty spaces, e.g. 0x20)
         [  ..  ]: text; morph key JSON (tail-padded with 0x20)
         [  ..  ]: float32[]; positions array
         [  ..  ]: float32[]; normals array
         [  ..  ]: int32[];   indices array
         [  ..  ]: float32[]; uv array
         */

        var morph = {
            morphGeometry: {}
        };

        var index = new Uint32Array(asset, 0, 11);

        // var unusedFileType = index[0];
        var assetIdSize = index[1];
        var keysSize = index[2];
        var positionsSize = index[3];
        var normalsSize = index[4];
        var indicesSize = index[5];
        var uvsSize = index[6];
        // var unused = index[7 ... 10];

        var assetIdStart = 11  * Uint32Array.BYTES_PER_ELEMENT;
        var keysStart = assetIdStart + assetIdSize;
        var positionsStart = keysStart + keysSize;
        var normalsStart = positionsStart + positionsSize;
        var indicesStart = normalsStart + normalsSize;
        var uvsStart = indicesStart + indicesSize;

        var keys = morph.morphGeometry.keys = Human.utils.atoj(asset, keysStart, keysSize);

        var numKeys = keys.length;

        var target;
        var targets = morph.morphGeometry.targets = [];

        var targetPositionsSize = positionsSize / numKeys;
        var targetPositionsLength = targetPositionsSize / Float32Array.BYTES_PER_ELEMENT;

        var targetNormalSize = normalsSize / numKeys;
        var targetNormalLength = targetNormalSize / Float32Array.BYTES_PER_ELEMENT;

        var targetUVsSize = uvsSize / numKeys;
        var targetUVsLength = uvsSize / Float32Array.BYTES_PER_ELEMENT;

        for (var i = 0; i < numKeys; i++) {

            target = {};

            if (positionsSize > 0) {
                target.positions = new Float32Array(asset, positionsStart + (i * targetPositionsSize), targetPositionsLength);
            }

            if (normalsSize > 0) {
                target.normals = new Float32Array(asset, normalsStart + (i * targetNormalSize), targetNormalLength);
            }

            if (uvsSize > 0) {
                target.uvs = new Float32Array(asset, uvsStart + (i * targetUVsSize), targetUVsLength);
            }

            targets.push(target);
        }

        return morph;
    }

    var positionScaleMat = mat4.create();
    var positionTranslateMat = mat4.create();

    function parseCompressedMorph(asset) {
        /*
        # HEADER
         [0.. 3]: uint32; file type identifier (= 0x12)
         [4.. 7]: uint32; byte-length of padded asset id
         [8..11]: uint32; byte-length of padded morph JSON
        [12..15]: uint32; data segment offset (e.g. where DATA starts)
        [16..19]: uint32; indices offset
        [20..23]: uint32; byte-length of positions array
        [24..27]: uint32; byte-length of normals array
        [28..31]: uint32; byte-length of indices array
            [32]: uchar; byte-length of positions matrix elements (= 24)
            [33]: uchar; size (bytes) of indices type (e.g. 1, 2, 4)
            [34]: uchar; # of uv sets
            [35]: unused
        (36..39): uint32; byte-length of array for uv set 1
          ... repeat for uvs
        (  ..  ): uint32; byte-length of array for uv set n
            (  ): uchar; byte-length of uv set 1 matrix elements (= 16)
          ... repeat for uvs
            (  ): uchar; byte-length of uv set n matrix elements (= 16)
        (  ..  ): padding to align DATA to uint32; "unused" is obviated by data offset

        # DATA
        [  ..  ]: quad-char[]/text; asset id (tail-padded with empty spaces, e.g. 0x20)
        [  ..  ]: quad-char[]/text; morph JSON (tail-padded; includes extra info)
        [  ..  ]: float32[]; positions matrix elements
        (  ..  ): float32[]; uv set 1 matrix elements
          ... repeat for uvs
        (  ..  ): float32[]; uv set n matrix elements
        [  ..  ]: uint16[]; quantized positions array
        (  ..  ): uint16[]; quantized uv set 1 array
          ... repeat for uvs
        (  ..  ): uint16[]; quantized uv set n array
        (  ..  ): signed char[]; oct-encoded normals array
        (  ..  ): padding to align indices to uint32, which will work for all sizes
        (  ..  ): indices_t[]; indices array
        */

        var morph = {};

        var index = new DataView(asset);

        var assetIdSize = index.getUint32(4, true);
        var morphDataSize = index.getUint32(8, true);
        var dataOffset = index.getUint32(12, true);
        var positionsSize = index.getUint32(20, true);
        var normalsSize = index.getUint32(24, true);
        var positionDecodeSize = index.getUint16(32, true);
        var uvCount = index.getUint8(34);

        var uvIndex = new Array(uvCount);

        var bytePos, i;

        for (i = 0, bytePos = 36; i < uvCount; i++, bytePos += 5) {
            uvIndex[i] = {
                uvSize: index.getUint32(bytePos, true),
                uvDecodeSize: index.getUint8(bytePos + 4)
            };
        }

        // Start at position transform data
        bytePos = dataOffset + assetIdSize;

        morph.morphGeometry = Human.utils.atoj(asset, bytePos, morphDataSize);

        var keys = morph.morphGeometry.keys;
        var numKeys = keys.length;

        var targets = morph.morphGeometry.targets = new Array(numKeys);
        var target;

        for (i = 0; i < numKeys; i++) {
            targets[i] = {};
        }

        morph.positionTranslates = new Array(numKeys);
        morph.positionScales = new Array(numKeys);

        var targetPositionDecodeSize = positionDecodeSize / numKeys;

        var targetPositionsSize = positionsSize / numKeys;
        var targetPositionsLength = targetPositionsSize / Uint16Array.BYTES_PER_ELEMENT;

        var targetNormalSize = normalsSize / numKeys;
        var targetNormalLength = targetNormalSize / Int8Array.BYTES_PER_ELEMENT;

        bytePos += morphDataSize;

        if (positionDecodeSize > 0) {

            for (i = 0; i < numKeys; i++) {
                target = targets[i];

                var positionTranslate = morph.positionTranslates[i] = new Float32Array(asset, bytePos, 3);
                var positionScale = morph.positionScales[i] = new Float32Array(asset, bytePos + 12, 3);

                mat4.fromScaling(positionScaleMat, positionScale);
                mat4.fromTranslation(positionTranslateMat, positionTranslate);
                target.positionDecodeMat = mat4.create();

                mat4.multiply(target.positionDecodeMat, positionTranslateMat, positionScaleMat);

                bytePos += targetPositionDecodeSize;
            }
        }

        if (positionsSize > 0) {
            for (i = 0; i < numKeys; i++) {
                targets[i].positions = new Uint16Array(asset, bytePos + (i * targetPositionsSize), targetPositionsLength);
            }

            bytePos += positionsSize;
        }

        if (normalsSize > 0) {
            for (i = 0; i < numKeys; i++) {
                targets[i].normals = new Int8Array(asset, bytePos + (i * targetNormalSize), targetNormalLength);
            }
        }

        return morph;
    }

})();
;(function() {
    "use strict";

    /**
     * An animation comprised of a set of morphs, which may be installed into the {@link Human.timeline}.
     * Like all such animations, it has an {@link #update} method through which the timeline updates the
     * progress of the morphs. The morphs each contain a {@link SceneJS.MorphGeometry} and possibly
     * a {@link SceneJS.Geometry}, which are kept externally in a {@link Human.assets.morphs}.
     *
     * @class
     * @constructor
     * @private
     */
    Human.assets.morphs.Animation = function (cfg) {
        cfg = cfg || {};

        this.type = "morph-animation";
        this._loop = (cfg.loop !== false);
        this._morphList = [];
        this.timeline = cfg.timeline;
        this.firstTime = null;
        this.lastTime = null;
    };

    /**
     * Adds a morph to this animation
     * @param firstTime First time key
     * @param lastTime Last time key
     * @param update Callback to update the morph progress
     */
    Human.assets.morphs.Animation.prototype.addMorph = function (firstTime, lastTime, update) {
        this._morphList.push({ firstTime:firstTime, lastTime:lastTime, update:update  });
    };

    /**
     * Calculates time frame enclosing keys of all contained morphs
     * @return {*}
     */
    Human.assets.morphs.Animation.prototype.calculateTimeFrame = function () {
        var min = 1000000;
        var max = -1000000;
        var morph;
        var morphList = this._morphList;
        for (var i = 0, len = this._morphList.length; i < len; i++) {
            morph = morphList[i];
            if (morph.firstTime < min) {
                min = morph.firstTime;
            }
            if (morph.lastTime > max) {
                max = morph.lastTime;
            }
        }

        this.firstTime = min;
        this.lastTime = max;
    };

    /**
     * Updates progress of morphs
     * @param ctx
     * @param time
     */
    Human.assets.morphs.Animation.prototype.update = function (ctx, time) {
        var morph;
        var time2;
        for (var i = 0, len = this._morphList.length; i < len; i++) {
            morph = this._morphList[i];
            if (this._loop) {
                // Dont wrap when time is right on the last key
                time2 = (time === morph.lastTime) ? time : (morph.firstTime + time % (morph.lastTime - morph.firstTime));
            } else {
                if (time2 < morph.firstTime) {
                    time2 = morph.firstTime;
                }
                if (time2 > morph.lastTime) {
                    time2 = morph.lastTime;
                }
            }
            morph.update(time2);
        }
    };

    /**
     * Destroys this module
     */
    Human.assets.morphs.Animation.prototype.destroy = function () {
        this.destroyed = true;
    };
})();
;(function () {
    "use strict";

    /**
     * @namespace Loads and unloads lights to and from {@link Human.view.lights}.
     *
     * Loads lights in batches for models (states). When loading a batch, will immediately enable those lights, then
     * push a record of those lights onto a stack.
     *
     * After unloading a batch of lights for a model, will remove that batch from the stack, then
     * enable the batch (if any) that remains on the top of the stack.
     *
     * @private
     */
    var lightAssets = Human.assets.lights = {
        lightIds: {}
    };

    /**
     * Loads a library of light sources
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    lightAssets.parseLibrary = function (libId, manifest, params, ok) {

        var lightIds = lightAssets.lightIds[libId];

        if (lightIds) {
            // Should have hit cache at higher level
            Human.log.warn("Human.assets.lights.parseLibrary", "library already loaded");
            ok();
            return;
        }

        var lights = manifest.lights;

        if (!lights) {
            Human.log.error("Human.assets.lights.parseLibrary", "'lights' section expected in lights library");
            ok();
            return;
        }

        lightIds = lightAssets.lightIds[libId] = [];

        // Disable any lights already enabled
        Human.view.lights.clearEnabled(); 

        var light;
        var lightId;

        for (var i = 0, len = lights.length; i < len; i++) {

            light = lights[i];

            if (!light.lightId) {

                // Skip invalid light
                Human.log.error("Human.assets.lights.load", "'lightId' missing on light");
                ok();
                continue;
            }

            lightId = libId + "." + light.lightId;

            light.lightId = lightId;
            light.enabled = true;

            Human.view.lights.addLight(light);

            lightIds.push(lightId);
        }

        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a lights library.
     *
     * @param libId ID of lights library to unload.
     */
    lightAssets.unloadLibrary = function (libId) {

        var lightIds = lightAssets.lightIds[libId];

        if (!lightIds) {
            Human.log.warn("Human.assets.lights.unloadLibrary", "library not loaded");
            return;
        }

        var i;
        var len;
        var lights = Human.view.lights;

        for (i = 0, len = lightIds.length; i < len; i++) {
            lights.removeLight(lightIds[i]);
        }

        delete lightAssets.lightIds[libId];
    };
})();
;(function() {
    "use strict";

    var tweenAssets = Human.assets.tweens = {};

    /**
     * Loads a tweens library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    tweenAssets.parseLibrary = function (libId, manifest, params, ok) {
        var tweenDefs = manifest.tweens || {};
        var tweenDef;
        var type;
        var tweenType;
        var controlType;
        var tokens;
        var control;
        var tween;
        var tweens = [];

        var modelId = libId.split("/")[0];
        var leaf;

        if (!Human.timeline.leafTimelines.hasOwnProperty(modelId)){
            leaf = new Human.timeline.LeafTimeline(modelId);
        }

        for (var tweenName in tweenDefs) {
            if (tweenDefs.hasOwnProperty(tweenName)) {

                tweenDef = tweenDefs[tweenName];

                // Validate tween data

                if (!tweenDef.keys) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'keys'");
                    continue;
                }

                if (!tweenDef.targets) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'targets'");
                    continue;
                }

                if (tweenDef.keys.length < 2 || tweenDef.targets.length < 2) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "tween has insufficient keys or targets - minimum of two required");
                    continue;
                }

                if (tweenDef.keys.length !== tweenDef.targets.length) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "tween has mismatching numbers of keys and targets");
                    continue;
                }

                tweenDef.options = Human.utils.applyIf(this.options, tweenDef.options || {});

                type = tweenDef.type;

                if (!type) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute missing: 'type'");
                    continue;
                }

                tokens = type.split(":");

                tweenType = tokens[0];
                controlType = tokens[1];

                if (tweenType === "lerp") {
                    tweenType = "tween";
                }

                if (!tweenType || !controlType) {
                    Human.log.error("Human.timeline.tweenAnimationLoader", "Tween attribute invalid: 'type'");
                    continue;
                }

                // Create control strategy

                switch (controlType) {

                    // Tween attributes of a scene object

                    case "objectAttr":
                        control = new Human.timeline.ObjectControl({
                            modelId: modelId,
                            objectId: getAbsoluteID(modelId, tweenDef.objectId || tweenDef.targetId)
                        });
                        break;

                    // Tween attributes of a transform via a scene object

                    case "objectXForm":
                        control = new Human.timeline.ObjectTransformControl({
                            modelId: modelId,
                            objectId: getAbsoluteID(modelId, tweenDef.objectId || tweenDef.targetId),
                            initial: tweenDef.targets[0]
                        });
                        break;

                    // Tween attributes of a material

                    case "material":
                        control = new Human.timeline.MaterialControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId || tweenDef.targetId),
                            attributes: tweenDef.targets[0]
                        });
                        break;

                    // Tween attributes of a material's texture

                    case "texture":
                        control = new Human.timeline.TextureControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId || tweenDef.targetId),
                            targetLayer: tweenDef.targetLayer
                        });
                        break;

                    // Tween a frenel on a material

                    case "fresnel":
                        control = new Human.timeline.FresnelControl({
                            modelId: modelId,
                            materialId: getAbsoluteID(modelId, tweenDef.materialId),
                            fresnelType: tweenDef.fresnelType
                        });
                        break;

                    case "particleSystem":
                        control = new Human.timeline.ParticleSystemControl({
                            modelId: modelId,
                            particleSystemId: tweenDef.particleSystemId
                        });
                        break;

                    // Tween camera

                    case "camera":
                        control = new Human.timeline.CameraControl();
                        break;

                    default:
                        Human.log.error("Human.timeline.tweenAnimationLoader", "Unsupported tween type: " + type);
                        continue;
                }

                // Create tween

                switch (tweenType) {

                    case "tween":
                        tween = new Human.timeline.Tween({
                            keys: tweenDef.keys,
                            targets: tweenDef.targets,
                            control: control
                        });
                        break;

                    case "switch":
                        tween = new Human.timeline.Switch({
                            keys: tweenDef.keys,
                            targets: tweenDef.targets,
                            control: control
                        });
                        break;

                    default:
                        Human.log.error("Human.timeline.tweenAnimationLoader", "Unsupported tween type: " + type);
                        continue;
                }

                tweens.push(tween);
            }
        }

        if (tweens.length > 0) {

            // Create tween animation
            // Only if we have valid tweens

            var animation = new Human.timeline.TweenAnimation({
                tweens: tweens
            });

            // Add to timeline

            Human.timeline.addAnimation(libId, animation);
        }

        leaf = Human.timeline.leafTimelines[modelId];
        leaf.addAnimation(libId, Human.timeline.animations[libId]); // add to leaf

        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a tweens library.
     *
     * @param libId ID of library to unload.
     */
    tweenAssets.unloadLibrary = function(libId) {
        var modelId = libId.split("/")[0];

        // Delete Tweens From Leaf Timelines
        Human.timeline.leafTimelines[modelId].unload("tweens");
    };

    /**
     * Converts an ID to an absolute ID if necessary.
     *
     * If the element ID has no "." then it is the relative ID of an element
     * within the given model. Otherwise, it will be the absolute ID of element
     * in another model.
     */
    function getAbsoluteID(modelId, elementId) {
        return (elementId.indexOf(".") < 0) ? modelId + "-" + elementId : elementId;
    }

})();
;/**
 * @namespace Reflection libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsReflections = Human.assets.reflections = {};

    // Array of reflection IDs for each library, used for unloading
    var libReflectionIds = {};

    /**
     * All reflections
     */
    HumanAssetsReflections.reflections = {};

    /**
     * Reflection IDs exported by #exportReflectionIds; a map of exported IDs to real asset IDs
     *
     * @type {{String:String}}
     * @deprecated
     */
    HumanAssetsReflections.exportedReflectionIds = {};

    // Holds all SceneJS nodes for reflections
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Reflections library" // For debugging
            });
        });

    /**
     * Loads a reflections library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    HumanAssetsReflections.parseLibrary = function (libId, manifest, params, ok) {

        var reflectionIds = libReflectionIds[libId];

        if (reflectionIds) {

            // Should have hit cache at higher level
            Human.log.warn("Human.assets.reflections.parseLibrary", "library already loaded");

            ok();
            return;
        }

        reflectionIds = [];
        libReflectionIds[libId] = reflectionIds;

        var parts = libId.split("/");
        var imagePath = "/content/states/" + parts[0] + "/reflections/" + parts[1] + "/";
        var reflectionParams;
        var srcList;
        var reflectionId;
        var reflection;

        var graph = Human.renderer.graph;

        for (var key in manifest) {
            if (manifest.hasOwnProperty(key)) {

                reflectionParams = manifest[key];

                reflectionParams.type = "reflect";
                reflectionParams.blendMode = reflectionParams.blendMode || "add";

                srcList = reflectionParams.src;

                if (!srcList) {
                    Human.log.error("Human.assets.reflections.loader", "Reflection property missing: src");
                    continue;
                }

                if (!Human.utils.isArray(srcList)) {
                    Human.log.error("Human.assets.reflections.loader", "Reflection property should be array: src");
                    continue;
                }

                for (var i = 0, len = srcList.length; i < len; i++) {
                    srcList[i] = imagePath + srcList[i] + "?v=" + Human.VERSION;
                }

                reflectionId = libId + "." + key;

                reflection = {
                    node: graph.insertNode(graph.rootNodes.library, reflectionParams)
                };

                HumanAssetsReflections.reflections[reflectionId] = reflection;

                reflectionIds.push(reflectionId);
            }
        }

        // Subsequently-loaded materials will need our reflections to exist, so render a frame
        // to force the creation of the reflections' nodes in the scene graph
        Human.renderer.compile();

        if (ok) {
            ok();
        }
    };

    /** Only once reflections are activated and mapped to names can they be used
     * <p>Enable materials to use a particular reflection when they have a "reflectionId" set to "myReflection":</p>
     * <pre>
     *     #exportReflections({
     *          "myReflection" : "someState.someReflectionLib.someReflectionId"
     *          });
     * </pre>
     *
     * @param mapping
     */
    HumanAssetsReflections.exportReflections = function (mapping) {
        mapping = mapping || {};

        for (var key in mapping) {
            if (mapping.hasOwnProperty(key)) {
                var value = mapping[key];
                if (value.indexOf("/") === -1) {
                    mapping[key] = value.replace(/^([^\.]+)\./, "$1/");
                }
            }
        }

        HumanAssetsReflections.exportedReflectionIds = mapping || {};
    };

    /**
     * Unloads a reflections library.
     *
     * @param libId ID of reflections library to unload.
     */
    HumanAssetsReflections.unloadLibrary = function (libId) {

        var reflectionIds = libReflectionIds[libId];

        if (!reflectionIds) {
            Human.log.warn("Human.assets.reflections.unloadLibrary", "library not loaded");
            return;
        }

        var i;
        var len;
        var reflectionId;
        var reflection;

        for (i = 0, len = reflectionIds.length; i < len; i++) {
            reflectionId = reflectionIds[i];
            reflection = HumanAssetsReflections.reflections[reflectionId];
            reflection.node.destroy();
        }

        delete libReflectionIds[libId];
    };
})();
;(function() {
    "use strict";

    /**
     * @namespace Loads and unloads audio to and from {@link Human.media.audio}.
     *
     * @private
     */
    var audioAssets = Human.assets.audio = {};

    /**
     * Loads an audio clips library
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    audioAssets.parseLibrary = function (libId, manifest, params, ok) {
        Human.media.audio.createLibrary(libId, manifest);
        if (ok) {
            ok();
        }
    };

    /**
     * Unloads an audio clips library
     * @param libId Library ID
     */
    audioAssets.unloadLibrary = function (libId) {
        Human.media.audio.destroyLibrary(libId);
    };

})();
;(function() {
    "use strict";

    /**
     * @namespace Loads and unloads video to and from {@link Human.media.video}.
     *
     * @private
     */
    var videoAssets = Human.assets.video = {};

    /**
     * Loads a video clips library
     *
     * @param libId Library ID
     * @param manifest Library manifest
     * @param params Options applied while loading
     * @param ok Callback fired on completion
     */
    videoAssets.parseLibrary = function (libId, manifest, params, ok) {
        Human.media.videos.createLibrary(libId, manifest);
        if (ok) {
            ok();
        }
    };

    /**
     * Unloads a video clips library
     * @param libId Library ID
     */
    videoAssets.unloadLibrary = function (libId) {
        Human.media.videos.destroyLibrary(libId);
    };

})();
;/**
 @namespace Captures and restores engine state to and from JSON bookmark objects.

 */
(function () {
    "use strict";

    var HumanBookmarks = Human.bookmarks = {};

    /**
     * Captures the current engine state to a JSON bookmark object
     * <h4>Examples</h4>
     * <p>Capture everything:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture();
     * </pre>
     * <p>Capture just camera and view modes:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture({
     *         camera: true,
     *         view: true
     *     });
     * </pre>
     * <p>Capture everything but view modes:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture({
     *         view: false
     *     });
     * </pre>
     * @memberof Human.bookmarks
     * @param {{String: Boolean}} mask Mask which specifies what to capture in the bookmark
     * @param {Boolean} mask.modules Capture what modules are loaded?
     * @param {Boolean} mask.camera Capture camera state?
     * @param {Boolean} mask.modes Capture view modes?
     * @param {Boolean} mask.objects Capture scene object states?
     * @param {Boolean} mask.annotations Capture annotations?
     * @returns {{}} The JSON bookmark object
     */
    HumanBookmarks.capture = function (mask) {
        var bm = {
            engineVersion: Human.VERSION
        };
        if (masked(mask, "modules")) {
            bm.modules = {
                moduleLibs: captureModuleLibs(),
                activeModules: captureActiveModules()
            };
        }
        if (masked(mask, "modes")) {    
            bm.modes = captureViewModes();    
        }
        if (masked(mask, "camera")) {
            bm.camera = captureCamera();
        }
        if (masked(mask, "clips")) {
            bm.clips = captureCrossSections();
        }
        if (masked(mask, "objects")) {
            bm.objects = captureObjectStates();
        }
        if (masked(mask, "annotations")) {
            bm.annotations = captureAnnotations();
        }
        if (masked(mask, "timeline")) {
            bm.timeline = Human.timeline.getBookmark();
        }

        if (masked(mask, "background")) {
            bm.background = {
                colors: Human.renderer.bg.getBGColor()
            };
        }

        // Plugins are free to read and write state anywhere in a bookmark, but we'll
        // define a convenient namespace as a convention that they may opt to stay within.
        bm.plugins = {};

        var plugins = Human.plugins;
        var plugin;
        for (var id in plugins) {
            if (plugins.hasOwnProperty(id)) {
                plugin = plugins[id];
                if (plugin.writeBookmark) {
                    plugin.writeBookmark(bm);
                }
            }
        }
        return bm;
    };

    function masked(mask, key) {
        if (!mask) {
            return true;
        }
        if (mask[key] === true) {
            return true;
        }
        if (mask[key] === false) {
            return false;
        }
        return false;
    }

    /**
     * Bookmarks which module libraries are currently loaded
     */
    function captureModuleLibs() {
        var obj = Human.modules.moduleLibs;
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    }

    /**
     * Bookmarks which modules are currently active
     */
    function captureActiveModules() {
        var modules = [];
        if (Human.modules.numActiveModules > 0) {
            var activeModules = Human.modules.activeModules;
            for (var moduleId in activeModules) {
                if (activeModules.hasOwnProperty(moduleId)) {
                    modules.push(moduleId);
                }
            }
        }
        return modules;
    }

    /**
     * Bookmarks current state of the camera
     * @return {Object}
     */
    function captureCamera() {
        return Human.view.camera.getLookAt();
    }

    function captureViewModes() {    
        return {    
            dissect: Human.view.dissect.getEnabled(),   
            highlight: Human.view.highlight.getEnabled(),   
            isolate: Human.view.isolate.getEnabled(),   
            labels: Human.view.labels.getEnabled(),   
            xray: Human.view.xray.getEnabled(),   
            singlePick: Human.view.pick.getSinglePickEnabled(),   
            multiPick: Human.view.pick.getMultiPickEnabled()    
        };    
    }

    /**
     * Bookmarks current state of cross-section planes
     * @return {Object} Map containing state of each clip plane, mapped to the plane IDs
     */
    function captureCrossSections() {
        var clips = Human.view.clip.clips;
        var clip;
        var map = {};
        for (var clipId in clips) {
            if (clips.hasOwnProperty(clipId)) {
                clip = clips[clipId];
                map[clipId] = {
                    clipId: clip.clipId,
                    type: clip.type,
                    progress: clip.progress,
                    state: clip.state
                };
            }
        }
        return map;
    }

    /**
     * Bookmarks current visibility, selection and transparency states of scene objects
     * @return {Object} Map containing set of flags for each object
     */
    function captureObjectStates() {
        var map = {};
        var anatomy = Human.scene;
        var objects = anatomy.objects;
        var object, transform;
        var enabledObjects = anatomy.enabledObjects;
        var selectedObjects = anatomy.selectedObjects;
        var mapData;
        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                object = objects[objectId];
                mapData = null;

                // Only capture enabled leaf objects
                if (object.objects.length === 0 && enabledObjects[objectId]) {
                    mapData = mapData || {};

                    mapData.enabled = true;
                    mapData.selected = !!selectedObjects[objectId];

                    transform = captureTransformData(object);
                    if (transform) {
                        mapData.transform = transform;
                    }
                    mapData.opacity = object.opacity;
                }
                if (mapData) {
                    map[objectId] = mapData;
                }
            }
        }

        for (var idx=0; idx < Human.scene.rootObjects.length; idx++) {
          object = Human.scene.rootObjects[idx];
          objectId = object.objectId;
          if (!object.shown){
            // make sure these never get turned on, during restore
            map[objectId] = {
              enabled: object.shown,
              selected: object.selected,
              opacity: object.opacity
            };
          }

        }
        return map;
    }

    function captureTransformData(object) {
        if (object.pivot === null) {
            // Object transform not initialized
            return null;
        }

        var mapTransform = {};

        if (object.pivot.x !== 0) {
            mapTransform.pivot = mapTransform.pivot || {};
            mapTransform.pivot.x = object.pivot.x;
        }
        if (object.pivot.y !== 0) {
            mapTransform.pivot = mapTransform.pivot || {};
            mapTransform.pivot.y = object.pivot.y;
        }
        if (object.pivot.z !== 0) {
            mapTransform.pivot = mapTransform.pivot || {};
            mapTransform.pivot.z = object.pivot.z;
        }

        if (object.translate.x !== 0) {
            mapTransform.translate = mapTransform.translate || {};
            mapTransform.translate.x = object.translate.x;
        }
        if (object.translate.y !== 0) {
            mapTransform.translate = mapTransform.translate || {};
            mapTransform.translate.y = object.translate.y;
        }
        if (object.translate.z !== 0) {
            mapTransform.translate = mapTransform.translate || {};
            mapTransform.translate.z = object.translate.z;
        }

        if (object.scale.x !== 1) {
            mapTransform.scale = mapTransform.scale || {};
            mapTransform.scale.x = object.scale.x;
        }
        if (object.scale.y !== 1) {
            mapTransform.scale = mapTransform.scale || {};
            mapTransform.scale.y = object.scale.y;
        }
        if (object.scale.z !== 1) {
            mapTransform.scale = mapTransform.scale || {};
            mapTransform.scale.z = object.scale.z;
        }

        if (object.rotate.x !== 0) {
            mapTransform.rotate = mapTransform.rotate || {};
            mapTransform.rotate.x = object.rotate.x;
        }
        if (object.rotate.y !== 0) {
            mapTransform.rotate = mapTransform.rotate || {};
            mapTransform.rotate.y = object.rotate.y;
        }
        if (object.rotate.z !== 0) {
            mapTransform.rotate = mapTransform.rotate || {};
            mapTransform.rotate.z = object.rotate.z;
        }

        if (Object.keys(mapTransform).length > 0) {
            return mapTransform;
        } else {
            return null;
        }
    }

    /** Bookmarks current annotations
     * @return {Array} List containing a set of properties for each annotation
     */
    function captureAnnotations() {
        var list = [];
        var annotations = Human.view.annotations.annotations;
        var annotation;
        var item;
        var slice = Array.prototype.slice;
        for (var annotationId in annotations) {
            if (annotations.hasOwnProperty(annotationId)) {
                annotation = annotations[annotationId];
                if (annotation.saved) {
                    item = {
                        annotationId: annotationId,
                        title: annotation.label.title,
                        description: annotation.label.description,
                        pos: slice.call(annotation.pin.pos),
                        pinVec: slice.call(annotation.pin.dir),
                        shown: annotation.pin.shown,
                        labelShown: annotation.label.shown,
                        labelOffset: slice.call(annotation.label.offset),
                        occludable: annotation.occludable,
                        primitiveIndex: annotation.pin.primitiveIndex,
                        barycentric: annotation.pin.barycentric
                    };
                    if (annotation.object) {
                        item.objectId = annotation.object.objectId;
                    }
                    list.push(item);
                }
            }
        }
        return list;
    }

    /* Returns the objects from a module to restore during bookmark activation
    * object id must be shown or enabled in bookmark
    * normalized objectId must exist in Human.scene.objects
    */
    function _buildAssetObjects(bookmark){
      var loadObjects = [];
      var sync = bookmark.objects;
      var objId;

      if (Human.modules.isBaseModule(bookmark.theModuleId)) {
        // base anatomy - dont load EVERYTHING
        for (objId in sync) {
          if (sync.hasOwnProperty(objId) && (sync[objId].shown || sync[objId].enabled)) {
              objId = Human.modules.convertBaseAnatomyObjectId(objId);
              if (!!Human.scene.objects[objId]) {
                  loadObjects.push(Human.scene.objects[objId]);
              }
          }
        }
      } else {
        // regular module - go ahead and be sure everything is loaded
        if (Human.modules.moduleData.hasOwnProperty(bookmark.theModuleId)) {
          var objects = Human.modules.moduleData[bookmark.theModuleId].sceneGraph;
          for (var i=0; i<objects.length; i++) {
            objId = objects[i].objectId;
            if (Human.scene.objects.hasOwnProperty(objId)) {
              loadObjects.push(Human.scene.objects[objId]);
            }
          }
        }
      }

      return loadObjects;
    }

    function trimUntargetedChapters(moduleId, bookmark){
      var time = 0;
      var root = Human.timeline.rootTimelines[moduleId];
      if (bookmark.timeline) {
        if (bookmark.timeline.hasOwnProperty("scrub")) {
          try {
            time = bookmark.timeline.scrub.time;
          } catch(err) {
            time = 0;
          }

        } else if (bookmark.timeline.hasOwnProperty("play")) {
          var pi = bookmark.timeline.play;
          // pi.root = root;
          try {
            time = Human.timeline.parsePlayInstruction(pi).t;
          } catch(err){
            time = 0;
          }

        }
      }

      var chapterIndex = root.mapGlobalTime(time).index;

      //root._chapters = [Human.modules.modules[moduleId].chapters[chapterIndex]];
      root._chapters = [root._chapters[chapterIndex]];
      root.build();
    }

    function _bookmarkModuleActivationCallback(bookmark, moduleId, ok) {
      // now show the results of the changes

      //overwrite graph
      restoreGraph(bookmark.objects);
      
      // set modes
      restoreModes(bookmark.modes);
      

      // overwrite camera
      restoreCamera(bookmark.camera, function() {});

      Human.renderer.resumeCompilation();
      Human.renderer.popPause();

      if (!moduleId || moduleId === undefined) {
          if (ok) {
              ok();
          }
          return;
      }

      var loadObjects = _buildAssetObjects(bookmark);
      var assetTypes = ["tweens", "reflections", "audio", "videos", "lights", "skyBoxes", "geometry", "material", "transform", "morph"];
      Human.modules.load(moduleId, loadObjects, assetTypes, function(){
          //overwrite transforms
          restoreObjectTransforms(bookmark.objects);

          // set clipping planes
          restoreCrossSections(bookmark.clips);

          // overwrite annotations
          var isOwner = bookmark['is_owner'] || false;
          restoreAnnotations(bookmark.annotations, isOwner);

          playTimeline(bookmark);
          Human.events.fire("bookmarks.restored", bookmark);
          if(ok) {
              ok();
          }
      });

    }

    HumanBookmarks.restore = function(bookmark, ok) {
        Human.events.fire("bookmarks.restoring");

        // We have an oldie
        if(!Human.utils.isObject(bookmark.modules)) {
            normalizeLegacy(bookmark);
        }

        // HACK: Client Side data migration of bookmarks.
        // Old bookmarks referencing states (maleAdult) that newer engines don't understand.
        var activeModules = bookmark.modules.activeModules;
        var multipleModules = activeModules.length > 1;
        var activeModulesClone = [];

        for (var i = 0, len = activeModules.length; i < len; i++) {
          activeModulesClone[i] = Human.modules.convertBaseAnatomyModuleId(activeModules[i]);
        }

        Human.utils.filterInPlace(activeModulesClone, function(moduleId) {
            if (Human.modules.activeModules[moduleId]) {
                return false;
            }

            if (multipleModules && Human.modules.isBaseModule(moduleId)) {
                return false;
            }

            return true;
        });

        // Custom Loading Options
        var moduleId = activeModulesClone[0];
        var modConfig = {
            camera: true,
            graph: true,
            annotations: true,
            properties: true,
            time: true,
            hotspots: true
        };

        bookmark.theModuleId = moduleId;

        // Load Module Life Cycle
        Human.renderer.pushPause();
        Human.renderer.pauseCompilation();

        if (!moduleId){ // Scene Restore

          _bookmarkModuleActivationCallback(bookmark, moduleId, ok);

        } else if (Human.modules.modules.hasOwnProperty(moduleId)){
          var moduleData = Human.modules.moduleData[moduleId];
          Human.modules.create(moduleId, moduleData, function(){
            trimUntargetedChapters(moduleId, bookmark);
            Human.modules.activate(moduleId, 0, modConfig, function(){
                _bookmarkModuleActivationCallback(bookmark, moduleId, ok);
            });
          });
        } else {
          Human.modules.fetch(moduleId, function() {
              var moduleData = Human.modules.moduleData[moduleId];
              Human.modules.create(moduleId, moduleData, function() {
                  trimUntargetedChapters(moduleId, bookmark);
                  Human.modules.activate(moduleId, 0, modConfig, function() {
                    _bookmarkModuleActivationCallback(bookmark, moduleId, ok);
                });
              });
          });
        }
    };


    //////////////////////////////////////////////////////
    // HANDLE LEGACY BOOKMARKS
    //////////////////////////////////////////////////////

    // Some Normalization of the synchronization data
    function normalizeSynchronization(bookmarkObjects){
        var objectId, normalizedObjectId;
        var synchronization = {};
        var bookmarkDef;
        var idx;

        // start with assuming all are false
        for (objectId in Human.scene.objects) {
          if (Human.scene.objects[objectId]) {
            synchronization[objectId] = {shown:false};
            Human.scene.objects[objectId].numEnabledSubObjects = 0;
          }
        }

        var ancestorsToShow = [];
        for (objectId in bookmarkObjects){
            if (bookmarkObjects.hasOwnProperty(objectId)){

                bookmarkDef = bookmarkObjects[objectId];
                normalizedObjectId = Human.modules.convertBaseAnatomyObjectId(objectId);
                var object = Human.scene.objects[normalizedObjectId];

                if (object) {

                    if (bookmarkDef.hasOwnProperty("enabled")){
                        bookmarkDef.shown = bookmarkDef.enabled;
                        delete bookmarkDef.enabled;
                    }

                    if (!bookmarkDef.hasOwnProperty("pickable")) {
                        bookmarkDef.pickable = object.pickable;
                    }

                    if (!bookmarkDef.hasOwnProperty("backfaces")) {
                        bookmarkDef.backfaces = object.backfaces;
                    }

                    if (!bookmarkDef.hasOwnProperty("opacity")) {
                        bookmarkDef.opacity = object.opacity;
                    }

                    bookmarkDef.glassFactor = object.glassFactor;
                    bookmarkDef.murkiness = object.murkiness;

                    if (object.isLeaf() && bookmarkDef.shown && object.parent) {
                      Human.scene._updateAncestorSubObjects(object.parent, true);
                      if (ancestorsToShow.indexOf(object.parent.objectId)<0 ) {
                        var ancestors = getAncestors(normalizedObjectId);
                        for (idx=0; idx < ancestors.length; idx++) {
                          if (ancestorsToShow.indexOf(ancestors[idx])<0) {
                            ancestorsToShow.push(ancestors[idx]);
                          }
                        }
                      }
                    }
                    synchronization[normalizedObjectId] = bookmarkDef;
                }
            }
        }

        for (idx=0; idx < ancestorsToShow.length; idx++) {
          synchronization[ancestorsToShow[idx]].shown = true;
        }
        return synchronization;
    }


    function normalizeLegacy(bookmark) {
        bookmark.modules = {};
        bookmark.modules.activeModules = [];
        bookmark.modules.moduleLibs = [];

        if(!Human.utils.isObject(bookmark.objects)) {
            bookmark.objects = {};
        }

        var genderModuleId = getGenderModule(bookmark.objects);

        if(genderModuleId) {
            bookmark.modules.activeModules.unshift(genderModuleId);
        }
    }

    function getGenderModule(objects) {
        var genderModuleId = null;
        var match;

        for (var id in objects) {
            if(objects.hasOwnProperty(id)) {
                match = id.match(/^(fe)?maleAdult/);
                if(match) {
                    genderModuleId = ['production', match[0], match[0] + '.json']
                    .join('/');

                    break;
                }
            }
        }

        return genderModuleId;
    }

    function getAncestors(objectId) {
      var ancestors = [];
      var hObject = Human.scene.objects[objectId].parent;
      while (hObject) {
        ancestors.push(hObject.objectId);
        hObject = hObject.parent;
      }
      return ancestors;
    }

    // ================== RESTORE FUNCTIONS =====================================
    function playTimeline(bookmark) {
        if (!bookmark.timeline) {
            Human.timeline.scrub({time:0.0});
            return;
        }
        if (bookmark.timeline.scrub) {
            Human.timeline.scrub(bookmark.timeline.scrub);
        } else if (bookmark.timeline.play) {
            Human.timeline.play(bookmark.timeline.play);
        }
    }

    /**
     * Loads camera position as given in bookmark
     * @param camera
     */
    function restoreCamera(camera, ok) {
        Human.view.camera.fly.flyTo(camera, function(){
            if (ok){
                ok();
            }
        });
    }

    /**
     * Loads viewing modes as given in bookmark
     * @param modes Flag for each view mode, indicating enable or disable
     */
    function restoreModes(modes) {
        if (!modes) {
          return;
        }

        if (modes.highlight !== undefined && modes.highlight !== null) {
            Human.rpc.call(null, "highlight.setEnabled", { enable: modes.highlight });
        }
        // Only enable isolate if objects are selected
        if (Human.scene.anySelected() && modes.isolate) {
            if (modes.isolate !== undefined && modes.isolate !== null) {
                Human.rpc.call(null, "isolate.setEnabled", { enable: modes.isolate  });
            }
        } else {
            if (modes.isolate !== undefined && modes.isolate !== null) {
                Human.rpc.call(null, "isolate.setEnabled", { enable: false  });
            }
        }
        if (modes.labels !== undefined && modes.labels !== null) {
            Human.rpc.call(null, "labels.setEnabled", { enable: modes.labels });
        }
        if (modes.singlePick !== undefined && modes.singlePick !== null) {
            Human.rpc.call(null, "pick.single.setEnabled", { enable: modes.singlePick });
        }
        if (modes.multiPick !== undefined && modes.multiPick !== null) {
            Human.rpc.call(null, "pick.multi.setEnabled", { enable: modes.multiPick });
        }

        if (modes.xray !== undefined && modes.xray !== null) {
            Human.rpc.call(null, "xray.setEnabled", { enable: modes.xray });
        }
    }

    /**
     * Restore the state of the current scene graph against the passed synchronization object.
     * @param synchronization Object of objectIds and their non-default states
     */
    function restoreGraph(synchronization){
        //Human.scene.setEnabledObjects({ objectIds: {}, replace: true });
        synchronization = normalizeSynchronization(synchronization);
        Human.scene.setObjectProperties(synchronization);

    }

    /**
     * Loads cross-section clip plane states as given in bookmark
     * @param clips Clip plane states, mapped to IDs of the planes
     */
    function restoreCrossSections(clips) {
        Human.view.clip.reset();
        for (var clipId in clips) {
            if (clips.hasOwnProperty(clipId)) {
                Human.view.clip.setClip(clips[clipId]);
            }
        }
    }

    /** Overwrites the transform position of objects in scene.
     *
     */
    function restoreObjectTransforms(objectData) {
        objectData = objectData || {};
        var object, objectId, transform;

        for (objectId in objectData) {
            if (objectData.hasOwnProperty(objectId)) {
                object = Human.scene.objects[objectId];
                transform = objectData[objectId].transform;
                if (object && transform) {
                    object.setTransform(restoreTransform(object, transform));
                }
            }
        }
    }

    function restoreTransform(object, transform) {
        var objectPivot = object.pivot || { x: 0, y: 0, z: 0 };
        var objectTranslate = object.translate || { x: 0, y: 0, z: 0 };
        var objectScale = object.scale || { x: 1, y: 1, z: 1 };
        var objectRotate = object.rotate || { x: 0, y: 0, z: 0 };

        transform.pivot = transform.pivot || {};
        transform.translate = transform.translate || {};
        transform.scale = transform.scale || {};
        transform.rotate = transform.rotate || {};

        transform.pivot.x = transform.pivot.x === undefined ? objectPivot.x : transform.pivot.x;
        transform.pivot.y = transform.pivot.y === undefined ? objectPivot.y : transform.pivot.y;
        transform.pivot.z = transform.pivot.z === undefined ? objectPivot.z : transform.pivot.z;

        transform.translate.x = transform.translate.x === undefined ? objectTranslate.x : transform.translate.x;
        transform.translate.y = transform.translate.y === undefined ? objectTranslate.y : transform.translate.y;
        transform.translate.z = transform.translate.z === undefined ? objectTranslate.z : transform.translate.z;

        transform.scale.x = transform.scale.x === undefined ? objectScale.x : transform.scale.x;
        transform.scale.y = transform.scale.y === undefined ? objectScale.y : transform.scale.y;
        transform.scale.z = transform.scale.z === undefined ? objectScale.z : transform.scale.z;

        transform.rotate.x = transform.rotate.x === undefined ? objectRotate.x : transform.rotate.x;
        transform.rotate.y = transform.rotate.y === undefined ? objectRotate.y : transform.rotate.y;
        transform.rotate.z = transform.rotate.z === undefined ? objectRotate.z : transform.rotate.z;

        return transform;
    }

    /**
     * Loads annotations as given in bookmark
     * @param annotations List of property sets, one for each annotation
     */
    function restoreAnnotations(annotations, isOwner) {
        var a;

        isOwner = (typeof isOwner === 'undefined') ? false : isOwner;

        for (var i = 0, len = annotations.length; i < len; i++) {
            a = annotations[i];
            Human.view.annotations.createAnnotation({
                annotationId: a.annotationId,
                objectId: a.objectId,
                title: a.title || "",
                description: a.description || "",
                pos: a.offset || a.pos,
                dir: a.pinVec,
                shown: a.shown,
                type: a.type,
                labelShown: a.labelShown,
                labelOffset: a.labelOffset,
                saved: true,
                isOwner: isOwner,
                occludable: a.occludable,
                primitiveIndex: a.primitiveIndex,
                barycentric: a.barycentric
            });
        }
    }


})();
;/**
 @namespace Handles module creation, activation, deactivation, destruction and query.

 <p>Modules are the engine's abstract unit of content. These are extensible and can be all sorts things, such as anatomies,
 disease conditions, guided tours, bookmarks, medline conditions etc.</p>
 */
(function () {
    "use strict";

    var MAX_HISTORY = 5;

    var HumanModules = Human.modules = {};

    // =========== MODULE MANAGEMENT =========================================
    // True once Human loaded
    var loaded;

    // Module IDs are internally generated from this pool
    var idPool = new Human.utils.IDPool();
    // Supports query for modules by tag matches
    // This just stores records of module IDs and tags
    var queryTagMap = new Human.utils.TagMapList();

    // Existing and Active modules
    HumanModules.modules = {};
    HumanModules.moduleData = {}; // stores module definitions
    HumanModules.moduleLibs = {};
    HumanModules.activeModules = {};
    HumanModules.numActiveModules = 0;
    HumanModules.history = [];

    // Make sure we don't try to create, activate or deactivate
    // modules until Human has loaded
    Human.events.on("loaded", function () {
        loaded = true;
    });

    // ========= MODULE LIFE CYCLE MANAGEMENT  ================================

    /* Get Module Data from the asset server
     * "ok" and "error" are callbacks
     */
    HumanModules.fetch = function(moduleId, ok, error){
        Human.events.fire("modules.fetch.start", {moduleId: moduleId});
        Human.assets.server.getModuleDefinition(moduleId, function (moduleData) {
                // Attach id to module data
                moduleData.moduleId = moduleId;
                HumanModules.moduleData[moduleId] = moduleData;
                Human.events.fire("modules.fetch.finish", {moduleId: moduleId, moduleData:moduleData});
                if (ok){
                    ok();
                }
            }, function(e){
                Human.log.info("Human.modules.activateModules", "Failed to activate module: '" + moduleId + "' - " + e);
                if (error) {
                    error(e);
                }
        });
    };


    /* Create the Module Object from the module data
     * "ok" is a callback function that accepts two parameters:
     *      1) moduleId
     *      2) Human Module (Human Object)
     */
    HumanModules.create = function(moduleId, moduleData, ok){
        Human.events.fire("modules.create.start", {moduleId:moduleId, moduleData:moduleData});

        if (HumanModules.modules[moduleId]){
            delete HumanModules.modules[moduleId];
        }
        // Create the Human Module Object
        var module = new HumanModules.Module(moduleData);
        var _ok = function() {
            HumanModules.modules[moduleId] = module;
            queryTagMap.addItem(moduleId, moduleData.tags || ["untagged"], module);
            Human.events.fire("modules.created", moduleData);
            Human.events.fire("modules.create.finish", {moduleId:moduleId, module:HumanModules.modules[moduleId]});
            if (ok){
                ok();
            }
        };

        module.create(_ok);

        HumanModules.history.unshift(moduleId);
        if (HumanModules.history.length > MAX_HISTORY) {
            HumanModules.history.pop();
        }
    };

    /* Activates the module according to configuration provided.
     *
     * Module activation simply sets up the scenegraph, the rootTimeline and steps into the rootTimeline
     *
     */
    HumanModules.activate = function(moduleId, time, config, ok){
        Human.events.fire("modules.activate.start", {moduleId:moduleId, config:config});
        Human.events.fire("modules.activating",{moduleId:moduleId});
        var _ok = function(){
            HumanModules.activeModules[moduleId] = HumanModules.modules[moduleId];
            HumanModules.numActiveModules++;
            Human.events.fire("modules.activated", {moduleId:moduleId}); // backwards compatibility.
            Human.events.fire("modules.activate.finish", {moduleId:moduleId});
            if (ok){
                ok();
            }
        };
        HumanModules.modules[moduleId].activate(time, config, _ok);
    };

    /* Loads requisite assets and asset libraries from CDB via graph traversal and module library requests
     *
     * Unlike other life cycle steps, this function operates on the scene graph
     */
    HumanModules.load = function(moduleId, graphNodes, assetTypes, ok){
        Human.events.fire("modules.load.start", {moduleId:moduleId, graphNodes:graphNodes, assetTypes:assetTypes});
        // wrap passed callback into new callback
        var _ok = function(){
            Human.events.fire("modules.load.finish",{moduleId:moduleId, graphNodes:graphNodes, assetTypes:assetTypes});
            if (ok){
                ok();
            }
        };
        HumanModules.modules[moduleId].load(graphNodes, assetTypes, _ok);
    };

    /* Unload assets from moduleId that are unique that module.
     */
    HumanModules.unload = function(moduleId, graphNodes, assetTypes, ok){
        Human.events.fire("modules.unload.start",{moduleId:moduleId, graphNodes:graphNodes, assetTypes:assetTypes});
        var _ok = function(){
            Human.events.fire("modules.unload.finish",{moduleId:moduleId, graphNodes:graphNodes, assetTypes:assetTypes});
            if (ok){
                ok();
            }
        };
        HumanModules.modules[moduleId].unload(graphNodes, assetTypes, _ok);
    };

    // Detaches module root from the active root
    HumanModules.deactivate = function(moduleId, config, ok){
        Human.events.fire("modules.deactivate.start", {moduleId:moduleId, config: config});
        var _ok = function(){
            delete HumanModules.activeModules[moduleId];
            HumanModules.numActiveModules--;
            Human.events.fire("modules.deactivated", {moduleId:moduleId});
            Human.events.fire("modules.deactivate.finish", {moduleId:moduleId});
            if (ok){
                ok();
            }
        };
        HumanModules.modules[moduleId].deactivate(config, _ok);
    };

    // Removes the module from memory, and calls module destroy which destroys root and branch timelines
    HumanModules.destroy = function(moduleId, ok){
        Human.events.fire("modules.destory.start", {moduleId:moduleId});
        if (!HumanModules.modules[moduleId]){
            Human.log.warn("Human.modules.destroyModule", "Module does not exist, cannot be destoryed: + " + moduleId);
        }
        else {
            var _ok = function(){
                delete HumanModules.modules[moduleId];
                queryTagMap.removeItem(moduleId);
                idPool.putId(moduleId);
                Human.events.fire("modules.destroy.finish",{moduleId:moduleId});
                if (ok){
                    ok();
                }
            };
            HumanModules.modules[moduleId].destroy(_ok);
        }

    };

    // NOTE[EM] - This is bad to bake in knowledge of our content management.
    /* BASE ANATOMY UTILITY METHODS */
    HumanModules.isBase = function (input) {
       var match = input.match(/^(femaleAdult|maleAdult|female_complete_anatomy|male_complete_anatomy)/);
       return match && match[0];
    };

    HumanModules.isBaseModule = function (input) {
       var parts = input.split('/');
       return HumanModules.isBase(parts[parts.length - 1]) ? input : false;
    };

   HumanModules.requiresBase = function (objectIds) {
       var baseFound = false;

       for (var i = 0; i < objectIds.length; i++) {
           baseFound = HumanModules.isBase(objectIds[i]);

           if(baseFound) {
               break;
           }
       }

       return baseFound;
   };


   /* STATE CONVERSION METHODS */
   var MALE_STATE_ID = HumanModules.MALE_STATE_ID = 'maleAdult_standard';
   var FEMALE_STATE_ID = HumanModules.FEMALE_STATE_ID = 'femaleAdult_standard';
   var MODULE_ID_CONVERSIONS = {
       "production/maleAdult/maleAdult.json": "production/maleAdult/maleAdult_standard.json",
       "production/maleAdult/femaleAdult.json": "production/maleAdult/femaleAdult_standard.json"
   };

   HumanModules.convertBaseAnatomyModuleId = function (moduleId) {
       return MODULE_ID_CONVERSIONS[moduleId] || moduleId;
   };

   HumanModules.convertBaseAnatomyStateId = function (stateId) {
       return stateId.replace(/^femaleAdult$/, FEMALE_STATE_ID)
           .replace(/^maleAdult$/, MALE_STATE_ID);
   };

   HumanModules.convertBaseAnatomyObjectId = function (objectId) {
       if(HumanModules.isBase(objectId)) {
           var parts = objectId.split('-');
           var stateId = HumanModules.convertBaseAnatomyStateId(parts[0]);

           objectId = [stateId, parts[1]].join('-');

           if(!/_ID$/.test(objectId)) {
               objectId += "_ID";
           }
       }

       return objectId;
   };

})();
;(function () {
    "use strict";

    // MODULE CREATION constructor
    var Module = Human.modules.Module = function (cfg) {

        // Metadata
        this.moduleId = cfg.moduleId;
        this.displayName = cfg.displayName || "";
        this.description = cfg.description || "";
        this.translations = cfg.translations || {};
        this.tags = cfg.tags || [];
        this.ui = cfg.ui || {};
        this.active = false;
        this.timeActivated = -1;

        // List of objectIds of objects created by this module
        this.rootObjects = [];

        // Specific to this module type
        this.animation = cfg.animation || {};
        this.camera = cfg.camera;
        this.jumpTo = cfg.jumpTo;
        this.flyTo = cfg.flyTo;
        var p = cfg.modelIds || cfg.stateId;
        this.modelIds = p ? (Human.utils.isArray(p) ? p : [p]) : [];
        this.showObjects = cfg.showObjects;
        this.selectObjects = cfg.selectObjects;
        this.pickThroughObjects = cfg.pickThroughObjects;
        this.xray = cfg.xray;
        this.effects = cfg.effects;
        this.properties = cfg.properties;
        this.swapped = false;
        this.swappedObjectId = null;
        this.background = cfg.background || null;
        this.customData = cfg.customData || {};
        this.cache = false;

        this.chapters = cfg.chapters || null;
        this.sceneGraph = cfg.sceneGraph;

        if (cfg.customData && cfg.customData.particleSystems) {
            this.particleSystems = cfg.customData.particleSystems;
        } else {
            this.particleSystems = [];
        }
        
        this.assetLibraries = cfg.assetLibraries;

        // Help track whether lights are defined and loaded
        this.hasLights = this.assetLibraries.hasOwnProperty('lights') && this.assetLibraries.lights.length > 0;

        // Maps reflection-id shorthand to true reflection asset. NOTE[EM] - parsing could be cleaned up in data
        this.reflections = cfg.reflections || {};
        for (var refid in this.reflections){
          if (this.reflections.hasOwnProperty(refid)){
            var ref = this.reflections[refid];
            var refparts = ref.split(".");
            ref = refparts[0] + "/" + refparts.slice(1).join(".");
            Human.assets.reflections.exportedReflectionIds[refid] = ref;
          }
        }

        this.objectState = cfg.objects || {}; // hook when module created from bookmark
        this.clips = cfg.clips || {};         // hook when module created from bookmark
        this.modes = cfg.modes || {};         // hook when module created from bookmark
    };

    // TODO[EM]: Find a better location for this
    function createSynchronization(chapter, defaultState){
        var objectId, prop;
        defaultState = defaultState || {"showObjects":{},"selectObjects":{},"pickThroughObjects":{}};
        var showObjects = chapter.showObjects || defaultState.showObjects || {};
        var selectObjects = chapter.selectObjects || defaultState.selectObjects || {};
        var pickThroughObjects = chapter.pickThroughObjects || defaultState.pickThroughObjects || {};

        var synchronization = {};

        // Collect Shown Objects
        prop = "shown";
        for (objectId in showObjects){
            if (showObjects.hasOwnProperty(objectId)){
                if (!synchronization.hasOwnProperty(objectId)){
                    synchronization[objectId] = {};
                }
                synchronization[objectId][prop] = showObjects[objectId];
            }
        }

        // Collect Selected Objects
        prop = "selected";
        for (objectId in selectObjects){
            if (selectObjects.hasOwnProperty(objectId)){
                if (!synchronization.hasOwnProperty(objectId)){
                    synchronization[objectId] = {};
                }
                synchronization[objectId][prop] = selectObjects[objectId];
            }
        }

        // Collect UnPickable Objects
        prop = "pickable";
        for (objectId in pickThroughObjects){
            if (pickThroughObjects.hasOwnProperty(objectId)){
                if (!synchronization.hasOwnProperty(objectId)){
                    synchronization[objectId] = {};
                }
                synchronization[objectId][prop] = !pickThroughObjects[objectId];
            }
        }

        return synchronization;

    }

    Module.prototype.create = function(ok){
        var self = this;
        var i, branch, root;


        // Construct the Scene graph for each root
        Human.scene.graph.buildGraph(self.sceneGraph, null, {});
        for (i=0; i< self.sceneGraph.length; i++){
            self.rootObjects.push( Human.scene.objects[self.sceneGraph[i].objectId]);
        }

        // Construct Root Timeline
        root = new Human.timeline.RootTimeline(self.moduleId);

        var modStateInstructions = {
          "showObjects": self.showObjects,
          "pickThroughObjects": self.pickThroughObjects,
          "selectObjects": self.selectObjects
        };

        // Construct Branch Timelines
        // TODO[EM]: consider prepending module name to branch-ids to ensure uniqueness
        for (i=0 ; i < self.chapters.length; i++){
            self.chapters[i].synchronization = createSynchronization(self.chapters[i], modStateInstructions);
            if (!self.chapters[i].hasOwnProperty("id")){
                self.chapters[i].id = self.moduleId + "_" + i;
            }
            branch = new Human.timeline.BranchTimeline(self.chapters[i]);
            root.addChapter(branch, { rebuild: false });
        }
        root.build();
        self.rootTimeline = root;

        Human.particles.parse(self.particleSystems);

        if (ok){
            ok();
        }
    };

    // TODO[EM]: Consult on time requirement
    Module.prototype.activate = function(time, config, ok){
        var self = this;
        self.timeActivated = Date.now();
        self.active = true;

        // Activate Object Transforms
        if (self.objectState){
            var objectId, objectState;
            for (objectId in self.objectState){
                if (self.objectState.hasOwnProperty(objectId)){
                    objectState = self.objectState[objectId];
                    // Set Transform
                    Human.scene.objects[objectId].setTransform(objectState);
                }
            }
        }

        // Activate Clipping Planes
        Human.view.clip.reset();
        if (self.clips){
            var clipId, clipState;
            for (clipId in self.clips){
                if (self.clips.hasOwnProperty(clipId)){
                    clipState = self.clips[clipId];
                    if (clipState.state !== "dormant" && clipState.progress > 0.0){
                        Human.view.clip.setClip(clipState);
                    }
                }
            }
        }

        // Activate View Modes - Use RPC
        // NOTE[EM] - anyway to reset view modes?
        if (self.modes){
            var modes = self.modes;
            if (modes.dissect !== undefined && modes.dissect !== null) {
                //   Human.rpc.call(null, "dissect.setEnabled", { enable: modes.dissect });
            }
            if (modes.highlight !== undefined && modes.highlight !== null) {
                Human.rpc.call(null, "highlight.setEnabled", { enable: modes.highlight });
            }
            // Only enable isolate if objects are selected
            if (Human.scene.anySelected() && modes.isolate) {
                if (modes.isolate !== undefined && modes.isolate !== null) {
                    Human.rpc.call(null, "isolate.setEnabled", { enable: modes.isolate  });
                }
            } else {
                if (modes.isolate !== undefined && modes.isolate !== null) {
                    Human.rpc.call(null, "isolate.setEnabled", { enable: false  });
                }
            }
            if (modes.labels !== undefined && modes.labels !== null) {
                Human.rpc.call(null, "labels.setEnabled", { enable: modes.labels });
            }
            if (modes.singlePick !== undefined && modes.singlePick !== null) {
                Human.rpc.call(null, "pick.single.setEnabled", { enable: modes.singlePick });
            }
            if (modes.multiPick !== undefined && modes.multiPick !== null) {
                Human.rpc.call(null, "pick.multi.setEnabled", { enable: modes.multiPick });
            }
            if (modes.xray !== undefined && modes.xray !== null) {
                Human.rpc.call(null, "xray.setEnabled", { enable: modes.xray });
            }
        }

        // Set Module-Level Properties
        if (self.properties){
          Human.properties.set(self.properties);
        }

        // Activate Timeline
        if (time !== false){
            self.rootTimeline.activate(time, config, ok);
        }

        Human.view.lights.clearEnabled(); 
        if (self.hasLights) {
            // NOTE(Tarek): If lights are already loaded, enabled them.
            var lightLibs = self.assetLibraries.lights;
            for (var i = 0, len = lightLibs.length; i < len; ++i) {
                if (Human.assets.lights.lightIds[lightLibs[i]]) {
                    var lightIds = Human.assets.lights.lightIds[lightLibs[i]];
                    var enableMap = {};
                    for (var j = 0, lenJ = lightIds.length; j < lenJ; ++j) {
                        enableMap[lightIds[j]] = true;
                    }
                    Human.view.lights.setEnabled({
                        lights: enableMap
                    });
                }
            }
            
        } else {
            Human.view.lights.restoreDefaults();
        }

    };

    /* Load all assets; whole asset libraries, and assets attached to scene graphs.
     *
     * This function will first load all asset libraries.
     * Once all asset libraries are downloaded, then the assets will be attached to the scene graph.
     *
     * NOTE: this "ok" callback will only be called when ALL assets are loaded
     *
     * NOTE[EM]: Lights are to be enabled on load - they are not otherwise 'activated' by module or chapters
     */
    Module.prototype.load = function(graphNodes, assetTypes, ok){
        var self = this, i=0,libType, numRequestedLibs = 0;

        // count the number of asset libraries to expect
        for (libType in self.assetLibraries){
            if (self.assetLibraries.hasOwnProperty(libType) && assetTypes.indexOf(libType)>=0){
                numRequestedLibs += self.assetLibraries[libType].length;
            }
        }

        if (numRequestedLibs > 0){
            // tracks the number of unloaded libraries, until all libraries are loaded before kicking off scene graph asset loading
            var countAssetLibs = function(){
                numRequestedLibs--;
                if (numRequestedLibs === 0){
                    Human.scene.graph.attachAssetSetsToSubtree(graphNodes, [assetTypes], ok);
                }
            };

            // kick off library requests
            if (self.assetLibraries.tweens && assetTypes.indexOf("tweens")>=0){
                for (i=0; i<self.assetLibraries.tweens.length; i++){
                    Human.assets.getAssetLibrary("animation","animations",self.assetLibraries.tweens[i],"manifest",{},countAssetLibs);
                }
            }
            if (self.assetLibraries.reflections && assetTypes.indexOf("reflections")>=0){
                for (i=0; i<self.assetLibraries.reflections.length; i++){
                    Human.assets.getAssetLibrary("reflection","reflections",self.assetLibraries.reflections[i],"outline",{},countAssetLibs);
                }
            }
            if (self.assetLibraries.lights && self.assetLibraries.lights.length > 0 && assetTypes.indexOf("lights") >= 0){
                for (i = 0; i < self.assetLibraries.lights.length; i++){
                    Human.assets.getAssetLibrary("light","lights",self.assetLibraries.lights[i],"outline",{}, countAssetLibs);
                }
            }
        } else {
            Human.scene.graph.attachAssetSetsToSubtree(graphNodes, [assetTypes], ok);
        }

    };

    /* Unload all assets; whole asset libraries, and assets attached to scene graphs.
     *
     * This function first unload all asset libraries.
     * Once all asset libarries are deleted, the assets attached to the scene graph will be removed.
     *
     * NOTE: this "ok" callback will only be called when ALL assets are removed.
     *
     * NOTE: assets on the graph are only fully deleted from memory when their reference count hits 0.
     */
    Module.prototype.unload = function(graphNodes, assetTypes, ok){
        var self = this;
        var i = 0;

        // Unloading is not asynchronous, so we don't need to track progress of unloading
        if (self.assetLibraries.tweens && assetTypes.indexOf("tweens")>=0){
            for (i=0; i<self.assetLibraries.tweens.length; i++){
                Human.assets.putAssetLibrary(self.assetLibraries.tweens[i]);
            }
        }
        if (self.assetLibraries.reflections && assetTypes.indexOf("reflections")>=0){
            for (i=0; i<self.assetLibraries.reflections.length; i++){
                Human.assets.putAssetLibrary(self.assetLibraries.reflections[i]);
            }
        }
        if (self.assetLibraries.lights && assetTypes.indexOf("lights")>=0){
            for (i=0; i<self.assetLibraries.lights.length; i++){
                Human.assets.putAssetLibrary(self.assetLibraries.lights[i]);
            }
        }

        Human.scene.graph.unloadSubtree(graphNodes, assetTypes, ok);
    };

    Module.prototype.deactivate = function (config, ok) {
        var self= this;
        self.timeActivated = -1;
        self.active = false;
        self.rootTimeline.deactivate(config, ok);
    };

    // Destroy the root timeline
    Module.prototype.destroy = function(ok){
        var self = this;
        self.rootTimeline.destroy();
        Human.scene.graph.destroySubtree(self.rootObjects);
        self = null;
        if (ok){
            ok();
        }
    };

})();
;/**
 @namespace Plugin registry.
 */
(function () {

    "use strict";

    Human.plugins = {};

    Human.addPlugin = function (id, plugin) {
        Human.plugins[id] = plugin;
    };
})();