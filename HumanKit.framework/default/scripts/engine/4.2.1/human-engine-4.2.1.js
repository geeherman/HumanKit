/**
 * @namespace The core engine namespace.
 */
(function () {
    "use strict";

    var Human = window.Human = {};

    var VERSION = "4.2.1";
    VERSION = VERSION.indexOf("ENGINE_VERSION") > 0 ? "qa" : VERSION;

    /**
     * Engine version.
     *
     * @memberof Human
     * @name VERSION
     * @property
     * @type {string}
     */
    Human.VERSION = VERSION;

    /** True when this engine instance is running on the Web
     *
     * @type {boolean}
     * @memberof Human
     */
    Human.deployed = ( window.location.hostname === "localhost" || 
        /192\.168\.11\.\d{1,3}/.test(window.location.hostname) || 
        window.location.protocol === "file:" ) ? false : true;

    /* IDs of nodes in the document and scene graph    
     */
    Human.CANVAS_ID = "theCanvas";
    Human.CONTAINER_ID = "container";
    Human.SCENE_ROOT_ID = "bds-human";
    Human.CONTENT_ROOT_ID = "outline";
    Human.MATERIAL_ROOT_ID = "human.outline";
    Human.NULL_OBJECT_ID = "null-object";   // ID of invisible object at origin, used for anchoring things like labels to
    Human.NULL_OBJECT_ID2 = "null-object-2";   // ID of invisible object at origin, used for anchoring things like labels to
    Human.CLIP_INDICATORS_ATTACH_ID = "clip-indicators";
    Human.CLIP_ATTACH_ID = "clips";
    Human.LOOKAT_ID = "theLookat";
    Human.CAMERA_ID = "theCamera";
    Human.VIEW_SPACE_ID = "viewSpace";


    /*-----------------------------------------------------------------------------------------------------------------
     * Error management
     *---------------------------------------------------------------------------------------------------------------*/

    var errorHandlers = [];         // Handlers called on error

    /**
     * Subscribes to command error notifications
     * @memberof Human
     */
    Human.onError = function (handler) {
        errorHandlers.push(handler);
    };

    /**
     * Signals non-fatal error.
     * @memberof Human
     */
    Human.error = function (code, msg) {
        if (typeof code === "string") {
            msg = code;
            code = "ERROR";
        }
        return Human._error("ERROR", code, msg, false);
    };

    Human._error = function (errorName, code, msg, fatal) {
        var error = {
            errorName: errorName,
            code: code,
            exception: msg,
            fatal: fatal
        };
        for (var i = 0, len = errorHandlers.length; i < len; i++) {
            errorHandlers[i](error);
        }
        Human.events.fire("error", {
            name: errorName,
            code: code,
            message: msg,
            fatal: fatal
        });
        return msg;
    };

    /**
     * Signals fatal error.
     * @memberof Human
     */
    Human.fatalError = function (code, msg) {
        if (typeof code === "string") {
            msg = code;
            code = "ERROR";
        }
        return Human._error("ERROR", code, msg, true);
    };




    /** Returns shallow copy of object
     * @private
     */
    Human._shallowClone = function (o) {
        var o2 = {};
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /** Add properties of o to o2 where undefined or null on o2, returns o2
     * @private
     */
    Human._applyIf = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                if (o2[name] === undefined || o2[name] === null) {
                    o2[name] = o[name];
                }
            }
        }
        return o2;
    };

    Human._applyIf2 = function (p, q) {
        p = p || {};
        var r = {};
        for (var key in q) {
            if (q.hasOwnProperty(key)) {
                r[key] = p[key] !== undefined ? p[key] : q[key];
            }
        }
        return r;
    };

    /** Add properties of o to o2, overwriting them on o2 if already there
     * @private
     */
    Human._apply = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /**
     * Returns true if object is an array
     * @private
     */
    Human._isArray = function (testObject) {
        return testObject && !(testObject.propertyIsEnumerable('length')) && typeof testObject === 'object' && typeof testObject.length === 'number';
    };

    /**
     * Returns true if given map has no items
     * @private
     */
    Human._isEmpty = function (map) {
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                return false;
            }
        }
        return true;
    };

    /**
     * Gets directory from given path
     * @private
     */
    Human._getDir = function (path) {
        var i = path.lastIndexOf("/");
        return (i > -1) ? path.substring(0, i > 0 ? i + 1 : 0) : "";
    };

    /**
     * Null function
     * @private
     */
    Human._noop = function () {
    };

    /**
     * Gets keys on given map in array
     * @private
     */
    Human._getKeys = function (map) {
        var keys = [];
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                keys.push(key);
            }
        }
        return keys;
    };

    /**
     * Returns new universally unique ID
     * @private
     */
    Human._createUUID = function () {
        var data = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F"];
        var data2 = ["8", "9", "A", "B"];
        var uuid = [];
        for (var i = 0; i < 38; i++) {
            switch (i) {
                case 8:
                    uuid.push("-");
                    break;
                case 13:
                    uuid.push("-");
                    break;
                case 18:
                    uuid.push("-");
                    break;
                case 14:
                    uuid.push("4");
                    break;
                case 19:
                    uuid.push(data2[Math.round(Math.random() * 3)]);
                    break;
                default:
                    uuid.push(data[Math.round(Math.random() * 15)]);
                    break;
            }
        }
        return uuid.join("");
    };

})();

;/**
 * @class Base class for the various engine modules.
 *
 * @constructor
 */

(function() {
    "use strict";

    Human.Component = function () {

    };


    Human.Component.prototype = {

        _init:function (ctx) {

            this._ctx = ctx;

            this._handleMap = new Human.utils.Map(); // Subscription handle pool
            this._topicSubs = {}; // A [handle -> callback] map for each topic name
            this._handleTopics = {}; // Maps handles to topic names
            this._topicPubs = {}; // Maps topics to publications
        },

        /**
         * Publishes to a topic.
         *
         * Immediately notifies existing subscriptions to that topic, retains the publication to give to
         * any subsequent notifications on that topic as they are made.
         *
         * This is called internally by proxies. Only they create publications, which are subscribed
         * to by client code.
         *
         * @param topic Publication topic
         * @param pub The publication
         * @param once True to publish once ie. not retain
         * @private
         */
        publish:function (topic, pub, once) {
            if (!once) {
                this._topicPubs[topic] = pub; // Save notification
            }
            var subsForTopic = this._topicSubs[topic];
            if (subsForTopic) { // Notify subscriptions
                for (var handle in subsForTopic) {
                    if (subsForTopic.hasOwnProperty(handle)) {
                        subsForTopic[handle].call(this, pub);
                    }
                }
            }
        },

        /**
         * Listen for data changes at a particular location on this component.
         *
         * <p>This is the primary way to read data from the Human API. Your callback will be triggered for
         * the initial data and again whenever the data changes. Use {@link #unsubscribe} to stop receiving updates.</p>
         *
         * <p>The callback is be called with this component as scope.</p>
         *
         * @param {String} topic Publication location
         * @param {Function(data)} callback Called when fresh data is available at the location
         * @return {String} Handle to the subscription, which may be used to unsubscribe with {@link #off}.
         */
        on:function (topic, callback) {
            var subsForTopic = this._topicSubs[topic];
            if (!subsForTopic) {
                subsForTopic = {};
                this._topicSubs[topic] = subsForTopic;
            }
            var handle = this._handleMap.addItem(); // Create unique handle
            subsForTopic[handle] = callback;
            this._handleTopics[handle] = topic;
            var pub = this._topicPubs[topic];
            if (pub) { // A publication exists, notify callback immediately
                callback.call(this, pub);
            }
            return handle;
        },

        /**
         * Unsubscribes from a publication on this proxy that was previously made with {@link #on}.
         * @param handle Publication handle
         */
        off:function (handle) {
            var topic = this._handleTopics[handle];
            if (topic) {
                delete this._handleTopics[handle];
                var topicSubs = this._topicSubs[topic];
                if (topicSubs) {
                    delete topicSubs[handle];
                }
                this._handleMap.removeItem(handle); // Release handle
            }
        },

        /**
         * Listens for exactly one data update at the specified location, and then stops listening.
         * <p>This is equivalent to calling {@link #on}, and then calling {@link #off} inside the callback function.</p>
         * @param {String} topic Data location to listen to
         * @param {Function(data)} callback Called when fresh data is available at the location
         */
        once:function (topic, callback) {
            var self = this;
            var sub = this.on(topic,
                function (pub) {
                    self.off(sub);
                    callback(pub);
                });
        }
    };

})();

;/** @namespace
 * @private
 */

(function() {
    "use strict";

    Human.utils = Human.utils || {};

    /**
     * Tests if the given object is an array
     * @private
     */
    Human.utils.isArray = function (testObject) {
        return testObject && !(testObject.propertyIsEnumerable('length')) && 
                typeof testObject === 'object' && typeof testObject.length === 'number';
    };

    /**
     * @private
     * @param childObj
     * @param parentObj
     */
    Human.utils.extend = function (childObj, parentObj) {
        var TmpObj = function () {
        };
        TmpObj.prototype = parentObj.prototype;
        childObj.prototype = new TmpObj();
        childObj.prototype.constructor = childObj;
    };

    /** Add properties of o to o2, overwriting them on o2 if already there
     */
    Human.utils.apply = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                o2[name] = o[name];
            }
        }
        return o2;
    };

    /**
     * Add properties of o to o2 where undefined or null on o2
     * @private
     */
    Human.utils.applyIf = function (o, o2) {
        for (var name in o) {
            if (o.hasOwnProperty(name)) {
                if (o2[name] === undefined || o2[name] === null) {
                    o2[name] = o[name];
                }
            }
        }
        return o2;
    };
})();



;
/**
 * @namespace Math functions
 * @private
 */

(function() {
    "use strict";

    var HumanMath = Human.math = {};
    var tempVec = new Float64Array(4);
    var tempMat4 = new Float64Array(16);

    /**
     *
     */
    HumanMath.clamp = function(u, min, max) {
       return (u < min) ? min : ((u > max) ? max : u);
    };

    HumanMath.vec2 = function() {
        return new Float64Array(2);
    };

    HumanMath.vec3 = function() {
        return new Float64Array(3);
    };

    HumanMath.vec4 = function() {
        return new Float64Array(4);
    };

    /**
     *
     */
    HumanMath.mat3 = function() {
        return new Float64Array(9);
    };

    /**
     *
     */
    HumanMath.mat4 = function() {
        return new Float64Array(16);
    };

    HumanMath.setVec = function(s, dest) {
        var r = dest || HumanMath.vec4();
        var i, len;

        for (i = 0, len = r.length; i < len; i++) {
            r[i] = s;
        }

        return r;
    };

    HumanMath.zeroVec = function(dest) {
        return HumanMath.setVec(0, dest);
    }; 

    /**
     *
     */
    HumanMath.divVec3 = function(u, v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = u[0] / v[0];
        result[1] = u[1] / v[1];
        result[2] = u[2] / v[2];

        return result;
    };

    /**
     *
     */
    HumanMath.negateVector4 = function(v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = -v[0];
        result[1] = -v[1];
        result[2] = -v[2];
        result[3] = -v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.addVec4 = function(u, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = u[0] + v[0];
        result[1] = u[1] + v[1];
        result[2] = u[2] + v[2];
        result[3] = u[3] + v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.addVec4s = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] + s;
        result[1] = v[1] + s;
        result[2] = v[2] + s;
        result[3] = v[3] + s;

        return result;
    };


    /**
     *
     */
    HumanMath.addScalarVec4 = function(s, v, dest) {
        return HumanMath.addVec4s(v, s, dest);
    };

    /**
     *
     */
    HumanMath.addVec3 = function(u, v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = u[0] + v[0];
        result[1] = u[1] + v[1];
        result[2] = u[2] + v[2];

        return result;
    };


    /**
     *
     */
    HumanMath.addVec3s = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] + s;
        result[1] = v[1] + s;
        result[2] = v[2] + s;

        return result;
    };

    /**
     *
     */
    HumanMath.subVec4 = function(u, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = u[0] - v[0];
        result[1] = u[1] - v[1];
        result[2] = u[2] - v[2];
        result[3] = u[3] - v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.subVec3 = function(u, v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = u[0] - v[0];
        result[1] = u[1] - v[1];
        result[2] = u[2] - v[2];

        return result;
    };

    /**
     *
     */
    HumanMath.lerpVec3 = function(t, t1, t2, p1, p2, dest) {
        var result = dest || HumanMath.vec3();
        var f = (t - t1) / (t2 - t1);

        result[0] = p1[0] + (f * (p2[0] - p1[0]));
        result[1] = p1[1] + (f * (p2[1] - p1[1]));
        result[2] = p1[2] + (f * (p2[2] - p1[2]));
        
        return result;
    };

    /**
     *
     */
    HumanMath.lerpVec2 = function(t, t1, t2, p1, p2, dest) {
        var result = dest || HumanMath.vec2();
        var f = (t - t1) / (t2 - t1);

        result[0] = p1[0] + (f * (p2[0] - p1[0]));
        result[1] = p1[1] + (f * (p2[1] - p1[1]));
        
        return result;
    };

    /**
     *
     */
    HumanMath.negateVector3 = function(v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = -v[0];
        result[1] = -v[1];
        result[2] = -v[2];

        return result;
    };

    /**
     *
     */
    HumanMath.subVec2 = function(u, v, dest) {
        var result = dest || HumanMath.vec2();
        result[0] = u[0] - v[0];
        result[1] = u[1] - v[1];

        return result;
    };


    /**
     *
     */
    HumanMath.subVec4Scalar = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] - s;
        result[1] = v[1] - s;
        result[2] = v[2] - s;
        result[3] = v[3] - s;

        return result;
    };


    /**
     *
     */
    HumanMath.subScalarVec4 = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = s - v[0];
        result[1] = s - v[1];
        result[2] = s - v[2];
        result[3] = s - v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.mulVec4 = function(u, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = u[0] * v[0];
        result[1] = u[1] * v[1];
        result[2] = u[2] * v[2];
        result[3] = u[3] * v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.mulVec4Scalar = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] * s;
        result[1] = v[1] * s;
        result[2] = v[2] * s;
        result[3] = v[3] * s;

        return result;
    };


    /**
     *
     */
    HumanMath.mulVec3Scalar = function(v, s, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = v[0] * s;
        result[1] = v[1] * s;
        result[2] = v[2] * s;

        return result;
    };


    /**
     *
     */
    HumanMath.mulVec2Scalar = function(v, s, dest) {
        var result = dest || HumanMath.vec2();
        result[0] = v[0] * s;
        result[1] = v[1] * s;

        return result;
    };

    /**
     *
     */
    HumanMath.divVec4 = function(u, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = u[0] / v[0];
        result[1] = u[1] / v[1];
        result[2] = u[2] / v[2];
        result[3] = u[3] / v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.divScalarVec3 = function(s, v, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = s / v[0];
        result[1] = s / v[1];
        result[2] = s / v[2];

        return result;
    };


    /**
     *
     */
    HumanMath.divVec3s = function(v, s, dest) {
        var result = dest || HumanMath.vec3();
        result[0] = v[0] / s;
        result[1] = v[1] / s;
        result[2] = v[2] / s;

        return result;
    };


    /**
     *
     */
    HumanMath.divVec4s = function(v, s, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = v[0] / s;
        result[1] = v[1] / s;
        result[2] = v[2] / s;
        result[3] = v[3] / s;

        return result;
    };


    /**
     *
     */
    HumanMath.divScalarVec4 = function(s, v, dest) {
        var result = dest || HumanMath.vec4();
        result[0] = s / v[0];
        result[1] = s / v[1];
        result[2] = s / v[2];
        result[3] = s / v[3];

        return result;
    };


    /**
     *
     */
    HumanMath.dotVector4 = function(u, v) {
        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);
    };


    /**
     *
     */
    HumanMath.cross3Vec4 = function(u, v, dest) {
        var r = dest || HumanMath.vec4();

        tempVec[0] = u[1] * v[2] - u[2] * v[1];
        tempVec[1] = u[2] * v[0] - u[0] * v[2];
        tempVec[2] = u[0] * v[1] - u[1] * v[0];
        tempVec[3] = 0.0;

        r[0] = tempVec[0]; 
        r[1] = tempVec[1]; 
        r[2] = tempVec[2]; 
        r[3] = tempVec[3]; 

        return r;
    };


    HumanMath.cross3Vec3 = function(u, v, dest) {
        var r = dest || HumanMath.vec3();

        tempVec[0] = u[1] * v[2] - u[2] * v[1];
        tempVec[1] = u[2] * v[0] - u[0] * v[2];
        tempVec[2] = u[0] * v[1] - u[1] * v[0];

        r[0] = tempVec[0]; 
        r[1] = tempVec[1]; 
        r[2] = tempVec[2];

        return r;
    };


    /**
     *
     */
    HumanMath.sqLenVec4 = function(v) {
        return HumanMath.dotVector4(v, v);
    };


    /**
     *
     */
    HumanMath.lenVec4 = function(v) {
        return Math.sqrt(HumanMath.sqLenVec4(v));
    };


    /**
     *
     */
    HumanMath.dotVector3 = function(u, v) {
        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);
    };


    /**
     *
     */
    HumanMath.dotVector2 = function(u, v) {
        return (u[0] * v[0] + u[1] * v[1]);
    };


    /**
     *
     */
    HumanMath.sqLenVec3 = function(v) {
        return HumanMath.dotVector3(v, v);
    };


    /**
     *
     */
    HumanMath.sqLenVec2 = function(v) {
        return HumanMath.dotVector2(v, v);
    };


    /**
     *
     */
    HumanMath.lenVec3 = function(v) {
        return Math.sqrt(HumanMath.sqLenVec3(v));
    };


    /**
     *
     */
    HumanMath.lenVec2 = function(v) {
        return Math.sqrt(HumanMath.sqLenVec2(v));
    };


    /**
     *
     */
    HumanMath.rcpVec3 = function(v, dest) {
        return HumanMath.divScalarVec3(1.0, v, dest);
    };

    /**
     *
     */
    HumanMath.vec3ObjToArray = function(v, dest) {
        var result = dest || HumanMath.vec3();

        result[0] = v.x;
        result[1] = v.y;
        result[2] = v.z;

        return result;
    };

    /**
     *
     */
    HumanMath.vec3ArrayToObj = function(v) {
        return { x: v[0], y: v[1], z: v[2] };
    };


    /**
     *
     */
    HumanMath.normalizeVec4 = function(v, dest) {
        var f = 1.0 / HumanMath.lenVec4(v);
        return HumanMath.mulVec4Scalar(v, f, dest);
    };


    /**
     *
     */
    HumanMath.normalizeVec3 = function(v, dest) {
        var f = 1.0 / HumanMath.lenVec3(v);
        return HumanMath.mulVec3Scalar(v, f, dest);
    };

    HumanMath.normalizeVec2 = function(v, dest) {
        var f = 1.0 / HumanMath.lenVec2(v);
        return HumanMath.mulVec2Scalar(v, f, dest);
    };

    /**
     *
     */
    HumanMath.dupMat4 = function(m, dest) {
        var result = dest || HumanMath.mat4();

        result.set(m);

        return result;
    };


    /**
     *
     */
    HumanMath.getCellMat4 = function(m, row, col) {
        return m[row + col * 4];
    };


    /**
     *
     */
    HumanMath.setCellMat4 = function(m, row, col, s) {
        m[row + col * 4] = s;
    };


    /**
     *
     */
    HumanMath.getRowMat4 = function(m, r, dest) {
        var result = dest || HumanMath.vec4();

        result[0] = m[r + 0]; 
        result[1] = m[r + 4]; 
        result[2] = m[r + 8]; 
        result[3] = m[r + 12];

        return result;
    };


    /**
     *
     */
    HumanMath.setRowMat4 = function(m, r, v) {
        m[r + 0] = v[0];
        m[r + 4] = v[1];
        m[r + 8] = v[2];
        m[r + 12] = v[3];
    };


    /**
     *
     */
    HumanMath.setRowMat4c = function(m, r, x, y, z, w) {
        HumanMath.setRowMat4(m, r, [x,y,z,w]);
    };


    /**
     *
     */
    HumanMath.setRowMat4s = function(m, r, s) {
        HumanMath.setRowMat4c(m, r, s, s, s, s);
    };


    /**
     *
     */
    HumanMath.getColMat4 = function(m, c, dest) {
        var result = dest || HumanMath.vec4();
        var i = c * 4;

        result[0] = m[i + 0]; 
        result[1] = m[i + 1];
        result[2] = m[i + 2];
        result[3] = m[i + 3];

        return result;
    };


    /**
     *
     */
    HumanMath.setColMat4v = function(m, c, v) {
        var i = c * 4;
        m[i + 0] = v[0];
        m[i + 1] = v[1];
        m[i + 2] = v[2];
        m[i + 3] = v[3];
    };


    /**
     *
     */
    HumanMath.setColMat4c = function(m, c, x, y, z, w) {
        HumanMath.setColMat4v(m, c, [x,y,z,w]);
    };


    /**
     *
     */
    HumanMath.setColMat4Scalar = function(m, c, s) {
        HumanMath.setColMat4c(m, c, s, s, s, s);
    };


    /**
     *
     */
    HumanMath.mat4To3 = function(m, dest) {
        var result = dest || HumanMath.mat3();

        result[0] = m[0];
        result[1] = m[1];
        result[2] = m[2];
        result[3] = m[4];
        result[4] = m[5];
        result[5] = m[6];
        result[6] = m[8];
        result[7] = m[9];
        result[8] = m[10];

        return result;
    };


    /**
     *
     */
    HumanMath.m4s = function(s, dest) {
        var result = dest || HumanMath.mat4();

        result[0] = s;
        result[1] = s;
        result[2] = s;
        result[3] = s;
        result[4] = s;
        result[5] = s;
        result[6] = s;
        result[7] = s;
        result[8] = s;
        result[9] = s;
        result[10] = s;
        result[11] = s;
        result[12] = s;
        result[13] = s;
        result[14] = s;
        result[15] = s;

        return result;
    };


    /**
     *
     */
    HumanMath.setMat4ToZeroes = function(dest) {
        return HumanMath.m4s(0.0, dest);
    };


    /**
     *
     */
    HumanMath.setMat4ToOnes = function(dest) {
        return HumanMath.m4s(1.0, dest);
    };

    /**
     *
     */
    HumanMath.diagonalMat4v = function(v, dest) {
        var result = dest || HumanMath.mat4();

        result[0] = v[0];
        result[1] = 0;
        result[2] = 0;
        result[3] = 0;
        result[4] = 0;
        result[5] = v[1];
        result[6] = 0;
        result[7] = 0;
        result[8] = 0;
        result[9] = 0;
        result[10] = v[2];
        result[11] = 0;
        result[12] = 0;
        result[13] = 0;
        result[14] = 0;
        result[15] = v[3];

        return result;
    };

    /**
     *
     */
    HumanMath.diagonalMat4c = function(x, y, z, w, dest) {
        return HumanMath.diagonalMat4v([x,y,z,w], dest);
    };

    /**
     *
     */
    HumanMath.diagonalMat4s = function(s, dest) {
        return HumanMath.diagonalMat4c(s, s, s, s, dest);
    };

    /**
     *
     */
    HumanMath.identityMat4 = function(dest) {
        return HumanMath.diagonalMat4s(1.0, dest);
    };

    /**
     *
     */
    HumanMath.isIdentityMat4 = function(m) {
        var i = 0;
        var j = 0;
        var s = 0.0;
        for (i = 0; i < 4; ++i) {
            for (j = 0; j < 4; ++j) {
                s = m[i + j * 4];
                if ((i === j)) {
                    if (s !== 1.0) {
                        return false;
                    }
                }
                else {
                    if (s !== 0.0) {
                        return false;
                    }
                }
            }
        }
        return true;
    };

    /**
     *
     */
    HumanMath.negateMat4 = function(m, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = -m[i];
        }
        return r;
    };

    /**
     *
     */
    HumanMath.addMat4 = function(a, b, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = a[i] + b[i];
        }
        return r;
    };

    /**
     *
     */
    HumanMath.addMat4Scalar = function(m, s, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = m[i] + s;
        }
        return r;
    };

    /**
     *
     */
    HumanMath.addScalarMat4 = function(s, m, dest) {
        return HumanMath.addMat4Scalar(m, s, dest);
    };

    /**
     *
     */
    HumanMath.subMat4 = function(a, b, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = a[i] - b[i];
        }
        return r;
    };

    /**
     *
     */
    HumanMath.subMat4Scalar = function(m, s, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = m[i] - s;
        }
        return r;
    };

    /**
     *
     */
    HumanMath.subScalarMat4 = function(s, m, dest) {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = s - m[i];
        }
        return r;
    };

    /**
     * @param a mat4
     * @param b mat4
     * @param dest mat4 - optional destination
     * @return {mat4} dest if specified, a otherwise
     * @private
     */
    HumanMath.mulMat4 = function(a, b, dest) {
        if (!dest) {
            dest = a;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
        var a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
        var a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
        var a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

        var b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3];
        var b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7];
        var b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11];
        var b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15];

        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;
        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;
        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;
        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;
        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;
        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;
        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;
        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;
        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;
        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;
        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;
        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;
        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;
        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;
        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;
        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;

        return dest;
    };


    /**
     *
     */
    HumanMath.mulMat4s = function(m, s, dest)
    {
        var r = dest || HumanMath.mat4();
        for (var i = 0; i < 16; ++i) {
            r[i] = m[i] * s;
        }
        return r;
    };

    /**
     *
     */
    HumanMath.mulMat4v4 = function(m, v, dest) {
        var r = dest || HumanMath.vec4();

        r[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];
        r[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];
        r[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];
        r[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];
        
        return r;
    };

    /**
     *
     */
    HumanMath.transposeMat4 = function(m, dest) {
        var r = dest || HumanMath.mat4();
        var i = 0;
        var j = 0;
        for (i = 0; i < 4; ++i) {
            for (j = 0; j < 4; ++j) {
                r[i + j * 4] = m[i * 4 + j];
            }
        }
        return r;
    };

    /**
     *
     */
    HumanMath.determinantMat4 = function(m) {
        var f = HumanMath.getCellMat4;
        return (
                f(m, 0, 3) * f(m, 1, 2) * f(m, 2, 1) * f(m, 3, 0) - f(m, 0, 2) * f(m, 1, 3) * f(m, 2, 1) * f(m, 3, 0) - f(m, 0, 3) * f(m, 1, 1) * f(m, 2, 2) * f(m, 3, 0) + f(m, 0, 1) * f(m, 1, 3) * f(m, 2, 2) * f(m, 3, 0) +
                f(m, 0, 2) * f(m, 1, 1) * f(m, 2, 3) * f(m, 3, 0) - f(m, 0, 1) * f(m, 1, 2) * f(m, 2, 3) * f(m, 3, 0) - f(m, 0, 3) * f(m, 1, 2) * f(m, 2, 0) * f(m, 3, 1) + f(m, 0, 2) * f(m, 1, 3) * f(m, 2, 0) * f(m, 3, 1) +
                f(m, 0, 3) * f(m, 1, 0) * f(m, 2, 2) * f(m, 3, 1) - f(m, 0, 0) * f(m, 1, 3) * f(m, 2, 2) * f(m, 3, 1) - f(m, 0, 2) * f(m, 1, 0) * f(m, 2, 3) * f(m, 3, 1) + f(m, 0, 0) * f(m, 1, 2) * f(m, 2, 3) * f(m, 3, 1) +
                f(m, 0, 3) * f(m, 1, 1) * f(m, 2, 0) * f(m, 3, 2) - f(m, 0, 1) * f(m, 1, 3) * f(m, 2, 0) * f(m, 3, 2) - f(m, 0, 3) * f(m, 1, 0) * f(m, 2, 1) * f(m, 3, 2) + f(m, 0, 0) * f(m, 1, 3) * f(m, 2, 1) * f(m, 3, 2) +
                f(m, 0, 1) * f(m, 1, 0) * f(m, 2, 3) * f(m, 3, 2) - f(m, 0, 0) * f(m, 1, 1) * f(m, 2, 3) * f(m, 3, 2) - f(m, 0, 2) * f(m, 1, 1) * f(m, 2, 0) * f(m, 3, 3) + f(m, 0, 1) * f(m, 1, 2) * f(m, 2, 0) * f(m, 3, 3) +
                f(m, 0, 2) * f(m, 1, 0) * f(m, 2, 1) * f(m, 3, 3) - f(m, 0, 0) * f(m, 1, 2) * f(m, 2, 1) * f(m, 3, 3) - f(m, 0, 1) * f(m, 1, 0) * f(m, 2, 2) * f(m, 3, 3) + f(m, 0, 0) * f(m, 1, 1) * f(m, 2, 2) * f(m, 3, 3)
                );
    };

    /**
     *
     */
    HumanMath.inverseMat4 = function(m, dest) {
        var m0 = m[ 0], m1 = m[ 1], m2 = m[ 2], m3 = m[ 3],
                m4 = m[ 4], m5 = m[ 5], m6 = m[ 6], m7 = m[ 7],
                m8 = m[ 8], m9 = m[ 9], m10 = m[10], m11 = m[11],
                m12 = m[12], m13 = m[13], m14 = m[14], m15 = m[15]  ;

        var n = dest || HumanMath.mat4();
        HumanMath.identityMat4(n);

        n[ 0] = (m9 * m14 * m7 - m13 * m10 * m7 + m13 * m6 * m11 - m5 * m14 * m11 - m9 * m6 * m15 + m5 * m10 * m15);
        n[ 1] = (m13 * m10 * m3 - m9 * m14 * m3 - m13 * m2 * m11 + m1 * m14 * m11 + m9 * m2 * m15 - m1 * m10 * m15);
        n[ 2] = (m5 * m14 * m3 - m13 * m6 * m3 + m13 * m2 * m7 - m1 * m14 * m7 - m5 * m2 * m15 + m1 * m6 * m15);
        n[ 3] = (m9 * m6 * m3 - m5 * m10 * m3 - m9 * m2 * m7 + m1 * m10 * m7 + m5 * m2 * m11 - m1 * m6 * m11);

        n[ 4] = (m12 * m10 * m7 - m8 * m14 * m7 - m12 * m6 * m11 + m4 * m14 * m11 + m8 * m6 * m15 - m4 * m10 * m15);
        n[ 5] = (m8 * m14 * m3 - m12 * m10 * m3 + m12 * m2 * m11 - m0 * m14 * m11 - m8 * m2 * m15 + m0 * m10 * m15);
        n[ 6] = (m12 * m6 * m3 - m4 * m14 * m3 - m12 * m2 * m7 + m0 * m14 * m7 + m4 * m2 * m15 - m0 * m6 * m15);
        n[ 7] = (m4 * m10 * m3 - m8 * m6 * m3 + m8 * m2 * m7 - m0 * m10 * m7 - m4 * m2 * m11 + m0 * m6 * m11);

        n[ 8] = (m8 * m13 * m7 - m12 * m9 * m7 + m12 * m5 * m11 - m4 * m13 * m11 - m8 * m5 * m15 + m4 * m9 * m15);
        n[ 9] = (m12 * m9 * m3 - m8 * m13 * m3 - m12 * m1 * m11 + m0 * m13 * m11 + m8 * m1 * m15 - m0 * m9 * m15);
        n[10] = (m4 * m13 * m3 - m12 * m5 * m3 + m12 * m1 * m7 - m0 * m13 * m7 - m4 * m1 * m15 + m0 * m5 * m15);
        n[11] = (m8 * m5 * m3 - m4 * m9 * m3 - m8 * m1 * m7 + m0 * m9 * m7 + m4 * m1 * m11 - m0 * m5 * m11);

        n[12] = (m12 * m9 * m6 - m8 * m13 * m6 - m12 * m5 * m10 + m4 * m13 * m10 + m8 * m5 * m14 - m4 * m9 * m14);
        n[13] = (m8 * m13 * m2 - m12 * m9 * m2 + m12 * m1 * m10 - m0 * m13 * m10 - m8 * m1 * m14 + m0 * m9 * m14);
        n[14] = (m12 * m5 * m2 - m4 * m13 * m2 - m12 * m1 * m6 + m0 * m13 * m6 + m4 * m1 * m14 - m0 * m5 * m14);
        n[15] = (m4 * m9 * m2 - m8 * m5 * m2 + m8 * m1 * m6 - m0 * m9 * m6 - m4 * m1 * m10 + m0 * m5 * m10);

        var s = 1.0 / (
                m12 * m9 * m6 * m3 - m8 * m13 * m6 * m3 - m12 * m5 * m10 * m3 + m4 * m13 * m10 * m3 +
                m8 * m5 * m14 * m3 - m4 * m9 * m14 * m3 - m12 * m9 * m2 * m7 + m8 * m13 * m2 * m7 +
                m12 * m1 * m10 * m7 - m0 * m13 * m10 * m7 - m8 * m1 * m14 * m7 + m0 * m9 * m14 * m7 +
                m12 * m5 * m2 * m11 - m4 * m13 * m2 * m11 - m12 * m1 * m6 * m11 + m0 * m13 * m6 * m11 +
                m4 * m1 * m14 * m11 - m0 * m5 * m14 * m11 - m8 * m5 * m2 * m15 + m4 * m9 * m2 * m15 +
                m8 * m1 * m6 * m15 - m0 * m9 * m6 * m15 - m4 * m1 * m10 * m15 + m0 * m5 * m10 * m15
                );
        for (var i = 0; i < 16; ++i) {
            n[i] *= s;
        }
        return n;
    };

    /**
     *
     */
    HumanMath.traceMat4 = function(m) {
        return (m[0] + m[5] + m[10] + m[15]);
    };

    /**
     *
     */
    HumanMath.translationMat4v = function(v, dest) {
        var m = dest || HumanMath.mat4();
        HumanMath.identityMat4(m);
        
        m[12] = v[0];
        m[13] = v[1];
        m[14] = v[2];

        return m;
    };

    /**
     *
     */
    HumanMath.translationMat4c = function(x, y, z, dest) {
        return HumanMath.translationMat4v([x,y,z], dest);
    };

    /**
     *
     */
    HumanMath.translationMat4s = function(s, dest) {
        return HumanMath.translationMat4c(s, s, s, dest);
    };

    /**
     *
     */
    HumanMath.rotationMat4v = function(anglerad, axis, dest) {
        var ax = HumanMath.normalizeVec4([axis[0],axis[1],axis[2],0.0]);
        var s = Math.sin(anglerad);
        var c = Math.cos(anglerad);
        var q = 1.0 - c;

        var x = ax[0];
        var y = ax[1];
        var z = ax[2];

        var xx,yy,zz,xy,yz,zx,xs,ys,zs;

        xx = x * x;
        yy = y * y;
        zz = z * z;
        xy = x * y;
        yz = y * z;
        zx = z * x;
        xs = x * s;
        ys = y * s;
        zs = z * s;

        var m = dest || HumanMath.mat4();

        m[0] = (q * xx) + c;
        m[1] = (q * xy) + zs;
        m[2] = (q * zx) - ys;
        m[3] = 0.0;

        m[4] = (q * xy) - zs;
        m[5] = (q * yy) + c;
        m[6] = (q * yz) + xs;
        m[7] = 0.0;

        m[8] = (q * zx) + ys;
        m[9] = (q * yz) - xs;
        m[10] = (q * zz) + c;
        m[11] = 0.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 0.0;
        m[15] = 1.0;

        return m;
    };

    /**
     * Uses NASA standard aeroplane conventions as described on page:
    *   http://www.euclideanspace.com/maths/geometry/rotations/euler/index.htm
    *   Coordinate System: right hand
    *   Positive angle: right hand
    *   Order of euler angles: heading first, then attitude, then bank
    *   matrix row column ordering:
    *   [m00 m01 m02]
    *   [m10 m11 m12]
    *   [m20 m21 m22]*/
    HumanMath.rotationEulerMat4v = function(x, y, z, dest) {

        var ch = Math.cos(-y);
        var sh = Math.sin(-y);
        var ca = Math.cos(-z);
        var sa = Math.sin(-z);
        var cb = Math.cos(-x);
        var sb = Math.sin(-x);

        var m = dest || HumanMath.mat4();

        m[0] = ch * ca;
        m[1] = sh * sb - ch * sa * cb;
        m[2] = ch * sa * sb + sh * cb;
        m[3] = 0;
        m[4] = sa;
        m[5] = ca * cb;
        m[6] = -ca * sb;
        m[7] = 0;
        m[8] = -sh * ca;
        m[9] = sh * sa * cb + ch * sb;
        m[10] = -sh * sa * sb + ch * cb;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;

        return m;
    };


    //    m[0] = ch * ca;
    //    m01 = sh * sb - ch * sa * cb;
    //    m02 = ch * sa * sb + sh * cb;
    //    m10 = sa;
    //    m11 = ca * cb;
    //    m12 = -ca * sb;
    //    m20 = -sh * ca;
    //    m21 = sh * sa * cb + ch * sb;
    //    m22 = -sh * sa * sb + ch * cb;
    /**
     *
     */
    HumanMath.rotationMat4c = function(anglerad, x, y, z, dest) {
        return HumanMath.rotationMat4v(anglerad, [x,y,z], dest);
    };

    /**
     *
     */
    HumanMath.scalingMat4v = function(v, dest) {
        var m = dest || HumanMath.mat4();
        HumanMath.identityMat4(m);

        m[0] = v[0];
        m[5] = v[1];
        m[10] = v[2];

        return m;
    };

    /**
     *
     */
    HumanMath.scalingMat4c = function(x, y, z, dest) {
        return HumanMath.scalingMat4v([x,y,z], dest);
    };

    /**
     *
     */
    HumanMath.scalingMat4s = function(s, dest) {
        return HumanMath.scalingMat4c(s, s, s, dest);
    };

    /**
     *
     */

    var pos4 = HumanMath.vec4();
    var v = HumanMath.vec4();
    var u = HumanMath.vec4();
    var s = Human.math.vec4();

    HumanMath.lookAtMat4v = function(pos, target, up, dest) {
        pos4[0] = pos[0];
        pos4[1] = pos[1];
        pos4[2] = pos[2];
        pos4[3] = 0.0;

        v[0] = target[0];
        v[1] = target[1];
        v[2] = target[2];
        v[3] = 0.0;

        u[0] = up[0];
        u[1] = up[1];
        u[2] = up[2];
        u[3] = 0.0;

        HumanMath.subVec4(v, pos4, tempVec);

        HumanMath.normalizeVec4(tempVec, v);
        HumanMath.normalizeVec4(u, u);

        HumanMath.cross3Vec4(v, u, tempVec);
        HumanMath.normalizeVec4(tempVec, s);

        HumanMath.cross3Vec4(s, v, tempVec);
        HumanMath.normalizeVec4(tempVec, u);

        var m = dest || HumanMath.mat4();

        m[0] = s[0];
        m[1] = u[0];
        m[2] = -v[0];
        m[3] = 0.0;

        m[4] = s[1];
        m[5] = u[1];
        m[6] = -v[1];
        m[7] = 0.0;

        m[8] = s[2];
        m[9] = u[2];
        m[10] = -v[2];
        m[11] = 0.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = 0.0;
        m[15] = 1.0;

        HumanMath.negateVector4(pos4, pos4);
        HumanMath.translationMat4v(pos4, tempMat4);

        HumanMath.mulMat4(m, tempMat4, m);

        return m;
    };

    /**
     *
     */
    HumanMath.lookAtMat4c = function(posx, posy, posz, targetx, targety, targetz, upx, upy, upz, dest) {
        return HumanMath.lookAtMat4v([posx,posy,posz], [targetx,targety,targetz], [upx,upy,upz], dest);
    };

    /**
     *
     */
    HumanMath.orthoMat4v = function(omin, omax, dest) {
        var omin4 = [omin[0],omin[1],omin[2],0.0];
        var omax4 = [omax[0],omax[1],omax[2],0.0];
        var vsum = HumanMath.addVec4(omax4, omin4);
        var vdif = HumanMath.subVec4(omax4, omin4);

        var m = dest || HumanMath.mat4();

        m[0] = 2.0 / vdif[0];
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;

        m[4] = 0.0;
        m[5] = 2.0 / vdif[1];
        m[6] = 0.0;
        m[7] = 0.0;

        m[8] = 0.0;
        m[9] = 0.0;
        m[10] = -2.0 / vdif[2];
        m[11] = 0.0;

        m[12] = -vsum[0] / vdif[0];
        m[13] = -vsum[1] / vdif[1];
        m[14] = -vsum[2] / vdif[2];
        m[15] = 1.0;

        return m;
    };

    /**
     *
     */
    HumanMath.orthoMat4c = function(left, right, bottom, top, znear, zfar, dest) {
        return HumanMath.orthoMat4v([left,bottom,znear], [right,top,zfar], dest);
    };

    /**
     *
     */
    HumanMath.frustumMat4v = function(fmin, fmax, dest) {
        var fmin4 = [fmin[0],fmin[1],fmin[2],0.0];
        var fmax4 = [fmax[0],fmax[1],fmax[2],0.0];
        var vsum = HumanMath.addVec4(fmax4, fmin4);
        var vdif = HumanMath.subVec4(fmax4, fmin4);
        var t = 2.0 * fmin4[2];

        var m = dest || HumanMath.mat4();

        m[0] = t / vdif[0];
        m[1] = 0.0;
        m[2] = 0.0;
        m[3] = 0.0;

        m[4] = 0.0;
        m[5] = t / vdif[1];
        m[6] = 0.0;
        m[7] = 0.0;

        m[8] = vsum[0] / vdif[0];
        m[9] = vsum[1] / vdif[1];
        m[10] = -vsum[2] / vdif[2];
        m[11] = -1.0;

        m[12] = 0.0;
        m[13] = 0.0;
        m[14] = -t * fmax4[2] / vdif[2];
        m[15] = 0.0;

        return m;
    };

    /**
     *
     */
    HumanMath.frustumMatrix4 = function(left, right, bottom, top, znear, zfar, dest) {
        return HumanMath.frustumMat4v([left, bottom, znear], [right, top, zfar], dest);
    };

    /**
     *
     */
    HumanMath.perspectiveMatrix4 = function(fovyrad, aspectratio, znear, zfar, dest) {
        var pmin = HumanMath.vec4();
        var pmax = HumanMath.vec4();

        pmin[2] = znear;
        pmax[2] = zfar;

        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);
        pmin[1] = -pmax[1];

        pmax[0] = pmax[1] * aspectratio;
        pmin[0] = -pmax[0];

        return HumanMath.frustumMat4v(pmin, pmax, dest);
    };

    /**
     *
     */
    HumanMath.transformPoint3 = function(m, p, dest) {
        var r = dest || HumanMath.vec4();

        tempVec[0] = (m[0] * p[0]) + (m[4] * p[1]) + (m[8] * p[2]) + m[12];
        tempVec[1] = (m[1] * p[0]) + (m[5] * p[1]) + (m[9] * p[2]) + m[13];
        tempVec[2] = (m[2] * p[0]) + (m[6] * p[1]) + (m[10] * p[2]) + m[14];
        tempVec[3] = (m[3] * p[0]) + (m[7] * p[1]) + (m[11] * p[2]) + m[15];

        r[0] = tempVec[0];
        r[1] = tempVec[1];
        r[2] = tempVec[2];
        r[3] = tempVec[3];
        
        return r;
    };

    /**
     *
     */
    HumanMath.transformPoint4 = function(m, v, dest) {
        var r = dest || HumanMath.vec4();

        tempVec[0] = m[ 0] * v[0] + m[ 4] * v[1] + m[ 8] * v[2] + m[12] * v[3];
        tempVec[1] = m[ 1] * v[0] + m[ 5] * v[1] + m[ 9] * v[2] + m[13] * v[3];
        tempVec[2] = m[ 2] * v[0] + m[ 6] * v[1] + m[10] * v[2] + m[14] * v[3];
        tempVec[3] = m[ 3] * v[0] + m[ 7] * v[1] + m[11] * v[2] + m[15] * v[3];

        r[0] = tempVec[0];
        r[1] = tempVec[1];
        r[2] = tempVec[2];
        r[3] = tempVec[3];

        return r;
    };

    /**
     *
     */
    HumanMath.transformPoints3 = function(m, points) {
        var len = points.length;
        var result = new Array(len);
        for (var i = 0; i < len; i++) {
            result[i] = HumanMath.transformPoint3(m, points[i]);
        }
        return result;
    };


    /**
     *
     */
    HumanMath.transformVector3 = function(m, v, dest) {
        var r = dest || HumanMath.vec3();

        tempVec[0] = (m[0] * v[0]) + (m[4] * v[1]) + (m[8] * v[2]);
        tempVec[1] = (m[1] * v[0]) + (m[5] * v[1]) + (m[9] * v[2]);
        tempVec[2] = (m[2] * v[0]) + (m[6] * v[1]) + (m[10] * v[2]);

        r[0] = tempVec[0];
        r[1] = tempVec[1];
        r[2] = tempVec[2];
       
        return r;
    };


    /**
     *
     */
    HumanMath.projectVec4 = function(v, dest) {
        var r = dest || HumanMath.vec4();
        var f = 1.0 / v[3];

        r[0] = v[0] * f; 
        r[1] = v[1] * f; 
        r[2] = v[2] * f; 
        r[3] = 1.0;
        
        return r;
    };


    /**
     *
     */
    HumanMath.Plane3 = function (normal, offset, normalize) {
        this.normal = new Float64Array([0.0, 0.0, 1.0]);
        this.offset = 0.0;
        if (normal && offset) {
            this.normal[0] = normal[0];
            this.normal[1] = normal[1];
            this.normal[2] = normal[2];
            this.offset = offset;

            if (normalize) {
                var s = Math.sqrt(
                        this.normal[0] * this.normal[0] +
                        this.normal[1] * this.normal[1] +
                        this.normal[2] * this.normal[2]
                        );
                if (s > 0.0) {
                    s = 1.0 / s;
                    this.normal[0] *= s;
                    this.normal[1] *= s;
                    this.normal[2] *= s;
                    this.offset *= s;
                }
            }
        }
    };


    HumanMath.MAX_DOUBLE = Number.POSITIVE_INFINITY;
    HumanMath.MIN_DOUBLE = Number.NEGATIVE_INFINITY;

    HumanMath.MAX_NUMBER = Number.POSITIVE_INFINITY;
    HumanMath.MIN_NUMBER = Number.NEGATIVE_INFINITY;


    /**
     *
     */
    HumanMath.Box3 = function(min, max) {
        this.min = min || [ HumanMath.MAX_DOUBLE,HumanMath.MAX_DOUBLE,HumanMath.MAX_DOUBLE ];
        this.max = max || [ HumanMath.MIN_DOUBLE,HumanMath.MIN_DOUBLE,HumanMath.MIN_DOUBLE ];


        this.init = function(min, max) {
            for (var i = 0; i < 3; ++i) {
                this.min[i] = min[i];
                this.max[i] = max[i];
            }
            return this;
        };


        this.fromPoints = function(points) {
            var points2 = [];
            for (var i = 0; i < points.length; i++) {
                points2.push([points[i][0] / points[i][3], points[i][1] / points[i][3], points[i][2] / points[i][3]]);
            }
            points = points2;
            for (i = 0; i < points.length; i++) {
                var v = points[i];
                for (var j = 0; j < 3; j++) {
                    if (v[j] < this.min[j]) {
                        this.min[j] = v[j];
                    }
                    if (v[j] > this.max[j]) {
                        this.max[j] = v[j];
                    }
                }
            }
            return this;
        };


        this.isEmpty = function() {
            return (
                    (this.min[0] >= this.max[0]) && 
                        (this.min[1] >= this.max[1]) && 
                        (this.min[2] >= this.max[2])
                    );
        };


        this.getCenter = function() {
            return new Float64Array([
                (this.max[0] + this.min[0]) / 2.0,
                (this.max[1] + this.min[1]) / 2.0,
                (this.max[2] + this.min[2]) / 2.0
            ]);
        };


        this.getSize = function() {
            return new Float64Array([
                (this.max[0] - this.min[0]),
                (this.max[1] - this.min[1]),
                (this.max[2] - this.min[2])
            ]);
        };


        this.getFacesAreas = function() {
            var s = this.size;
            return new Float64Array([
                (s[1] * s[2]),
                (s[0] * s[2]),
                (s[0] * s[1])
            ]);
        };


        this.getSurfaceArea = function() {
            var a = this.getFacesAreas();
            return ((a[0] + a[1] + a[2]) * 2.0);
        };


        this.getVolume = function() {
            var s = this.size;
            return (s[0] * s[1] * s[2]);
        };


        this.getOffset = function(halfDelta) {
            for (var i = 0; i < 3; ++i) {
                this.min[i] -= halfDelta;
                this.max[i] += halfDelta;
            }
            return this;
        };
    };

    /** @private
     *
     * @param min
     * @param max
     */
    HumanMath.AxisBox3 = function(min, max) {
        this.verts = [
            [min[0], min[1], min[2]],
            [max[0], min[1], min[2]],
            [max[0], max[1], min[2]],
            [min[0], max[1], min[2]],

            [min[0], min[1], max[2]],
            [max[0], min[1], max[2]],
            [max[0], max[1], max[2]],
            [min[0], max[1], max[2]]
        ];


        this.toBox3 = function() {
            var box = new HumanMath.Box3();
            for (var i = 0; i < 8; i++) {
                var v = this.verts[i];
                for (var j = 0; j < 3; j++) {
                    if (v[j] < box.min[j]) {
                        box.min[j] = v[j];
                    }
                    if (v[j] > box.max[j]) {
                        box.max[j] = v[j];
                    }
                }
            }
        };

        this.toBoundary = function() {
            var box = new HumanMath.Box3();
            for (var i = 0; i < 8; i++) {
                var v = this.verts[i];
                for (var j = 0; j < 3; j++) {
                    if (v[j] < box.min[j]) {
                        box.min[j] = v[j];
                    }
                    if (v[j] > box.max[j]) {
                        box.max[j] = v[j];
                    }
                }
            }
        };
    };

    /** @private
     *
     * @param center
     * @param radius
     */
    HumanMath.Sphere3 = function(center, radius) {
        this.center = new Float64Array(center);
        this.radius = radius;


        this.isEmpty = function() {
            return (this.radius === 0.0);
        };


        this.surfaceArea = function() {
            return (4.0 * Math.PI * this.radius * this.radius);
        };


        this.getVolume = function() {
            return ((4.0 / 3.0) * Math.PI * this.radius * this.radius * this.radius);
        };
    };

    /** Creates billboard matrix from given view matrix
     * @private
     */
    HumanMath.billboardMat = function(viewMatrix, dest) {
        var rotVec = [
            HumanMath.getColMat4(viewMatrix, 0),
            HumanMath.getColMat4(viewMatrix, 1),
            HumanMath.getColMat4(viewMatrix, 2)
        ];

        var scaleVec = new Float64Array([
            HumanMath.lenVec4(rotVec[0]),
            HumanMath.lenVec4(rotVec[1]),
            HumanMath.lenVec4(rotVec[2])
        ]);

        var scaleVecRcp = HumanMath.rcpVec3(scaleVec);
        var sMat = HumanMath.scalingMat4v(scaleVec);

        HumanMath.mulVec4Scalar(rotVec[0], scaleVecRcp[0], rotVec[0]);
        HumanMath.mulVec4Scalar(rotVec[1], scaleVecRcp[1], rotVec[1]);
        HumanMath.mulVec4Scalar(rotVec[2], scaleVecRcp[2], rotVec[2]);

        var result = dest || HumanMath.mat4();

        HumanMath.identityMat4(result);

        HumanMath.setRowMat4(result, 0, rotVec[0]);
        HumanMath.setRowMat4(result, 1, rotVec[1]);
        HumanMath.setRowMat4(result, 2, rotVec[2]);

        HumanMath.mulMat4(result, sMat, result);

        return result;
        // return HumanMath.mulMat4(sMat, HumanMath.mulMat4(rotMatInverse, sMat));
        //return HumanMath.mulMat4(sMatInv, HumanMath.mulMat4(rotMatInverse, sMat));
    };

    /**
     *
     */
    HumanMath.identityQuaternion = function(dest) {
        var r = dest || HumanMath.vec4;

        r[0] = 0;
        r[1] = 0;
        r[2] = 0;
        r[3] = 1;

        return r;
    };

    /**
     *
     */
    HumanMath.angleAxisQuaternion = function(axis, radians, dest) {
       // var angleRad = (degrees / 180.0) * Math.PI;
        //var angleRad = degrees;
        var r = dest || HumanMath.vec4();
        var halfAngle = radians / 2.0;
        var fsin = Math.sin(halfAngle);

        r[0] = fsin * axis[0];
        r[1] = fsin * axis[1];
        r[2] = fsin * axis[2];
        r[3] = Math.cos(halfAngle);

        return r;
    };

    /**
     *
     */
    HumanMath.mulQuaternions = function(p, q, dest) {
        var r = dest || HumanMath.vec4();

        r[0] = p[3] * q[0] + p[0] * q[3] + p[1] * q[2] - p[2] * q[1];
        r[1] = p[3] * q[1] + p[1] * q[3] + p[2] * q[0] - p[0] * q[2];
        r[2] = p[3] * q[2] + p[2] * q[3] + p[0] * q[1] - p[1] * q[0];
        r[3] = p[3] * q[3] - p[0] * q[0] - p[1] * q[1] - p[2] * q[2];

        return r;
    };

    /**
     *
     */
    HumanMath.newMat4FromQuaternion = function(q, dest) {
        var tx = 2.0 * q[0];
        var ty = 2.0 * q[1];
        var tz = 2.0 * q[2];
        var twx = tx * q[3];
        var twy = ty * q[3];
        var twz = tz * q[3];
        var txx = tx * q[0];
        var txy = ty * q[0];
        var txz = tz * q[0];
        var tyy = ty * q[1];
        var tyz = tz * q[1];
        var tzz = tz * q[2];
        var m = dest || HumanMath.mat4();
        HumanMath.identityMat4(m);
        HumanMath.setCellMat4(m, 0, 0, 1.0 - (tyy + tzz));
        HumanMath.setCellMat4(m, 0, 1, txy - twz);
        HumanMath.setCellMat4(m, 0, 2, txz + twy);
        HumanMath.setCellMat4(m, 1, 0, txy + twz);
        HumanMath.setCellMat4(m, 1, 1, 1.0 - (txx + tzz));
        HumanMath.setCellMat4(m, 1, 2, tyz - twx);
        HumanMath.setCellMat4(m, 2, 0, txz - twy);
        HumanMath.setCellMat4(m, 2, 1, tyz + twx);
        HumanMath.setCellMat4(m, 2, 2, 1.0 - (txx + tyy));
        return m;
    };


    //HumanMath.slerp(t, q1, q2) {
    //    var result = HumanMath.identityQuaternion();
    //    var cosHalfAngle = q1[3] * q2[3] + q1[0] * q2[0] + q1[1] * q2[1] + q1[2] * q2[2];
    //    if (Math.abs(cosHalfAngle) >= 1) {
    //        return [ q1[0],q1[1], q1[2], q1[3] ];
    //    } else {
    //        var halfAngle = Math.acos(cosHalfAngle);
    //        var sinHalfAngle = Math.sqrt(1 - cosHalfAngle * cosHalfAngle);
    //        if (Math.abs(sinHalfAngle) < 0.001) {
    //            return [
    //                q1[0] * 0.5 + q2[0] * 0.5,
    //                q1[1] * 0.5 + q2[1] * 0.5,
    //                q1[2] * 0.5 + q2[2] * 0.5,
    //                q1[3] * 0.5 + q2[3] * 0.5
    //            ];
    //        } else {
    //            var a = Math.sin((1 - t) * halfAngle) / sinHalfAngle;
    //            var b = Math.sin(t * halfAngle) / sinHalfAngle;
    //            return [
    //                q1[0] * a + q2[0] * b,
    //                q1[1] * a + q2[1] * b,
    //                q1[2] * a + q2[2] * b,
    //                q1[3] * a + q2[3] * b
    //            ];
    //        }
    //    }
    //}

    /**
     *
     */
    HumanMath.slerp = function(t, q1, q2, dest) {
        var r = dest || HumanMath.vec4();
        var q13 = q1[3] * 0.0174532925;
        var q23 = q2[3] * 0.0174532925;
        var cosHalfAngle = q13 * q23 + q1[0] * q2[0] + q1[1] * q2[1] + q1[2] * q2[2];
        if (Math.abs(cosHalfAngle) >= 1) {
            r[0] = q1[0];
            r[1] = q1[1];
            r[2] = q1[2];
            r[3] = q1[3];

            return r;
        } else {
            var halfAngle = Math.acos(cosHalfAngle);
            var sinHalfAngle = Math.sqrt(1 - cosHalfAngle * cosHalfAngle);
            if (Math.abs(sinHalfAngle) < 0.001) {
                r[0] = q1[0] * 0.5 + q2[0] * 0.5;
                r[1] = q1[1] * 0.5 + q2[1] * 0.5;
                r[2] = q1[2] * 0.5 + q2[2] * 0.5;
                r[3] = q1[3] * 0.5 + q2[3] * 0.5;

                return r;
            } else {
                var a = Math.sin((1 - t) * halfAngle) / sinHalfAngle;
                var b = Math.sin(t * halfAngle) / sinHalfAngle;

                r[0] = q1[0] * a + q2[0] * b;
                r[1] = q1[1] * a + q2[1] * b;
                r[2] = q1[2] * a + q2[2] * b;
                r[3] = (q13 * a + q23 * b) * 57.295779579;
                
                return r;
            }
        }
    };

    /**
     *
     */
    HumanMath.normalizeQuaternion = function(q, dest) {
        var r = dest || HumanMath.vec4();
        var len = HumanMath.lenVec3([q[0], q[1], q[2]]);

        r[0] = q[0] / len;
        r[1] = q[1] / len;
        r[2] = q[2] / len;
        r[3] = q[3] / len;

        return r;
    };


    /**
     *
     */
    HumanMath.conjugateQuaternion = function(q, dest) {
        var r = dest || HumanMath.vec4();

        r[0] = -q[0];
        r[1] = -q[1];
        r[2] = -q[2];
        r[3] = q[3];

        return r;
    };

    /**
     *
     */
    HumanMath.angleAxisFromQuaternion = function(q) {        
        HumanMath.normalizeQuaternion(q, q);
        var angle = 2 * Math.acos(q[3]);
        var s = Math.sqrt(1 - q[3] * q[3]);
        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
            return {
                x : q[0],
                y : q[1],
                z : q[2],
                angle: angle
            };
        } else {
            return {
                x : q[0] / s,
                y : q[1] / s,
                z : q[2] / s,
                angle: angle
            };
        }
    };

    /**
     *
     */
    HumanMath.getBoundaryCenter = function(boundary, dest) {
        var r = dest || HumanMath.vec3();

        r[0] = (boundary.xmax + boundary.xmin ) * 0.5;
        r[1] = (boundary.ymax + boundary.ymin ) * 0.5;
        r[2] = (boundary.zmax + boundary.zmin ) * 0.5;

        return r;
    };
    /**
     *
     */
    var min = HumanMath.vec3();
    var max = HumanMath.vec3();
    HumanMath.getBoundaryDiag = function(boundary) {
        
        min[0] = boundary.xmin;
        min[1] = boundary.ymin;
        min[2] = boundary.zmin;

        max[0] = boundary.xmax;
        max[1] = boundary.ymax;
        max[2] = boundary.zmax;

        HumanMath.subVec3(max, min, tempVec);

        return Math.abs(HumanMath.lenVec3(tempVec));
    };
})();
;
/**
 * Applies a callback to each item in a map concurrently, Returns via callback when
 * all items processed. In addition to the key and item, passes a context into callback also.
 * @param map
 * @param context
 * @param fn
 * @param ok
 * @param error
 */
Human.utils.concurrentMapIterate = function (map, context, fn, ok, error) {
    "use strict";

    var keys = [];
    for (var key in map) {
        if (map.hasOwnProperty(key)) {
            keys.push(key);
        }
    }
    var numKeys = keys.length;

    // Immediate ok when no items
    if (numKeys === 0) {
        ok();
        return;
    }

    var numComplete = 0;
    var wasError = false;

    // Fires ok when all items processed
    function done() {
        if (++numComplete >= numKeys && !wasError) {
            ok();
        }
    }

    // Catches only first error to avoid cascade
    function error2(message) {
        if (!wasError) {
            wasError = true;
            error(message);
        }
    }

    if (context) {
        for (var i = 0, len = keys.length; i < len; i++) {
            fn.call(context, keys[i], map[keys[i]], done, error2);
        }
    } else {
        for (i = 0, len = keys.length; i < len; i++) {
            fn(keys[i], map[keys[i]], done, error2);
        }
    }
};
;
/**
 * Executes a collection of tasks concurrently, signals completion
 * when all tasks complete, or error as soon as a task fails.
 */
Human.utils.ConcurrentTasks = function() {
    "use strict";

    var tasks = [];
    var numTasks = 0;
    var _onComplete;
    var _onError;
    var wasError = false;

    /**
     * Adds a task, like this:
     *
     * add(function(done, error) {
     *
     *      // Do task here, then call done() on success, or error("some error") on failure
     *
     * })
     *
     */
    this.add = function(task) {
        tasks[numTasks++] = task;
    };

    function done() {
        if (--numTasks <= 0 && !wasError) {
            _onComplete();
        }
    }

    function error(errMsg) {
        if (!wasError) {
            wasError = true;
            _onError(errMsg);
        }
    }

    /**
     * Runs added tasks concurrently.
     *
     * Calls onComplete as soon as all tasks have called their done() callbacks, else onError
     * as soon as one task calls its error() callback.
     *
     * The onError callback is only called once, for the first task that fails.
     */
    this.go = function(onComplete, onError) {
        _onComplete = onComplete;
        _onError = onError;
        wasError = false;
        if (numTasks > 0) {
            for (var i = 0, len = numTasks; i < len; i++) {
                (tasks[i])(done, error);
            }
        } else {
            onComplete();
        }
    };
};
;/**
 * Tests if files exist on server, caches results.
 */
(function () {
    "use strict";

    var FileExists = Human.utils.fileExists = {}; 

    // Caches flags for URLs
    var cache = {};

    // Ensures that cache doesn't grow too much
    var evictionQueue = [];
    var maxSize = 200;

    /**
     * Test if file exists at the given URL.
     * @param {String} url The file URL
     * @param {Function} callback callback which returns boolean flag which indicates if file exists
     */
    FileExists.test = function (url, callback) {

        var exists = cache[url];

        if (exists !== undefined) {
            callback(exists);
            return;
        }

        var http = new XMLHttpRequest();

        http.open('HEAD', url);

        http.onreadystatechange = function () {
            // response completed
            if (http.readyState === 4) {

                // Evict least-recently-used
                // if cache size limit reached

                if (evictionQueue.length >= maxSize) {
                    var evictURL = evictionQueue.shift();
                    delete cache[evictURL];
                }

                // Cache result
                exists = http.status !== 404;
                cache[url] = exists;
                evictionQueue.push(url);

                // Return result
                callback(exists);
            }
        };
        http.send();
    };

})();






;// TODO: Why is this a constructor?
Human.utils.ArrayIteration = function(array, fn, onComplete, onError) {
    "use strict";

    this.push = function(item) {
        array.push(item);
        window.setTimeout(next, 1);
    };

    var wasError = false;

    if (array.length === 0) {
        if (onComplete) {
            onComplete();
        }
        return;
    }

    function done() {
        if (array.length === 0) {
            if (onComplete) {
                onComplete();
            }
        } else {
            window.setTimeout(next, 1);
        }
    }

    function error(msg) {
        if (!wasError) {
            wasError = true;
            if (onError) {
                onError(msg);
            } else {
                if (onComplete) {
                    onComplete();
                }
            }
        }
    }

    function next() {
        if (array.length > 0) {
            fn(array.shift(), done, error);
        }
    }

    window.setTimeout(next, 1);
};
;
/**
 * Maps tags to items, supports fast queries to find items matching queries on tags
 */
Human.utils.TagMap = function () {
    "use strict";

    // Map of tags to items
    var tagMap = {};

    // Count of items mapped to each tag
    var tagCounts = {};

    // Map of all items by ID
    var items = {};

    // Search results cached against sets of query tags
    var cachedSearchResults;

    /**
     * Insert item into tag map
     */
    this.addItem = function (itemId, tags, item) {
        var tag;
        var tagItems;
        var tagCount;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagItems = tagMap[tag];
            if (!tagItems) {
                tagItems = tagMap[tag] = {};
            }
            tagItems[itemId] = item;
            tagCount = tagCounts[tag];
            if (!tagCount) {
                tagCounts[tag] = 1;
            } else {
                tagCounts[tag]++;
            }
        }
        items[itemId] = item;

        /* Blow away search results cache - could refine this
         */
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };

    /**
     * Returns items that match the given tags.
     * Caches them against the tags for fast re-query.
     */
    this.findItems = function (withTags) {

        withTags = withTags || {};

        var tags = withTags.tags || [];
        var key = tags.join(".");

        var matching = withTags.matching || "any";

        if (!cachedSearchResults) {
            cachedSearchResults = {};
        }
        var matchTypeCache = cachedSearchResults[matching];
        if (!matchTypeCache) {
            matchTypeCache = cachedSearchResults[matching] = {};
        }

        var result = matchTypeCache[key];

        if (!result) {
            switch (matching) {

                case "most":
                    result = this._findHitsMost(tags);
                    break;

                case "atLeast":
                    result = this._findHitsAtLeast(tags);
                    break;

                case "any":
                    result = this._findHitsAny(tags);
                    break;
            }
            matchTypeCache[key] = result;
        }

        return result;
    };

    /**
     * Returns the first item found (in lexical order) that matches the largest subset of the given tags.
     */
    this._findHitsMost = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var bestItemId;
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {                // With each item info for tag
                    if (items.hasOwnProperty(itemId)) {
                        var hits = itemHits[itemId];       // Record tag hit for item info
                        if (!hits) {
                            hits = itemHits[itemId] = 1;
                        } else {
                            hits = ++itemHits[itemId];
                        }
                        if (!bestItemId || hits > itemHits[bestItemId]) { // Track item info with most hits
                            bestItemId = itemId;
                        }
                    }
                }
            }
        }
        var result = {};// Return item info with most hits
        if (bestItemId) {
            result[bestItemId] = items[bestItemId];
        }
        return result;
    };

    /**
     * Returns items matching the complete set of given tags
     */
    this._findHitsAtLeast = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var numTags = tags.length;
        var result = {};
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) { // With each item info for tag
                        var hits = itemHits[itemId];    // Record tag hit for item info
                        if (!hits) {
                            hits = itemHits[itemId] = 1;
                        } else {
                            hits = ++itemHits[itemId];
                        }
                        if (hits === numTags) {          // Collect item infos matching
                            result[itemId] = items[itemId]; // all the query tags
                        }
                    }
                }
            }
        }
        return result;
    };

    /**
     * Returns item infos matching any of the given tags
     */
    this._findHitsAny = function (tags) {
        var tag;
        var items;
        var result = {};
        for (var i = 0, len = tags.length; i < len; i++) {  // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) {   // With each item info for tag
                        result[itemId] = items[itemId];   // Collect item infos matching the tag
                    }
                }
            }
        }
        return result;
    };

    /** Remove item from map
     */
    this.removeItem = function (itemId) {
        var tagItems;
        var item;
        for (var tag in tagMap) {
            if (tagMap.hasOwnProperty(tag)) {
                tagItems = tagMap[tag];
                item = tagItems[itemId];
                if (item) {
                    delete tagItems[itemId];
                    if (--tagCounts[tag] === 0) {
                        delete tagMap[tag];
                        delete tagCounts[tag];
                    }
                }
            }
        }
        delete items[itemId];
        // Blow away search results cache - could refine this
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };
};;/**
 * Maps tags to lists of items, supports fast queries to find items matching given tags
 */
Human.utils.TagMapList = function () {
    "use strict";

    //  Map of tags to items
    var tagMap = {};

    //  Count of items mapped to each tag
    var tagCounts = {};

    //  Map of all items by ID
    var items = {};

    /**
     * Search results cached against sets of query tags
     */
    var cachedSearchResults;

    /**
     * Insert item into tag map
     */
    this.addItem = function (itemId, tags, item) {
        var tag;
        var tagItems;
        var tagCount;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagItems = tagMap[tag];
            if (!tagItems) {
                tagItems = tagMap[tag] = {};
            }
            tagItems[itemId] = item;
            tagCount = tagCounts[tag];
            if (!tagCount) {
                tagCounts[tag] = 1;
            } else {
                tagCounts[tag]++;
            }
        }
        items[itemId] = item;

        // Blow away search results cache - could refine this
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };

    /**
     * Returns items that match the given tags.
     * Caches them against the tags for fast re-query.
     */
    this.findItems = function (withTags) {
        withTags = withTags || {};
        var tags = withTags.tags || [];
        var key = tags.join(".");
        var matching = withTags.matching || "any";
        if (!cachedSearchResults) {
            cachedSearchResults = {};
        }
        var matchTypeCache = cachedSearchResults[matching];
        if (!matchTypeCache) {
            matchTypeCache = cachedSearchResults[matching] = {};
        }
        var result = matchTypeCache[key];
        if (!result) {
            switch (matching) {
                case "most":
                    result = this._findHitsMost(tags);
                    break;
                case "atLeast":
                    result = this._findHitsAtLeast(tags);
                    break;
                case "any":
                    result = this._findHitsAny(tags);
                    break;
                case "except":
                    result = this._findHitsExcept(tags);
            }
            matchTypeCache[key] = result;
        }
        return result;
    };

    /**
     * Returns the first item found (in lexical order) that
     * matches the largest subset of the given tags.
     */
    this._findHitsMost = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var bestItemId;
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) { // With each item info for tag
                    if (items.hasOwnProperty(itemId)) {
                        var hits = itemHits[itemId]; // Record tag hit for item info
                        if (!hits) {
                            hits = itemHits[itemId] = 1;
                        } else {
                            hits = ++itemHits[itemId];
                        }
                        if (!bestItemId || hits > itemHits[bestItemId]) { // Track item info with most hits
                            bestItemId = itemId;
                        }
                    }
                }
            }
        }
        var result = []; // Return item info with most hits
        if (bestItemId) {
            result.push(items[bestItemId]);
        }
        return result;
    };

    /**
     * Returns items matching the complete set of given tags
     */
    this._findHitsAtLeast = function (tags) {
        var itemHits = {};
        var tag;
        var items;
        var numTags = tags.length;
        var got = {};
        var result = [];
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) { // With each item info for tag
                        if (!got[itemId]) {
                            var hits = itemHits[itemId];    // Record tag hit for item info
                            if (!hits) {
                                hits = itemHits[itemId] = 1;
                            } else {
                                hits = ++itemHits[itemId];
                            }
                            if (hits === numTags) {          // Collect item infos matching
                                result.push(items[itemId]); // all the query tags
                                got[itemId] = true;
                            }
                        }
                    }
                }
            }
        }
        return result;
    };

    /**
     * Returns item infos matching any of the given tags
     */
    this._findHitsAny = function (tags) {
        var tag;
        var items;
        var got = {};
        var result = [];
        for (var i = 0, len = tags.length; i < len; i++) { // With each query tag
            tag = tags[i];
            items = tagMap[tag];
            if (items) {
                for (var itemId in items) {
                    if (items.hasOwnProperty(itemId)) { // With each item info for tag
                        if (!got[itemId]) {
                            result.push(items[itemId]);  // Collect item infos matching the tag
                            got[itemId] = true;
                        }
                    }
                }
            }
        }
        return result;
    };

    /**
     * Returns item infos not matching the given tags
     */
    this._findHitsExcept = function (tags) {
        var result = [];
        var got = {};
        for (var tag in tagMap) {
            if (tagMap.hasOwnProperty(tag)) {
                for (var i = 0, len = tags.length; i < len; i++) {
                    if (tag === tags[i] || got[tag] === true) {
                        continue;
                    }
                    result.push(tagMap[tag]);
                    got[tag] = true;
                }
            }
        }
        return result;
    };

    /** Remove item from map
     */
    this.removeItem = function (itemId) {
        var tagItems;
        var item;
        for (var tag in tagMap) {
            if (tagMap.hasOwnProperty(tag)) {
                tagItems = tagMap[tag];
                item = tagItems[itemId];
                if (item) {
                    delete tagItems[itemId];
                    if (--tagCounts[tag] === 0) {
                        delete tagMap[tag];
                        delete tagCounts[tag];
                    }
                }
            }
        }

        delete items[itemId];

        /* Blow away search results cache - could refine this
         */
        if (cachedSearchResults) {
            cachedSearchResults = null;
        }
    };
};;/**
 * @class Generic map of IDs to items - can generate own IDs or accept given IDs. IDs should be strings in order to not
 * clash with internally generated IDs, which are numbers.
 * @private
 */
Human.utils.Map = function (items, _baseId) {
    "use strict";

    /**
     * @property Items in this map
     */
    this.items = items || [];


    var baseId = _baseId || 0;
    var lastUniqueId = baseId + 1;

    /**
     * Adds an item to the map and returns the ID of the item in the map. If an ID is given, the item is
     * mapped to that ID. Otherwise, the map automatically generates the ID and maps to that.
     *
     * id = myMap.addItem("foo") // ID internally generated
     *
     * id = myMap.addItem("foo", "bar") // ID is "foo"
     *
     */
    this.addItem = function () {

        var item;

        if (arguments.length === 2) {

            var id = arguments[0];

            item = arguments[1];

            if (this.items[id]) { // Won't happen if given ID is string
                throw "ID clash: '" + id + "'";
            }

            this.items[id] = item;

            return id;

        } else {

            while (true) {

                item = arguments[0];
                var findId = lastUniqueId++;

                if (!this.items[findId]) {
                    this.items[findId] = item;
                    return findId;
                }
            }
        }
    };

    /**
     * Removes the item of the given ID from the map and returns it
     */
    this.removeItem = function (id) {
        var item = this.items[id];
        delete this.items[id];
        return item;
    };
};;
/**
 * A fast pool of reusable ids
 */
Human.utils.IDPool = function(cfg) {
    "use strict";

    cfg = cfg || {};

    var prefix = cfg.prefix || "id";
    var prefixLen = prefix.length;
    var idNums = [];
    var clientIds = {};    // IDs explicitly supplied by client
    var internalIds = {};  // IDs internally generated

    /** Gets new ID
     */
    this.getId = function(clientId) {
        if (clientId) {
            // Explicit user-supplied ID
            if (clientIds[clientId] || internalIds[clientId]) {
                throw "ID already in use: " + clientId;
            }
            clientIds[clientId] = true;
            return clientId;
        }
        var internalId;
        // Try to find hole in ID nums
        for (var i = 0, len = idNums.length; i < len; i++) {
            if (!idNums[i]) {
                internalId = prefix + i;
                if (!clientIds[internalId]) { // Don't clobber user ID
                    idNums[i] = true;
                    internalIds[internalId] = true;
                    return internalId;
                }
            }
        }
        // No hole found in ID nums - append new one
        idNums.push(true);
        internalId = prefix + (idNums.length - 1);
        internalIds[internalId] = true;
        return internalId;
    };

    /** Returns true if given ID in use
     *
     * @param id
     * @return {Boolean}
     */
    this.containsId = function(id) {
        return clientIds[id] !== undefined || internalIds[id] !== undefined;
    };

    /** Releases ID to the pool for reuse
     */
    this.putId = function(id) {
        if (clientIds[id]) {
            delete clientIds[id];
        } else {
            idNums[parseInt(id.substr(prefixLen))] = false;
            delete internalIds[id];
        }
    };

};;

/**
 * Base class for all content library loader types.
 *
 * Provides template methods to overload to do the actual load and unload of libraries.
 *
 * Tracks what's loaded against a model/state ID so you can just unload using that ID.
 *
 * @param cfg
 * @param cfg.libraries Library container this loader loads into
 * @param cfg.load Loader strategy

 */
Human.utils.Loader = function () {
    "use strict";

    // Tracks asset libraries that are loaded for models
    this._loadedModelLibs = {};

    /**
     * Override this template method to configure the loader subclass
     */
    this.configure = function () {
    };

    /**
     * Loads a library for a given model
     *
     * @param moduleId
     * @param modelId
     * @param libraryId
     * @param params
     * @param ok
     * @param error
     */
    this.load = function (moduleId, modelId, libraryId, params, ok, error) {
        this._loadedModelLibs[modelId] = this._loadedModelLibs[modelId] || {};
        if (this._loadedModelLibs[modelId][libraryId]) {
            Human.log.warn("Human.utils.Loader.load", "Library '" + libraryId + "' already loaded for model '" + modelId + "' - not reloading");
            ok();
            return;
        }
        var self = this;
        var _ok = function () {
            self._loadedModelLibs[modelId][libraryId] = true;
            ok();
        };
        this._load(moduleId, modelId, libraryId, params,_ok, error);
    };

    /** Override this template method to implement the load method
     *
     * @param moduleId Module that owns this model
     * @param modelId State collection we're loading for
     * @param libraryId Library we're loading
     * @param params Whatever params are involved for this load
     * @param ok Success callback
     * @param error Failure callback
     * @private
     */

    this._load = function (moduleId, modelId, libraryId, params, ok, error) {
        // jshint unused:false

        Human.log.error("Human.utils.Loader._load not implemented");
        ok();
    };

    /**
     * Unloads libraries for the given model
     *
     * @param modelId
     */
    this.unload = function (modelId) {
    //    Human.log.info("Human.utils.Loader.unload", "Unloading model '" + modelId + "'");
        var loaded = this._loadedModelLibs[modelId];
        if (loaded) {
            for (var libraryId in loaded) {
                if (loaded.hasOwnProperty(libraryId)) {
                    this._unload(modelId + "." + libraryId);
                }
            }
            delete this._loadedModelLibs[modelId];
        }
    };

    /** Override this template method to implement unload
     *
     * @param globalLibraryId Library to unload
     * @private
     */
    this._unload = function (globalLibraryId) {
        // jshint unused:false
        
        Human.log.error("Human.utils.Loader._unload", "This method needs to be implemented");
    };
};

;/**
 * @namespace Human RPC interface.
 *
 */
(function () {
    "use strict";

    var rpc = Human.rpc = {};

    /** Map of procedures that have been created with {@link Human.rpc.define}.
     * @memberof Human.rpc
     * @type {{}}
     */
    rpc._procedures = {};

    // Callbacks registered with #onResult
    var resultCallbacks = [];

    /**
     * Execution scope for a procedure execution.
     * <p>A fresh one of these is instantiated for every procedure call, providing the procedure with
     * methods for returning the procedure result and logging.</p>
     * @param {string} procName Procedure name, for logging
     * @param {string} callId ID of procedure call, against which procedure result, if any, will be published
     * @constructor
     */
    function Scope(procName, callId) {
        this.procName = procName;
        this.callId = callId;
    }

    /**
     * Publishes the result of the procedure call.
     * <p>The result value is published against the ID of the caller,
     * who may subscribe to that ID using methods like {#link Human.rpc.on} in order to get the result.</p>
     * @param {{}} value The result value
     */
    Scope.prototype.setResult = function (value) {
        for (var i = 0, len = resultCallbacks.length; i < len; i++) {
            resultCallbacks[i](this.callId, value);
        }
    };

    /**
     * Logs debug info in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.info = function (msg) {
        Human.log.info(this.procName, msg);
    };

    /**
     * Logs a warning in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.warn = function (msg) {
        Human.log.warn(this.procName, msg);
    };

    /**
     * Logs an error in the context of this procedure call.
     * @param {string} msg The message
     */
    Scope.prototype.error = function (msg) {
        Human.log.error(this.procName, msg);
    };

    /**
     * Registers a procedure, which may then be called with {@link #call}.
     *
     * @param {String} procName Procedure name
     * @param {function} proc The procedure
     */
    rpc.define = function (procName, proc) {
        if (rpc._procedures[procName]) {
            Human.log.warn("Human.rpc.define", "Redefining procedure: " + procName);
        }
        rpc._procedures[procName] = function (callId, params) {
            proc.call(new Scope(procName, callId), params || {});
        };
    };

    /**
     * Subscribes to results of subsequent RPC calls.
     *
     * <p>Each time a procedure returns a result, the given callback will be fired
     * with the the ID of the procedure call and the value that was returned.</p>
     *
     * <pre>
     *     #onResult(function(callId, value) {
     *         //..
     *     });
     *
     * @param {function(callId, value)} callback The callback
     * @function
     * @name onResult
     * @memberof Human.rpc
     */
    rpc.onResult = function (callback) {
        resultCallbacks.push(callback);
    };

    /**
     * Calls a procedure that was previously registered with {@link #define}.
     *
     * @param {String} callId ID of the procedure call
     * @param {String} procName Name of procedure
     * @param {{}} [params] Optional parameters for the procedure
     * @function
     * @name create
     * @memberof Human.rpc
     */
    rpc.call = function (callId, procName, params) {
        var proc = rpc._procedures[procName];
        if (!proc) {
            Human.log.warn("Human.rpc.call", "Target procedure not found: " + name);
            return;
        }
        proc(callId, params);
    };

})();
;/**
 * @namespace Provides methods for sending and subscribing events.
 */
(function () {
    "use strict";

    var HumanEvents = Human.events = {};

    var eventBinders = {};

    var DEFAULT_EVENT_CHANNEL = 0;

    var eventChannels = [
        {} // Default channel
    ];

    var enabledEventChannels = {};

    var remembered = {};

    /**
     * Injects a factory function which creates bindings for a given event type. This enables an event source
     * to decide when to fire events based on an event-specific mask that may be optionally given to the .onEvent method.
     *
     * <h3>Works like this:</h3>
     *
     * Human.events.addBinder(
     *      "my-event-type",
     *      function(mask, fn) {  // The factory function
     *
     *          // Creates bindings where fn will be called
     *          // by event source, passing event to it,
     *          // when criteria in mask are met.
     *
     *      });
     * </pre>
     *
     * @memberof Human.events
     */
    HumanEvents.addBinder = function (eventName, eventBinder) {
        (eventBinders[eventName] || (eventBinders[eventName] = [])).push(eventBinder);
    };

    /**
     * Creates an event channel. Events can be fired on these channels,
     * which can be selectively enabled/disabled for efficient dynamic event
     * subscription/unsubsubscription.
     *
     * <h3>Example:</h3>
     * <pre>
     *     var myNewChannel = createEventChannel({
     *        enabled: true
     *     });
     * </pre>
     *
     * @memberof Human.events
     */
    HumanEvents.createChannel = function (cfg) {
        var channel = eventChannels.length;
        eventChannels.push({});
        if (cfg && cfg.enabled) {
            HumanEvents.enableEventChannel(channel, cfg.enabled);
        }
        return channel;
    };

    /**
     * Enable or disable an event channel.
     *
     * @memberof Human.events
     */
    HumanEvents.enableChannel = function (channel, enable) {
        enabledEventChannels[channel] = enable;
    };

    /**
     * Registers a handler for a type of engine event.
     *
     * <p>The handler can be registered with an optional priority number which specifies the order it is
     * called among the other handler already registered for the event.</p>
     *
     * <p>So, with n being the number of handlers registered for the given event:</p>
     * <ul>
     * <li>(priority <= 0)      - handler will be the first called</li>
     * <li>(priority >= n)      - handler will be the last called</li>
     * <li>(0 < priority < n)   - handler will be called at the order given by the priority</li>
     *
     * @param channel - Optional channel name, falls back on default channel when omitted
     * @param type Event type - one of the values in SceneJS._eventModule
     * @param fn - Handler function that will accept whatever parameter object accompanies the event
     * @param priority - Optional priority number (see above)
     * @memberof Human.events
     */
    HumanEvents.onEvent = HumanEvents.on = function () {
        var channel;
        var type;
        var fn;
        var options;
        if (typeof arguments[0] === "number") {
            if (channel > eventChannels.length - 1) {
                Human.log.error("Human_event.onEvent", "Channel not created: " + channel +
                    " - should be created first with Human.events.createChannel");
                return;
            }
            channel = arguments[0];
            type = arguments[1];
            fn = arguments[2];
            options = arguments[3];
        } else if (typeof arguments[0] === "object") {
            var params = arguments[0];
            type = params.type;
            fn = params.fn;
            // Masked subscriptions not (yet) channeled or prioritised
            var binders = eventBinders[type];
            if (binders) {
                var mask = params.mask || {};
                for (var i = 0, len = binders.length; i < len; i++) {
                    binders[i](mask, fn);
                }
            }
            channel = (params.channel !== undefined && params.channel !== null) ? params.channel : DEFAULT_EVENT_CHANNEL;
            options = params.options;
        } else {
            channel = DEFAULT_EVENT_CHANNEL;
            type = arguments[0];
            fn = arguments[1];
            options = arguments[2];
        }
        enabledEventChannels[channel] = (options && options.enable !== undefined && options.enable !== null) ? options.enable : true;
        options = options || {};
        var subscriberLists = eventChannels[channel];
        if (!subscriberLists) {
            subscriberLists = eventChannels[channel] = {};
        }
        var list = subscriberLists[type];
        if (!list) {
            list = [];
            subscriberLists[type] = list;
        }
        var handler = {
            fn: fn,
            priority: (options.priority === undefined) ? list.length : options.priority,
            once: options.once
        };
        for (i = 0; i < list.length; i++) {
            if (list[i].priority > handler.priority) {
                list.splice(i, 0, handler);
                return;
            }
        }
        list.push(handler);
        if (remembered[type]) {
            handler.fn(remembered[type]);
        }
    };

    /** Single-shot event subscribe
     *
     * @param type
     * @param ok
     */
    HumanEvents.once = function (type, ok) {
        var fn = function (result) {
            HumanEvents.off(type, fn);
            ok(result);
        };
        HumanEvents.on(type, fn);
    };

    /**
     * Fire an event.
     * @param {String} type Event type name
     * @param {{}} [params] Map of parameters to accompany the event - must be JSON-serializable.
     * @memberof Human.events
     */
    HumanEvents.fireEvent = HumanEvents.fire = function (type, params, remember) {
        var subscriberLists;
        var list;
        for (var channel = 0, numChannels = eventChannels.length; channel < numChannels; channel++) {
            if (enabledEventChannels[channel]) {
                subscriberLists = eventChannels[channel];
                list = subscriberLists[type];
                if (list) {
                    if (!params) {
                        params = {};
                    }
                    var toRemove;
                    var handler;
                    for (var i = 0, len = list.length; i < len; i++) {
                        handler = list[i];
                        // A handler could be undefined by this time,
                        // should we ever unEvent it before we get here.
                        try {
                            handler.fn(params);
                            if (handler.once) {
                                if (!toRemove) {
                                    toRemove = [];
                                }
                                toRemove.push(i);
                            }
                       } catch(exception) {
                           Human.log.error(exception);
                       }
                    }
                    if (toRemove) {
                        for (i = toRemove.length - 1; i >= 0; i--) {
                            list.splice(toRemove[i]);
                        }
                    }
                }
            }
        }
        if (remember) {
            remembered[type] = params;
        }
    };

    /** Remove a Handler with a certain Function from the List of Handlers for
     * an Event of a certain Type.
     * @memberof Human.events
     */
    HumanEvents.unEvent = HumanEvents.off = function () {  // TODO: unbind for optional channel
        var channel = DEFAULT_EVENT_CHANNEL;
        var type = arguments[ 0 ];
        var fn = arguments[ 1 ];
        var subscriberLists = eventChannels[channel];
        if (!subscriberLists) {
            subscriberLists = eventChannels[ channel ] = {};
        }
        var list = subscriberLists[ type ];
        if (!list) {
            list = [];
            subscriberLists[ type ] = list;
        }
        for (var i = list.length; i--;) {
            if (list[ i ].fn === fn) {
                list.splice(i, 1);
            }
        }
    };
})();;/**
 * RPC procedures for subscription to engine events.
 */
(function () {
    "use strict";

    var callbacks = {};

    /**
     * Subscribes to an engine event
     */
    Human.rpc.define("events.on",
        function (params) {
            var self = this;
            var id = this.id;
            if (id) {
                if (callbacks[id]) {
                    // Support "events.off" for this subscription
                    this.error("an event is already bound to this ID: '" + id + "'");
                    return;
                }
            }
            var type = params.type;
            if (!type) {
                this.error("parameter expected: 'type'");
                return;
            }
            var fn = function (event) {
                self.setResult(event);
            };
            if (params.mask) {
                params.fn = fn;
                Human.events.on(params);
            } else {
                Human.events.on(params.type, fn);
            }
            if (id) { // So we can unbind with "events.off"
                callbacks[id] = [type, fn];
            }
        });

    /**
     * Subscribes to the next engine event of the given type
     */
    Human.rpc.define("events.once",
        function (params) {
            var self = this;
            var type = params.type;
            if (!type) {
                this.error("parameter expected: 'type'");
                return;
            }
            Human.events.once(type, function (event) {
                self.setResult(event);
            });
        });
    
    /**
     * Triggers an engine event
     */
    Human.rpc.define("events.fire",
        function (params) {
            Human.events.fire(params.eventName, params.params);
        });
    
    /**
     * Unsubscribes from an engine event
     */
    Human.rpc.define("events.off",
        function (params) {
            if (params.id) {
                // Undo specific subscription
                unbindEvent(params.id);
            } else if (params.ids) {
                // Undo list of subscriptions
                var ids = params.ids;
                for (var i = 0, len = ids.length; i < len; i++) {
                    unbindEvent(ids[i]);
                }
            } else {
                // Undo all subscriptions
                for (var id in callbacks) {
                    if (callbacks.hasOwnProperty(id)) {
                        unbindEvent(id);
                    }
                }
            }
        });

    function unbindEvent(id) {
        var callback = callbacks[id];
        if (callback) {
            var type = callback[0];
            var fn = callback[1];
            Human.unEvent(type, fn);
            delete callbacks[id];
        }
    }
})();;/**
 * @namespace Provides methods for logging debug info, warnings and errors.
 */
(function () {
    "use strict";

    var log = Human.log = {};

    /**
     * Logging level at which nothing is logged
     * @memberof Human.log
     * @private
     */
    log.LOG_NONE = 0;

    /**
     * Logging level at which everything is logged
     * @memberof Human.log
     * @private
     */
    log.LOG_DEBUG = 1;

    /**
     * Logging level at which only info, warnings and errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_INFO = 2;

    /**
     * Logging level at which only warnings and errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_WARN = 3;

    /**
     * Logging level at only errors are logged
     * @memberof Human.log
     * @private
     */
    log.LOG_ERROR = 4;

    // Used in event that notifies on each logged message
    var levelNames = ["none", "debug", "info", "warn", "error"];

    // Buffers messages until engine ready, at which point
    // they are each fired off in a Log.Message event
    var messageBuf = [];
    var maxMessageBuf = 200;

    var minLogLevel;

    // Reporters which may be registered to report logging messages as they happen
    var reporters = {};

    /**
     * Sets minimum log level. Messages logged to levels below that will then not be reported.
     * @memberof Human.log
     * @private
     */
    log.setLevel = function (newLevel) {
        minLogLevel = newLevel;
    };

    /**
     * Returns the current minimum log level
     * @memberof Human.log
     * @private
     */
    log.getLevel = function () {
        return minLogLevel;
    };

    log.setLevel(log.LOG_INFO); // Set default level

    /**
     * Logs a message at the given logging level.
     * @memberof Human.log
     * @private
     */
    log.log = function (message, level) {
        level = (level === undefined || level === null) ? log.INFO : level;
        switch (level) {
            case log.LOG_DEBUG:
                if (minLogLevel <= log.LOG_DEBUG && window.console && window.console.debug) {
                    window.console.debug(message);
                }
                break;
            case log.LOG_ERROR:
                if (minLogLevel <= log.LOG_ERROR && window.console && window.console.error) {
                    window.console.error(message);
                }
                break;
            case log.LOG_INFO:
                if (minLogLevel <= log.LOG_INFO && window.console && window.console.info) {
                    window.console.info(message);
                }
                break;
            case log.LOG_WARN:
                if (minLogLevel <= log.LOG_WARN && window.console && window.console.warn) {
                    window.console.warn(message);
                }
                break;
        }
        var event = {
            message: message,
            level: levelNames[level]
        };
        // Fire off to existing reporters
        for (var reporterId in reporters) {
            if (reporters.hasOwnProperty(reporterId)) {
                Human.events.fire(reporterId, event);
            }
        }
        // If message buffer now too long, flush and start it again with warning
        if (messageBuf.length > maxMessageBuf) {
            messageBuf.length = 0;
            messageBuf.push({
                message: "Logging buffer exceeded max length of " + maxMessageBuf + 
                    " - messages to this point were flushed",
                level: levelNames[log.LOG_WARN]
            });
        }
        // Buffer message for reporters which may be created later
        messageBuf.push(event);
    };

    /** Logs a debugging message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.debug = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_DEBUG);
    };

    function pad(str) {
        return (str.length < 45) ? str + "                                                           ".substr(0, 45 - str.length) : str;
    }

    /** Logs an error message
     * @name error
     * @function
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.error = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_ERROR);
    };

    /** Logs an info message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.info = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_INFO);
    };

    /** Logs a warning message
     * @memberof Human.log
     * @param {String} [origin] ID of whatever module is doing the logging
     * @param {String} message Message to log
     */
    log.warn = function () {
        log.log((arguments.length === 1) ? arguments[0] : "[" + pad(arguments[0]) + "] " + arguments[1], log.LOG_WARN);
    };

    // Relay engine errors through logging methods
    Human.events.on("error",
        function (event) {
            log.error(event.message);
        });

    // Creates a log reporter
    // For network efficiency, this allows networked clients to only get
    // logging if they are interested in it. Potentially this is also
    // good for compression of that logging.
    Human.rpc.define("log.createReporter",
        function (params) {
            if (!params.id) {
                log.error("param expected: id");
                return;
            }
            var id = "log.reporters." + params.id;
            if (reporters[id]) {
                // TODO: complain
                return;
            }
            reporters[id] = {};
            // Update reporter with events so far
            for (var i = 0, len = messageBuf.length; i < len; i++) {
                Human.events.fire(id, messageBuf[i]);
            }
        });

    // Destroys a log reporter
    Human.rpc.define("log.destroyReporter",
        function (params) {
            if (!params.id) {
                log.error("param expected: id");
                return;
            }
            var id = "log.reporters." + params.id;
            delete reporters[id];
        });

})();



;/**
 @namespace Engine configs definition, update, subscription and query.

 <p>Properties are various engine configurations, such as background color in the 3D view, or mouse sensitivity.</p>

 <h3>Setting a property:</h3>
 <p>This will define the property if it doesn't already exist.</p>
 <pre>
 Human.properties.set({
        "annotations.style.default" : {
            displayName: "Default annotation config",
            pinHeadColor: { r: 1.0, g: 0.5, b: 0.5 },
            pinShaftColor: { r: 1.0, b: 1.0, g: 0.0 }
        }
  });
 </pre>
 <h3>Setting multiple properties:</h3>
 <pre>
 Human.properties.set({
        "annotation.teacher" : {
            pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
            pinShaftColor: { r: 1.0,b: 0.0, g: 1.0 }
        }
        "annotation.student" : {
            pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 }
            pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
        }
    });
 </pre>
 <h3>Querying properties</h3>
 <p>Querying all engine properties:</p>
 <pre>
 Human.properties.query();
 </pre>
 <p>Result:</p>
 <pre>
 {
     "annotation.default" : {
          pinHeadColor: { r: 1.0, g: 0.5, b: 0.5 },
          pinShaftColor: { r: 1.0, b: 1.0, g: 0.0 }
      },
      "annotation.teacher" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      },
      "annotation.student" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      }
  }
 </pre>

 <p>Querying engine properties with keys matching a regular expression:</p>
 <pre>
 Human.properties.query("teacher");
 </pre>
 <p>Result:</p>
 <pre>
 {
      "annotation.teacher" : {
          pinHeadColor: { r: 1.0, g: 0.0, b: 0.0 },
          pinShaftColor: { r: 1.0, b: 0.0, g: 1.0 }
      }
  }
 </pre>

 <h3>Subscribing to a property</h3>
 <p>A property may be subscribed to by a consumer who wants to be notified of any change to its value.</p>
 <ul>
 <li>The property will be created first if it does not yet exist, and a subscriber can provide an initial value to assign to the property if
 it is being created.</li>
 <li>The subscription will return an ID which is a handle to the subscription which can be used to unsubscribe. By default,
 the subscription ID is automatically generated, but the subscriber may optionally provide their own subscription ID instead.</li>
 </ul>
 <pre>
 var subId = Human.properties.subscribe({

          // Optional subscriber-managed ID.
          // Auto-generated if not supplied.
          subId: "mySub",

          // Mandatory property ID
          propId: "annotation.student",

          // Default config properties - these are overridden by
          // any properties that are previously or subsequently set
          // by a Config.Set command:
          value: {
              pinHeadColor:  { r: 1, g: 0, b: 0 },
              pinShaftColor: { r: 1, g: 1, b: 0 }
          },

          // Callback fired each time the config properties are set,
          // and immediately when the config is bound in this call:
          callback: function(props) {

              if (props.pinHeadColor) {
                 theAnnotation.setPinHeadColor(props.pinHeadColor);
              }

              if (props.pinShaftColor) {
                theAnnotation.setPinShaftColor(props.pinShaftColor);
             }

          }
  });
 </pre>

 <h3>Unsubscribing from a property:</h3>
 <pre>
 Human.properties.unsubscribe(subId);
 </pre>
 */
(function () {
    "use strict";

    var HumanProperties = Human.properties = {}; 

    // Subscription handle map, can internally generate new handles,
    // as well as insert user-generated handles
    var idPool = new Human.utils.IDPool();

    /**
     * Currently defined properties
     * @type {{*}}
     * @memberof Human.properties
     */
    HumanProperties.properties = {};

    // Maps subscription handles to callbacks
    var subCallbacks = {};

    // For each style, a map of callbacks mapped to subscription IDs
    var propSubCallbacks = {};

    // Maps subscription handles to property IDs
    var subProps = {};

    /**
     * Subscribes to a property, defining it first if not defined, and optionally setting its value
     *
     * <pre>
     *
     * // This format is extensible, eg. in case we want to add metadata etc
     *
     * var subId = Human.properties.subscribe({
     *          subId: "foo", // Call can opt to manage subscription IDs themselves
     *          propId: "myProperty",
     *          value: {
     *              color: { r: 0.2, g: 0.7, b: 1.0 },
     *              width: 1.2
     *          },
     *          callback: function(config) {
     *              someElement.setColor(config.color);
     *              someElement.setWidth(config.width);
     *          }
     *     });
     * </pre>
     *
     * @memberof Human.properties
     * @return {String} Handle to the subscription, which can be given to {@link Human.properties.unsubscribe} to unsubscribe
     */
    HumanProperties.subscribe = function (params) {

        params = params || {};

        // Every property has an ID
        var propId = params.propId;
        if (!propId) {
            Human.log.error("Human.properties.subscribe", "Param expected: propId");
            return null;
        }

        // Subscriber gets updates via callback
        var callback = params.callback;
        if (!callback) {
            Human.log.error("Human.properties.subscribe", "Param expected: callback");
            return null;
        }

        // If caller supplies own subscription handle, ensure no clash with existing handles
        if (params.subId) {
            if (idPool.containsId(params.subId)) {
                Human.log.error("Human.properties.subscribe", "Subscription already exists with this ID: " + params.subId);
                return null;
            }
        }

        var value = params.value;
        var subId = idPool.getId(params.subId); // Generate or insert subscription handle in map
        var prop = HumanProperties.properties[propId];

        if (prop) {

            // Property already exists

            if (value) {

                // New value supplied; set the property
                HumanProperties.properties[propId] = value;
            }

            // Map callback to subscription handle
            subCallbacks[subId] = callback;

            // Map property to subscription handle
            subProps[subId] = propId;

            // Notify callback of new property value
            callback(value);

            // Return subscription handle
            return subId;
        }

        // Register callback for the new property
        var callbacks = (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}));
        callbacks[subId] = callback;

        // Initial value not given, initialize to default
        if (value === undefined || value === null) {
            value = {}; // Might as well be a literal object
        }

        // Set property to new value
        HumanProperties.properties[propId] = value;

        // Map callback to subscription handle
        subCallbacks[subId] = callback;

        // Map property to subscription handle
        subProps[subId] = propId;

        // Notify callback of new property
        callback(value);

        // Return subscription handle
        return subId;
    };

    /**
     * Switches a subscription to a different property
     *
     * @param {String} subId Subscription handle that was obtained with {@link Human.properties.subscribe}
     * @param {String} propId ID of property to switch the subscription to
     * @memberof Human.properties
     */
    HumanProperties.resubscribe = function (subId, propId) {
        var callback = subCallbacks[subId];
        if (!callback) {
            Human.log.warn("Human.properties.resubscribe", "Subscription not found: '" + subId + "'");
            return;
        }
        var oldPropId = subProps[subId];
        var newProp = HumanProperties.properties[propId];
        if (oldPropId && newProp) {
            if (propSubCallbacks[oldPropId]) {
                delete propSubCallbacks[oldPropId][subId];
            }
            (propSubCallbacks[propId] || (propSubCallbacks[propId] = {}))[subId] = callback;
            subProps[subId] = propId;
            callback(newProp);
        }
    };

    /**
     * Creates or edits one or more properties
     * @memberof Human.properties
     * @param {String} propId ID of config
     * @param {*} props Properties to write to the config
     */
    HumanProperties.set = function (props) {
        var value;
        var callbacks;
        for (var propId in props) {
            if (props.hasOwnProperty(propId)) {
                value = props[propId];
                HumanProperties.properties[propId] = value;
                callbacks = propSubCallbacks[propId];
                if (callbacks) {
                    for (var subId in callbacks) {
                        if (callbacks.hasOwnProperty(subId)) {
                            callbacks[subId](value);
                        }
                    }
                }
            }
        }
    };

    /**
     * Unsubscribes from a property
     * @memberof Human.properties
     * @param {String} subId Subscription ID
     */
    HumanProperties.unsubscribe = function (subId) {
        var propId = subProps[subId];
        if (!propId) {
            return;
        }
        delete subProps[subId];
        delete propSubCallbacks[propId][subId];
    };

    /**
     * Query existing props
     * @param {String} [regex] Regular expression to select properties by name
     * @returns {*} JSON map of queried props
     */
    HumanProperties.query = function (regex) {
        if (!regex) {
            return HumanProperties.properties;
        }
        var props;
        if (regex) {
            var pattern = new RegExp(regex);
            props = {};
            for (var propId in HumanProperties.properties) {
                if (HumanProperties.properties.hasOwnProperty(propId)) {
                    if (pattern.test(propId)) {
                        props[propId] = HumanProperties.properties[propId];
                    }
                }
            }
        }
        return props;
    };
})();



;(function() {
    "use strict";

    Human.rpc.define("properties.set",
        function (params) {
            //backwards compatibility for older API libraries
            var props = params.props || params;
            Human.properties.set(props || {});
        });

    Human.rpc.define("properties.subscribe",
        function (params) {
            var self = this;
            Human.properties.subscribe({
                subId: params.subId,
                propId: "myProperty",
                callback: function (value) {
                    self.setResult(value);
                }
            });
        });

    Human.rpc.define("properties.resubscribe",
        function (params) {
            Human.properties.resubscribe(params.subId, params.propId);
        });

    Human.rpc.define("properties.unsubscribe",
        function (params) {
            Human.properties.unsubscribe(params.subId);
        });

    Human.rpc.define("properties.query",
        function (params) {
            this.setResult(Human.properties.query(params.regex));
        });
})();
;(function () {
    "use strict";

    var HumanCookies = Human.cookies = {};

//    /**
//     * Values of all available cookies
//     * @type {String:String}
//     */
//    HumanCookies.cookies = {};
//
//    // Get the document's cookies
//    var c = document.cookie.split(';');
//    var tokens;
//    for (var i = 0, len = c.length; i < len; i++) {
//        tokens = c[i].split('=');
//        if (tokens.length == 2) {
//            HumanCookies.cookies[tokens[0]] = tokens[1];
//        }
//    }
//
//    /**
//     * Sets or removes a cookie
//     *
//     * @memberof Human.cookies
//     * @param {String} name Cookie name
//     * @param {String} [value] Cookie value - clears the cookie when null or omitted
//     */
//    HumanCookies.setCookie = function (name, value) {
//        if (value == undefined || value == null) {
//            // Clear cookie
//            delete HumanCookies.cookies[name];
//        } else {
//            // Set cookie
//            HumanCookies.cookies[name] = value;
//        }
//        save.call(this);
//    };
//
//    // Saves cookies on the document
//    function save() {     // TODO: Deferred call on tick if called frequently?
//        var list = [];
//        var numCookies = 0;
//        for (var name in HumanCookies.cookies) {
//            if (HumanCookies.cookies.hasOwnProperty(name)) {
//                if (numCookies++ > 0) {
//                    list.push(";");
//                }
//                list.push(name);
//                list.push("=");
//                list.push(HumanCookies.cookies[name]);
//            }
//        }
//        document.cookie = list.join("");
//    }

    HumanCookies.setCookie = function (name, value, days) {
        var expires;

        if (days) {
            var date = new Date();
            date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000));
            expires = "; expires=" + date.toGMTString();
        }
        else {
            expires = "";
        }
        document.cookie = name + "=" + value + expires + "; path=/";
    };

    HumanCookies.getCookie = function (name) {
        var nameEQ = name + "=";
        var ca = document.cookie.split(';');
        for (var i = 0; i < ca.length; i++) {
            var c = ca[i];
            while (c.charAt(0) === ' ') {
                c = c.substring(1, c.length);
            }
            if (c.indexOf(nameEQ) === 0) {
                return c.substring(nameEQ.length, c.length);
            }
        }
        return null;
    };

    HumanCookies.eraseCookie = function (name) {
        HumanCookies.setCookie(name, "", -1);
    };
})();;/**
 * @namespace Supports query of params on URL in browser location bar.
 */
(function () {
    "use strict";

    var request = Human.request = {};

    var prevHash;
    var hashParams;
    var searchParams;

    request.getHashStr = function () {
        return window.location.hash;
    };

    /**
     * Gets all hash params.
     * @memberof Human.request
     * @return {*}
     */
    request.getHashParams = function () {
        if (!hashParams || prevHash !== window.location.hash) {
            hashParams = {};
            var stringAfterHash = window.location.hash.slice(1);
            var paramsAfterHash = stringAfterHash.split(',');
            var tokens;
            for (var i = 0, len = paramsAfterHash.length; i < len; i++) {
                tokens = paramsAfterHash[i].split("=");
                hashParams[tokens[0]] = tokens[1];
            }
            prevHash = window.location.hash;
        }
        return hashParams;
    };

    /** Gets a selected hash param - those params after the hash in the URL.
     * @memberof Human.request
     *
     * @param {String} key Hash parameter key
     * @return {String} Value of the hash parameter
     */
    request.getHashParam = function (key) {
        if (!hashParams || prevHash !== window.location.hash) {
            request.getHashParams();
        }
        return hashParams[key];
    };

    /**
     * Gets the search string - those params after the "?" in the URL.
     * @memberof Human.request
     * @return {String} The search string
     */
    request.getSearchStr = function () {
        return window.location.search;
    };

    /**
     * Get all search parameters.
     * @memberof Human.request
     * @return {*}
     */
    request.getSearchParams = function () {
        if (!searchParams) {
            searchParams = {};
            var search = window.location.search.slice(1);
            var params = search.split('&');
            var tokens;
            for (var i = 0, len = params.length; i < len; i++) {
                tokens = params[i].split("=");
                searchParams[tokens[0]] = tokens[1];
            }
        }
        return searchParams;
    };

    /** Gets a selected search parameter
     * @memberof Human.request
     *
     * @param {String} key Search parameter key
     * @return {String} Value of the search parameter
     */
    request.getSearchParam = function (key) {
        if (!searchParams) {
            request.getSearchParams();
        }
        return searchParams[key];
    };

})();;(function() {
	"use strict";

	Human.rpc.define("request.getParams",
	    function () {
	        this.setResult({
	            hashParams: Human.request.getHashParams(),
	            hashStr: Human.request.getHashStr(),
	            searchParams: Human.request.getSearchParams(),
	            searchStr: Human.request.getSearchStr()
	        });
	    });
})();
;/**
 * @namespace Provides methods for installing initialization scripts and resetting the engine.
 */
(function () {
    "use strict";

    var HumanInit = Human.init = {}; 

    var requires = [];
    var started = false;

    /**
     * Bookmark of Human's initial state. An full engine reset is performed by restoring this bookmark.
     * @type {{}}
     * @memberof Human.init
     */
    HumanInit.bookmark = {};

    /**
     * Bookmark of Human's initial camera state. A camera reset is performed by restoring this bookmark.
     * @type {{}}
     * @memberof Human.init
     */
    HumanInit.cameraBookmark = {};

    var urlParams = Human.request.getHashParams();
    var pluginsPath = location.origin + location.pathname.substring(0, location.pathname.lastIndexOf("/")) + "/lib/scenejs/plugins";
    var validateShaders = (urlParams.validateShaders === "true");
    var enableVAO = (urlParams.enableVAO !== "false");
    var enableInterleaving = (urlParams.enableInterleaving !== "false");

    // Configure SceneJS
    SceneJS.setConfigs({
        texturing: {
            waitForLoad: true // Set true to make objects wait for their material's textures to load
        },
        // Where SceneJS finds its plugin bundle
        pluginPath: pluginsPath,
        statusPopups: false, // Disable the default status popups
        validateShaders: validateShaders, // Validate shaders before drawing with them - debug mode only
        enableVAO: enableVAO, // Enable or disable the "OES_vertex_array_object" WebGL extension
        enableInterleaving: enableInterleaving // Enable or disable vertex array interleaving
    });

    // Fatal error handling
    (function () {

        // Ensures only first error handled in a cascade
        var errorCaught;

        SceneJS.bind("error",
            function (e) {
                handleError(e, "WEBGL");
            });

        Human.onError(
            function (e) {
                handleError(e, "HUMAN");
            });

        /** Posts error to logger service and redirects to error page
         * @param e The error
         * @param e.errorName Error name, eg "ERROR" or "OUT_OF_VRAM"
         * @param e.exception The exception, eg "There was an error"
         * @param e.message Human-readable error message
        */
        function handleError(e, type) {
            if (!errorCaught) {  // Only catch first error
                errorCaught = true;
                if (urlParams.noErrorRedirect === "true") {
                    debugInfoAlert();
                } else {
                    postError(e.errorName || "ERROR", e.exception || e.message);
//                        if (Human.configs.embedded && Human.configs.embedded == true) {
//                            window.location.replace("embedded-low.html");
//                        } else {
                    if (document.URL.indexOf("embedded.html") === -1) {
                        window.location.replace("webgl-error.html?error=" + (e.errorName || "ERROR") + "&message=[" + type + "] " + (e.exception || e.message));
                    }
                    //}
                }
            }
        }

        // Alerts user of fatal error
        function debugInfoAlert() {
            alert("An error has occurred; 'noErrorRedirect=true' is specified on URL, so logging debug info to console without redirecting to recovery page");
        }

        // Posts error to logging service
        function postError(category, message) {
            jQuery.post("/ws/human-error", {
                    category: category,
                    log: (Human.log.messages || []).join(),
                    message: message
                }
            );
        }

        // Backdoor for testing in dev
        window.__testError = function () {
            handleError({ errorName: "A mock error", message: "A mock error has occurred for testing purposes" }, "WEBGL");
        };
    })();


    // RequireJS timeout for slow connections
    require.config({
        waitSeconds: 30
    });

    /**
     * Saves engine state to restore to when {@link #reset} is called.
     * If the engine has multiple modules currently active, then the bookmark will capture only
     * the activation of the first module that was activated. For example, is we have two modules active,
     * say, male anatomy and healthy heart beat, then restoring the bookmark will put the engine back
     * into the state it was in right after loading, before the user selected a condition or
     * bookmark, or whatever additional content.
     */
    HumanInit.saveReset = function () {
        var bookmark = Human.bookmarks.capture();
        var modules = bookmark.modules;
        if (modules) {
            var active = modules.active;
            if (active && active.length > 1) {
                // Ensure only first active module will be reactivated when bookmark restored
                modules.active = [modules.active[0]];
            }
        }
        HumanInit.bookmark = bookmark;
        HumanInit.bookmarkCamera = Human.bookmarks.capture({ camera: true });
    };

    function scope(path, module, params, requires, ok) {
        function _require(path, params) {
            requires.unshift({path: path, params: params || {}});
        }

        requireFn = _require;
        if (module) {
            module.call(new Human.init.ModuleScope(path), params,
                function () {
                    nextRequire();
                },
                function (errMsg) {
                    Human.log.error("Error in init module: " + path + " : " + errMsg);
                    nextRequire();
                });
        } else {
            nextRequire();
        }
        function nextRequire() {
            if (requires.length === 0) {
                requireFn = _require;
                ok();
            } else {
                var r = requires.pop();
                if (r.path) {
                    var path = r.path;
                    var params = r.params;
                    Human.log.info("Human.init", "Loading init script: " + path);
                    require([path],
                        function (module) {
                            scope(path, module, params, [], nextRequire);
                        });
                } else if (r.callback) {
                    r.callback(nextRequire);
                }
            }
        }
    }

    var requireFn;

    /** Adds an init script and optional parameters.
     * <p>Complete info on init scripts may be found on the Human Data
     * Wiki <a href="https://github.com/biodigital/HumanData/wiki/Init-Scripts" target="_other">here</a>.</p>
     *
     * <h3>Example:</h3>
     * <pre>
     * Human.init
     *      .require("foo.js", { someParam: "alpha", otherParam: "beta" })
     *      .require("bar.js")
     *      .require("baz.js");
     * </pre>
     * @function
     * @param path
     * @param params
     * @return {Human.init}
     * @memberof Human.init
     */
    HumanInit.require = function (path, params) {
        if (started) {
            Human.log.error("Human.init.require", "Engine already started, ignoring script: " + path);
            return this;
        }
        if (requireFn) {
            requireFn(path, params || {});
        } else {
            requires.unshift({path: path, params: params || {}});
        }
        return this;
    };


    /** Adds a step to the init sequence.
     * <p>Complete info on init scripts may be found on the Human Data
     * Wiki <a href="https://github.com/biodigital/HumanData/wiki/Init-Scripts" target="_other">here</a>.</p>
     *
     * <h3>Example:</h3>
     * <pre>
     * Human.init
     *      .require("foo.js", { someParam: "alpha", otherParam: "beta" })
     *      .stage(function() {
     *           // Do something
     *      })
     *      .require("baz.js");
     * </pre>
     * @function
     * @param callback
     * @return {Human.init}
     * @memberof Human.init
     */
    HumanInit.step = function (callback) {
        if (started) {
            Human.log.error("Human.init.stage", "Engine already started, ignoring");
            return this;
        }
        requires.unshift({callback: callback});
        return this;
    };

    /**
     * Resets Human state to how it was just after it started up, ie before the user modifies the
     * view, activates a module, or loads a bookmark.
     *
     * @name reset
     * @function
     * @param {Function} [ok] Callback which signals when reset complete
     * @memberof Human.init
     */
    HumanInit.reset = function (ok) {
        // Resets app by restoring its state to the
        // bookmark that was captured after startup
        if (!HumanInit.bookmark) {
            Human.log.error("Human.init.reset", "Bookmark for reset was not captured");
            if (ok) {
                ok();
            }
            return;
        }
        Human.bookmarks.restore(HumanInit.bookmark,
            function () {
                Human.events.fire("init.reset");
                if(ok) {
                    ok();
                }
            },
            function (err) {
                Human.log.error("Human.init.reset", "Reset failed: " + err);
                if (ok) {
                    ok();
                }
            });
    };

    /**
     * Resets Human camera state to how it was just after it started up, ie before the user modifies the
     * view, activates a module, or loads a bookmark.
     *
     * @name resetCamera
     * @function
     * @param {Function} [ok] Callback which signals when camera reset complete
     * @memberof Human.init
     */
    HumanInit.resetCamera = function (ok) {

        // Try to reset to the initial camera position off the most recently activated module,
        // otherwise reset to the camera that was captured after the engine started up.

        var mostRecentModule;
        var module;
        var time = 0;
        var activeModules = Human.modules.activeModules;
        for (var moduleId in activeModules) {
            if (activeModules.hasOwnProperty(moduleId)) {
                module = activeModules[moduleId];
                if (module.camera && module.timeActivated > time) {
                    mostRecentModule = module;
                }
            }
        }
        if (mostRecentModule) {
            Human.view.camera.fly.flyTo(mostRecentModule.camera, ok);
            return;
        }

        // Reset to camera bookmarked after startup
        if (!HumanInit.bookmark) {
            Human.log.error("Human.init.resetCamera", "Bookmark for reset was not captured");
            if (ok) {
                ok();
            }
            return;
        }
        Human.view.camera.fly.flyTo(HumanInit.bookmark.camera, ok);
    };

    /** Reloads the page/frame that contains the engine
     * @function
     * @name reload
     * @memberof Human.init
     */
    HumanInit.reload = function () {
        window.location.reload(); // No point in chaining further commands
    };

    HumanInit.ModuleScope = function (path) {
        var logPrefix = "[Init script " + path + "] ";
        HumanInit.log = {
            info: function (msg) {
                Human.log.info(logPrefix, msg);
            },
            warn: function (msg) {
                Human.log.warn(logPrefix, msg);
            },
            error: function (msg) {
                Human.log.error(logPrefix, msg);
            }
        };
    };

    /**
     *
     * @param initScript
     */
    HumanInit.start = function (initScript, ok) {

        // Load root init script
        HumanInit.require(initScript);

        // Initialize SceneJS renderer, which initialized asynchronously because
        // it may have to pull in lazy-loaded plugins for extra scene node types.
        Human.renderer.init(
            function () {

                // Renderer ready and all engine JS scripts loaded
                Human.events.fire("loaded");

                //   Human.processes.startProcess({ processId: "init", statusText: "Loading" });
                scope(null, null, null, requires,
                    function () {
                        // All init scripts executed
                        started = true;
                        HumanInit.saveReset();
                        //Human.processes.finishProcess({ processId: "init" });
                        Human.events.fire("started");
                        if (ok) {
                            ok();
                        }
                    });
            });
    };

})();
;(function() {
    "use strict";

    Human.rpc.define("reset",
        function () {
            var self = this;
            Human.init.reset(function () {
                    self.setResult(true);
                });
        });

    Human.rpc.define("reload",
        function () {
            Human.init.reload();
        });


    Human.rpc.define("alert",
        function (params) {
            window.alert(params.message || "");
        });

})();

;/**
 * @namespace Tracks processes within the engine
 *
 * Fires notifications when processes start, stop or fail
 */

(function () {
    "use strict";

    var processes = Human.processes = {};

    /**
     * Existing processes
     * @type {Object}
     */
    processes.processes = {};

    // Number of processes for fast lookup
    processes.numProcesses = 0;

    /**
     * Notifies of process start, produces a "processes.started" event
     * @param params
     * @param params.processId Caller-managed process ID
     * @param params.statusText Optional status text
     */
    processes.startProcess = function (params) {
        var processId = params.processId;
        if (!processId) {
            Human.log.error("Human.processes.startProcess", "Param expected: processId");
            return;
        }
        if (processes.processes[processId]) {
            Human.log.warn("Human.processes.startProcess", "Process already exists: '" + processId + "'");
            return;
        }
     //   Human.log.info("Human.processes.startProcess", "Starting: '" + processId + "'");
        params.scaleProgress = params.scaleProgress || 1;
        processes.processes[processId] = params;
        params.numProcesses = ++processes.numProcesses;
        Human.events.fire("processes.started", params);
    };

    /**
     * Notifies of process continuation, produces a "processes.updated" event
     * @param params
     * @param params.processId Caller-managed process ID
     * @param params.statusText Optional status text
     */
    processes.updateProcess = function (params) {
        var processId = params.processId;
        if (!processId) {
            Human.log.error("Human.processes.updateProcess", "Param expected: processId");
            return;
        }
//        if (params.progress == null || params.progress == undefined) {
//            Human.log.error("Human.processes.updateProcess", "Param expected: progress");
//            return;
//        }
        if (!processes.processes[processId]) {
            // Human.log.error("Human.processes.updateProcess", "Process not found: '" + processId + "'");
            return;
        }
      //  Human.log.info("Human.processes.updateProcess", "Updating: '" + processId + "'");
        params.scaleProgress = params.scaleProgress || 1;
        params.numProcesses = processes.numProcesses;
        Human.events.fire("processes.updated", params);
    };

    /**
     * Notify of process completion, produces a "processes.finished" event
     * @param params
     * @param params.processId Caller-managed process ID
     * @param params
     */
    processes.finishProcess = function (params) {
        var processId = params.processId;
        if (!processId) {
            Human.log.error("Human.processes.finishProcess", "Param expected: processId");
            return;
        }
        if (!processes.processes[processId]) {
            Human.log.warn("Human.processes.finishProcess", "Process not found: '" + processId + "'");
            return;
        }
       // Human.log.info("Human.processes.finishProcess", "Finishing: '" + processId + "'");
        delete processes.processes[processId];
        params.numProcesses = --processes.numProcesses;
        Human.events.fire("processes.finished", params);
    };

    /**
     * Notify of process failure
     * @param params
     */
    processes.failProcess = function (params) {
        var processId = params.processId;
        if (!processId) {
            Human.log.error("Human.processes.failProcess", "Param expected: processId");
            return;
        }
        if (!processes.processes[processId]) {
            Human.log.warn("Human.processes.failProcess", "Process not found: '" + processId + "'");
            return;
        }
        delete processes.processes[processId];
        params.numProcesses = --processes.numProcesses;
        Human.events.fire("processes.failed", params);
    };

})();;(function () {
    "use strict";

    var net = Human.net = {};

    var contentDir = "content";

    net.mode = "stream";
    var streamMode = true;
    var base = "";
    var prefix = "";
    var modelDir = "";
    var streamBuffer;
    var streamBaseIndex;
    var streamIndex;

    net.getModuleDb = function (dbId, ok, error) {
        $.ajax({
            dataType: "json",
            url: contentDir + "/modules/db/" + dbId,
            success: ok,
            error: function (xhr, textStatus, errorThrown) {
                error(errorThrown);
            }
        });
    };

    net.getModuleManifest = function (libId, ok, error) {
        $.ajax({
            dataType: "json",
            url: contentDir + "/modules/" + libId,
            success: ok,
            error: function (xhr, textStatus, errorThrown) {
                error(errorThrown);
            }
        });
    };

    net.getModuleDefinition = function (moduleName, ok, error) {
        $.ajax({
            dataType: "json",
            url: contentDir + "/modules/" + moduleName,
            success: ok,
            error: function (xhr, textStatus, errorThrown) {
                error(errorThrown);
            }
        });
    };

    /**
     * Select which source we'll access data from
     * @param mode
     */
    net.setMode = function (mode) {
        switch (mode) {
            case "stream":
                streamMode = true;
                base = "";
                break;
            case "file":
                streamMode = false;
                base = "./" + contentDir + "/";
                break;
            default:
                Human.log.error("Human.net.setMode", "Mode not supported: '" + mode + "'");
                return;
        }
        net.mode = mode;
        Human.log.info("Human.net.setMode", "Mode set to: " + mode);
    };

    Human.properties.subscribe({
        propId: "modules.contentSource",
        value: "stream",
        callback: function (mode) {
            net.setMode(mode);
        }
    });

    /**
     * Opens a model
     *
     * <p>All other calls on Human.Net will then be fetching elements from within
     * that model.</p>
     *
     * <p>In "stream" mode, this method will open a stream, and those other methods will
     * be extracting files from within the stream.</p>
     *
     * <p>In "file" mode, this method will point Human.Net at a directory that contains
     * the required model, then the other methods will be loading files from within
     * that directory</p>
     *
     * @param {String} modelId Either a model ID for "stream" mode, or a path to a directory for "file" mode.
     * @param {Object} streamObjects Subset of model objects to return in the stream. Used with the embedded window in "stream" mode.
     * @param {Function} ok Success callback, fired once stream or directory is opened.
     * @param {Function} error Error callback
     */
    net.openModel = function (modelId, streamObjects, ok, error) {
        if (!streamMode) {
            prefix = "./" + contentDir + "/states/" + modelId + "/";
            modelDir = "./" + contentDir + "/states/" + modelId + "/";
            ok();
            return;
        }
        var url = "./" + contentDir + "/streams/" + modelId + ".bin";
        // if (streamObjects) {
        //     url += "?" + $.param(streamObjects);
        // }
        var streamObjectsArgs = null;
        if (streamObjects) {
            streamObjectsArgs = $.param(streamObjects);
        }
        //   Human.processes.startProcess({ processId: url, statusText: "Loading..."});
        loadArrayBuffer(url,
            function (buffer) {
                streamBuffer = buffer;
                var listingLengthView = new Uint32Array(buffer, 0, 1);
                var listingLength = listingLengthView[0];
                // add baseIndex to the offsets in the listing
                streamBaseIndex = 4 + listingLength; // bytes
                // listingLength is the byte-length of the listing JSON
                // var listingView = new Uint8Array(buffer, 1, listingLength);
                streamIndex = atoj(4, listingLength);
                modelDir = "./" + contentDir + "/states/" + modelId + "/";
                prefix = contentDir + "/states/" + modelId + "/";
                Human.processes.finishProcess({ processId: url });
                ok();
            },
            function (err) {
                //  Human.processes.failProcess({ processId: url });
                error(err);
            },
            function (progressPercent) { // -1 when progress monitoring not supported
                Human.processes.updateProcess({ processId: "modules.activate", progress: progressPercent });
            },
            streamObjectsArgs); // This could get very long (see HTTP 414), so we may need to POST these
    };

    net.getOffset = function (systemName, objectName, keyName) {
        // jshint unused:false
        return 0;
    };

    net.getAnatomyManifest = function (libId, ok, error) {
        getJSON(filePath('anatomy/' + libId + '/manifest'), ok, error);
    };

    net.getAnatomyToMedline = function (libId, ok, error) {
        // getJSON(filePath('anatomy/' + libId + '/' + "anatomy_to_medline"), ok, error);
        // load from file system
        var url = filePath('anatomy/' + libId + '/' + "anatomy_to_medline");
        $.ajax({ dataType: "json", url: url, success: ok, error: function () {
            if (error) {
                error();
            }
        } });
    };

    net.getAnimationManifest = function (libId, ok, error) {
        getJSON(filePath('animations/' + libId + '/manifest'), ok, error);
    };

    net.getGeometryManifest = function (libId, ok, error) {
        getJSON(filePath('geometry/' + libId + '/manifest'), ok, error);
    };

    net.getChapterSetManifest = function (libId, ok, error) {
        getJSON(filePath('chapters/' + libId + '/manifest'), ok, error);
    };

    /**
     * Gets path to directory containing the images dir for the textures within the given material library
     */
    net.getMaterialDir = function (libId) {
        return modelDir + "materials/" + libId + "/images/"; // In file mode, images are kept within a dir in each material lib
    };

    net.getMaterialLibrary = function (libId, ok, error) {
        getJSON(filePath('materials/' + libId + '/outline'), ok, error);
    };

    /**
     * Gets path to directory containing the files dir for the clips within the given audio library
     */
    net.getAudioDir = function (libId) {
        return modelDir + "audio/" + libId + "/clips/"; // In file mode, clips are kept within a dir in each audio lib
    };

    net.getAudioLibrary = function (libId, ok, error) {
        getJSON(filePath('audio/' + libId + '/manifest'), ok, error);
    };

    net.getVideosLibrary = function (libId, ok, error) {
        getJSON(filePath('videos/' + libId + '/manifest'), ok, error);
    };

    /**
     * Gets path to directory containing the images dir for the textures within the given reflections library
     */
    net.getReflectionsDir = function (libId) {
        return modelDir + "reflections/" + libId + "/images/"; // In file mode, images are kept within a dir in each material lib
    };

    net.getReflectionsLibrary = function (libId, ok, error) {
        getJSON(filePath('reflections/' + libId + '/outline'), ok, error);
    };

    net.getLightsLibrary = function (libId, ok, error) {
        getJSON(filePath('lights/' + libId + '/outline'), ok, error);
    };

    net.getTransformsLibrary = function (libId, ok, error) {
        getJSON(filePath('transforms/' + libId + '/outline'), ok, error);
    };

    // get the index for a system
    //NOTE: Handle errors with the |error| callback.
    //See: http://api.jquery.com/jQuery.ajax/
    net.getAnatomyIndex = function (libId, systemName, ok, error) {
        getJSON(filePath("anatomy/" + libId + '/b/' + systemName + '/idx.json'), ok, error);
    };

    net.getAnatomyPositions = function (libId, systemName, ok, error) {
        getFloat32Array(filePath("anatomy/" + libId + '/b/' + systemName + '/positions.bds'), ok, error);
    };

    net.getAnatomyNormals = function (libId, systemName, ok, error) {
        getFloat32Array(filePath("anatomy/" + libId + '/b/' + systemName + '/normals.bds'), ok, error);
    };

    net.getAnatomyUVs = function (libId, systemName, ok, error) {
        getFloat32Array(filePath("anatomy/" + libId + '/b/' + systemName + '/uv.bds'), ok, error);
    };

    net.getAnatomyIndices = function (libId, systemName, ok, error) {
        getInt32Array(filePath("anatomy/" + libId + '/b/' + systemName + '/indices.bds'), ok, error);
    };

    net.getStateIndex = function (ok, error) {
        getJSON(filePath('index'), ok, error);
    };

    net.getGeometryIndices = function (libId, ok, error) {
        getInt32Array(filePath("geometry/" + libId + '/indices.bds'), ok, error);
    };

    net.getGeometryUVs = function (libId, ok, error) {
        getFloat32Array(filePath("geometry/" + libId + '/uv.bds'), ok, error);
    };

    net.getGeometryPositions = function (libId, ok, error) {
        getFloat32Array(filePath("geometry/" + libId + '/positions.bds'), ok, error);
    };

    net.getGeometryNormals = function (libId, ok, error) {
        getFloat32Array(filePath("geometry/" + libId + '/normals.bds'), ok, error);
    };

    net.getGeometryMesh = function (libId, meshName, ok, error) {
        getJSON(filePath('geometry/' + libId + '/' + meshName + '/geo'), ok, error);
    };

    net.getMorphIndices = function (libId, ok, error) {
        getInt32Array(filePath("animations/" + libId + '/indices.bds'), ok, error);
    };

    net.getMorphUVs = function (libId, ok, error) {
        getFloat32Array(filePath("animations/" + libId + '/uv.bds'), ok, error);
    };

    net.getMorphPositions = function (libId, ok, error) {
        getFloat32Array(filePath("animations/" + libId + '/positions.bds'), ok, error);
    };

    net.getMorphNormals = function (libId, ok, error) {
        getFloat32Array(filePath("animations/" + libId + '/normals.bds'), ok, error);
    };

    // progress callback returns -1 when progress unsupported
    function loadArrayBuffer(url, ok, error, progress, streamObjectsArgs) {

        console.log("Human.net#loadArrayBuffer", "Loading from: " + url);

        var contentLength = null;

        $.ajax({
            url: url,
            dataType: 'json',
            type: 'HEAD',
            success: function (data, status, jqXHR) {
                contentLength = jqXHR.getResponseHeader("Content-Length");
            }
        });

        var xhr = new XMLHttpRequest();

        var progressSupported;

        xhr.addEventListener("progress", function (e) {
            if (e.lengthComputable) {
                if (progressSupported === undefined) {
                    progressSupported = true;
                    //  console.log("Human.net", "XHR load progress supported == YES");
                }
                if (progress) {
                    progress(100.0 * (e.loaded / e.total));
                }
            } else {
                // Unable to compute progress information since the total size is unknown
                if (progressSupported === undefined) {
                    progressSupported = false;
                    console.log("Human.net", "XHR load progress supported == NO; is server compressing this data?");
                }
                if (progress) {
                    if (contentLength !== null && contentLength !== undefined) {
                        progress(100 * e.position / contentLength);
                    } else { // HEAD request got lost
                        progress(-1); // not supported
                    }
                }
            }
        }, false);

        var done = false; // Prevents double callback
        xhr.onreadystatechange = function () {
            var buffer = null;
            if (xhr.readyState === 4) {
                // xhr.status == 0 when the --disable-web-security Chr flag is set
                // and you are running Human directly off the filesystem instead of a web server
                if (!xhr.status || ( xhr.status === 200 )) {
                    // webkit
                    if (xhr.response) {
                        buffer = xhr.response;
                    } else {
                        // gecko
                        if (xhr.mozResponseArrayBuffer) {
                            buffer = xhr.mozResponseArrayBuffer;
                        }
                    }
                    if (buffer) {
                        if (!done) {
                            done = true;
                            ok(buffer);
                        }
                    } else {
                        error("Failed to load - status: " + xhr.status);
                    }
                } else {
                    error("Failed to load - status: " + xhr.status);
                }
            }
        };
        if (streamObjectsArgs) {
            xhr.open("POST", url, true);
            xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
            xhr.responseType = "arraybuffer";
            xhr.send(streamObjectsArgs);
        } else {
            xhr.open("GET", url, true);
            xhr.responseType = "arraybuffer";
            xhr.send(null);
        }
    }


    function filePath(subpath) {
        return streamMode ? (prefix + subpath) : (prefix + subpath + "?v=" + Human.VERSION);
    }

    function getJSON(url, ok, error) {
        if (streamMode) {
            // Load from stream
            getStreamEntry(url,
                function (entry) {
                    ok(atoj(streamBaseIndex + entry[0], entry[1]));
                },
                error);
        } else {
            // Load from file system
            $.ajax({ dataType: "json", url: url, success: ok })
                .fail(function (jqXHR, textStatus) {
                    error("Request failed: " + textStatus);
                });
        }
    }

    function getStreamEntry(key, ok, error) {
        var entry = streamIndex[key];
        if (entry) {
            ok(entry);
        } else {
            error("Could not find data in stream at key '" + key + "'");
        }
    }

    function atoj(index, length) {
        var view = new Uint8Array(streamBuffer, index, length);
        // the following dies if view is longer than 65536
        // TODO: chunking?
        var str = new TextDecoder("utf-8").decode(view);
        return JSON.parse(str);
    }

    function getInt32Array(url, ok, error) {
        if (streamMode) {
            // Load from stream
            getStreamEntry(url,
                function (entry) {
                    try {
                        var start = streamBaseIndex + entry[0];
                        var end = start + entry[1];
                        // Not allowed to create array with buffer and offset that's not a
                        // multiple of the element size, so we'll create from a slice
                        ok(new Int32Array(streamBuffer.slice(start, end)));
                    } catch (e) {
                        error(e);
                    }
                },
                error);
        } else {
            // Load from file system
            loadArrayBuffer(url,
                function (buffer) {
                    ok(new Int32Array(buffer));
                },
                error);
        }
    }

    function getFloat32Array(url, ok, error) {
        if (streamMode) {
            // Load from stream
            getStreamEntry(url,
                function (entry) {
                    try {
                        var start = streamBaseIndex + entry[0];
                        var end = start + entry[1];
                        // Not allowed to create array with buffer and offset that's not a
                        // multiple of the element size, so we'll create from a slice
                        ok(new Float32Array(streamBuffer.slice(start, end))); // Handles
                    } catch (e) {
                        error(e);
                    }
                },
                error);
        } else {
            // Load from file system
            loadArrayBuffer(url,
                function (buffer) {
                    ok(new Float32Array(buffer));
                },
                error);
        }
    }

})();;/**
 * Human.renderer
 *
 * @namespace Provides access to the SceneJS WebGL engine
 */
(function () {

    "use strict";

    var HumanRenderer = Human.renderer = {};

    HumanRenderer.NULL_OBJECT_ID = "null-object";   // ID of invisible object at origin, used for anchoring things like labels to

    var scene;

    HumanRenderer.init = function (ok) {

        // Create scene graph
        var json = {
            type: "scene",
            id: Human.SCENE_ROOT_ID,
            canvasId: Human.CANVAS_ID,

            // transparent canvas
            transparent: true,

            contextAttr: {

                // Default: false. If false, once the drawing buffer is presented as described in theDrawing Buffer
                // section, the contents of the drawing buffer are cleared to their default values. All elements of the
                // drawing buffer (color, depth and stencil) are cleared. If the value is true the buffers will not be
                // cleared and will preserve their values until cleared or overwritten by the author.
                // On some hardware setting the preserveDrawingBuffer flag to true can have significant performance implications.
                // http://code.google.com/p/chromium/issues/detail?id=82086
                preserveDrawingBuffer: false,
                antialias: true
            },

            nodes: [
                {   type: "library", id: "assetLibraryRoot" },

                // Camera for projection
                {
                    type: "camera",
                    id: Human.CAMERA_ID,
                    optics: { type: "perspective",
                        fovy: 60, near: 0.01, far: 400.0
                    },

                    // Screen-space pan
                    pan: {x: 0, y: 0, z: 0},

                    nodes: [

                        // Illuminated annotation labels in their own frustum space
                        // Don't rely on SceneJS default lookat for label wires
                        {
                            type: "lookAt", eye: { x: 0.0, y: 0.0, z: 0.05 }, look: { x: 0.0, y: 0, z: 0 }, up: { y: 1.0 },
                            nodes: [
                                {
                                    type: "lights",
                                    lights: [
                                        {
                                            mode: "dir",
                                            color: { r: 1.0, g: 1.0, b: 1.0 },
                                            dir: { x: 0.0, y: 0.0, z: -1.0 },
                                            diffuse: true, specular: true, space: "view"
                                        }
                                    ],
                                    nodes: [
                                        { type: "node", id: "annotation-labels" }
                                    ]
                                }
                            ]
                        },

                        // Main view transform
                        {
                            // Camera attributes will be overwritten by Human.view.camera
                            type: "lookAt",
                            id: Human.LOOKAT_ID,
                            eye: { x: 0.0, y: 0.0, z: 55 }, look: { x: 0.0, y: 0, z: 0 }, up: { y: 1.0 },
                            nodes: [

                                // Lights node will be inserted here, above "lights.subtree"
                                // See ./view/lights/lights.js
                                {
                                    id: "lights",
                                    nodes: [

                                        // Subnodes of lights
                                        {
                                            id: "lights.subtree",
                                            nodes: [

                                                // Postprocessing nodes will be inserted here, above "effects.subtree"
                                                // See ./view/effects/effects.js
                                                {
                                                    id: "effect",
                                                    nodes: [

                                                        // Subnodes of effects
                                                        {
                                                            id: "effect.subtree",
                                                            nodes: [

                                                                // Clip indicators
                                                                {
                                                                    type: "layer", priority: 10000,
                                                                    nodes: [
                                                                        {
                                                                            type: "flags",
                                                                            id: Human.CLIP_INDICATORS_ATTACH_ID,
                                                                            flags: { picking: false }
                                                                        }
                                                                    ]
                                                                },

                                                                // Default material around content
                                                                {
                                                                    type: "material", id: Human.MATERIAL_ROOT_ID,
                                                                    emit: 0, baseColor: { r: 0.9, g: 0.9, b: 0.9 },
                                                                    specularColor: { r: 0.9, g: 0.9, b: 0.9 }, specular: 0.9,
                                                                    shine: 100.0,
                                                                    nodes: [

                                                                        // Null objects - hack to give global labels something to bind to.
                                                                        // Note we avoid scaling transforms around the null object, because
                                                                        // those will distort the offset that is fed into the "rendered"
                                                                        // handler.
                                                                        // We have multiple null objects - one for labels, another for
                                                                        // annotations. For some reason those clobber each other when on
                                                                        // same null object.

                                                                        // Null object #1
                                                                        {
                                                                            type: "node", id: HumanRenderer.NULL_OBJECT_ID,
                                                                            nodes: [
                                                                                // Infintesimally small dummy triangle.
                                                                                //
                                                                                // Was getting SceneJS problems with primitives like "points"
                                                                                // and "lines" where the lighting/shading states of other
                                                                                // "triangles" geometries subsequent in the scene
                                                                                // were not applied, ie. coming up black for some reason.
                                                                                {
                                                                                    type: "geometry",
                                                                                    positions: [ 0, 0, 0, 0.1, 0.1, 0.1, 0.2, 0.2, 0.2 ],
                                                                                    indices: [0, 1, 2],
                                                                                    uv: [0, 0, 1, 0, 1, 1],
                                                                                    normals: [0, 1, 0, 0, 1, 0, 0, 1, 0], // Above error happens when normals missing
                                                                                    primitive: "triangles"

                                                                                }
                                                                            ]
                                                                        },

                                                                        // Default flags at content root
                                                                        // Content attached here
                                                                        {
                                                                            type: "flags",
                                                                            id: Human.CONTENT_ROOT_ID,
                                                                            flags: {
                                                                                picking: true,
                                                                                enabled: true,
                                                                                specular: true,
                                                                                backfaceLighting: true,
                                                                                backfaceTexturing: true,
                                                                                backfaces: true,
                                                                                reflection: false
                                                                            }
                                                                        }
                                                                    ]
                                                                },

                                                                // Object Boundary - shown when flying. rotating. panning etc
                                                                {
                                                                    type: "flags",
                                                                    id: "object-boundary-flags",
                                                                    flags: { enabled: false, transparent: true, clipping: false },
                                                                    nodes: [
                                                                        {
                                                                            type: "material",
                                                                            baseColor: { r: 0.0, g: 1.0, b: 0.0 },
                                                                            specularColor: { r: 0.0, g: 1.0, b: 0.0 },
                                                                            emit: 1.0, alpha: 0.4,
                                                                            nodes: [
                                                                                {
                                                                                    type: "geometry",
                                                                                    id: "object-boundary-geo",
                                                                                    positions: [
                                                                                        1.0, 1.0, 1.0, 1.0, -1.0, 1.0,
                                                                                        -1.0, -1.0, 1.0, -1.0, 1.0, 1.0,
                                                                                        1.0, 1.0, -1.0, 1.0, -1.0, -1.0,
                                                                                        -1.0, -1.0, -1.0, -1.0, 1.0, -1.0
                                                                                    ],
                                                                                    primitive: "lines",
                                                                                    indices: [
                                                                                        0, 1, 1, 2, 2, 3, 3, 0, 4,
                                                                                        5, 5, 6, 6, 7, 7, 4, 0, 4,
                                                                                        1, 5, 2, 6, 3, 7
                                                                                    ]
                                                                                }
                                                                            ]
                                                                        }
                                                                    ]
                                                                }
                                                            ]
                                                        }
                                                    ]
                                                }
                                            ]
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                }
            ]
        };

        // Lost WebGL context testing
        // keep this here for quick check on how well that's handled

        var simulateWebGLContextLost = Human.request.getSearchParam("testContextLost");

        scene = SceneJS.createScene(json, { simulateWebGLContextLost: !!simulateWebGLContextLost });

        if (simulateWebGLContextLost) {

            var interval =  parseInt(simulateWebGLContextLost);

            // Simulate WebGL context loss on interval
            window.setInterval(
                function () {
                    //  alert("losing webgl context");
                    scene.loseWebGLContext();
                }, interval *1000);
        }

        var timeStarted = (new Date()).getTime();
        var timeLast = timeStarted;
        var tick = 0;

        scene.on("tick",
            function () {

                var timeNow = (new Date()).getTime();

                Human.events.fire("tick", {
                    timeStarted: timeStarted,
                    timeLast: timeLast,
                    timeNow: timeNow,
                    tick: tick
                });

                timeLast = timeNow;
                tick++;
            });

        scene.on("sleep", // Fired after SceneJS finds 3D view needs no refresh
            function () {
                Human.events.fire("Scene.Sleep");
            });

        if (ok) {
            ok();
        }
    };

    /**
     * Pauses the renderer.
     *
     * <p>This actually pushes a 'pause' directive onto a stack. Only once the same number of pops are done
     * with {@link #popPause} will the renderer unpause again.</p>
     *
     * <p>You would normally do this when you want to do batches of content creation, to prevent the
     * renderer from slowing things down as it works to keeps the 3D view in synch. Then when you've
     * done all your creation, you'd unpause the renderer again.</p>
     */
    HumanRenderer.pushPause = function () {
        HumanRenderer._pauses = (!HumanRenderer._pauses) ? 1 : HumanRenderer._pauses + 1;
        if (HumanRenderer._pauses === 1) {
            scene.pause(true);
        }
    };

    /**
     * Un-pauses the renderer.
     *
     * <p>As described in {@link #pushPause}, this pops a pause directive that was made with that method. Only once the same
     * number of pops are done with this method will the renderer unpause again.</p>
     */
    HumanRenderer.popPause = function () {
        if (!HumanRenderer._pauses) {
            return;
        }
        if (--HumanRenderer._pauses === 0) {
            scene.pause(false);
            scene.renderFrame();   // Forces garbage collection
        }
    };

    /**
     * Fires callback as soon as current task count is zero
     */
    HumanRenderer.onTasksComplete = function (ok) {
        if (HumanRenderer._pauses !== undefined && HumanRenderer._pauses !== null && HumanRenderer._pauses > 0) {
            Human.log.error("Human.renderer.onTaskComplete", "Renderer deadlock: Human.renderer.pushPause has " +
                "paused renderer. Renderer needs to be unpaused in order to complete pending tasks.");
        }
        var numTasks = Human.renderer.getScene().getStatus().numTasks;
        if (!numTasks || numTasks === 0) {
            ok();
            return;
        }
        if (HumanRenderer.__checkLoaded) {
            throw "Human.renderer.onTasksComplete: already blocking";
        }
        HumanRenderer.__checkLoaded = window.setInterval(
            function () {
                var numTasks = Human.renderer.getScene().getStatus().numTasks;
                if (!numTasks || numTasks === 0) {
                    window.clearInterval(HumanRenderer.__checkLoaded);
                    HumanRenderer.__checkLoaded = null;
                    ok();
                }
            }, 200);
    };

    /** Forces renderer to render a frame
     */
    HumanRenderer.forceRenderFrame = function () {
        scene.renderFrame({ force: true });
    };

    var rayPickEnabled = false;

    /**
     * Enable or disable ray-picking mode
     * You'd only want ray picking enabled when you're actually going to do the sort of
     * picking that needs 3D intersection results, like attaching annotations. Otherwise
     * you'd want ray-picking off, for things like regular object selection.
     * @param enable
     */
    HumanRenderer.enableRayPick = function (enable) {
        rayPickEnabled = enable;
    };

    HumanRenderer.pick = function (canvasX, canvasY, rayPick) {
        if (!scene) {
            Human.log.error("Human.renderer.pick", "Engine not started, ignoring pick");
            return null;
        }
        return scene.pick(canvasX, canvasY, { rayPick: rayPick });
    };

    HumanRenderer.getScene = function () {
        return SceneJS.scene(Human.SCENE_ROOT_ID);
    };

    HumanRenderer.getContentRootNode = function () {
        return HumanRenderer.getNode(Human.CONTENT_ROOT_ID);
    };

    HumanRenderer.getNode = function (nodeId) {
        return scene.findNode(nodeId);
    };

    HumanRenderer.getLookAt = function () {
        return HumanRenderer.getNode(Human.LOOKAT_ID);
    };

    HumanRenderer.nodeExists = function (nodeId) {
        var node = scene.findNode(nodeId);
        return (node !== null && node !== undefined);
    };

    /**
     * Returns the 4x4 View transform matrix.
     * <p>Transform World-space coordinates by this matrix to obtain View-space coordinates.</p>
     */
    HumanRenderer.getViewMat = function () {
        return HumanRenderer.getNode(Human.LOOKAT_ID).getMatrix();
    };

    /**
     * Returns the 4x4 Projection transform matrix.
     * <p>Transform View-space coordinates by this matrix to obtain Canvas-space coordinates.</p>
     */
    HumanRenderer.getProjMat = function () {
        return HumanRenderer.getNode(Human.CAMERA_ID).getMatrix();
    };

})();;/**
 * Human.renderer.bg
 *
 * @namespace Manages the background color and configures Human.renderer.shader accordingly
 */
(function () {
    "use strict";

    var bgDefault = Human.request.getSearchParam('bgstd') || Human.cookies.getCookie('background') || 'standard';
    var bgRadial = true;
    var bgDirty = true;

    var HumanRendererBG = Human.renderer.bg = {};

    HumanRendererBG.bgColor = bgDefault;

    HumanRendererBG.bgColors = {
        black: [
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0
        ],
        white: [
            1, 1, 1,
            1, 1, 1,
            1, 1, 1,
            1, 1, 1
        ],
        standard: [
            0.13, 0.15, 0.17, // top left (R,G,B)
            0.13, 0.15, 0.17, // top right
            0.54, 0.58, 0.64, // bottom right
            0.54, 0.58, 0.64  // bottom left
        ],
        quiz: [
            1, 1, 1,
            1, 1, 1,
            1, 1, 1,
            1, 1, 1
        ]
    };

    HumanRendererBG.getBGColor = function () {
        return HumanRendererBG.bgColor;
    };

    Human.properties.subscribe({
        propId: "backgrounds",
        subId: "background",
        value: HumanRendererBG.bgColors,
        callback: function (value) {
            HumanRendererBG.bgColors = value;
            bgDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "background.radial",
        callback: function (value) {
            value = !!value;
            if (bgRadial !== value) {
                bgRadial = value;
                bgDirty = true;
            }
        }
    });

    Human.events.on(
        "tick",
        function () {
            if (bgDirty) {
                HumanRendererBG.setBGColor(HumanRendererBG.bgColor, bgRadial);
                bgDirty = false;
            }
        });

    // Bind activation of backgrounds for various modes. As we get notification from Human
    // that each mode (Highlight, X-Ray, Quiz) is activated, we select an appropriate background
    // from among those we just defined above.

    Human.events.on("highlight.toggled", // Highlight
        function (event) {
            if (event.enabled === true) {
                var bgPreference = Human.cookies.getCookie("background") || 'standard';
                Human.properties.resubscribe("background", "background." + bgPreference);
            }
        });

    /**
     *
     */
    Human.renderer.setBGColor = // HACK for UI backward compatibility
        HumanRendererBG.setBGColor = function(color, radial) {
        radial = radial !== false;

        var top, bottom;

        //lengths between 3-16
        var csv = /^([\d\.]+,){2,15}[\d\.]+$/.test(color);

        var is256Scale = function (channels) {
            for (var i = 0; i < channels.length; i++) {
                if (parseFloat(channels[i]) > 1) {
                    return true;
                }
            }

            return false;
        };

        if (!color) {
            color = bgDefault;
        }

        if (typeof color === 'string') {

            if (csv) {

                var channels = color.split(",");
                var length = channels.length;
                var multiply = !is256Scale(channels);

                switch (length) {
                    case 16: //backwards compatibility
                        top = cssRGB(channels.slice(0, 3));
                        bottom = cssRGB(channels.slice(12, 15));
                        break;
                    case 12:
                        top = cssRGB(channels.slice(0, 3));
                        bottom = cssRGB(channels.slice(9, 12));
                        break;
                    case 6:
                        top = cssRGB(channels.slice(0, 3), multiply);
                        bottom = cssRGB(channels.slice(3, 6), multiply);
                        break;
                    case 3:
                        top = bottom = cssRGB(channels, false); //RGB color
                        break;
                    default:
                        return;
                }

                color = 'custom'; //for subsequent getting

            } else if (color === 'standard') {

                top = cssRGB(HumanRendererBG.bgColors[color].slice(0, 3));
                bottom = cssRGB(HumanRendererBG.bgColors[color].slice(9, 12));

            } else {

                top = bottom = color; //css color name
            }

        } else {

            return;
        }

        HumanRendererBG.bgColor = color;

        //this is necessary for annotations / elements that respond to bg color
        setBGClass(/rgb\([\d,]+\)/.test(HumanRendererBG.bgColor) ? 'custom' : HumanRendererBG.bgColor);

        //only one way gradient for now
        setBGCSS(top, bottom, radial);

        Human.renderer.shader.setBGColor(HumanRendererBG.bgColor);
    };

    function cssRGB(arr, multiply) {
        var values = [];
        multiply = typeof multiply === 'boolean' ? multiply : true;

        for (var i = 0; i < arr.length; i++) {
            values.push(Math.round(arr[i] * (multiply ? 255 : 1)));
        }

        return "rgb(" + values.join(',') + ")";
    }

    function setBGCSS(top, bottom, radial) {
        var $container = $("#container");

        var prefixes = ['-webkit-', '-moz-', '-ms-', '-o-', ''];
        var _rule;

        if (radial) {
            //Safari
            $container.css("background-image", "-gradient(radial, center center, 0px, center center, 100%, color-stop(0%," + bottom + "), color-stop(100%," + top + "))");
            _rule = "radial-gradient(ellipse at center, "  + bottom + " 0%, " + top + " 100%)";
        } else {
            //Safari
            $container.css("background-image", "-webkit-gradient(linear, left top, left bottom, color-stop(0, " + top + "), color-stop(1, " + bottom + ")");
            _rule = "linear-gradient(top, " + top + " 0%, " + bottom + " 100%)";
        }

        for (var i = 0; i < prefixes.length; i++) {
            var rule = prefixes[i] + _rule;
            $container.css("background-image", rule);
        }
    }

    function setBGClass(color) {
        var className = document.body.className;
        //remove old
        document.body.className = className = className.replace(/bg-([^\s]*)/, '');
        //add new
        var newClass = 'bg-' + color;
        document.body.className = (className + ' ' + newClass).trim();
    }


})();;/**
 * Human.renderer.shader
 *
 * This module inserts a custom shader node into the SceneJS scene graph, tailored for XRay and/or
 * highlighting functionality, depending on which of those are currently enabled via engine configs.
 *
 * This module listens to two boolean engine configs: "xray.enabled" and "highlight.enabled".
 *
 * Whenever either of these configs are set true, this module will dynamically insert a shader node
 * to support XRay and/or highlighting, depending on which of the two configs are true.
 *
 * When both of these configs are false, this module will remove the shader node from
 * the scene graph altogether.
 *
 * This module also ensures that certain colors used within the XRay effect are appropriate for
 * for the current background color, which is indicated to this module via Human.renderer.setBGColor().
 *
 * @namespace Manages the XRay and Highlight shader
 */
(function () {
    "use strict";

    // Exports

    Human.renderer.shader = {
        setBGColor: setBGColor
    };

    // Default desaturated rendering colors for transparent objects in X-Ray mode for each background color
    // May be overridden in properties init script

    var colorsForBackgrounds = {
        "white": [0.0, 0.0, 0.1],
        "black": [0.8, 0.8, 0.9],
        "standard": [0.8, 0.8, 0.9],
        "default": [0.8, 0.8, 0.9]   // When Bg color name is none of the above
    };

    // Default glassFactor properties for transparent objects in X-Ray mode for each background color
    // May be overridden in properties init script

    var glassFactorsForBackgrounds = {
        "white": 1.0,
        "black": 1.0,
        "standard": 1.0,
        "default": 1.0
    };

    // Default murkiness properties for transparent objects in X-Ray mode for each background color
    // May be overridden in properties init script

    var murkinessForBackgrounds = {
        "white": 0.8,
        "black": 0.8,
        "standard": 0.8,
        "default": 0.8
    };

    var enableXRay = true;
    var enableHighlight = true;

    var shaderDirty = true;

    var params = {};
    var paramsDirty = false;

    var shaderNode = null;

    var bgColor = Human.request.getSearchParam('bgstd') || Human.cookies.getCookie('background') || 'standard';

    var bgDirty = true;


    Human.properties.subscribe({
        subId: "colorsForBackgrounds",
        propId: "xray.colorsForBackgrounds",
        value: colorsForBackgrounds,
        callback: function (value) {
            colorsForBackgrounds = value;
            bgDirty = true;
        }
    });

    Human.properties.subscribe({
        subId: "glassFactorsForBackgrounds",
        propId: "xray.glassFactorsForBackgrounds",
        value: glassFactorsForBackgrounds,
        callback: function (value) {
            glassFactorsForBackgrounds = value;
            bgDirty = true;
        }
    });

    Human.properties.subscribe({
        subId: "murkinessForBackgrounds",
        propId: "xray.murkinessForBackgrounds",
        value: murkinessForBackgrounds,
        callback: function (value) {
            murkinessForBackgrounds = value;
            bgDirty = true;
        }
    });

    Human.properties.subscribe({
        subId: "glassFactor",
        propId: "xray.glassFactor",
        value: 0.4,
        callback: function (value) {
            setParams({
                glassFactor: value
            });
        }
    });

    Human.properties.subscribe({
        subId: "murkiness",
        propId: "xray.murkiness",
        value: 0.8,
        callback: function (value) {
            setParams({
                murkiness: value
            });
        }
    });

    Human.properties.subscribe({
        propId: "xray.enabled",
        value: enableXRay,
        callback: function (value) {
            enableXRay = value;
            shaderDirty = true;
        }
    });

    Human.properties.subscribe({
        propId: "highlight.enabled",
        value: enableHighlight,
        callback: function (value) {
            enableHighlight = value;
            shaderDirty = true;
        }
    });

    Human.events.on(
        "tick",
        function () {

            if (shaderDirty) {

                if (enableXRay || enableHighlight) {
                    createShaderNode();

                    paramsDirty = true;

                } else {
                    destroyShaderNode();
                }

                shaderDirty = false;
            }

            if (paramsDirty) {

                if (shaderNode) {

                    shaderNode.setParams(params);
                    paramsDirty = false;
                }
            }

            if (bgDirty) {

                updateShader();
                bgDirty = false;
            }
        });


    function setBGColor(color) {
        bgColor = color;
        bgDirty = true;
    }

    function setParams(p) {
        if (shaderNode) {
            shaderNode.setParams(p);
        } else {
            paramsDirty = true;
        }
        Human._apply(p, params);
    }

    function createShaderNode() {

        destroyShaderNode();


        // Compose a shader that performs XRay and/or highlighting, depending on what
        // functionality is enabled

        var code = []; // GLSL fragment shader code

        var hooks = {}; // Function hooks

        if (enableXRay) {
            code.push("uniform bool  transparent;");
            code.push("uniform bool  xray;");
            code.push("uniform float glassFactor;");
            code.push("uniform float murkiness;");
            code.push("uniform float xrayGlassFactor;");
            code.push("uniform float xrayMurkiness;");
            code.push("uniform float opacity;");
        }

        if (enableXRay || enableHighlight) {
            code.push("uniform vec3  xrayBGColor;");
        }

        if (enableXRay || enableHighlight) {
            code.push("uniform bool highlight;");
            code.push("uniform bool desaturate;");
        }

        if (enableXRay) {
            code.push("vec3 _std_viewNormal = vec3(0.0, 0.0,  -1.0);");
            code.push("vec3 _std_viewEyeVec = vec3(0.0, 0.0, -1.0);");

            // Intercept the View-space normal vector
            code.push("void _std_ViewNormalFunc(vec3 vec) {");
            code.push("   _std_viewNormal = vec;");
            code.push("}");

            // Intercept material alpha, adjust according to angle between the vectors
            code.push("float _std_MaterialAlphaFunc(float alpha) {");

            // If in X-Ray, mode compute transparency from 'glassFactor' and 'murkiness'
            code.push("   if (xray) {");
            code.push("       alpha = (xrayGlassFactor  * (xrayMurkiness - abs(dot(_std_viewNormal, _std_viewEyeVec))));");
            code.push("   }");

            // If in transparency mode, set transparency to lowest among 'opacity' and 'alpha'
            code.push("   else if (transparent) {");
            code.push("       if (opacity < alpha) {");
            code.push("           alpha = opacity;");
            code.push("       }");
            code.push("       float gf = (glassFactor  * (murkiness - abs(dot(_std_viewNormal, _std_viewEyeVec))));");
            code.push("       if (gf > alpha) {");
            code.push("           alpha = gf;");
            code.push("       }");
            code.push("   }");

            code.push("   return alpha;");
            code.push("}");

            // Function hooks

            hooks.viewNormal = "_std_ViewNormalFunc";
            hooks.materialAlpha = "_std_MaterialAlphaFunc";
        }

        if (enableXRay || enableHighlight) {

            code.push("vec4 _std_PixelColorFunc(vec4 color) {");
            code.push("   if (highlight) {");
            if (enableHighlight) {
                code.push("       float intensity = 0.3 * color.r + 0.59 * color.g + 0.11 * color.b;");
                code.push("       color = vec4((intensity * -0.1) + color.rgb * (1.0 + 0.1), color.a);");
                code.push("       color.r = clamp(color.r * 1.5, 0.3, 1.0);");
                code.push("       color.g = clamp(color.g * 1.5, 0.3, 1.0);");
                code.push("       color.b = color.b * 0.5;");
            }
            code.push("   } else if (desaturate) {");
            if (enableXRay) {
                code.push("       color.rgb = xrayBGColor;");
            }
            code.push("   } ");
            code.push("   return color;");
            code.push("}");

            // Function hooks

            hooks.pixelColor = "_std_PixelColorFunc";
        }


        var json = {
            "type": "shader",
            "shaders": [
                {
                    "stage": "fragment",
                    "code": code,
                    "hooks": hooks
                }
            ],

            // Params that don't correspond to anything in the shader
            // are ignored, so won't bother to specify these conditionally

            "params": {
                "transparent": false,
                "xray": false,
                "glassFactor": 1.0, // Full glass effect
                "murkiness": 0.8,
                "xrayGlassFactor": 1.0, // Full glass effect
                "xrayMurkiness": 0.8,
                "highlight": false,
                "opacity": 1.0,
                "desaturate": false,
                "xrayBGColor": [0.0, 0.0, 0.1]
            }
        };

        // Insert shader node above scene graph content root

        var contentRootNode = Human.renderer.getContentRootNode();

        var parent = contentRootNode.parent;

        var children = parent.disconnectNodes();

        shaderNode = parent.addNode(json);

        shaderNode.addNodes(children);
    }

    //
    function destroyShaderNode() {

        if (!shaderNode) {
            return;
        }

        // Extract shader node from scene graph,
        // moving its children up to its parent

        shaderNode.splice();

        shaderNode.destroy();

        shaderNode = null;
    }

    function updateShader() {

        var color = colorsForBackgrounds[bgColor] || colorsForBackgrounds["default"] || [0.8, 0.8, 1.0];

        var glassFactor = glassFactorsForBackgrounds[bgColor];

        if (glassFactor === undefined || glassFactor === null) {
            glassFactor = glassFactorsForBackgrounds["default"];
        }

        if (glassFactor === undefined || glassFactor === null) {
            glassFactor = 1.0;
        }

        var murkiness = murkinessForBackgrounds[bgColor];

        if (murkiness === undefined || murkiness === null) {
            murkiness = murkinessForBackgrounds["default"];
        }

        if (murkiness === undefined || murkiness === null) {
            murkiness = 0.8;
        }

        setParams({
            xrayBGColor: color,
            xrayGlassFactor: glassFactor,
            xrayMurkiness: murkiness
        });
    }

})();;/**
 * Human.renderer.canvas
 *
 * @namespace Manages the WebGL canvas
 */
(function () {
    "use strict";

    var canvas = $("#" + Human.CANVAS_ID);

    Human.renderer.canvas = {
        canvas: canvas,
        getCanvas: function() {
            return canvas;
        }
    };

    // HACK for UI compatibility
    Human.renderer.resize = resize;

    $(window).resize(resize);

    resize();

    function resize() {

        var canvasBody = canvas.parent();

        var canvasWidth = canvasBody.width();
        var canvasHeight = canvasBody.height();

        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        canvas.attr({ width: canvasWidth, height: canvasHeight });

        var annotationCanvas = $("#annotationCanvas");

        annotationCanvas.width = canvasWidth;
        annotationCanvas.height = canvasHeight;
        annotationCanvas.attr({ width: canvasWidth, height: canvasHeight });

        Human.events.fire("canvas.resized", {
            canvasWidth: canvas.width,
            canvasHeight: canvas.height
        });
    }

})();;(function () {
	"use strict";

	Human.rpc.define("renderer.getBGColor", function () {
	  this.setResult(Human.renderer.bg.getBGColor());
	});

	Human.rpc.define("renderer.setBGColor", function (params) {
	  Human.renderer.bg.setBGColor(params.color);
	});
})();
;/** @namespace Holds functionality relating to the way the {@link Human.scene} is viewed.
 *
 */
(function() {
  "use strict";

  var view = Human.view = {};

  var modes = ["Highlight", "Xray", "Isolate"];
  
  view.currentMode = modes[0];
  
  view.setModeEnabled = function (mode) {
      mode = mode.toLowerCase();
      
      if(mode === 'isolate') {
          if (!Human.scene.anySelected()) {
              alert("Please select an object before Isolating.");
              return;
          }
      } 
    
      var _modes = modes.map(function (mode) {
          return mode.toLowerCase();
      });
      
      var enabledIndex = _modes.indexOf(mode);
      
      if(enabledIndex >= 0) {
          _modes.forEach(function (mode, i) {
              var enable = (enabledIndex === i);
              Human.view[mode].setEnabled(enable);
          });
      }
  };
})();;(function () {
    "use strict";

    Human.rpc.define("dissect.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.dissect.enabled;
            }
            checkUnsavedAnnotation(enable,
                function () {
                    Human.view.dissect.setEnabled(enable);
                    if (enable) {
                        Human.view.pick.setMultiPickEnabled(false);
                        Human.view.pick.setSinglePickEnabled(false);
                        Human.view.annotations.setEnabled(false);
                    }
                });
        });

    Human.rpc.define("highlight.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.highlight.enabled;
            }
            Human.view.highlight.setEnabled(enable);
            if (enable) {
                Human.view.isolate.setEnabled(false);
                Human.view.xray.setEnabled(false);
            }
        });

    Human.rpc.define("isolate.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.isolate.enabled;
            }
            if (enable) {
                var selection = Human.scene.anySelected();
                if (!selection) {
                    alert("Please select an object before Isolating.");
                    return;
                }
            }
            Human.view.isolate.setEnabled(enable);
            if (enable) {
                Human.view.highlight.setEnabled(false);
                Human.view.xray.setEnabled(false);
                Human.view.pick.setSinglePickEnabled(true); // Multi-pick doesn't make sense in Isolate mode
                Human.view.pick.setMultiPickEnabled(false);
            }
        });

    Human.rpc.define("labels.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.labels.enabled;
            }
            Human.view.labels.setEnabled(enable);
            Human.view.tooltips.setEnabled(enable);
        });

    Human.rpc.define("pick.single.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.pick.getSinglePickEnabled();
            }
            checkUnsavedAnnotation(enable,
                function () {
                    Human.view.pick.setSinglePickEnabled(enable);
                    if (enable) {
                        Human.view.pick.setMultiPickEnabled(false);
                        Human.view.dissect.setEnabled(false);
                        Human.view.annotations.setEnabled(false);
                    }
                });
        });

    Human.rpc.define("pick.multi.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.pick.getMultiPickEnabled();
            }
            checkUnsavedAnnotation(enable,
                function () {
                    Human.view.pick.setMultiPickEnabled(enable);
                    if (enable) {
                        Human.view.pick.setSinglePickEnabled(false);
                        Human.view.dissect.setEnabled(false);
                        Human.view.annotations.setEnabled(false);
                    }
                });
        });

    Human.rpc.define("pick.pick",
        function (params) {
            Human.view.pick.pick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });

    Human.rpc.define("pick.doublePick",
        function (params) {
            Human.view.pick.doublePick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });

    Human.rpc.define("pick.hoverPick",
        function (params) {
            Human.view.pick.hoverPick({ canvasX: params.canvasX, canvasY: params.canvasY });
        });

    Human.rpc.define("pick.queryPick",
        function (params) {
            this.setResult(Human.view.pick.queryPick({ canvasX: params.canvasX, canvasY: params.canvasY, rayPick: params.rayPick }) || {});
        });

    Human.rpc.define("annotations.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.annotations.enabled;
            }
            checkUnsavedAnnotation(!enable, // Don't check, if enabling annotation mode
                function () {
                    Human.view.annotations.setEnabled(enable);
                    if (enable) {
                        Human.view.pick.setSinglePickEnabled(false);
                        Human.view.pick.setMultiPickEnabled(false);
                        Human.view.dissect.setEnabled(false);
                    }
                });
        });

    Human.rpc.define("xray.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.xray.enabled;
            }
            Human.view.xray.setEnabled(enable);
            if (enable) {
                Human.view.highlight.setEnabled(false);
                Human.view.isolate.setEnabled(false);
            }
        });

    Human.rpc.define("queryModes",
        function () {
            var data = {
                xray: Human.view.xray.enabled,
                highlight: Human.view.highlight.enabled,
                annotation: Human.view.annotations.enabled,
                singlePick: Human.view.pick.singleEnabled,
                multipick: Human.view.pick.multiEnabled,
                dissect: Human.view.dissect.enabled
            };
            this.setResult(data);
        });
    
    //UI outside of the canvas
    Human.rpc.define("jquery",
        function (params) {
            if(params.selector === 'document'){
                params.selector = document;
            } 

            $.fn[params.method].apply($(params.selector), params.args);
        });
        
    Human.rpc.define("navigation.setEnabled",
        function (params) {
            _setUIEnabled('navigator_container', params.enable);
        });
    
    Human.rpc.define("fullscreen.setEnabled",
        function (params) {
            _setUIEnabled('embed-full-screen', params.enable);
        });
    
    Human.rpc.define("injectStyles", 
        function (params) {
            if(window === top) {
                return;
            }
          
            var css  = params.styles,
                head = document.head || document.getElementsByTagName('head')[0],
                styleSheets = document.getElementsByTagName('link'),
                lastSheet   = styleSheets[ styleSheets.length - 1 ],
                style       = document.createElement('style');

                style.type  = 'text/css';
          
            if (style.styleSheet){
                style.styleSheet.cssText = css;
            } else {
                style.appendChild(document.createTextNode(css));
            }

            head.insertBefore(style, lastSheet);
            
            Human.view.annotations.updateDimensions(); //updates width property
            Human.view.annotations.layouts.redrawLayout(); // redraws positions
        });
    
    //Private methods
    
    var _setUIEnabled = function (id, enable) {
      var _enable = (typeof enable === 'undefined') ? true : enable;
      var el = document.getElementById(id);
      el.style.display = (_enable) ? 'block' : 'none';
    };
    
    function checkUnsavedAnnotation(doCheck, ok) {
        if (doCheck && Human.view.annotations.unsavedAnnotation) {
            alert("Please save or cancel annotation first");
        } else {
            ok();
        }
    }
})();;//TODO: do we really need the state-keeping?

(function () {
    "use strict";

    var mouseCursor = Human.view.mouseCursor = {};

    var STATES = {
        DEFAULT: 0,
        PAN: 1,
        PROGRESS: 2,
        ROTATE: 3,
        ZOOM_IN: 4,
        ZOOM_OUT: 5
    };
    var _state = STATES.PROGRESS;

    var defaultCursorType = "pointer";

    var processCount = 0;

    Human.events.on("processes.started",
        function () {
            if (++processCount === 1) {
                mouseCursor.gotoProgress();
            }
        });

    Human.events.on("processes.finished",
        function () {
            if (--processCount <= 0) {
                processCount = 0;
                mouseCursor.gotoDefault();
            }
        });

    Human.events.on("processes.failed",
        function () {
            if (--processCount <= 0) {
                processCount = 0;
                mouseCursor.gotoDefault();
            }
        });

    Human.events.on("dissect.toggled",
        function () {
            mouseCursor.gotoDefault();
        });

    mouseCursor.setDefault = function (type) {
        if (type !== "pointer" && type !== "crosshair") {
            Human.log.error("Human.view.mouseCursor", "Unsupported default cursor type: " + type);
            return;
        }
        defaultCursorType = type;
        if (_state === STATES.DEFAULT) {
            $("body").css("cursor", type);
        }
    };

    mouseCursor.gotoDefault = function () {
        $("body").css("cursor", Human.view.dissect.getEnabled() ? "crosshair" : defaultCursorType);
        _state = STATES.DEFAULT;
    };

    mouseCursor.gotoPan = function () {
        if (_state !== STATES.PROGRESS) {
            $("body").css("cursor", "move");
            _state = STATES.PAN;
        }
    };

    mouseCursor.gotoProgress = function () {
        if (_state === STATES.DEFAULT || _state === STATES.PROGRESS) {
            $("body").css("cursor", "progress");
            _state = STATES.PROGRESS;
        }
    };

    mouseCursor.gotoRotate = function () {
        if (_state !== STATES.PROGRESS) {
            $("body").css("cursor", "n-resize");
            _state = STATES.ROTATE;
        }
    };

    mouseCursor.gotoZoomIn = function () {
        if (_state !== STATES.PROGRESS) {
            $("body").css("cursor", "url(Images/zoom-in.png), auto");
            _state = STATES.ZOOM_IN;
        }
    };

    mouseCursor.gotoZoomOut = function () {
        if (_state !== STATES.PROGRESS) {
            $("body").css("cursor", "url(Images/zoom-out.png), auto");
            _state = STATES.ZOOM_OUT;
        }
    };
})();
;/**
 * @namespace Manages the camera
 */
(function () {
    "use strict";

    var HumanViewCamera = Human.view.camera = {};

    // Scene graph nodes, initialized when engine loaded
    var lookatNode = null;
    var cameraNode = null;

    // Used in some methods for distance calculations
    var eyeVec = Human.math.vec3();
    var lookVec = Human.math.vec3();
    var upVec = Human.math.vec3();
    var eyeVecNorm = Human.math.vec3();
    var lookVecNorm = Human.math.vec3();
    var upVecNorm = Human.math.vec3();
    var leftVec = Human.math.vec3();
    var panVec = Human.math.vec3();
    var tempVec = Human.math.vec3();
    var tempMat4 = Human.math.mat4();

    /**
     Current eye position
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanViewCamera.eye = { x: 0, y: 0, z: -80 };

    /**
     Current point-of-interest
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanViewCamera.look = { x: 0, y: 0, z: 0 };

    /**
     Current "up" vector
     @type {{x: number, y: number, z: number}}
     @readonly
     */
    HumanViewCamera.up = { x: 0, y: 1, z: 0 };

    /**
     * Offset added to the "look" point in View-space, allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     * @type {{x: number, y: number, z: number}}
     */
    HumanViewCamera._screenPan = {x: 0, y: 0, z: 0 };

    // Schedules scene graph updates when true

    var lookatNodeDirty = false;
    var cameraNodeDirty = false;

    // True when no scene graph updates pending
    var rested = false;

    // Constraints registered with #addConstraint
    var constraints = [];

    /**
     * When true, causes camera to ignore calls to pan or rotate.
     * This is set and unset by Human.camera.fly to stop the user from panning or rotating
     * the camera while flight is in progress, which screws things up.
     */
    HumanViewCamera.lock = false;

    /**
     Camera aspect ration
     @type {number}
     @readonly
     */
    HumanViewCamera.aspect = 1;

    // Field-of-View angle in degrees
    Human.properties.subscribe({
        propId: "camera.optics.aspect",
        value: HumanViewCamera.aspect,
        callback: function (value) {
            HumanViewCamera.aspect = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Field-ov-view angle on Y-axis
     @type {number}
     @readonly
     */
    HumanViewCamera.fovy = 55;

    // Field-of-View angle in degrees
    Human.properties.subscribe({
        propId: "camera.optics.fov",
        value: HumanViewCamera.fovy,
        callback: function (value) {
            HumanViewCamera.fovy = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Distance to the near clipping plane
     @type {number}
     @readonly
     */
    HumanViewCamera.near = 0.1;

    // Distance to near clipping plane
    Human.properties.subscribe({
        propId: "camera.optics.near",
        value: 0.1,
        callback: function (value) {
            HumanViewCamera.near = value;
            cameraNodeDirty = true;
        }
    });

    /**
     Minimum allowed distance between {@link #eye} and {@link #look}
     @type {number}
     @readonly
     */
    HumanViewCamera.minZoom = 0.01;

    /**
     Maximum allowed distance between {@link #eye} and {@link #look}
     @type {number}
     @readonly
     */
    HumanViewCamera.maxZoom = 150;

    // Zoom limits - distance between eye and look
    Human.properties.subscribe({
        propId: "camera.zoomLimits",
        value: {
            min: 0.01,
            max: 150
        },
        callback: function (value) {
            if (value.min < 0.01) {
                Human.log.error("Human.view.camera", "Property 'camera.zoomLimits.min' too small - should be >= 0.01");
                return;
            }
            if (value.min >= value.max) {
                Human.log.error("Human.view.camera", "Property 'camera.zoomLimits.min' should be less than camera.zoomLimits.max");
                return;
            }
            HumanViewCamera.minZoom = value.min;
            HumanViewCamera.maxZoom = value.max;
            lookatNodeDirty = true;
        }
    });

    // Gimbal lock constraint
    // When true, camera is "gimbal locked" and spins about model's Y axis
    var gimbalLockY = true;

    Human.properties.subscribe({
        propId: "camera.gimbalLockY",
        value: gimbalLockY,
        callback: function (value) {

            gimbalLockY = value;
        }
    });

    // Pitch constraint
    // When true, prevents camera from being rotated outside [0..180] about X-axis
    var constrainRotateX = false;

    Human.properties.subscribe({
        propId: "camera.constrainRotateX",
        value: constrainRotateX,
        callback: function (value) {

            constrainRotateX = value;

            // Need to reset the camera position because it might
            // be currently outside of the rotation constraint

            // HumanViewCamera.viewAnterior();
        }
    });

    // First-person mode
    // When true, look rotates about eye, otherwise eye rotates about look
    var firstPerson = false;

    Human.properties.subscribe({
        propId: "camera.firstPerson",
        value: firstPerson,
        callback: function (value) {
            firstPerson = value;
        }
    });

    // When engine started
    Human.events.on(
        "loaded",
        function () {

            // Get scene graph nodes

            lookatNode = Human.renderer.getNode(Human.LOOKAT_ID);
            cameraNode = Human.renderer.getNode(Human.CAMERA_ID);

            // Initialise projection aspect ratio

            var optics = cameraNode.get("optics");

            HumanViewCamera.aspect = optics.aspect;
            HumanViewCamera.fovy = optics.fovy;

            // Schedule update of view and projection transforms for next tick

            lookatNodeDirty = true;
            cameraNodeDirty = true;

            // Camera not at rest now
            rested = false;

        });

    // Adjust camera aspect on canvas resize
    Human.events.on("canvas.resized",
        function (params) {
            HumanViewCamera.setAspect(params.canvasWidth / params.canvasHeight);
        });

    Human.events.on(
        "tick",
        function () {

            if (lookatNodeDirty) {

                // View transform update scheduled for scene graph

                lookatNode.setEye(HumanViewCamera.eye);
                lookatNode.setLook(HumanViewCamera.look);
                lookatNode.setUp(HumanViewCamera.up);

                Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
                Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
                Human.math.subVec3(eyeVec, lookVec, tempVec);

                Human.events.fire("camera.updated", {

                    // Camera position
                    eye: HumanViewCamera.eye,
                    look: HumanViewCamera.look,
                    up: HumanViewCamera.up,

                    // Distance from viewpoint to point-of-interest
                    dist: Math.abs(Human.math.lenVec3(tempVec))
                });

                // Camera not at rest now
                rested = false;

                // Scene camera position now up to date
                lookatNodeDirty = false;

            } else {

                // Else camera position now at rest

                if (!rested) {

                    rested = true;

                    Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
                    Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
                    Human.math.subVec3(eyeVec, lookVec, tempVec);

                    Human.events.fire("camera.rested", {

                        // Camera position
                        eye: HumanViewCamera.eye,
                        look: HumanViewCamera.look,
                        up: HumanViewCamera.up,

                        // Distance from viewpoint to point-of-interest
                        dist: Math.abs(Human.math.lenVec3(tempVec))
                    });
                }
            }

            if (cameraNodeDirty) {

                // Update the scene graph

                cameraNode.set({
                    optics: {
                        type: "perspective",
                        fovy: HumanViewCamera.fovy,
                        near: HumanViewCamera.near,
                        far: HumanViewCamera.far,
                        aspect: HumanViewCamera.aspect
                    },
                    pan: HumanViewCamera._screenPan
                });

                // Scene projection now up to date
                cameraNodeDirty = false;
            }

        });

    /**
     Installs a constraint callback into this camera.

     <p>Every time the camera is about to update state, it will only allow that to happen if all constraint callbacks return "true".</p>

     <p>Unexpected results may occur if you add the same callback more than once.</p>

     @param {Function} callback The constraint callback
     */
    HumanViewCamera.addConstraint = function (callback) {
        constraints.push(callback);
    };

    /**
     Removes a constraint callback that was installed previously with {@link #addConstraint}.

     @param {Function} callback The constraint callback
     */
    HumanViewCamera.removeConstraint = function (callback) {
        for (var i = 0, len = constraints.length; i < len; i++) {
            if (constraints[i] === callback) {
                constraints.splice(i, 1);
                return;
            }
        }
    };

    /**
     Sets the position of the camera.

     @param params
     @param [params.eye]
     @param [params.look]
     @param [params.up]
     */
    HumanViewCamera.setLookAt = function (params) {
        HumanViewCamera._setConstrainedLookat(params.eye, params.look, params.up);
    };

    /**
     * Sets lookat state as long as it passes constraints,
     * return false if constrained else true.
     */
    HumanViewCamera._setConstrainedLookat = function (eye, look, up) {

        if (eye) {
            //HumanViewCamera.clampEye(eye);
        }

        eye = eye || HumanViewCamera.eye;
        look = look || HumanViewCamera.look;
        up = up || HumanViewCamera.up;

        for (var i = 0, len = constraints.length; i < len; i++) {

            if (!constraints[i](eye, look, up)) {

                // Camera constrained

                // Need to cancel camera behaviours like fly-to
                // which may be sending the camera off on a wild journey

                Human.events.fire("camera.constrained");

                return false;
            }
        }

        // Not constrained, set state and schedule scene update

        HumanViewCamera.eye = eye;
        HumanViewCamera.look = look;
        HumanViewCamera.up = up;

        lookatNodeDirty = true;
    };

    HumanViewCamera._clampEye = function (pos) {
        lookVec[0] = HumanViewCamera.look.x;
        lookVec[1] = HumanViewCamera.look.y;
        lookVec[2] = HumanViewCamera.look.z;

        eyeVec[0] = pos.x;
        eyeVec[1] = pos.y;
        eyeVec[2] = pos.z;

        Human.math.subVec3(eyeVec, lookVec, tempVec); // Vector from eye to look
        Human.math.normalizeVec3(tempVec, tempVec);
        var dist = Math.abs(Human.math.lenVec3(tempVec));   // Distance from center to pos
        if (dist < HumanViewCamera.minZoom) {
            Human.math.mulVec3Scalar(tempVec, HumanViewCamera.minZoom, tempVec);
            Human.math.addVec3(lookVec, tempVec, tempVec);
        } else if (dist > HumanViewCamera.maxZoom) {
            Human.math.mulVec3Scalar(tempVec, HumanViewCamera.maxZoom, tempVec);
            Human.math.addVec3(lookVec, tempVec, tempVec);
        } else {
            return pos;
        }
        return {
            x: tempVec[0],
            y: tempVec[1],
            z: tempVec[2]
        };
    };

    /**
     Returns the position of this camera.
     @returns {{eye: *, look: *, up: *}}
     */
    HumanViewCamera.getLookAt = function () {
        return {
            eye: HumanViewCamera.eye,
            look: HumanViewCamera.look,
            up: HumanViewCamera.up
        };
    };

    /** Returns the eye position.
     * @returns {{x: Number, y: Number, z: Number}}
     */
    HumanViewCamera.getEye = function () {
        return HumanViewCamera.eye;
    };

    /** Returns the 'look' position.
     * @returns {{x: Number, y: Number, z: Number}}
     */
    HumanViewCamera.getLook = function () {
        return HumanViewCamera.look;
    };

    /** Returns the 'up' vector.
     * @returns {{x: Number, y: Number, z: Number}}
     */
    HumanViewCamera.getUp = function () {
        return HumanViewCamera.up;
    };

    /**
     * Sets offset added to the "look" position in View-space, which allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     *
     * @param {{x: number, y: number, z: number}} screenPan The View-space pan vector
     */
    HumanViewCamera.setScreenPan = function (screenPan) {
        HumanViewCamera._screenPan.x = screenPan.x || 0;
        HumanViewCamera._screenPan.y = screenPan.y || 0;
        HumanViewCamera._screenPan.z = screenPan.z || 0;
        cameraNodeDirty = true;
    };

    /**
     * Gets offset that's added to the "look" point in View-space, which allows camera to orbit
     * about an arbitrary offset from the point-of-interest.
     *
     * @return {{x: number, y: number, z: number}} The View-space pan vector
     */
    HumanViewCamera.getScreenPan = function () {
        return HumanViewCamera._screenPan;
    };

    HumanViewCamera._reset = {
        eye: { x: HumanViewCamera.eye.x, y: HumanViewCamera.eye.y, z: HumanViewCamera.eye.z },
        look: { x: HumanViewCamera.look.x, y: HumanViewCamera.look.y, z: HumanViewCamera.look.z },
        up: { x: HumanViewCamera.up.x, y: HumanViewCamera.up.y, z: HumanViewCamera.up.z }
    };

    /**
     * Resets this camera to initial position
     */
    HumanViewCamera.reset = function () {
        HumanViewCamera.yaw = 0;
        HumanViewCamera.pitch = 90;
        HumanViewCamera._eye = { x: HumanViewCamera._reset.eye.x, y: HumanViewCamera._reset.eye.y, z: HumanViewCamera._reset.eye.z };
        HumanViewCamera._look = { x: HumanViewCamera._reset.look.x, y: HumanViewCamera._reset.look.y, z: HumanViewCamera._reset.look.z };
        HumanViewCamera._up = { x: HumanViewCamera._reset.up.x, y: HumanViewCamera._reset.up.y, z: HumanViewCamera._reset.up.z };
        lookatNodeDirty = true;
    };

    /**
     * Rotates camera about X-axis.
     *
     * <p>When "camera.firstPerson" property is true, defers to {@link #rotateLookY} else {@link #rotateEyeY}.</p>
     */
    HumanViewCamera.rotateX = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        if (firstPerson) {
            HumanViewCamera.rotateLookX(-angle);
        } else {
            HumanViewCamera.rotateEyeX(angle);
        }
    };

    /**
     * Rotates camera about Y-axis.
     *
     * <p>When "camera.firstPerson" property is true, defers to {@link #rotateLookX} else {@link #rotateEyeX}.</p>
     */
    HumanViewCamera.rotateY = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        if (firstPerson) {
            HumanViewCamera.rotateLookY(-angle);
        } else {
            HumanViewCamera.rotateEyeY(angle);
        }
    };

    /**
     * Rotate 'eye' about 'look', around the 'up' vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */
    HumanViewCamera.rotateEyeY = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(eyeVec, lookVec, eyeVec);

        // Rotate 'eye' vector about 'up' vector
        Human.math.rotationMat4v(angle * 0.0174532925, gimbalLockY ? [0, 1, 0] : upVec, tempMat4);
        Human.math.transformVector3(tempMat4, eyeVec, eyeVec);

        // Set eye position as 'look' plus 'eye' vector
        Human.math.addVec3(eyeVec, lookVec, eyeVec);

        if (gimbalLockY) {

            // Rotate 'up' vector about orthogonal vector
            Human.math.transformVector3(tempMat4, upVec, upVec);
        }

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },


            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }
        });
    };

    /**
     * Rotate 'eye' about 'look' around the X-axis
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */

    HumanViewCamera.rotateEyeX = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(eyeVec, lookVec, eyeVec);

        Human.math.normalizeVec3(eyeVec, eyeVecNorm);
        Human.math.normalizeVec3(upVec, upVecNorm);


        // Get orthogonal vector from 'eye' and 'up'
        Human.math.cross3Vec3(eyeVecNorm, upVecNorm, leftVec);

        // Rotate 'eye' vector about orthogonal vector
        Human.math.rotationMat4v(angle * 0.0174532925, leftVec, tempMat4);
        Human.math.transformVector3(tempMat4, eyeVec, eyeVec);

        if (constrainRotateX) {

            // Pitch constraint
            // Prevents camera from being rotated outside [0..180] about X-axis
            // TODO: This implementation does not work through full 360 degrees
//
//        var alt =  (57.2957795 * Math.atan2(eye2[1], Math.sqrt(eye2[0] * eye2[0] + eye2[2] * eye2[2])));
//        var az = 57.2957795 * Math.atan2(-eye2[0], -eye2[2]);
//        if (alt > 80 || alt < -80) {
//            return;
//        }
        }

        // Set eye position as 'look' plus 'eye' vector
        Human.math.addVec3(eyeVec, lookVec, eyeVec);

        // Rotate 'up' vector about orthogonal vector
        Human.math.transformVector3(tempMat4, upVec, upVec);

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },
            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }
        });
    };

    /**
     * Rotate 'look' about 'eye', around the 'up' vector
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */
    HumanViewCamera.rotateLookY = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(lookVec, eyeVec, lookVec);

        // Rotate 'look' vector about 'up' vector
        Human.math.rotationMat4v(angle * 0.0174532925, gimbalLockY ? [0, 1, 0] : upVec, tempMat4);
        Human.math.transformVector3(tempMat4, lookVec, lookVec);

        // Set look position as 'look' plus 'eye' vector
        Human.math.addVec3(lookVec, eyeVec, lookVec);

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },
            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }
        });
    };

    /**
     * Rotate 'eye' about 'look' around the X-axis
     *
     * <p>Applies constraints added with {@link #addConstraint}.</p>
     *
     * @param {Number} angle Angle of rotation in degrees
     */
    HumanViewCamera.rotateLookX = function (angle) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(lookVec, eyeVec, lookVec);

        Human.math.normalizeVec3(lookVec, lookVecNorm);
        Human.math.normalizeVec3(upVec, upVecNorm);


        // Get orthogonal vector from 'eye' and 'up'
        Human.math.cross3Vec3(lookVecNorm, upVecNorm, leftVec);

        // Rotate 'look' vector about orthogonal vector
        Human.math.rotationMat4v(angle * 0.0174532925, leftVec, tempMat4);
        Human.math.transformVector3(tempMat4, lookVec, lookVec);

        // Set eye position as 'look' plus 'eye' vector
        Human.math.addVec3(lookVec, eyeVec, lookVec);

        // Rotate 'up' vector about orthogonal vector
        Human.math.transformVector3(tempMat4, upVec, upVec);

        // Update scene graph camera
        HumanViewCamera.setLookAt({
            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            },
            up: {
                x: upVec[0],
                y: upVec[1],
                z: upVec[2]
            }
        });
    };

    /**
     * Pans the camera along X and Y axis.
     * Applies constraints added with {@link #addConstraint}.
     * @param pan The pan vector
     */

    var eyeVec2 = Human.math.vec3();

    HumanViewCamera.pan = function (pan) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        // Get eye, look and up as arrays
        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.vec3ObjToArray(HumanViewCamera.up, upVec);

        // Get 'look' -> 'eye' vector
        Human.math.subVec3(eyeVec, lookVec, eyeVec2);

        // Building this pan vector
        Human.math.zeroVec(panVec);

        if (pan.x !== undefined && pan.x !== null) {

            // Pan along orthogonal vector to 'look' and 'up'

            Human.math.normalizeVec3(eyeVec2, eyeVecNorm);
            Human.math.normalizeVec3(upVec, upVecNorm);

            var left = Human.math.cross3Vec3(eyeVec2, upVec, leftVec);
            Human.math.normalizeVec3(Human.math.cross3Vec3(eyeVec2, upVec, leftVec), left);

            Human.math.mulVec3Scalar(left, pan.x, tempVec);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        if (pan.y !== undefined && pan.y !== null) {

            // Pan along 'up' vector
            Human.math.normalizeVec3(upVec, upVecNorm);

            Human.math.mulVec3Scalar(upVecNorm, pan.y, tempVec);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        if (pan.z !== undefined && pan.z !== null) {

            // Pan along 'eye'- -> 'look' vector

            Human.math.normalizeVec3(eyeVec, eyeVecNorm);

            Human.math.mulVec3Scalar(eyeVecNorm, pan.z, tempVec);

            panVec[0] += tempVec[0];
            panVec[1] += tempVec[1];
            panVec[2] += tempVec[2];
        }

        Human.math.addVec3(eyeVec, panVec, eyeVec);
        Human.math.addVec3(lookVec, panVec, lookVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            },
            look: {
                x: lookVec[0],
                y: lookVec[1],
                z: lookVec[2]
            }
        });
    };

    /** Sets the projection aspect ratio
     */
    HumanViewCamera.setAspect = function (aspect) {
        HumanViewCamera.aspect = aspect;
        cameraNodeDirty = true;
    };

    /**
     Positions camera to look at the scene from along the -X axis.
     */
    HumanViewCamera.viewRight = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: -dist, y: elev, z: 0 },
            up: {x: 0, y: 1, z: 0 }
        });
    };

    /**
     Positions camera to look at the scene from along the +X axis.
     */
    HumanViewCamera.viewLeft = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: dist, y: elev, z: 0 },
            up: {x: 0, y: 1, z: 0 }
        });
    };

    /**
     Positions camera to look at the scene from along the +Z axis.
     */
    HumanViewCamera.viewPosterior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: elev, z: -dist },
            up: {x: 0, y: 1, z: 0 }
        });
    };

    /**
     Positions camera to look at the scene from along the -Z axis.
     */
    HumanViewCamera.viewAnterior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: elev, z: dist },
            up: {x: 0, y: 1, z: 0 }
        });
    };

    /**
     Positions camera to look at the scene from along the +Y axis.
     */
    HumanViewCamera.viewSuperior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: -dist + elev, z: 0 },
            up: {x: 0, y: 0, z: 1 }
        });
    };

    /**
     Positions camera to look at the scene from along the +Y axis.
     */
    HumanViewCamera.viewInferior = function () {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        var eye = Human.init.bookmark.camera.eye;
        var dist = eye.z;
        var elev = eye.y;

        HumanViewCamera.setLookAt({
            look: { x: 0, y: elev, z: 0 },
            eye: { x: 0, y: dist + elev, z: 0 },
            up: {x: 0, y: 0, z: -1 }
        });
    };

    /**
     * Increments/decrements zoom factor, ie. distance between eye and look.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @param delta
     */
    HumanViewCamera.zoom = function (delta) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);
        Human.math.subVec3(eyeVec, lookVec, eyeVec);            // Get vector from eye to look
        var lenLook = Math.abs(Human.math.lenVec3(eyeVec));    // Get len of that vector
        var newLenLook = Math.abs(lenLook + delta);         // Get new len after zoom

        if (HumanViewCamera.minZoom && HumanViewCamera.maxZoom) {

            var f = (lenLook / HumanViewCamera.maxZoom) * 0.6;

            delta = (40 * delta) * f;

            newLenLook = Math.abs(lenLook + delta);

            if (newLenLook < HumanViewCamera.minZoom) {
                newLenLook = HumanViewCamera.minZoom;

            } else if (newLenLook > HumanViewCamera.maxZoom) {
                newLenLook = HumanViewCamera.maxZoom;
            }
        }

        Human.math.normalizeVec3(eyeVec, eyeVecNorm);  // Get normalised vector
        Human.math.mulVec3Scalar(eyeVecNorm, newLenLook, eyeVec);
        Human.math.addVec3(lookVec, eyeVec, eyeVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            }
        });
    };

    /**
     * Sets the zoom as a factor indicating a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @param {Number} zoomFactor The factor
     */
    HumanViewCamera.setZoom = function (zoomFactor) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        Human.math.subVec3(eyeVec, lookVec, eyeVec);  // Get vector from eye to look
        Human.math.normalizeVec3(eyeVec, eyeVecNorm);  // Get normalised vector
        Human.math.mulVec3Scalar(eyeVecNorm, HumanViewCamera.minZoom + (1.0 - zoomFactor) * (HumanViewCamera.maxZoom - HumanViewCamera.minZoom), eyeVec);

        Human.math.addVec3(lookVec, eyeVec, eyeVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: eyeVec[0],
                y: eyeVec[1],
                z: eyeVec[2]
            }
        });
    };

    /**
     * Returns the zoom as a factor indicating a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * @return {Number} The zoom factor
     */
    HumanViewCamera.getZoom = function () {

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        Human.math.subVec3(eyeVec, lookVec, eyeVec);            // Get vector from eye to look
        var lenLook = Math.abs(Human.math.lenVec3(eyeVec));    // Get len of that vector

        return 1 - (((lenLook - HumanViewCamera.minZoom) / HumanViewCamera.maxZoom));
    };


    /**
     * Sets the zoom via a percentage factor which indicates a position between {@link #minZoom} and {@link #maxZoom}.
     *
     * Applies constraints added with {@link #addConstraint}.
     *
     * @deprecated
     * @param {Number} zoomPercent The percentage factor
     */
    HumanViewCamera.setZoomPercent = function (zoomPercent) {

        if (HumanViewCamera.lock) {
            // Camera is being animated, don't allow interaction
            return;
        }

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        Human.math.subVec3(eyeVec, lookVec, eyeVec);  // Get vector from eye to look
        Human.math.normalizeVec3(eyeVec, eyeVecNorm);  // Get normalised vector

        Human.math.mulVec3Scalar(eyeVecNorm, HumanViewCamera.minZoom + (100.0 - zoomPercent) * 0.01 * (HumanViewCamera.maxZoom - HumanViewCamera.minZoom), eyeVec);

        HumanViewCamera.setLookAt({
            eye: {
                x: lookVec[0] + eyeVec[0],
                y: lookVec[1] + eyeVec[1],
                z: lookVec[2] + eyeVec[2]
            }
        });
    };

    /**
     * @deprecated
     */
    HumanViewCamera.getZoomPercent = function () {

        Human.math.vec3ObjToArray(HumanViewCamera.eye, eyeVec);
        Human.math.vec3ObjToArray(HumanViewCamera.look, lookVec);

        Human.math.subVec3(eyeVec, lookVec, eyeVec);            // Get vector from eye to look
        var lenLook = Math.abs(Human.math.lenVec3(eyeVec));    // Get len of that vector

        return 100 - (((lenLook - HumanViewCamera.minZoom) / HumanViewCamera.maxZoom) * 100);
    };
})();


;(function() {
    "use strict";

    Human.rpc.define("camera.flyTo", function (params) {
        var self = this;
        Human.view.camera.fly.flyTo(params,
            function () {
                self.setResult(true);
            });
    });


    Human.rpc.define("camera.jumpTo", function (params) {
        var self = this;
        Human.view.camera.fly.jumpTo(params,
            function () {
                self.setResult(true);
            });
    });

    Human.rpc.define("camera.orbit", function (params) {
        var yaw = params.yaw;
        var pitch = params.pitch;
        if (yaw !== undefined && yaw !== null && yaw !== 0) {
            Human.view.camera.rotateY(yaw);
        }
        if (pitch !== undefined && pitch !== null && pitch !== 0) {
            Human.view.camera.rotateX(pitch);
        }
    });

    //
    //Human.rpc.define("camera.orbitTo", function (params) {
    //    if (params.yaw == undefined && params.pitch == undefined) {
    //        this.error("incomplete parameter configuration: both 'yaw' and 'pitch' expected");
    //        return;
    //    }
    //    Human.view.camera.set(params);
    //});


    //Human.rpc.define("camera.panTo", function (params) {
    //    Human.view.camera.panTo(params.x || 0, params.y || 0, params.z || 0);
    //});

    Human.rpc.define("camera.pan", function (params) {
        Human.view.camera.pan({
            x: params.x || 0,
            y: params.y || 0,
            z: params.z || 0
        });
    });

    Human.rpc.define("camera.zoom", function (params) {
        Human.view.camera.setZoom(params.factor || 0);
    });

    Human.rpc.define("camera.getZoom", function () {
        this.setResult(Human.view.camera.getZoom());
    });

    Human.rpc.define("camera.query", function () {
        this.setResult(Human.view.camera.getLookAt());
    });

    Human.rpc.define("camera.reset",
        function () {
            var self = this;
            Human.init.resetCamera(function () {
                self.setResult(true);
            });
        });

})();
;/**
 * @namespace Manages camera flights
 */
(function () {
    "use strict";

    var fly = Human.view.camera.fly = {};

    var stopFOV;

    Human.properties.subscribe({
        propId: "camera.flyTo",
        value: {
            stopFOV: 55
        },
        callback: function (value) {
            stopFOV = value.stopFOV;
        }
    });

    var callbacks = [];
    var animation = null;
    var eyeVec3 = Human.math.vec3();
    var lookVec3 = Human.math.vec3();
    var paramLookVec3 = Human.math.vec3();
    var tempVec3 = Human.math.vec3();

    Human.events.on("tick",
        function () {
            if (animation) {
                animation.update((new Date()).getTime());
            }
        });

    // Stop animation when a flight goes out of the max camera boundary
    Human.events.on("camera.constrained",
        function () {
            finishAnimation();
        });

    /** Initiates camera flight to the given target
     *
     * <p>This method can be called again at any time during a fly-to to initiate a new flight
     * that replaces any already in progress.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {String} [params.objectId] Scene object to fly to, given by ID
     * @param {String} [params.fmaId] Scene object to fly to, given by FMAID
     * @param {*} [params.boundary] Boundary to fly to
     * @param {*} [params.lookVec] Look vector to fly along
     * @param {*} [params.eye] Eye position to fly to, used in conjunction with params.look
     * @param {*} [params.look] Look vector to fly to, used in conjunction with params.eye
     * @param {Boolean} [params.selectedObjects] Flies to boundary of all currently selected scene objects when true
     * @param {Boolean} [params.selectedLeafObjects] Flies to boundary of all currently selected scene leaf objects when true
     * @param {Boolean} [params.enabledObjects] Flies to boundary of all currently enabled scene objects when true
     * @param {Number} [params.velocity] Camera flight velocity factor - default is 1.0
     * @param {Number} [params.arc] Camera flight arc factor - 0.0 for no arc, 1.0 for maximum arc - default is 0.0
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.view.camera.fly
     */
    fly.flyTo = function (params, ok, error) {
        var object, boundary, objectId;

        ok = ok || function () {
        };
        error = error || function (msg) {
            Human.log.error("Human.view.camera.fly", msg);
            ok();
        };

        if (params.objectId) {

            // Fly to scene object, found by ID

            objectId = params.objectId;
            object = Human.scene.objects[objectId];
            if (!object) {
                error("No scene object found for the given ID: '" + objectId + "'");
                return;
            }
            boundary = Human.scene.getBoundary(objectId);
            if (boundary) {
                Human.view.boundary.setBoundary(boundary, true);     // Show boundary
                flyTo({
                        target: { boundary: boundary },
                        arc: params.arc,
                        backOff: params.backOff,
                        velocity: params.velocity
                    },
                    function () {
                        Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                        ok();
                    });
            } else {
                ok();
            }
        } else if (params.fmaId) {

            // Fly to scene object, found by FMAID

            var fmaId = params.fmaId;
            object = Human.scene.objectsByFMAID[fmaId];
            if (!object) {
                error("no object found for the given FMA ID: '" + fmaId + "'");
                return;
            }
            boundary = Human.scene.getBoundary(object.objectId);
            if (boundary) {
                Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
                flyTo({
                    target: { boundary: boundary },
                    arc: params.arc,
                    backOff: params.backOff,
                    velocity: params.velocity
                }, function () {
                    Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator                    
                    ok();
                });
            } else {
                ok();
            }

        } else if (params.boundary) {

            // Fly to look at given boundary

            boundary = params.boundary;
            Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
            flyTo({
                target: { boundary: boundary },
                arc: params.arc,
                backOff: params.backOff,
                velocity: params.velocity
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator                
                ok();
            });

        } else if (params.lookVec) {

            // Fly along look vector 

            var lookVec = params.lookVec;
            var eye = Human.view.camera.eye;
            var look = Human.view.camera.look;

            paramLookVec3[0] = lookVec.x;
            paramLookVec3[1] = lookVec.y;
            paramLookVec3[2] = lookVec.z;

            eyeVec3[0] = eye.x;
            eyeVec3[1] = eye.y;
            eyeVec3[2] = eye.z;

            lookVec3[0] = look.x;
            lookVec3[1] = look.y;
            lookVec3[2] = look.z;

            Human.math.subVec3(lookVec3, eyeVec3, tempVec3);
            // Distance from current eye to look
            var distEyeLook = Human.math.lenVec3(tempVec3);

            Human.math.subVec3(paramLookVec3, eyeVec3, tempVec3);
            // Distance from current eye to the given point we'll point the look at
            var distVec = Human.math.lenVec3(tempVec3);
            // Ratio of distances
            var factor = distEyeLook / distVec;
            // Find point on vector [eye->lookVec] that is the same dist from eye as [eye->look]
            Human.math.lerpVec3(
                factor,
                0,
                1,
                lookVec3,
                paramLookVec3,
                lookVec3);    // New look vector destination
            // Fly to it, without arcing movement
            flyTo({
                    target: {
                        look: { x: lookVec3[0], y: lookVec3[1], z: lookVec3[2] }
                    },
                    arc: params.arc,
                    velocity: params.velocity
                },
                ok);

        } else if (params.eye || params.look) {

            // Fly to given eye point and look vector

            flyTo({
                    target: { eye: params.eye, look: params.look, up: params.up },
                    arc: params.arc,
                    backOff: params.backOff,
                    velocity: params.velocity,

                    // Want to animate "up" vector, which we don't animate by default
                    // in order to preserve camera's upwards orientation while flying
                    constrainUp: false
                },
                ok);

        } else if (params.selectedObjects) {

            // Fly to boundary of all currently selected scene objects

            boundary = Human.scene.getBoundary(Human.scene.selectedObjects);
            Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
            flyTo({
                target: { boundary: boundary }, arc: params.arc, backOff: params.backOff,
                velocity: params.velocity
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator            
                ok();
            });

        } else if (params.selectedLeafObjects) {

            // Fly to boundary of all currently selected scene leaf objects

            var list = [];
            var selectedObjects = Human.scene.selectedObjects;
            for (objectId in selectedObjects) {
                if (selectedObjects.hasOwnProperty(objectId)) {
                    object = selectedObjects[objectId];
                    if (object.objects.length === 0) {
                        list.push(objectId);
                    }
                }
            }
            boundary = Human.scene.getBoundary(list);
            Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
            flyTo({
                target: { boundary: boundary }, arc: params.arc, backOff: params.backOff,
                velocity: params.velocity
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                ok();
            });

        } else if (params.enabledObjects) {

            // Fly to boundary of all currently visible scene objects

            boundary = Human.scene.getBoundary(Human.scene.enabledObjects);
            flyTo({
                target: { boundary: boundary }, arc: params.arc, backOff: params.backOff,
                velocity: params.velocity
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator                
                ok();
            });

        } else if (params.objects) {

            // Fly to boundary of given scene objects

            boundary = Human.scene.getBoundary(params.objects);
            flyTo({
                target: { boundary: boundary }, arc: params.arc, backOff: params.backOff,
                velocity: params.velocity
            }, function () {
                Human.view.boundary.setBoundary(boundary, false);     // Hide boundary indicator
                ok();
            });
        } else {

            // Fly to default position

            flyTo({
                    target: {
                        eye: { x: 0.0, y: 6.0, z: -70.0 },
                        look: { x: 0.0, y: 0.0, z: 0 },
                        up: {x: 0.0, y: 1.0, z: 0.0}
                    },
                    arc: params.arc,
                    backOff: params.backOff,
                    velocity: params.velocity
                },
                function () {
                    ok();
                });
        }
    };

    function flyTo(params, ok) {

        Human.view.camera.lock = true;

        // Keep callbacks already registered so
        // that their owners still get completion
        if (ok) {
            callbacks.push(ok);
        }
        params = params || {};
        // Replace old animation if one existing
        animation = new Human.view.camera.fly.Animation({
            target: params.target, arc: params.arc, backOff: params.backOff, velocity: params.velocity,
            constrainUp: params.constrainUp,
            onComplete: finishAnimation
        });
    }

    function finishAnimation() {
        animation = null;
        while (callbacks.length > 0) {
            callbacks.pop()();
        }
        Human.view.camera.lock = false;
    }

    /** Jumps camera to the given target
     *
     * <p>Terminates any camera flight in progress and signals its completion.</p>
     *
     * @param {*} params Parameters for various flight modes
     * @param {String} [params.objectId] Scene object to fly to, given by ID
     * @param {String} [params.fmaId] Scene object to fly to, given by FMAID
     * @param {*} [params.boundary] Boundary to fly to
     * @param {*} [params.lookVec] Look vector to fly along
     * @param {*} [params.eye] Eye position to fly to, used in conjunction with params.look
     * @param {*} [params.look] Look vector to fly to, used in conjunction with params.eye
     * @param {Boolean} [params.selectedObjects] Flies to boundary of all currently selected scene objects when true
     * @param {Boolean} [params.enabledObjects] Flies to boundary of all currently enabled scene objects when true
     * @param {Number} [params.backOff] Camera back-off factor in range of [0..1], when 0 is close (default), 1 is far
     * @param {Function} ok Optional callback, fired when camera arrives at target
     * @param {Function} error Optional error callback
     * @memberof Human.view.camera.fly
     */
    fly.jumpTo = function (params, ok, error) {
        var object, boundary, objectId;

        ok = ok || function () {
        };

        error = error || function (msg) {
            Human.log.error("Human.view.camera.fly", msg);
            ok();
        };

        var target;

        if (params.objectId) {

            // Boundary of scene object, found by ID

            objectId = params.objectId;
            object = Human.scene.objects[objectId];
            if (!object) {
                error("No scene object found for the given ID: '" + objectId + "'");
                return;
            }
            boundary = Human.scene.getBoundary(objectId);

            if (boundary) {
                target = {
                    target: {
                        boundary: boundary
                    },
                    backOff: params.backOff
                };
            }

        } else if (params.fmaId) {

            // Boundary of scene object, found by FMAID

            var fmaId = params.fmaId;
            object = Human.scene.objectsByFMAID[fmaId];
            if (!object) {
                error("no object found for the given FMA ID: '" + fmaId + "'");
                return;
            }
            boundary = Human.scene.getBoundary(object.objectId);
            if (boundary) {
                target = {
                    target: {
                        boundary: boundary
                    },
                    backOff: params.backOff
                };
            }

        } else if (params.boundary) {

            // Given boundary

            target = {
                target: {
                    boundary: params.boundary
                }
            };

        } else if (params.eye || params.look) {

            // Given eye point and look vector

            if (!params.eye && !params.look) {
                error("incomplete parameter configuration: both 'eye' and 'look' expected");
                return;
            }
            target = {
                target: {
                    eye: params.eye,
                    look: params.look,
                    up: params.up
                }
            };

        } else if (params.selectedObjects) {

            // Boundary of all currently selected scene objects

            boundary = Human.scene.getBoundary(Human.scene.selectedObjects);
            Human.view.boundary.setBoundary(boundary, true);     // Show boundary indicator
            target = {
                target: {
                    boundary: boundary
                },
                backOff: params.backOff
            };

        } else if (params.enabledObjects) {

            // Boundary of all currently visible scene objects

            boundary = Human.scene.getBoundary(Human.scene.enabledObjects);
            target = {
                target: {
                    boundary: boundary
                },
                backOff: params.backOff
            };

        } else if (params.lookVec) {

            // Fly along look vector

            var lookVec = params.lookVec;
            var eye = Human.view.camera.eye;
            var look = Human.view.camera.look;

            // Distance from current eye to look
            var distEyeLook = Human.math.lenVec3(Human.math.subVec3([look.x, look.y, look.z], [eye.x, eye.y, eye.z]));

            // Distance from current eye to the given point we'll point the look at
            var distVec = Human.math.lenVec3(Human.math.subVec3([lookVec.x, lookVec.y, lookVec.z], [eye.x, eye.y, eye.z]));

            // Ratio of distances
            var factor = distEyeLook / distVec;

            // Find point on vector [eye->lookVec] that is the same dist from eye as [eye->look]
            var newLook = Human.math.lerpVec3(
                factor,
                0,
                1,
                [look.x, look.y, look.z],
                [lookVec.x, lookVec.y, lookVec.z]);
            // Fly to it, without arcing movement
            target = {
                target: {
                    look: { x: newLook[0], y: newLook[1], z: newLook[2] }
                }
            };

        } else {

            // Default position

            target = {
                target: {
                    eye: { x: 0.0, y: 6.0, z: -70.0 },
                    look: { x: 0.0, y: 0.0, z: 0 },
                    up: {x: 0.0, y: 1.0, z: 0.0}
                },
                backOff: params.backOff
            };
        }

        if (target) {

            finishAnimation();

            if (target.target.boundary) {
                target.target.stopFOV = stopFOV || target.target.stopFOV;
                Human.view.camera.fly.jumpTo(target.target);
            } else {
                Human.view.camera.setLookAt(target.target);
            }
        }

        ok();
    };

})();
;/**
 * @class Interpolates a {@link Human.view.camera} along a curved path from current position to look at a
 * target region of space.
 * @private
 *
 */
(function () {
    "use strict";

    var velocity;
    var stopFOV;

    var tempVec = Human.math.vec3();

    Human.properties.subscribe({
        propId: "camera.flyTo",
        value: {
            velocity: 1.0,
            stopFOV: 55
        },
        callback: function (value) {
            velocity = value.velocity || 1.0;
            stopFOV = value.stopFOV || 55;
        }
    });

    /**
     * @private
     */
    Human.view.camera.fly.Animation = function (cfg) {
        var target = cfg.target;

        this.arc = cfg.arc === undefined ? 0.0 : cfg.arc;

        this.easing = cfg.easing === undefined ? true : cfg.easing;

        // When true, we'll not change the camera's "up" vector
        this.constrainUp = cfg.constrainUp !== false;

        if (!target) {
            Human.log.error("Human.view.camera.fly.Animation config missing: target");
            if (cfg.onComplete) {
                cfg.onComplete();
            }
            return;
        }
        // Initial camera state
        var camera = Human.view.camera;
        this._look1 = Human.math.vec3ObjToArray(camera.look);
        this._eye1 = Human.math.vec3ObjToArray(camera.eye);
        this._up1 = Human.math.vec3ObjToArray(camera.up);

        Human.math.subVec3(this._eye1, this._look1, tempVec);

        this._vec = Human.math.normalizeVec3(tempVec);
        // Back-off factor in range of [0..1], when 0 is close, 1 is far
        var backOff = cfg.backOff || 0;
        if (backOff < 0) {
            backOff = 0;
        } else if (backOff > 1) {
            backOff = 1;
        }
        backOff = 1 - backOff;
        // Final camera state
        if (target.boundary) {
            // Zooming to look and eye computed from boundary
            var boundary = target.boundary;
            var dist = target.dist || 2.5;
            var lenVec = Math.abs(Human.math.lenVec3(this._vec));
            var diag = Human.math.getBoundaryDiag(boundary);
            var len = Math.abs((diag / (1.0 + (backOff * 0.8))) / Math.tan(stopFOV / 2));  /// Tweak this to set final camera distance on arrival
            var sca = (len / lenVec) * dist;
            this._look2 = Human.math.getBoundaryCenter(boundary);
            if (target.offset) {
                this._look2[0] += target.offset[0];
                this._look2[1] += target.offset[1];
                this._look2[2] += target.offset[2];
            }
            Human.math.mulVec3Scalar(this._vec, sca, tempVec);

            this._eye2 = Human.math.addVec3(this._look2, tempVec);
            this._up2 = Human.math.vec3();
            this._up2[1] = 1;
        } else {
            // Zooming to specific look and eye points
            var look = target.look;
            var eye = target.eye;
            var up = target.up;
            var cameraEye = Human.view.camera.eye;
            var cameraLook = Human.view.camera.look;
            var cameraUp = Human.view.camera.up;
            this._look2 = Human.math.vec3();
            this._eye2 = Human.math.vec3();
            this._up2 = Human.math.vec3();


            if (look) {
                this._look2[0] = look.x || 0;
                this._look2[1] = look.y || 0;
                this._look2[2] = look.z || 0;
            } else {
                this._look2[0] = cameraLook.x;
                this._look2[1] = cameraLook.y;
                this._look2[2] = cameraLook.z;
            }


            if (eye) {
                this._eye2[0] = eye.x || 0;
                this._eye2[1] = eye.y || 0;
                this._eye2[2] = eye.z || 0;
            } else {
                this._eye2[0] = cameraEye.x;
                this._eye2[1] = cameraEye.y;
                this._eye2[2] = cameraEye.z;
            }

            if (up) {
                this._up2[0] = up.x || 0;
                this._up2[1] = up.y || 0;
                this._up2[2] = up.z || 0;
            } else {
                this._up2[0] = cameraUp.x;
                this._up2[1] = cameraUp.y;
                this._up2[2] = cameraUp.z;
            }

        }

        // Distance to travel
        Human.math.subVec3(this._look2, this._look1, tempVec);
        var lookDist = Math.abs(Human.math.lenVec3(tempVec));
        
        Human.math.subVec3(this._eye2, this._eye1, tempVec);
        var eyeDist = Math.abs(Human.math.lenVec3(tempVec));

        this._dist = lookDist > eyeDist ? lookDist : eyeDist;

        // Duration of travel
        this._duration = 1000.0 * ((this._dist / ((cfg.velocity || velocity) * 200.0)) + 1); // extra seconds to ensure arrival

        // Completion callback
        this._onComplete = cfg.onComplete;
    };


    /** Update the interpolation to push the next state to the bound {@link Human.view.camera}
     */

    var eyeVec = Human.math.vec3();
    var lookVec = Human.math.vec3();

    Human.view.camera.fly.Animation.prototype.update = function (time) {
        if (this._time1 === undefined || this._time1 === null) {
            this._time1 = time;
            this._time2 = this._time1 + this._duration;
        }
        if (this._done || time > this._time2) {
            this._done = true;
            this._onComplete(this);
            return;
        }
        var t = (time - this._time1) / this._duration;
        var easedTime = this.easing ? this._easeOut(t, 0, 1, 1) : t;
        Human.math.lerpVec3(
            easedTime,
            0,
            1,
            this._eye1,
            this._eye2,
            eyeVec); // Destination
        var zoom;

        if (this.arc > 0.0) {
            var f = 1.0 + Math.sin(((Math.PI * 2) * easedTime) - (Math.PI * 0.75));
            zoom = (this._dist * f * (0.1 * this.arc));
//            if (zoom > Human.view.camera.maxZoom) {
//                zoom = Human.view.camera.maxZoom;
//            }
            Human.math.mulVec3Scalar(this._vec, zoom, tempVec);
            Human.math.addVec3(eyeVec, tempVec, eyeVec);
        }

        Human.math.lerpVec3(easedTime, 0, 1, this._look1, this._look2, lookVec);

        if (this.constrainUp) {

            // Interpolating "eye" and "look" but not "up"

            Human.view.camera.setLookAt({
                look: Human.math.vec3ArrayToObj(lookVec),
                eye: Human.math.vec3ArrayToObj(eyeVec)
            });

        } else {

            // Interpolating "eye", "look" and "up"

            var up = Human.math.lerpVec3(easedTime, 0, 1, this._up1, this._up2, []);

            Human.view.camera.setLookAt({
                look: Human.math.vec3ArrayToObj(lookVec),
                eye: Human.math.vec3ArrayToObj(eyeVec),
                up:  Human.math.vec3ArrayToObj(up)
            });
        }
    };

    Human.view.camera.fly.Animation.prototype._easeOut = function (t, b, c, d) {
        var ts = (t /= d) * t;
        var tc = ts * t;
        return b + c * (-1 * ts * ts + 4 * tc + -6 * ts + 4 * t);
    };

    Human.view.camera.fly.Animation.prototype._easeIn = function (t, b, c, d) {
        var ts = (t /= d) * t;
        var tc = ts * t;
        return b + c * (tc * ts);
    };

    Human.view.camera.fly.Animation.prototype.stop = function () {
    };
})();;/**
 * A camera constraint that blocks any updates to the camera that would cause
 * the objects in the 3D scene from being shifted off the canvas.
 *
 * Active while the "camera.constrainSceneToCanvas" property is set "true".
 *
 * Installed into Human.view.camera, this constraint works by tracking the
 * current center of the scene (updated whenever a module is activated or deactivated),
 * then the camera can poll it on every incoming camera update to see if the update
 * would cause that center to fall of the canvas. If so, returns false, which
 * indicates to the camera that it should ignore the update.
 */
(function () {
    "use strict";

    var viewMat = Human.math.mat4();
    var viewCenter = Human.math.vec4();
    var projCenter = Human.math.vec4();

    // Holds the center point, but potentially could hold a group of points.
    // Just the center for now and we'll see how well that works.
    var points = [
        [0, 0, 0]
    ];

    var canvas;

    Human.events.on("loaded",
        function () {
            canvas = document.getElementById(Human.CANVAS_ID);
        });

    // Property activates or deactivates this constraint
    Human.properties.subscribe({
        propId: "camera.constrainSceneToCanvas",
        value: false,
        callback: function (value) {
            if (value) {
                activate();
            } else {
                deactivate();
            }
        }
    });

    // Activates this constraint
    function activate() {

        // Track scene center point on change
        Human.events.on("modules.activated", saveCenter);
        Human.events.on("modules.deactivated", saveCenter);

        // Install the constraint callback into camera
        Human.view.camera.addConstraint(constrain);
    }

    // Saves center point
    function saveCenter() {
        var b = Human.scene.getBoundary();
        points[0] = [
                b.xmin + ((b.xmax - b.xmin) / 2),
                b.ymin + ((b.ymax - b.ymin) / 2),
                b.zmin + ((b.zmax - b.zmin) / 2)
        ];
    }

    // Runs the constraint
    function constrain(eye, look, up) {

        // Build view matrix
        Human.math.lookAtMat4c(eye.x, eye.y, eye.z, look.x, look.y, look.z, up.x, up.y, up.z, viewMat);

        // Assume projection matrix not changed
        var projMat = Human.renderer.getProjMat();

        // Test points against canvas, return true as soon as one is found inside

        for (var i = 0, len = points.length; i < len; i++) {

            // Transform point to View space
            Human.math.transformPoint3(viewMat, points[i], viewCenter);
            viewCenter[3] = 1; // Need homogeneous 'w' for perspective division

            if (viewCenter[2] > -0.1 || viewCenter[2] < -10000) {
                //      return false;
            }

            // Transform point to Projection space
            Human.math.transformPoint4(projMat, viewCenter, projCenter);

            var x = projCenter[0];
            var y = projCenter[1];
            var w = projCenter[3];

            var canvasX = (1 + x / w) * canvas.width / 2;
            if (canvasX < 0 || canvasX > canvas.width) {

                // Point outside of canvas X extents
                continue;
            }

            var canvasY = (1 - y / w) * canvas.height / 2;
            if (canvasY <  0 || canvasY > canvas.height) {

                // Point outside of canvas Y extents
                continue;
            }

            // Point inside canvas, constraint passes
            return true;
        }

        // No points in canvas, constraint fails
        return false;
    }

    // Deactivates this constraint
    function deactivate () {

        // Remove constraint callback from camera
        Human.view.camera.removeConstraint(constrain);

        // Unsubscribe from module updates
        Human.events.off("modules.activated", saveCenter);
        Human.events.off("modules.deactivated", saveCenter);

    }

})();
;/**
 * @namespace Manages a box-shaped boundary indicator in the 3d view
 */
(function () {
    "use strict";

    var HumanViewBoundary = Human.view.boundary = {};

    var flagsNode;
    var geoNode;
    var ready = false;
    var showing = false;

    Human.events.on(
        "loaded",
        function () {
            flagsNode = Human.renderer.getNode("object-boundary-flags");
            geoNode = Human.renderer.getNode("object-boundary-geo");
            ready = true;
        });

    /**
     * Updates the boundary indicator
     *
     *
     * <pre>
     *     Examples:
     *
     * var boundary = { xmin: -10, ymin: -2, zmin: -123, xmax: 20, ymax: 100, zmax: 23 };
     *
     * setBoundary(boundary)          // Set up new boundary, dont change visibility status
     *
     * boundary = { xmin: -40, ymin: -100, zmin: -33, xmax: 20, ymax: 200, zmax: 450 };
     *
     * setBoundary(boundary, true)    // Set up new boundary, make visible
     *
     * setBoundary(false)             // Keep boundary setup, make invisible
     * setBoundary(true)              // Keep boundary setup, make visible
     * </pre>
     * @memberof Human.view.boundary
     */
    HumanViewBoundary.setBoundary = function () {
        if (!ready) {
            return;
        }
        if (arguments.length === 0) {
            HumanViewBoundary.reset();
            return;
        }
        var boundary;
        var enable;
        if (arguments.length === 1) {
            if (typeof arguments[0] === "boolean") {
                enable = !!arguments[1];
                HumanViewBoundary._showBoundary(enable);
            } else {
                boundary = arguments[0];
                HumanViewBoundary._setBoundaryExtents(boundary);
            }
        } else {
            boundary = arguments[0];
            enable = arguments[1];
            HumanViewBoundary._setBoundaryExtents(boundary);
            HumanViewBoundary._showBoundary(enable);
        }
    };
    HumanViewBoundary._setBoundaryExtents = function (boundary) {
        flagsNode.setEnabled(showing);
        var xmin = boundary.xmin;
        var ymin = boundary.ymin;
        var zmin = boundary.zmin;
        var xmax = boundary.xmax;
        var ymax = boundary.ymax;
        var zmax = boundary.zmax;
        geoNode.setPositions({
            positions:[
                xmax, ymax, zmax, xmax, ymin, zmax, xmin, ymin, zmax, xmin, ymax, zmax,
                xmax, ymax, zmin, xmax, ymin, zmin, xmin, ymin, zmin, xmin, ymax, zmin
            ]
        });
    };

    HumanViewBoundary._showBoundary = function (doShow) {
        if (showing === doShow) {
            return;
        }
        flagsNode.setEnabled(doShow);
        showing = doShow;
    };

    /** Clears the boundary indicator. Makes it invisible and zero size.
     * @memberof Human.view.boundary
     */
    HumanViewBoundary.reset = function () {
        HumanViewBoundary._setBoundaryExtents({ xmin:0, ymin:0, zmin:0, xmax:0, ymax:0, zmax:0 });
        HumanViewBoundary._showBoundary(false);
    };
})();
;/** @namespace Manages the Tooltips view mode
 */
(function () {
    "use strict";

    var tooltips = Human.view.tooltips = {};

    var enabled = true;
    var tooltipId = null;
    var labelElement;               // Single tooltip element

    var enabledAnatomyLabels = {};  // Currently visible labels from Human.view.labels - don't tooltip

    // Whether or not tooltips are enabled by default
    Human.properties.subscribe({
        propId: "tooltips.enabled",
        value: true,
        callback: function (value) {
            enabled = !!value;
        }
    });

    Human.events.on("loaded",
        function () {
            var containerSelector = "#" + Human.CONTAINER_ID;
            $(containerSelector).append("<div id=\"objectToolTip\" style=\"display: none;\" class=\"objectTooltip\">XXXX</div>");
            labelElement = $("#objectToolTip");
            tooltips._hide();
        });

    // Destroy tooltip when object destroyed
    Human.events.on("scene.objectDestroyed", // Destroy label when object destroyed
        function (params) {
            if (labelElement && tooltipId) {
                if (params.objectId === tooltipId) {
                    tooltips._hide();
                }
            }
        });

    // Destroy tooltip when object disabled
    Human.events.on("scene.objectsShown",
        function (params) {
            if (labelElement && tooltipId) {
                if (params.enabledObjectsUpdate[tooltipId] === false) {      // Newly enabled/disabled objects
                    tooltips._hide();
                }
            }
        });

    // Track the currently labelled anatomy objects so we don't tooltip them
    Human.events.on("labels.updated", // Don't tooltip over labelled object
        function (params) {
            enabledAnatomyLabels = params.enabledLabels;
            if (tooltipId && enabledAnatomyLabels[tooltipId]) {
                tooltips._hide();
            }
        });

    Human.events.on("camera.updated", function () {
        if (labelElement && tooltipId) {
            tooltips._hide();
        }
    });

    tooltips.setTooltip = function (params) {
        var objectId = params.objectId;
        if (objectId) {  // Only tooltip anatomy objects
            if (labelElement) {
                if (enabledAnatomyLabels[objectId] || Human.scene.checkTestStarted) {
                    tooltips._hide();
                } else {
                    tooltips._show(params);
                }
            }
        }
    };

    tooltips.clearTooltip = function () {
        if (labelElement && tooltipId) {
            tooltips._hide();
        }
    };

    /**
     * Show tooltip on object at given canvas coordinates
     */
    tooltips._show = function (params) {
        if (!enabled) {
            return;
        }
        var title;
        if (params.objectId) {
            tooltipId = params.objectId;
            if (enabledAnatomyLabels[tooltipId]) {
                tooltips._hide();
                return;
            }
            var object = Human.scene.objects[params.objectId];
            title = object.name;
        }
        labelElement.css({
            "left": params.canvasX + 10,
            "top": params.canvasY + 0
        });
        labelElement.text(title);
        labelElement.show();
    };

    /**
     * Hide tooltip if shown
     */
    tooltips._hide = function () {
        if (!tooltipId || !labelElement) {
            return;
        }
        labelElement.hide();
        tooltipId = null;
    };

    tooltips.getEnabled = function () {
        return enabled;
    };

    tooltips.setEnabled = function (enable) {
        if (enabled !== enable) {
            if (!enable) {
                tooltips._hide();
            }
            enabled = enable;
        }
        Human.events.fire("tooltips.toggled", {
            enabled: enabled
        });
    };
})();






;(function() {
	"use strict";

	Human.rpc.define("tooltips.setEnabled",
	    function (params) {
	        var enable = params.enable;
	        if (enable === undefined || enable === null) {   // Toggle by default
	            enable = !Human.view.tooltips.getEnabled();
	        }
	        Human.view.tooltips.setEnabled(enable);
	    });
})();
;/**
 * @namespace Manages labels on objects in {@link Human.scene}
 *
 * <p>Observes updates to the currently selected anatomy object set and maintains
 * a set of labels for the currently selected objects.</p>
 *
 */
(function () {
    "use strict";

    var HumanViewLabels = Human.view.labels = {};

    HumanViewLabels.enabled = true;

    var labels = {};
    var numLabels = 0;

    Human.properties.subscribe({
        propId: "labels.enabled",
        value: true,
        callback: function (value) {
            HumanViewLabels.enabled = !!value;
        }
    });

    Human.events.on(
        "loaded",
        function () {
            HumanViewLabels.clearLabels();
        });

    // When a labeled scene object is destroyed, ensure that the label is also destroyed
    Human.events.on(
        "scene.objectDestroyed",
        function (params) {
            if (HumanViewLabels.enabled) {
                if (numLabels > 0) {
                    var objectId = params.objectId;
                    if (labels[objectId]) {
                        HumanViewLabels._destroyLabel(objectId);
                        var enabledLabelsUpdate = {};
                        enabledLabelsUpdate[objectId] = false;
                        Human.events.fire("labels.updated", {
                            enabledLabels:labels
                        });
                    }
                }
            }
        });

    // When a labeled scene object is deselected, ensure that the label is destroyed
    Human.events.on(
        "scene.objectsSelected",
        function (params) {
            if (HumanViewLabels.enabled) {
                if (numLabels > 0) {
                    var objects = params.selectedObjectsUpdate; // Newly selected/deselected objects
                    var anatomyObjects = Human.scene.objects;
                    for (var objectId in objects) {
                        if (objects.hasOwnProperty(objectId)) {
                            if (anatomyObjects[objectId].objects.length === 0) {  // Leaf object
                                if (objects[objectId] === false) {   // Object deselected, destroy label
                                    if (labels[objectId]) {
                                        HumanViewLabels._destroyLabel(objectId);
                                    }
                                }
                            }
                        }
                    }
                    Human.events.fire("labels.updated", {
                        enabledLabels:labels
                    });
                }
            }
        });

    // When a labeled scene object is hidden, ensure that the label is destroyed
    Human.events.on(
        "scene.objectsShown",
        function (params) {
            if (HumanViewLabels.enabled) {
                if (numLabels > 0) {
                    var objects = params.enabledObjectsUpdate;  // Newly enabled/disabled objects
                    for (var objectId in objects) {
                        if (objects.hasOwnProperty(objectId)) {
                            if (objects[objectId] === false) { // Object disabled, destroy label
                                if (labels[objectId]) {
                                    HumanViewLabels._destroyLabel(objectId);
                                }
                            }
                        }
                    }
                    Human.events.fire("labels.updated", {
                        shownLabels:labels
                    });

                }
            }
        });

    HumanViewLabels._destroyLabel = function (objectId) {
        var label = labels[objectId];
        if (label) {
            label.destroy();
            delete labels[objectId];
            numLabels--;
        }
    };

    /**
     * Creates a label on an object in {@link Human.scene}
     * @memberof Human.view.labels
     * @param params
     */
    HumanViewLabels.createLabel = function (params) {
        var objectId = params.objectId;
        var object = Human.scene.objects[objectId];
        if (!object) { // Not likely
            Human.log.warn("Human.view.labels.createLabel", "Scene object not found: '" + objectId + "'");
            return;
        }
        if (params.replace) {
            HumanViewLabels.clearLabels();
        }
        if (!object.displayName) {
            Human.log.warn("Human.view.labels.createLabel", "Scene object has no displayName: '" + objectId + "'");
            return;
        }
        var offset = params.offset || object.getCenter();
        labels[objectId] = new Human.view.labels.Label({
            labelId:objectId,
            text:object.displayName,
            style:null, // Default style
            offset:offset,
            nodeId:objectId,
            objectId:objectId,
            enabled:HumanViewLabels.enabled,
            onHide:function () {
                HumanViewLabels._destroyLabel(objectId);
            }
        });
        Human.events.fire("labels.updated", {
            enabledLabels:labels
        });
        numLabels++;
    };

    /**
     * Clears all labels currently in {@link Human.scene}
     * @memberof Human.view.labels
     */
    HumanViewLabels.clearLabels = function () {
        if (numLabels > 0) {
            HumanViewLabels._clearLabels();
            Human.events.fire("labels.updated", {
                enabledLabels:labels
            });
        }
    };

    HumanViewLabels._clearLabels = function () {
        for (var labelId in labels) {
            if (labels.hasOwnProperty(labelId)) {
                HumanViewLabels._destroyLabel(labelId);
            }
        }
        numLabels = 0;
    };

    /** Enables or disables Label mode
     * <p>Disabling will remove all labels.</p>
     * @memberof Human.view.labels
     * @param {Boolean} enable Enables or disables Label mode
     */
    HumanViewLabels.setEnabled = function (enable) {
        if (HumanViewLabels.enabled === enable) {
            return;
        }
        HumanViewLabels.enabled = enable;
        if (!enable) {
            // Destroy all labels when disabled
            HumanViewLabels._clearLabels();
        }
        Human.events.fire("labels.toggled", {
            enabled:enable
        });
    };

    /** Queries whether or not Label mode is enabled
     * @memberof Human.view.labels
     * @returns true if Label mode enabled else false
     */
    HumanViewLabels.getEnabled = function () {
        return HumanViewLabels.enabled;
    };

})();







;(function () {
    "use strict";

    var container;
    var audio;
    var labels = {};
    var canvasWidth;
    var canvasHeight;

    Human.events.on("loaded",
        function () {
            container = $("#container");
            audio = initAudio();
        });

    function initAudio() {
        var id = "___labelNarration";
        var body = document.getElementsByTagName("body")[0];
        var div = document.createElement('div');
        div.innerHTML += ' <audio id="' + id + '" src=""></audio>';
        body.appendChild(div);
        var audio = document.getElementById(id);
        if (!audio) {
            Human.log.error("Scene.view.labels",  "Label audio init failed: Failed to create audio element in DOM");
            return null;
        }
        if (audio.canPlayType('audio/ogg;codecs="vorbis"') !== "probably") {
            Human.log.error("Scene.view.labels",  "Label audio init failed: Codec not supported");
            return null;
        }
        return audio;
    }

    Human.events.on("loaded",
        function () {
            Human.renderer.getNode(Human.renderer.NULL_OBJECT_ID).on("rendered",
                function (event) {
                    for (var labelId in labels) {
                        if (labels.hasOwnProperty(labelId)) {
                            labels[labelId]._onRender(event);
                        }
                    }
                });
        });

    Human.events.on("canvas.resized",
        function (params) {
            canvasWidth = params.canvasWidth;
            canvasHeight = params.canvasHeight;
        });

    /**
     * A label within {@link Human.view.labels}.
     * @param cfg
     * @constructor
     * @private
     */
    Human.view.labels.Label = function (cfg) {

        this.nodeId = cfg.nodeId;               // Always have nodeId
        this.objectId = cfg.objectId;
        this.animationId = cfg.animationId;
        this.offset = cfg.offset;               // Optional
        this.shown = cfg.shown;
        this.enabled = cfg.enabled;
        this.audioText = cfg.text;

        if (this.audioText) {
            this.audioText = this.audioText.toLowerCase().replace(/\s/g, '_');
        }

        this._style = cfg.style || "labelStyleDefault";

        if (cfg.labelId) {
            this.labelId = cfg.labelId;
        } else if (this.animationId) {  // Animation label
            this.labelId = "a." + this.objectId;
        } else if (this.objectId) { // Object label
            this.labelId = "o." + this.objectId;
        } else {
            this.labelId = "n." + this.nodeId;
        }

        /* add class (right, left, bottom or top) according to where the label arrow should appear
          relative to the elemtn */
        this._labelElement = jQuery([
            '<div id="',
            this.labelId,
            '" class="label-container right hidden">',
            '<div class="label-container-header ',
            this.style,
            '">',
            '<span>',
            cfg.text,
            '</span>',
            '<img src="img/shim.gif" alt="Play" class="icon-speaker icon-inverse" />',
            '<img src="img/shim.gif" alt="Close" class="icon-close icon-inverse" />',
            '<div class="label-toggle-secondary icon-expand"></div>',
            '<ul class="options"></ul>',
            '</div>',
            '</div>'
        ].join(""));

        container.append(this._labelElement);

        this._elementWidth = this._labelElement.width();
        this._elementHeight = this._labelElement.height();

        var self = this;

        this._onRender = function (event) {
            self.updatePos({
                canvasPos:event.getCanvasPos(self.offset)
            });
        };

        labels[this.labelId] = this;

        var $closeBtn = this._labelElement.find(".icon-close");
        $closeBtn.click(function () {
            cfg.onHide();
        });

        // build options
        var $labelOptions = this._labelElement.find(".options");
        var $optionsToggle = this._labelElement.find(".label-toggle-secondary");
        $labelOptions.hide();        
        $optionsToggle.hide();
        var annotations = Human.view.annotations.getAnnotations({ objectId: this.objectId, type: "secondary" });
        var hasSecondary = Object.keys(annotations).length > 0;
        // toggle label option
        if (hasSecondary) {
            var annotationsShownCount = 0;
            var setAnnotationToggle = function (shown) {
                if (shown) {
                    $optionShowPins.text("Hide Pins");
                }
                else {
                    $optionShowPins.text("Show Pins");
                }
            };
            var setAnnotationShown = function (shown) {
                if (shown === true) {
                    annotationsShownCount++;
                }
                else if (annotationsShownCount > 0) {
                    annotationsShownCount--;
                }
                setAnnotationToggle(annotationsShownCount !== 0);
            };
            var annotationChecked = false;
            var initAnnotationCheck = function () {
                if (annotationChecked === true) {
                    return;
                }
                annotationsShownCount = 0;
                for (var id in annotations) {
                    if (annotations.hasOwnProperty(id)) {
                        var annotation = annotations[id];
                        annotation.label.on("shown", setAnnotationShown);
                        if (annotation.label.shown === true) {
                            annotationsShownCount++;
                        }
                    }
                }
                setAnnotationToggle(annotationsShownCount !== 0);
            };
            
            var $optionShowPins = $("<li />");            
            $optionShowPins.click(function () {
                var shown = annotationsShownCount !== 0;
                var objects = {};
                objects[self.objectId] = !shown;
                // set annotations
                Human.view.annotations.setLabelsShown({
                    objects: objects,
                    type: "secondary",
                    replace: true
                });
            });
            // lazy loaded check
            $optionsToggle.click(function () {
                if (annotationChecked !== true) {
                    initAnnotationCheck();
                    annotationChecked = true;
                }
            });
            $labelOptions.append($optionShowPins);
        }
        // label options available
        if ($labelOptions.children().length > 0) {
            // remove main close btn
            $closeBtn.hide();
            // add close btn option
            var $hideBtn = $("<li />");
            $hideBtn.text("Hide Label");
            $hideBtn.click(function () {
                cfg.onHide();
            });
            $labelOptions.append($hideBtn);
            // setup options toggle
            $optionsToggle.click(function () {
                if ($labelOptions.is(":visible")) {
                    $labelOptions.hide();
                    $optionsToggle.attr("class", "icon-expand");
                }
                else {
                    $labelOptions.show();
                    $optionsToggle.attr("class", "icon-collapse");
                }
            });
            $optionsToggle.show();
        }
        var speakerButton = this._labelElement.find(".icon-speaker");
        speakerButton.hide();

        if (this.objectId) { // Speaking for objects only
            if (audio) {
                // var src = "content/sounds/labels/" + self.objectId + ".ogg";
                var src = "content/sounds/labels/" + self.audioText + ".ogg";
                Human.utils.fileExists.test(src,
                    function (exists) {
                        if (exists) {
                            speakerButton.click(
                                function () {
                                    audio.setAttribute("src", src);
                                    if (!audio.currentTime) {
                                        audio.play();
                                    } else {
                                        // Workaround Firefox not being able to reliably determine audio.duration
                                        // because media data seems unavailable. This is a better method anyway.
                                        if (audio.ended) {
                                            // Workaround Chrome bug(?).
                                            // Chrome will not repeat playback unless the src is destroyed and reset.
                                            audio.pause();
                                            audio.src = '';
                                            audio.setAttribute("src", src);
                                            audio.play();
                                        }
                                    }
                                });
                            self._hasAudioFile = true;
                            speakerButton.show();
                        }
                    });
            }
        }
    };

    Human.view.labels.Label.prototype.updatePos = function (params) {
        var x = params.canvasPos.x;
        var y = params.canvasPos.y;
        if (x <= 0 || y <= 0 || x > canvasWidth - this._elementWidth || y > canvasHeight - this._elementHeight) {
            if (this.shown) {
                this.setShown(false);
            }
        } else {
            this._labelElement.css({
                "left":x,
                "top":y + 40
            });
            if (!this.shown) {
                this.setShown(true);
            }
        }
    };

    Human.view.labels.Label.prototype.update = function (params) {
        var x = params.canvasPos.x;
        var y = params.canvasPos.y;
        if (y <= 0) {                    // Just clip to top - overlap with menus is only issue, other borders OK
            if (this.shown) {
                this.setShown(false);
            }
        } else {
            this._labelElement.css({
                "left":x,
                "top":y + 40
            });
            if (params.style) {
                if (this._style) {
                    this._labelElement.removeClass(this._style);
                }
                this._labelElement.addClass(params.style);
                this._style = params.style;
            }
            if (!this.shown) {
                this.setShown(true);
            }
        }
    };

    Human.view.labels.Label.prototype.setShown = function (doShow) {
        if (this.shown === doShow) {
            return;
        }
        if (doShow && this.enabled) {
            this._labelElement.show();
        } else {
            this._labelElement.hide();
        }
        this.shown = doShow;
    };

    Human.view.labels.Label.prototype.setEnabled = function (enable) {
        if (this.enabled !== enable) {
            if (this.shown && enable) {
                this._labelElement.show();
            } else {
                this._labelElement.hide();
            }
            this.enabled = enable;
        }
    };

    Human.view.labels.Label.prototype.destroy = function () {
        delete labels[this.labelId];
        if (audio && this._hasAudioFile) {
            audio.pause();
            audio.src = '';
        }
        if (this.shown) {
            this.setShown(false);
        }
        if (this._labelElement) {
            this._labelElement.remove();
            this._labelElement = null;
        }
    };

})();;(function() {
    "use strict";

    Human.rpc.define("labels.setEnabled",
        function (params) {
            var enable = params.enable;
            if (enable === undefined || enable === null) {                    // Toggle by default
                enable = !Human.view.labels.getEnabled();
            }
            Human.view.labels.setEnabled(enable);
        });

    Human.rpc.define("labels.create",
        function (params) {
            if (!params.objectId) {
                this.error("parameter expected: 'objectId'");
                return;
            }
            if (params.replace) {
                Human.view.labels.clearLabels();
            }
            Human.view.labels.createLabel(params);
        });

    Human.rpc.define("labels.clear",
        function () {
            Human.view.labels.clearLabels();
        });

})();
;/**
 * @namespace Manages Highlight mode
 */
(function () {
    "use strict";

    var HumanViewHighlight = Human.view.highlight = {};

    HumanViewHighlight.enabled = true;
    var dirty = false;

    Human.events.on(
        "loaded",
        function () {
            HumanViewHighlight.setEnabled(true); // Notifies of initial state
        });

    Human.events.on(
        "scene.objectsSelected", // Track the set of currently selected objects
        function () {
            if (HumanViewHighlight.enabled) {
                dirty = true;
            }
        });

    Human.events.on(
        "tick", // Lazy-highlight when flagged for next render frame
        function () {
            if (dirty) {
                highlight(HumanViewHighlight.enabled);
                dirty = false;
            }
        });

    function highlight(doHighlight) {
        var object, objectId;
        if (!doHighlight) {
            for (objectId in Human.scene.objects) { // De-highlight an highlighted objects
                if (Human.scene.objects.hasOwnProperty(objectId)) {
                    object = Human.scene.objects[objectId];
                    if (object.highlight) {
                        object.setHighlight(false);
                    }
                }
            }
        } else {
            for (objectId in Human.scene.objects) { // Highlight only selected objects
                if (Human.scene.objects.hasOwnProperty(objectId)) {
                    object = Human.scene.objects[objectId];
                    if (object) {
                        if (Human.scene.selectedObjects.hasOwnProperty(objectId)) {
                            if (!object.highlight) {
                                object.setHighlight(true);
                            }
                        } else {
                            if (object.highlight) {
                                object.setHighlight(false);
                            }
                        }
                    }
                }
            }
        }
    }

    HumanViewHighlight.setEnabled = function (enable) {
        if (HumanViewHighlight.enabled !== enable) {
            HumanViewHighlight.enabled = enable;
            dirty = true;
        }
        Human.events.fire("highlight.toggled", { enabled: HumanViewHighlight.enabled });
        if (HumanViewHighlight.enabled) {
            Human.view.currentMode = 'Highlight';
        }
    };

    HumanViewHighlight.getEnabled = function () {
        return HumanViewHighlight.enabled;
    };

})();
;/**
 * @namespace manages Isolation mode
 */
(function () {
    "use strict";

    var HumanViewIsolate = Human.view.isolate = {}; 

    HumanViewIsolate.enabled = false;
    var dirty = true;

    Human.events.on(
        "loaded",
        function () {
            HumanViewIsolate.enabled = false;
            dirty = false;
        });

    Human.events.on(
        "tick",
        function () {
            if (dirty) {
                // Lazy-isolate when flagged for next render frame
                Human.scene.setShowSelectedObjects(HumanViewIsolate.enabled);
                dirty = false;
            }
        });

    Human.events.on(
        "scene.objectsSelected",
        function () {
            if (HumanViewIsolate.enabled) {
                dirty = true;
            }
        });

    HumanViewIsolate.setEnabled = function (enable) {
        if (HumanViewIsolate.enabled !== enable) {
            HumanViewIsolate.enabled = enable;
            dirty = true;
        }
        Human.events.fire("isolate.toggled", { enabled:HumanViewIsolate.enabled });
        if(HumanViewIsolate.enabled) {
            Human.view.currentMode = 'Isolate';
            // Multi-pick doesn't make sense in Isolate mode
            Human.view.pick.setSinglePickEnabled(true);
            Human.view.pick.setMultiPickEnabled(false);
        }
    };

    HumanViewIsolate.getEnabled = function () {
        return HumanViewIsolate.enabled;
    };

})();;/**
 * @namespace Manages Dissection mode
 *
 * Can undo and redo dissections, forgets history when enable status changes.
 */
(function () {
    "use strict";

    var dissect = Human.view.dissect = {};

    dissect.enabled = false;  // Disable by default
    var undoStack = [];
    var redoStack = [];

    Human.events.on(
        "loaded",
        function () {
            dissect.enabled = false;
        });

    /**
     * Enable/disable dissection and notify
     */
    dissect.setEnabled = function (enable) {
        if (dissect.enabled === enable) {
            return;
        }
        dissect.enabled = enable;
        //redoStack.length = 0;
        //undoStack.length = 0;
        Human.events.fire("dissect.toggled", { enabled:dissect.enabled });
    };

    dissect.getEnabled = function () {
        return dissect.enabled;
    };

    /**
     * Dissect an object
     * Causes the object to be disabled (hidden) within the 3D scene
     * @param objectId
     */
    dissect.dissect = function (objectId) {
        if (!dissect.enabled) {
            return;
        }
        redoStack.length = 0;
        undoStack.push(objectId);
        var objects = {};
        objects[objectId] = false;
        Human.scene.setEnabledObjects({
            objectIds:objects
        });
    };

    /**
     * Undo last dissection
     */
    dissect.undo = function () {
        if (!dissect.enabled) {
            //return;
        }
        if (undoStack.length) {
            var objectId = undoStack.pop();
            var objects = {};
            objects[objectId] = true;
            Human.scene.setEnabledObjects({
                objectIds:objects
            });
            redoStack.unshift(objectId);
        }
    };

    /**
     * Redo last dissection
     */
    dissect.redo = function () {
        if (!dissect.enabled) {
            return;
        }
        var objectId;
        var objects;
        if (redoStack.length) {
            objectId = redoStack.shift();
            objects = {};
            objects[objectId] = false;
            Human.scene.setEnabledObjects({
                objects:objects
            });
            undoStack.push(objectId);
        }
    };

    dissect.reset = function () {
        redoStack.length = 0;
        undoStack.length = 0;
    };
})();
;/**
 * @namespace View mode in which annotations can be pinned to objects in {@link Human.scene}.
 */
(function () {
    "use strict";

    var HumanViewAnnotations = Human.view.annotations = {};

    /**
     * Pool of internally-managed annotation IDs, for annotations that are created without user-supplied IDs.
     * Such annotations are typically created from picking a scene object, while IDs are supplied on annotations
     * that are loaded with bookmarks, conditions etc.
     *
     * @type {Human.utils.IDPool}
     */
    var idPool = new Human.utils.IDPool({
        prefix: "__a"
    });

    /**
     * True when annotation mode is enabled
     * @type {boolean}
     */
    HumanViewAnnotations.enabled = false;

    /**
     * True when annotations are visible
     * @type {boolean}
     */
    HumanViewAnnotations.shown = true;

    /**
     * The annotations
     * @type {{String:Human.view.annotations.Annotation}}
     */
    HumanViewAnnotations.annotations = {};

    /**
     * Annotations on each scene object
     * @type {{String:Human.view.annotations.Annotation}}
     */
    HumanViewAnnotations.objectAnnotations = {};

    // Annotation currently being created, not yet saved
    HumanViewAnnotations.unsavedAnnotation = null;

    // Hide annotations whenever engine is loading things
    (function () {

        var count = 0;

        Human.events.on("processes.started",
            function () {
                if (!count) {
                    HumanViewAnnotations.setShown(false);
                }
                count++;
            });

        Human.events.on("processes.finished",
            function () {
                if (!--count) {
                    HumanViewAnnotations.setShown(true);
                }
            });

        Human.events.on("processes.failed",
            function () {
                if (!--count) {
                    HumanViewAnnotations.setShown(true);
                }
            });
    })();

    /**
     * Enable or disables annotation mode, in which annotations may be created
     * @memberof Human.view.annotations
     * @param {boolean} enable True to enable, false to disable
     */
    HumanViewAnnotations.setEnabled = function (enable) {
        if (HumanViewAnnotations.enabled !== enable) {
            HumanViewAnnotations.enabled = enable;
            Human.events.fire("annotations.toggled", { enabled: enable });
        }
    };

    /**
     * Creates an annotation on an {@link Human.scene.Object} in {@link Human.scene}.
     *
     * @memberof Human.view.annotations
     * @param {*} params
     * @param {String} [params.annotationId] ID to assign to the annotation, generated internally if omitted.
     * @param {String} params.objectId ID of an {@link Human.scene.Object} in {@link Human.scene}.
     * @param {String} [params.type] Type of annotation, "default" by default.
     * @param {Boolean} [params.shown] True to show the annotation initially - default true
     * @param {String} params.title Title for annotation label
     * @param {String} params.description Text for annotation description in label
     * @param {[Number, Number, Number]} params.pos World-space position of annotation pin
     * @param {[Number, Number, Number]} params.dir 3D vector indicating direction the pin is pointing
     * @param {[Number, Number]} [params.labelOffset] @D vector indicating offset of label in canvas-space
     * @returns {Human.view.annotations.Annotation} The new annotation, or null if error occurred, in which case the error is logged
     */
    HumanViewAnnotations.createAnnotation = function (params) {

        var object;

        if (params.objectId) {
            object = Human.scene.objects[params.objectId];
            if (!object) {
                Human.log.warn("Human.view.annotations.createAnnotation", "Scene object not found: '" + params.objectId + "'");
            }
        }

        // If annotation already being created, reuse that one
        if (HumanViewAnnotations.unsavedAnnotation) {
            params.title = HumanViewAnnotations.unsavedAnnotation.label.$titleField.val();
            params.description = HumanViewAnnotations.unsavedAnnotation.label.$descriptionField.val();
            params.objectId = HumanViewAnnotations.unsavedAnnotation.object ? HumanViewAnnotations.unsavedAnnotation.object.objectId : null;

            HumanViewAnnotations.unsavedAnnotation.destroy();
            HumanViewAnnotations.unsavedAnnotation = null;
        }

        if (params.annotationId) {
            if (HumanViewAnnotations.annotations[params.annotationId]) {
                Human.log.error("Human.view.annotations.createAnnotation", "Annotation with this ID already exists: '" + params.annotationId + "'");
                return null;
            }
        } else {
            params.annotationId = idPool.getId();
        }

        var annotation = new Human.view.annotations.Annotation(object, params);

        HumanViewAnnotations.annotations[params.annotationId] = annotation;

        addObjectLookup(annotation);

        HumanViewAnnotations.unsavedAnnotation = params.saved ? null : annotation;

        annotation.setAnnotationsShown(HumanViewAnnotations.shown);

        annotation.on("picked",
            function () {
                Human.events.fire("annotations.picked", {
                    annotationId: annotation.annotationId
                });
            });

        annotation.label.on("mouseClick",
            function () {
                Human.events.fire("annotations.mouseClick", {
                    annotationId: annotation.annotationId
                });
            });

        annotation.label.on("mouseEnter",
            function (params) {
                if (annotation.object) {
                    highlightObject(annotation.object, true);
                }
                Human.events.fire("annotations.mouseEnter", params);
            });

        function highlightObject(object, highlight) {
            object.setHighlight(highlight);
            for (var i = 0, len = object.objects.length; i < len; i++) {
                highlightObject(object.objects[i], highlight);
            }
        }

        annotation.label.on("mouseLeave",
            function (params) {
                if (annotation.object) {
                    highlightObject(annotation.object, false);
                }
                Human.events.fire("annotations.mouseLeave", params);
            });

        annotation.label.on("mouseDown",
            function (params) {
                Human.events.fire("annotations.mouseDown", params);
            });

        annotation.label.on("mouseUp",
            function (params) {
                Human.events.fire("annotations.mouseUp", params);
            });

        annotation.on("saved",
            function () {
                if (HumanViewAnnotations.unsavedAnnotation && HumanViewAnnotations.unsavedAnnotation.annotationId === annotation.annotationId) {
                    notify("annotations.created", annotation);
                } else {
                    notify("annotations.updated", annotation);
                }
                HumanViewAnnotations.unsavedAnnotation = null;
            });

        annotation.on("destroyed",
            function () {
                HumanViewAnnotations.unsavedAnnotation = null;
                delete HumanViewAnnotations.annotations[annotation.annotationId];
                removeObjectLookup(annotation);
                Human.events.fire("annotations.destroyed", {
                    annotationId: annotation.annotationId
                });
            });

        if (params.saved) {
            notify("annotations.created", annotation);
            HumanViewAnnotations.unsavedAnnotation = null;
        } else {
            Human.events.fire("annotations.creating", {
                annotationId: annotation.annotationId
            });
        }

        return annotation;
    };

    function addObjectLookup(annotation) {
        if (annotation.object) {
            var object = annotation.object;
            var objAnnots = HumanViewAnnotations.objectAnnotations[object.objectId];
            if (!objAnnots) {
                objAnnots = HumanViewAnnotations.objectAnnotations[object.objectId] = {
                    annotations: {},
                    numAnnotations: 0
                };
            }
            objAnnots.annotations[annotation.annotationId] = annotation;
            objAnnots.numAnnotations++;
        }
    }

    function removeObjectLookup(annotation) {
        if (annotation.object) {
            var object = annotation.object;
            var objAnnots = HumanViewAnnotations.objectAnnotations[object.objectId];
            if (objAnnots) {
                var a = objAnnots.annotations[annotation.annotationId];
                if (a) {
                    delete objAnnots.annotations[annotation.annotationId];
                    if (--objAnnots.numAnnotations === 0) {
                        delete HumanViewAnnotations.objectAnnotations[object.objectId];
                    }
                }
            }
        }
    }

    function notify(event, annotation) {
        Human.events.fire(event, {
            annotationId: annotation.id || annotation.annotationId,
            type: annotation.type,
            styleId: annotation.styleId,
            objectId: annotation.object ? annotation.object.objectId : null,
            title: annotation.label.title,
            description: annotation.label.description,
            pos: annotation.pin.pos,
            pinVec: annotation.pin.dir
        });
    }

    /**
     * Batch updates dimension properties of all annotation labels
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.updateDimensions = function () {
        for (var annotationId in HumanViewAnnotations.annotations) {
            if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                HumanViewAnnotations.annotations[annotationId].label.updateWidth();
            }
        }
    };

    /**
     * Control display of all annotation labels
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.setShown = function (shown) {
        if (HumanViewAnnotations.shown !== shown) {
            for (var annotationId in HumanViewAnnotations.annotations) {
                if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                    HumanViewAnnotations.annotations[annotationId].setAnnotationsShown(shown);
                }
            }
            HumanViewAnnotations.shown = shown;
            Human.events.fire("annotations.shown", {shown: shown });
        }
    };

    /**
     * Destroys all annotations.
     * @param [options]
     * @param [options.keepModuleAnnotations=false] When true, does not clear annotations that were loaded by modules.
     * @memberof Human.view.annotations
     */
    HumanViewAnnotations.clearAnnotations = function (options) {
        options = options || {};
        var keepModuleAnnotations = !!options.keepModuleAnnotations;
        HumanViewAnnotations.unsavedAnnotation = null;
        var annotation;
        for (var annotationId in HumanViewAnnotations.annotations) {
            if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                annotation = HumanViewAnnotations.annotations[annotationId];
                if (!keepModuleAnnotations || !annotation.moduleId) {
                    annotation.destroy();
                }
            }
        }
    };

    /**
     Queries annotations, with optional restrictions

     <p>Examples:</p>

     <pre>

     // Get a list of annotations for the Bones of the Head
     Human.view.annotations.getAnnotations({
        objectId: "maleAdult-Bones_of_the_Head"
     });

     // Get a list of secondary annotations for the Diaphragm
     Human.view.annotations.getAnnotations({
        objectId: "maleAdult-Diaphragm_13295",
        type: "secondary"
     });

     </pre>

     @param params
     @param [params.objectId] Object ID of the object to restrict annotation search
     @param [params.type] The type of annotation to restrict the search
     @returns {*}
     */
    HumanViewAnnotations.getAnnotations = function (params) {
        var _annotations = {};
        var searchAnnotations = HumanViewAnnotations.annotations;
        // restrict by object id
        if (params.objectId) {
            if (HumanViewAnnotations.objectAnnotations.hasOwnProperty(params.objectId)) {
                searchAnnotations = HumanViewAnnotations.objectAnnotations[params.objectId].annotations;
            }
            else {
                searchAnnotations = {};
            }
        }
        var type = params.type;
        for (var annotationId in searchAnnotations) {
            if (searchAnnotations.hasOwnProperty(annotationId)) {
                var annotation = searchAnnotations[annotationId];
                // restrict by type
                if (!type || type === annotation.type) {
                    _annotations[annotationId] = annotation;
                }
            }
        }
        return _annotations;
    };

    /**
     Convenience method which opens or closes labels on annotations,
     either per their IDs and/or the IDs of their scene objects.

     <p>Examples:</p>

     <pre>

     // Close labels on all annotations on the male frontal bone

     Human.view.annotations.setLabelsShown({
        objects: {
            "maleAdult-Frontal_bone_52734": false
        }
     });

     // Open labels on all annotations on the male frontal bone
     // Close labels on all other annotations

     Human.view.annotations.setLabelsShown({
        objects: {
            "maleAdult-Frontal_bone_52734": true
        },
        replace: true
     });

     // Hide one annotation and show another
     // Close labels on all other annotations

     Human.view.annotations.setLabelsShown({
        annotations: {
            "foo": false,
            "bar": true
        },
        replace: true
     });

     </pre>

     @param params
     @param [params.annotations] Map of annotation IDs to flags
     @param [params.objects] Map of object IDs to flags
     @param [params.replace] True to close labels on all other annotations - default false
     @param [params.type] When object IDs given, open/close only the annotations of this type on those objects
     */
    HumanViewAnnotations.setLabelsShown = function (params) {

        // Annotations we'll open labels for
        var updates = {};

        var type = params.type;
        var annotation, flags;
        var annotationId;
        var open;

        if (params.annotations) {

            // Show hide labels of given annotations
            // optionally filter on type

            flags = params.annotations;
            for (annotationId in flags) {
                if (flags.hasOwnProperty(annotationId)) {
                    annotation = HumanViewAnnotations.annotations[annotationId];
                    if (annotation) {
                        if (!type || type === annotation.type) {
                            updates[annotationId] = flags[annotationId];
                        }
                    }
                }
            }

        } else if (params.objects) {

            // Show/hide labels for annotations on target objects
            // optionally filter on type

            flags = params.objects;
            for (var objectId in flags) {
                if (flags.hasOwnProperty(objectId)) {
                    var object = Human.scene.objects[objectId];
                    if (object) {
                        var objectAnnotations = HumanViewAnnotations.objectAnnotations[objectId];
                        if (objectAnnotations) {
                            open = flags[objectId];
                            for (annotationId in objectAnnotations.annotations) {
                                if (objectAnnotations.annotations.hasOwnProperty(annotationId)) {
                                    annotation = objectAnnotations.annotations[annotationId];
                                    if (!type || type === annotation.type) {
                                        updates[annotationId] = open;
                                    }
                                }
                            }
                        }
                    }
                }
            }

        } else if (params.type) {

            // Show/hide labels of annotations of given type

            open = params.shown !== false;
            for (annotationId in HumanViewAnnotations.annotations) {
                if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                    annotation = HumanViewAnnotations.annotations[annotationId];
                    if (annotation) {
                        if (!type || type === annotation.type) {
                            updates[annotationId] = open;
                        }
                    }
                }
            }
        }

        if (params.replace) {

            // Close all other annotations

            for (annotationId in HumanViewAnnotations.annotations) {
                if (HumanViewAnnotations.annotations.hasOwnProperty(annotationId)) {
                    if (!updates[annotationId]) {
                        annotation = HumanViewAnnotations.annotations[annotationId];

                        // When closing or opening annotations of a given type on an object,
                        // ensure that we don't change the state of other annotations not matching the given type.

                        if (!type || type === annotation.type) {
                            annotation.pin.setShown(false);
                            annotation.label.setShown(false);
                        }
                    }
                }
            }
        }

        // Open the labels for the annotations we specified
        for (annotationId in updates) {
            if (updates.hasOwnProperty(annotationId)) {
                var shown = updates[annotationId];
                annotation = HumanViewAnnotations.annotations[annotationId];
                annotation.pin.setShown(shown);
                annotation.label.setShown(shown);
            }
        }
    };

    /**
     * Batch update of an annotation's state, fires an "annotations.updated".
     * This is intended for use by the API via RPC.
     * @param annotationId
     * @param params
     */
    HumanViewAnnotations.updateAnnotation = function (annotationId, params) {
        var annotation = HumanViewAnnotations.annotations[annotationId];
        if (annotation) {
            var label = annotation.label;
            if (params.title && params.title !== label.title) {
                label.setTitle(params.title);
            }
            if (params.description && params.description !== label.description) {
                label.setDescription(params.description);
            }
            // TODO: Other state updates as we need them for the API...
            notify("annotations.updated", annotation);
        }
    };

})();







;(function() {
    "use strict";

    /**
     * @class An annotation within {@link Human.view.annotations}
     * @param [object]
     * @param cfg
     * @constructor
     */
    Human.view.annotations.Annotation = function (object, cfg) {

        var self = this;

        // Call parent class Human.Component init
        this._init();

        /** Module that loaded this annotation, if loaded by a module
         * @type {string}
         */
        this.moduleId = cfg.moduleId;

        /** Type of this annotation.
         *
         * @type {string}
         */
        this.type = cfg.type || "default";

        /** ID of this annotation, unique within {@link Human.view.annotations}
         * @type {String}
         */
        this.annotationId = cfg.annotationId;

        /**
         * Whether or not annotations are globally enabled
         * @type {boolean}
         */
        this.annotationsShown = Human.view.annotations.shown;

        /**
         * True when this annotation was configured with a 'labelOffset'.
         */
        this.draggable = !!cfg.labelOffset;

        /* DOM order should be Label, Wire, Pin for CSS */
        
        /** The label for this annotation
         * @type {Human.view.annotations.Label}
         */
        this.label = new Human.view.annotations.Label(this, {
            enabled: cfg.enabled,
            shown: cfg.labelShown,
            title: cfg.title,
            description: cfg.description,
            saved: cfg.saved,
            isOwner: cfg.isOwner,
            embed: cfg.embed,
            offset: cfg.labelOffset
        });
        
        /** The wire for this annotation
        */
        this.wire = $('<div class="annotationWire"></div>').appendTo('#container');

        /** The pin for this annotation
         * @type {Human.view.annotations.Pin}
         */
        this.pin = new Human.view.annotations.Pin(this, cfg.annotationId, {
            enabled: cfg.enabled,
            shown: cfg.shown,
            pos: cfg.pos,
            dir: cfg.dir
        });

        /** True when this annotation is saved
         * @type {boolean}
         */
        this.saved = (cfg.saved !== undefined && cfg.saved !== null) ? cfg.saved : false;

        // Toggle label visibility when pin picked
        this.pin.on("picked",
            function () {
                if (!self.label.saved) {
                    alert("Please save or cancel annotation before hiding label");
                    return;
                }
                self.label.setShown(!self.label.shown);
                self.publish("picked", true, true);
            });

        // Toggle label visibility when pin picked
        this.label.on("saved",
            function () {
                self.publish("saved", self.saved = true);
            });

        // Toggle label visibility when pin picked
        this.label.on("delete",
            function () {
                self.destroy();
            });
        
        var _showWire = function (show) {
            if (show) {
                self.wire.show();
            } else {
                self.wire.hide();
            }
        };
        
        // These events influence whether to show or hide the wire

        // These events influence whether to show or hide the wire
        this.pin.on("enabled", function (enabled) {
            _showWire(
                    self.annotationsShown &&
                    enabled &&
                    !self.label.culled &&
                    self.label.shown &&
                    self.pin.shown);
        });

        this.label.on("shown", function (shown) {
            _showWire(
                    self.annotationsShown && // All annotations visible
                    self.pin.enabled &&  // ie. Object visible
                    !self.label.culled && // Pin inside view
                    shown &&
                    self.pin.shown); // Pin shown
        });

        this.label.on("culled", function (culled) {
            _showWire(
                    self.annotationsShown &&
                    self.pin.enabled &&
                    !culled &&
                    self.label.shown &&
                    self.pin.shown);
        });

        this.label.on("annotationsShown", function () {
            _showWire(
                    self.annotationsShown &&
                    self.pin.enabled &&
                    !self.label.culled &&
                    self.label.shown &&
                    self.pin.shown);
        });

        //TODO: write code for occlusion
        this.pin.on("occluded", function (occluded) {
            //ensure no opacity when occluded
            //not setting show / hide for simplicity
            if(occluded) {
                self.wire.css('opacity', '0');
            }
        });
        
        /** The scene object this annotation is attached to
         * @type {Human.scene.Object}
         */
        this.object = null;

        if (object) {
            this.setObject(object);
            if (!cfg.pos) {
                // No pin position was given, so position pin at center of object
                this.pin.setPos(object.getCenter());
            }
        }

        // Behaviours
        if (cfg.on) {
            var on = cfg.on;
            if (on.mouseClick) {
                this.label.on("mouseClick",
                    function () {
                        Human.rpc.call(null, on.mouseClick.call, on.mouseClick);
                    });
            }
        }
    };

    Human.utils.extend(Human.view.annotations.Annotation, Human.Component);


    /**
     * Reassigns annotation to an object
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.setObject = function (object) {

        if (this._objectShown) {
            this.object.off(this._objectShown);
        }
        var self = this;
        // Show/hide annotation in synch with its object
        this._objectShown = object.on("shown",
            function (shown) {
                self.pin.setEnabled(shown);
                self.label.setEnabled(shown);
            });
        // Nuke annotation when its object is destroyed
        this._objectDestroyed = object.on("destroyed",
            function () {
                self.destroy();
            });
        this.publish("object", this.object = object);
    };


    /**
     * Notifies this annotation on change to global toggle of annotation visibilities
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.setAnnotationsShown = function (annotationsShown) {
        this.annotationsShown = annotationsShown;
        this.pin.setAnnotationsShown(annotationsShown);
        this.label.setAnnotationsShown(annotationsShown);
    };

    /**
     * Control display of this annotation
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.setShown = function (shown) {
        this.pin.setShown(shown);
        this.label.setShown(shown);
    };

    /**
     * Destroys this annotation
     * @memberof Human.view.annotations.Annotation
     */
    Human.view.annotations.Annotation.prototype.destroy = function () {
        this.pin.destroy();
        this.label.destroy();
        this.wire.remove();
        
        if (this._objectShown) {
            this.object.off(this._objectShown);
        }
        if (this._objectDestroyed) {
            this.object.off(this._objectDestroyed);
        }
        this.publish("destroyed", true);
    };
})();

;(function() {
    "use strict";


    /**
     * @class A pin belonging to an {@link Human.view.Annotation}
     * @param cfg
     * @constructor
     */
    Human.view.annotations.Pin = function (annotation, id, cfg) {

        var containerSelector = $("#container");

        // Call parent class Human.Component init
        this._init();

        this._id = id;

        /** The {@link Human.view.Annotation} to which this pin belongs
         * @type {Human.view.Annotation}
         */
        this.annotation = annotation;

        /**
         * Whether or not annotations are globally enabled
         * @type {boolean}
         */
        this.annotationsShown = Human.view.annotations.shown;

        /**
         * Whether or not this pin is enabled
         * @type {boolean}
         */
        this.enabled = cfg.enabled !== false;

        /**
         * Whether or not this pin is shown
         * @type {boolean}
         */
        this.shown = cfg.shown !== false;

        /**
         * Whether or not this pin is culled
         * @type {boolean}
         */
        this.culled = false;

        /**
         * World-space position at which this pin is attached to its object
         * @type {[Number, Number, Number]}
         */
        this.pos = cfg.pos || Human.math.vec3();
        
        this.worldPos = this.pos;
        
        this.viewPos = Human.math.vec4();

        /**
         * Whether or not this pin is occluded
         * @type {boolean}
         */
        this.occluded = false;

        /**
         * Direction this pin points
         * @type {[Number, Number, Number]}
         */
        this.dir = cfg.dir || [0, 0, -1];

        this._element = $('<div class="annotationPin"></div>');

        this.setPos(cfg.pos || [0, 0, 0]);
        this.setDir(cfg.dir || [0, 0, 0]);

        this.setAnnotationsShown(Human.view.annotations.shown);
        this.setEnabled((cfg.enabled !== undefined && cfg.enabled !== null) ? cfg.enabled : true);
        this.setShown((cfg.shown !== undefined && cfg.shown !== null) ? cfg.shown : true);
        this.setCulled(!!cfg.culled);
        this.setOpacity(1.0);

        containerSelector.append(this._element);

        this._element.click(this.pick.bind(this));
    };

    Human.utils.extend(Human.view.annotations.Pin, Human.Component);

    /**
     * Notifies this pin of change to global enable of annotation visibilities
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} annotationsShown True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setAnnotationsShown = function (annotationsShown) {
        this._showElement(annotationsShown && this.enabled && this.shown && !this.culled && !this.occluded);
        this.publish("enabled", this.annotationsShown = annotationsShown);
    };

    /**
     * Sets whether or not this pin is enabled
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} enabled True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setEnabled = function (enabled) {
        this._showElement(this.annotationsShown && enabled && this.shown && !this.culled && !this.occluded);
        this.publish("enabled", this.enabled = enabled);
    };

    /**
     * Sets whether or not this pin is shown
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} shown True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setShown = function (shown) {
        this._showElement(this.annotationsShown && this.enabled && shown && !this.culled && !this.occluded);
        this.publish("shown", this.shown = shown);
    };

    Human.view.annotations.Pin.prototype._showElement = function (shown) {
        if (shown) {
            this._element.show();
        } else {
            this._element.hide();
        }
    };

    /**
     * Culls this pin to given rectangle extents - pin is culled if it falls outside
     * @param {Number} xmin
     * @param {Number} ymin
     * @param {Number} xmax
     * @param {Number} ymax
     */
    Human.view.annotations.Pin.prototype.cullToRectangle = function (xmin, ymin, xmax, ymax) {
        var canvasPos = this.canvasPos;
        if (!canvasPos) {
            return;
        }
        this.setCulled(canvasPos[0] < xmin || canvasPos[0] > xmax || canvasPos[1] < ymin || canvasPos[1] > ymax);
        return this.culled;
    };

    /**
     * Sets whether or not this pin is culled
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} culled True to show, false to hide
     */
    Human.view.annotations.Pin.prototype.setCulled = function (culled) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !culled && !this.occluded);
        this.publish("culled", this.culled = culled);
    };

    /**
     * Transforms pin to View and Canvas space.
     */

    var projPos = Human.math.vec4();

    Human.view.annotations.Pin.prototype.transform = function (viewMat, projMat, canvas) {
        Human.math.transformPoint3(viewMat, this.worldPos, this.viewPos);
        this.viewPos[3] = 1; // Need homogeneous 'w' for perspective division
        Human.math.transformPoint4(projMat, this.viewPos, projPos);
        var x = projPos[0];
        var y = projPos[1];
        var w = projPos[3];
        this.canvasPos = [(1 + x / w) * canvas.width / 2, (1 - y / w) * canvas.height / 2];
        this._element.css({ "left": this.canvasPos[0], "top": this.canvasPos[1] });
    };

    /**
     * Sets whether or not this pin is occluded
     * @memberof Human.view.annotations.Pin
     * @param {Boolean} occluded True if occluded
     */
    Human.view.annotations.Pin.prototype.setOccluded = function (occluded) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !this.culled && !occluded);
        this.publish("occluded", this.occluded = occluded);
    };

    /**
     * Sets the pin's angle between it's "direction" and the direction towards the eye
     * @memberof Human.view.annotations.Pin
     * @param {number} viewAngle The angle in degrees
     */
    Human.view.annotations.Pin.prototype.setViewAngle = function (viewAngle) {
        this.publish("angle", this.viewAngle = viewAngle);
    };

    /**
     * Sets the pin's angle between direction and
     * @memberof Human.view.annotations.Pin
     * @param {number} opacity Opacity factor in range [0..1]
     */
    Human.view.annotations.Pin.prototype.setOpacity = function (opacity) {
        this._element.css({ "opacity": this.opacity = opacity });
        this.publish("opacity", opacity);
    };

    /**
     * Sets pin position in World-space coordinates
     * @memberof Human.view.annotations.Pin
     * @param {[Number, Number, Number]} pos World-space position
     */
    Human.view.annotations.Pin.prototype.setPos = function (pos) {
        this.publish("pos", this.pos = pos);
    };

    /**
     * Sets pin direction
     * @memberof Human.view.annotations.Pin
     * @param {[Number, Number, Number]} dir Pin direction vector
     */
    Human.view.annotations.Pin.prototype.setDir = function (dir) {
        this.publish("dir", this.dir = dir);
    };

    /**
     * Notifies this pin that it has been picked
     * @memberof Human.view.annotations.Pin
     * @private
     */
    Human.view.annotations.Pin.prototype.pick = function () {
        this.publish("picked", true, true);
    };

    /**
     * Destroys this pin
     * @memberof Human.view.annotations.Pin
     * @private
     */
    Human.view.annotations.Pin.prototype.destroy = function () {
        Human.renderer.getNode(Human.NULL_OBJECT_ID).off(this._rendered);
        this._element.remove();
        this.publish("destroyed", true);
    };
})();
;(function (Human, $) {
    "use strict";

    /**
     * @class A label belonging to a {@link Human.view.Pin}
     * @param {Human.view.annotations.Annotation} annotation Owner annotation
     * @param {{}} cfg Configs
     * @constructor
     */
    var Label = Human.view.annotations.Label = function (annotation, cfg) {
        this._init(); // Call parent class Human.Component init

        this.annotation = annotation;
        this.saved      = !!cfg.saved;

        this.offset     = cfg.offset || [70, 70];

        var editable = (!cfg.saved || (cfg.saved && cfg.isOwner));

        var editing = this.editing = editable && !this.saved;

        var initialClass  = this.saved ? '' : 'new';
        var editableClass = editable ? 'editable' : '';
        var editingClass  = editing ? 'editing' : '';
        var initialClasses = [initialClass, editableClass, editingClass].join(' ');

        var $container = $('#container');

        this.$element = $([
            '<div class="annotationContainer">',
            '<div class="annotationTitle clearfix">', //holds title elements
            '<input type="text" placeholder="Title">',
            '<h1></h1>',
            '<button class="annotationDelete"></button>',
            '</div>',
            '<div class="annotationDescription">', //holds descriptions elements
            '<textarea placeholder="Description"></textarea>',
            '<p></p>',
            '</div>',
            // '<div class="annotationButtons clearfix">', //holds state buttons
//             '<button class="annotationCancel">Cancel</button>',
//             '<div class="clearfix">',
//               '<button class="annotationSave" title="Save"></button>',
//               '<button class="annotationClose" title="Hide"></button>',
//               '<button class="annotationDelete" title="Delete"></button>',
//             '</div>',
//           '</div>',
            '<div class="embedContainer"></div>',
            '</div>'
        ].join(''));

        //Select annotation components
        this.$titleContainer   = this.$element.find('.annotationTitle');
        this.$title            = this.$element.find('h1');
        this.$description      = this.$element.find('p');
        this.$titleField       = this.$element.find('input');
        this.$descriptionField = this.$element.find('textarea');

        _initFieldMaxLength(this.$titleField, 100);
        _initFieldMaxLength(this.$descriptionField, 300); //set length constraints

        this.setTitle(cfg.title || '');
        this.setDescription(cfg.description || ''); //set initial values

        //set initial classes and add to DOM
        this.$element.addClass(initialClasses).appendTo($container);

        this.bindHandlers(editable);

        //Set these states after this.$element is defined
        this.setAnnotationsShown(Human.view.annotations.shown);
        this.setEnabled(cfg.enabled !== false);
        this.setShown(cfg.shown !== false);
        this.setCulled(!!cfg.culled);
        this.setOccluded(!!cfg.occluded);

        if(cfg.embed) {
            this.setEmbed(cfg.embed); //support for nested widget
        }

        this.setOffset(cfg.offset || [70,-70]);

        this.updateWidth();
    };

    Human.utils.extend(Human.view.annotations.Label, Human.Component);

    Label.prototype.bindHandlers = function (editable) {
        var self      = this,
            $document = $(document);

        var globalSet = function (e) {
            //listen for a click outside the container to cancel editing
            var $target = $(e.target);
            var outsideClick = $target.closest('.annotationContainer').length === 0;

            if(outsideClick) {
                if(self.$titleField.val() || self.$descriptionField.val()) {
                    self.save();
                } else { //delete empty annotation
                    self.$element.find('.annotationDelete').trigger('click');
                }

                $document.off('click.set-annotation'); //turn it off
            }
        };

        if(editable && this.editing) {
            //allow setting of newly created annotation on a global click
            $document.on('click.set-annotation', function (e) {
                globalSet(e);
            });
        }

        //Bind mouse events on label and buttons
        this.$element.click(function () {

            if (editable && !self.editing) {

                self.editing = true;

                //give textarea same height as current description
                self.$descriptionField.height(self.$description[0].offsetHeight);

                self.$element.addClass('editing');

                self.publish("edit", true, true);
                self.publish('updateWidth', true, true);

                $document.on('click.set-annotation', function (e) {
                    globalSet(e);
                });
            }

            // API still wants this event
            self.publish("mouseClick", true, true);
        });

        this.$descriptionField.blur(this.save.bind(this));

        this.$element.find(".annotationDelete").click(function (e) {
            e.preventDefault();

            self.publish("delete", true, true);
        });

        // this.$element.find(".annotationCancel").click(function (e) {
//       if(!self.saved) return;
//       editing = false;
//
//       self.setTitle(self.title); //revert to current title / description
//       self.setDescription(self.description);
//
//       self.$element.removeClass('editing');
//
//       self.publish('cancel', true, true);
//       self.publish('updateWidth', true, true);
//     });

        // this.$element.find(".annotationClose").click(function (e) {
//       if(!self.saved) return;
//
//       self.setShown(false);
//
//       if (self.shown) {
//           self.shown = false;
//           self.$element.hide();
//       }
//
//       self.publish("close", true, true);
//     });

        //Bind simple publishing to Label object
        this.$element.mouseenter(function () {
            self.publish("mouseEnter", {
                annotationId: self.annotation.annotationId
            }, true);
        });

        this.$element.mouseleave(function () {
            self.publish("mouseLeave", {
                annotationId: self.annotation.annotationId
            }, true);
        });

        this.$element.mousedown(function (e) {
            self.publish("mouseDown", {
                annotationId: self.annotation.annotationId,
                x: e.clientX,
                y: e.clientY
            }, true);
        });

        this.$element.mouseup(function () {
            self.publish("mouseUp", {
                annotationId: self.annotation.annotationId
            }, true);
        });

        //On any human event that changes the Label object's width, update layout
        this.on('updateWidth', this._redrawWireConnection.bind(this));
    };

    Label.prototype.save = function () {
        this.editing = false;

        this.setTitle(this.$titleField.val());
        this.setDescription(this.$descriptionField.val());

        this.$element.removeClass('new editing');

        this.publish("saved", this.saved = true);
        this.publish('updateWidth', true, true);
    };

    /**
     * Sets the 2D canvas offset of the label from the pin. default value is [0,0].
     * @memberof Human.view.annotations.Label
     * @param {Array of Number} [offset=[0,0]] Canvas-space 2D offset
     */
    Label.prototype.setOffset = function (offset) {
        this.publish("offset", this.offset = offset || [70, 70]);
    };

    /**
     * Notifies this label on change to global toggle of annotation visibilities
     * @memberof Human.view.annotations.Label
     * @param {Boolean} annotationsShown True to show, false to hide
     */
    Label.prototype.setAnnotationsShown = function (annotationsShown) {
        this._showElement(annotationsShown && this.enabled && this.shown && !this.culled && !this.occluded);
        this.publish("annotationsShown", this.annotationsShown = annotationsShown);
    };

    /**
     * Sets whether or not this label is enabled
     * @memberof Human.view.annotations.Label
     * @param {Boolean} enabled True to show, false to hide
     */
    Label.prototype.setEnabled = function (enabled) {
        this._showElement(this.annotationsShown && enabled && this.shown && !this.culled && !this.occluded);
        this.publish("enabled", this.enabled = enabled);
    };

    /**
     * Sets whether or not this label is shown
     * @memberof Human.view.annotations.Label
     * @param {Boolean} shown True to show, false to hide
     */
    Label.prototype.setShown = function (shown) {
        this._showElement(this.annotationsShown && this.enabled && shown && !this.culled && !this.occluded);
        this.publish("shown", this.shown = shown);
    };

    /**
     * Sets whether or not this label is culled
     * @memberof Human.view.annotations.Label
     * @param {Boolean} culled True to show, false to hide
     */
    Label.prototype.setCulled = function (culled) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !culled && !this.occluded);
        this.publish("culled", this.culled = culled);
    };

    /**
     * Sets whether or not this label is occluded
     * @memberof Human.view.annotations.Label
     * @param {Boolean} occluded True if occluded
     */
    Label.prototype.setOccluded = function (occluded) {
        this._showElement(this.annotationsShown && this.enabled && this.shown && !this.culled && !occluded);
        this.publish("occluded", this.occluded = occluded);
    };

    /**
     * Sets the label's opacity
     * @memberof Human.view.annotations.Label
     * @param {number} opacity Opacity factor in range [0..1]
     */
    Label.prototype.setOpacity = function (opacity) {
        this.$element.css({ "opacity": this.opacity = opacity });
        this.publish("opacity", opacity);
    };

    Label.prototype._showElement = function (shown) {
        if (shown) {
            this.$element.css("display", "inline-block");
        } else {
            this.$element.hide();
        }
    };

    /**
     * Sets the title
     * @memberof Human.view.annotations.Label
     * @param {String} title Title text
     */
    Label.prototype.setTitle = function (title) {
        this.$titleField.val(title);
        this.$title.html(title);
        this.publish("title", this.title = title);
    };

    /**
     * Sets the description
     * @memberof Human.view.annotations.Label
     * @param {String} description Description text
     */
    Label.prototype.setDescription = function (description) {
        this.$descriptionField.val(description);
        this.$description.html(description);
        this.publish("description", this.description = description);
    };

    /**
     * Sets the embed window
     * @memberof Human.view.annotations.Label
     * @param {Object} embed Embedded config data
     */
    Label.prototype.setEmbed = function (embed) {
        var params =['ui-all=false']; //enforce no ui elements in this mode

        for (var key in embed) {
            if (embed.hasOwnProperty(key)) {
                params.push(key + '=' + embed[key]);
            }
        }

        var url    = '/embedded.html?' + params.join('&');
        var iframe = '<iframe src="' + url + '" width="150" height="150" border="0"></iframe>';

        this.$element.addClass('annotationEmbed');
        this.$element.find('.embedContainer').append(iframe).show();

        this.publish('embed', this.embed = embed);
    };

    /**
     * Sets the DOM-space position of this label
     * @memberof Human.view.annotations.Label
     * @param {[Number, Number]} pos DOM-space label position
     * @param {Boolean} horizontal Indicates horizontal property set
     */
    Label.prototype.setPos = function (pos, horizontal) {
        if(horizontal) {
            pos[1] = pos[1] - this.$titleContainer[0].offsetHeight;
        }

        this.$element.css({left: pos[0] + 'px', top: pos[1] + 'px'});
        this.publish("pos", this.pos = pos);
    };

    /**
     * Sets the side of the canvas this label is on,
     * as well its wire connection position
     * @memberof Human.view.annotations.Label
     * @param {String} side 'left' or 'right'
     */
    Label.prototype.setSide = function (side) {
        this.side = side;
        this.$element.removeClass('left right').addClass(side);

        this.connectionPoint = [ //set the point where the wire will meet the label
                this.pos[0] + (side === 'left' ? this.getWidth() : 0),
                this.pos[1] + this.$titleContainer[0].offsetHeight
        ];
    };

    /**
     * Gets the top of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Top of label
     */
    Label.prototype.getTop = function () {
        return this.$element[0].offsetTop;
    };

    /**
     * Gets the bottom of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Bottom of label
     */
    Label.prototype.getBottom = function () {
        return this.$element[0].offsetTop + this.getHeight();
    };

    /**
     * Gets the height of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Height of label
     */
    Label.prototype.getHeight = function () {
        return this.$element[0].offsetHeight;
    };

    /**
     * Gets the width of this label
     * @memberof Human.view.annotations.Label
     * @return {Number} Width of label
     */
    Label.prototype.getWidth = function () {
        return this.$element[0].offsetWidth;
    };

    /**
     * Synchs the width property of this label with it's DOM outer width
     * @memberof Human.view.annotations.Label
     */
    Label.prototype.updateWidth = function () {
        this.width = this.getWidth();
    };

    Label.prototype._redrawWireConnection = function () {
        this.updateWidth();
        Human.view.annotations.layouts.redrawLayout();
    };

    /**
     * Destroys this label
     * @memberof Human.view.annotations.Label
     * @private
     */
    Label.prototype.destroy = function () {
        this.$element.remove();
        this.publish("destroyed", true);
    };

    //Private Utilities
    var _initFieldMaxLength = function ($element, maxLength) {
        if (maxLength && maxLength > 0) {
            $element.attr("maxlength", maxLength);

            $element.keyup(function (e) {
                if (e.keyCode === 13) { // ignore ENTER
                    return;
                } else if ($element.val().length >= maxLength) {
                    alert('Maximum characters allowed (' + maxLength + ')');
                }
            });
        }
    };

})(Human, jQuery);;/**
 * @namespace Pins annotations on anatomy objects
 */
(function () {
    "use strict";

    var placer = Human.view.annotations.placer = {};
    var eyePosVec = Human.math.vec3();

    /**
     * Places a fresh annotation at the given World-space position, with pin pointing towards the eye position.
     *
     * <p>The annotation:</p>
     * <ul>
     *     <li>will have empty strings for title and description,</li>
     *      <li>have an initially visible pin and label, and</li>
     *      <li>will be in an unsaved state.</li>
     * </ul>
     *
     * @param {{}} params Placement params
     * @param {String} params.objectId ID of an {@link Human.scene.Object} in {@link Human.scene}.
     * @param {[Number, Number, Number]} params.pos World-space position of annotation pin
     * @param {[Number, Number, Number]} params.dir 3D vector indicating direction the pin is pointing
     */
    placer.placeAnnotation = function (params) {

        var eyePos = Human.view.camera.eye;

        eyePosVec[0] = eyePos.x;
        eyePosVec[1] = eyePos.y;
        eyePosVec[2] = eyePos.z;

        var eyeVec = Human.math.subVec3(eyePosVec, params.pos);

        Human.view.annotations.createAnnotation({
            objectId: params.objectId,
            title: params.title || "",
            description: params.description || "",
            pos: params.pos,
            dir: eyeVec,
            enabled: true,
            shown: true,
            labelShown: true,
            saved: (params.saved !== undefined && params.saved !== null) ? params.saved : false
        });
    };

})();







;/**
 * @namespace Annotation layout manager.
 *
 * <p>Strategies are plugged into this to provide various types of layout for annotation labels.</p>
 *
 * <p>The active layout is bound to the "annotation.layout.type" property.</p>
 */
(function () {
    "use strict";

    var HumanViewAnnotationsLayouts = Human.view.annotations.layouts = {};

    var layouts = {};
    var activeLayout;
    HumanViewAnnotationsLayouts.activeLayout = null;

    // Get annotation canvas when engine loaded
    Human.events.on(
        "loaded",
        function () {

            var canvas = document.getElementById("annotationCanvas");
            if (!canvas) {
                Human.log.error("Human.view.annotations.layouts", "DOM element not found: 'annotationCanvas'");
                return;
            }

            var context = canvas.getContext('2d');
            if (!context) {
                Human.log.error("Human.view.annotations.layouts", "Failed to get 2D canvas context");
                return;
            }

            // Select any layout required in configs
            Human.properties.subscribe({
                propId: "annotations.layout.type",
                value: "columns",  // HACK
                callback: function (value) {
                    //if (value != "") {
                        HumanViewAnnotationsLayouts._selectLayout(value);
                   // }
                }
            });

            // Update dirty layout on each renderer tick
            Human.events.on(
                "tick",
                function () {
                    if (activeLayout && canvas && context) {
                        activeLayout.layout(canvas, context);
                    }
                });
        });

    function layoutDirty() {
        if (activeLayout) {
            activeLayout.setDirty();
        }
    }
        
    // Layout dirty whenever camera moves
    Human.events.on(
        "camera.updated",
        function () {
            layoutDirty();
        });
        
     Human.events.on(
         "canvas.resized",
         function () {
            layoutDirty();
        });

    // Layout dirty whenever an annotation is created
    Human.events.on(
        "annotations.creating",
        function (params) {
            setLayoutEvents(params);
        });
    
    // Layout dirty whenever an annotation is loaded from a bookmark
    Human.events.on(
        "annotations.created",
        function (params) {
            setLayoutEvents(params);
        });

    var setLayoutEvents = function (params) {
        Human.events.onEvent("annotations.shown", layoutDirty);
        var annotation = Human.view.annotations.annotations[params.annotationId];
        annotation.on("object", layoutDirty);
        annotation.pin.on("enabled", layoutDirty);
        annotation.pin.on("shown", layoutDirty);
        annotation.label.on("shown", layoutDirty);
        annotation.label.on("edit", layoutDirty);
        annotation.label.on("saved", layoutDirty);
        annotation.label.on("cancel", layoutDirty);
        annotation.label.on("destroyed", layoutDirty);
        layoutDirty();
    };
            
    // Snapshot tool publishes its canvas and context just before it's
    // about to capture the snapshot image from it. We'll intercept it
    // and render the labels to it.
    Human.events.on(
        "snapshot.rendering",
        function (params) {
            if (activeLayout && activeLayout.snapshot) { // Only if active layout supports it
                activeLayout.snapshot(params.canvas, params.context, params.bgColor);
            }
        });

    /**
     * Adds a layout strategy.
     * @param {String} type The layout type name
     * @param {{}} layout The layout strategy
     */
    HumanViewAnnotationsLayouts.addLayoutType = function (type, layout) {
        if (layouts[type]) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout already added: '" + type + "'");
            return;
        }
        if (!layout.setEnabled) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout strategy does not have a 'setEnabled' method");
            return;
        }
        if (!layout.setDirty) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout strategy does not have a 'setDirty' method");
            return;
        }
        if (!layout.layout) {
            Human.log.error("Human.view.annotations.layouts.addLayoutType", "Layout strategy does not have a 'layout' method");
            return;
        }
        layouts[type] = layout;
        if (!activeLayout) {
            HumanViewAnnotationsLayouts._selectLayout(type); // Select first added by default
        }
    };

    /**
     * Activates a layout type.
     * Bound to a config property (see above)
     * @param {String} type The layout type name
     * @private
     */
    HumanViewAnnotationsLayouts._selectLayout = function (type) {

        // HACK alias names - want to use "columns" instead of "columns-v2"
        if (type === "columns-v2") {
            type = "columns";
        }

        Human.log.info("Human.view.annotations.layouts._selectLayout", "Selecting label type: '" + type + "'");
        if (!layouts[type]) {
            Human.log.error("Human.view.annotations.layouts._selectLayout", "Layout not found: '" + type + "'");
            return;
        }
        if (activeLayout === type) {
            // Already active
            return;
        }
        if (activeLayout) {
            activeLayout.setEnabled(false);
        }
        activeLayout = layouts[type];
        activeLayout.setEnabled(true);
        activeLayout.setDirty();
        HumanViewAnnotationsLayouts.activeLayout = type;
    };

    /**
     * Redraw the active layout.
     */
    HumanViewAnnotationsLayouts.redrawLayout = layoutDirty;

})();;/**
 * @namespace Annotation layout strategy which lays the labels out in left and right columns
 */
Human.view.annotations.layouts.addLayoutType(
    "columns",

    (function () {
        "use strict";

        var ColumsLayout = {};

        // Margins config
        var margins;

        Human.properties.subscribe({
            propId: "annotations.margins",
            value: {
                top: 50,
                left: 50,
                right: 50,
                bottom: 50
            },
            callback: function (value) {
                margins = value;
            }
        });

        // Width of labels
        var maxLabelWidth;

        Human.properties.subscribe({
            propId: "annotations.labelWidth",
            value: 150,
            callback: function (value) {
                maxLabelWidth = value;
            }
        });

        // Horizontal lines flag
        var horizontalLines = false;

        Human.properties.subscribe({
            propId: "annotations.horizontalLines",
            value: horizontalLines,
            callback: function (value) {
                horizontalLines = value;
                dirty = true;
            }
        });

        // Angle beyond which labels are occluded
        var occludedAngle = 100;

        Human.properties.subscribe({
            propId: "annotations.occludedAngle",
            value: occludedAngle,
            callback: function (value) {
                occludedAngle = value;
                dirty = true;
            }
        });

        // Angle beyond which labels are faded
        var fadeoutAngle = 80;

        Human.properties.subscribe({
            propId: "annotations.fadeoutAngle",
            value: fadeoutAngle,
            callback: function (value) {
                fadeoutAngle = value;
                dirty = true;
            }
        });

        var enabled = false;
        var dirty = true;

        var leftColumn = [];
        var lenLeftColumn = 0;
        var rightColumn = [];
        var lenRightColumn = 0;

        var layoutCanvasWidth;
        var layoutCanvasHeight;

        /** Notifies this layout that it's enabled
         *
         * @param {boolean} enable True to enable, else false
         */
        ColumsLayout.setEnabled = function (enable) {
            enabled = enable;
            dirty = true;
        };

        /** Notifies this layout that will need to rebuild itself
         */
        ColumsLayout.setDirty = function () {
            dirty = true;
        };

        /**
         * Refreshes this layout.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        ColumsLayout.layout = function (canvas, context) {

            if (!dirty) {
                return;
            }

            context.clearRect(0, 0, canvas.width, canvas.height);

            if (!Human.view.annotations.shown) {
                // Annotations globally hidden
                dirty = false;
                return;
            }

            lenLeftColumn = 0;
            lenRightColumn = 0;

            var annotations = Human.view.annotations.annotations;
            var annotation;
            var pin;
            var label;
            var left;

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();

            var boundary = getCanvasModelBoundary(canvas, context, viewMat, projMat);

            if (Human.request.getSearchParam("showBoundary")) {
                context.beginPath();
                context.rect(boundary.xmin, boundary.ymin, boundary.xmax - boundary.xmin, boundary.ymax - boundary.ymin);
                context.lineWidth = 2;
                context.strokeStyle = 'black';
                context.stroke();
            }

            // Assign annotations to left and right columns
            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    pin = annotation.pin;
                    label = annotation.label;

                    // Skip over hidden annotations

                    if (!pin.shown || !pin.enabled) {
                        continue;
                    }

                    if (!label.shown && !pin.shown) {
                        continue;
                    }

                    // Transform pin into View and Canvas space
                    pin.transform(viewMat, projMat, canvas);

                    // Test if pin is "hidden" on a backface, ie. pointing away from eye
                    var angle = getPinViewAngle(pin);

                    pin.setViewAngle(angle);

                    var occluded = angle < -occludedAngle || angle > occludedAngle;

                    pin.setOccluded(occluded);

                    var opacity;

                    if (angle >= fadeoutAngle) {
                        opacity = 1 - ((angle - fadeoutAngle) / (occludedAngle - fadeoutAngle));
                        if (opacity < 0) {
                            opacity = 0;
                        }
                    } else {
                        opacity = 1.0;
                    }

                    pin.setOpacity(opacity);
                    label.setOpacity(opacity);

                    // Cull pins outside canvas extents.
                    // For API user convenience, want to update cull status on all pins,
                    // including those not enabled and/or not shown
                    pin.cullToRectangle(margins.left, 0, canvas.width - margins.right - maxLabelWidth, canvas.height);

                    // Cull label in synch with pin
                    if (pin.culled !== label.culled) {
                        label.setCulled(pin.culled);
                    }

                    // Synch label with pin's occlusion status
                    if (pin.occluded !== label.occluded) {
                        label.setOccluded(pin.occluded);
                    }

                    // If label visible, add to left or right column
                    // Label is visible only if pin enabled, shown, not culled and label shown
                    if (pin.enabled && pin.shown && !pin.culled && !pin.occluded && label.shown) {
                        left = (annotation.pin.viewPos[0] < 0);
                        if (left) {
                            leftColumn[lenLeftColumn++] = annotation;
                        } else {
                            rightColumn[lenRightColumn++] = annotation;
                        }
                    }
                }
            }

            // Sort columns by pin positions on Y-axis
            sortColumn(leftColumn, lenLeftColumn);
            sortColumn(rightColumn, lenRightColumn);

            // Lay the columns out
            layoutColumn(canvas, context, boundary, leftColumn, lenLeftColumn, -1);
            layoutColumn(canvas, context, boundary, rightColumn, lenRightColumn, +1);

            // Retain canvas dimensions for when we might render to snapshot
            layoutCanvasWidth = canvas.width;
            layoutCanvasHeight = canvas.height;

            dirty = false;
        };

        var projPos = Human.math.vec4();

        function getCanvasModelBoundary(canvas, context, viewMat, projMat) {

            // Get boundary of visible leaf objects

            var enabled = Human.scene.enabledObjects;
            var b;
            var worldBox;
            var worldPos;

            var x;
            var y;
            var w;

            var canvasBox = {
                xmin: Human.math.MAX_DOUBLE,
                ymin: Human.math.MAX_DOUBLE,
                xmax: Human.math.MIN_DOUBLE,
                ymax: Human.math.MIN_DOUBLE
            };

            for (var objectId in enabled) {
                if (enabled.hasOwnProperty(objectId)) {

                    var object = enabled[objectId];

                    if (object.numSubObjects === 0) {

                        b = object.getBoundary();

                        worldBox = [
                            [b.xmin, b.ymin, b.zmin],
                            [b.xmax, b.ymin, b.zmin],
                            [b.xmax, b.ymax, b.zmin],
                            [b.xmin, b.ymax, b.zmin],
                            [b.xmin, b.ymin, b.zmax],
                            [b.xmax, b.ymin, b.zmax],
                            [b.xmax, b.ymax, b.zmax],
                            [b.xmin, b.ymax, b.zmax]
                        ];

                        for (var i = 0; i < 8; i++) {

                            worldPos = worldBox[i];

                            Human.math.transformPoint3(viewMat, worldBox[i], projPos);

                            if (projPos[2] > 0.1) {

                                // Skip points that are outside the front clip plane

                                continue;
                            }

                            projPos[3] = 1; // Need homogeneous 'w' for perspective division

                            Human.math.transformPoint4(projMat, projPos, projPos);

                            x = projPos[0];
                            y = projPos[1];
                            w = projPos[3];

                            x = (1 + x / w) * canvas.width / 2;
                            y = (1 - y / w) * canvas.height / 2;

                            if (x < 0 || y < 0 || x > canvas.width || y > canvas.height) {

                                // Skip points that project off the canvas

                                continue;
                            }

                            if (canvasBox.xmin > x) {
                                canvasBox.xmin = x;
                            }

                            if (canvasBox.ymin > y) {
                                canvasBox.ymin = y;
                            }

                            if (canvasBox.xmax < x) {
                                canvasBox.xmax = x;
                            }

                            if (canvasBox.ymax < y) {
                                canvasBox.ymax = y;
                            }
                        }
                    }
                }
            }

            return canvasBox;
        }


        var eyeVec = Human.math.vec3();

        function getPinViewAngle(pin) {
            var eyePos = Human.view.camera.eye;

            eyeVec[0] = eyePos.x;
            eyeVec[1] = eyePos.y;
            eyeVec[2] = eyePos.z;

            Human.math.subVec3(eyeVec, pin.pos, eyeVec);
            var dot = Human.math.dotVector3(eyeVec, pin.dir);
            var lenEyeVec = Human.math.lenVec3(eyeVec);
            var lenPinVec = Human.math.lenVec3(pin.dir);
            var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
            return angle;
        }

        function sortColumn(column, len) { // Faster than native JS sort - no callback and less GC
            var temp;
            var min;
            for (var out = 0; out < len - 1; out++) {
                min = out;
                for (var inn = out; inn < len; inn++) {
                    if (column[inn].pin.canvasPos[1] < column[min].pin.canvasPos[1]) { //If max greater => new max
                        min = inn;
                    }
                }
                temp = column[out];
                column[out] = column[min];
                column[min] = temp;
            }
        }

        function layoutColumn(canvas, context, boundary, column, len, side) {
            // Find X position as the closest point possible to the model's
            // current canvas-space boundary, clamped to margins
            var x = (side < 0) ?
                Math.max(margins.left, boundary.xmin - maxLabelWidth - 50) :
                Math.min(canvas.width - margins.right - maxLabelWidth, boundary.xmax);

            var topMargin = Math.max(margins.top, boundary.ymin);
            var bottomMargin = Math.min(margins.bottom, boundary.ymax);
            var y = topMargin;
            var yRange = canvas.height - topMargin - bottomMargin;
            var yInc = yRange / len;
            var annotation;
            var pin, label, wire;

            for (var i = 0; i < len; i++) {
                annotation = column[i];

                pin = annotation.pin;
                label = annotation.label;
                wire = annotation.wire;

                // Draw wire
                var pinX = pin.canvasPos[0];
                var pinY = pin.canvasPos[1];

                // Position the label
                label.setPos([x, horizontalLines ? pinY : y], horizontalLines);
                //sets side & connectionPoint relative to position
                label.setSide(side < 0 ? 'left' : 'right');

                var connection = label.connectionPoint;

                var wireLength = Math.sqrt((Math.pow(connection[0] - pinX, 2) + Math.pow(connection[1] - pinY, 2)));

                var wireAngle;

                if (horizontalLines) {
                    wireAngle = side < 0 ? 0 : 180;
                } else {
                    wireAngle = Math.atan2(pinY - connection[1], pinX - connection[0]) * 180 / Math.PI;
                }

                wire.css({
                    width: wireLength + 'px',
                    left: connection[0] + 'px',
                    top: connection[1] + 'px',
                    opacity: pin.opacity,

                    '-webkit-transform': 'rotate(' + wireAngle + 'deg)',
                    '-moz-transform': 'rotate(' + wireAngle + 'deg)',
                    '-ms-transform': 'rotate(' + wireAngle + 'deg)',
                    '-o-transform': 'rotate(' + wireAngle + 'deg)',
                    transform: 'rotate(' + wireAngle + 'deg)'
                });

                y += yInc;
            }
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        ColumsLayout.snapshot = function (canvas, context, bgColor) {

            if (!Human.view.annotations.shown) {
                // Annotations globally hidden
                return;
            }

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates 
            //from layout canvas to snapshot canvas
            var scaleX = snapshotCanvasWidth / layoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / layoutCanvasHeight;

            var annotations = Human.view.annotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    if (annotation.pin.enabled && !annotation.pin.occluded) {

                        label = annotation.label;

                        if (label.shown) {
                            renderLabel(annotation, canvasData, bgColor);
                        }
                    }
                }
            }
        };

        function renderLabel(annotation, canvasData, bgColor) {
            var label = annotation.label;
            var pin = annotation.pin;

            var labelX = label.pos[0] * canvasData.scaleX;

            var connectX = label.connectionPoint[0] * canvasData.scaleX;
            var connectY = label.connectionPoint[1] * canvasData.scaleY;

            var context = canvasData.context;

            var labelWidth = Math.min((canvasData.width - labelX - 10), label.width * canvasData.scaleX); //cap max-width

            //Multi-line text drawing offset from leader line
            var drawText = function (text, fontSize, startOffset) {
                var lineHeight = fontSize * 1.25;
                context.font = fontSize + "px Arial";

                var lines = wrapText(context, text || "", labelWidth);
                var startY = connectY + startOffset(lines, lineHeight);

                for (var i = 0; i < lines.length; i++) {
                    context.fillText(lines[i], labelX, startY + (lineHeight * i));
                }
            };

            //set font color based on background
            context.fillStyle = bgColor === 'white' ? "rgb(0, 0, 0)" : "rgb(255, 255, 255)";

            drawText(label.title, 24, function (lines, lineHeight) {
                return -(lines.length - 1) * lineHeight - 20;
            });

            drawText(label.description, 24, function (lines, lineHeight) {
                return lineHeight + 10;
            });

            //Draw wire (w/ title underline)
            // Need wire a bit more visible than pin
            var wireOpacity = pin.opacity;

            context.strokeStyle = "rgba(204, 204, 204, " + wireOpacity + ")";
            context.beginPath();

            context.moveTo(
                    pin.canvasPos[0] * canvasData.scaleX,
                    pin.canvasPos[1] * canvasData.scaleY
            );

            context.lineTo(connectX, connectY); //wire

            var underlineEnd = label.side === 'left' ? -labelWidth : labelWidth;
            context.lineTo(connectX + underlineEnd, connectY); //underline

            //context.closePath();
            context.stroke();

            var drawCircle = function (radius, color, stroke) {
                context.fillStyle = color;
                context.beginPath();
                context.arc(
                        pin.canvasPos[0] * canvasData.scaleX,
                        pin.canvasPos[1] * canvasData.scaleY,
                    radius,
                    0,
                        2 * Math.PI
                );

                context.fill();
                if (stroke) {
                    stroke();
                }
            };

            drawCircle(8, 'rgb(255, 255, 255)', function () {
                context.lineWidth = 1;
                context.strokeStyle = 'rgb(204, 204, 204)';
                context.stroke();
            });

            drawCircle(4, 'rgb(153,0,0)');

            // var radialGradient = context.createRadialGradient(
//                 pin.canvasPos[0] * canvasData.scaleX - 2, pin.canvasPos[1] * canvasData.scaleY - 2, 1,
//                 pin.canvasPos[0] * canvasData.scaleX, pin.canvasPos[1] * canvasData.scaleY, 4
//             );
//
//             radialGradient.addColorStop(0, 'rgba(252,207,204,' + pinOpacity + ')');
//             radialGradient.addColorStop(0.4, 'rgba(197,0,0,' + pinOpacity + ')');
//             radialGradient.addColorStop(0.6, 'rgba(245,0,0,' + pinOpacity + ')');
//             radialGradient.addColorStop(1, 'rgba(153,0,0,' + pinOpacity + ')');


        }

        function wrapText(context, text, maxWidth) {
            var words = text.split(' ');

            var line = '';
            var lines = [];

            for (var n = 0; n < words.length; n++) {
                var testLine = line + words[n];
                var metrics = context.measureText(testLine);

                if (metrics.width > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine + ' ';
                }
            }

            lines.push(line);
            return lines;
        }

        return ColumsLayout;
    })());;/**
 * @namespace Annotation layout strategy which arranges the labels on wires that radiate outwards.
 */
Human.view.annotations.layouts.addLayoutType(
    "radial",

    (function () {
        "use strict";

        var RadialLayout = {};

        // Whether wires are enabled or not
        var wires = true;
        Human.properties.subscribe({
            propId: "annotation.layout.wires",
            value: true,
            callback: function (value) {
                wires = value;
            }
        });

        // Gap between edge of canvas and labels
        var labelMargins = 100;
        Human.properties.subscribe({
            propId: "annotation.layout.labelMargins",
            value: 100,
            callback: function (value) {
                labelMargins = value;
            }
        });

        // Width of labels
        var labelWidth = 200;
        Human.properties.subscribe({
            propId: "annotation.layout.labelWidth",
            value: 100,
            callback: function (value) {
                labelWidth = value;
            }
        });

        var enabled = false;
        var dirty = true;

        var leftColumn = [];
        var lenLeftColumn = 0;
        var rightColumn = [];
        var lenRightColumn = 0;

        var layoutCanvasWidth;
        var layoutCanvasHeight;


        /** Notifies this layout that it's enabled
         *
         * @param {boolean} enable True to enable, else false
         */
        RadialLayout.setEnabled = function (enable) {
            enabled = enable;
            dirty = true;
        };

        /** Notifies this layout that will need to rebuild itself
         */
        RadialLayout.setDirty = function () {
            dirty = true;
        };

        /**
         * Refreshes this layout.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        RadialLayout.layout = function (canvas, context) {

            if (!dirty) {
                return;
            }

            lenLeftColumn = 0;
            lenRightColumn = 0;

            var annotations = Human.view.annotations.annotations;
            var annotation;
            var pin;
            var label;
            var left;

            // Assign annotations to left and right columns
            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    pin = annotation.pin;
                    label = annotation.label;

                    // Cull pins outside canvas extents.
                    // For API user convenience, want to update cull status on all pins,
                    // including those not enabled and/or not shown
                    pin.cullToRectangle(0, 0, canvas.width, canvas.height);

                    // Cull label with pin
                    if (pin.culled !== label.culled) {
                        label.setCulled(pin.culled);
                    }

                    // If label visible, add to left or right column
                    // Label is visible only if pin enabled, shown, not culled and label shown
                    if (pin.enabled && pin.shown && !pin.culled && label.shown) {
                        if (annotation.pin.viewPos) { // Might not have been obtained (ie. pin rendered) yet
                            left = (annotation.pin.viewPos[0] < 0);
                            if (left) {
                                leftColumn[lenLeftColumn++] = annotation;
                            } else {
                                rightColumn[lenRightColumn++] = annotation;
                            }
                        }
                    }
                }
            }

            // Sort columns by pin positions on Y-axis
            sortColumn(leftColumn, lenLeftColumn);
            sortColumn(rightColumn, lenRightColumn);

            context.clearRect(0, 0, canvas.width, canvas.height);

            // Lay the columns out
            layoutColumn(canvas, context, leftColumn, lenLeftColumn, labelMargins);
            layoutColumn(canvas, context, rightColumn, lenRightColumn, canvas.width - labelMargins - labelWidth);

            // Retain canvas dimensions for when we might render to snapshot
            layoutCanvasWidth = canvas.width;
            layoutCanvasHeight = canvas.height;

            dirty = false;
        };

        function sortColumn(column, len) { // Faster than native JS sort - no callback and less GC
            var temp;
            var min;
            for (var out = 0; out < len - 1; out++) {
                min = out;
                for (var inn = out; inn < len; inn++) {
                    if (column[inn].pin.pos[1] > column[min].pin.pos[1]) { //If max greater => new max
                        min = inn;
                    }
                }
                temp = column[out];
                column[out] = column[min];
                column[min] = temp;
            }
        }

        function layoutColumn(canvas, context, column, len, x) {
            var canvasHalfX = canvas.width / 2.0;
            var yRange = canvas.height;
            var yInc = yRange / len;
            var y = 50;
            var annotation;
            var pin;

            var label;
            for (var i = 0; i < len; i++) {
                annotation = column[i];
                pin = annotation.pin;
                label = annotation.label;

                // Position the label
                label.setPos([x, y]);

                // Draw wire
                context.strokeStyle = "rgb(0, 0, 100)";
                context.beginPath();
                context.moveTo(pin.canvasPos[0], pin.canvasPos[1]);
                if (x < canvasHalfX) {
                    context.lineTo(x + label.getWidth(), y);
                } else {
                    context.lineTo(x, y);
                }
                context.closePath();
                context.stroke();

                y += yInc;
            }
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        RadialLayout.snapshot = function (canvas, context) {

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates 
            //from layout canvas to snapshot canvas
            var scaleX = snapshotCanvasWidth / layoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / layoutCanvasHeight;

            var annotations = Human.view.annotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];

                    if (annotation.pin.enabled) {

                        label = annotation.label;

                        if (label.shown) {
                            renderLabel(annotation, canvasData);
                        }
                    }
                }
            }
        };

        function renderLabel(annotation, canvasData) {
            var label = annotation.label;
            var pin = annotation.pin;
            var labelX = label.pos[0] * canvasData.scaleX;
            var labelY = label.pos[1] * canvasData.scaleY;

            var labelMaxWidth = 120, lineHeight = 20;
            var context = canvasData.context;

            var labelWidth = Math.min(  //cap max-width
                (canvasData.width - labelX - 10), labelMaxWidth);

            //Calc description lines before drawing rectangle
            var lines = wrapText(
                context,
                    label.description || "",
                labelWidth
            );

            //Rectangle
//            context.strokeStyle = "rgb(50, 50, 50)";
//            context.fillStyle = "rgba(30, 30, 30, 0.7)";
//            roundRect(
//                context,
//                    labelX - 7,
//                    labelY - 7,
//                    labelWidth + 7,
//                    (lineHeight * lines.length) + 35, //account for title and padding
//                6,
//                true
//            );

            // Title
            context.font = "12pt Arial";
            context.fillStyle = "rgb(34, 168, 221)";
            context.fillText(
                    label.title || "",
                labelX,
                    labelY + 10
            );

            //Description text
            context.font = "10pt Arial";
            context.fillStyle = "rgb(255, 255, 255)";

            for (var i = 0; i < lines.length; i++) {
                context.fillText(
                    lines[i],
                    labelX,
                        labelY + 30 + (lineHeight * i)
                );
            }

            //Draw wire
            context.strokeStyle = "rgb(0, 0, 100)";
            context.beginPath();
            context.moveTo(pin.canvasPos[0], pin.canvasPos[1]);
            if (labelX < canvasData.halfWidth) {
                context.lineTo(labelX + labelWidth, labelY - 7); //account for title and padding
            } else {
                context.lineTo(labelX - 7, labelY - 7); //account for title and padding
            }
            context.closePath();
            context.stroke();
        }

        function wrapText(context, text, maxWidth) {

            var words = text.split(' ');
            var line = '';
            var lines = [];

            for (var n = 0; n < words.length; n++) {
                var testLine = line + words[n];
                var metrics = context.measureText(testLine);

                if (metrics.width > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine + ' ';
                }
            }

            lines.push(line);
            return lines;
        }

        return RadialLayout;
    })());
;/**
 * @namespace Annotation layout strategy which floats the labels directly over their pin positions
 */
Human.view.annotations.layouts.addLayoutType(
    "floating",

    (function () {
        "use strict";

        var FloatingLayout = {};

        // Width of labels
        var maxLabelWidth;

        Human.properties.subscribe({
            propId: "annotations.labelWidth",
            value: 120,
            callback: function (value) {
                maxLabelWidth = value;
            }
        });

        var enabled = false;
        var dirty = true;

        var layoutCanvasWidth;
        var layoutCanvasHeight;

        // Angle at which to decide whether or not a pin is occluded
        var occludedPinAngle = 90;

        /** Notifies this layout that it's enabled
         *
         * @param {boolean} enable True to enable, else false
         */
        FloatingLayout.setEnabled = function (enable) {
            enabled = enable;
            dirty = true;
        };

        /** Notifies this layout that will need to rebuild itself
         */
        FloatingLayout.setDirty = function () {
            dirty = true;
        };

        /**
         * Refreshes this layout.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        FloatingLayout.layout = function (canvas, context) {

            if (!dirty) {
                return;
            }

            context.clearRect(0, 0, canvas.width, canvas.height);

            var annotations = Human.view.annotations.annotations;
            var annotation;
            var pin;
            var label;

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    pin = annotation.pin;
                    label = annotation.label;

                    // Transform pin into View and Canvas space
                    pin.transform(viewMat, projMat, canvas);

                    // Test if pin is "hidden" on a backface, ie. pointing away from eye
                    var angle = getPinViewAngle(pin);
                    pin.setViewAngle(angle);
                    var occluded = angle < -90 || angle > 90;
                    pin.setOccluded(occluded);

                    // Set translucency in proportion to
                    // how much pin points away from eye
                    var opacity = ((0 - 1) * (angle - 0)) / (occludedPinAngle - 0) + 1;
                    if (opacity < 0) {
                        opacity = 0;
                    }
                    pin.setOpacity(opacity);
                    label.setOpacity(opacity + 0.5);

                    // Cull pins outside canvas extents.
                    // For API user convenience, want to update cull status
                    // on all pins, including those not enabled and/or not shown
                    pin.cullToRectangle(0, 0, canvas.width, canvas.height);

                    // Cull label in synch with pin
                    if (pin.culled !== label.culled) {
                        label.setCulled(pin.culled);
                    }

                    // Synch label with pin's occlusion status
                    if (pin.occluded !== label.occluded) {
                        label.setOccluded(pin.occluded);
                    }

                    // Position label is shown
                    // Label is visible only if pin enabled, shown, not culled and label shown
                    if (pin.enabled && pin.shown && !pin.culled && !pin.occluded && label.shown) {
                        label.setPos(pin.canvasPos);
                    }
                }
            }

            // Save canvas dimensions for snapshots
            layoutCanvasWidth = canvas.width;
            layoutCanvasHeight = canvas.height;

            dirty = false;
        };

        var eyeVec = Human.math.vec3();

        function getPinViewAngle(pin) {
            var eyePos = Human.view.camera.eye;

            eyeVec[0] = eyePos.x;
            eyeVec[1] = eyePos.y;
            eyeVec[2] = eyePos.z;

            Human.math.subVec3(eyeVec, pin.pos, eyeVec);
            var dot = Human.math.dotVector3(eyeVec, pin.dir);
            var lenEyeVec = Human.math.lenVec3(eyeVec);
            var lenPinVec = Human.math.lenVec3(pin.dir);
            var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
            return angle;
        }

        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        FloatingLayout.snapshot = function (canvas, context) {

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates 
            //from layout canvas to snapshot canvas
            var scaleX = snapshotCanvasWidth / layoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / layoutCanvasHeight;

            var annotations = Human.view.annotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    annotation = annotations[annotationId];
                    if (annotation.pin.enabled && !annotation.pin.occluded) {
                        label = annotation.label;
                        if (label.shown) {
                            renderLabel(annotation, canvasData);
                        }
                    }
                }
            }
        };

        function renderLabel(annotation, canvasData) {
            var label = annotation.label;
            var pin = annotation.pin;
            var labelX = label.pos[0] * canvasData.scaleX;
            var labelY = label.pos[1] * canvasData.scaleY;

            var lineHeight = 20;
            var context = canvasData.context;

            var labelWidth = Math.min((canvasData.width - labelX - 10), maxLabelWidth); //cap max-width

            //Calc description lines before drawing rectangle
            var lines = wrapText(context, label.description || "", labelWidth);

            var labelYOffset = 10;
            var labelXOffset = 10;
            var rectWidth = labelWidth + 10 + labelXOffset * 2;
            var rectHeight = (lineHeight * lines.length) + 35; //account for title and padding

            //Rectangle
            context.strokeStyle = "rgb(50, 50, 50)";
            context.fillStyle = "rgba(30, 30, 30, 0.7)";
            roundRect(
                context,
                labelX - 0,
                labelY - labelYOffset,
                rectWidth,
                rectHeight,
                6,
                true
            );

            // Title
            // TODO: wrapping titles
            context.font = "12pt Arial";
            context.fillStyle = "rgb(255, 255, 255)";
            context.fillText(
                label.title || "",
                labelX + labelXOffset,
                labelY + labelYOffset
            );

            //Description text
            context.font = "10pt Arial";
            context.fillStyle = "rgb(255, 255, 255)";

            for (var i = 0; i < lines.length; i++) {
                context.fillText(
                    lines[i],
                    labelX + labelXOffset,
                    labelY + labelYOffset + lineHeight + (lineHeight * i)
                );
            }

            //Draw wire

            var pinOpacity = pin.opacity;
            var wireOpacity = pinOpacity + 0.4; // Need wire a bit more visible than pin

            context.strokeStyle = "rgba(102, 102, 102, " + wireOpacity + ")";
            context.beginPath();
            context.moveTo(pin.canvasPos[0] * canvasData.scaleX, pin.canvasPos[1] * canvasData.scaleY);
            if (labelX < canvasData.halfWidth) {
                context.lineTo(labelX + rectWidth, labelY); //account for title and padding
            } else {
                context.lineTo(labelX, labelY); //account for title and padding
            }
            context.closePath();
            context.stroke();

            //Draw 2d pin
            var radialGradient = context.createRadialGradient(
                pin.canvasPos[0] * canvasData.scaleX - 2, pin.canvasPos[1] * canvasData.scaleY - 2, 1,
                pin.canvasPos[0] * canvasData.scaleX, pin.canvasPos[1] * canvasData.scaleY, 4
            );

            radialGradient.addColorStop(0, 'rgba(252,207,204,' + pinOpacity + ')');
            radialGradient.addColorStop(0.4, 'rgba(197,0,0,' + pinOpacity + ')');
            radialGradient.addColorStop(0.6, 'rgba(245,0,0,' + pinOpacity + ')');
            radialGradient.addColorStop(1, 'rgba(153,0,0,' + pinOpacity + ')');

            context.fillStyle = radialGradient;

            context.beginPath();
            context.arc(
                pin.canvasPos[0] * canvasData.scaleX,
                pin.canvasPos[1] * canvasData.scaleY,
                4,
                0,
                2 * Math.PI
            );

            context.fill();
        }

        function wrapText(context, text, maxWidth) {

            var words = text.split(' ');
            var _words = [];
            var metrics;

            // word validation: wrap words if needed
            for (var i = 0; i < words.length; i++) {
                var word = words[i];
                metrics = context.measureText(word);
                // ok
                if (metrics.width <= maxWidth) {
                    _words.push(word);
                }
                // else, break up word
                else {
                    var chunkOffset = word.length % 2 === 0 ? 0 : 1;
                    for (var chunkSize = 2; chunkSize < word.length;) {
                        var chunks = word.split('');
                        var wordLines = [];
                        var success = true;
                        while (chunks.length > 0) {
                            var chunkLength = word.length / chunkSize + (chunkOffset);
                            var chunk = chunks.splice(0, chunkLength);
                            var chunkText = chunk.join('');
                            metrics = context.measureText(chunkText);
                            // ok
                            if (metrics.width <= maxWidth) {
                                wordLines.push(chunkText);
                                continue;
                            }
                            // next chunk size
                            else {
                                chunkSize++;
                                success = false;
                                break;
                            }
                        }
                        if (success === true) {
                            _words = _words.concat(wordLines);
                            break;
                        }
                    }
                }
            }
            var line = '';
            var lines = [];

            for (var n = 0; n < _words.length; n++) {
                var testLine = line + _words[n];
                metrics = context.measureText(testLine);

                if (metrics.width > maxWidth && n > 0) {
                    lines.push(line);
                    line = _words[n] + ' ';
                } else {
                    line = testLine + ' ';
                }
            }

            lines.push(line);
            return lines;

        }

        function roundRect(context, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke === "undefined") {
                stroke = true;
            }
            if (typeof radius === "undefined") {
                radius = 5;
            }
            context.beginPath();
            context.moveTo(x + radius, y);
            context.lineTo(x + width - radius, y);
            context.quadraticCurveTo(x + width, y, x + width, y + radius);
            context.lineTo(x + width, y + height - radius);
            context.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            context.lineTo(x + radius, y + height);
            context.quadraticCurveTo(x, y + height, x, y + height - radius);
            context.lineTo(x, y + radius);
            context.quadraticCurveTo(x, y, x + radius, y);
            context.closePath();
            if (stroke) {
                context.stroke();
            }
            if (fill) {
                context.fill();
            }
        }

        return FloatingLayout;
    })());
;/**
 * @namespace Annotation layout strategy which lays the labels out in left and right columns
 */
Human.view.annotations.layouts.addLayoutType(
    "draggable",

    (function () {
        "use strict";


        var Layout = {};


        // Margins config
        var margins;

        Human.properties.subscribe({
            propId: "annotations.margins",
            value: {
                top: 50,
                left: 50,
                right: 50,
                bottom: 50
            },
            callback: function (value) {
                margins = value;
            }
        });


        // Angle beyond which labels are occluded
        var occludedAngle = 100;

        Human.properties.subscribe({
            propId: "annotations.occludedAngle",
            value: occludedAngle,
            callback: function (value) {
                occludedAngle = value;
                dirty = true;
            }
        });


        // Angle beyond which labels are faded
        var fadeoutAngle = 80;

        Human.properties.subscribe({
            propId: "annotations.fadeoutAngle",
            value: fadeoutAngle,
            callback: function (value) {
                fadeoutAngle = value;
                dirty = true;
            }
        });


        // True when this layout strategy is enabled
        var enabled = false;

        // True when the whole layout needs to be rebuilt
        var dirty = true;

        // Set to an annotation when we just need to update the layout of that annotation label
        var dirtyAnnotation = null;

        // Save canvas dimensions after doing each layout,
        // Used when rendering the snapshot, which is always preceded by a layout.

        var lastLayoutCanvasWidth;
        var lastLayoutCanvasHeight;


        /** Notifies this layout that it's enabled
         *
         * @param {Boolean} enable True to enable, else false
         */
        Layout.setEnabled = function (enable) {

            enabled = enable;

            dirty = true;
        };


        // Annotation label drag behaviours

        (function () {

            // Annotation who's label we're currently dragging
            var annotation;

            // Previous mouse position while dragging
            var lastX = -1;
            var lastY = -1;


            // Get mouse down on annotations because we need the annotation

            Human.events.on("annotations.mouseDown",
                function (params) {

                    if (!enabled) {
                        return;
                    }

                    annotation = Human.view.annotations.annotations[params.annotationId];

                    lastX = params.x;
                    lastY = params.y;
                });

            $('body').mousemove(
                function (e) {

                    if (!enabled) {
                        return;
                    }

                    if (annotation) {

                        var x = e.clientX;
                        var y = e.clientY;

                        var offset = annotation.label.offset;

                        annotation.label.setOffset([
                                offset[0] + x - lastX,
                                offset[1] + y - lastY
                        ]);

                        lastX = x;
                        lastY = y;

                        dirtyAnnotation = annotation;
                    }
                });

            $('body').mouseup(
                function () {

                    if (!enabled) {
                        return;
                    }

                    annotation = null;
                });
        })();


        /**
         * Indicate that layout needs to be rebuilt
         */
        Layout.setDirty = function () {
            dirty = true;
        };

        /**
         * Rebuilds this layout, if it needs a rebuild.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        Layout.layout = function (canvas, context) {

            if (!dirty && !dirtyAnnotation) {

                // Rebuild not needed
                return;
            }

            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();

            if (dirty) {

                // Refresh layout for all annotations

                // Clear canvas
                context.clearRect(0, 0, canvas.width, canvas.height);

                if (!Human.view.annotations.shown) {

                    // Annotations are currently globally hidden
                    dirty = false;
                    return;
                }

                // Update states of all annotations

                var annotations = Human.view.annotations.annotations;

                for (var annotationId in annotations) {
                    if (annotations.hasOwnProperty(annotationId)) {
                        layoutAnnotation(annotations[annotationId], viewMat, projMat, canvas);
                    }
                }

                // Save canvas dimensions after doing each layout,
                // Used when rendering the snapshot, which is always preceded by a layout.

                lastLayoutCanvasWidth = canvas.width;
                lastLayoutCanvasHeight = canvas.height;

                dirty = false;

            } else {

                // Refresh layout for a single annotation

                layoutAnnotation(dirtyAnnotation, viewMat, projMat, canvas);

                dirtyAnnotation = null;
            }
        };


        function layoutAnnotation(annotation, viewMat, projMat, canvas) {

            var pin = annotation.pin;
            var label = annotation.label;
            var wire = annotation.wire;

            var canvasHeight = canvas.height;
            var canvasWidth = canvas.width;

            // Sets label offset to a random value, for testing
//                    label.setOffset([(Math.random() * 500) -250, (Math.random() * 500)-250]);

            // Skip over hidden annotations

            if (!pin.shown || !pin.enabled) {

                // Label pin not shown, skip annotation
                return;
            }

            if (!label.shown && !pin.shown) {

                // Label and pin not shown, skip annotation
                return;
            }

            // Transform annotation pin position by view and projection transforms
            pin.transform(viewMat, projMat, canvas);

            // Get angle between pin and eye vector
            var angle = getPinViewAngle(pin);

            pin.setViewAngle(angle);

            // Pin is occluded when it points away from the eye
            var occluded = angle < -occludedAngle || angle > occludedAngle;

            pin.setOccluded(occluded);

            // Set annotation opacity according to the pin-eye angle
            var opacity;

            if (angle >= fadeoutAngle) {
                opacity = 1 - ((angle - fadeoutAngle) / (occludedAngle - fadeoutAngle));
                if (opacity < 0) {
                    opacity = 0;
                }
            } else {
                opacity = 1.0;
            }

            pin.setOpacity(opacity);
            label.setOpacity(opacity);

            // Clip pins outside canvas extents.
            // For API user convenience, we update the cull status
            // on ALL pins including those not enabled and/or not shown

            pin.cullToRectangle(margins.left, 0, canvasWidth - margins.right - label.getWidth(), canvasHeight);

            // Cull label in synch with pin
            if (pin.culled !== label.culled) {
                label.setCulled(pin.culled);
            }

            // Synch label with pin's occlusion status
            if (pin.occluded !== label.occluded) {
                label.setOccluded(pin.occluded);
            }

            // Label is visible only if pin enabled, shown, not culled and label shown
            if (pin.enabled && pin.shown && !pin.culled && !pin.occluded && label.shown) {

                var wirePos1 = pin.canvasPos;

                var labelPos = [wirePos1[0] + label.offset[0], wirePos1[1] + label.offset[1]];

                if (labelPos[1] < 0 || labelPos[1] > 900) {
                    //     return;
                }

                label.setPos(labelPos);

                var side = (label.offset[0] < 0);

                // Sets side & connectionPoint relative to position
                label.setSide(side ? 'left' : 'right');
//
                var connection = label.connectionPoint;

                var wireLength = Math.sqrt((Math.pow(connection[0] - wirePos1[0], 2) + Math.pow(connection[1] - wirePos1[1], 2)));

                var wireAngle;

                wireAngle = Math.atan2(connection[1] - wirePos1[1], connection[0] - wirePos1[0]) * 180 / Math.PI;

                // Position the wire
                wire.css({
                    width: wireLength + 'px',
                    left: wirePos1[0] + 'px',
                    top: wirePos1[1] + 'px',
                    opacity: pin.opacity,

                    '-webkit-transform': 'rotate(' + wireAngle + 'deg)',
                    '-moz-transform': 'rotate(' + wireAngle + 'deg)',
                    '-ms-transform': 'rotate(' + wireAngle + 'deg)',
                    '-o-transform': 'rotate(' + wireAngle + 'deg)',
                    transform: 'rotate(' + wireAngle + 'deg)'
                });
            }
        }


        /**
         * Returns angle indicating how much the given annotation pin points away from the eye,
         * where 0 indicates that it points directly at the eye, while 180 indicates that it points directly away.
         *
         * @param pin
         * @returns {number}
         */
        function getPinViewAngle(pin) {
            var eyePos = Human.view.camera.eye;
            var eyeVec = Human.math.subVec3([eyePos.x, eyePos.y, eyePos.z], pin.pos);
            var dot = Human.math.dotVector3(eyeVec, pin.dir);
            var lenEyeVec = Human.math.lenVec3(eyeVec);
            var lenPinVec = Human.math.lenVec3(pin.dir);
            var angle = Math.acos(dot / (lenEyeVec * lenPinVec)) * 57.2957795;
            return angle;
        }


        /**
         * Renders this layout to the given snapshot canvas/context.
         *
         * Renders the annotations that are visible and not occluded.
         *
         * @param {HTMLCanvasElement} canvas The canvas
         * @param {CanvasRenderingContext2D} context The canvas' 2D context
         */
        Layout.snapshot = function (canvas, context, bgColor) {

            if (!Human.view.annotations.shown) {
                // Annotations globally hidden
                return;
            }

            var snapshotCanvasWidth = canvas.width;
            var snapshotCanvasHeight = canvas.height;

            // Scale factors for mapping coordinates 
            //from layout canvas to snapshot canvas

            var scaleX = snapshotCanvasWidth / lastLayoutCanvasWidth;
            var scaleY = snapshotCanvasHeight / lastLayoutCanvasHeight;

            var annotations = Human.view.annotations.annotations;
            var annotation;
            var label;

            var canvasData = {
                context: context,
                width: snapshotCanvasWidth,
                height: snapshotCanvasHeight,
                halfWidth: snapshotCanvasWidth / 2,
                scaleX: scaleX,
                scaleY: scaleY
            };

            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {

                    annotation = annotations[annotationId];

                    if (annotation.pin.enabled && !annotation.pin.occluded) {

                        label = annotation.label;

                        if (label.shown) {
                            renderLabel(annotation, canvasData, bgColor);
                        }
                    }
                }
            }
        };


        function renderLabel(annotation, canvasData, bgColor) {

            var label = annotation.label;
            var pin = annotation.pin;

            var labelX = label.pos[0] * canvasData.scaleX;

            var connectX = label.connectionPoint[0] * canvasData.scaleX;
            var connectY = label.connectionPoint[1] * canvasData.scaleY;

            var context = canvasData.context;

            var labelWidth = Math.min((canvasData.width - labelX - 10), label.width * canvasData.scaleX); //cap max-width

            //Multi-line text drawing offset from leader line
            var drawText = function (text, fontSize, startOffset) {
                var lineHeight = fontSize * 1.25;
                context.font = fontSize + "px Arial";

                var lines = wrapText(context, text || "", labelWidth);
                var startY = connectY + startOffset(lines, lineHeight);

                for (var i = 0; i < lines.length; i++) {
                    context.fillText(lines[i], labelX, startY + (lineHeight * i));
                }
            };

            //set font color based on background
            context.fillStyle = bgColor === 'white' ? "rgb(0, 0, 0)" : "rgb(255, 255, 255)";

            drawText(label.title, 24, function (lines, lineHeight) {
                return -(lines.length - 1) * lineHeight - 20;
            });

            drawText(label.description, 24, function (lines, lineHeight) {
                return lineHeight + 10;
            });

            //Draw wire (w/ title underline)
            // Need wire a bit more visible than pin
            var wireOpacity = pin.opacity;
            // +0.4;

            context.strokeStyle = "rgba(204, 204, 204, " + wireOpacity + ")";
            context.beginPath();

            context.moveTo(
                    pin.canvasPos[0] * canvasData.scaleX,
                    pin.canvasPos[1] * canvasData.scaleY
            );

            context.lineTo(connectX, connectY); //wire

            var underlineEnd = label.side === 'left' ? -labelWidth : labelWidth;
            context.lineTo(connectX + underlineEnd, connectY); //underline

            //context.closePath();
            context.stroke();

            var drawCircle = function (radius, color, stroke) {
                context.fillStyle = color;
                context.beginPath();
                context.arc(
                        pin.canvasPos[0] * canvasData.scaleX,
                        pin.canvasPos[1] * canvasData.scaleY,
                    radius,
                    0,
                        2 * Math.PI
                );

                context.fill();
                if (stroke) {
                    stroke();
                }
            };

            drawCircle(8, 'rgb(255, 255, 255)', function () {
                context.lineWidth = 1;
                context.strokeStyle = 'rgb(204, 204, 204)';
                context.stroke();
            });

            drawCircle(4, 'rgb(153,0,0)');
        }


        function wrapText(context, text, maxWidth) {

            var words = text.split(' ');

            var line = '';
            var lines = [];

            for (var n = 0; n < words.length; n++) {
                var testLine = line + words[n];
                var metrics = context.measureText(testLine);

                if (metrics.width > maxWidth && n > 0) {
                    lines.push(line);
                    line = words[n] + ' ';
                } else {
                    line = testLine + ' ';
                }
            }

            lines.push(line);
            return lines;
        }

        return Layout;

    })());;/**
 * @namespace Hides annotations while camera is moving
 */
(function () {
    "use strict";

    var enabled = false;
    var cameraUpdated = false;
    var timeout;

    Human.properties.subscribe({
        propId: "annotations.hideWhileCameraMoving",
        value: enabled,
        callback: function (value) {
            enabled = value;
        }
    });

    Human.events.on("camera.updated",
        function () {
            cameraUpdated = true;
        });

    Human.events.on("tick",
        function () {
            if (!enabled) {
                return;
            }
            if (cameraUpdated) {
                if (timeout) {
                    clearTimeout(timeout);
                    timeout = null;
                }
                Human.view.annotations.setShown(false);
                cameraUpdated = false;
            } else {
                if (!timeout) {
                    timeout = setTimeout(function () {
                        clearTimeout(timeout);
                        Human.view.annotations.setShown(true);
                    }, 200);
                }
            }
        });


})();
;/**
 * @namespace Activates "draggable" layout manager whenever possible
 */
(function () {
    "use strict";

    Human.events.on("bookmarks.restored", tryActivateDraggable);

    Human.events.on("modules.activated", tryActivateDraggable);

    Human.events.on("modules.deactivated", tryActivateDraggable);

    function tryActivateDraggable(evt) {
        if (moduleAnnotationsLayoutSet(Human.modules.modules[evt.moduleId])) {
            return;
        }

        var layout = canActivateDraggable() ? "draggable": "columns-v2";
        Human.properties.set({ "annotations.layout.type": layout });
    }

    function canActivateDraggable() {
        var annotations = Human.view.annotations.annotations;
        var chapters = Human.timeline.chapters;
        var annotationId;

        for (annotationId in annotations) {
            if (annotations.hasOwnProperty(annotationId)) {
                if (!annotations[annotationId].draggable) {
                    return false;
                }
            }
        }
        for (var chapterId in chapters) {
            if (chapters.hasOwnProperty(chapterId)) {
                annotations = chapters[chapterId].annotations || {};
                for (annotationId in annotations) {
                    if (annotations.hasOwnProperty(annotationId)) {
                        if (!annotations[annotationId].draggable) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;
    }

    function moduleAnnotationsLayoutSet(module) {
        if (!module) {
            return false;
        }
        if (module.annotationsLayout) {
            return true;
        }
        if (module.properties && module.properties["annotations.layout.type"]) {
            return true;
        }
        return false;
    }

})();
;(function() {
    "use strict";

    Human.rpc.define("annotations.getAnnotations",
        function () {
            var annotations = Human.view.annotations.annotations;
            var result = {};
            var a;
            for (var annotationId in annotations) {
                if (annotations.hasOwnProperty(annotationId)) {
                    a = annotations[annotationId];
                    result[annotationId] = {
                        annotationId: a.id || a.annotationId,
                        type: a.type,
                        styleId: a.styleId,
                        objectId: a.object && a.object.objectId,
                        title: a.label.title,
                        description: a.label.description,
                        pos: a.pin.pos,
                        pinVec: a.pin.dir
                    };
                }
            }
            this.setResult(result);
        });

    Human.rpc.define("annotations.create", function (params) {
        var annotation = Human.view.annotations.createAnnotation(params);
        var result = {
            annotationId: annotation.annotationId,
            type: annotation.type,
            objectId: annotation.object ? annotation.object.objectId : "",
            title: annotation.label.title,
            description: annotation.label.description,
            pos: annotation.pin.pos,
            pinVec: annotation.pin.dir
        };
        this.setResult(result);
    });

    Human.rpc.define("annotations.setTitle", function (params) {
        var annotation = Human.view.annotations.annotations[params.annotationId];
        if (annotation) {
            annotation.label.setTitle(params.title);
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.setDescription", function (params) {
        var annotation = Human.view.annotations.annotations[params.annotationId];
        if (annotation) {
            annotation.label.setDescription(params.description);
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.update", function (params) {
        // This will fire an "annotations.updated" event:
        Human.view.annotations.updateAnnotation(params.annotationId, params);
        this.setResult(true);
    });

    Human.rpc.define("annotations.flyTo", function (params) {
        //jshint unused: false

        // TODO: DOES THIS CODE JUST DO NOTHING?

        // var annotation = Human.view.annotations.annotations[params.annotationId];
        // if (annotation) {
        //     var self = this;

        //    Human.view.camera.fly.flyTo({
    
        //    }, function () {
        //        self.setResult(true);
        //    });
        // }
        this.setResult(true);
    });

    //
    // Opens or closes annotations, either per their IDs and/or the IDs of their scene objects.
    //
    Human.rpc.define("annotations.setLabelsShown", function (params) {
        Human.view.annotations.setLabelsShown(params);
        this.setResult(true);
    });

    Human.rpc.define("annotations.setShown", function (params) {
        Human.view.annotations.setShown(params.shown);
        this.setResult(true);
    });

    Human.rpc.define("annotations.destroy", function (params) {
        var annotation = Human.view.annotations.annotations[params.annotationId];
        if (annotation) {
            annotation.destroy();
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.setLabelStyles", function (styles) {
        if (styles.label) {
            $('.annotationContainer').css(styles.label);
        }

        if (styles.title) {
            $('.annotationContainer > .title').css(styles.title);
        }
        
        if (styles.description) {
            $('.annotationContainer > .description').css(styles.description);
        }

        Human.view.annotations.updateDimensions(); //updates width property
        Human.view.annotations.layouts.redrawLayout(); //redraws positions
        this.setResult(true);
    });

    Human.rpc.define("annotations.setPinStyles", function (styles) {
        if (styles.hasOwnProperty('pin')) {
            $('.annotationPin').css(styles.pin);

            if (styles.hasOwnProperty('after')) {
                //can't access :after pseudo element via js, so approximating...
                $('.annotationPin').html('<div class="after"></div>');
                $('.annotationPin > .after').css(styles.after);
            }
        } else {
            $('.annotationPin').css(styles);
        }
        this.setResult(true);
    });

    Human.rpc.define("annotations.setWireStyles", function (styles) {
        $('.annotationWire').css(styles);
        this.setResult(true);
    });
})();
;/**
 * @namespace Focuses the view on specified objects in the 3D scene.
 */
(function () {
    "use strict";

    var HumanViewFocus = Human.view.focus = {};

    var medlineEnabled = true;

    Human.properties.subscribe({
        propId: "data.medline.enabled",
        value: true,
        callback: function (value) {
            medlineEnabled = value;
        }
    });

    var wikipediaEnabled = true;

    Human.properties.subscribe({
        propId: "data.wikipedia.enabled",
        value: true,
        callback: function (value) {
            wikipediaEnabled = value;
        }
    });

    /**
     * Focuses on an {@link Human.scene.Object} in the {@link Human.scene}.
     * <ol>
     * <li>Shows label on object,</li>
     * <li>flies camera to either a) boundary of object,</li>
     * <li>queries data on object from the 3rd-party data sources enabled on {@link Human.data}, and</li>
     * <li>publishes object's new "focused" status in a "focus.objectFocused" event.</li>
     * @function
     * @param {{}} params Focus params
     * @param {String} [params.objectId] ID of object to focus on
     * @param {String} [params.fmaId] FMA ID of object to focus on
     * @param {Boolean} [params.select]
     * @param {Boolean} [params.allSelected]
     * @param {Boolean} [params.newSelected]
     * @param {Boolean} [params.showLabel=true]
     * @param {Boolean} [params.xray]
     * @param {Number} [params.backOff] Camera back-off factor in range of [0..1], when 0 is close (default), 1 is far
     * @param {Function} ok Completion callback
     * @memberof Human.view.focus
     */
    HumanViewFocus.focusObject = function (params, ok) {

        ok = ok || Human._noop;

        var fmaId = params.fmaId;
        var objectId = params.objectId;
        var objectIds = params.objectIds;

        if (!objectId && !fmaId && !objectIds) {

            // Missing params

            Human.log.error("Human.view.focusObject", "Parameter expected: either 'objectId', 'objectIds' or 'fmaId'");
            ok();
            return;
        }

        var scene = Human.scene;

        var object;

        if (objectId) {

            // Focus on object by ID

            object = scene.objects[objectId];

            if (!object) {
                Human.log.error("Human.view.focusObject", "Scene object not found: '" + objectId + "'");
                ok();
                return;
            }

        } else if (fmaId) {

            // Focus on object by FMA ID

            object = scene.objectsByFMAID[fmaId];

            if (!object) {
                Human.log.error("Human.view.focusObject", "Scene object not found for this FMAID: '" + fmaId + "'");
                ok();
                return;
            }

            objectId = object.objectId;
        }

        if (params.xray === true) {

            // X-Ray mode

            Human.rpc.call(null, "xray.setEnabled", { enable: true });

        } else if (params.xray === false) {

            // No X-Ray

            Human.rpc.call(null, "xray.setEnabled", { enable: false });
        }

        var select = params.select;

        if (select === undefined || select === null) {
            select = params.replace || !scene.selectedObjects[objectId];
        } else {
            select = params.select;
        }

        var flyTo = params.flyTo;
        var boundary;

        if (params.replace) {    // Single focus

            scene.setSelectedObjects({
                objectId: objectId,
                select: select,
                replace: params.replace
            });

        } else if (select) {   // Multi focus

            var objects = {};

            objects[objectId] = select;

            scene.setSelectedObjects({
                objects: objects,
                replace: params.replace
            });
        }

        if ((params.showLabel !== false) || !select) {
            Human.view.labels._clearLabels();
        }

        if (params.showLabel !== false) {
            showLabel(params);
        }

        if (select && flyTo === "newSelected") {

            // Get boundary enclosing newly selected objects

            boundary = object.getBoundary();
            if (boundary) {
                Human.view.boundary.setBoundary(boundary, true);     // Show selected object boundary
                Human.view.camera.fly.flyTo({                               // Fly to selected object
                        boundary: boundary,
                        backOff: params.backOff,
                        arc: 0.0,
                        easing: true
                    },
                    function () {
                        Human.view.boundary.setBoundary(false);      // Hide boundary
                        publishObjectFocused(objectId, flyTo);
                        ok();
                    });
            }

        } else if (!flyTo || flyTo === "allSelected") {

            // Get boundary enclosing currently selected objects

            boundary = scene.getBoundary(scene.selectedObjects);
            if (boundary) {
                Human.view.boundary.setBoundary(boundary, true);     // Show selected object boundary
                Human.view.camera.fly.flyTo({                               // Fly to selected object
                        boundary: boundary,
                        backOff: params.backOff,
                        arc: 0.0,
                        easing: true
                    },
                    function () {
                        Human.view.boundary.setBoundary(false);      // Hide boundary
                        if (select) {
                            publishObjectFocused(objectId, flyTo);
                        }
                        ok();
                    });
            } else {

                Human.view.boundary.setBoundary(false);      // Hide boundary

                if (select) {
                    publishObjectFocused(objectId, flyTo);
                }

                ok();
            }

        } else if (flyTo === "selectedLeafObjects") {

            // Fly to leaf objects from among those objects that are currently selected

            Human.view.camera.fly.flyTo({                        // Fly to selected object
                    selectedLeafObjects: true,
                    backOff: params.backOff,
                    arc: 0.0,
                    easing: true
                },
                function () {
                    Human.view.boundary.setBoundary(false);      // Hide boundary
                    if (select) {
                        publishObjectFocused(objectId, flyTo);
                    }
                    ok();
                });

        } else if (flyTo === "object") {

            boundary = object.getBoundary();

            Human.view.boundary.setBoundary(boundary, true);     // Show selected object boundary

            Human.view.camera.fly.flyTo({                               // Fly to selected object
                    boundary: boundary,
                    backOff: params.backOff,
                    arc: 0.0,
                    easing: true
                },
                function () {
                    Human.view.boundary.setBoundary(false);      // Hide boundary
                    if (select) {
                        publishObjectFocused(objectId, flyTo);
                    }
                    ok();
                });
        } else {
            publishObjectFocused(objectId, flyTo);
            ok();
        }
    };


    function showLabel(params) {
        Human.view.labels.createLabel({ objectId: params.objectId, afterDelay: true });
        Human.renderer.forceRenderFrame();
    }

    function publishObjectFocused(objectId, flyTo) {
        var object = Human.scene.objects[objectId];
        if (object) {
            Human.events.fire("focus.objectFocused", {
                objectId: objectId,
                description: object.description,
                flyTo: flyTo
            });
        }
    }

})();;(function() {
	"use strict";

	Human.rpc.define("focus.focusObject",
	    function (params) {
	        var self = this;
	        Human.view.focus.focusObject(
	            params, function () {
	                self.setResult(true);  // Completion RPC result
	            });
	    });
})();
;/** @namespace Manages X-Ray view mode
 */
(function () {
    "use strict";

    var HumanViewXray = Human.view.xray = {};

    HumanViewXray.enabled = false;
    var dirty = true;

    Human.events.on(
        "loaded",
        function () {
            HumanViewXray.enabled = false;
            dirty = false;
        });

    Human.events.on(
        "scene.objectsSelected",
        function () { // Schedule xray for next frame when object selection changes
            if (HumanViewXray.enabled) {
                dirty = true;
            }
        });

    Human.events.on(
        "tick",
        function () {// Apply pending xray for next frame
            if (dirty) {
                xray(HumanViewXray.enabled);
                dirty = false;
            }
        });

    // Applies XRay to enabled model objects, making selected
    // objects opaque and the rest transparent
    function xray(enabled) {
        var model = Human.scene;
        var objects = model.objects;
        var object;
        for (var objectId in objects) { // De-highlight highlighted objects
            if (objects.hasOwnProperty(objectId)) {
                object = objects[objectId];
                if (enabled) { // Do X-ray
                    if (Human.scene.selectedObjects[object.objectId]) { // Opaque
                        object.setXRay(false);
                        object.setHighlight(false);
                    } else { // X-ray
                        object.setXRay(true);
                    }
                } else { // Undo X-ray
                    object.setXRay(false);
                }
            }
        }
    }

    HumanViewXray.setEnabled = function (enable) {
        if (HumanViewXray.enabled !== enable) {
            HumanViewXray.enabled = enable;
            dirty = true;
        }
        Human.events.fire("xray.toggled", { enabled:enable });
        if (HumanViewXray.enabled) {
            Human.view.currentMode = 'Xray';
        }
    };

    HumanViewXray.getEnabled = function () {
        return HumanViewXray.enabled;
    };

})();
;/** @namespace Manages picking of {@link Human.scene.Object}s in the {@link Human.scene}.
 */
(function () {
    "use strict";

    var HumanViewPick = Human.view.pick = {};

    HumanViewPick.singleEnabled = true;
    HumanViewPick.multiEnabled = false;

    /**
     * Always get 3D intersection point when picking.
     * API can set this true so that it always gets the 3D point in "pick.picked" events.
     * @type {boolean}
     */
    var alwaysRayPick = false;

    // Whether picking changes visibility of objects
    Human.properties.subscribe({
        propId: "pick.alwaysRayPick",
        value: alwaysRayPick,
        callback: function (value) {
            alwaysRayPick = value;
        }
    });

    Human.events.on(
        "loaded", // Pick enabled by default
        function () {
            HumanViewPick.setSinglePickEnabled(true); // Notifies of initial state
            HumanViewPick.setMultiPickEnabled(false);
        });

    /** Enables or disables single-pick mode
     * @memberof Human.view.pick
     * @param {Boolean} enable Enables or disables single-pick mode
     */
    HumanViewPick.setSinglePickEnabled = function (enable) {
        if (HumanViewPick.singleEnabled !== enable) {
            HumanViewPick.singleEnabled = enable;
        }
        if (enable) {
            if (HumanViewPick.multiEnabled) {
                HumanViewPick.multiEnabled = false;
            }
            Human.events.fire("pick.multi.toggled", { enabled: HumanViewPick.multiEnabled });
        }
        Human.events.fire("pick.single.toggled", { enabled: HumanViewPick.singleEnabled });
    };

    /** Queries whether or not single-pick mode is enabled
     * @memberof Human.view.pick
     * @returns true if single-pick mode enabled else false
     */
    HumanViewPick.getSinglePickEnabled = function () {
        return HumanViewPick.singleEnabled;
    };

    /** Enables or disables multi-pick mode
     * @memberof Human.view.pick
     * @param {Boolean} enable Enables or disables multi-pick mode
     */
    HumanViewPick.setMultiPickEnabled = function (enable) {
        if (HumanViewPick.multiEnabled !== enable) {
            HumanViewPick.multiEnabled = enable;
        }
        if (enable) {
            if (HumanViewPick.singleEnabled) {
                HumanViewPick.singleEnabled = false;
            }
            Human.events.fire("pick.single.toggled", { enabled: HumanViewPick.singleEnabled });
        }
        Human.events.fire("pick.multi.toggled", { enabled: HumanViewPick.multiEnabled });
    };

    /** Queries whether or not multi-pick mode is enabled
     * @memberof Human.view.pick
     * @returns true if multi-pick mode enabled else false
     */
    HumanViewPick.getMultiPickEnabled = function () {
        return HumanViewPick.multiEnabled;
    };

    HumanViewPick.hoverPick = function (params) {
        return HumanViewPick._pick(params, true, false, false, alwaysRayPick);
    };

    HumanViewPick.hoverOff = function () {
        Human.view.tooltips.clearTooltip();
    };

    HumanViewPick.pick = function (params) {
        return HumanViewPick._pick(params, false, false, false, alwaysRayPick);
    };

    HumanViewPick.doublePick = function (params) {
        return HumanViewPick._pick(params, false, true, false, alwaysRayPick);
    };

    HumanViewPick.queryPick = function (params) {
        return HumanViewPick._pick(params, false, false, true, params.rayPick || alwaysRayPick);
    };

    var lastObject = null;

    /**
     * Performs a pick at the given X,Y canvas coordinates
     * @memberof Human.view.pick
     * @param params
     * @param {Number} params.canvasX Canvas X-coordinate
     * @param {Number} params.canvasY Canvas Y-coordinate
     * @param {Boolean} params.mouseDownLeft True when left mouse key is down
     * @param {Boolean} params.mouseDownRight True when right mouse key is down
     * @param {Boolean} params.spaceDown True when SPACE key is down
     * @param {Boolean} params.ctrlDown True when ALT key is down
     * @param {Boolean} hover Set true to do a hover-pick
     * @param {Boolean} doubleClick Set true to do a "double click" pick
     * @return
     */
    HumanViewPick._pick = function (params, hover, doubleClick, query, rayPick) {

        var canvasX = params.canvasX;
        var canvasY = params.canvasY;
        var mouseDownLeft = params.mouseDownLeft;
        var mouseDownRight = params.mouseDownRight;
        var spaceDown = params.spaceDown;
        var ctrlDown = params.ctrlDown;
        var hit, object, objects, annotation;

        // Querying picked object
        if (query) {
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {
                    var result = Human._apply(hit, {
                        mode: "query",
                        objectId: object.objectId,
                        mouseDownLeft: mouseDownLeft,
                        mouseDownRight: mouseDownRight
                    });
                    Human.events.fire("pick.picked", result);
                    return result;
                } else {
                    return;
                }
            }
            return;
        }

        if (!HumanViewPick.singleEnabled && 
            !HumanViewPick.multiEnabled && 
            !Human.view.dissect.enabled && 
            !Human.view.annotations.enabled && 
            !Human.view.highlight.enabled) {
            return;
        }

        //If test condition has been started. Disable selection of object
        if (Human.scene.checkTestStarted) { // TODO: Code smell!
            return;
        }

        // Hovering
        if (hover) {
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {
                    Human.view.tooltips.setTooltip({
                        objectId: object.objectId,
                        canvasX: canvasX, canvasY: canvasY
                    });
                    var event = Human._apply(hit, {
                        mode: "hover",
                        objectId: object.objectId
                    });
                    Human.events.fire("pick.hoverPicked", event);
                    Human.events.fire("pick.picked", event);
                }
            }
            return;
        }

        // Highlight or XRay mode
        // but do nothing for pick in these modes if in Dissect mode
        if ((Human.view.highlight.enabled || Human.view.xray.enabled) && 
            !Human.view.dissect.enabled && 
            !Human.view.annotations.enabled) {

            if (doubleClick && lastObject) {
                // Scene object double-clicked
                Human.view.focus.focusObject({
                    objectId: lastObject.objectId,
                    replace: HumanViewPick.singleEnabled,
                    showLabel: true,
                    select: true,
                    flyTo: "selectedLeafObjects"
                });
                lastObject = null;
                return;
            }
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {

                    Human.view.annotations.setLabelsShown({
                        objects: {},
                        type: "secondary",
                        replace: true
                    });
                    if (spaceDown) {
                        // SPACE key down
                        objects = {};
                        objects[object.objectId] = true;
                        Human.view.annotations.setLabelsShown({
                            objects: objects,
                            type: "secondary"
                        });
                        return;
                    }

                    if (ctrlDown) {
                        // ALT key down
                        objects = {};
                        objects[object.objectId] = false;
                        Human.view.annotations.setLabelsShown({
                            objects: objects,
                            type: "secondary"
                        });
                        return;
                    }

                    // Scene object picked
                    if (Human.scene.selectedObjects[object.objectId]) {
                        // Object deselected
                        Human.scene.setSelectedObjects({
                            objectId: object.objectId,
                            select: !Human.scene.selectedObjects[object.objectId], // Deselect if currently selected
                            replace: !HumanViewPick.multiEnabled
                        });
                    } else {
                        // Object selected
                        Human.view.focus.focusObject({
                            objectId: object.objectId,
                            showLabel: true,
                            replace: !HumanViewPick.multiEnabled,
                            flyTo: "none"
                        });
                        // Show tooltip
                        Human.view.tooltips.setTooltip({
                            objectId: object.objectId,
                            canvasX: canvasX,
                            canvasY: canvasY
                        });
                    }
                    lastObject = object;
                    Human.events.fire("pick.picked",
                        Human._apply(hit, {
                            mode: Human.view.highlight.enabled ? "highlight" : "xray",
                            objectId: object.objectId,
                            mouseDownLeft: mouseDownLeft,
                            mouseDownRight: mouseDownRight
                        }));
                } else {
                    annotation = Human.view.annotations.annotations[hit.name];
                    if (annotation) {
                        // Annotation pin picked
                        annotation.pin.pick();
                    }
                }
            } else {

                // Pick nothing - clear object selection
                // But not in X-Ray mode, because we don't clear selection
                // in that mode when clicking empty canvas.

                if (!Human.view.xray.enabled) {
                    Human.scene.setSelectedObjects({
                        select: false,
                        replace: true
                    });
                }
            }
        }

        // Isolation mode
        if (Human.view.isolate.enabled && 
            !Human.view.dissect.enabled && 
            !Human.view.annotations.enabled) {
            if (doubleClick && lastObject) {
                // Scene object double-clicked
                Human.view.focus.focusObject({
                    objectId: lastObject.objectId,
                    showLabel: true,
                    select: false,
                    flyTo: "object"
                });
                lastObject = null;
                return;
            }
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {
                    // Object selected
                    Human.view.focus.focusObject({
                        objectId: object.objectId,
                        showLabel: true,
                        select: false,
                        flyTo: "none"
                    });
                    // Show tooltip
                    Human.view.tooltips.setTooltip({
                        objectId: object.objectId,
                        canvasX: canvasX,
                        canvasY: canvasY
                    });
                    lastObject = object;
                    Human.events.fire("pick.picked",
                        Human._apply(hit, {
                            mode: "isolate",
                            objectId: object.objectId
                        }));
                }
            }
        }

        // Dissection mode
        if (Human.view.dissect.enabled && !Human.view.annotations.enabled) {
            if (doubleClick) {
                return;
            }
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {
                    Human.view.dissect.dissect(object.objectId);
                    Human.events.fire("pick.picked",
                        Human._apply(hit, {
                            mode: "dissect",
                            objectId: object.objectId
                        }));
                }
            }
            return;
        }

        // Annotation mode
        if (Human.view.annotations.enabled) {
            if (doubleClick) {
                return;
            }
            rayPick = true; // Find 3D pick point
            hit = Human.renderer.pick(canvasX, canvasY, rayPick);
            if (hit) {
                object = findNamedObject(hit.name);
                if (object) {
                    Human.view.annotations.placer.placeAnnotation({
                        objectId: object.objectId,
                        pos: hit.worldPos
                    });
                    //         Human.view.labels.createLabel({ objectId: object.objectId});
                    Human.events.fire("pick.picked",
                        Human._apply(hit, {
                            mode: "annotation",
                            objectId: object.objectId
                        }));
                } else {
                    annotation = Human.view.annotations.annotations[hit.name];
                    if (annotation) {
                        // Annotation pin picked
                        annotation.pin.pick();
                    }
                }
            }
            return;
        }
    };

    // Given an object ID, find the first object on path to root, including that object,
    // that was given an explicit ID, as opposed to one that was internally generated for the object.
    function findNamedObject(objectId) {
        var object = Human.scene.objects[objectId];
        while (object && object.anonymous) {
            object = object.parent;
        }
        return object;
    }
})();
;/** @namespace Grabs JPEG canvas snapshots
 */
(function () {
    "use strict";

    var HumanViewSnapshot = Human.view.snapshot = {};

    // Property to select MIME type for snapshot images
    var mimeType;

    Human.properties.subscribe({
        propId: "snapshot.mime",
        value: "image/jpeg",
        callback: function (value) {
            mimeType = value;
        }
    });

    var canvasId = "theCanvas";
    var copyrightImagePath = "img/bhuman-logo-powered.png";
    var copyrightImage = new Image();
    var copyrightImageDimensions = { width: 0, height: 0 };
    copyrightImage.onload = function () {
        copyrightImageDimensions.width = copyrightImage.width;
        copyrightImageDimensions.height = copyrightImage.height;
    };
    var queue = []; // Snapshots cannot be taken asynch, so we queue them

    // init copyright logo
    copyrightImage.src = copyrightImagePath;

    /**
    * Grabs a JPEG snapshot of the 3D view.
    *
    * <p>Snapshot requests are queued, so this may be called while other snapshots are still in progress.</p>
    *
    * @memberof Human.view.snapshot
    * @param {*} params
    * @param {Number} params.width Optional snapshot width
    * @param {Number} params.height Optional snapshot height
    * @param {Boolean} params.openInTab Image opened in new tab when true
    * @param {Function} ok Optional method to returns snapshot image
    * @param {Function} error Optional callback to return error message
    */
    HumanViewSnapshot.getSnapshot = function (params, ok, error) {
        if (params.width !== undefined || params.height !== undefined) {
            if (params.width === undefined || params.height === undefined) {
                var msg = "Snapshot failed: incomplete params: both 'width' and 'height' expected";
                if (error) {
                    error(msg);
                    //TODO: IS THIS A BUG? SHOULDN'T FUNCTION RETURN IF ERROR?
                }
            }
        }
        queue.unshift({ params: params, ok: ok });
        nextSnapshot();
    };

    function nextSnapshot() {
        if (queue.length === 0) {
            return;
        }
        var snapshot = queue.pop();
        var params = snapshot.params;
        var ok = snapshot.ok;
        doSnapshot(params,
            function (image) {
//                if (params.openInTab) {
//                    window.open(image.src, "_blank")
//                }
                if (ok) {
                    ok(image);
                }
                nextSnapshot();
            });
    }

    function doSnapshot(params, ok) {
        Human.events.fire("snapshot.started");
        params = params || {};
        var theCanvas = document.getElementById(canvasId);
        var copyright = (params.copyright !== undefined && params.copyright !== null) ? params.copyright : true;
        // scale, unless turned off
        var scale = params.scale !== false;
        // get current canvas dimensions
        var dimensions = getCanvasDimentions(theCanvas);
        var width = dimensions.width;
        var height = dimensions.height;
        // get target snapshot dimensions
        var targetWidth = params.width || width;
        var targetHeight = params.height || height;
        // aspect fix?
        if (targetWidth >= targetHeight) {
            targetHeight = Math.floor(height / width * targetWidth);
        }
        else if (targetWidth < targetHeight) {
            targetWidth = Math.floor(width / height * targetHeight);
        }
        // scaling
        var adjustCanvasScaling = !scale && targetWidth > width || targetHeight > height;
        // color options
        var color = params.color || Human.renderer.bg.bgColor;
        var currentColor = Human.renderer.bg.bgColor; //store current color

        // resize canvas
        if (adjustCanvasScaling) {
            theCanvas.width = targetWidth;
            theCanvas.height = targetHeight;
        }
        // adjust color
        if (color) {
            Human.renderer.bg.setBGColor(color);
        }
        Human.timeline.pause();
        Human.renderer.forceRenderFrame();

        // create output canvas
        var outputCanvas = document.createElement("canvas");
        var outputCanvasContext = outputCanvas.getContext("2d");
        outputCanvas.width = targetWidth;
        outputCanvas.height = targetHeight;

        var theCanvasDimensions = getCanvasDimentions(theCanvas);
        var canvasWidth = theCanvasDimensions.width;
        var canvasHeight = theCanvasDimensions.height;
        // TODO: cropping
        // write canvas

        var bgColor = Human.renderer.bg.bgColors[Human.renderer.bg.bgColor];

        // We'll just to a vertical gradient to begin with
        // and sample just the top-left and bottom-right colors

        var topLeft = bgColor.slice(0, 3);
        var bottomLeft = bgColor.slice(9, 12);

        var rGrad = outputCanvasContext.createLinearGradient(0, 0, 0, outputCanvas.height);
        rGrad.addColorStop(0, cssRGB(topLeft));
        rGrad.addColorStop(1, cssRGB(bottomLeft));
        outputCanvasContext.fillStyle = rGrad;
        outputCanvasContext.fillRect(0,0, outputCanvas.width, outputCanvas.height);

        outputCanvasContext.drawImage(theCanvas, 0, 0, canvasWidth, canvasHeight, 0, 0, targetWidth, targetHeight);

        // write copyright: bottom center
        if (copyright) {
            // write watermark
            var watermarkX = Math.max(15, (targetWidth / 2) - (copyrightImageDimensions.width / 2));
            var watermarkY = Math.max(15, targetHeight - 20 - copyrightImageDimensions.height);

            outputCanvasContext.drawImage(copyrightImage, watermarkX, watermarkY);

            // write copy text
            outputCanvasContext.font = "12pt Arial";
            var copyYear = new Date().getFullYear();
            var copysymbol = String.fromCharCode(169);
            var text = copysymbol + " " + copyYear;
            var textX = targetWidth / 2;
            var textY = watermarkY + copyrightImageDimensions.height + 10;
            outputCanvasContext.fillStyle = "#666666";
            outputCanvasContext.textAlign = 'center';

            outputCanvasContext.fillText(text, textX, textY);
        }

        // Let other engine code modules draw their bits to
        // the snapshot, eg. annotations.
        Human.events.fire("snapshot.rendering", { canvas: outputCanvas, context: outputCanvasContext, bgColor: color });

        // post-render cleanup
        // restore canvas
        if (adjustCanvasScaling) {
            theCanvas.width = width;
            theCanvas.height = height;
        }
        // restore color
        if (color) {
            Human.renderer.bg.setBGColor(currentColor);
        }
        Human.renderer.forceRenderFrame();
        Human.timeline.unpause();

        Human.events.fire("snapshot.finished");

        // get output image
        var outputImage = new Image();
        outputImage.width = targetWidth;
        outputImage.height = targetHeight;
        outputImage.onload = function () {
            // publish snapshot
            ok(outputImage);
        };
        outputImage.src = outputCanvas.toDataURL(mimeType);
    }

    function cssRGB(arr) {
        return "rgb(" + Math.round(arr[0] * 255) + ", " + Math.round(arr[1] * 255) + ", " + Math.round(arr[2] * 255) + ")";
    }

    function getCanvasDimentions(canvas) {
        var RADIX = 10;
        return {
            width: parseInt(canvas.getAttribute("width"), RADIX),
            height: parseInt(canvas.getAttribute("height"), RADIX)
        };
    }

})();;(function() {
	"use strict";

	Human.rpc.define("snapshot.get",
	    function (params) {
	        var self = this;
	        Human.view.snapshot.getSnapshot(params,
	            function (image) {
	                self.setResult(image.src);
	            });
	    });	
})();

;/**
 * @namespace Manages clip planes for cross-section views
 */
(function () {
    "use strict";

    var HumanViewClip = Human.view.clip = {};

    HumanViewClip.LEFT = "left";
    HumanViewClip.RIGHT = "right";
    HumanViewClip.TOP = "top";
    HumanViewClip.BOTTOM = "bottom";
    HumanViewClip.FRONT = "front";
    HumanViewClip.BACK = "back";

    var ready = false;
    var enabled = false;
    var isolating;

    // SceneJS clips node
    var clipsNode;

    var dirty;

    // True while SceneJS clips node is active
    var active = false;

    HumanViewClip.clips = {};

    HumanViewClip.selectedClip = null;

    Human.events.on(
        "loaded",
        function () {
            enabled = false;
            createClipsNode();
        });

    // Creates a clips node in a "library" part of the scene graph,
    // where it will be dormant and not part of the live 3D view
    function createClipsNode() {

        // Create clips node

        var libraryNode = Human.renderer.getNode("assetLibraryRoot");

        if (!libraryNode) {
            Human.log.error("Human.view.clip.createClipsNode", "Scene node not found: 'assetlibraryRoot'");
            return;
        }

        clipsNode = libraryNode.addNode({
            type: "clips",
            clips: [
                {
                    mode: "disabled", x: -1.0, y: 0.0, z: 0.0// left
                },
                {
                    mode: "disabled", x: 1.0, y: 0.0, z: 0.0 // right
                },
                {
                    mode: "disabled", x: 0.0, y: -1.0, z: 0.0 // bottom
                },
                {
                    mode: "disabled", x: 0.0, y: 1.0, z: 0.0 // top
                },
                {
                    mode: "disabled", x: 0.0, y: 0.0, z: -1.0 // front
                },
                {
                    mode: "disabled", x: 0.0, y: 0.0, z: 1.0 // back
                }
            ]
        });

        // Create clipping planes

        HumanViewClip.clips = {};

        createClip({ index: 0, type: HumanViewClip.LEFT, clipId: HumanViewClip.LEFT, state: "dormant", progress: 0.0, color: { r: 0.3, g: 0.3, b: 0.8 } });
        createClip({ index: 1, type: HumanViewClip.RIGHT, clipId: HumanViewClip.RIGHT, state: "dormant", progress: 0.0, color: { r: 0.3, g: 0.3, b: 0.8 } });
        createClip({ index: 2, type: HumanViewClip.TOP, clipId: HumanViewClip.TOP, state: "dormant", progress: 0.0, color: { r: 0.3, g: 0.3, b: 0.8 } });
        createClip({ index: 3, type: HumanViewClip.BOTTOM, clipId: HumanViewClip.BOTTOM, state: "dormant", progress: 0.0, color: { r: 0.3, g: 0.3, b: 0.8 } });
        createClip({ index: 4, type: HumanViewClip.FRONT, clipId: HumanViewClip.FRONT, state: "dormant", progress: 0.0, color: { r: 0.3, g: 0.3, b: 0.8 } });
        createClip({ index: 5, type: HumanViewClip.BACK, clipId: HumanViewClip.BACK, state: "dormant", progress: 0.0, color: { r: 0.3, g: 0.3, b: 0.8 } });

        // Updates are sent to front plane by default
        HumanViewClip.selectClip("front");
    }

    Human.events.on(
        "tick",
        function () {
            if (dirty) {
                HumanViewClip._updateClipForIsolatedObjects();
                dirty = false;
            }
        });

    /**
     * Toggle clipability of selected objects
     */
    HumanViewClip._updateClipForIsolatedObjects = function () {
        var objects = Human.scene.objects;
        var selectedObjects = Human.scene.selectedObjects;

        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                objects[objectId].setClippable(!!selectedObjects[objectId] ? false : true);
            }
        }
    };

    /**
     * Hide visible clip planes again whenever the renderer goes back to sleep
     */
    Human.events.on(
        "Scene.Sleep",
        function () {
            var plane;
            for (var clipId in HumanViewClip.clips) {
                if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                    plane = HumanViewClip.clips[clipId];
                    if (plane.state === Human.view.clip.Plane.STATE_VISIBLE) {
                        if (plane.framesUntilHide > 0) {
                            plane.framesUntilHide--;
                        } else {
                            Human.view.clip.setClip({
                                clipId:plane.clipId,
                                state:Human.view.clip.Plane.STATE_CLIPPING
                            });
                        }
                    }  
                }
                
            }
        });

    Human.events.on(
        "scene.objectsSelected", // Track the set of currently selected objects
        function () {
            dirty = true;
        });

    Human.events.on(
        "isolate.toggled",
        function (params) {
            isolating = params.enabled;
            dirty = true;
        });

    function createClip (params) {

        if (HumanViewClip.clips[params.clipId]) {
            HumanViewClip.clips[params.clipId]._destroy();
        }

        params.onUpdate = function (clip) {
            HumanViewClip._onUpdate(clip);
        };

        var plane = HumanViewClip.clips[params.clipId] = new Human.view.clip.Plane(params);

        /* Optional immediate transition into non-dormant state
         */
        if (params.state && params.state !== Human.view.clip.Plane.STATE_DORMANT) {
            HumanViewClip.setClip(params);
        }

        /* Optional immediate progress setting
         */
        if (params.progress) {
            plane._setProgress(params.progress);
        }
    }

    HumanViewClip._onUpdate = function (clip) {

        var clips = {};

        clips["" + clip.index] = {
            x:clip.x,
            y:clip.y,
            z:clip.z,
            dist:clip.dist,
            mode:clip.clipping ? "inside" : "disabled"
        };

        clipsNode.setClips(clips);
    };

    /** Returns true if given plane ID matches a built-in plane
     */
    HumanViewClip._isReservedClip = function (clipId) {
        return (clipId === HumanViewClip.LEFT ||
            clipId === HumanViewClip.RIGHT ||
            clipId === HumanViewClip.TOP ||
            clipId === HumanViewClip.BOTTOM ||
            clipId === HumanViewClip.FRONT ||
            clipId === HumanViewClip.BACK);
    };

    /**
     * Set state of existing clip plane.
     * Type change is ignored.
     *
     */
    HumanViewClip.setClip = function (params) {
        var clip;
        if (!params.clipId) {
            if (HumanViewClip.selectedClip) {
                clip = HumanViewClip.selectedClip;
            } else {
                Human.log.error("Human.view.clip.setClip", "Parameter expected: 'clipId'");
                return;
            }
        } else {
            clip = HumanViewClip.clips[params.clipId];
            if (!clip) {
                Human.log.error("Human.view.clip.setClip", "Clip plane not found: '" + params.clipId + "'");
                return;
            }
        }

        if (params.state &&
            params.state !== Human.view.clip.Plane.STATE_DORMANT &&
            params.state !== Human.view.clip.Plane.STATE_ACTIVE &&
            params.state !== Human.view.clip.Plane.STATE_CLIPPING &&
            params.state !== Human.view.clip.Plane.STATE_VISIBLE) {
            Human.log.error("Human.view.clip.setClip", "State not recognized: '" + params.state + "'");
            return;
        }

        var oldState = clip.state;
        var newState = params.state || oldState;

        switch (newState) {
            case Human.view.clip.Plane.STATE_DORMANT:

                clip._setClipping(false);
                clip._setVisible(false);

                break;

            case Human.view.clip.Plane.STATE_ACTIVE:

                HumanViewClip._configureClip(clip, params);

                clip._setClipping(false);
                clip._setVisible(false);

                break;

            case Human.view.clip.Plane.STATE_CLIPPING:

                clip._setClipping(true);
                clip._setVisible(false);

                switch (oldState) {
                    case Human.view.clip.Plane.STATE_DORMANT:
                        HumanViewClip._configureClip(clip, params);
                        break;

                    default:
                        if (params.progress) {
                            clip._setProgress(params.progress);
                        }
                        if (params.color) {
                            clip._setColor(params.color);
                        }
                }
                break;

            case Human.view.clip.Plane.STATE_VISIBLE:

                clip._setClipping(true);
                clip._setVisible(true);

                switch (oldState) {
                    case Human.view.clip.Plane.STATE_DORMANT:
                        HumanViewClip._configureClip(clip, params);
                        break;

                    default:
                        if (params.progress) {
                            clip._setProgress(params.progress);
                        }
                        if (params.color) {
                            clip._setColor(params.color);
                        }
                }
                break;
        }

        clip.state = newState;

        // Notify of new clip plane state
        Human.events.fire("clip.updated", {
            clipId: clip.clipId,
            state: clip.state, // "dormant", "active", "clipping", "visible"
            progress: clip.progress // "left", "right", "top", "bottom", "front", "back"
        });

        // Activate clips node only if clipping is now visibly in effect
        // otherwise disable it
        activateClipsIfNeeded();
    };

    HumanViewClip._configureClip = function (clip, params) {
        var boundary;

        params = params || {};

        if (!params.pos) {
            boundary = Human.scene.getBoundary();
        }

        var xCenter = (boundary.xmin + boundary.xmax) * 0.5;
        var yCenter = (boundary.ymin + boundary.ymax) * 0.5;
        var zCenter = (boundary.zmin + boundary.zmax) * 0.5;

        var pos;
        var dir;
        var size;
        var range;

        switch (clip.type) {

            case HumanViewClip.LEFT:

                pos = {
                    x:boundary.xmax,
                    y:yCenter,
                    z:zCenter
                };
                dir = {
                    y:1,
                    angle:-90.0
                };
                size = {
                    x:(boundary.zmax - boundary.zmin),
                    y:(boundary.ymax - boundary.ymin)
                };
                range = {
                    min:boundary.xmin,
                    max:boundary.xmax
                };
                break;

            case HumanViewClip.RIGHT:

                pos = {
                    x:boundary.xmin,
                    y:yCenter,
                    z:zCenter
                };
                dir = {
                    y:1,
                    angle:90.0
                };
                size = {
                    x:(boundary.zmax - boundary.zmin),
                    y:(boundary.ymax - boundary.ymin)
                };
                range = {
                    min:boundary.xmin,
                    max:boundary.xmax
                };
                break;

            case HumanViewClip.FRONT:

                pos = {
                    x:-xCenter,
                    y:yCenter,
                    z:boundary.zmin
                };
                dir = {
                    y:1,
                    angle:0.0
                };
                size = {
                    x:(boundary.xmax - boundary.xmin),
                    y:(boundary.ymax - boundary.ymin)
                };
                range = {
                    min:boundary.zmin,
                    max:boundary.zmax
                };
                break;

            case HumanViewClip.BACK:

                pos = {
                    x:xCenter,
                    y:yCenter,
                    z:boundary.zmax
                };
                dir = {
                    y:1,
                    angle:180.0
                };
                size = {
                    x:(boundary.xmax - boundary.xmin),
                    y:(boundary.ymax - boundary.ymin)
                };
                range = {
                    min:boundary.zmin,
                    max:boundary.zmax
                };
                break;

            case HumanViewClip.TOP:

                pos = {
                    x:xCenter,
                    y:boundary.ymax,
                    z:zCenter
                };
                dir = {
                    x:1,
                    angle:90.0
                };
                size = {
                    x:(boundary.xmax - boundary.xmin),
                    y:(boundary.zmax - boundary.zmin)
                };
                range = {
                    min:boundary.ymin,
                    max:boundary.ymax
                };
                break;

            case HumanViewClip.BOTTOM:

                pos = {
                    x:xCenter,
                    y:boundary.ymin,
                    z:zCenter
                };
                dir = {
                    x:1,
                    angle:-90.0
                };
                size = {
                    x:(boundary.xmax - boundary.xmin),
                    y:(boundary.zmax - boundary.zmin)
                };
                range = {
                    min:boundary.ymin,
                    max:boundary.ymax
                };
                break;

            default:

                // TODO: Align to vectored position on sphere when no pos given

                pos = params.pos;
                dir = params.dir;
                size = params.size;
                range = params.range;
                break;
        }

        clip._setPos(pos);
        clip._setDir(dir);
        clip._setRange(range);
        clip._setProgress(params.progress || 0);
        clip._setSize(size);

        if (params.color) {
            clip._setColor(params.color);
        }
    };

    // Activates the clips node if any clip planes are in effect, otherwise deactivates it
    function activateClipsIfNeeded() {
        var plane;
        for (var clipId in HumanViewClip.clips) {
            if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                plane = HumanViewClip.clips[clipId];
                if (plane.state !== Human.view.clip.Plane.STATE_DORMANT && plane.progress !== 0) {
                    activateClipsNode();
                    return;
                }
            }
        }
        deactivateClipsNode();
    }

    // Moves the clips node from the dormant "library" part of the scene graph
    // into the "live" part so that it then clips the 3D scene
    function activateClipsNode() {

       // window.console.log("activating");

        if (active) {
            return;
        }

        // Insert clips node above content root
        var contentRootNode = Human.renderer.getContentRootNode();
        var parent = contentRootNode.parent;
        var children = parent.disconnectNodes();
        clipsNode.disconnect();
        clipsNode.addNodes(children);
        parent.addNode(clipsNode);

        active = true;
    }

    // Moves the clips node from the "live" part of the scene graph
    // back into the dormant "library" part so that it then no longer clips the 3D scene
    function deactivateClipsNode() {

       // window.console.log("deactivating");

        if (!active) {
            return;
        }

        // Extract clips node from scene graph,
        // moving its children up to its parent
        clipsNode.splice();

        // Insert clips node into scene graph's library subgraph
        var libraryNode = Human.renderer.getNode("assetLibraryRoot");

        if (!libraryNode) {
            Human.log.error("Human.view.clip.deactivateClipsNode", "Scene node not found: 'assetlibraryRoot'");
            return;
        }

        libraryNode.addNode(clipsNode);

        active = false;
    }

    /**
     * Selects a clip as the default fallback for setClip.
     * Call with null to stop using clip.
     */
    HumanViewClip.selectClip = function (clipId) {
        var clip;
        if (clipId) {
            clip = HumanViewClip.clips[clipId];
            if (!clip) {
                Human.log.error("Human.view.clip.selectClip", "Clip plane not found: '" + clipId + "'");
                return;
            }
        }
        HumanViewClip.selectedClip = clip;
    };

    /**
     * Destroys a custom clip plane - rejects destruction of built-in clip
     */
    HumanViewClip.destroyClip = function (clipId) {
        if (HumanViewClip._isReservedClip(clipId)) {
            Human.log.error("Human.view.clip.destroyClip", "Not allowed to destroy built-in plane with clipId: '" + clipId + "'");
            return;
        }
        HumanViewClip.clips[clipId]._destroy();
        delete HumanViewClip.clips[clipId];
        if (HumanViewClip.selectedClip === clipId) {
            HumanViewClip.selectedClip = null;
        }
    };

    /**
     * Reset cross-sections - destroy custom clips, reset built-in clips to inital dormant state
     */
    HumanViewClip.reset = function () {

        var clip;
        for (var clipId in HumanViewClip.clips) {    // Reset build-in clips
            if (HumanViewClip.clips.hasOwnProperty(clipId)) {
                if (!HumanViewClip._isReservedClip(clipId)) {
                    HumanViewClip.destroyClip(clipId);
                } else {
                    clip = HumanViewClip.clips[clipId];
                    Human.view.clip.setClip({
                        clipId:clip.clipId,
                        state:Human.view.clip.Plane.STATE_DORMANT
                    });
                    HumanViewClip._configureClip(clip);      // Reset clips' position, dir, progress etc
                }
            }
        }

        if (ready) {
            HumanViewClip.selectClip("front");
        }

        Human.events.fire("CrossSections.Reset");
    };
})();;(function() {
    // jshint camelcase: false, newcap: false
    // ^ Have to turn these off because of SceneJS variables.

    "use strict";

    /**
     *
     * @param cfg
     * @constructor
     * @private
     */

    var indicatorMat = Human.math.mat4();
    var clipMat = Human.math.mat4();

    Human.view.clip.Plane = function(cfg) {

        this.index = cfg.index;

        this.clipId = cfg.clipId;
        this.type = cfg.type;
        this.state = Human.view.clip.Plane.STATE_DORMANT;
        this.framesUntilHide = 1;  // Number of SLEEPS this frame is allowed to remain in STATE_VISIBLE

        var pos = cfg.pos || {};
        this.pos = {
            x: pos.x || 0.0,
            y: pos.y || 0.0,
            z: pos.z || 0.0
        };

        var dir = cfg.dir || {};
        this.dir = {
            x: dir.x || 0.0,
            y: dir.y || 0.0,
            z: dir.z || 0.0,
            angle: dir.angle || 0.0
        };

        var size = cfg.size || {};
        this.size = {
            x: size.x || 10.0,
            y: size.y || 10.0
        };

        var range = cfg.range || {};
        this.range = {
            min: range.min || 0.0,
            max: range.max || 0.0
        };

        var color = cfg.color || {};
        this.color = {
            r: color.r !== undefined ? color.r : 0.3,
            g: color.g !== undefined ? color.g : 0.3,
            b: color.b !== undefined ? color.b : 0.3
        };

        this.progress = cfg.progress || 0; // In range of [0.0 - 1.0]

        var indicatorFlagsId = cfg.clipId + ".indicator.flags";
        var indicatorXFormId = cfg.clipId + ".indicator.xf";

        var indicatorColorId = cfg.clipId + ".indicator.color";

        this.visible = cfg.visible || false;
        this.clipping = cfg.clipping || false;

        this._onUpdate = cfg.onUpdate;

        Human.renderer.getNode(Human.CLIP_INDICATORS_ATTACH_ID).addNode({
            type: "flags",
            id: indicatorFlagsId,

            flags: {
                enabled: this.visible,
                transparent: true,
                backfaces: false
            },

            nodes: [
                {
                    type: "xform",
                    id: indicatorXFormId,

                    nodes: [

                        /* Solid plane
                         */
                        {
                            type:           "material",
                            emit:           0.9,
                            id:             indicatorColorId,
                            baseColor:      { r: 0.3, g: 0.3, b: 0.8 },
                            specularColor:  { r: 0.3, g: 0.3, b: 0.8 },
                            specular:       0.0,
                            shine:          100.0,
                            alpha:          0.2,

                            nodes:[
                                {
                                    type: "geometry",
                                    source: {
                                        type: "box",
                                        xSize: 1.0,
                                        ySize: 1.0,
                                        zSize: 0.0001
                                    }
                                }
                            ]
                        },

                        /* Plane outline
                         */
                        {
                            type:           "material",
                            emit:           0.9,
                            baseColor:      this.color,
                            specularColor:  this.color,
                            specular:       0.0,
                            shine:          100,
                            alpha:          0.9,

                            nodes:[
                                {
                                    type: "geometry",
                                    primitive: "lines",
                                    positions : [
                                        1.0,  1.0,  1.0,
                                        1.0, -1.0,  1.0,
                                        -1.0, -1.0,  1.0,
                                        -1.0,  1.0,  1.0,
                                        1.0,  1.0, -1.0,
                                        1.0, -1.0, -1.0,
                                        -1.0, -1.0, -1.0,
                                        -1.0,  1.0, -1.0
                                    ],
                                    indices : [ 0, 1, 1, 2, 2, 3, 3, 0 ]
                                }
                            ]
                        }
                    ]
                }
            ]
        });

        this.indicatorXFormNode = Human.renderer.getNode(indicatorXFormId);
        this.indicatorFlagsNode = Human.renderer.getNode(indicatorFlagsId);
        this.indicatorColorNode = Human.renderer.getNode(indicatorColorId);

        this._updatePosition();
    };

    Human.view.clip.Plane.prototype._updatePosition = function() {

        Human.math.identityMat4(indicatorMat);

        Human.math.mulMat4(indicatorMat, Human.math.translationMat4v([this.pos.x, this.pos.y, this.pos.z]), indicatorMat);
        Human.math.mulMat4(indicatorMat, Human.math.rotationMat4v(this.dir.angle * Math.PI / 180.0, [this.dir.x, this.dir.y, this.dir.z]), indicatorMat);
        Human.math.mulMat4(indicatorMat, Human.math.translationMat4v([0, 0,  this.range.min + (this.progress * 2 * (this.range.max - this.range.min))]), indicatorMat);
        Human.math.mulMat4(indicatorMat, Human.math.scalingMat4v([this.size.x * 0.5, this.size.y * 0.5, 0]), indicatorMat);

        this.indicatorXFormNode.setElements(indicatorMat);

        Human.math.identityMat4(clipMat);

        Human.math.mulMat4(clipMat, Human.math.translationMat4v([this.pos.x, this.pos.y, this.pos.z]), clipMat);
        Human.math.mulMat4(clipMat, Human.math.rotationMat4v(this.dir.angle * Math.PI / 180.0, [this.dir.x, this.dir.y, this.dir.z]), clipMat);
        Human.math.mulMat4(clipMat, Human.math.translationMat4v([0, 0,  this.range.min + (this.progress * 2 * (this.range.max - this.range.min))]), clipMat);
        Human.math.mulMat4(clipMat, Human.math.scalingMat4v([this.size.x * 0.5, this.size.y * 0.5, 0]), clipMat);

        var a = SceneJS_math_transformPoint3(clipMat, [-1,-1,0]);
        var b = SceneJS_math_transformPoint3(clipMat, [ 1,-1,0]);
        var c = SceneJS_math_transformPoint3(clipMat, [ 1, 1,0]);

        var normal = SceneJS_math_normalizeVec3(
                SceneJS_math_cross3Vec4(
                        SceneJS_math_normalizeVec3(
                                SceneJS_math_subVec3(b, a, [0,0,0]), [0,0,0]),
                        SceneJS_math_normalizeVec3(
                                SceneJS_math_subVec3(b, c, [0,0,0]), [0,0,0])));

        var dist = SceneJS_math_dotVector3(normal, a);

        this.x = normal[0];
        this.y = normal[1];
        this.z = normal[2];
        this.dist = dist;

        this._onUpdate(this);
    };

    /** States a Plane can be in
     */
    Human.view.clip.Plane.STATE_DORMANT = "dormant";    // Existing but not associated with selected objects
    Human.view.clip.Plane.STATE_ACTIVE = "active";      // Associated with selected objects but not clipping them
    Human.view.clip.Plane.STATE_CLIPPING = "clipping";  // Clipping the selected objects
    Human.view.clip.Plane.STATE_VISIBLE = "visible";    // Clipping and visible

    Human.view.clip.Plane.prototype._setPos = function(pos) {
        pos = pos || {};
        this.pos = {
            x: pos.x || 0.0,
            y: pos.y || 0.0,
            z: pos.z || 0.0
        };
        this._updatePosition();
    };

    Human.view.clip.Plane.prototype._setDir = function(dir) {
        dir = dir || {};
        this.dir = {
            x: dir.x || 0.0,
            y: dir.y || 0.0,
            z: dir.z || 0.0,
            angle: dir.angle || 0.0
        };
        this._updatePosition();
    };

    Human.view.clip.Plane.prototype._setRange = function(range) {
        range = range || {};
        this.range = {
            min: range.min || 0.0,
            max: range.max || 0.0
        };
        this._setProgress(0.0);
        this._updatePosition();
    };

    Human.view.clip.Plane.prototype._setProgress = function(progress) {
        if (this.progress === progress) {
            return;
        }
        if (progress < 0.0) {
            progress = 0.0;
            this._setClipping(false);
        } else if (progress > 1.0) {
            progress = 1.0;
            this._setClipping(false);
        } else {
            this._setClipping(true);
        }
        this.progress = progress;
        this._updatePosition();
    };

    Human.view.clip.Plane.prototype._setSize = function(size) {
        size = size || {};
        this.size = {
            x: size.x || 10.0,
            y: size.y || 10.0
        };
        this._updatePosition();
    };

    Human.view.clip.Plane.prototype._setColor = function(color) {
        color = color || {};
        this.color = {
            r: color.r !== undefined ? color.r : 0.3,
            g: color.g !== undefined ? color.g : 0.3,
            b: color.b !== undefined ? color.b : 0.3
        };
        this.indicatorColorNode
                .setBaseColor(this.color)
                .setSpecularColor(this.color);
    };

    Human.view.clip.Plane.prototype._setVisible = function(visible) {
        this.framesUntilHide = visible ? 1 : 0;
        if (this.visible === visible) {
            return;
        }
        this.persist = false;
        var flags = this.indicatorFlagsNode.get("flags" );
        flags.enabled = visible;
        this.indicatorFlagsNode.set("flags", flags);
        this.visible = visible;
    };

    Human.view.clip.Plane.prototype._setMode = function(mode) {
        if (this.mode === mode) {
            return;
        }
        this.mode = mode;
        this._onUpdate(this);
    };

    Human.view.clip.Plane.prototype._setClipping = function(clipping) {
        if (this.clipping === clipping) {
            return;
        }
        this.clipping = clipping;
        this._onUpdate(this);
    };

    Human.view.clip.Plane.prototype._destroy = function() {
        this.clipPosNode.destroy();
        this.indicatorPosNode.destroy();
    };
})();

;(function() {
    "use strict";

    Human.rpc.define("clip.set",
        function (params) {
            if (params.clips) {
                var clips = params.clips;
                var clip;
                for (var clipId in clips) {
                    if (clips.hasOwnProperty(clipId)) {
                        clip = clips[clipId];
                        clip.clipId = clipId;
                        Human.view.clip.setClip(clip);   
                    }
                }
            } else if (params.clip) {
                Human.view.clip.setClip(params.clip);
            }
        });

    Human.rpc.define("clip.reset",
        function () {
            Human.view.clip.reset();
        });

})();
;(function () {
    "use strict";

    var HumanViewSpinner = Human.view.spinner = {}; 

    var loaderImage;
    HumanViewSpinner.shown = false;

    Human.events.on("loaded",
        function () {
            var loaderImageId = "human-embed-progress";
            var loaderImagePath = "Images/large-loader.gif";
            loaderImage = document.getElementById(loaderImageId);
            if (loaderImage === null || loaderImage === undefined) {
                loaderImage = new Image();
                loaderImage.id = loaderImageId;
                loaderImage.src = loaderImagePath;
                loaderImage.alt = "Loading...";
                var loaderImageStyles = {
                    "display": "none",
                    "position": "absolute",
                    "top": "50%",
                    "left": "50%",
                    "zIndex": "1001",
                    "width": "64px",
                    "height": "64px",
                    "marginLeft": "-32px",
                    "marginTop": "-32px"
                };
                for (var k in loaderImageStyles) {
                    if (loaderImageStyles.hasOwnProperty(k)) {
                        loaderImage.style[k] = loaderImageStyles[k];                        
                    }
                }
                document.body.appendChild(loaderImage);
            }
        });

    HumanViewSpinner.setShown = function (show) {
        if (HumanViewSpinner.shown !== show && loaderImage) {
            loaderImage.style.display = show ? "inline-block" : "none";
        }
    };

})();
;/**

 @namespace Dynamic lighting support

 <p>Usage:</p>

 <pre>

 // Add some lights

 Human.view.lights.addLight({
                lightId: "light0",
                displayName: "Default ambient",
                description: "Default ambient light source",
                params: {
                    mode: "ambient",
                    color: { r: 0.15, g: 0.15, b: 0.15 },
                    diffuse: true
                }
            });

 Human.view.lights.addLight({
                lightId: "light1",
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 0.15, g: 0.15, b: 0.2 },
                    dir: { x: -0.3, y: 0.4, z: 0.5 },
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

 Human.view.lights.addLight({
                lightId: "light2",
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "point",
                    color: { r: 1.3, g: 1.3, b: 1.2 },
                    pos: { x: -1.0, y: 0.0, z: 1.0},
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

 // Enable and disable lights in a batch

 Human.view.lights.setEnabled({
        lights: {
            "light0": true,
            "light1": true,
            "light2": false
        },
        replace: true // Disable all previously active lights
 });

 // Set light parameters in a batch

 Human.view.lights.setParams({
        "light0": {
            dir: { x: 0.2, y: 0.1, z: -0.2
        },
        "light2": {
            pos: { x: 0, y: 10, z: -20,
            color: { r: .9, g: 0.2, b: 1.0 }
        }
    });

 // Remove a light

 Human.view.lights.removeLight("light0");

 </pre>
 */
(function () {
    "use strict";

    var HumanViewLights = Human.view.lights = {};

    /**
     * Lights mapped to their IDs
     *
     * @type {{String:Human.view.lights.Light}}
     */
    HumanViewLights.lights = {};

    // True when lights in the scene graph need to be rebuilt
    var dirty = false;

    // Create default lights once engine code has loaded, all enabled
    Human.events.on("loaded",
        function () {

            // Need one ambient light
            HumanViewLights.addLight({
                lightId: "light0",
                enabled: true,
                displayName: "Default ambient",
                description: "Default ambient light source",
                params: {
                    mode: "ambient",
                    color: { r: 0.15, g: 0.15, b: 0.15 },
                    diffuse: true
                }
            });

//            // Add directional lights
//            HumanViewLights.addLight({
//                lightId: "light1",
//                enabled: true,
//                displayName: "Default directional",
//                description: "Default directional light source",
//                params: {
//                    mode: "dir",
//                    color: { r: 0.15, g: 0.15, b: 0.2 },
//                    dir: { x: -0.3, y: 0.4, z: 0.5 },
//                    diffuse: true,
//                    specular: true,
//                    space: "view"
//                }
//            });

            HumanViewLights.addLight({
                lightId: "light2",
                enabled: true,
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 1.3, g: 1.3, b: 1.2 },
                    dir: { x: -1.0, y: 0.0, z: 1.0},
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

            HumanViewLights.addLight({
                lightId: "light3",
                enabled: true,
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 0.5, g: 0.5, b: 0.5 },
                    dir: { x: 1.1, y: 0, z: 1},
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });

            HumanViewLights.addLight({
                lightId: "light4",
                enabled: true,
                displayName: "Default directional",
                description: "Default directional light source",
                params: {
                    mode: "dir",
                    color: { r: 1.1, g: 1.1, b: 1.05},
                    dir: { x: -0.05, y: 0, z: -1.0 },
                    diffuse: true,
                    specular: true,
                    space: "view"
                }
            });


        });

    // Lazy-rebuild the lights in the scene graph on next tick
    Human.events.on("tick",
        function () {
            if (dirty) {
                rebuildScene();
            }
        });

    function rebuildScene() {

        var scene = Human.renderer.getScene();

        // Get lights container node
        scene.getNode("lights",
            function (container) {

                // Get subtree of that, which contains the scene content
                scene.getNode("lights.subtree",
                    function (subtree) {

                        // Disconnect scene content
                        subtree.disconnect();

                        // Blow away lights node
                        container.removeNodes();

                        // Accumulate enabled light sources in array
                        var _lights = [];
                        var count = 0;
                        var maxLights = 4; // TODO: use WebGL query within SceneJS, ie. myScene.getMaxLights() ?
                        var light;
                        var warnedTooManyLights = false;
                        var lightId;

                        for (lightId in HumanViewLights.lights) {
                            if (HumanViewLights.lights.hasOwnProperty(lightId)) {

                                light = HumanViewLights.lights[lightId];

                                if (light.enabled) {
                                    if (light.params) {

                                        // Lights use 'varying' types in shader
                                        // Prevent attempt to use too many of those
                                        if (light.mode !== "ambient") {
                                            if (++count > maxLights) {
                                                if (!warnedTooManyLights) {
                                                    Human.log.warn("Human.view.lights.rebuildScene", "Tried to activate too many lights - max allowed is " + maxLights + " - only enabling that many");
                                                    warnedTooManyLights = true;
                                                }
                                                continue;
                                            }
                                        }

                                        _lights.push(light.params || {});
                                    }
                                }
                            }
                        }

                        // Rebuild light node

                        var node = container.addNode({
                            type: "lights",
                            lights: _lights.slice(0),
                            nodes: [
                                {
                                    id: "lightsSubTree"
                                }
                            ]
                        });

                        // Link light elements back to the node
                        // to assist with dynamic update

                        count = 0;

                        for (lightId in HumanViewLights.lights) {
                            if (HumanViewLights.lights.hasOwnProperty(lightId)) {
                                if (count++ < maxLights) {
                                    light = HumanViewLights.lights[lightId];
                                    light.node = node;
                                    light.index = count;
                                } else {
                                    light.node = null;
                                    light.index = -1;
                                }
                            }
                        }


                        scene.getNode("lightsSubTree",
                            function (leaf) {
                                leaf.addNode(subtree);
                                Human.renderer.forceRenderFrame();
                            });
                    });
            });

        dirty = false;
    }

    /**
     * Adds a light
     * @param params
     */
    HumanViewLights.addLight = function (params) {
        var light = new Human.view.lights.Light(params);
        HumanViewLights.lights[params.lightId] = light;
        light.on("enabled",
            function () {
                dirty = true;
            });
        dirty = true;
    };

    /**
     * Removes a light
     * @param lightId ID of light to remove
     */
    HumanViewLights.removeLight = function (lightId) {
        if (HumanViewLights.lights[lightId]) {
            delete HumanViewLights.lights[lightId];
            dirty = true;
        }
    };

    /**
     * Removes all lights
     */
    HumanViewLights.removeAllLights = function () {
        HumanViewLights.lights = {};
        dirty = true;
    };

    /**
     * Enables or disables one or more lights
     *
     * <p>Examples:</p>
     *
     * <pre>
     *
     *  Human.view.lights.setEnabled({
     *      lightId: "myLight",
     *      enable: true
     *  });
     *
     *  Human.view.lights.setEnabled({
     *      lights: {
     *          "myLight": true,
     *          "myOtherlight": false
     *      },
     *      replace: true // Disable any lights that are previously enabled
     *  });
     * </pre>
     * @param params
     */
    HumanViewLights.setEnabled = function (params) {
        // Option to replace the set of enabled lights
        if (params.replace) {
            HumanViewLights.clearEnabled();
        }
        var lightId;
        var light;
        if (params.lightId) {
            lightId = params.lightId;
            light = HumanViewLights.lights[lightId];
            if (!light) {
                Human.log.error("Human.view.lights.setEnabled", "Light not found: " + lightId);
                return;
            }
            light.enabled = !!params.enable;
        } else if (params.lights) {
            var lights = params.lights;
            var val;
            for (lightId in lights) {
                if (lights.hasOwnProperty(lightId)) {
                    light = HumanViewLights.lights[lightId];
                    if (!light) {
                        Human.log.error("Human.view.lights.setEnabled", "Light not found: " + lightId);
                        continue;
                    }
                    val = lights[lightId];
                    light.enabled = !!val;
                    if (val && typeof val !== "boolean") {
                        // Light params given
                        light.setParams(val);
                    }
                }
            }
        }
        dirty = true;
    };

    /**
     * Disables all lights
     */
    HumanViewLights.clearEnabled = function () {
        for (var lightId in HumanViewLights.lights) {
            if (HumanViewLights.lights.hasOwnProperty(lightId)) {
                HumanViewLights.lights[lightId].setEnabled(false);
            }
        }
        dirty = true;
    };

    /**
     * Sets parameters for lights
     * @param params
     */
    HumanViewLights.setParams = function (params) {
        var light;
        for (var lightId in params) {
            if (params.hasOwnProperty(lightId)) {
                light = HumanViewLights.lights[lightId];
                if (!light) {
                    Human.log.error("Human.view.lights.setParams", "Light not found: " + lightId);
                    continue;
                }
                light.setParams(params[lightId]);
            }
        }
    };

})();;(function() {
    "use strict";

    
    /**
     * @class A rendering post-light within {@link Human.view.lights}
     * @param cfg
     * @constructor
     */
    Human.view.lights.Light = function (cfg) {

        // Call parent class Human.Component init
        this._init();

        /**
         * Display name for this light
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /**
         * Description of this light
         * @type {String}
         */
        this.description = cfg.description;

        /** ID of this light, unique within {@link Human.view.lights}
         * @type {String}
         */
        this.lightId = cfg.lightId;

        /**
         * True when light is enabled
         * @type {boolean}
         */
        this.enabled = !!cfg.enabled;

        /**
         * Light parameters
         * @type {{}}
         */
        this.params = cfg.params || {};

        /**
         * Target scene node for this light, non-null while the light is active.
         * @type {SceneJS.Node}
         */
        this.node = null;

        /**
         * Index of light on the target scene node, valid while light active
         * @type {number}
         */
        this.index = 0;
    };

    Human.utils.extend(Human.view.lights.Light, Human.Component);

    /**
     * Enables or disables this light
     * @memberof Human.view.lights.Light
     */
    Human.view.lights.Light.prototype.setEnabled = function (enabled) {
        this.publish("enabled", this.enabled = enabled);
    };


    /**
     * Configures this light
     * @memberof Human.view.lights.Light
     */
    Human.view.lights.Light.prototype.setParams = function (params) {
        Human._apply(params, this.params);
        if (this.node) {
            // Light is currently enabled, update its scene node
            var p = {};
            p["" + this.index] = params;
            this.node.setLights(p);
        }
    };

})();




;(function() {
    "use strict";

    /**
     * @namespace Loads and unloads lights to and from {@link Human.view.lights}.
     *
     * Loads lights in batches for models (states). When loading a batch, will immediately enable those lights, then
     * push a record of those lights onto a stack.
     *
     * After unloading a batch of lights for a model, will remove that batch from the stack, then
     * enable the batch (if any) that remains on the top of the stack.
     *
     * @private
     */
    Human.view.lights.loader = new Human.utils.Loader();

    /**
     * Records what's loaded with #load so it can be unloaded with #unload
     * @type {Array}
     * @private
     */
    Human.view.lights.loader._loadedStack = [];

    /**
     * Loads a lights library
     * @param moduleId
     * @param modelId
     * @param libraryId Library ID, unique within namespace of the configured stateId
     * @param params Params for loading
     * @param ok Success
     * @param error Failure
     */
    Human.view.lights.loader.load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localLibraryId = libraryId;
        var globalLibraryId = modelId + "." + libraryId;
        var light;
        var self = this;

        Human.net.getLightsLibrary(
            localLibraryId,
            function (manifest) {

                var lights = manifest.lights;

                if (!lights) {
                    Human.log.error("Human.view.lights.loader.load", "'lights' section expected in lights library");
                    ok();
                    return;
                }

                // Disable any lights already enabled
                Human.view.lights.clearEnabled();

                // Add the batch and enable them, record them in stack

                var loaded = {
                    modelId: modelId,
                    lights: []
                };

                for (var i = 0, len = lights.length; i < len; i++) {
                    light = lights[i];
                    // Skip invalid lights
                    if (!light.lightId) {
                        Human.log.error("Human.view.lights.loader.load", "'lightId' missing on light");
                        continue;
                    }
                    light.lightId = globalLibraryId + "." + light.lightId;
                    light.enabled = true;
                    loaded.lights.push(light);
                    Human.view.lights.addLight(light);
                }

                self._loadedStack.push(loaded);

                ok();
            },
            function (err) {
                error("failed to load manifest file for lights module '" + localLibraryId + "': " + err.errorText + " - status: " + err.request.status);
            });
    };

    /**
     * Unloads a lights library for a model
     * @param modelId
     * @private
     */
    Human.view.lights.loader.unload = function (modelId) {

        // Find the light batch for the given model, remove them from the stack
        var loadedLights;
        var lights, flags;
        var i, len;

        for (i = 0, len = this._loadedStack.length; i < len; i++) {
            if (this._loadedStack[i].modelId === modelId) {
                loadedLights = this._loadedStack[i].lights;
                this._loadedStack.splice(i);
            }
        }

        // No lights were loaded for the given model, warn and bail
        if (!loadedLights) {
            Human.log.warn("Human.view.lights.loader.unload", "Failed to unload lights for model: " + modelId + " - not found");
            return;
        }

        // Remove the lights for the model
        for (i = 0, len = loadedLights.length; i < len; i++) {
            Human.view.lights.removeLight(loadedLights[i].lightId);
        }

        // If light stack not empty, then among the light batches remaining, enable most recently added
        // Otherwise if light stack empty, enable whatever lights exist

        if (this._loadedStack.length > 0) {
            lights = this._loadedStack[this._loadedStack.length - 1].lights;
            flags = {};
            for (i = 0, len = lights.length; i < len; i++) {
                flags[lights[i].lightId] = true;
            }
            Human.view.lights.setEnabled({
                lights: flags,
                replace: true
            });
        } else {
            lights = Human.view.lights.lights;
            flags = {};
            for (var lightId in lights) {
                if (lights.hasOwnProperty(lightId)) {
                    flags[lightId] = true;
                }
            }
            Human.view.lights.setEnabled({
                lights: flags,
                replace: true
            });

        }
    };

})();
;(function() {
    "use strict";

    
    /**
     * Queries what lights exist
     */
    Human.rpc.define("lights.getLights",
        function () {
            var result = [];
            var light;
            var lights = Human.view.lights.lights;
            for (var lightId in lights) {
                if (lights.hasOwnProperty(lightId)) {
                    light = lights[lightId];
                    result.push({
                        lightId: lightId,
                        displayName: light.displayName,
                        description: light.description,
                        enabled: light.enabled,
                        params: light.params
                    });
                }
            }
            this.setResult(result);
        });

    /**
     * Enables or disables lights
     */
    Human.rpc.define("lights.setEnabled",
        function (params) {
            Human.view.lights.setEnabled(params);
        });

    /**
     * Sets parameters for lights
     */
    Human.rpc.define("lights.setParams",
        function (params) {
            Human.view.lights.setParams(params);
        });
})();
;/**

 Post-effect pipeline

 <pre>

 //----------------------------------------------------------------------------
 // Build the pipeline
 //----------------------------------------------------------------------------

 // Add depth-of-field blur
 Human.view.effects.addEffect({
                effectId: "dof",                // Unique ID to assign
                type: "postprocess/dof",        // SceneJS node to use for this effect
                displayName: "Depth-of-field",
                description: "Simulates photographic depth-of-field",
                params: {
                    texelSize: 0.00022,             // Size of one texel (1 / width, 1 / height)
                    blurCoeff: 0.0084,	            // Calculated from the blur equation, b = ( f * ms / N )
                    autofocus: true                 // Automatically synch focusDist to "cameras/pickFlyOrbit"
                }
            });

 // Film grain effect
 Human.view.effects.addEffect({
                effectId: "filmGrain",
                type: "postprocess/filmGrain",
                displayName: "Film Grain",
                description: "Film grain noise"
            });

 // Sepia effect
 Human.view.effects.addEffect({
                effectId: "sepia",
                type: "postprocess/sepia",
                displayName: "Sepia",
                description: "Sepia color filter"
            });

 //----------------------------------------------------------------------------
 // Enable effects
 //----------------------------------------------------------------------------

 // Enable "sepia" and "dof", disable "filmGrain"
 Human.view.effects.setEnabled({
                effectIds: {
                    "sepia": true,
                    "dof": true,
                    "filmGrain": false
                },
                replace: true
        });

 //----------------------------------------------------------------------------
 // Set effect parameters
 //----------------------------------------------------------------------------

 // Set parameters for depth-of-field effect
 Human.view.effects.setParams({
        "dof": {
            "PPM": 100000,
            "blurCoeff" : 0.001
        }
    });
 </pre>
 */
(function () {
    "use strict";

    var HumanViewEffects = Human.view.effects = {};

    /**
     * Effects in the order in which they will be applied
     *
     * @type {[Human.view.effects.Effect]}
     */
    HumanViewEffects.pipeline = [];

    /**
     * Effects mapped to their IDs
     *
     * @type {{String:Human.view.effects.Effect}}
     */
    HumanViewEffects.effects = {};


    // True when effects pipeline in the
    // scene graph needs to be rebuilt
    var dirty = false;

    // Set up the effects pipeline once the engine code has loaded
    Human.events.on("loaded",
        function () {

            // These must be added in the order in which they
            // should be applied with respect to one another

            // Depth-of-field blur
            HumanViewEffects.addEffect({
                effectId: "dof",                // Unique ID to assign
                type: "postprocess/dof",        // SceneJS node to use for this effect
                displayName: "Depth-of-field",
                description: "Simulates photographic depth-of-field",

                // Effect parameters
                params: {
                    texelSize: 0.00022,             // Size of one texel (1 / width, 1 / height)
                    blurCoeff: 0.0084,	            // Calculated from the blur equation, b = ( f * ms / N )
                    ppm: 10000.0,
                    autofocus: true                 // Automatically synch focusDist to "cameras/pickFlyOrbit"
                }
            });

            // Sepia effect
            HumanViewEffects.addEffect({
                effectId: "sepia",
                type: "postprocess/sepia",
                displayName: "Sepia",
                description: "Sepia color filter"
            });

            // Scanlines effect
            HumanViewEffects.addEffect({
                effectId: "scanlines",
                type: "postprocess/scanlines",
                displayName: "Scanlines",
                description: "Scan lines pattern"
            });

            // Film grain effect
            HumanViewEffects.addEffect({
                effectId: "filmGrain",
                type: "postprocess/filmGrain",
                displayName: "Film Grain",
                description: "Film grain noise"
            });

            // Technicolor effect
            HumanViewEffects.addEffect({
                effectId: "technicolor",
                type: "postprocess/technicolor",
                displayName: "Technicolor",
                description: "Technicolor color filter"
            });

            // Oculus Rift
            HumanViewEffects.addEffect({
                effectId: "oculusRift",
                type: "effects/oculusRift",
                displayName: "Oculus Rift",
                description: "View using Oculus Rift",
                params: {
                    eyeSep: 20.6,
                    focalLength: 27
                }
            });

            // Stereo
            HumanViewEffects.addEffect({
                effectId: "stereo",
                type: "effects/stereo",
                displayName: "Stereo",
                description: "View in stereo"
            });

            // Anaglyph
            HumanViewEffects.addEffect({
                effectId: "anaglyph",
                type: "effects/anaglyph",
                displayName: "Anaglyph 3D",
                description: "View in Anaglyph 3D"
            });
        });

    // Lazy-rebuild the effect nodes in the scene graph
    Human.events.on("tick",
        function () {
            if (dirty) {
                rebuildScene();
            }
        });

    function rebuildScene() {
        // Get effects container node
        var scene = Human.renderer.getScene();
        scene.getNode("effect",
            function (container) {
                // Get subtree of that, which contains the scene content
                scene.getNode("effect.subtree",
                    function (subtree) {
                        // Disconnect scene content
                        subtree.disconnect();
                        // Blow away effect nodes
                        container.removeNodes();
                        // Rebuild effect nodes
                        var effect;
                        var json = {
                            nodes: []
                        };
                        var node = json;
                        for (var i = 0, len = HumanViewEffects.pipeline.length; i < len; i++) {
                            effect = HumanViewEffects.pipeline[i];
                            if (effect.enabled) {
                                var child = Human._applyIf(effect.params, {
                                    type: effect.type,
                                    id: "__effects." + effect.effectId,
                                    nodes: []
                                });
                                node.nodes.push(child);
                                node = child;

                                // Save scene node on effect for param updates
                                // See {@link Human.effects.Effect#setParams}
                                scene.getNode("__effects." + effect.effectId,
                                    createEffectCallback(effect));
                            } else {

                                // No scene nodes exist for disabled effects
                                effect.node = null;
                            }
                        }
                        // Append scene content to lowest effect node, thus applying
                        // all the effects to it, in order of each effect on the path
                        // up to the scene root
                        node.nodes.push({ id: "effectsSubTree" });
                        container.addNode(json);
                        scene.getNode("effectsSubTree",
                            function (leaf) {
                                leaf.addNode(subtree);
                                Human.renderer.forceRenderFrame();
                            });
                    });
            });
        dirty = false;
    }

    /**
     * Adds a effect
     * @param params
     * @returns {Human.view.effects.Effect}
     */
    HumanViewEffects.addEffect = function (params) {
        var effect = new Human.view.effects.Effect(params);
        HumanViewEffects.effects[params.effectId] = effect;
        HumanViewEffects.pipeline.unshift(effect);
        effect.on("enabled",
            function () {
                dirty = true;
            });
        dirty = true;
    };

    /**
     * Enables or disables effects
     *
     * <p>Examples:</p>
     *
     * <pre>
     *
     *  Human.view.effects.setEnabled({
     *      effectId: "dof",
     *      enable: true
     *  });
     *
     *  Human.view.effects.setEnabled({
     *      effectIds: {
     *          "dof": true,
     *          "blur": false
     *      }
     *  });
     * </pre>
     * @param params
     */
    HumanViewEffects.setEnabled = function (params) {

        var effectId;

        // Option to replace the set of enabled effects
        if (params.replace) {
            for (var i = 0, len = HumanViewEffects.pipeline.length; i < len; i++) {
                HumanViewEffects.pipeline[i].enabled = false;
            }
        }
        var effect;
        if (params.effectId) {
            effectId = params.effectId;
            effect = HumanViewEffects.effects[effectId];
            if (!effect) {
                Human.log.error("Human.view.effects.setEnabled", "Effect not found: " + effectId);
                return;
            }
            effect.enabled = !!params.enable;
        } else if (params.effectIds) {
            var effectIds = params.effectIds;
            var val;
            for (effectId in effectIds) {
                if (effectIds.hasOwnProperty(effectId)) {
                    effect = HumanViewEffects.effects[effectId];
                    if (!effect) {
                        Human.log.error("Human.view.effects.setEnabled", "Effect not found: " + effectId);
                        continue;
                    }
                    val = effectIds[effectId];
                    effect.enabled = !!val;
                    if (val && typeof val !== "boolean") {
                        // Effect params given
                        effect.setParams(val);
                    }
                }
            }
        }
        dirty = true;
    };

    /**
     * Disables all effects
     */
    HumanViewEffects.clearEnabled = function () {
        for (var i = 0, len = HumanViewEffects.pipeline.length; i < len; i++) {
            HumanViewEffects.pipeline[i].enabled = false;
        }
        dirty = true;
    };

    /**
     * Sets parameters for effects
     * @param params
     */
    HumanViewEffects.setParams = function (params) {
        var effect;
        for (var effectId in params) {
            if (params.hasOwnProperty(effectId)) {
                effect = HumanViewEffects.effects[effectId];
                if (!effect) {
                    Human.log.error("Human.view.effects.setParams", "Effect not found: " + effectId);
                    continue;
                }
                effect.setParams(params[effectId]);
            }
        }
    };

    function createEffectCallback(effect) {
        return function (node) {
            effect.node = node;
        };
    }

})();;(function() {
    "use strict";


    /**
     * @class A rendering post-effect within {@link Human.view.effects}
     * @param cfg
     * @constructor
     */
    Human.view.effects.Effect = function (cfg) {

        // Call parent class Human.Component init
        this._init();

        /** ID of this effect, unique within {@link Human.view.effects}
         * @type {String}
         */
        this.effectId = cfg.effectId;

        /** Type name of this effect
         * @type {String}
         */
        this.type = cfg.type;

        /**
         * Display name for this effect
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /**
         * Description of this effect
         * @type {String}
         */
        this.description = cfg.description;

        /**
         *
         * @type {boolean}
         */
        this.enabled = false;

        /**
         * Effect parameters
         * @type {{}}
         */
        this.params = cfg.params || {};

        /**
         * Scene node for this effect, non-null while the effect is active.
         * @type {SceneJS.Node}
         */
        this.node = null;
    };

    Human.utils.extend(Human.view.effects.Effect, Human.Component);

    /**
     * Enables or disables this effect
     * @memberof Human.view.effects.Effect
     */
    Human.view.effects.Effect.prototype.setEnabled = function (enabled) {
        this.publish("enabled", this.enabled = enabled);
    };


    /**
     * Configures this effect
     * @memberof Human.view.effects.Effect
     */
    Human.view.effects.Effect.prototype.setParams = function (params) {
        Human._apply(params, this.params);
        if (this.node) {
            // Effect is currently active, update its scene node
            this.node.set(params);
        }
    };

})();
;(function() {
    "use strict";

    
    /**
     * Queries what effects exist
     */
    Human.rpc.define("effects.getEffects",
        function () {
            var result = [];
            var effect;
            var effects = Human.view.effects.effects;
            for (var effectId in effects) {
                if (effects.hasOwnProperty(effectId)) {
                    effect = effects[effectId];
                    result.push({
                        effectId: effectId,
                        displayName: effect.displayName,
                        description: effect.description,
                        enabled: effect.enabled,
                        params: effect.params
                    });
                }
            }
            this.setResult(result);
        });

    /**
     * Enables or disables effects
     */
    Human.rpc.define("effects.setEnabled",
        function (params) {
            Human.view.effects.setEnabled(params);
        });

    /**
     * Sets parameters for effects
     */
    Human.rpc.define("effects.setParams",
        function (params) {
            Human.view.effects.setParams(params);
        });
})();
;/**
 * @namespace
 */
(function () {
    "use strict";

    var HumanInput = Human.input = {};

    var canvas = $("#annotationCanvas");
    var handlers = [];
    var tickSubs = [];
    var keyDownSubs = {};
    var keyUpSubs = {};
    var mouseDownSubs = [];
    var mouseUpSubs = [];
    var mouseDoubleClickSubs = [];
    var mouseMoveSubs = [];
    var mouseWheelSubs = [];
    var resetSubs = [];
    var enabled = true;

    // TOUCH
    var touchStartSubs = [];
    var touchMoveSubs = [];
    var touchPinchSubs = [];
    var touchZoomSubs = [];
    var touchPanSubs = [];
    var touchEndSubs = [];
    var touchTapSubs = [];
    var touchDoubleTapSubs = [];
    var TAP_INTERVAL = 250;
    var DBL_TAP_INTERVAL = 250;

    jQuery(document).ready(function () {
        jQuery("body").bind(
                (jQuery.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection",
            function (event) {
                //our only change is to prevent selection for everything, except input fields, selectable
                //TODO: seems unnecessary, actually...Chrome/Firefox don't seem to be throwing this for text input fields
                if (event.target.tagName.toLowerCase() !== "input" &&
                    event.target.tagName.toLowerCase() !== "email" &&
                    event.target.tagName.toLowerCase() !== "text" &&
                    event.target.tagName.toLowerCase() !== "textarea") {
                    event.preventDefault();
                }
            });

        // Disable context menu throughout document.
        jQuery(document).bind("contextmenu", function (event) {
            //Well, except for the snapshot image and text fields.
            if (event.target.id !== "snapshotPanelImage" &&
                event.target.type !== "input" &&
                event.target.type !== "email" &&
                event.target.type !== "text" &&
                event.target.type !== "textarea") {
                return false;
            }
        });
    });

    // Context given to each handler
    var ctx = {

        // True when ALT down
        altDown: false,

        // True when CTL down
        ctrlDown: false,

        // Flag for each key currently down
        keyDown: [],

        // Subscribe to periodic engine tick event
        onTick: function (fn) {
            tickSubs.push(fn);
        },

        // Subscribe to key down event
        onKeyDown: function (keys, fn) {
            var key;
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                (keyDownSubs[key] || (keyDownSubs[key] = [])).push(fn);
            }
        },

        // Subscribe to key up event
        onKeyUp: function (keys, fn) {
            var key;
            for (var i = 0, len = keys.length; i < len; i++) {
                key = keys[i];
                (keyUpSubs[key] || (keyUpSubs[key] = [])).push(fn);
            }
        },

        // Subscribe to mouse down event
        onMouseDown: function (fn) {
            mouseDownSubs.push(fn);
        },

        // Subscribe to mouse up event
        onMouseUp: function (fn) {
            mouseUpSubs.push(fn);
        },

        // Subscribe to mouse doubleClick event
        onMouseDoubleClick: function (fn) {
            mouseDoubleClickSubs.push(fn);
        },

        // Subscribe to mouse move event
        onMouseMove: function (fn) {
            mouseMoveSubs.push(fn);
        },

        // Subscribe to mouse wheel event
        onMouseWheel: function (fn) {
            mouseWheelSubs.push(fn);
        },

        // Subscribe to reset
        onReset: function (fn) {
            resetSubs.push(fn);
        },

        // Subscribe to touch start
        onTouchStart: function (fn) {
            touchStartSubs.push(fn);
        },

        // Subscribe to touch move
        onTouchMove: function (fn) {
            touchMoveSubs.push(fn);
        },

        // Subscribe to touch end
        onTouchEnd: function (fn) {
            touchEndSubs.push(fn);
        },

        // Subscribe to touch tap
        onTouchTap: function (fn) {
            touchTapSubs.push(fn);
        },
        onTouchDoubleTap: function (fn) {
            touchDoubleTapSubs.push(fn);
        },
        onTouchPinch: function (fn) {
            touchPinchSubs.push(fn);
        },
        onTouchZoom: function (fn) {
            touchZoomSubs.push(fn);
        },
        onTouchPan: function (fn) {
            touchPanSubs.push(fn);
        }
    };

    var lastTime = null;
    Human.events.on(
        "tick",
        function () {
            if (!enabled) {
                lastTime = null;
                return;
            }
            var time = (new Date()).getTime() / 1000;
            if (lastTime !== null) {
                var elapsed = time - lastTime;
                for (var i = 0, len = tickSubs.length; i < len; i++) {
                    tickSubs[i](time, elapsed);
                }
            }
            lastTime = time;
        });

    // Block input while processes are running
    var numProcesses = 0;
    Human.events.on("processes.started",
        function () {
            if (++numProcesses === 1) {
                HumanInput.setEnabled(false);
            }
        });
    Human.events.on("processes.finished",
        function () {
            if (--numProcesses === 0) {
                HumanInput.setEnabled(true);
            }
        });
    Human.events.on("processes.failed",
        function () {
            if (--numProcesses === 0) {
                HumanInput.setEnabled(true);
            }
        });

    document.addEventListener("keydown",
        function (e) {
            if (!enabled) {
                return;
            }
            if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                ctx.ctrlDown = e.ctrlKey || e.keyCode === 17 || e.metaKey; // !important, treat Windows or Mac Command Key as ctrl
                ctx.altDown = e.altKey || e.keyCode === 18;
                ctx.keyDown[e.keyCode] = true;
                var code = e.keyCode;
                var subs = keyDownSubs[code];
                if (subs) {
                    for (var i = 0, len = subs.length; i < len; i++) {
                        subs[i](code);
                    }
                }
            }
        }, true);

    document.addEventListener("keyup",
        function (e) {
            if (!enabled) {
                return;
            }
            if (e.target.tagName !== "INPUT" && e.target.tagName !== "TEXTAREA") {
                if (e.ctrlKey || e.keyCode === 17) {
                    ctx.ctrlDown = false;
                }
                if (e.altKey || e.keyCode === 18) {
                    ctx.altDown = false;
                }
                ctx.keyDown[e.keyCode] = false;
                var code = e.keyCode;
                var subs = keyUpSubs[code];
                if (subs) {
                    for (var i = 0, len = subs.length; i < len; i++) {
                        subs[i](code);
                    }
                }
            }
        });

    canvas.mousedown(
        function (e) {
            switch (e.which) {
                case 1: // Left button
                    ctx.mouseDownLeft = true;
                    break;
                case 2: // Middle/both buttons
                    ctx.mouseDownMiddle = true;
                    break;
                case 3: // Right button
                    ctx.mouseDownRight = true;
                    break;
                default:
                    break;
            }
            var coords = getClickCoordsWithinElement(e);
            ctx.mouseDownX = coords.x;
            ctx.mouseDownY = coords.y;
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseDownSubs.length; i < len; i++) {
                mouseDownSubs[i](x, y);
            }
        });

    canvas.mouseup(
        function (e) {
            switch (e.which) {
                case 1: // Left button
                    ctx.mouseDownLeft = false;
                    break;
                case 2: // Middle/both buttons
                    ctx.mouseDownMiddle = false;
                    break;
                case 3: // Right button
                    ctx.mouseDownRight = false;
                    break;
                default:
                    break;
            }
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseUpSubs.length; i < len; i++) {
                mouseUpSubs[i](x, y);
            }
        });

    canvas.dblclick(
        function (e) {
            switch (e.which) {
                case 1: // Left button
                    ctx.mouseDownLeft = false;
                    ctx.mouseDownRight = false;
                    break;
                case 2: // Middle/both buttons
                    ctx.mouseDownMiddle = false;
                    break;
                case 3: // Right button
                    ctx.mouseDownLeft = false;
                    ctx.mouseDownRight = false;
                    break;
                default:
                    break;
            }
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseDoubleClickSubs.length; i < len; i++) {
                mouseDoubleClickSubs[i](x, y);
            }
        });

    canvas.mousemove(
        function (e) {
            var coords = getClickCoordsWithinElement(e);
            var x = coords.x;
            var y = coords.y;
            for (var i = 0, len = mouseMoveSubs.length; i < len; i++) {
                mouseMoveSubs[i](x, y);
            }
        });

    canvas.bind("mousewheel",
        function (event, d) {
            for (var i = 0, len = mouseWheelSubs.length; i < len; i++) {
                mouseWheelSubs[i](event, d);
            }
        });

    function getClickCoordsWithinElement(event) {
        var coords = { x: 0, y: 0 };
        if (!event) {
            event = window.event;
            coords.x = event.x;
            coords.y = event.y;
        }
        else {
            var element = event.target;
            var totalOffsetLeft = 0;
            var totalOffsetTop = 0;

            while (element.offsetParent) {
                totalOffsetLeft += element.offsetLeft;
                totalOffsetTop += element.offsetTop;
                element = element.offsetParent;
            }
            coords.x = event.pageX - totalOffsetLeft;
            coords.y = event.pageY - totalOffsetTop;
        }
        return coords;
    }

    /* TOUCH SUPPORT */
    // todo: messy, needs cleanup
    var isTouchEnabled = !!("ontouchstart" in window);
    if (isTouchEnabled) {
        var Y_PAN_DEGREES = 15;
        var X_PAN_DEGREES = 75;
        var tapStart;
        var downTouches = [];
        var tapDownTime = null;
        var startPosition = null;
        var stopPosition = null;
        var pinchZoomActive = false;
        var multiCoordinates = [];
        var distanceX = 0;
        var distanceY = 0;
        var speed = 0;
        var panning = false;

        // touchstart touchmove touchend
        var touchContainer = document.getElementById("container");
        touchContainer.addEventListener("touchstart", onTouchEvent, false);
        touchContainer.addEventListener("touchmove", onTouchEvent, false);
        touchContainer.addEventListener("touchend", onTouchEvent, false);
    }

    /**
    * Add a handler
    * @param handler
    */
    HumanInput.addHandler = function (Handler) {
        handlers.push(new Handler(ctx));
    };

    /**
    * Enables or disables user input
    */
    HumanInput.setEnabled = function (enable) {
        if (enabled !== enable) {
            if (enable) {
                // Block/unblock Ui using the jQuery blockUI plugin
                $.unblockUI();
            } else {
                // Invisible overlay because our progress bar would be dimmed otherwise
                // Disable blockUI's popup
                $.blockUI({ overlayCSS: { opacity: 0 }, message: "" });
            }
            enabled = enable;
            Human.events.fire(enable ? "inputEnabled" : "inputDisabled", {});
        }
    };

    function toCoordiantes(touches) {
        var coordinates = [];
        for (var i = 0, length = touches.length; i < length; i++) {
            var touch = touches[i];
            coordinates.push({ x: touch.pageX, y: touch.pageY });
        }
        return coordinates;
    }

    function onTouchEvent(e) {
        // prevent bubble up
        e.preventDefault();
        e.stopPropagation();
        // dispatch messages
        var subs = [];
        var tap = false;
        var dblTap = false;
        var xDelta = 0;
        var yDelta = 0;
        var elapse = 0;
        var xSpeed = 0;
        var ySpeed = 0;

        // normalize touch coordiantes
        var touches = e.touches;
        var coordinates = toCoordiantes(touches);
        var i;

        switch (e.type) {
            case "touchstart":
                tapStart = new Date().getTime();
                downTouches.length = 0;
                downTouches = downTouches.concat(coordinates);
                startPosition = coordinates[0];
                // pinch-zoom start
                pinchZoomActive = coordinates.length === 2;
                if (pinchZoomActive) {
                    multiCoordinates = coordinates;
                }
                else {
                    subs.push(touchStartSubs);
                    multiCoordinates = [];
                }
                panning = false;
                break;
            case "touchmove":
                // pinch-zoom active
                pinchZoomActive = coordinates.length === 2 && multiCoordinates.length === 2;
                // process pinch/zoom
                if (pinchZoomActive) {
                    // compare to prev action
                    var deltaOneX = Math.abs(multiCoordinates[0].x - multiCoordinates[1].x);
                    var deltaOneY = Math.abs(multiCoordinates[0].y - multiCoordinates[1].y);
                    var deltaTwoX = Math.abs(coordinates[0].x - coordinates[1].x);
                    var deltaTwoY = Math.abs(coordinates[0].y - coordinates[1].y);
                    xDelta = coordinates[0].x - multiCoordinates[0].x;
                    yDelta = coordinates[0].y - multiCoordinates[0].y;
                    distanceX = Math.abs(coordinates[0].x - coordinates[1].x);
                    distanceY = Math.abs(coordinates[0].y - coordinates[1].y);
                    // angle in radians
                    // angle in degrees
                    var angleDeg = Math.atan2(deltaTwoY, deltaTwoX) * 180 / Math.PI;
                    // determine panning
                    panning = angleDeg <= Y_PAN_DEGREES || angleDeg > X_PAN_DEGREES;
                    if (panning) {
                        subs.push(touchPanSubs);
                    }
                    // pinch
                    else if (deltaTwoX < deltaOneX && deltaTwoY < deltaOneY) {
                        subs.push(touchPinchSubs);
                    }
                    // zoom
                    else if (deltaTwoX > deltaOneX && deltaTwoY > deltaOneY) {
                        subs.push(touchZoomSubs);
                    }
                    // update multi position
                    multiCoordinates = coordinates.concat([]);
                }
                // standard cursor move
                else {
                    subs.push(touchMoveSubs);
                    multiCoordinates = [];
                }
                stopPosition = coordinates[0];
                break;
            case "touchend":
                var currentTime = new Date().getTime();
                tap = (currentTime - tapStart) < TAP_INTERVAL && multiCoordinates.length <= 1;
                elapse = currentTime - tapStart;
                if (multiCoordinates.length <= 1) {
                    subs.push(touchEndSubs);
                }
                // check double tap
                if (tap) {
                    // if first tap, set inital wait
                    if (tapDownTime === null) {
                        tapDownTime = currentTime;
                    }
                    // check if double tap threshold met
                    else {
                        dblTap = downTouches.length === 1 && (currentTime - tapDownTime) < DBL_TAP_INTERVAL;
                        tapDownTime = null;
                    }
                }
                else {
                    dblTap = false;
                    tapDownTime = null;
                }
                // check speed
                if (multiCoordinates.length !== 2) {
                    xDelta = stopPosition.x - startPosition.x;
                    yDelta = stopPosition.y - startPosition.y;
                    // s = d/t
                    xSpeed = Math.abs(xDelta) / elapse;
                    ySpeed = Math.abs(yDelta) / elapse;
                }
                else {
                    speed = 0;
                }

                startPosition = null;
                // pinch-zoom end
                pinchZoomActive = false;
                break;
            default:
                break;
        }
        for (i = 0; i < subs.length; i++) {
            var _subs = subs[i];
            // dispatch messages
            for (var j = 0; j < _subs.length; j++) {
                _subs[j]({
                    touches: coordinates,
                    xDelta: xDelta,
                    yDelta: yDelta,
                    distanceX: distanceX,
                    distanceY: distanceY,
                    elapse: elapse,
                    xSpeed : xSpeed,
                    ySpeed : ySpeed
                });
            }
            // dispatch tap
            if (tap) {
                for (i = 0; i < touchTapSubs.length; i++) {
                    touchTapSubs[i]({ touches: downTouches });
                }
                tap = false;
            }
            if (dblTap) {
                for (i = 0; i < touchTapSubs.length; i++) {
                    touchDoubleTapSubs[i]({ touches: downTouches });
                }
                dblTap = false;
            }
        }

    }

    // Key codes

    HumanInput.KEY_BACKSPACE = 8;
    HumanInput.KEY_TAB = 9;
    HumanInput.KEY_ENTER = 13;
    HumanInput.KEY_SHIFT = 16;
    HumanInput.KEY_CTRL = 17;
    HumanInput.KEY_ALT = 18;
    HumanInput.KEY_PAUSE_BREAK = 19;
    HumanInput.KEY_CAPS_LOCK = 20;
    HumanInput.KEY_ESCAPE = 27;
    HumanInput.KEY_PAGE_UP = 33;
    HumanInput.KEY_PAGE_DOWN = 34;
    HumanInput.KEY_END = 35;
    HumanInput.KEY_HOME = 36;
    HumanInput.KEY_LEFT_ARROW = 37;
    HumanInput.KEY_UP_ARROW = 38;
    HumanInput.KEY_RIGHT_ARROW = 39;
    HumanInput.KEY_DOWN_ARROW = 40;
    HumanInput.KEY_INSERT = 45;
    HumanInput.KEY_DELETE = 46;
    HumanInput.KEY_NUM_0 = 48;
    HumanInput.KEY_NUM_1 = 49;
    HumanInput.KEY_NUM_2 = 50;
    HumanInput.KEY_NUM_3 = 51;
    HumanInput.KEY_NUM_4 = 52;
    HumanInput.KEY_NUM_5 = 53;
    HumanInput.KEY_NUM_6 = 54;
    HumanInput.KEY_NUM_7 = 55;
    HumanInput.KEY_NUM_8 = 56;
    HumanInput.KEY_NUM_9 = 57;
    HumanInput.KEY_A = 65;
    HumanInput.KEY_B = 66;
    HumanInput.KEY_C = 67;
    HumanInput.KEY_D = 68;
    HumanInput.KEY_E = 69;
    HumanInput.KEY_F = 70;
    HumanInput.KEY_G = 71;
    HumanInput.KEY_H = 72;
    HumanInput.KEY_I = 73;
    HumanInput.KEY_J = 74;
    HumanInput.KEY_K = 75;
    HumanInput.KEY_L = 76;
    HumanInput.KEY_M = 77;
    HumanInput.KEY_N = 78;
    HumanInput.KEY_O = 79;
    HumanInput.KEY_P = 80;
    HumanInput.KEY_Q = 81;
    HumanInput.KEY_R = 82;
    HumanInput.KEY_S = 83;
    HumanInput.KEY_T = 84;
    HumanInput.KEY_U = 85;
    HumanInput.KEY_V = 86;
    HumanInput.KEY_W = 87;
    HumanInput.KEY_X = 88;
    HumanInput.KEY_Y = 89;
    HumanInput.KEY_Z = 90;
    HumanInput.KEY_LEFT_WINDOW = 91;
    HumanInput.KEY_RIGHT_WINDOW = 92;
    HumanInput.KEY_SELECT_KEY = 93;
    HumanInput.KEY_NUMPAD_0 = 96;
    HumanInput.KEY_NUMPAD_1 = 97;
    HumanInput.KEY_NUMPAD_2 = 98;
    HumanInput.KEY_NUMPAD_3 = 99;
    HumanInput.KEY_NUMPAD_4 = 100;
    HumanInput.KEY_NUMPAD_5 = 101;
    HumanInput.KEY_NUMPAD_6 = 102;
    HumanInput.KEY_NUMPAD_7 = 103;
    HumanInput.KEY_NUMPAD_8 = 104;
    HumanInput.KEY_NUMPAD_9 = 105;
    HumanInput.KEY_MULTIPLY = 106;
    HumanInput.KEY_ADD = 107;
    HumanInput.KEY_SUBTRACT = 109;
    HumanInput.KEY_DECIMAL_POINT = 110;
    HumanInput.KEY_DIVIDE = 111;
    HumanInput.KEY_F1 = 112;
    HumanInput.KEY_F2 = 113;
    HumanInput.KEY_F3 = 114;
    HumanInput.KEY_F4 = 115;
    HumanInput.KEY_F5 = 116;
    HumanInput.KEY_F6 = 117;
    HumanInput.KEY_F7 = 118;
    HumanInput.KEY_F8 = 119;
    HumanInput.KEY_F9 = 120;
    HumanInput.KEY_F10 = 121;
    HumanInput.KEY_F11 = 122;
    HumanInput.KEY_F12 = 123;
    HumanInput.KEY_NUM_LOCK = 144;
    HumanInput.KEY_SCROLL_LOCK = 145;
    HumanInput.KEY_SEMI_COLON = 186;
    HumanInput.KEY_EQUAL_SIGN = 187;
    HumanInput.KEY_COMMA = 188;
    HumanInput.KEY_DASH = 189;
    HumanInput.KEY_PERIOD = 190;
    HumanInput.KEY_FORWARD_SLASH = 191;
    HumanInput.KEY_GRAVE_ACCENT = 192;
    HumanInput.KEY_OPEN_BRACKET = 219;
    HumanInput.KEY_BACK_SLASH = 220;
    HumanInput.KEY_CLOSE_BRAKET = 221;
    HumanInput.KEY_SINGLE_QUOTE = 222;
    HumanInput.KEY_SPACE = 32;

})();;(function() {
	"use strict";

	/**
	 * Disables user input
	 */
	Human.rpc.define("input.disable",
	    function () {
	        Human.input.setEnabled();
	    });

	/**
	 * Enables user input
	 */
	Human.rpc.define("input.enable",
	    function () {
	        Human.input.setEnabled(true);
	    });


})();
;/**
 * Orbits camera with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var yawRate = 50;
        var pitchRate = 50;

        ctx.onTick(
            function (time, elapsed) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    var left = ctx.keyDown[Human.input.KEY_LEFT_ARROW];
                    var right = ctx.keyDown[Human.input.KEY_RIGHT_ARROW];
                    var up = ctx.keyDown[Human.input.KEY_UP_ARROW];
                    var down = ctx.keyDown[Human.input.KEY_DOWN_ARROW];
                    if (left || right || up || down) {
                        var yaw = 0;
                        var pitch = 0;
                        if (right) {
                            yaw = -elapsed * yawRate;
                        } else if (left) {
                            yaw = (elapsed * yawRate);
                        }
                        if (down) {
                            pitch = -(elapsed * pitchRate);
                        } else if (up) {
                            pitch = (elapsed * pitchRate);
                        }
                        if (Math.abs(yaw) > Math.abs(pitch)) {
                            pitch = null;
                        } else {
                            yaw = null;
                        }

                        Human.view.camera.rotateY(yaw);
                        Human.view.camera.rotateX(pitch);

                        Human.view.mouseCursor.gotoRotate();
                    }
                }
            });
        
        // restore mouse state on arrow de-press
        ctx.onKeyUp([
            Human.input.KEY_UP_ARROW,
            Human.input.KEY_RIGHT_ARROW,
            Human.input.KEY_DOWN_ARROW,
            Human.input.KEY_LEFT_ARROW
        ],
        function () {
            if (!ctx.ctrlDown && !ctx.altDown) {
                Human.view.mouseCursor.gotoDefault();
            }
        });
    });;/**
 * Selects predefined camera with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        ctx.onKeyDown([
            Human.input.KEY_NUM_1,
            Human.input.KEY_NUM_2,
            Human.input.KEY_NUM_3,
            Human.input.KEY_NUM_4,
            Human.input.KEY_NUM_5,
            Human.input.KEY_NUM_6
        ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    var camera = Human.view.camera;
                    if (key === Human.input.KEY_NUM_1) {
                        camera.viewAnterior();
                    } else if (key === Human.input.KEY_NUM_2) {
                        camera.viewPosterior();
                    } else if (key === Human.input.KEY_NUM_3) {
                        camera.viewRight();
                    } else if (key === Human.input.KEY_NUM_4) {
                        camera.viewLeft();
                    } else if (key === Human.input.KEY_NUM_5) {
                        camera.viewSuperior();
                    } else if (key === Human.input.KEY_NUM_6) {
                        camera.viewInferior();
                    }
                }
            });
    });;/**
 * Pans camera with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var panRate = 10;

        ctx.onTick(
            function (time, elapsed) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    var w = ctx.keyDown[Human.input.KEY_W];
                    var s = ctx.keyDown[Human.input.KEY_S];
                    var a = ctx.keyDown[Human.input.KEY_A];
                    var d = ctx.keyDown[Human.input.KEY_D];
                    if (w || s || a || d) {
                        var x = 0;
                        var y = 0;
                        var z = 0;
                        if (s) {
                            y = elapsed * panRate;
                        } else if (w) {
                            y = -elapsed * panRate;
                        }
                        if (d) {
                            x = elapsed * panRate;
                        } else if (a) {
                            x = -elapsed * panRate;
                        }
                        Human.view.camera.pan({x: x, y: y, z: z});
                    }
                }
            });
    });;/**
 * Zooms camera with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var rate = 3;

        ctx.onTick(
            function (time, elapsed) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    var z = ctx.keyDown[Human.input.KEY_Z];
                    var x = ctx.keyDown[Human.input.KEY_X];
                    if (z || x) {
                        var delta = z ? -(elapsed * rate) : elapsed * rate;
                        Human.view.camera.zoom(delta);
                    }
                }
            });
    });;(function () {
    "use strict";

    var enabled = true;

    Human.properties.subscribe({
        propId: "ui.zoom.mouseWheel.enabled",
        value: enabled,
        callback: function (value) {
            enabled = !!value;
        }
    });

    Human.input.addHandler(
        function (ctx) {

            var delta = 0;
            var target = 0;
            var newTarget = false;
            var targeting = false;
            var progress = 0;
            var sensitivity = 0.2;
            var eyeVec = Human.math.vec3();
            var lookVec = Human.math.vec3();
            var tempVec3 = Human.math.vec3();

            var lastTime;


            ctx.onMouseWheel(function (event, d) {

                if (!enabled) {
                    return;
                }

                delta = -d;
                if (delta === 0) {
                    targeting = false;
                    newTarget = false;
                } else {
                    newTarget = true;
                }
            });

            ctx.onTick(function (time) {

                if (!enabled) {
                    return;
                }

                var camera = Human.view.camera;
                var eye = camera.eye;
                var look = camera.look;
                eyeVec[0] = eye.x;
                eyeVec[1] = eye.y;
                eyeVec[2] = eye.z;

                lookVec[0] = look.x;
                lookVec[1] = look.y;
                lookVec[2] = look.z;

                Human.math.subVec3(eyeVec, lookVec, tempVec3);
                var lenLook = Math.abs(Human.math.lenVec3(tempVec3));
                var lenLimits = camera.maxZoom - camera.minZoom;
                var f = sensitivity * (2.0 + (lenLook / lenLimits));

                if (newTarget) {
                    target = delta * f;
                    progress = 0;
                    newTarget = false;
                    targeting = true;
                }

                if (targeting) {
                    if (delta > 0) {
                        progress += 0.2 * f;
                        if (progress > target) {
                            targeting = false;
                        }
                    } else if (delta < 0) {
                        progress -= 0.2 * f;
                        if (progress < target) {
                            targeting = false;
                        }
                    }
                    if (targeting) {
                        Human.view.camera.zoom(progress);
                    }
                }

                lastTime = time;
            });
        });

})();;/**
 * Orbits camera with mouse drags
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var sensitivity = 0.20;
        var lastX;
        var lastY;
        var xDelta = 0;
        var yDelta = 0;
        var down = false;
        var eyeVec = Human.math.vec3();
        var lookVec = Human.math.vec3();
        var tempVec3 = Human.math.vec3();

        ctx.onMouseDown(function (x, y) {
            // Only left mouse down starts drag-orbit
            if ((ctx.mouseDownLeft && !ctx.mouseDownRight && !ctx.keyDown[Human.input.KEY_SHIFT])) {
                down = true;
                lastX = x;
                lastY = y;
            } else {
                down = false;
            }
        });

        ctx.onMouseUp(function () {
            down = (ctx.mouseDownLeft && !ctx.mouseDownRight);
        });

        ctx.onMouseMove(function (x, y) {
            if (down) {
                xDelta += (x - lastX) * sensitivity;
                yDelta += (y - lastY) * sensitivity;
                lastX = x;
                lastY = y;
            }
        });

        ctx.onTick(function () {
            if (Math.abs(xDelta) > 0 || Math.abs(yDelta) > 0) {

                var camera = Human.view.camera;
                var eye = camera.eye;
                var look = camera.look;

                eyeVec[0] = eye.x;
                eyeVec[1] = eye.y;
                eyeVec[2] = eye.z;

                lookVec[0] = look.x;
                lookVec[1] = look.y;
                lookVec[2] = look.z;

                Human.math.subVec3(eyeVec, lookVec, tempVec3);
                var lenLook = Math.abs(Human.math.lenVec3(tempVec3));
                var lenLimits = camera.maxZoom - camera.minZoom;
                var f = 1.0 + (lenLook / lenLimits);

                Human.view.camera.rotateY(-xDelta * f);
                Human.view.camera.rotateX(yDelta * f);

                xDelta = 0;
                yDelta = 0;
            }
        });
    });;/**
 * Pans camera with mouse drags
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var zoomLimits;

        Human.properties.subscribe({
            propId: "camera.zoomLimits",
            value: {
                min: 0.01,
                max: 150
            },
            callback: function (value) {
                zoomLimits = value;
            }
        });

        var sensitivity = 0.16;
        var rate = 1;
        var lastX;
        var lastY;
        var xDelta = 0;
        var yDelta = 0;
        var down = false;
        var eyeVec = Human.math.vec3();
        var lookVec = Human.math.vec3();
        var tempVec3 = Human.math.vec3();

        ctx.onMouseDown(function (x, y) {
            if ((ctx.mouseDownLeft && ctx.mouseDownRight) ||
                (ctx.mouseDownLeft && ctx.keyDown[Human.input.KEY_SHIFT]) ||
                 ctx.mouseDownMiddle) {
                down = true;
                lastX = x;
                lastY = y;
            } else {
                down = false;
            }
        });

        ctx.onMouseUp(function () {
            down = false;
        });

        ctx.onMouseMove(function (x, y) {
            if (down) {

                var camera = Human.view.camera;
                var eye = camera.eye;
                var look = camera.look;

                eyeVec[0] = eye.x;
                eyeVec[1] = eye.y;
                eyeVec[2] = eye.z;

                lookVec[0] = look.x;
                lookVec[1] = look.y;
                lookVec[2] = look.z;

                Human.math.subVec3(eyeVec, lookVec, tempVec3);
                var lenLook = Math.abs(Human.math.lenVec3(tempVec3));
                var lenLimits = camera.maxZoom - camera.minZoom;
                var f = sensitivity * (lenLook / lenLimits);

                xDelta += (x - lastX) * f;
                yDelta += (y - lastY) * f;

                lastX = x;
                lastY = y;
            }
        });

        ctx.onTick(function () {
            if (Math.abs(xDelta) > 0 || Math.abs(yDelta) > 0) {

                Human.view.camera.pan({ x: xDelta * rate, y: yDelta * rate });

                xDelta = 0;
                yDelta = 0;
            }
        });
    });;Human.input.addHandler(
    function (ctx) {
        "use strict";

        var lastX = null;
        var lastY = null;
        var tolerance = 4; // Pixels
        var hoverTime = 0.5; // Seconds
        var timeout = null;
        var mouseDown = false;

        ctx.onReset(function () {
            reset();
        });

        function reset() {
            if (timeout) {
                clearTimeout(timeout);
                timeout = null;
            }
            lastX = null;
            lastY = null;
            Human.view.pick.hoverOff();
        }

        ctx.onMouseMove(function (x, y) {
            if (mouseDown) {
                return;
            }
            if (lastX !== null) {
                if (Math.abs(x - lastX) > tolerance || Math.abs(y - lastY) > tolerance) {
                    reset();
                } else {
                    if (timeout) {
                        clearTimeout(timeout);
                        timeout = null;
                    }
                    Human.view.pick.hoverOff();
                    timeout = setTimeout(
                        function () {
                            Human.view.pick.hoverPick({ canvasX: x, canvasY: y });
                            clearTimeout(timeout);
                            timeout = null;
                            lastX = null;
                            lastY = null;
                        }, hoverTime * 1000);
                }
            }
            lastX = x;
            lastY = y;
        });

        ctx.onMouseDown(function () {
            reset();
            mouseDown = true;
        });

        ctx.onMouseUp(function (x, y) {
            lastX = x;
            lastY = y;
            mouseDown = false;
        });
    });;Human.input.addHandler(
    function (ctx) {
        "use strict";

        var lastX = null;
        var lastY = null;
        var tolerance = 4;
        var picked = false;
        var doubleClicked = false;
        var mouseDownLeft = false;
        var mouseDownRight = false;
        var spaceDown = false;
        var ctrlDown = false;
        var pickX;
        var pickY;

        ctx.onKeyDown([
                Human.input.KEY_SHIFT
            ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.CTRL) {
                    switch (key) {
                        case Human.input.KEY_SHIFT:
                            Human.view.pick.setMultiPickEnabled(true);
                            break;
                    }
                }
            });

        ctx.onKeyUp([
                Human.input.KEY_SHIFT
            ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.CTRL) {
                    switch (key) {
                        case Human.input.KEY_SHIFT:
                            Human.view.pick.setSinglePickEnabled(true);
                            break;
                    }
                }
            });

        ctx.onKeyDown([
                Human.input.KEY_SPACE
            ],
            function () {
                spaceDown = true;
            });

        ctx.onKeyUp([
                Human.input.KEY_SPACE
            ],
            function () {
                spaceDown = false;
            });

        ctx.onKeyDown([
                Human.input.KEY_CTRL
            ],
            function () {
                ctrlDown = true;
            });

        ctx.onKeyUp([
                Human.input.KEY_CTRL
            ],
            function () {
                ctrlDown = false;
            });

        ctx.onMouseDown(function (x, y) {
            lastX = x;
            lastY = y;
            mouseDownLeft = ctx.mouseDownLeft;
            mouseDownRight = ctx.mouseDownRight;
        });

        ctx.onMouseUp(function (x, y) {
            if (Math.abs(lastX - x) < tolerance && Math.abs(lastY - y) < tolerance) {
                pickX = x;
                pickY = y;
                picked = true;
            }
        });

        ctx.onMouseDoubleClick(function (x, y) {
            if (Math.abs(lastX - x) < tolerance && Math.abs(lastY - y) < tolerance) {
                pickX = x;
                pickY = y;
                picked = true;
                doubleClicked = true;
                mouseDownLeft = ctx.mouseDownLeft;
                mouseDownRight = ctx.mouseDownRight;
            }
        });

        ctx.onTick(function () {
            if (picked) {
                var params = {
                    canvasX: pickX,
                    canvasY: pickY,
                    mouseDownLeft: mouseDownLeft,
                    mouseDownRight: mouseDownRight,
                    spaceDown: spaceDown,
                    ctrlDown: ctrlDown
                };
                if (doubleClicked) {
                    Human.view.pick.doublePick(params);
                } else {
                    Human.view.pick.pick(params);
                }
                picked = false;
                doubleClicked = false;
                lastX = null;
                lastY = null;
            }
        });
    });
;/**
 * Selects view mode with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        ctx.onKeyDown([
            Human.input.KEY_R,
            Human.input.KEY_T,
            Human.input.KEY_I,
            Human.input.KEY_Y,
            Human.input.KEY_Z,
            Human.input.KEY_C
        ],
            function (key) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    switch (key) {
                        case  Human.input.KEY_R:
                            Human.rpc.call(null, "highlight.setEnabled", { enable: true });
                            break;
                        case  Human.input.KEY_T:
                            Human.rpc.call(null, "xray.setEnabled", { enable: true });
                            break;
                        case  Human.input.KEY_I:
                            Human.rpc.call(null, "isolate.setEnabled", { enable: true });
                            break;
                    }
                }

                if (ctx.ctrlDown && !ctx.altDown) {
                    switch (key) {
                        case Human.input.KEY_Y:
                            Human.view.dissect.redo();
                            break;

                        case Human.input.KEY_Z:
                            Human.view.dissect.undo();
                            break;

                        case Human.input.KEY_R:
                            Human.init.reset();
                            break;

                        case Human.input.KEY_C:
                            Human.rpc.call(null, "dissect.setEnabled", { enable: true });
                            break;
                    }
                }
            });
    });;/**
 * Moves active cross-section with keyboard
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        var moveRate = 10.0;
        var clipPlaneShownByThis = null;
        var timeLast;

        ctx.onTick(
            function (time) {
                if (!ctx.ctrlDown && !ctx.altDown) {
                    var m = ctx.keyDown[Human.input.KEY_M];
                    var n = ctx.keyDown[Human.input.KEY_N];
                    if (m || n) {
                        if (!Human.view.clip.selectedClip) {
                            return;
                        }
                        if (timeLast) {
                            var elapsed = (time - timeLast) / 1000.0; // Scale to seconds
                            var z;
                            if (n) {
                                z = elapsed * moveRate;
                            } else if (m) {
                                z = -elapsed * moveRate;
                            }
                            var clip = Human.view.clip.selectedClip;
                            if (!clip.shown) {
                                clipPlaneShownByThis = clip.clipId;
                            }
                            Human.view.clip.setClip({
                                state: Human.view.clip.Plane.STATE_VISIBLE,
                                progress: clip.progress + z
                            });
                            return true; // Updated
                        }

                        timeLast = time;
                    } else {
                        timeLast = null;
                        if (clipPlaneShownByThis) {
                            Human.view.clip.setClip({
                                clipId: clipPlaneShownByThis,
                                state: Human.view.clip.Plane.STATE_CLIPPING
                            });
                            clipPlaneShownByThis = null;
                        }
                    }
                }
            });
    });;/**
* Toggles the dissect state
*/
Human.input.addHandler(
    function (ctx) {
        "use strict";

        // track keyboard enable state
        var enabledOnKeyPress = false;

        ctx.onKeyDown([
            Human.input.KEY_X
        ],
            function () {
                if (ctx.ctrlDown && !ctx.altDown && !enabledOnKeyPress) {
                    Human.view.dissect.setEnabled(true);
                    enabledOnKeyPress = true;
                }
            });
        ctx.onKeyUp([
            Human.input.KEY_X
        ],
            function () {
                if (enabledOnKeyPress) {
                    Human.view.dissect.setEnabled(false);
                    enabledOnKeyPress = false;
                }
            });
    });;/**
 * Resets engine to the state it was in after it fired "started"
 */
Human.input.addHandler(
    function (ctx) {
        "use strict";

        ctx.onKeyDown([
            Human.input.KEY_R
        ],
            function () {
                if (ctx.keyDown[Human.input.KEY_SHIFT]) {
                    var confirmText = 'This will reset to the initial view. Are you sure you want to continue?';

                    if(confirm(confirmText)) {
                        Human.init.reset();
                    }
                }
            });
    });;/**
 * @namespace The 3D scene, consisting of a hierarchy of {@link Human.scene.Object}s.
 */
(function () {
    "use strict";

    var HumanScene = Human.scene = {};

    // TODO: What is this doing here!?
    HumanScene.checkTestStarted = false;	//Control variable to enable/disable the label feature.

    /** Array of root objects
     *
     * @type {Array}
     * @memberof Human.scene
     */
    HumanScene.rootObjects = [];

    /**
     * A map of objects by ID for each model that's currently loaded
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.modelObjects = {};

    /** All objects by ID
     *
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.objects = {};

    /** All objects by FMA ID
     *
     * @type {{}}
     * @memberof Human.scene
     */
    HumanScene.objectsByFMAID = {};

    /**
     * For each distinct object meta tag, a map of object IDs to object instances.
     *
     * Eg.
     *
     * <pre>
     * {
     *     "head": {
     *          "maleAdult_frontal_bone": <object>,
     *          "maleAdult_mandible": <object>
     *     },
     *     "skeleton": {
     *          "maleAdult_frontal_bone": <object>,
     *          "maleAdult_mandible": <object>
     *     },
     *     "digestion": {
     *          "maleAdult_mandible": <object>
     *     }
     * }
     * </pre>
     * @type {{}}
     */
    HumanScene.objectsForTags = {};

    /** Count of all objects in scene
     *
     * @type {number}
     * @memberof Human.scene
     */
    HumanScene.numObjects = 0;

    HumanScene._boundary = null;

    /**
     * @memberof Human.scene
     * @type {Array}
     */
    HumanScene.center = [0, 0, 0];

    /**
     * Map of flags for the currently visible objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
    HumanScene.enabledObjects = {};           // Enabled objects

    /**
     * Map of flags for the currently selected objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
    HumanScene.selectedObjects = {};          // Selected objects, which are not neccessarily enabled

    /**
     * Map of flags for the currently transparent objects, keyed by object ID
     * @memberof Human.scene
     * @type {{}}
     */
    HumanScene.transparentObjects = {};

    /**
     * Map of flags for pick-through objects, keyed by object ID
     * @memberof Human.scene
     *
     * @type {{}}
     */
    HumanScene.pickThroughObjects = {};

    /**
     * Map of flags for desaturated objects, keyed by object ID
     * @memberof Human.scene
     *
     * @type {{}}
     */
    HumanScene.desaturatedObjects = {};

    /**
     * Map of flags for objects whose backfaces are always shown, keyed by object ID
     * @memberof Human.scene
     *
     * @type {{}}
     */
    HumanScene.backfaceObjects = {};

    /**
     * True when only the currently selected objects are allowed to be visible
     * @memberof Human.scene
     * @type {boolean}
     */
    HumanScene.showSelectedObjects = false;   // When true, only selected objects shown, else all shown

    HumanScene.alwaysEnabledObjects = {};     // Objects that cannot be disabled
    HumanScene._leavesCache = {};

    /**
     * Creates an object
     *
     * <p>Object is not yet enabled or selected</p>
     *<pre>
     * createObject({
     *
     *      // All objects, leaf and branch
     *
     *      moduleId:         "maleAdult",
     *      objectId:         "Left_posterior_auricular_artery_49626",
     *      displayName:    "Left Posterior Auricular Artery"
     *      parentObjectId: "Anatomy",
     *
     *      // Leaf objects only:
     *
     *      materialId:     "bloodsupply01_blinn43SG",
     *      geometryId:     "Left_posterior_auricular_artery_49626Shape",
     *      attachObjectId : "the-scene-root" | undefined,
     *      pickable:       true,
     *      layerName:      "Muscular_System"
     *
     *      flags: {
     *          transparency:       0.2,
     *          pickable:           false,
     *          renderPriority:     0 | null
     *      }
     * });
     * </pre>
     *
     * @memberof Human.scene
     * @private
     */

    HumanScene.__createObject = function (params) {
        //  if (!params.displayName) {
//            throw Human.fatalError("params.displayName expected");
//        }

        if (!params.moduleId) {
            Human.log.error("Scene.__createObject", "Param expected: moduleId");
            return;
        }

        if (!params.objectId) {
            Human.log.error("Scene.__createObject", "Param expected: objectId");
            return;
        }

        var parent = params.parentObjectId ? HumanScene.objects[params.parentObjectId] : null;
        var modelId = params.modelId;

        // Inherit metatags from parent object

        params.tags = params.tags || [];

        var tags = parent ? HumanScene._inheritTags(params.tags, parent) : params.tags;

        var object = new Human.scene.Object({
            moduleId: params.moduleId,
            modelId: modelId,
            parent: parent,
            attachNodeId: Human.CONTENT_ROOT_ID,
            displayName: params.displayName,
            objectId: params.objectId,
            anonymous: params.anonymous,
            localObjectId: params.localObjectId,
            fmaId: params.fmaId,
            objectName: params.objectName,
            description: params.description,
            reflectInstance: params.reflectInstance,
            material: params.material, // Optional
            shader: params.shader, // Optional
            pickable: params.pickable,
            layer: params.layer,
            level: parent ? parent.level + 1 : 0,
            geometry: params.geometry,
            morph: params.morph,
            transform: params.transform,
            pivot: params.pivot,
            translate: params.translate,
            scale: params.scale,
            rotate: params.rotate,
            flip: params.flip,
            desaturate: params.desaturate,
            glassFactor: params.glassFactor,
            murkiness: params.murkiness,
            tags: tags
        });
        HumanScene.objects[params.objectId] = object;
        if (object.fmaId) {
            HumanScene.objectsByFMAID[object.fmaId] = object;
        }
        if (parent) {
            parent.__addObject(object);
        } else {
            HumanScene.rootObjects.push(object); // Register on roots map
        }

        (HumanScene.modelObjects[modelId] = HumanScene.modelObjects[modelId] || {})[params.objectId] = object;

        HumanScene._registerObjectForTags(object);

        HumanScene.numObjects++;

        HumanScene._boundary = null; // Now needs lazy-recompute

        // Publish object creation
        Human.events.fire("scene.objectCreated", {
            moduleId: params.moduleId,
            modelId: modelId,
            objectId: object.objectId,
            name: object.displayName,
            description: object.description,
            displayName: object.displayName,
            fmaId: object.fmaId,
            tags: object.tags,
            parentObjectId: parent ? parent.objectId : null
        });

        return object;
    };

    HumanScene._inheritTags = function(childTags, parentObject) {
        var tags = childTags || [];
        var parentTags = parentObject.tags;
        var tag;
        var parentTag;
        var inheritTags = [];
        if (tags) {
            for (var i = 0, leni = parentTags.length; i < leni; i++) {
                parentTag = parentTags[i];
                var inherit = true;
                for (var j = 0, lenj = tags.length; j < lenj; j++) {
                    tag = tags[j];
                    if (tag === parentTags[j]) {
                        inherit = false;
                    }
                }
                if (inherit) {
                    inheritTags.push(parentTag);
                }
            }
            return tags.concat(inheritTags);
        } else {
            return tags;
        }
    };

    HumanScene._registerObjectForTags = function(object) {
        var tags = object.tags;
        var tag;
        var tagObjects;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagObjects = HumanScene.objectsForTags[tag];
            if (!tagObjects) {
                tagObjects = HumanScene.objectsForTags[tag] = {};
            }
            tagObjects[object.objectId] = object;
        }
    };

    HumanScene._deregisterObjectForTags = function (object) {
        var tags = object.tags;
        var tag;
        var tagObjects;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            tagObjects = HumanScene.objectsForTags[tag];
            if (tagObjects) {
                delete tagObjects[object.objectId];
            }
        }
    };


//    HumanScene._geometryLoaded = function (object) {
//        HumanScene._expandBoundary(HumanScene._boundary, object.getBoundary());
//        HumanScene.center = [
//            (HumanScene._boundary.xmax + HumanScene._boundary.xmin) * 0.5,
//            (HumanScene._boundary.ymax + HumanScene._boundary.ymin) * 0.5,
//            (HumanScene._boundary.zmax + HumanScene._boundary.zmin) * 0.5
//        ];
//    };
//
//    HumanScene._expandBoundary = function (a, b) {
//        if (a.xmin > b.xmin) {
//            a.xmin = b.xmin;
//        }
//        if (a.ymin > b.ymin) {
//            a.ymin = b.ymin;
//        }
//        if (a.zmin > b.zmin) {
//            a.zmin = b.zmin;
//        }
//        if (a.xmax < b.xmax) {
//            a.xmax = b.xmax;
//        }
//        if (a.ymax < b.ymax) {
//            a.ymax = b.ymax;
//        }
//        if (a.zmax < b.zmax) {
//            a.zmax = b.zmax;
//        }
//    };

    /** Returns the {@link Human.scene.Object} corresponding to the given object ID
     * @memberof Human.scene
     */
    HumanScene.getObject = function (objectId) {
        var object = HumanScene.objects[objectId];
        if (!object) {
            Human.log.error("Human.scene.getObject", "Scene object not found: '" + objectId + "'");
        }
        return object;
    };

    /**
     * Enable or disable some or all objects
     * @memberof Human.scene
     */
    HumanScene.setEnabledObjects = function (params) {

        var objects = params.objects || params.objectIds;
        var objectId;

        var enabledObjectsUpdate = {};
        var selectedObjectsUpdate = {};

        /* Clear all selected objects if replacing the selected set
         */
        if (params.replace) {
            for (objectId in HumanScene.enabledObjects) {
                if (HumanScene.enabledObjects.hasOwnProperty(objectId)) {


                    // TODO ability to override this optimization

                    HumanScene.enabledObjects[objectId]._enabledSubObjects = 0;
                    delete HumanScene.enabledObjects[objectId];

                    enabledObjectsUpdate[objectId] = false;

                    if (HumanScene.selectedObjects.hasOwnProperty(objectId)) {
                        HumanScene.selectedObjects[objectId]._selectedSubObjects = 0;
                        delete HumanScene.selectedObjects[ objectId ];
                        selectedObjectsUpdate[objectId] = false;
                    }

                    HumanScene._updateObjectVisibility(objectId);
                }
            }
        }

        /* Build object ID->flag map for trees rooted by given objects
         */
        HumanScene._getEnabledFlagsinSubtreeForObjectMap(objects, enabledObjectsUpdate);

        /* Enable map of objects
         */
        for (objectId in enabledObjectsUpdate) {
            if (enabledObjectsUpdate.hasOwnProperty(objectId)) {
                if (enabledObjectsUpdate[objectId]) {

                    if (!HumanScene.enabledObjects[objectId]) {
                        HumanScene.enabledObjects[objectId] = HumanScene.objects[objectId];
                        HumanScene._updateObjectVisibility(objectId);

                        enabledObjectsUpdate[objectId] = true;
                    }
                } else {

                    if (HumanScene.enabledObjects[objectId]) {

                        delete HumanScene.enabledObjects[objectId];

                        /* Selection of an object forces enabling of it
                         * if it's currently disabled
                         */
                        if (HumanScene.selectedObjects[objectId]) {
                            if (!selectedObjectsUpdate) {
                                selectedObjectsUpdate = {};
                            }
                            delete HumanScene.selectedObjects[objectId];  // Disabling forces deselection
                            selectedObjectsUpdate[objectId] = false;
                        }

                        HumanScene._updateObjectVisibility(objectId);

                        enabledObjectsUpdate[objectId] = false;
                    }
                }
            }
        }

        Human.events.fire("scene.objectsShown", {    // Post-notify
            enabledObjectsUpdate: enabledObjectsUpdate,
            showSelectedObjects: HumanScene.showSelectedObjects
        });

        if (selectedObjectsUpdate) {
            Human.events.fire("scene.objectsSelected", {
                selectedObjectsUpdate: selectedObjectsUpdate,
                showSelectedObjects: HumanScene.showSelectedObjects
            });
        }
    };

    /**
     * Builds enabled flags for objects in given map of enabled flags,
     * in order of objects' level in anatomy hierarchy
     */
    HumanScene._getEnabledFlagsinSubtreeForObjectMap = function (objects, objectFlags) {
        var buckets = HumanScene._sortObjectIDsIntoLevelBuckets(objects);
        var bucket;
        var objectId;
        // Iterate buckets in order, accumulate enabled flags for each object
        for (var i = 0, len = buckets.length; i < len; i++) {
            bucket = buckets[i];
            if (bucket) {
                for (var j = 0, len2 = bucket.length; j < len2; j++) {
                    objectId = bucket[j];
                    HumanScene._getEnabledFlagsInSubtreeForObject(objectId, !!objects[objectId], objectFlags);
                }
            }
        }
    };

    /**
     * Sorts given map of object IDs into buckets ordered by ascending
     * order of object levels in anatomy hierarchy
     */
    HumanScene._sortObjectIDsIntoLevelBuckets = function (objectIds) {
        var objectId;
        var buckets = [];
        var bucket;
        var object;
        var level;
        for (objectId in objectIds) {
            if (objectIds.hasOwnProperty(objectId)) {
                object = HumanScene.objects[objectId];
                if (object) {
                    level = object.level;
                    bucket = buckets[level] || (buckets[level] = []);
                    bucket.push(objectId);
                }
            }
        }
        return buckets;
    };

    HumanScene._getEnabledFlagsInSubtreeForObject = function (objectId, flag, objectFlags) {
        objectFlags = objectFlags || {};
        var object = HumanScene.objects[objectId];
        if (!object || object._destroyed) {
            return objectFlags;
        }
        objectFlags[objectId] = flag;
        // Set flags for parents
        var objectEnabled = HumanScene.enabledObjects[objectId];
        if (object.parent) {
            for (var parent = object.parent; parent; parent = parent.parent) {  // Get flags on path to root
                if (parent._enabledSubObjects === undefined || parent._enabledSubObjects === null) {
                    parent._enabledSubObjects = 0;
                }
                if (flag) {
                    if (!objectEnabled) {
                        if (++parent._enabledSubObjects === 1) {
                            objectFlags[parent.objectId] = true;
                        }
                    }
                } else {
                    if (objectEnabled) {
                        if (--parent._enabledSubObjects === 0) {
                            objectFlags[parent.objectId] = false;
                        }
                    }
                }
            }
        }
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._getEnabledFlagsInSubtreeForObject(objects[i].objectId, flag, objectFlags);
        }
        return objectFlags;
    };

    /**
     * Select or disable some or all objects
     * @memberof Human.scene
     */
    HumanScene.setSelectedObjects = function (params) {
        var objects = params.objects || params.objectIds || {};
        var objectId;
        var object;

        var selectedObjectsUpdate = {};


        if (params.objectId) {

            // Selecting a single object

            // Verify object exists
            object = HumanScene.objects[params.objectId];
            if (!object) {
                Human.log.error("Human.scene.setSelectedObjects", "Scene object not found: '" + params.objectId + "'");
                return;
            }

            var select = !!params.select;

            // Unselect all currently selected objects if replacing the selected set
            if (params.replace) {
                for (objectId in HumanScene.selectedObjects) {
                    if (HumanScene.selectedObjects.hasOwnProperty(objectId)) {

                        object = HumanScene.selectedObjects[objectId];
                        object._selectedSubObjects = 0;
                        delete HumanScene.selectedObjects[ objectId ];

                        // Hide object if selected objects are currently visible
                        if (HumanScene.showSelectedObjects) {
                            if (object.shown) {
                                object.show(false);
                            }
                        }

                        selectedObjectsUpdate[objectId] = false;
                    }
                }
            }

            HumanScene._getObjectSelectedFlagsInSubtree(params.objectId, select, selectedObjectsUpdate);

        } else {

            // Selection/deselecting multiple objects

            // Unselect all currently selected objects if replacing the selected set
            if (params.replace) {
                for (objectId in HumanScene.selectedObjects) {
                    if (HumanScene.selectedObjects.hasOwnProperty(objectId)) {
                        HumanScene.selectedObjects[ objectId ]._selectedSubObjects = 0;
                        delete HumanScene.selectedObjects[ objectId ];
                        selectedObjectsUpdate[objectId] = false;
                        HumanScene._updateObjectVisibility(objectId);
                    }
                }
            }

            // Build object ID->flag map for trees rooted by given objects
            HumanScene._getSelectedFlagsInSubtreeForObjectMap(objects, selectedObjectsUpdate);

        } // Multiple select


        /* Defined as soon as disabled object becomes enabled as it is
         * selected - we'll notify of new enables if this is defined
         */
        var enabledObjectsUpdate;

        /* Enable map of objects
         */
        for (objectId in selectedObjectsUpdate) {
            if (selectedObjectsUpdate.hasOwnProperty(objectId)) {
                object = HumanScene.objects[objectId];
                if (selectedObjectsUpdate[objectId]) {
                    if (!HumanScene.selectedObjects[objectId]) {

                        HumanScene.selectedObjects[objectId] = object;

                        /* Selection of an object forces enabling of it
                         * if it's currently disabled
                         */
                        if (!HumanScene.enabledObjects[objectId]) {
                            if (!enabledObjectsUpdate) {
                                enabledObjectsUpdate = {};
                            }
                            enabledObjectsUpdate[objectId] = true;
                            HumanScene.enabledObjects[objectId] = object;
                        }

                        var show = !!((HumanScene.showSelectedObjects) ?
                            HumanScene.selectedObjects[objectId] :  // Object ID will be an owned property
                            HumanScene.enabledObjects[objectId]);

                        if (object.shown !== show) {
                            object.show(show);
                        }

                        if (!object.selected) {
                            object.select(true);
                        }

                        //HumanScene._updateObjectVisibility(objectId);

                        selectedObjectsUpdate[objectId] = true;


                    }
                } else {

                    if (HumanScene.selectedObjects[objectId]) {

                        delete HumanScene.selectedObjects[objectId];      // Deselection leaves object enabled

                        HumanScene._updateObjectVisibility(objectId);

                        if (object.selected) {
                            object.select(false);
                        }

                        selectedObjectsUpdate[objectId] = false;
                    }
                }
            }
        }


        /* Notify of new object enables/disables
         */
        if (enabledObjectsUpdate) {

            Human.events.fire("scene.objectsShown", {
                enabledObjectsUpdate: enabledObjectsUpdate,
                showSelectedObjects: HumanScene.showSelectedObjects
            });
        }

        /* Notify of new object selections/deselections
         */
        Human.events.fire("scene.objectsSelected", {
            selectedObjectsUpdate: selectedObjectsUpdate,
            showSelectedObjects: HumanScene.showSelectedObjects
        });
    };


    /** Builds selected and enabled flags for object enabled flags in given map in order of objects' level in anatomy hierarchy
     */
    HumanScene._getSelectedFlagsInSubtreeForObjectMap = function (objects, objectFlags) {
        var buckets = HumanScene._sortObjectIDsIntoLevelBuckets(objects);
        var bucket;
        var objectId;
        // Iterate buckets in order, accumulate enabled flags for each object
        for (var i = 0, len = buckets.length; i < len; i++) {
            bucket = buckets[i];
            if (bucket) {
                for (var j = 0, len2 = bucket.length; j < len2; j++) {
                    objectId = bucket[j];
                    HumanScene._getObjectSelectedFlagsInSubtree(objectId, !!objects[objectId], objectFlags);
                }
            }
        }
    };

    HumanScene._getObjectSelectedFlagsInSubtree = function (objectId, flag, objectFlags) {
        objectFlags = objectFlags || {};
        var object = HumanScene.objects[objectId];
        if (!object || object._destroyed) {
            return objectFlags;
        }
        objectFlags[objectId] = flag;
        // Set flags for parents
        var objectSelected = HumanScene.selectedObjects[objectId];
        var objectEnabled = HumanScene.enabledObjects[objectId];
        if (object.parent) {
            for (var parent = object.parent; parent; parent = parent.parent) {  // Get flags on path to root
                if (parent._enabledSubObjects === undefined || parent._enabledSubObjects === null) {
                    parent._enabledSubObjects = 0;
                }
                if (parent._selectedSubObjects === undefined || parent._selectedSubObjects === null) {
                    parent._selectedSubObjects = 0;
                }
                if (flag) {
                    if (!objectSelected) {
                        if (++parent._selectedSubObjects === 1) {
                            objectFlags[parent.objectId] = true;
                        }
                    }
                    if (!objectEnabled) {
                        parent._enabledSubObjects++;
                    }
                } else {
                    if (objectSelected) {
                        if (--parent._selectedSubObjects <= 0) {
                            parent._selectedSubObjects = 0; // Safety?
                            objectFlags[parent.objectId] = false;
                        }
                    }
                }
            }
        }
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._getObjectSelectedFlagsInSubtree(objects[i].objectId, flag, objectFlags);
        }
        return objectFlags;
    };

    HumanScene.anySelected = function (leaves) {
        var object;
        for (var key in HumanScene.selectedObjects) {
            if (HumanScene.selectedObjects.hasOwnProperty(key)) {
                object = HumanScene.selectedObjects[key];
                if (leaves) {
                    if (object.numSubObjects === 0) {
                        return true;
                    }
                } else {
                    return true;
                }
            }
        }
        return false;
    };

    /**
     * Sets whether or not to show only the objects that are selected and enabled
     * @memberof Human.scene
     * @param showSelected
     */
    HumanScene.setShowSelectedObjects = function (showSelected) {
        HumanScene.showSelectedObjects = showSelected;
        var object;
        var show;
        for (var objectId in HumanScene.objects) {
            if (HumanScene.objects.hasOwnProperty(objectId)) {
                object = HumanScene.objects[objectId];
                show = !!((HumanScene.showSelectedObjects) ? HumanScene.selectedObjects[objectId] : HumanScene.enabledObjects[objectId]);
                if (object.shown !== show) {
                    object.show(show);
                }   
            }
        }
    };

    HumanScene._updateObjectVisibility = function (objectId) {
        var object = HumanScene.objects[objectId];
        var show = !!((HumanScene.showSelectedObjects) ? HumanScene.selectedObjects[objectId] : HumanScene.enabledObjects[objectId]);
        if (object.shown !== show) {
            object.show(show);
        }
    };

    /**
     * Sets which objects may be picked through
     * @param params
     * @memberof Human.scene
     */
    HumanScene.setPickThroughObjects = function (params) {
        var objects = params.objects || params.objectIds || {};
        var objectId;
        // Clear all unpickable objects if replacing the unpickable set
        if (params.replace) {
            for (objectId in HumanScene.pickThroughObjects) {
                if (HumanScene.pickThroughObjects.hasOwnProperty(objectId)) {
                    if (HumanScene.pickThroughObjects[objectId]) {
                        HumanScene.objects[objectId].setPickable(true);
                        delete HumanScene.pickThroughObjects[ objectId ];
                    }
                }
            }
        }
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId) && objects[objectId] === true) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setPickThroughObjects(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setPickThroughObjects = function (object, pickThrough) {
        HumanScene.pickThroughObjects[object.objectId] = pickThrough;
        object.setPickable(!pickThrough);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setPickThroughObjects(objects[i], pickThrough);
        }
    };

    /**
     * Sets which objects are transparent
     * @param params
     * @memberof Human.scene
     */
    HumanScene.setTransparentObjects = function (params) {
        var objects = params.objectIds || {};
        var objectId;
        // Clear all transparent objects if replacing the transparent set
        if (params.replace) {
            for (objectId in HumanScene.transparentObjects) {
                if (HumanScene.transparentObjects.hasOwnProperty(objectId)) {
                    if (HumanScene.transparentObjects[objectId]) {
                        HumanScene.objects[objectId].setTransparent(false, true, true);
                        delete HumanScene.transparentObjects[ objectId ];
                        //            HumanScene._updateObjectVisibility(objectId);
                    }
                }
            }
        }
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId) && objects[objectId] === true) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setTransparentObjects(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setTransparentObjects = function (object, transparent) {
        HumanScene.transparentObjects[object.objectId] = transparent;
        object.setTransparent(transparent, true);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setTransparentObjects(objects[i], transparent);
        }
    };

    /**
     * Sets which objects appear desaturated
     * @param params
     * @memberof Human.scene
     */
    HumanScene.setDesaturatedObjects = function (params) {
        var objects = params.objects || params.objectIds || {};
        var objectId;
        if (params.replace) {
            for (objectId in HumanScene.desaturatedObjects) {
                if (HumanScene.desaturatedObjects.hasOwnProperty(objectId)) {
                    if (HumanScene.desaturatedObjects[objectId]) {
                        HumanScene.objects[objectId].setDesaturate(false);
                        delete HumanScene.desaturatedObjects[ objectId ];
                    }
                }
            }
        }
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId) && objects[objectId] === true) {
                if (HumanScene.objects[objectId]) {
                    HumanScene._setDesaturatedObjects(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setDesaturatedObjects = function (object, desaturate) {
        HumanScene.desaturatedObjects[object.objectId] = desaturate;
        object.setDesaturate(desaturate);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setDesaturatedObjects(objects[i], desaturate);
        }
    };

    /**
     * Sets which objects appear backface
     * @param params
     * @memberof Human.scene
     */
    HumanScene.setBackfaceObjects = function (params) {
        var objects = params.objects || params.objectIds || {};
        var objectId;
        if (params.replace) {
            for (objectId in HumanScene.backfaceObjects) {
                if (HumanScene.backfaceObjects.hasOwnProperty(objectId)) {
                    if (HumanScene.backfaceObjects[objectId]) {
                        HumanScene.objects[objectId].setBackfaces(false);
                        delete HumanScene.backfaceObjects[ objectId ];
                    }
                }
            }
        }
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId) && objects[objectId] === true) {
                if (HumanScene.objects[objectId]) {
                    HumanScene._setBackfaceObjects(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setBackfaceObjects = function (object, backface) {
        HumanScene.backfaceObjects[object.objectId] = backface;
        object.setTransparentBackfaces(backface);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setBackfaceObjects(objects[i], backface);
        }
    };


    /** When transparent, this sets the degree of "facing ratio" effect for objects, which is
     * where the object becomes more opaque towards the edges.
     * <p>Values are continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} params Degree of effect, between 0 and 1, for each object we want to update
     * @memberof Human.scene
     */
    HumanScene.setObjectGlassFactors = function (params) {
        var objects = params.objectIds || {};
        var objectId;        
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setObjectGlassFactors(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setObjectGlassFactors = function (object, glassFactor) {
        object.setGlassFactor(glassFactor, true);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setObjectGlassFactors(objects[i], glassFactor);
        }
    };

    /** When transparent, this sets the degree of "murkiness" effect for objects.
     * <p>Values are continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} params Degree of effect, between 0 and 1, for each object we want to update
     * @memberof Human.scene
     */
    HumanScene.setObjectMurkiness = function (params) {
        var objects = params.objectIds || {};
        var objectId;
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setObjectMurkiness(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setObjectMurkiness = function (object, murkiness) {
        object.setMurkiness(murkiness, true);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setObjectMurkiness(objects[i], murkiness);
        }
    };


    /** Sets the opacity for objects when they are transparent.
     * <p>Values are continuous, in the range [0.0..1.0], where 0.0 is completely transparent, while 1.0 is full opacity.
     *
     * @param {Number} params Degree of effect, between 0 and 1, for each object we want to update
     * @memberof Human.scene
     */
    HumanScene.setObjectOpacities = function (params) {
        var objects = params.objectIds || {};
        var objectId;
        for (objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                if (!HumanScene.objects[objectId]) {
                    // TODO: log?
                } else {
                    HumanScene._setObjectOpacities(HumanScene.objects[objectId], objects[objectId]);
                }
            }
        }
    };

    HumanScene._setObjectOpacities = function (object, opacity) {
        object.setOpacity(opacity, true);
        var objects = object.objects;
        for (var i = 0, len = objects.length; i < len; i++) {
            HumanScene._setObjectOpacities(objects[i], opacity);
        }
    };

    /**
     * Returns the IDs of leaf objects within the given tree
     * @param objectId
     * @memberof Human.scene
     */
    HumanScene.getLeaves = function (objectId) {
        var objectIdList = HumanScene._leavesCache[ objectId ];
        if (!objectIdList) {
            objectIdList = [];
            var object = HumanScene.objects[objectId];
            if (object) {
                HumanScene._getLeaves([object], objectIdList);
            }
            HumanScene._leavesCache[ objectId ] = objectIdList;
        }
        return objectIdList;
    };

    HumanScene._getLeaves = function (objects, objectIdList) {
        var object;
        for (var i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            if (object.objects.length === 0) { // Leaf
                objectIdList.push(object.objectId);
            } else {
                HumanScene._getLeaves(object.objects, objectIdList);
            }
        }
    };

    /**
     * Returns the IDs of visible leaf objects within the given tree
     * @param objectId
     * @memberof Human.scene
     */
    HumanScene.getEnabledLeaves = function (objectId) {
        var objectIdList = [];
        var object = HumanScene.objects[objectId];
        if (object) {
            HumanScene._getEnabledLeaves([object], objectIdList);
        }
        return objectIdList;
    };

    HumanScene._getEnabledLeaves = function (objects, objectIdList) {
        var object;
        for (var i = 0, len = objects.length; i < len; i++) {
            object = objects[i];
            if (object.objects.length === 0) { // Leaf
                if (HumanScene.enabledObjects.hasOwnProperty(object.objectId)) {
                    objectIdList.push(object.objectId);
                }
            } else {
                HumanScene._getEnabledLeaves(object.objects, objectIdList);
            }
        }
    };

    HumanScene._getKeys = function (map, val) {
        var keys = {};
        for (var key in map) {
            if (map.hasOwnProperty(key)) {
                key[key] = val;
            }
        }
        return keys;
    };

    /** Destroys an object and all sub-objects
     */
    HumanScene._destroyObject = function (objectId) {
        var object = HumanScene.objects[objectId];
        if (!object || object._destroyed) {
            return;
        }
        var o, i, len;
        for (i = 0, len = HumanScene.rootObjects.length; i < len; i++) {
            if (HumanScene.rootObjects[i].objectId === objectId) {
                HumanScene.rootObjects.splice(i, 1);
                break;
            }
        }
        delete HumanScene.objects[objectId];                              // Delete object
        if (object.fmaId) {
            delete HumanScene.objectsByFMAID[object.fmaId];
        }

        // Update enabled object counts at higher objects
        // When a higher object has an enabled object count, and this object is enabled, decrement the count
        if (HumanScene.enabledObjects[objectId]) {
            for (o = object.parent; o; o = o.parent) { // Blow away leaves caches on path to root
                if (o._enabledSubObjects !== undefined && o._enabledSubObjects !== null) {
                    o._enabledSubObjects--;
                }
            }
        }

        // Update selected object counts at higher objects
        // When a higher object has a selected object count, and this object is selected, decrement the count
        if (HumanScene.selectedObjects[objectId]) {
            for (o = object.parent; o; o = o.parent) { // Blow away leaves caches on path to root
                if (o._selectedSubObjects !== undefined && o._selectedSubObjects !== null) {
                    o._selectedSubObjects--;
                }
            }
        }

        delete HumanScene.selectedObjects[objectId];                      // Delete from selected objects
        delete HumanScene.enabledObjects[objectId];                       // Delete from enabled objects
        delete HumanScene.transparentObjects[objectId];
        delete HumanScene.pickThroughObjects[objectId];
        delete HumanScene.desaturatedObjects[objectId];
        delete HumanScene.backfaceObjects[objectId];

        HumanScene.numObjects--;
        if (object.parent) {
            object.parent._removeObject(objectId);
        }
        var children = object.objects.slice(0); // Avoid modification during removals
        for (i = 0, len = children.length; i < len; i++) {
            HumanScene._destroyObject(children[i].objectId);
        }
        object._destroy();
        object._destroyed = true;

        // TODO: check
//        for (var o = object.parent; o; o = o.parent) { // Blow away leaves caches on path to root
//            delete HumanScene._leavesCache[o.objectId];
//        }

        delete HumanScene.modelObjects[object.modelId][object.objectId];

        HumanScene._deregisterObjectForTags(object);

        // Will need to recompute leaf object cache
        HumanScene._leavesCache = {};

        // Will need to lazy-recompute boundary
        HumanScene._boundary = null;

        Human.events.fire("scene.objectDestroyed", { objectId: objectId });
    };


    /**
     * Get boundary enclosing selection of objects.
     *
     * <p>TODO</p>
     *  @memberof Human.scene
     */
    HumanScene.getBoundary = function (selection) {
        var object, objectId;

        if (!selection) {

            // Get boundary of all objects

            if (!HumanScene._boundary) {
                HumanScene._boundary = {
                    xmin: 100000, ymin: 100000, zmin: 100000, xmax: -100000, ymax: -100000, zmax: -100000
                };
                for (objectId in HumanScene.objects) {
                    if (HumanScene.objects.hasOwnProperty(objectId)) {
                        object = HumanScene.objects[objectId];
                        if (object.objects.length === 0) {               // Leaf object
                            var b = object.getBoundary();
                            if (b.xmin < HumanScene._boundary.xmin) {
                                HumanScene._boundary.xmin = b.xmin;
                            }
                            if (b.ymin < HumanScene._boundary.ymin) {
                                HumanScene._boundary.ymin = b.ymin;
                            }
                            if (b.zmin < HumanScene._boundary.zmin) {
                                HumanScene._boundary.zmin = b.zmin;
                            }
                            if (b.xmax > HumanScene._boundary.xmax) {
                                HumanScene._boundary.xmax = b.xmax;
                            }
                            if (b.ymax > HumanScene._boundary.ymax) {
                                HumanScene._boundary.ymax = b.ymax;
                            }
                            if (b.zmax > HumanScene._boundary.zmax) {
                                HumanScene._boundary.zmax = b.zmax;
                            }
                        }
                    }
                }
            }
            return HumanScene._boundary;
        }

        if (typeof selection === "string") {

            // Get boundary of a single object

            object = Human.scene.objects[selection];
            if (!object) {
                Human.log.warn("Human.scene.getBoundary", "Scene object not found: '" + selection + "'");
                return null;
            }
            return object.getBoundary();
        }

        // Get boundary of specified objects

        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var gotBoundary = false;
        var b2;

        if (Human._isArray(selection)) {
            for (var i = 0; i < selection.length; i++) {
                object = HumanScene.objects[selection[i]];
                if (!!object) {               // Leaf object
                    b2 = object.getBoundary();
                    if (b2.xmin < xmin) {
                        xmin = b2.xmin;
                    }
                    if (b2.ymin < ymin) {
                        ymin = b2.ymin;
                    }
                    if (b2.zmin < zmin) {
                        zmin = b2.zmin;
                    }
                    if (b2.xmax > xmax) {
                        xmax = b2.xmax;
                    }
                    if (b2.ymax > ymax) {
                        ymax = b2.ymax;
                    }
                    if (b2.zmax > zmax) {
                        zmax = b2.zmax;
                    }
                    gotBoundary = true;
                }
            }
        } else {

            for (objectId in selection) {
                if (selection[objectId] !== false) { // Selection map could be a boolean or an object
                    object = HumanScene.objects[objectId];
                    if (!!object) {               // Leaf object
                        b2 = object.getBoundary();
                        if (b2.xmin < xmin) {
                            xmin = b2.xmin;
                        }
                        if (b2.ymin < ymin) {
                            ymin = b2.ymin;
                        }
                        if (b2.zmin < zmin) {
                            zmin = b2.zmin;
                        }
                        if (b2.xmax > xmax) {
                            xmax = b2.xmax;
                        }
                        if (b2.ymax > ymax) {
                            ymax = b2.ymax;
                        }
                        if (b2.zmax > zmax) {
                            zmax = b2.zmax;
                        }
                        gotBoundary = true;
                    }
                }
            }
        }

        return gotBoundary ? 
            { xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax } : 
            { xmin: -100, ymin: -100, zmin: -100, xmax: 100, ymax: 100, zmax: 100 };
    };
})();
;(function () {
    "use strict";

    // HACK: Face winding bug hacks
    // Remove when condition meshes with face winding bug are re-exported

    var hackNeverBackfaces;
    var hackAlwaysBackfaces;

    Human.properties.subscribe({
        propId: "hacks.neverBackfaces",
        value: false,
        callback: function (value) {
            hackNeverBackfaces = value;
        }
    });

    Human.properties.subscribe({
        propId: "hacks.alwaysBackfaces",
        value: false,
        callback: function (value) {
            hackAlwaysBackfaces = value;
        }
    });


    /**
     * @class An object within {@link Human.scene}
     * @param cfg
     * @constructor
     */
    Human.scene.Object = function (cfg) {

        var self = this;

        this._hackAlwaysBackfaces = hackAlwaysBackfaces;
        this._hackNeverBackfaces = hackNeverBackfaces;

        this._init();

        /** ID of module that loaded the model that contains this object
         *
         * @type {moduleId|*}
         */
        this.moduleId = cfg.moduleId;

        /** ID of model that contains this object
         *
         * @type {modelId|*}
         */
        this.modelId = cfg.modelId;

        /** Unique ID of this object
         * @type {String}
         */
        this.objectId = cfg.objectId;

        /** True when this object was not explicitly assigned an ID and has one that's internally generated.
         * @type {String}
         */
        this.anonymous = cfg.anonymous;

        /** FMA ID
         * @type {String}
         */
        this.fmaId = cfg.fmaId;

        /** Z-sorting layer
         * @type {*}
         */
        this.layer = cfg.layer;

        /** Long display name
         * @type {String}
         */
        this.displayName = cfg.displayName;

        /** Short display name
         * @deprecated
         * @type {String}
         */
        this.name = cfg.displayName;

        /** Detailed description
         * @type {String}
         */
        this.description = cfg.description;

        /** Parent object
         * @type @link Human.scene.Object
         */
        this.parent = cfg.parent;

        /** True when this object is shown
         * @type {*|Boolean}
         */
        this.shown = false;

        /** True when this object is selected
         * @type {*|Boolean}
         */
        this.selected = false;

        /** Level in anatomy object hierarchy
         * @type {Number}
         */
        this.level = cfg.level;

        /** True when this object may be picked
         *  @type {Boolean}
         */
        this.pickable = true;

        /** True when this object may be clipped
         *  @type {Boolean}
         */
        this.clippable = true;

        /** True when this object is transparent.
         * <p>When transparent but not X-rayed, the object will retain its texture and color.</p>
         *  @type {Boolean}
         */
        this.transparent = false;

        /** True when this object is X-rayed
         *  @type {Boolean}
         */
        this.xray = false;

        /** When transparent, this controls the degree of "facing ratio" effect, which is
         * where the object becomes more opaque towards the edges.
         * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
         *  @type {Number}
         */
        this.glassFactor = cfg.glassFactor !== undefined ? cfg.glassFactor : 1.0;

        /** When transparent, this controls the degree of "murkiness" effect.
         * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
         *  @type {Number}
         */
        this.murkiness = cfg.murkiness !== undefined ? cfg.murkiness : 1.0;
        
        /** True when object color is desaturated
         * @type {boolean}
         */
        this.desaturate = !!cfg.desaturate;

        /** True when this object is highlighted
         *  @type {Boolean}
         */
        this.highlight = false;

        /** True when backfaces are shown in X-Ray mode
         *  @type {Boolean}
         */
        this.transparentBackfaces = false;

        /** False to prevent reversal of frontface vertex winding when object is reflected by a negative scaling transform
         *
         * @type {Boolean}
         */
        this.flip = cfg.flip !== false;

        /** Anatomy region metatags
         *
         * @type {Array of String}
         */
        this.tags = cfg.tags;

        /** Number of sub-objects
         *  @type {Number}
         */
        this.numSubObjects = 0;

        /** Number of sub-objects that have finished loading
         *  @type {Number}
         */
        this.numSubObjectsLoaded = 0;

        /** Sub-objects
         *  @type {[Human.scene.Object]}
         */
        this.objects = [];

        // Assets in array for boundary rebuild
        this._boundedAssets = [];

        //
        this._boundaryDirty = true;

        var node, material, flags;

        // Root of scene subgraph for this object

        if (cfg.parent) {
            // Chain subgraph onto parent object's
            this._rootNode = node = cfg.parent._childNodeContainer.addNode();
        } else {
            // No parent object
            this._rootNode = node = Human.renderer.getNode(cfg.attachNodeId).addNode();
        }

        // Modelling transform - both group and leaf objects have these

        this._transformNode = node = node.addNode({
            type: "xform"
        });

        this._childNodeContainer = this._transformNode;

        if (cfg.geometry || cfg.morph) {

            // Only the leaf objects will have assets

            if (cfg.material) {
                material = cfg.material;

                // When material assets are animated, they will
                // be driven driven directly by tween animations

                if (material.texture) {
                    // Use deprecated SceneJS texture - http://xeolabs.com/articles/scenejs4-release/#texture-node-changes
                    node = node.addNode({
                        type: "_texture",
                        coreId: material.texture.getCoreId()
                    });
                }
                if (material.material) {
                    node = node.addNode({
                        type: "material",
                        coreId: material.material.getCoreId()
                    });
                    this.glassFactor = material.glassFactor;
                    this.murkiness = material.murkiness;
                }
                if (material.reflection) {
                    node = node.addNode({
                        type: "reflect",
                        coreId: material.reflection.getCoreId()
                    });
                }
            }

            // Flags

            flags = {
                picking: this.pickable,
                enabled: false,
                specular: true,
                backfaceLighting: true,
                backfaceTexturing: true,
                backfaces: (this._hackNeverBackfaces === true) ? false : (this._hackAlwaysBackfaces === true ? true : true),
                reflection: true
            };

            this._xrayBackfaces = false;

            if (material && material.flags) {
                flags = Human._apply(material.flags.get("flags"), flags);
            }

            flags.enabled = false;
            flags.pickable = true;

            this._flagsNode = node = node.addNode({
                type: "flags",
                flags: flags
            });

            // Pick name

            this._nameNode = node = node.addNode({
                type: "name",
                name: cfg.objectId || "noname"
            });

            // Layer

            var layerPriority = 0; // Default layer

            if (cfg.layer) {
                layerPriority = cfg.layer;
            }

            this._layerNode = node = node.addNode({
                type: "layer",
                priority: layerPriority
            });

            // Shader

            this._shaderNode = node = node.addNode({ // Default custom shader
                type: "shader",
                coreId: "standard-shaders-xray"
            });

            // Shader params

            this._shaderParamsNode = node = node.addNode({
                type: "shaderParams",
                params: {
                    transparent: false,
                    xray: false,
                    highlight: false,
                    desaturate: this.desaturate, // Color or monochrome transparency
                    opacity: 1.0,
                    glassFactor: this.glassFactor,
                    murkiness: this.murkiness
                }
            });

            // Append morph

            if (cfg.morph) {
                node = node.addNode({
                    type: "morphGeometry",
                    coreId: cfg.morph.morphGeometry.getCoreId()
                });
                this._boundedAssets.push(cfg.morph);
            }

            // Append geometry

            if (cfg.geometry) {
                node.addNode({
                    type: "geometry",
                    coreId: cfg.geometry.geometry.getCoreId()
                });
                this._boundedAssets.push(cfg.geometry);
            }

        } // if (geometry || morph)

        // Bounding volume indicator

        /**
         * @private
         */
        this._bbox = createBBox();

        // Notify parent that child has been added
        if (this.parent) {
            this.parent._subObjectReady(this);
        }

        // Both branch and leaf nodes can have transform assets

        if (cfg.transform) {

            var transform = cfg.transform;

            this._transform = transform;

            // Update transform immediately from transform asset
            updateTransform();

            // Update whenever the asset changes
            transform.on("updated", updateTransform);

        } else {

            // Initial transform
            this.pivot = cfg.pivot ? Human._apply(cfg.pivot, { x: 0, y: 0, z: 0 }) : { x: 0, y: 0, z: 0 };
            this.translate = cfg.translate ? Human._apply(cfg.translate, { x: 0, y: 0, z: 0 }) : { x: 0, y: 0, z: 0 };
            this.scale = cfg.scale ? Human._apply(cfg.scale, { x: 1, y: 1, z: 1 }) : { x: 1, y: 1, z: 1 };
            this.rotate = cfg.rotate ? Human._apply(cfg.rotate, { x: 0, y: 0, z: 0 }) : { x: 0, y: 0, z: 0 };

            this._buildMatrix();
        }

        // Material 'alpha' is being used to set object's transparency
        if (cfg.material) {
            material = cfg.material.material;
            flags = cfg.material.flags;
            if (material && flags) {
                if (flags.getTransparent()) {
                    this.setOpacity(material.getAlpha()); // default to opaque alpha
                    this.setTransparent(true);
                }
            }
        }

        function updateTransform () {

            self.pivot = transform.pivot;
            self.translate = transform.translate;
            self.scale = transform.scale;
            self.rotate = transform.rotate;

            self._buildMatrix();
        }
    };

    Human.utils.extend(Human.scene.Object, Human.Component);

// Notifies objects on path to root that geometry sub-object has loaded.
    Human.scene.Object.prototype._subObjectReady = function (object) {
        this.numSubObjectsLoaded++;
        this._boundaryDirty = true;
        if (this.numSubObjects > 0 && this.numSubObjects === this.numSubObjectsLoaded) {
            // This is a group object and all its sub-objects have loaded
            if (this.parent) {
                // Notify parent
                this.parent._subObjectReady(this);
            }
        }
        // Relay notifications from sub-objects
        if (this.parent) {
            // Notify parent
            this.parent._subObjectReady(object);
        }
    };

    /**
     * Sets modelling transformation for this object
     *
     * @param {*} params Transform
     * @param {*} params.pivot Pivot point
     * @param {*} params.translate Translation vector
     * @param {*} params.scale Scaling vector
     * @param {*} params.rotate Rotation vectors
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setTransform = function (params) {

        if (this._transform) {

            // This object has a transform asset, so direct the update to that.

            // The transform asset will then fire an 'updated' event back at this object,
            // triggering the matrix rebuild.

            this._transform.set(params);
            return;
        }

        // Otherwise, update the transform parameters on this object and rebuild the matrix.
        // @deprecated

        if (params.pivot) {
            if (params.pivot.x !== undefined && params.pivot.x !== null) {
                this.pivot.x = params.pivot.x;
            }
            if (params.pivot.y !== undefined && params.pivot.y !== null) {
                this.pivot.y = params.pivot.y;
            }
            if (params.pivot.z !== undefined && params.pivot.z !== null) {
                this.pivot.z = params.pivot.z;
            }
        }

        if (params.translate) {
            if (params.translate.x !== undefined && params.translate.x !== null) {
                this.translate.x = params.translate.x;
            }
            if (params.translate.y !== undefined && params.translate.y !== null) {
                this.translate.y = params.translate.y;
            }
            if (params.translate.z !== undefined && params.translate.z !== null) {
                this.translate.z = params.translate.z;
            }
        }

        if (params.scale) {
            if (params.scale.x !== undefined && params.scale.x !== null) {
                this.scale.x = params.scale.x;
            }
            if (params.scale.y !== undefined && params.scale.y !== null) {
                this.scale.y = params.scale.y;
            }
            if (params.scale.z !== undefined && params.scale.z !== null) {
                this.scale.z = params.scale.z;
            }
        }

        if (params.rotate) {
            if (params.rotate.x !== undefined && params.rotate.x !== null) {
                this.rotate.x = params.rotate.x;
            }
            if (params.rotate.y !== undefined && params.rotate.y !== null) {
                this.rotate.y = params.rotate.y;
            }
            if (params.rotate.z !== undefined && params.rotate.z !== null) {
                this.rotate.z = params.rotate.z;
            }
        }

        this._buildMatrix();
    };

    var pivotMat = Human.math.mat4(); 
    var scaleMat = Human.math.mat4(); 
    var translateMat = Human.math.mat4(); 
    var rotateZMat = Human.math.mat4(); 
    var rotateYMat = Human.math.mat4(); 
    var rotateXMat = Human.math.mat4(); 
    var tempMat = Human.math.mat4(); 

    Human.scene.Object.prototype._buildMatrix = function () {
        var pivot = this.pivot;
        var translate = this.translate;
        Human.math.translationMat4v([-pivot.x, -pivot.y, -pivot.z], pivotMat);
        var scale = this.scale;
        Human.math.scalingMat4v([scale.x, scale.y, scale.z], scaleMat);
        Human.math.translationMat4v([translate.x + pivot.x, translate.y + pivot.y, translate.z + pivot.z], translateMat);
        var rotate = this.rotate;
        Human.math.rotationMat4v(rotate.z * Math.PI / 180.0, [0, 0, 1], rotateZMat);
        Human.math.rotationMat4v(rotate.y * Math.PI / 180.0, [0, 1, 0], rotateYMat);
        Human.math.rotationMat4v(rotate.x * Math.PI / 180.0, [1, 0, 0], rotateXMat);
        Human.math.identityMat4(tempMat);
        Human.math.mulMat4(pivotMat, tempMat, tempMat);
        Human.math.mulMat4(scaleMat, tempMat, tempMat);
        Human.math.mulMat4(rotateXMat, tempMat, tempMat);
        Human.math.mulMat4(rotateYMat, tempMat, tempMat);
        Human.math.mulMat4(rotateZMat, tempMat, tempMat);
        Human.math.mulMat4(translateMat, tempMat, tempMat);
        this.matrix = tempMat;
        this._transformNode.setElements(this.matrix);
        this._setBoundaryDirty();

        // Flip front face vertex winding whenever a negative scaling is applied

        if (this.flip) {
            if (this.scale.x < 0 || this.scale.y < 0 || this.scale.z < 0) {
                this._setFrontFaceWinding("cw");
            } else {
                this._setFrontFaceWinding("ccw"); // Default
            }
        }
    };

    Human.scene.Object.prototype._setBoundaryDirty = function () {
            this._boundaryDirty = true;
            this._setSubBoundaryDirty();
            this._setAncestorBoundaryDirty();
    };

    Human.scene.Object.prototype._setAncestorBoundaryDirty = function () {
        for (var parent = this.parent; parent && !parent._boundaryDirty; parent = parent.parent) {
            parent._boundaryDirty = true;            
        }
    };

    Human.scene.Object.prototype._setSubBoundaryDirty = function () {
        var child;
        for (var i = 0, len = this.objects.length; i < len; i++) {
            child = this.objects[i];
            if (!child._boundaryDirty) {
                child._boundaryDirty = true;
                child._setSubBoundaryDirty();
            }
            
        }
    };

    Human.scene.Object.prototype._setFrontFaceWinding = function (winding) {
        if (this._flagsNode) {
            this._flagsNode.setFrontface(winding);
        }
        for (var i = 0, len = this.objects.length; i < len; i++) {
            this.objects[i]._setFrontFaceWinding(winding);
        }
    };

    /**
     * Returns this object's World-space boundary
     * @memberof Human.scene.object
     * @return {*}
     */
    Human.scene.Object.prototype.getBoundary = function () {
        if (this._boundaryDirty) {
            this._rebuildBoundary();
        }
        return this._boundary;
    };

    /**
     * Gets this object's World-space boundary center
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.getCenter = function () {
        if (this._boundaryDirty) {
            this._rebuildBoundary();
        }
        return this._center;
    };

    Human.scene.Object.prototype._rebuildBoundary = function () {
        if (!this._boundaryDirty) {
            return;
        }

        var i, len;

        // Initial inside-out boundary, ready to expand to fit geometry or sub-objects
        this._boundary = {
            xmin: 1000000.0,
            ymin: 1000000.0,
            zmin: 1000000.0,
            xmax: -1000000.0,
            ymax: -1000000.0,
            zmax: -1000000.0
        };
        // Expand boundary to enclose world-space boundaries of any
        // geometry and morph assets that are referenced by this object
        if (this._boundedAssets) {
            var matrix = this._transformNode.getWorldMatrix();
            var axisBoundary;
            var worldBoundary;
            for (i = 0, len = this._boundedAssets.length; i < len; i++) {
                axisBoundary = this._boundedAssets[i].axisBoundary;
                if (axisBoundary) {
                    worldBoundary = this._getBoundary(Human.math.transformPoints3(matrix, axisBoundary.verts));
                    this._expandBoundary(this._boundary, worldBoundary);
                }
            }
        }
        // Expand boundary to enclose sub-objects
        var object;
        for (i = 0, len = this.objects.length; i < len; i++) {
            object = this.objects[i];
            if (object._boundaryDirty) {
                object._rebuildBoundary();
            }
            this._expandBoundary(this._boundary, object._boundary);
        }
        // Find center of boundary
        this._center = [
                (this._boundary.xmax + this._boundary.xmin) * 0.5,
                (this._boundary.ymax + this._boundary.ymin) * 0.5,
                (this._boundary.zmax + this._boundary.zmin) * 0.5
        ];
        this._boundaryDirty = false;
        // Show boundary
        this._bbox.setBoundary(this._boundary);
    };

    // Get minimal boundary enclosing the given vertex array
    Human.scene.Object.prototype._getBoundary = function (positions) {
        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var x, y, z;
        for (var i = 0, len = positions.length; i < len; i++) {
            x = positions[i][0];
            y = positions[i][1];
            z = positions[i][2];
            if (x === undefined || x === null ||
                y === undefined || y === null ||
                z === undefined || z === null) {
                continue;
            }
            if (x < xmin) {
                xmin = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (z < zmin) {
                zmin = z;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y > ymax) {
                ymax = y;
            }
            if (z > zmax) {
                zmax = z;
            }
        }
        return { xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax };
    };

    Human.scene.Object.prototype._expandBoundary = function (a, b) {
        if (a.xmin > b.xmin) {
            a.xmin = b.xmin;
        }
        if (a.ymin > b.ymin) {
            a.ymin = b.ymin;
        }
        if (a.zmin > b.zmin) {
            a.zmin = b.zmin;
        }
        if (a.xmax < b.xmax) {
            a.xmax = b.xmax;
        }
        if (a.ymax < b.ymax) {
            a.ymax = b.ymax;
        }
        if (a.zmax < b.zmax) {
            a.zmax = b.zmax;
        }
    };

    /** Add a child object and notify super-objects
     */
    Human.scene.Object.prototype.__addObject = function (object) {
        this.objects.push(object);
        this._subObjectAdded(object);
    };

    /**
     * Notitify nodes on path to root that child object created.
     * Each object counts how many geometry sub-objects are created.
     *
     * NOTE - All objects are created before any of them start to load,
     * so there should be no race condition between this method and _subObjectReady.
     */
    Human.scene.Object.prototype._subObjectAdded = function (object) {
        this.numSubObjects++;
        this._boundaryDirty = true;
        if (this.parent) {
            this.parent._subObjectAdded(object);
        }
    };

    /**
     * Show/hide this object
     * Only has effect on leaf objects, ignored on branch objects
     * @param {Boolean} doShow Flag specifying whether or not to show
     * @private
     */
    Human.scene.Object.prototype.show = function (doShow) {
        if (this.shown !== doShow) {
            if (this._flagsNode) {
                this._flagsNode.setEnabled(doShow);
            }
            this.shown = doShow;
            this.publish("shown", this.shown);
        }
    };


    /**
     * Select/deselect this object
     * @param {Boolean} doSelect Flag specifying whether or not to select
     * @private
     */
    Human.scene.Object.prototype.select = function (doSelect) {
        this.selected = doSelect;
    };


    /**
     * Set degree of transparency of this object - sets property, but only does something if this object has scene content
     *
     * @param {Number} opacity Degree of transparency between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setOpacity = function (opacity) {
        if (this._shaderParamsNode) {
            this._shaderParamsNode.setParams({ opacity: opacity  });
        }
    };

    /**
     * Enables/disables this object's transparency
     * Only has effect on leaf objects, ignored on branch objects
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setTransparent = function (transparent) {
        if (this.transparent !== transparent) {
            if (this._shaderParamsNode) {
                this._shaderParamsNode.setParams({
                    transparent: transparent
//                    ,
//
//                    // Only desaturate if also in XRay mode or explicitly desaturating, otherwise retain color
//                    desaturate: this.xray || this.desaturate
                });
                var alpha = (transparent || this.xray);
                this._flagsNode.setTransparent(alpha);
                this._flagsNode.setBackfaces((this._hackNeverBackfaces === true) ? false : (this._hackAlwaysBackfaces === true || !alpha));
            }
            this.transparent = transparent;
        }
    };

    /**
     * Set whether or not object appears X-rayed
     * Only has effect on leaf objects, ignored on branch objects
     * @param {boolean} xray True to make object appear X-rayed
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setXRay = function (xray) {
        if (this.xray !== xray) {
            if (this._shaderParamsNode) {
                this._shaderParamsNode.setParams({ xray: xray });
                var alpha = (xray || this.transparent);
                this._flagsNode.setTransparent(alpha);
                this._flagsNode.setBackfaces((this._hackNeverBackfaces === true) ? false : (this._hackAlwaysBackfaces === true || !alpha));

                // Only desaturate if now in XRay mode or explicitly desaturating, otherwise retain color
                this._shaderParamsNode.setParams({ desaturate: xray || this.desaturate });
            }
            this.xray = xray;
        }
    };

    /**
     * Switches object's color between gray monochrome or full color.
     * Only has effect on leaf objects, ignored on branch objects
     * @param desaturate
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setDesaturate = function (desaturate) {
        if (this.desaturate !== desaturate) {
            if (this._shaderParamsNode) {

                // Only desaturate if now desaturating or currently in X-ray mode, otherwise retain color
                this._shaderParamsNode.setParams({ desaturate: desaturate || this.xray });
            }
            this.desaturate = desaturate;
        }
    };

    /** When transparent, this sets the degree of "facing ratio" effect, which is
     * where the object becomes more opaque towards the edges.
     * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} glassFactor Degree of effect between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setGlassFactor = function (glassFactor) {
        this.glassFactor = glassFactor;
        if (this._shaderParamsNode) {
            this._shaderParamsNode.setParams({ glassFactor: glassFactor  });
        }
    };

    /** When transparent, this sets the degree of "murkiness" effect.
     * <p>Value is continuous, in the range [0.0..1.0], where 0.0 is no effect, while 1.0 is the full effect.
     *
     * @param {Number} murkiness Degree of effect between 0 and 1
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setMurkiness = function (murkiness) {
        this.murkiness = murkiness;
        if (this._shaderParamsNode) {
            this._shaderParamsNode.setParams({ murkiness: murkiness  });
        }
    };

    /**
     * Sets whether or not this object is pickable
     * Only has effect on leaf objects, ignored on branch objects
     * @param pickable
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setPickable = function (pickable) {
        if (this.pickable !== pickable) {
            if (this._flagsNode) {
                this._flagsNode.setPicking(pickable);
            }
            this.pickable = pickable;
        }
    };

    /**
     * Sets whether or not this object is clippable
     * Only has effect on leaf objects, ignored on branch objects
     * @param clippable
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setClippable = function (clippable) {
        if (this.clippable !== clippable) {
            if (this._flagsNode) {
                this._flagsNode.setClipping(clippable);
            }
            this.clippable = clippable;
        }
    };

    /**
     * Sets whether or not this object is highlight - only affects leaf objects
     * @param highlight
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setHighlight = function (highlight) {
        if (this.highlight !== highlight) {
            if (this._shaderParamsNode) {
                this._shaderParamsNode.setParams({ highlight: highlight });
            }
            this.highlight = highlight;
        }
    };

    /**
     * Sets whether or not this object shows backfaces whenever transparent.
     * Only has effect on leaf objects, ignored on branch objects
     * @param backfaces
     * @memberof Human.scene.object
     * @private
     */
    Human.scene.Object.prototype.setTransparentBackfaces = function () {
//        if (this.transparentBackfaces !== backfaces) {
//            if (this._flagsNode) {
//                var alpha = this.xray || this.transparent;
//                this._flagsNode.setBackfaces(!alpha || (alpha && backfaces));
//            }
//            this.transparentBackfaces = backfaces;
//        }
    };

    Human.scene.Object.prototype._destroy = function () {
        if (this._destroyed) {
            return;
        }
        if (this._rootNode) {
            this._rootNode.destroy();
        }
        if (this._bbox) {
            this._bbox.destroy();
        }
        this.publish("destroyed");
    };

    Human.scene.Object.prototype._removeObject = function (objectId) {
        for (var i = 0, len = this.objects.length; i < len; i++) {
            if (this.objects[i].objectId === objectId) {
                this.objects.splice(i, 1);
                this.numSubObjects--;
                return;
            }
            this._setBoundaryDirty();
        }
    };

    function createBBox() {
        var bbox = {};

        var flags = Human.renderer.getContentRootNode().addNode({
            type: "flags",
            flags: {
                enabled: false
            }
        });
        var material = flags.addNode({
            type: "material",
            color: { r: 0, g: 0, b: 1 }, // TODO: different colors for levels
            emit: 1
        });
        var geometry = material.addNode({
            type: "geometry",
            source: {
                type: "boundary"
            }
        });
        /**
         * @private
         */
        bbox.setShown = function (shown) {
            flags.setEnabled(shown);
        };
        /**
         * @private
         */
        bbox.setBoundary = function (boundary) {
            geometry.setSource(boundary);
        };
        /**
         * @private
         */
        bbox.destroy = function () {
            flags.destroy();
        };

        return bbox;
    }

})();;/**
 * @namespace Loads objects into {@link Human.scene}
 * @type {Loader}
 * @private
 */
(function () {
    "use strict";

    var HumanSceneLoader = Human.scene.loader = {};

    // Globals to simplify method signatures

    var moduleId;
    var modelId;
    var localAnatomyId;
    var globalAnatomyId;
    var manifest;
    var numSystemsToLoad;
    var layerStack = [];
    var layerStackLen = 0;

    // Records what's loaded with _load so it can be unloaded with _unload
    var loadedModelAnatomies = {};

    /**
     *
     * @param _moduleId
     * @param _modelId
     * @param anatomyId
     * @param params
     * @param ok
     * @param error
     */
    HumanSceneLoader.load = function (_moduleId, _modelId, anatomyId, params, ok, error) {

        moduleId = _moduleId;

        modelId = _modelId;

          // Globals to simplify method signatures      var modelId;     var localAnatomyId;     var globalAnatomyId;     var manifest;     var displayName;     var numSystemsToLoad;     var layerStack = [];     var layerStackLen = 0; [modelId] = loadedModelAnatomies[modelId] || {};

        localAnatomyId = anatomyId;
        globalAnatomyId = modelId + "." + localAnatomyId;

        loadedModelAnatomies[modelId] = loadedModelAnatomies[modelId] || {};

        if (loadedModelAnatomies[modelId][globalAnatomyId]) {
            Human.log.warn("Human.scene.Loader.load", "Library '" + anatomyId + "' already loaded for model '" + modelId + "' - not reloading");
            ok();
            return;
        }

        var temp = error;
        error = function (msg) {
            Human.log.error("Human.scene.loader", "Load failed: '" + globalAnatomyId + "': " + msg);
            // TODO: call HumanSceneLoader.unload(..)?
            delete loadedModelAnatomies[modelId][globalAnatomyId];
            temp(msg);
        };

        // Contains geometry library for this anatomy
        Human.assets.geometries.createLibrary(globalAnatomyId);

        loadedModelAnatomies[modelId][globalAnatomyId] = {
            geometryLibId: globalAnatomyId,
            objects: []
        };

        Human.net.getAnatomyManifest(
            localAnatomyId,
            function (json) {
                manifest = json.manifest;
                loadAnatomy(moduleId, modelId, ok, error);
            },
            function (error) {
                error("Human.scene.loader: failed to load anatomy manifest '" + localAnatomyId + "': " + error.errorText + " - status: " + error.request.status);
            });
    };

    /** Loads objects in manifest
     *
     * @param moduleId
     * @param modelId
     * @param ok
     * @param error
     */
    function loadAnatomy(moduleId, modelId, ok, error) {

        var manifestObjects = manifest.objects;

        var queue = [];
        for (var objectId in manifestObjects) {
            if (manifestObjects.hasOwnProperty(objectId)) {
                queue.push(objectId);
            }
        }

        numSystemsToLoad = queue.length;

        // Iterate over top-level manifest objects, which are systems
        // TODO: Clumsy invocation because ArrayIteration is meant to be
        // used as a constructor for some reason? 
        (Human.utils.ArrayIteration.call(
            {},
            queue,

            function (objectId, ok, error) {

                var object = manifestObjects[objectId];
                var systemDisplayName = object.displayname;
                var parentObjectData = null;
                var systemData = {
                    systemId: objectId
                };

                layerStackLen = 0;

                // Load geometry assets for this system
                loadSystemGeometries(
                    objectId,
                    systemDisplayName,
                    function () {

                        // Create object tree for this system
                        var newObject = createObject(modelId, object, parentObjectData, systemData);

                        // Record root object for unload
                        loadedModelAnatomies[modelId][globalAnatomyId].objects.push(newObject.objectId);

                        // System loaded
                        ok();
                    },
                    error);
            },

            function () {

                // All systems loaded

//                Human.events.fire("Anatomy.Created", {
//                    globalAnatomyId: globalAnatomyId,
//                    localAnatomyId: localAnatomyId
//                });

                ok();
            },
            error));
    }

    /**
     * Loads geometry assets for a system
     */
    function loadSystemGeometries(systemId, systemDisplayName, ok, error) {
        Human.net.getAnatomyIndex(
            localAnatomyId,
            systemId,
            function (index) {
                loadSystemGeometryArrays(systemId, systemDisplayName, index,
                    function (arrays) {
                        createSystemGeometries(systemId, index, arrays);
                        ok();
                    }, error);
            },
            error);
    }

    /**
     * Loads geometry arrays for a system, returns them via callback
     */
    function loadSystemGeometryArrays(systemId, systemDisplayName, index, _ok, _error) {

        var wasError = false;
        var arrays = {};

        // Fired when all arrays have loaded
        function ok() {
            if (!wasError) {
                _ok(arrays);
            }
        }

        function error(msg) {
            if (!wasError) {
                wasError = true;
                _error(msg);
            }
        }

        // Load the arrays

        var numArraysToLoad = 4; // Must equal number of Human.net.getXX calls below or loading will hang
        var numArraysLoaded = 0;

        Human.net.getAnatomyPositions(
            localAnatomyId,
            systemId,
            function (array) {
                arrays.positions = array;
                if (++numArraysLoaded === numArraysToLoad) {
                    ok();
                }
            },
            error);

        Human.net.getAnatomyNormals(
            localAnatomyId,
            systemId,
            function (array) {
                arrays.normals = array;
                if (++numArraysLoaded === numArraysToLoad) {
                    ok();
                }
            },
            error);

        Human.net.getAnatomyUVs(
            localAnatomyId,
            systemId,
            function (array) {
                arrays.uv = array;
                if (++numArraysLoaded === numArraysToLoad) {
                    ok();
                }
            },
            error);

        Human.net.getAnatomyIndices(
            localAnatomyId,
            systemId,
            function (array) {
                arrays.indices = array;
                if (++numArraysLoaded === numArraysToLoad) {
                    ok();
                }
            },
            error);
    }

    /**
     * Creates geometry assets for a system from the given geometry arrays
     */
    function createSystemGeometries(systemId, index, arrays) {
        for (var objectId in index) {
            if (index.hasOwnProperty(objectId)) {
                var objectIndexes = index[objectId];
                var positions = new Float32Array(slice(arrays.positions, objectIndexes.positions, Human.net.getOffset(systemId, objectId, "positions")));
                var boundary = getBoundary(positions);
                Human.assets.geometries.createGeometry(globalAnatomyId, globalAnatomyId + "." + objectId, {
                    geometry: {
                        primitive: "triangles",
                        positions: positions,
                        normals: new Float32Array(slice(arrays.normals, objectIndexes.normals, Human.net.getOffset(systemId, objectId, "normals"))),
                        uv: new Float32Array(slice(arrays.uv, objectIndexes.uv, Human.net.getOffset(systemId, objectId, "uv"))),
                        indices: new Uint16Array(slice(arrays.indices, objectIndexes.indices, Human.net.getOffset(systemId, objectId, "indices")))
                    },
                    boundary: boundary
                });
            }
        }
    }

    /**

     * @param portion Offset and num items, as shown in "uv" below:
     *  "Colon_14543":{
     *   "uv":[
     *       29148,
     *       8320
     *   ],
     */
    function slice(array, portion, bumpOffset) {
        var start = portion[0] - bumpOffset;
        var end = start + portion[1] - bumpOffset;
        if (array.subarray) {
            return array.subarray(start, end); // https://bugs.webkit.org/show_bug.cgi?id=53618
        } else {
            return array.slice(start, end);
        }
    }

    // Get minimal boundary enclosing the given array
    function getBoundary(positions) {
        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var x, y, z;
        for (var i = 0, len = positions.length - 2; i < len; i += 3) {
            x = positions[i];
            y = positions[i + 1];
            z = positions[i + 2];
            if (x === undefined || x === null ||
                y === undefined || y === null ||
                z === undefined || z === null ) {
                continue;
            }
            if (x < xmin) {
                xmin = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (z < zmin) {
                zmin = z;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y > ymax) {
                ymax = y;
            }
            if (z > zmax) {
                zmax = z;
            }
        }
        return { xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax };
    }

    /**
     * Recursively creates objects within Human.scene from manifest object data.
     */
    function createObject(modelId, object, parentObjectData, systemData) {

        // Render layer
        var layerStackTop = layerStackLen >= 0 ? layerStack[layerStackLen - 1] : null;
        var layer = object.priority;
        var subLayer = object.subLayer;
        if (subLayer !== undefined && subLayer !== null) {
            if (layerStackLen > 0) {
                layerStackTop = layerStack[layerStackLen - 1];
                layer = subLayer * ((1 + layerStackLen) * 0.001);
            }
        } else {
            if (layer === undefined || layer === null) {
                layer = layerStackLen > 0 ? layerStack[layerStackLen - 1] : 0;
            }
        }
        layerStack[layerStackLen++] = layer;

        var localObjectId = object.nodeId;
        var globalObjectId = modelId + "-" + localObjectId;
        var globalFMAId = (object.fmaid || object.fmaId) ? modelId + "-" + (object.fmaId || object.fmaid) : null;
        var parentObjectId = parentObjectData ? modelId + "-" + parentObjectData.nodeId : null;

        // Get material
        var material;
        if (object.materialId) {
            var materialId = modelId + "." + object.materialId;
            if (materialId) {
                material = Human.assets.materials.materials[materialId];
            } else {
                Human.log.error("Human.scene.loader", "Material not found: '" + object.materialId + "'");
            }
        }

        var transform;
        if (object.transformId) {
            transform = Human.assets.transforms.transforms[object.transformId];
            if (!transform) {
                transform = Human.assets.transforms.transforms[modelId + "." + object.transformId];
            }
            if (!transform) {
                Human.log.error("Human.scene.loader", "Transform asset not found: " + object.transformId);
            }
        }

        // Get geometry - will be null if not for leaf object
        var geometry = Human.assets.geometries.geometries[globalAnatomyId + "." + localObjectId];

        // Create object
        var newObject = Human.scene.__createObject({
            moduleId: moduleId,
            modelId: modelId,
            objectId: globalObjectId,
            localObjectId: localObjectId,
            objectName: object.nodeId,
            fmaId: globalFMAId,
            displayName: object.displayname,
            parentObjectId: parentObjectId,
            layer: layer,
            geometry: geometry,
            material: material,
            transform: transform,
            flip: object.flip,
            desaturate: object.desaturate,
            glassFactor: object.glassFactor,
            tags: object.tags || []
        });

        // Create child objects
        var childObjectData;
        if (object.objects) {
            for (var objectId in object.objects) {
                if (object.objects.hasOwnProperty(objectId)) {
                    childObjectData = object.objects[objectId];
                    createObject(modelId, childObjectData, object, systemData);
                }
            }
        }

        layerStackLen--;

        return newObject;
    }

    /**
     * Unloads anatomy that was loaded for a model
     *
     * @param modelId
     */
    HumanSceneLoader.unload = function (modelId) {
        var loaded = loadedModelAnatomies[modelId];
        if (!loaded) {
            return;
        }
        delete loadedModelAnatomies[modelId];
        var load;
        for (globalAnatomyId in loaded) {
            if (loaded.hasOwnProperty(globalAnatomyId)) {
                load = loaded[globalAnatomyId];
                // Destroy geometry assets
                Human.assets.geometries.destroyLibrary(load.geometryLibId);

                // Destroy objects
                var objectId;
                for (var i = 0, len = load.objects.length; i < len; i++) {
                    objectId = load.objects[i];
                    Human.scene._destroyObject(objectId);
                }
            }
        }
    };
})();;(function() {
    "use strict";


    /**
     * @namespace Loads those createObjects sections in model index files
     * @private
     */
    Human.scene.objectLoader = {

        _countAnonObjects: 0,

        // Remembers some initial object states so that we can apply them in a batch later.
        // Lazy-initialized when items are added, so that we can apply them only if not empty.

        _transparentObjects: null,
        _objectOpacities: null,
        _shownObjects: null,

        // Records what's loaded with _load so it can be unloaded with _unload
        _loaded: {}
    };

    Human.scene.objectLoader.load = function (moduleId, modelId, createObjects) {

        if (!createObjects) {
            return this;
        }

        this._transparentObjects = null;
        this._objectOpacities = null;
        this._shownObjects = null;

        var graft;
        var objects;
        var parentObject;

        // Graft object subtrees to their target parent objects
        for (var i = 0, len = createObjects.length; i < len; i++) {
            graft = createObjects[i];
            //        parentObjectId = graft.parentObjectId;
            //        if (!parentObjectId) {
            //            Human.log.error("parentObjectId expected");
            //            continue;
            //        }
            //        // Get parent object to graft to, assuming the object IDs are globally unique within anatomy
            //        parentObject = Human.scene.objects[parentObjectId];
            //        if (!parentObject) {
            //            Human.log.error("parent object not found: '" + parentObjectId + "'");
            //            continue;
            //        }
            var selection = {};
            parentObject = null;

            // Attach objects to parent
            objects = graft.objects;
            if (!objects) {
                continue;
            }
            var object;
            for (var j = 0, lenj = objects.length; j < lenj; j++) {
                object = objects[j];
                if (!object.objectId) {
                    Human.log.error("Human.scene.objectLoader", "Param expected on object: objectId");
                    continue;
                }
                this._attachObject(moduleId, modelId, parentObject, object);
                selection[object.objectId] = true;
            }
        }

        // Apply initial object states in a batch so that the scene
        // can apply inheritance of those states within the hierarchy

        if (this._transparentObjects) {
            Human.scene.setTransparentObjects({
                objectIds: this._transparentObjects,
                replace: false
            });
        }

        if (this._objectOpacities) {
            Human.scene.setObjectOpacities({
                objectIds: this._objectOpacities,
                replace: false
            });
        }

        if (this._shownObjects) {
            Human.scene.setEnabledObjects({
                objectIds: this._shownObjects,
                replace: false
            });
        }

        // Record what was loaded for this state for _unload
        this._loaded[modelId] = {
            createObjects: createObjects
        };
    };


    // Grafts an object tree onto a parent
    Human.scene.objectLoader._attachObject = function (moduleId, modelId, parentObject, object) {
        if (!object.objectId) {
            object.objectId = "___" + this._countAnonObjects++;
            object.anonymous = true;
        }
        parentObject = this._createObject(moduleId, modelId, parentObject, object);
        var objects = object.objects;
        if (objects) {
            for (var i = 0, len = objects.length; i < len; i++) {
                this._attachObject(moduleId, modelId, parentObject, objects[i]);
            }
        }
    };

    Human.scene.objectLoader._createObject = function (moduleId, modelId, parentObject, object) {

        var objectId = object.objectId;

        // These global IDs will be prefixed with this condition's ID
        var globalObjectId = modelId + "-" + objectId;
        var globalFMAId = (object.fmaid || object.fmaId) ? modelId + "-" + (object.fmaid || object.fmaId) : null;
        var systemId = parentObject ? parentObject.systemId : null;

        // Render order for transparency sorting
        var layer;
        if (parentObject) {
            if (object.layer !== undefined && object.layer !== null) {
                layer = parentObject.layer + (object.layer * 0.001);
            } else {
                layer = parentObject.layer;
            }
        } else {
            layer = object.layer || 0;
        }

        // Get assets (morphs, geometries etc) in this array, if any.
        // For each asset, set it's pick name and layer priority to those of this object,
        // which effectively mean that those assets will inherit the anatomy identity and
        // transparency sort order as defined by this object.

        var material; // Max one material per object
        var reflection; // Max one reflection per object
        var geometry; // Can have multiple geometries
        var morph; // Max one morph per object
        var transform; // Max one transform per object

        if (object.assets) {
            var assetId;
            for (var i = 0, len = object.assets.length; i < len; i++) {
                assetId = object.assets[i]; // Asset ID comes prefixed with the library ID
                var globalAssetId = modelId + "." + assetId;
                var asset;

                // See what the asset ID resolves to

                // Try getting a geometry
                asset = Human.assets.geometries.geometries[globalAssetId];
                if (asset) {
                    geometry = asset;

                    // Try getting material with partial ID
                    // This is a hack until geometries have the correct ID format instead of just
                    // something like "Blinn_SG567"
                    if (asset.materialId) {
                        asset = Human.assets.materials.findMaterial(asset.materialId);
                        if (asset) {
                            material = asset;
                        }
                    }

                } else {

                    // Try getting a material using the correct format, ie. "myState.myLibrary.myMaterial"
                    asset = Human.assets.materials.materials[globalAssetId];
                    if (asset) {
                        material = asset;
                    } else {

                        // Try getting a morph
                        asset = Human.assets.morphs.morphs[globalAssetId];

                        if (asset) {
                            morph = asset;

                            if (asset.materialId) {
                                asset = Human.assets.materials.findMaterial(asset.materialId);
                                if (asset) {
                                    material = asset;
                                }
                            }
                        } else {
                            Human.log.error("Human.scene.objectLoader", "Error in createObjects for '" + modelId + "' object '" + objectId + "': asset '" + assetId + "' not found");
                        }

                        //  asset = Human.timeline.animationsgeometries[globalAssetId];
                        //                        if (asset) {
                        //
                        ////                            material = ;
                        //                        }
                    }
                }
            }
        }

        if (object.geometryId) {
            //   if (typeof object.geometryId === "string") {
            geometry = Human.assets.geometries.geometries[object.geometryId];
            if (!geometry) {
                geometry = Human.assets.geometries.geometries[modelId + "." + object.geometryId];
            }
            if (!geometry) {
                Human.log.error("Human.scene.objectLoader", "Geometry asset not found: " + object.geometryId);
            }
            //    } else {
            //   }
        }

        if (object.morphId) {
            morph = Human.assets.morphs.morphs[object.morphId];
            if (!morph) {
                morph = Human.assets.morphs.morphs[modelId + "." + object.morphId];
            }
            if (!morph) {
                Human.log.error("Human.scene.objectLoader", "Morph asset not found: " + object.morphId);
            }
        }

        if (object.materialId) {
            material = Human.assets.materials.materials[object.materialId];
            if (!material) {
                material = Human.assets.materials.materials[modelId + "." + object.materialId];
            }
            if (!material) {
                Human.log.error("Human.scene.objectLoader", "Material asset not found: " + object.materialId);
            }
        }

        if (object.transformId) {
            transform = Human.assets.transforms.transforms[object.transformId];
            if (!transform) {
                transform = Human.assets.transforms.transforms[modelId + "." + object.transformId];
            }
            if (!transform) {
                Human.log.error("Human.scene.objectLoader", "Transform asset not found: " + object.transformId);
            }
        }

        if (!geometry && !morph && !material && !reflection &&
            (!object.assets || object.assets.length === 0) &&
            (!object.objects || object.objects.length === 0)) {
            // Log object that appears useless
            Human.log.warn("Human.scene.objectLoader", "Scene object with neither assets nor child objects: " + objectId);
        }

        // Create the object
        var newObject = Human.scene.__createObject({
            moduleId: moduleId,
            modelId: modelId,
            objectId: globalObjectId,
            anonymous: !!object.anonymous,
            localObjectId: objectId,
            objectName: objectId,
            fmaId: globalFMAId,
            systemId: systemId,
            displayName: object.displayName,
            description: object.description,
            parentObjectId: parentObject ? parentObject.objectId : null,
            layer: layer,
            shown: true,
            material: material,
            geometry: geometry,
            morph: morph,
            transform: transform,
            translate: object.translate,
            scale: object.scale,
            rotate: object.rotate,
            pivot: object.pivot,
            flip: object.flip,
            desaturate: object.desaturate,
            glassFactor: object.glassFactor,
            tags: object.tags || []
        });

        // Remember initially object states so that
        // we can apply those in a batch after loading all

        if (object.transparent !== undefined) {
            if (!this._transparentObjects) {
                this._transparentObjects = {};
            }
            this._transparentObjects[globalObjectId] = object.transparent;
        }

        if (object.opacity !== undefined) {
            if (!this._objectOpacities) {
                this._objectOpacities = {};
            }
            this._objectOpacities[globalObjectId] = object.opacity;
        }

        if (object.shown !== undefined) {
            if (!this._shownObjects) {
                this._shownObjects = {};
            }
            this._shownObjects[globalObjectId] = object.shown;
        }

        return newObject;
    };


    Human.scene.objectLoader.unload = function (modelId) {

        var loaded = this._loaded[modelId];
        if (!loaded) {
            return;
        }

        var createObjects = loaded.createObjects;

        delete this._loaded[modelId];

        var graft;
        var objects;
        var objectId;
        var object;

        // Remove subtrees that were attached
        // We only need to remove the roots

        for (var i = 0, len = createObjects.length; i < len; i++) {

            graft = createObjects[i];

            objects = graft.objects;
            for (var j = 0, lenj = objects.length; j < lenj; j++) {
                objectId = modelId + "-" + objects[j].objectId;
                if (!objectId) {
                    continue;
                }
                object = Human.scene.objects[objectId];
                if (!object) {
                    Human.log.error("Human.scene.objectLoader.unload", "Scene object not found: '" + objectId + "'");
                    continue;
                }
                Human.scene._destroyObject(object.objectId);
            }
        }
    };
})();

;(function() {
    "use strict";

    Human.rpc.define("scene.queryBoundary",
        function (params) {
            var boundary, object, fmaId;
            if (params.objectId) {

                // Get boundary of object by ID
                boundary = Human.scene.getBoundary(params.objectId);

            } else if (params.fmaId) {

                // get boundary of object by FMA ID
                fmaId = params.fmaId;
                object = Human.scene.objectsByFMAID[fmaId];
                if (!object) {
                    this.error("No scene object found for the given FMA ID: '" + fmaId + "'");
                    return;
                }
                boundary = Human.scene.getBoundary(object.objectId);

            } else if (params.objectIds) {

                // Get collective boundary of multiple objects by IDs
                boundary = Human.scene.getBoundary(params.objectIds);
                
            } else if (params.fmaIds) {

                // Get collective boundary of multiple objects by FMA IDs
                var fmaIds = params.fmaIds;
                var objectIds = [];
                for (var i = 0, len = fmaIds.length; i < len; i++) {
                    fmaId = fmaIds[i];
                    object = Human.scene.objectsByFMAID[fmaId];
                    if (!object) {
                        this.error("No scene object found for the given FMA ID: '" + fmaId + "'");
                        return;
                    }
                    objectIds.push(object.objectId);
                }
                boundary = Human.scene.getBoundary(objectIds);

            } else if (params.selectedObjects) {

                // Get collective boundary of all currently selected objects
                boundary = Human.scene.getBoundary(Human.scene.selectedObjects);
            } else if (params.enabledObjects) {

                // Get collective boundary of all currently visible objects
                boundary = Human.scene.getBoundary(Human.scene.enabledObjects);
            } else {

                // Default: get boundary of all objects
                boundary = Human.scene.getBoundary();
            }
            this.setResult(boundary);
        });

    Human.rpc.define("scene.setTransparentObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human._isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            Human.scene.setTransparentObjects({
                objectIds: objectIds,
                replace: params.replace
            });
        });

    function fmaIdsToObjectIds(map) {
        var result = {};
        var objectsByFMA = Human.scene.objectsByFMAID;
        var object;
        for (var fmaId in map) {
            if (map.hasOwnProperty(fmaId)) {
                object = objectsByFMA[fmaId];
                if (!object) {
                    Human.log.error("Object not found for FMA ID: '" + fmaId + "'");
                    continue;
                }
                result[object.objectId] = map[fmaId];
            }
        }
        return result;
    }

    Human.rpc.define("scene.setEnabledObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human._isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            Human.scene.setEnabledObjects({ objects: objectIds, replace: params.replace });
        });

    Human.rpc.define("scene.setSelectedObjects",
        function (params) {
            var objectIds;
            if (params.fmaIds) {
                objectIds = fmaIdsToObjectIds(params.fmaIds);
            } else {
                // Convert objects from ID array to map of true flags if neccessary
                if (Human._isArray(params.objectIds)) {
                    objectIds = {};
                    for (var i = 0, len = params.objectIds.length; i < len; i++) {
                        objectIds[params.objectIds[i]] = true;
                    }
                } else {
                    objectIds = params.objectIds;
                }
            }
            Human.scene.setSelectedObjects({ objects: objectIds, replace: params.replace });
        });

    (function () {
        Human.rpc.define("scene.getObjects",
            function (params) {
                var result = [];
                var object;
                if (params.objectId) {
                    var objectId = params.objectId;
                    object = Human.scene.objects[objectId];
                    if (object) {
                        result.push({
                            objectId: objectId,
                            displayName: object.displayName,
                            fmaId: object.fmaId,
                            parentObjectId: object.parent ? object.parent.objectId : null,
                            shown: !!Human.scene.enabledObjects[objectId],
                            selected: !!Human.scene.selectedObjects[objectId]
                        });
                    }
                } else {
                    // Get parent objects before their children so that on the API side we
                    // will always create HumanAPI.Objects for the parents BEFORE those for 
                    // their children, so that each child's HumanAPI.Object can be instantiated 
                    // with a reference to its parent's HumanAPI.Object.  
                    for (var i = 0, len = Human.scene.rootObjects.length; i < len; i++) {
                        traverseObjects(Human.scene.rootObjects[i], result);
                    }                       
                }
                this.setResult(result);
            });

        function traverseObjects(object, result) {
            if (!object) {
                return;
            }
            result.push({
                objectId: object.objectId,
                displayName: object.displayName,
                fmaId: object.fmaId,
                parentObjectId: object.parent ? object.parent.objectId : null,
                shown: !!Human.scene.enabledObjects[object.objectId],
                selected: !!Human.scene.selectedObjects[object.objectId]
            });
            for (var i = 0, len = object.objects.length; i < len; i++) {
                traverseObjects(object.objects[i], result);
            }
        }
    })();

    Human.rpc.define("scene.showBoundary",
        function (params) {
            var boundary;
            if (params.objectId) {
                boundary = Human.scene.getBoundary(params.objectId);
                if (boundary) {
                    Human.view.boundary.setBoundary(boundary, true);
                }
            } else {
                Human.view.boundary.setBoundary(false);
            }
        });


    Human.rpc.define("scene.setObjectTransform",
        function (params) {
            var objectId = params.objectId;
            var fmaId = params.fmaId;
            var object;
            if (objectId) { // Find object by ID
                object = Human.scene.objects[objectId];
                if (!object) {
                    this.error("Scene object not found: '" + objectId + "'");
                    return;
                }
            } else if (fmaId) { // Find object by FMA ID
                object = Human.scene.objectsByFMAID[fmaId];
                if (!object) {
                    this.error("scene object not found for the given FMA ID: '" + fmaId + "'");
                    return;
                }
            }
            object.setTransform(params);
        });

    (function () {
        var canvas = document.getElementById('theCanvas');
        
        var getCanvasPos = function (worldPos, offset) {
            if(offset) {
                Human.math.addVec3(worldPos, offset, worldPos);
            }
            
            var viewMat = Human.renderer.getViewMat();
            var projMat = Human.renderer.getProjMat();
            var projPos = Human.math.vec4();
            
            Human.math.transformPoint3(viewMat, worldPos, projPos);
            projPos[3]  = 1; // Need homogeneous 'w' for perspective division
            Human.math.transformPoint4(projMat, projPos, projPos);
        
            var x = projPos[0];
            var y = projPos[1];
            var w = projPos[3];
        
            return [
                Math.round((1 + x / w) * canvas.width  / 2), 
                Math.round((1 - y / w) * canvas.height / 2)
            ];
        };
        
        Human.rpc.define("scene.getCanvasPos",
            function (params) {
                this.setResult(getCanvasPos(params.worldPos, params.offset));
            });

        Human.rpc.define("scene.getObjectCanvasPos",
            function (params) {
               var object = Human.scene.objects[params.objectId];
           
               if(object) {
                   var worldPos = object.getCenter();
                   this.setResult(getCanvasPos(worldPos, params.offset));
               } 
            });
    })();
})();

;//Human.scene.reporter = new (function () {
//
//    var moduleCreations = {};
//    var moduleDestructions = {};
//
//    Human.events.on("modules.activating", function (params) {
//        moduleCreations[params.moduleId] = [];
//        moduleDestructions[params.moduleId] = [];
//    });
//
//    Human.events.on("modules.activated", function (params) {
//        Human.events.fire("scene.reporter.objectsCreated", {
//            objects: moduleCreations[params.moduleId]
//        });
//    });
//
//    Human.events.on("scene.objectCreated", function (params) {
//        moduleCreations[params.moduleId].push(params);
//        moduleDestructions[params.moduleId].push(params.objectId);
//    });
//
//    Human.events.on("modules.deactivated", function (params) {
//        Human.events.fire("scene.reporter.objectsDestroyed", {
//            objectIds: moduleDestructions[params.moduleId]
//        });
//        delete moduleCreations[params.moduleId];
//        delete moduleDestructions[params.moduleId];
//    });
//
//})();
;/**
 @namespace The animation timeline.

 <p>The animation timeline is the engine's temporal aspect. It contains whatever animations are currently loaded,
 possibly organizing and abstracting those within chapters which you can play, pause, scrub etc.</p>

 */
(function () {
    "use strict";

    var HumanTimeline = Human.timeline = {};

    /** All animations
     * @type {{}}
     */
    HumanTimeline.animations = {};

    /** Animations that are driven by the timeline
     * @type {{}}
     */
    HumanTimeline.timelineAnimations = {};

    /** Animations that run independently of the timeline
     * @type {{}}
     */
    HumanTimeline.freeAnimations = {};


    HumanTimeline._lastTime = null;
    HumanTimeline._lastActiveChapter = null;
    HumanTimeline._lastCameraChapter = null;

    HumanTimeline.chapterSets = {};
    HumanTimeline.chapters = {};

    HumanTimeline.FRAME_LENGTH = 0.033;

    /**
     The sequence of chapters currently on the timeline.

     <p><b>Example:</b></p>

     <p>Shown below is an example value for this property:</p>
     <pre>
     [{
        "chapterId": "_chapters.chapters0",
        "displayName": "Tweens",
        "description": "Tweens",
        "time": 0,
        "flyTo": {
            "eye": {
                "x": 0.8, "y": 0.19, "z": 2.0
            },
            "look": {
                "x": 0.0, "y": 0.1, "z": 1.9
            },
            "up": {
                "x": -2.8, "y": 0.9, "z": -2.6
            }
        }
     },
     {
         "chapterId": "_chapters.chapters1",
         "displayName": "Alpha Map",
         "description": "Alpha Map",
         "time": 10,
         "flyTo": {
             "eye": {
                 "x": 1.8, "y": 0.19, "z": 2.0
             },
             "look": {
                 "x": 3.0, "y": 0.1, "z": 1.9
             },
             "up": {
                 "x": 2.0, "y": 0.9, "z": -2.6
             }
         }
     },
     {
         "chapterId": "_chapters.chapters2",
         "displayName": "Highlight",
         "description": "Highlight",
         "time": 26,
         "flyTo": {
             "eye": {
                 "x": -2.8, "y": 0.19, "z": 2.0
             },
             "look": {
                 "x": 1.0, "y": 0.1, "z": 1.9
             },
             "up": {
                 "x": -9.8, "y": 0.9, "z": -2.6
             }
         }
     }]
     </pre>

     @type {Array}
     @memberof Human.timeline
     */
    HumanTimeline.chapterList = [];

    /**
     * Queue of play directives
     * These are created by #play()
     */
    HumanTimeline.playQueue = [];

    /**
     * When the current time is within a chapter, this map will contain {@link Human.scene.Object)s that the
     * chapter has explicitly specified visibilities for within its 'showObjects' property.
     *
     * @type {{string: Human.scene.Object}}
     */
    HumanTimeline.showObjects = {};

    /**
     * True when the timeline is currently playing
     *
     * @type {boolean}
     * @memberof Human.timeline
     */
    HumanTimeline.playing = false;

    /** True when the timeline is currently paused
     *
     * @type {boolean}
     * @memberof Human.timeline
     */
    HumanTimeline.paused = false;

    /** Current time on the timeline. This will update as the timeline plays or scrubs.
     *
     * @type {number}
     * @memberof Human.timeline
     */
    HumanTimeline.time = 0;

    /**
     * Direction the timeline is playing in - negative === backwards, positive === forwards
     * @type {number}
     */
    HumanTimeline.direction = 1.0;

    // Passed in to each animation's #update method
    HumanTimeline.animationCtx = {
        cameraEnabled: true // False when we don't want camera tweens running
    };

    // Enables or disables camera animation
    var cameraAnimationEnabled = true;

    Human.properties.subscribe({
        propId: "timeline.cameraAnimationEnabled",
        value: cameraAnimationEnabled,
        callback: function (value) {
            cameraAnimationEnabled = !!value;
            HumanTimeline.animationCtx.cameraEnabled = cameraAnimationEnabled;
        }
    });

    // Current timeframe we're playing within, if playing
    HumanTimeline._time1 = null;
    HumanTimeline._time2 = null;

    HumanTimeline._scrubbing = false;

    // When false and scrubbing, the next "tick" will not update camera animations
    HumanTimeline._scrubCamera = true;

    Human.events.on(
        "tick",
        function () {

            var timeNow = (new Date()).getTime();

            // Lazy-compute timeframe of entire timeline

            if (!HumanTimeline._timeFrame) {
                HumanTimeline.getTimeFrame();
            }

            // Update animations that are not bound to the timeline

            HumanTimeline._updateFreeAnimations();

            if (!HumanTimeline._scrubbing && !HumanTimeline.playing) {

                // Timeline is neither playing nor scrubbed

                HumanTimeline._lastTime = timeNow;

                return;
            }

            if (HumanTimeline._scrubbing) {

                // Timeline is scrubbing
                // Update timeline

                HumanTimeline._update(HumanTimeline._scrubCamera);

                HumanTimeline._scrubCamera = true;
                HumanTimeline._scrubbing = false;
                HumanTimeline._lastTime = null;

                // "timeline.scrubbed" event is fired by #scrub()

                return;
            }


            if (HumanTimeline.playing && !HumanTimeline.paused) {

                // Timeline is playing and not paused

                if (HumanTimeline._time1 === HumanTimeline._time2) {

                    // Timeline is empty, can't play
                    return;
                }

                // Bump time along by elapsed

                if (HumanTimeline._lastTime) {
                    HumanTimeline.time += (HumanTimeline.direction * ((timeNow - HumanTimeline._lastTime) / 1000));
                }

                // True if current timeline time is still within
                // time limits of the the current playing directive
                var timeInLimits = (HumanTimeline.direction > 0 && HumanTimeline.time > HumanTimeline._time2) || (HumanTimeline.direction < 0 && HumanTimeline.time < HumanTimeline._time2);

                if (!timeInLimits) {

                    // Time is still within limits
                    // Update timeline

                    Human.events.fire("timeline.playing", {
                        time: HumanTimeline.time
                    });

                    HumanTimeline._update();

                    HumanTimeline._lastTime = timeNow;

                    return;
                }

                // Time is outside limits

                if (HumanTimeline._loop) {

                    // Looping
                    // Wrap time within the limits
                    // Update timeline

                    HumanTimeline.time = HumanTimeline._time1 + HumanTimeline._fmod(HumanTimeline.time, HumanTimeline._time2 - HumanTimeline._time1);

                    Human.events.fire("timeline.playing", {
                        time: HumanTimeline.time
                    });

                    HumanTimeline._update();

                    HumanTimeline._lastTime = timeNow;

                    return;
                }

                // Not looping
                // Clamp time to the limits
                // Update timeline
                // Process next play directive or stop

                var min = HumanTimeline._time1 < HumanTimeline._time2 ? HumanTimeline._time1 : HumanTimeline._time2;
                var max = HumanTimeline._time1 > HumanTimeline._time2 ? HumanTimeline._time1 : HumanTimeline._time2;

                HumanTimeline.time = HumanTimeline.time < min ? min : (HumanTimeline.time > max ? max : HumanTimeline.time);

                HumanTimeline._update();

                if (HumanTimeline.playQueue.length > 0) {

                    // Play directives are queued up,
                    // process the next one

                    HumanTimeline._play(HumanTimeline.playQueue.pop());

                } else {

                    // Play directive queue is empty
                    // Stop playing

                    HumanTimeline.stop();
                }
            }
        });

    Human.events.on("snapshot.started", // Snapshot is about to be taken of the 3D canvas
        function () {
            HumanTimeline.pause();
        });

    Human.events.on("snapshot.finished", // Snapshot complete
        function () {
            HumanTimeline.unpause();
        });

    var prevNextScrub = true;
    Human.properties.subscribe({
        propId: "timeline.prevNextMode",
        value: prevNextScrub ? "scrub" : "play",
        callback: function (value) {
            prevNextScrub = (value === "scrub");
        }
    });

    HumanTimeline._fmod = function (a, b) {
        if (a < b) {
            Human.log.error("Human.timeline._fmod", "Attempting to find modulus within negative range - would be infinite loop - ignoring");
            return a;
        }
        while (b <= a) {
            a -= b;
        }
        return a;
    };


    /**
     * Runs the timeline for one frame at the current time.
     */
    HumanTimeline._update = function (cameraEnabled) {

        // Activate whatever chapter overlaps the current time,
        // unless that chapter is already active

        var chapter = HumanTimeline._findChapter(HumanTimeline.time);
        if (chapter) {
            HumanTimeline._activateChapter(chapter);
        }

        // Update each animation that runs off the timeline clock        

        var ctx = {
            cameraEnabled: cameraEnabled === false ? cameraEnabled : HumanTimeline.animationCtx.cameraEnabled
        };

        for (var animationId in HumanTimeline.timelineAnimations) {
            if (HumanTimeline.timelineAnimations.hasOwnProperty(animationId)) {
                HumanTimeline.timelineAnimations[animationId].update(ctx, HumanTimeline.time);
            }
        }
    };

    // Updates animations that are not updated off the timeline

    HumanTimeline._updateFreeAnimations = function () {

        // We assume that these animations are looping

        var time = (new Date()).getTime() / 1000;
        for (var animationId in HumanTimeline.freeAnimations) {
            if (HumanTimeline.freeAnimations.hasOwnProperty(animationId)) {
                HumanTimeline.freeAnimations[animationId].update(HumanTimeline.animationCtx, time);
            }
        }
    };

    /**
     Scrubs animation progress to given time or chapter.

     <p>Stops playing the timeline if it's currently playing.</p>

     <p><b>Scrubbing to a time instant:</b></p>
     <pre>
     Human.timeline.scrub({
        time: 9 // Seconds
      });
     </pre>

     <p><b>Scrubbing to a chapter:</b></p>
     <pre>
     Human.timeline.scrub({
        chapterId: "_chapters.chapters1"
      });
     </pre>

     @memberof Human.timeline
     */
    HumanTimeline.scrub = function (params) {

        var _update = function (time, scrubCamera) {

            // When scrubCamera is false then when we scrub the timeline
            // on the the next "tick", we'll not update any camera animations
            HumanTimeline.time = time;
            HumanTimeline._scrubbing = true;
            HumanTimeline.playing = false;
            HumanTimeline._looping = false;
            HumanTimeline._lastTime = null;
            HumanTimeline._nextChapter = null;
            HumanTimeline.playQueue = [];
            HumanTimeline._scrubParams = params;
            HumanTimeline._playParams = null;
            HumanTimeline._scrubCamera = scrubCamera;
            Human.events.fire("timeline.scrubbed", {
                time: HumanTimeline.time
            });
        };

        if (!HumanTimeline._timeFrame) {
            HumanTimeline.getTimeFrame();
        }
        params = params || {};
        var time = params.time;

        if (time !== undefined && time !== null) {

            // Scrubbing to time

            if (params.clamp) {
                if (time < HumanTimeline._timeFrame.firstTime) {
                    time = HumanTimeline._timeFrame.firstTime;
                } else if (time > HumanTimeline._timeFrame.lastTime) {
                    time = HumanTimeline._timeFrame.lastTime;
                }
            }

            _update.call(this, time, true); // Permit camera tweens
        } else if (params.chapterId) {

            // Scrubbing to chapter

            var chapterId = params.chapterId;
            var chapter = HumanTimeline.chapters[chapterId];

            if (!chapter) {
                Human.log.error("Human.timeline.scrub", "Chapter not found: '" + chapterId + "'");
                return;
            }

            if (chapter.flyTo) {
                
                // Chapter has a "flyTo"

                Human.view.camera.fly.flyTo(chapter.flyTo);

                _update.call(this, chapter.time, false); // Disallow camera tween

            } else {

                // Chapter has no "flyTo"

                _update.call(this, chapter.time, true); // Permit camera tweens
            }

        } else {

            // No time or chapter given

            _update.call(this, HumanTimeline._timeFrame.firstTime, true); // Permit camera tweens
        }
    };

    HumanTimeline._findChapter = function (time) {
        var chapter;
        for (var i = HumanTimeline.chapterList.length - 1; i >= 0; i--) {
            chapter = HumanTimeline.chapterList[i];
            if (chapter.time <= time) {
                return chapter;
            }
        }
    };

    HumanTimeline._activateChapter = function (chapter) {
        if (!HumanTimeline._lastActiveChapter || chapter.chapterId !== HumanTimeline._lastActiveChapter.chapterId) {
            Human.events.fire("timeline.chapters.activating", { chapterId: chapter.chapterId });

            if (chapter.showObjects) {
                HumanTimeline.showObjects = chapter.showObjects;
                Human.scene.setEnabledObjects({
                    objects: chapter.showObjects,
                    replace: true
                });
            } else {
                HumanTimeline.showObjects = {};
                Human.scene.setEnabledObjects({
                    replace: true
                });
            }
            if (chapter.selectObjects) {
                Human.scene.setSelectedObjects({
                    objects: chapter.selectObjects,
                    replace: true
                });
            } else {
                Human.scene.setSelectedObjects({
                    replace: true
                });
            }
            if (chapter.xray === true) {
                Human.rpc.call(null, "xray.setEnabled", { enable: true });
            } else {
                Human.rpc.call(null, "highlight.setEnabled", { enable: true });
            }
            if (chapter.screenPan) {
                Human.view.camera.setScreenPan(chapter.screenPan);
            }
            HumanTimeline._activateAnnotations(chapter);

            if (!HumanTimeline._lastCameraChapter || chapter.chapterId !== HumanTimeline._lastCameraChapter.chapterId) {
                if (cameraAnimationEnabled && chapter.flyTo) {
                    HumanTimeline._lastCameraChapter = chapter;
                } else if (cameraAnimationEnabled && chapter.jumpTo) {
                    HumanTimeline._lastCameraChapter = chapter;
                } else {
                    HumanTimeline.animationCtx.cameraEnabled = cameraAnimationEnabled;
                }
            }

            Human.events.fire("timeline.chapters.activated", {
                oldChapterIndex: HumanTimeline._lastActiveChapter ? HumanTimeline._lastActiveChapter.index : null,
                newChapterIndex: chapter.index,
                time: HumanTimeline.time,
                loop: HumanTimeline._loop
            });
            HumanTimeline._lastActiveChapter = chapter;
        }
    };

    HumanTimeline._activateAnnotations = function (chapter) {
        var annotations;
        var annotationId;
        var annotation;
        var i, len;
        if (HumanTimeline._lastLabelsChapter && HumanTimeline._lastLabelsChapter.annotations && HumanTimeline._lastLabelsChapter.chapterId !== chapter.chapterId) {
            annotations = HumanTimeline._lastLabelsChapter.annotations;
            for (i = 0, len = annotations.length; i < len; i++) {
                annotationId = "___" + HumanTimeline._lastLabelsChapter.chapterId + "." + i;
                annotation = Human.view.annotations.annotations[annotationId];
                if (annotation) {
                    annotation.destroy();
                }
            }
        }
        if (chapter.annotations && (!HumanTimeline._lastLabelsChapter || HumanTimeline._lastLabelsChapter.chapterId !== chapter.chapterId)) {
            annotations = chapter.annotations;
            for (i = 0, len = annotations.length; i < len; i++) {
                annotationId = "___" + chapter.chapterId + "." + i;
                var a = Human.view.annotations.annotations[annotationId];
                if (!a) {
                    annotation = annotations[i];
                    var pos;
                    if (!annotation.pos && annotation.objectId) {
                        var object = Human.scene.objects[annotation.objectId];
                        pos = object.getCenter();
                    }
                    Human.view.annotations.createAnnotation({
                        annotationId: annotationId,
                        objectId: annotation.objectId,
                        title: annotation.title || "",
                        description: annotation.description || "",
                        pos: annotation.pos || pos,
                        dir: annotation.pinVec || annotation.dir,
                        enabled: true,
                        shown: true,
                        labelShown: true,
                        saved: true
                    });
                } else {
                    a.pin.setEnabled(true);
                }
            }
        }
        HumanTimeline._lastLabelsChapter = chapter;
    };

    /**
     Plays the timeline, relative to given times and/or chapters.</p>

     <p><b>Playing from start time to end time</b></p>

     <p>You can start playing the timeline at a given time in seconds, to stop at the given time:</p>

     <pre>
     Human.timeline.play({
    startTime: 5, // Seconds
    finishTime: 23
 });
     </pre>

     <p><b>Playing from start time to end chapter</b></p>

     <p>You can start playing the timeline at a given time in seconds, to stop at the end of the given chapter, which
     must be after the start time on the timeline:</p>

     <pre>
     Human.timeline.play({
    startTime: 5, // Seconds
    finishChapterId: "_chapters.chapters1"
 });
     </pre>

     <p><b>Playing from start time to number of chapters</b></p>

     <p>You can start playing the timeline at a given time in seconds, to stop after playing the given number
     of subsequent chapters:</p>

     <pre>
     Human.timeline.play({
    startTime: 5, // Seconds
    numChapters: 1
 });
     </pre>

     <p><b>Playing from start chapter to end chapter</b></p>

     <p>You can start playing the timeline at the start of one chapter, to stop at the end of the other chapter:</p>

     <pre>
     Human.timeline.play({
    startChapterId: "_chapters.chapters0"
    finishChapterId: "_chapters.chapters1"
 });
     </pre>

     <p><b>Playing from start chapter to end time</b></p>

     <p>You can start playing the timeline at the start of one chapter, to stop at the given time, which must come after the
     start chapter:</p>

     <pre>
     Human.timeline.play({
    startChapterId: "_chapters.chapters0"
    finishTime: 24 // Seconds
 });
     </pre>

     <p><b>Playing from start chapter to number of chapters</b></p>

     <p>You can start playing the timeline at a given chapter, to stop after playing the given number of subsequent chapters:</p>
     <pre>
     Human.timeline.play({
    startChapterId: "_chapters.chapters0"
    numChapters: 2
 });
     </pre>
     @param {{}} params Play parameters
     @param {Number} [params.prevChapter] True play previous chapter
     @param {Number} [params.nextChapter] True play next chapter
     @param {Number} [params.startTime] Time in seconds to start playing at
     @param {Number} [params.finishTime] Time in seconds to stop playing at
     @param {String} [params.startChapterId] ID of chapter to start playing at
     @param {String} [params.finishChapterId] ID of chapter to stop playing at
     @param {String} [params.numChapters] Number of chapters to play before stopping

     @memberof Human.timeline
     */
    HumanTimeline.play = function (params) {
        params = params || {};
        if (params.queue && HumanTimeline.playing) {
            // Flagged to enqueue, currently playing
            HumanTimeline.playQueue.unshift(params);
        } else {
            // Kill queue, play immediately
            HumanTimeline.playQueue = [];
            HumanTimeline._play(params);
        }
    };

    HumanTimeline._play = function (params) {
        if (!HumanTimeline._timeFrame) {
            HumanTimeline.getTimeFrame();
        }

        if (HumanTimeline.paused) {
            HumanTimeline.paused = false;
            if ((params.startTime === undefined || params.startTime === null) && !params.startChapterId &&
                (params.finishTime === undefined || params.finishTime === null) && !params.finishChapterId && !params.numChapters) {

                // Just unpausing
                return;
            }
        }

        // Default time range
        var time1 = HumanTimeline._timeFrame.firstTime;
        var time2 = HumanTimeline._timeFrame.lastTime;

        var chapterId;
        var chapter;
        var index;

        // Override time range according to params

        // Determine start time

        if (params.prevChapter) {

            // Play the chapter preceding the current one

            if (HumanTimeline.chapterList.length === 0) {

                // No previous chapter
                return;
            }

            // Find the previous chapter, which we know we'll find

            index = 0;
            if (HumanTimeline._lastActiveChapter) {
                if (HumanTimeline._lastActiveChapter.index === 0) {
                    index = HumanTimeline.chapterList.length - 1;
                } else {
                    index = HumanTimeline._lastActiveChapter.index - 1;
                }
            }

            chapter = HumanTimeline.chapterList[index];

            // First time is start of previous chapter
            time1 = chapter.time;

            // Second time is end of previous chapter
            if (index < HumanTimeline.chapterList.length - 1) {
                time2 = HumanTimeline.chapterList[index + 1].time;
            }

            // Enter the chapter
            if (chapter.flyTo || chapter.jumpTo || chapter.showObjects || chapter.selectObjects) { // TODO: Need this check?
                HumanTimeline._activateChapter(chapter);
            }

        } else if (params.nextChapter) {

            // Play the chapter following the current one

            if (HumanTimeline.chapterList.length === 0) {

                // No chapters exist
                return;
            }

            // Find the preceding chapter
            index = 0;
            if (!HumanTimeline._lastActiveChapter) {

                // No current chapter, so we'll play the first chapter
                index = 0;
            } else {

                // Find the next chapter, which we know we'll find

                if (HumanTimeline._lastActiveChapter.index + 1 >= HumanTimeline.chapterList.length) {

                    // Already at the last chapter, so wrap around to find next chapter at the start
                    index = 0;
                } else {
                    index = HumanTimeline._lastActiveChapter.index + 1;
                }
            }

            chapter = HumanTimeline.chapterList[index];

            // First time is start of next chapter
            time1 = chapter.time;

            // Second time is end of next chapter
            if (index < HumanTimeline.chapterList.length - 1) {
                time2 = HumanTimeline.chapterList[index + 1].time;
            }

            // Enter the chapter
            if (chapter.flyTo || chapter.jumpTo || chapter.showObjects || chapter.selectObjects) { // TODO: Need this check?
                HumanTimeline._activateChapter(chapter);
            }

        } else if (params.startTime !== undefined && params.startTime !== null) {

            // Play from given start time

            // Clamp start time to beginning of timeline

            time1 = params.startTime < HumanTimeline._timeFrame.firstTime ?
                HumanTimeline._timeFrame.firstTime :
                (params.startTime > HumanTimeline._timeFrame.lastTime ?
                    HumanTimeline._timeFrame.lastTime :
                    params.startTime);

            // Find chapter at start time
            var curChapter = HumanTimeline._findChapter(time1);

            // If time1 is within a millisecond of start of nextChapter, then bump to nextChapter time
            if (curChapter) {
                var nextChapter = HumanTimeline.chapterList[curChapter.index + 1];
                if (nextChapter) {
                    var timeDiff = Math.round((nextChapter.time - time1) * 1000) / 1000;
                    if (timeDiff <= HumanTimeline.FRAME_LENGTH) {
                        time1 = nextChapter.time;
                    }
                }
            }

        } else if (params.startChapterId) {

            // Play from the given chapter

            chapterId = params.startChapterId;
            chapter = HumanTimeline.chapters[chapterId];
            if (!chapter) {

                // Chapter not found
                Human.log.error("Human.timeline.play", "Param 'startChapterId' does not match any chapters: '" + chapterId + "'");
                return;
            }

            // First time is start of chapter
            time1 = chapter.time;

            // Enter the chapter
            if (chapter.flyTo || chapter.jumpTo || chapter.showObjects || chapter.selectObjects) {
                HumanTimeline._activateChapter(chapter);
            }

        } else {

            // No start time or chapter given - will play from default, which is start of timeline

            HumanTimeline._lastCameraChapter = null;
        }

        // Determine finish time

        if (params.finishTime !== undefined && params.finishTime !== null) {

            // Finish time given

            // Clamp finish time to end of timeline

            time2 = params.finishTime < HumanTimeline._timeFrame.firstTime ? HumanTimeline._timeFrame.firstTime
                : (params.finishTime > HumanTimeline._timeFrame.lastTime ? HumanTimeline._timeFrame.lastTime : params.finishTime);

        } else if (params.finishChapterId) {

            // Finish chapter given

            chapterId = params.finishChapterId;
            chapter = HumanTimeline.chapters[chapterId];
            if (!chapter) {

                // Chapter not found
                Human.log.error("Human.timeline.play", "Param 'finishChapterId' does not match any chapters: '" + chapterId + "'");
                return;
            }

            // Finish time is one keyframe before start of chapter
            time2 = chapter.time - HumanTimeline.FRAME_LENGTH;

        } else if (params.numChapters) {

            // Number of chapters to play was given

            // Find chapter for the first time, along with its index
            var firstChapter;
            var firstChapterIndex = -1;
            for (var i = HumanTimeline.chapterList.length - 1; i >= 0; i--) {
                if (HumanTimeline.chapterList[i].time <= time1) {
                    firstChapter = HumanTimeline.chapterList[i];
                    firstChapterIndex = i;
                    break;
                }
            }

            // Find the finish chapter according to the number of chapters to play
            var lastChapterIndex = firstChapterIndex + params.numChapters;
            if (lastChapterIndex < HumanTimeline.chapterList.length) {

                // Finish chapter found; finish time is one keyframe (1/30th second) before start time of that chapter
                time2 = HumanTimeline.chapterList[lastChapterIndex].time - HumanTimeline.FRAME_LENGTH;
            } else {

                // No subsequent chapters found; finish time is then the duration of start chapter

                if (firstChapter.duration === undefined || firstChapter.duration === null) {
                    Human.log.error("Human.timeline.play", "Last chapter in chapters sequence does not have a 'duration'");
                } else {
                    time2 = firstChapter.time + firstChapter.duration;
                }
            }
        }

        HumanTimeline.playing = true;

        // Note that time1 is allowed to be greater than time2
        HumanTimeline._time1 = time1;
        HumanTimeline._time2 = time2;

        HumanTimeline.direction = (HumanTimeline._time1 < HumanTimeline._time2) ? 1.0 : -1.0;

        HumanTimeline._lastTime = null;

        HumanTimeline._loop = params.loop;

        HumanTimeline.time = (params.time !== undefined && params.time !== null) ? params.time : time1; // Time is captured by #saveBookmark

        HumanTimeline._playParams = params;
        HumanTimeline._scrubParams = null;

        Human.events.fire("timeline.played", {
            time: HumanTimeline.time
        });

        // Playing initiated - the "tick" subscription will now handle the actual playing progress.
    };

    /**
     * Plays the previous chapter to the current one
     */
    HumanTimeline.prev = function () {

        if (!HumanTimeline._lastActiveChapter) {
            return;
        }

        if (HumanTimeline._lastActiveChapter.index === 0) {
            return;
        }

        if (prevNextScrub) {

            // Prev/next scrubbing mode
            // Scrub to start of previous chapter

            HumanTimeline.scrub({
                chapterId: HumanTimeline.chapterList[HumanTimeline._lastActiveChapter.index - 1].chapterId
            });

        } else {

            // Prev/next playing mode

            var thisChapter = HumanTimeline.chapterList[HumanTimeline._lastActiveChapter.index];
            var prevChapter = HumanTimeline._lastActiveChapter.index > 0 ? HumanTimeline.chapterList[HumanTimeline._lastActiveChapter.index - 1] : null;

            if (prevChapter && prevChapter.loop) {

                // Target chapter has a 'loop' flag, so play from start of that
                // chapter to start of this chapter, while looping

                HumanTimeline.play({
                    startTime: prevChapter.time,
                    finishTime: thisChapter.time,
                    loop: true
                });

            } else {

                if ((HumanTimeline.time - thisChapter.time) > 0.1) {

                    // Scrubber is part-way through a chapter
                    // Play backwards and stop at the beginning of the current chapter

                    HumanTimeline.play({
                        startTime: HumanTimeline.time,
                        finishTime: thisChapter.time,
                        direction: -1
                    });

                } else {

                    // Scrubber is at the start of a chapter
                    // Play backwards and stop at the beginning of the previous chapter

                    var chapterId = HumanTimeline.chapterList[HumanTimeline._lastActiveChapter.index - 1].chapterId;
                    var chapter = HumanTimeline.chapters[chapterId];

                    HumanTimeline.play({
                        startTime: HumanTimeline.time,
                        finishTime: chapter.time,
                        direction: -1
                    });
                }
            }
        }
    };

    /**
     * Plays chapter following the current one
     */
    HumanTimeline.next = function () {

        if (!HumanTimeline._lastActiveChapter) {
            // Never played - scrub to start of timeline
            HumanTimeline.scrub({
                time: 0
            });
            return;
        }

        if (HumanTimeline._lastActiveChapter.index + 1 >= HumanTimeline.chapterList.length) {
            return;
        }

        var chapterId = HumanTimeline.chapterList[HumanTimeline._lastActiveChapter.index + 1].chapterId;

        if (prevNextScrub) {

            // Prev/next scrubbing mode
            // Scrub to start of next chapter

            HumanTimeline.scrub({
                chapterId: chapterId
            });

        } else {

            // Prev/next playing mode
            // Play from next chapter, looping within that if chapter has "loop" flag.

            var chapter = HumanTimeline.chapters[chapterId];
            if (chapter) {
                if (chapter.loop) {

                    // Target chapter has a 'loop' flag
                    // Play from start of that chapter to its end, while looping

                    HumanTimeline.play({
                        startTime: chapter.time,
                        numChapters: 1,
                        loop: chapter.loop
                    });

                } else {

                    // Target chapter has no 'loop' flag
                    // Play from current time to start of that chapter

                    HumanTimeline.play({
                        startTime: HumanTimeline.time,
                        finishTime: chapter.time
                    });
                }
            }
        }
    };

    HumanTimeline.mute = function (doMute) {
        // jshint unused: false
        // Human_sounds.mute(doMute);
    };

    /**
     Pauses timeline and returns true if it was playing before it was paused

     <p>Does nothing if timeline not currently playing.</p>

     <p><b>Example:</b></p>
     <p>When the timeline is currently playing, we can pause it like this:</p>
     <pre>
     Human.timeline.pause();
     </pre>

     @return {Boolean} True if timeline was playing.
     @memberof Human.timeline
     */
    HumanTimeline.pause = function () {
        if (HumanTimeline.playing) {
            HumanTimeline.paused = true;

            Human.events.fire("timeline.paused", {
                time: HumanTimeline.time
            });

            return true;
        }
    };

    /**
     Unpauses the timeline if it's currently paused.

     <p>Does nothing if timeline not currently paused.</p>

     <p><b>Example:</b></p>
     <p>When the timeline is currently paused, we can unpause it again like this:</p>
     <pre>
     Human.timeline.unpause();
     </pre>

     @memberof Human.timeline
     */
    HumanTimeline.unpause = function () {
        if (HumanTimeline.paused) {
            HumanTimeline.paused = false;
            HumanTimeline._lastTime = (new Date()).getTime(); // Ensures animation resumes where it was paused

            Human.events.fire("timeline.unpaused", {
                time: HumanTimeline.time
            });
        }
    };

    /**
     Stops playing the timeline if it's currently playing.

     <p>Does nothing if timeline not currently playing.</p>

     <p><b>Example:</b></p>
     <p>When the timeline is currently playing, we can stop it like this:</p>
     <pre>
     Human.timeline.stop();
     </pre>
     @memberof Human.timeline
     */
    HumanTimeline.stop = function () {
        var animation;
        for (var animationId in HumanTimeline.timelineAnimations) {
            if (HumanTimeline.timelineAnimations.hasOwnProperty(animationId)) {
                animation = HumanTimeline.timelineAnimations[animationId];
                if (animation.stop) {
                    animation.stop();
                }
            }
        }
        HumanTimeline._scrubbing = false;
        HumanTimeline.playing = false;
        HumanTimeline._loop = false;
        HumanTimeline._lastTime = null;
        HumanTimeline.playQueue = [];
        Human.events.fire("timeline.stopped", {
            time: HumanTimeline.time
        });
    };

    /**
     * Registers an animation on the timeline
     * @memberof Human.timeline
     * @private
     */
    HumanTimeline.addAnimation = function (animationId, animation) {
        if (!animation.update) {
            Human.log.error("Human.timeline.addAnimation", "Param expected: update");
            return;
        }
        if (HumanTimeline.animations[animationId]) {
            HumanTimeline.removeAnimation(animationId);
        }
        HumanTimeline.animations[animationId] = animation;

        if (animation.timeline === false) {

            // Animation runs independently of timeline
            HumanTimeline.freeAnimations[animationId] = animation;

        } else {

            // Animation driven off timeline
            HumanTimeline.timelineAnimations[animationId] = animation;
            HumanTimeline._timeFrame = null; // Need recompute now
        }

        Human.events.fire("Timeline.Loaded");
    };

    /** Destroy animation(s) - either a specific animation, all animations associated with a given object,
     * or all animations indiscriminately
     * @memberof Human.timeline
     * @private
     */
    HumanTimeline.removeAnimation = function (animationId) {
        var animation = HumanTimeline.animations[animationId];
        if (!animation) {
            Human.log.warn("Human.timeline.removeAnimation", "Animation not found: " + animationId);
            return;
        }
        delete HumanTimeline.animations[animationId];

        if (animation.timeline === false) {

            // Animation runs independently of timeline
            delete HumanTimeline.freeAnimations[animationId];
            HumanTimeline._timeFrame = null; // Need recompute now

        } else {

            // Animation driven off timeline
            delete HumanTimeline.timelineAnimations[animationId];
        }

        if (animation.destroy) {                                            // Destroy animation
            animation.destroy();
        }

        Human.events.fire("Timeline.Empty");
    };

    /** Adds a chapter set onto the timeline
     * @memberof Human.timeline
     * @private
     */
    HumanTimeline.addChapterSet = function (chapterSetId, chapters) {

        var chapterId;
        var newChapter;
        var chapter;

        for (var i = 0, len = chapters.length; i < len; i++) {

            newChapter = chapters[i];

            chapterId = newChapter.chapterId;

            if (!chapterId) {
                Human.log.error("Human.timeline.addChapterSet", "Chapter property missing: chapterId");
                continue;
            }

            if (HumanTimeline.chapters[chapterId]) {
                Human.log.error("Human.timeline.addChapterSet", "Chapter '" + chapterId + "' already defined");
                continue;
            }

            if (!newChapter.displayName) {
                Human.log.warn("Human.timeline.addChapterSet", "Chapter '" + chapterId + "' attribute missing: 'displayName' - substituting empty string");
                newChapter.displayName = "";
            }

            if (newChapter.time === undefined || newChapter.time === null) {
                Human.log.error("Human.timeline.addChapterSet", "Chapter '" + chapterId + "' attribute missing: 'time'");
                continue;
            }

            // Insert into time-sorted sequence
            HumanTimeline.chapters[chapterId] = newChapter;

            if (HumanTimeline.chapterList.length === 0) {
                HumanTimeline.chapterList.push(newChapter);
                newChapter.index = 0;

            } else {

                var inserted = false;
                var j, lenj;

                for (j = HumanTimeline.chapterList.length - 1; j >= 0; j--) {
                    chapter = HumanTimeline.chapterList[j];
                    if (chapter.time < newChapter.time) {
                        HumanTimeline.chapterList.splice(j + 1, 0, newChapter);
                        inserted = true;
                        break;
                    }
                }
                if (!inserted) {
                    HumanTimeline.chapterList.splice(0, 0, newChapter);
                }
                for (j = 0, lenj = HumanTimeline.chapterList.length; j < lenj; j++) {
                    HumanTimeline.chapterList[j].index = j;
                }
            }
        }

        HumanTimeline.chapterSets[chapterSetId] = chapters;

        HumanTimeline._lastActiveChapter = null;
        HumanTimeline._lastCameraChapter = null;

        HumanTimeline._timeFrame = null; // Need recompute now

        Human.events.fire("timeline.chapters.updated", HumanTimeline.chapterList);
    };

    /** Removes a chapter set from the timeline
     * @memberof Human.timeline
     * @param {String} chapterSetId ID of chapter set to remove
     * @private
     */
    HumanTimeline.destroyChapterSet = function (chapterSetId) {
        var i, len;

        if (chapterSetId) {
            var chapters = HumanTimeline.chapterSets[chapterSetId];
            if (!chapters) {
                Human.log.warn("Human.timeline.destroyChapterSet", " Chapter set not found: " + chapterSetId);
                return;
            }
            for (i = 0, len = chapters.length; i < len; i++) {
                var chapterId = chapters[i].chapterId;
                delete HumanTimeline.chapters[chapterId];
                // Delete from sequence
                var chapter;
                for (var j = HumanTimeline.chapterList.length - 1; j >= 0; j--) {
                    chapter = HumanTimeline.chapterList[j];
                    if (chapter.chapterId === chapterId) {
                        HumanTimeline.chapterList.splice(j, 1);
                        break;
                    }
                    if (chapter.annotations) {
                        destroyChapterAnnotations(chapter);
                    }
                }
            }
            delete HumanTimeline.chapterSets[chapterSetId];
        } else {
            HumanTimeline.chapterSets = {};
            HumanTimeline.chapters = {};
            HumanTimeline.chapterList = [];
        }
        for (i = 0, len = HumanTimeline.chapterList.length; i < len; i++) {
            HumanTimeline.chapterList[i].index = i;
        }
        HumanTimeline._lastActiveChapter = null;
        HumanTimeline._lastCameraChapter = null;
        HumanTimeline._timeFrame = null; // Need recompute now

        // Notify of chapters update
        Human.events.fire("timeline.chapters.updated", HumanTimeline.chapterList);
    };

    function destroyChapterAnnotations(chapter) {
        if (chapter.annotations) {
            var annotationId;
            var annotation;
            var annotations = chapter.annotations;
            for (var i = 0, len = annotations.length; i < len; i++) {
                annotationId = "___" + chapter.chapterId + "." + i;
                annotation = Human.view.annotations.annotations[annotationId];
                if (annotation) {
                    annotation.destroy();
                }
            }
        }
    }

    /**
     * Returns time frame enclosing keys of any animations and chapters on the timeline.
     * <p><b>Example:</b></p>
     * <pre>
     * var timeFrame = Human.timeline.getTimeFrame();
     * </pre>
     * <p>Example return value:</p>
     * <pre>
     *     {
     *          firstTime: 0,
     *          lastTime: 34
     *     }
     * </pre>
     * @memberof Human.timeline
     * @return The timeframe
     */
    HumanTimeline.getTimeFrame = function () {
        if (HumanTimeline._timeFrame) {
            return HumanTimeline._timeFrame;
        }
        var anyAnimations = false;
        var min = 0;
        var max = 0;
        var timeFrame;

        // Expand to enclose timeline animations

        for (var animationId in  HumanTimeline.timelineAnimations) {
            if (HumanTimeline.timelineAnimations.hasOwnProperty(animationId)) {
                anyAnimations = true;
                timeFrame = HumanTimeline.timelineAnimations[animationId].getTimeFrame();
                if (timeFrame.firstTime < min) {
                    min = timeFrame.firstTime;
                }
                if (timeFrame.lastTime > max) {
                    max = timeFrame.lastTime;
                }
            }
        }

        // Expand to enclose chapters

        var chapter;
        for (var i = 0, len = HumanTimeline.chapterList.length; i < len; i++) {
            chapter = HumanTimeline.chapterList[i];
            if (chapter.time < min) {
                min = chapter.time;
            }
            if (chapter.time > max) {
                max = chapter.time;
            }
            if (chapter.duration !== undefined && chapter.duration !== null) {
                if (chapter.duration < min) {
                    min = chapter.duration;
                }
                if (chapter.duration > max) {
                    max = chapter.duration;
                }
            }
        }

        HumanTimeline._timeFrame = {
            firstTime: min,
            lastTime: max
        };

        Human.events.fire("timeline.timeFrame.updated", HumanTimeline._timeFrame);

        return HumanTimeline._timeFrame;
    };

    /**
     * Gets a bookmark of the timeline's current playing state. This does not bookmark the content
     * currently loaded within the timeline, so when restoring the bookmark, ensure that all the currently-loaded
     * animations and chapters are loaded first.
     * @memberof Human.timeline
     * @return The bookmark, which may be given to {@link Human.timeline.setBookmark} to restore it
     * @private
     */
    HumanTimeline.getBookmark = function () {
        if (HumanTimeline._scrubParams) {
            return {
                scrub: Human._shallowClone(HumanTimeline._scrubParams)
            };
        } else if (HumanTimeline._playParams) {
            return {
                play: Human._apply(HumanTimeline._playParams, {
                    time: HumanTimeline.time
                })
            };
        } else if (HumanTimeline.time) {
            return {
                scrub: {
                    time: HumanTimeline.time
                }
            };
        }
        return {};
    };

    /**
     * Sets timeline's playing state to given bookmark. Assumes that the animations and chapters
     * that were on the timeline when the bookmark was captured are currently loaded.
     * @memberof Human.timeline
     * @param {*} bookmark The bookmark
     * @private
     */
    HumanTimeline.setBookmark = function (bookmark) {
        if (bookmark.scrub) {
            HumanTimeline.scrub(bookmark.scrub);
        } else if (bookmark.play) {
            HumanTimeline.play(bookmark.play);
        }
    };

    /** Queries the current state of the timeline - chapters, current time etc.
     *
     * @returns {*}
     */
    HumanTimeline.query = function () {
        var chapters = [];
        var chapter;
        for (var i = 0, len = HumanTimeline.chapterList.length; i < len; i++) {
            chapter = HumanTimeline.chapterList[i];
            chapters.push({
                chapterId: chapter.chapterId,
                type: chapter.type,
                displayName: chapter.displayName,
                description: chapter.description,
                tags: chapter.tags,
                annotations: chapter.annotations || null,
                hotspots: chapter.hotspots || null,
                flyTo: chapter.flyTo,
                active: chapter.active,
                time: chapter.time,
                sounds: chapter.sounds,
                translations: chapter.translations
            });
        }
        return {
            chapters: chapters,
            time: HumanTimeline.time,
            timeFrame: HumanTimeline._timeFrame,
            playing: HumanTimeline.playing,
            paused: HumanTimeline.paused
        };
    };
})();
;(function() {
    "use strict";

    Human.timeline.animationLoader = new Human.utils.Loader();

    Human.timeline.animationLoader.configure = function (params) {
        this._embedded = params.embedded;
        return this;
    };

    Human.timeline.animationLoader._animations = {};

    Human.timeline.animationLoader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localAnimationId = libraryId;
        var globalAnimationId = modelId + "." + libraryId;

        var self = this;

        Human.net.getAnimationManifest(

            localAnimationId,

            function (manifest) {
                var errMsg;

                if (!manifest.format) {
                    errMsg = "'format' attribute expected in manifest for animation library '" + localAnimationId + "'";
                    Human.log.error("Human.timeline.animationLoader", errMsg);
                    error(errMsg);
                    return;
                }

                var loader;

                switch (manifest.format) {
                    case "binary":
                        loader = Human.assets.morphs.loader;
                        break;
                    case "tween":
                        loader = Human.timeline.Tween.loader;
                        break;
                    default:
                        errMsg = "Unsupported value '" + manifest.format +
                            "' for 'format' in manifest for animation library '" + localAnimationId +
                            "' - supported values are 'binary' and 'tween'";
                        Human.log.error("Human.timeline.animationLoader", errMsg);
                        error(errMsg);
                        return;
                }

                loader.load(modelId, localAnimationId, globalAnimationId, manifest, params,
                    function () {
                        self._animations[globalAnimationId] = {
                            loader:loader
                        };
                        ok();
                    },
                    error);
            },
            function (errMsg) {
                var msg = "Failed to load animation library '" + localAnimationId + "': " + errMsg;
                Human.log.error("Human.timeline.animationLoader", msg);
                error(msg);
            });
    };

    Human.timeline.animationLoader._unload = function (globalLibraryId) {
        var animation = this._animations[globalLibraryId];
        if (animation) {
            animation.loader.unload(globalLibraryId);
            delete this._animations[globalLibraryId];
        }       
    };

})();
;(function() {
    "use strict";

    /**
     * @namespace Loads chapters into {@link Human.timeline}
     * @private
     * @type {Loader}
     */
    Human.timeline.chapterLoader = new Human.utils.Loader();

    Human.timeline.chapterLoader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localChapterSetId = libraryId;
        var globalChapterSetId = modelId + "." + localChapterSetId;

        var self = this;

        Human.net.getChapterSetManifest(
            localChapterSetId,
            function (manifest) {
                self._preprocessManifest(modelId, globalChapterSetId, manifest);
                if (Human._isArray(manifest.chapters)) {
                    Human.timeline.addChapterSet(globalChapterSetId, manifest.chapters);
                }
                ok();
            },
            function (e) {
                error("failed to load chapters module '" + localChapterSetId + "': " + e.errorText +
                    " - status: " + e.request.status);
            });
    };

    /**
     * Globalizes the sound reference IDs on chapters so that they uniquely ID their sounds
     * across state namespaces
     */
    Human.timeline.chapterLoader._preprocessManifest = function (modelId, globalChapterSetId, manifest) {
        var chapters = manifest.chapters;
        var chapter;
        var i, len;

        if (Human._isArray(chapters)) {
            for (i = 0, len = chapters.length; i < len; i++) {
                chapter = chapters[i];
                chapter.chapterId = globalChapterSetId + i;
                this._preprocessChapter(modelId, chapter);
            }
        } else {
            i = 0;
            for (var chapterId in chapters) {
                if (chapters.hasOwnProperty(chapterId)) {
                    chapter = chapters[chapterId];
                    chapter.chapterId = globalChapterSetId + i++;
                    this._preprocessChapter(modelId, chapter);
                }
            }
        }
    };

    Human.timeline.chapterLoader._preprocessChapter = function (modelId, chapter) {
        var sounds = chapter.sounds;
        var i, len;

        if (sounds) {
            for (i = 0, len = sounds.length; i < len; i++) {
                var sound = sounds[i];
                sound.soundId = modelId + "." + sound.soundId;
            }
        }

        // Allow both "internal" and "external" object IDs in showObjects and selectObjects
        // Internal IDs are of objects created within this model, while external IDs are of
        // objects in another model, and thus prefixed with the ID of that model.

        // showObjects
        var showObjects = chapter.showObjects;
        var globalObjectId;
        var objectId;

        if (showObjects) {
            for (objectId in showObjects) {
                if (showObjects.hasOwnProperty(objectId)) {
                    if (objectId.indexOf("-") < 0) {
                        globalObjectId = modelId + "-" + objectId;
                        // Object ID is local - prefix it to make global
                        showObjects[globalObjectId] = showObjects[objectId];
                        delete showObjects[objectId];
                    }
                }
            }
        }

        // selectObjects
        var selectObjects = chapter.selectObjects;
        if (selectObjects) {
            for (objectId in selectObjects) {
                if (selectObjects.hasOwnProperty(objectId)) {
                    if (objectId.indexOf("-") < 0) {
                        globalObjectId = modelId + "-" + objectId;
                        // Object ID is local - prefix it to make global
                        selectObjects[globalObjectId] = selectObjects[objectId];
                        delete selectObjects[objectId];
                    }
                }
            }
        }

        // annotations
        var annotations = chapter.annotations;
        if (annotations) {
            var annotation;
            for (i = 0, len = annotations.length; i < len; i++) {
                annotation = annotations[i];
                if (annotation.objectId) {
                    if (annotation.objectId.indexOf("-") < 0) {
                        annotation.objectId = modelId + "-" + annotation.objectId;
                    }
                }
            }
        }

        return {sounds:sounds, i:i, len:len, sound:sound};
    };


    Human.timeline.chapterLoader._unload = function (globalLibraryId) {
        Human.timeline.destroyChapterSet(globalLibraryId);
    };
})();
;(function() {
    "use strict";

    
    /**
     * A Tween Animation Module
     * @private
     */
    Human.timeline.Tween = function (params, cfg) {

        if (!cfg.tweens) {
            throw "Human.timeline.Tween config missing: tweens";
        }

        this.name = cfg.displayName;
        this.options = cfg.options || {};
        this.tweens = [];
        this._onComplete = cfg.onComplete;
        this.timeline = cfg.timeline;

        var tweens = cfg.tweens || {};
        var tween;

        for (var tweenName in tweens) {
            if (tweens.hasOwnProperty(tweenName)) {
                tween = tweens[tweenName];

                //Apply animation options to tween where not defined
                tween.options = Human._applyIf(this.options, tween.options || {});
                tween.modelId = params.modelId;

                var t = Human.timeline.Tween.tweenFactory.createTween(tween); // Logs errors
                if (t) {
                    this.tweens.push(t);
                }
            }
        }
    };

    /** Returns time frame enclosing keys of all contained tweens
     */
    Human.timeline.Tween.prototype.getTimeFrame = function () {
        if (this._timeFrame) {
            return this._timeFrame;
        }
        var min = 1000000;
        var max = -1000000;
        var tweens = this.tweens;
        var tween;
        for (var i = 0, len = tweens.length; i < len; i++) {
            tween = tweens[i];
            if (tween.firstTime < min) {
                min = tween.firstTime;
            }
            if (tween.lastTime > max) {
                max = tween.lastTime;
            }
        }
        this._timeFrame = {
            firstTime: min,
            lastTime: max
        };
        return this._timeFrame;
    };

    Human.timeline.Tween.prototype.update = function (ctx, time) {
        for (var i = 0, len = this.tweens.length; i < len; i++) {
            this.tweens[i].update(ctx, time);
        }
    };

    Human.timeline.Tween.prototype.stop = function () {
        var tween;
        for (var i = 0, len = this.tweens.length; i < len; i++) {
            tween = this.tweens[i];
            if (tween.stop) {
                tween.stop();
            }
        }
    };

    Human.timeline.Tween.prototype.destroy = function () {
        var tween;
        for (var i = 0, len = this.tweens.length; i < len; i++) {
            tween = this.tweens[i];
            if (tween.destroy) {
                tween.destroy();
            }
        }
    };


})();
;(function () {
    "use strict";

    var TweenLoader = Human.timeline.Tween.loader = {}; 

    TweenLoader.load = function (modelId, localAnimationId, globalAnimationId, manifest, params, ok, error) {
        try {
            Human.timeline.addAnimation(
                globalAnimationId,
                new Human.timeline.Tween({
                    modelId: modelId
                }, manifest));
            ok();
        } catch (e) {
            error(e);
        }
    };

    TweenLoader.unload = function (globalAnimationId) {
        Human.timeline.removeAnimation(globalAnimationId);
    };

})();
;/**
 * A pool of tweens
 */
(function() {
    "use strict";

    var TweenFactory = Human.timeline.Tween.tweenFactory = {};    

    var constructors = {};

    TweenFactory.createTweenType = function(typeName, construct) {
        constructors[typeName] = construct;
    };

    TweenFactory.createTween = function(params) {
        var type = params.type;
        if (!type) {
            throw "'type' expected";
        }
        var tokens = type.split(":");
        var tweenType = tokens[0];
        var manipType = tokens[1];
        if (!tweenType || !manipType) {
            Human.log.error("Human.timeline.Tween.tweenFactory.createTween", "Tween 'type' attribute should be of form <tween type>:<target type>");
            return null;
        }
        var Construct = constructors[tweenType];
        if (!Construct) {
            Human.log.error("Human.timeline.Tween.tweenFactory.createTween", "Tween type not supported: '" + tweenType + "'");
            return null;
        }
        return new Construct(params);
    };

})();;/**
 * A pool of attribute manipulators for scene graph nodes
 */
(function() {
    "use strict";

    var ManipulatorFactory = Human.timeline.Tween.manipulatorFactory = {}; 

    var manipConstructors = {};

    ManipulatorFactory.createManipulatorType = function(typeName, construct) {
        manipConstructors[typeName] = construct;
    };

    /**
     * Get manipulator of given type for a given node.
     *
     * Ensures that only one manipulator of that type exists on that node, and returns
     * shared references to them.
     */
    ManipulatorFactory.getManipulator = function(params) {
//        var manipId = type + (params && params.targetId ? "." + params.targetId : "");
//        var m = manipulators[manipId];
//        if (m) {
//            m._refCount++;
//            return m;
//        }
        if (!params.type) {
            throw "param expected: 'type'";
        }
        var m;

        var Construct = manipConstructors[params.type];
        if (!Construct) {
            throw "type not supported: '" + params.type + "'";
        }

        try {
            m = new Construct(params);
        } catch (e) {
            throw e;
        }

//        m._refCount = 1;
//        m._manipId = manipId;
     //   m._index = lenManipList;

        //manipulators[manipId] = m;
    //    manipList[lenManipList++] = m;

        return m;
    };

    ManipulatorFactory.putManipulator = function(m) {
        if (m.destroy) {
            m.destroy();
        }

//        if (!manipulators[m._manipId]) {
//            return;
//        }
//        if (m._refCount > 0 && --m._refCount == 0) {
//            manipulators[m._manipId] = null;
//            manipList.splice(m._index, 1);
//            if (m._destroy) {
//                m._destroy();
//            }
//        }
    };

})();;(function () {
    "use strict";

    Human.timeline.Tween.tweenFactory.createTweenType(
        "lerp",
        function (cfg) {
            if (!cfg.type) {
                throw "'type' expected";
            }
            if (!cfg.keys) {
                throw "'keys' expected";
            }
            if (!cfg.targets) {
                throw "'targets' expected";
            }

            if (cfg.keys.length < 2 || cfg.targets.length < 2) {
                throw "tween '" + cfg.name + "' has insufficient keys or targets - minimum of two required";
            }
            if (cfg.keys.length !== cfg.targets.length) {
                throw "tween '" + cfg.name + "' has mismatching numbers of keys and targets";
            }

            this.keys = cfg.keys;
            this.targets = cfg.targets;

            this.firstTime = cfg.keys[0];
            this.lastTime = cfg.keys[cfg.keys.length - 1];

            this._manipulator = Human.timeline.Tween.manipulatorFactory.getManipulator(cfg);
            this.name = cfg.name;
            this.type = cfg.type;
            this.tweenMap = {};
            this.tweenList = [];

            var target;
            var key;
            var targetAttr;
            var tween;

            // Parse "targets"
            for (var i = 0, len = this.targets.length; i < len; i++) {
                target = this.targets[i];
//                if (!target.attr) {
//                    Human.log.warn("tween '" + this.name + "' target # " + i + " does not have an 'attr' property");
//                    continue;
//                }
                key = this.keys[i];

                //Create a Tween for each attribute ("translate", "rotate" etc.) in target.
                // Each tween will contain a sub-tween for each of its target's elements ("x", "y" etc.)
                var attr = target;
                for (var attrName in attr) {
                    if (attr.hasOwnProperty(attrName)) {
                        targetAttr = attr[attrName];
                        tween = this.tweenMap[attrName];
                        if (!tween) { // Lazy-create
                            var tweenAttr = this._manipulator.attr[attrName];
//                            if (tweenAttr === undefined) {
//                                Human.log.warn("tween '" + this.name + "' of type '" + this.type + "' does not support attribute '" + attrName + "'");
//                                continue;
//                            }
                            tween = new AttrLerp(tweenAttr, cfg.options);
                            this.tweenMap[attrName] = tween;
                            this.tweenList.push(tween);
                        }
                        tween.addTarget(key, targetAttr);
                    }
                }
            }

            this.update = function (ctx, time) {

                if (time === undefined) {
                    time = this.firstTime;
                }

                var tweenList = this.tweenList;
                var countUpdated = 0;

                // Update each tween
                for (var j = 0, len = tweenList.length; j < len; j++) {
                    if (tweenList[j].update(ctx, time)) {
                        countUpdated++;
                    }
                }

                // Manipulate target
                if (countUpdated > 0) {
                    this._manipulator.update(ctx);
                }
            };

            this.stop = function () {
                if (this._manipulator.stop) {
                    this._manipulator.stop();
                }
            };

            this.destroy = function () {
                Human.timeline.Tween.manipulatorFactory.putManipulator(this._manipulator);
            };
        });


    /**
     * Tweens an attribute map
     *
     * Eg. var lerp = new AttrLerp({ "x": 0, "y": 0, "z": 0 });
     */
    function AttrLerp(attr, options) {

        this.attr = attr || {};
        this.attrNames = Object.keys(this.attr);
        this.options = options || {};

        this.keys = [];
        this.attrTargetLists = {};

        this._key1 = 0;
        this._key2 = 1;

        this._loop = !!options.loop;

        this._timeOffset = options.timeOffset || 0;

        /** Adds a target to this Tween
         *
         * Eg: addTarget(4, { "x": 0, "y": 0, "z": -10 });
         */
        this.addTarget = function (time, attr) {

            time += this._timeOffset;

            var name;
            if (this.keys.length === 0) {
                for (name in this.attr) {
                    if (this.attr.hasOwnProperty(name) && !attr.hasOwnProperty(name)) {
                        throw "Attribute expected on first target: '" + name + "'";
                    }
                }
            }
            this.keys.push(time);
            var targetList;
            for (name in this.attr) {
                if (this.attr.hasOwnProperty(name)) {
                    targetList = this.attrTargetLists[name];
                    if (!targetList) {
                        if (this.keys.length > 1) {
                            throw "First target in tween must contain a value for each animated attribute on target";
                        }
                        targetList = this.attrTargetLists[name] = [];
                    }
                    var val = attr[name];
                    if (val !== undefined && val !== null) {  // Attribute supplied, push to targets
                        targetList.push(val);
                    } else if (targetList.length > 0) {     // else inherit previous target
                        targetList.push(targetList[targetList.length - 1]);
                    } else {
                        targetList.push(this.attr[name]);   // else start target with initial attribute value
                    }
                }
            }

            /* Find key range
             */
            if (this._firstKey === undefined || time._firstKey === null || this._firstKey > time) {
                this._firstKey = time;
                this._keyDiff = this._lastKey - this._firstKey;
            }
            if (this._lastKey === undefined || time._lastKey === null || this._lastKey < time) {
                this._lastKey = time;
                this._keyDiff = this._lastKey - this._firstKey;
            }

        };

        /**
         * Drives the interpolation factor on this Tween
         *
         * Key is in seconds
         *
         * Eg. update(3.2);
         */
        this.update = function (ctx, time) {

            if (this._loop) {
                time = this._firstKey + (time % this._keyDiff);
            }

            var state = this._findEnclosingFrame(time);
            var attr = this.attr;
            var names = this.attrNames;

            if (!this._loop) {
                switch (state) {
                    case this.STATE_BEFORE:
                        this._clampToFrame(names, 0);
                        return true;

                    case this.STATE_AFTER:
                        this._clampToFrame(names, this.keys.length - 1);
                        return true;
                }
            }

            var attrTargetLists = this.attrTargetLists;
            var keys = this.keys;
            var key1 = this._key1;
            var key2 = this._key2;

            var targetList, delta, w, offs;
            var val;
            var updated = false;
            var i, len, name;

            delta = (time - keys[key1]) / (keys[key2] - keys[key1]);

            for (i = 0, len = names.length; i < len; i++) {
                name = names[i];
                targetList = attrTargetLists[name];

                w = targetList[key2] - targetList[key1];
                offs = delta * w;
                val = targetList[key1] + offs;

                if (attr[name] !== val) {
                    attr[name] = val;
                    updated = true;
                }  
            }
            return updated;
        };

        this._clampToFrame = function (names, time) {
            var attr = this.attr;
            var attrTargetLists = this.attrTargetLists;
            var i, len, name;

            for (i = 0, len = names.length; i < len; i++) {
                name = names[i];
                attr[name] = attrTargetLists[name][time];
            }
        };

        this._findEnclosingFrame = function (time) {
            var keys = this.keys;

            if (time < keys[0]) {
                this._key1 = 0;
                this._key2 = 1;
                return this.STATE_BEFORE;
            }
            if (time > keys[keys.length - 1]) {
                this._key1 = keys.length - 2;
                this._key2 = this._key1 + 1;
                return this.STATE_AFTER;
            }
            while (keys[this._key1] > time) {
                this._key1--;
                this._key2--;
            }
            while (keys[this._key2] < time) {
                this._key1++;
                this._key2++;
            }
            return this.STATE_RUNNING;
        };
    }


    AttrLerp.prototype.STATE_OUTSIDE = 0;    // Alpha outside of key sequence

    AttrLerp.prototype.STATE_BEFORE = 1;     // Alpha before first key

    AttrLerp.prototype.STATE_AFTER = 2;     // Alpha after last key

    AttrLerp.prototype.STATE_RUNNING = 3;    // Found keys before and after alpha

})();;(function() {
    "use strict";

    //var OUTSIDE = 0;    // Alpha outside of key sequence
    var BEFORE = 1;     // Alpha before first key
    var START = 2;      // At first key
    var AFTER = 3;     // Alpha after last key
    var RUNNING = 4;    // Found keys before and after alpha

    Human.timeline.Tween.tweenFactory.createTweenType(

            "switch",

            function(cfg) {
                if (!cfg.type) {
                    throw "'type' expected";
                }
                if (!cfg.keys) {
                    throw "'keys' expected";
                }
                if (!cfg.targets) {
                    throw "'targets' expected";
                }

                if (cfg.keys.length < 2 || cfg.targets.length < 2) {
                    Human.log.warn("Human.timeline.Tween", "tween '" + cfg.name + "' has insufficient keys or targets - minimum of two required");
                    return;
                }
                if (cfg.keys.length !== cfg.targets.length) {
                    Human.log.warn("Human.timeline.Tween", "tween '" + cfg.name + "' has mismatching numbers of keys and targets");
                    return;
                }

                // Bump keys by offset option if given
                if (cfg.options && cfg.options.timeOffset) {
                    var offset = cfg.options.timeOffset;
                    var keys = this.keys = cfg.keys.slice(0);
                    for (var i = 0, len = keys.length; i < len; i++) {
                        keys[i] += offset;
                    }
                } else {
                    this.keys = cfg.keys;
                }

                this.targets = cfg.targets;


                this.firstTime = cfg.keys[0];
                this.lastTime = cfg.keys[cfg.keys.length - 1];

                this._manipulator = Human.timeline.Tween.manipulatorFactory.getManipulator(cfg);
                this.type = cfg.type;
                this._options = cfg.options || {};
                this._key = 0;
                this._lastKey = null;

                this.update = function(ctx, time) {

                    if (time === undefined || time === null) {
                        time = this.firstTime;
                    }

                    var state = this._findTarget(time);

                    switch (state) {
                        case BEFORE:
                            if (this._options.wait) {
                                return false; // No update
                            }
                            //this._clampToFrame(0);
                            return true;

                        case START:
                            break;

                        case AFTER:
                            break;
                    }

                    if (this._lastKey !== this._key) {
                        this._manipulator.attr = this.targets[this._key];
                        this._manipulator.update(ctx);
                        this._lastKey = this._key;
                    }

                    return true;
                };

                this._findTarget = function(key) {
                    if (key < this.keys[0]) {
                        this._key = 0;
                        return BEFORE;
                    }
                    if (key === this.keys[0]) {
                        this._key = 0;
                        return START;
                    }
                    if (key > this.keys[this.keys.length - 1]) {
                        this._key = this.keys.length - 1;
                        return AFTER;
                    }
                    while (this.keys[this._key] > key) {
                        this._key--;
                    }
                    while (this.keys[this._key + 1] !== undefined && this.keys[this._key + 1] !== null && this.keys[this._key + 1] < key) {
                        this._key++;
                    }
                    return RUNNING;
                };

                this.stop = function() {
                    if (this._manipulator.stop) {
                        this._manipulator.stop();
                    }
                };

                this.destroy = function() {
                    Human.timeline.Tween.manipulatorFactory.putManipulator(this._manipulator);
                };

            });
})();

;(function() {
    "use strict";

    /**
     * Manipulates a scene graph camera
     */
    Human.timeline.Tween.manipulatorFactory.createManipulatorType(
        "lerp:camera",
        function (params) {

            var initial = params.initial || {};
            this.attr = {
                up: Human._applyIf2(initial.up, { x: 0, y: 1, z: 0 }),
                eye: Human._applyIf2(initial.eye, { x: 0, y: 0, z: 0 }),
                look: Human._applyIf2(initial.look, { x: 0, y: 0, z: 0 })
            };

            this.update = function (ctx) {
                if (ctx.cameraEnabled !== false) {
                    Human.view.camera.setLookAt(this.attr);
                }
            };
        });
})();


;/**
 * Manipulates a material
 *
 */
Human.timeline.Tween.manipulatorFactory.createManipulatorType(
    "lerp:material",
    function (params) {
        "use strict";

        if (!params.modelId) { // Added by loader
            throw "attribute expected: 'modelId'";
        }

        var materialId = params.targetId || params.materialId;

        if (!materialId) {
            Human.log.error("Human.timeline.Tween", "'material' tween attribute expected: 'materialId'");
            return;
        }

        this.materialId = params.modelId + "." + materialId;

        this.attr = {
            baseColor: {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            },
            specularColor: {
                "r": 1.0,
                "g": 1.0,
                "b": 1.0
            }
        };

        this.update = function () {

            if (!this.materialId) {
                // Did not initialize correctly
                return;
            }

            var material = Human.assets.materials.materials[this.materialId];

            if (!material && !this._targetMissing) {
                Human.log.error("Human.timeline.Tween", "'material' tween can't find material: " + this.materialId);
                this._targetMissing = true;
                return;
            }

            if (material.material) {
                material.material.set(this.attr);
            }
        };
    });;(function () {
    "use strict";

    /**
     * Manipulates continuously-changeable attributes on objects, such as opacity
     */
    Human.timeline.Tween.manipulatorFactory.createManipulatorType(
        "lerp:objectAttr",
        function (params) {

            if (!params.modelId) { // Added by loader
                throw "attribute expected: 'modelId'";
            }
            if (!params.objectId) {
                throw "attribute expected: 'objectId'";
            }
            var initial = params.initial || {};
            this.attr = {
                attr: {
                    opacity: initial.opacity !== undefined && initial.opacity !== null ? initial.opacity : 0.2
                }
            };
            var objectId = params.objectId;
            if (objectId.indexOf(".") < 0) {
                // Relative ID of object within this model
                objectId = params.modelId + "-" + params.objectId;
            } // Otherwise absolute ID of object in another model

            this.update = function () {
                var object = Human.scene.objects[objectId];
                if (!object) {
                    Human.log.warn("Human.timeline.Tween", "'lerp:objectAttr' tween can't find object: " + objectId);
                    return;
                }
                var flag = Human.timeline.showObjects[objectId];
                if (flag !== undefined && flag !== null && flag !== true) {
                    return;
                }
                var attr = this.attr.attr;
                if (attr.opacity !== undefined && attr.opacity !== null) {
                    setObjectAttr(object, attr);
                }
            };
        });

    function setObjectAttr(object, attr) {
        if (attr.opacity !== undefined && attr.opacity !== null) {
            object.setOpacity(attr.opacity);
        }
        if (object.objects.length > 0) {
            var objects = object.objects;
            for (var i = 0, len = objects.length; i < len; i++) {
                setObjectAttr(objects[i], attr);
            }
        }
    }

})();;/**
 * Manipulates the transformation of a target asset, or all assets in a target module
 */
Human.timeline.Tween.manipulatorFactory.createManipulatorType(
    "lerp:objectXForm",
    function (params) {
        "use strict";

        if (!params.modelId) { // Added by loader
            throw "attribute expected: 'modelId'";
        }

        if (!params.objectId) {
            throw "attribute expected: 'objectId'";
        }

        var initial = params.initial || {};
        this.attr = {
            translate:Human._applyIf2(initial.translate, { x:0, y:0, z:0 }),
            rotate:Human._applyIf2(initial.rotate, { x:0, y:0, z:0 }),
            scale:Human._applyIf2(initial.scale, { x:1, y:1, z:1 }),
            pivot:Human._applyIf2(initial.pivot, { x:0, y:0, z:0 })
        };

        var objectId = params.objectId;
        if (objectId.indexOf(".") < 0) {
            // Relative ID of object within this model
            objectId = params.modelId + "-" + params.objectId;
        } // Otherwise absolute ID of object in another model

        this.update = function () {
            var object = Human.scene.objects[objectId];
            if (!object) {
                Human.log.warn("Human.timeline.Tween", "'lerp:objectXForm' tween can't find object: " + objectId);
                return;
            }
            var flag = Human.timeline.showObjects[objectId];
            if (flag !== undefined && flag !== null && flag !== true) {
                return;
            }
            object.setTransform(this.attr);
        };
    });;/**
 * Manipulates the texture of a material in a Material Module
 *
 */
Human.timeline.Tween.manipulatorFactory.createManipulatorType(
    "lerp:texture",
    function (params) {
        "use strict";

        if (!params.modelId) { // Added by loader
            throw "attribute expected: 'modelId'";
        }

        var materialId = params.targetId || params.materialId;

        if (!materialId) {
            Human.log.error("Human.timeline.Tween", "'texture' tween attribute expected: 'materialId'");
            return;
        }

        this.materialId = params.modelId + "." + materialId;

        if (params.targetLayer === undefined || params.targetLayer === null) {
            Human.log.error("Human.timeline.Tween", "'texture' tween attribute expected: 'targetLayer'");
            return;
        }

        this.targetLayer = params.targetLayer;

        this.attr = {
            rotate: { z: 0 },
            translate: { x: 0, y: 0 },
            scale: { x: 1, y: 1 },
            blend: { factor: 1.0 }
        };

        this.update = function () {

            if (!this.materialId || this.targetLayer === undefined || this.targetLayer === null) {
                // Did not initialize correctly
                return;
            }

            var material = Human.assets.materials.materials[this.materialId];

            if (!material) {
                if (!this._targetMissing) {
                    Human.log.error("Human.timeline.Tween", "'material' tween can't find material: " + this.materialId);
                    this._targetMissing = true;
                }
                return;
            }

            var texture = material.texture;

            if (texture) {
                var layers = {};
                layers["" + this.targetLayer] = {
                    scale: this.attr.scale,
                    translate: this.attr.translate,
                    rotate: this.attr.rotate,
                    blendFactor: this.attr.blend.factor
                };
                texture.setLayers(layers);
            }
        };
    });;/**
 * Manipulates a transformation asset
 */
Human.timeline.Tween.manipulatorFactory.createManipulatorType(
    "lerp:transform",
    function (params) {
        "use strict";

        if (!params.modelId) { // Added by loader
            throw "attribute expected: 'modelId'";
        }

        var transformId = params.transformId;

        if (!transformId) {
            Human.log.error("Human.timeline.Tween", "'transform' tween attribute expected: 'transformId'");
            return;
        }

        this.transformId = params.modelId + "." + transformId;

        var initial = params.initial || {};

        this.attr = {
            translate: Human._applyIf2(initial.translate, { x: 0, y: 0, z: 0 }),
            rotate: Human._applyIf2(initial.rotate, { x: 0, y: 0, z: 0 }),
            scale: Human._applyIf2(initial.scale, { x: 1, y: 1, z: 1 }),
            pivot: Human._applyIf2(initial.pivot, { x: 0, y: 0, z: 0 })
        };

        this.update = function () {

            if (!this.transformId) {
                // Did not initialize correctly
                return;
            }

            var transform = Human.assets.transforms.transforms[this.transformId];

            if (!transform) {
                if (!this._targetMissing) {
                    Human.log.error("Human.timeline.Tween", "'lerp:transform' tween can't find transform: " + transformId);
                    this._targetMissing = true;
                }
                return;
            }

            transform.set(this.attr);
        };
    });;(function () {
    "use strict";

    /**
     * Manipulates discretely-changeable attributes on objects, such as visibility and transparency
     */
    Human.timeline.Tween.manipulatorFactory.createManipulatorType(
        "switch:objectAttr",
        function (params) {

            if (!params.modelId) { // Added by loader
                throw "attribute expected: 'modelId'";
            }

            if (!params.objectId) {
                throw "attribute expected: 'objectId'";
            }

            var initial = params.initial || {};
            this.attr = {
                attr: {
                    pickable: initial.pickable !== undefined && initial.pickable !== null ? initial.pickable : true,
                    shown: initial.shown !== undefined && initial.shown !== null ? initial.shown : true,
                    transparent: initial.transparent !== undefined && initial.transparent !== null ? initial.transparent : true
                }
            };

            var objectId = params.objectId;
            if (objectId.indexOf(".") < 0) {
                // Relative ID of object within this model
                objectId = params.modelId + "-" + params.objectId;
            } // Otherwise absolute ID of object in another model

            this.update = function () {
                var object = Human.scene.objects[objectId];
                if (!object) {
                    Human.log.warn("Human.timeline.Tween", "'switch:objectAttr' tween can't find object: " + objectId);
                    return;
                }
                var flag = Human.timeline.showObjects[objectId];
                if (flag !== undefined && flag !== null && flag !== true) {
                    return;
                }
                var attr = this.attr.attr;
                if ((attr.pickable !== undefined && attr.pickable !== null) ||
                    (attr.shown !== undefined && attr.shown !== null) ||
                    (attr.transparent !== undefined && attr.transparent !== null)) {

                    setObjectAttr(object, attr);
                }
            };
        });

    function setObjectAttr(object, attr) {
        if (attr.pickable !== undefined && attr.pickable !== null) {
            object.setPickable(attr.pickable);
        }
        if (attr.shown !== undefined && attr.shown !== null) {
            object.show(attr.shown);
        }
        if (attr.transparent !== undefined && attr.transparent !== null) {
            object.setTransparent(attr.transparent);
        }
        if (object.objects.length > 0) {
            var objects = object.objects;
            for (var i = 0, len = objects.length; i < len; i++) {
                setObjectAttr(objects[i], attr);
            }
        }
    }

})();;/**
 * @namespace Updates the camera as timeline chapters are activated
 */
(function () {
    "use strict";

    var ChapterCameras = Human.timeline.chapterCameras = {};

    /**
     * Camera interpolated along a path when true
     * @type {boolean}
     */
    ChapterCameras.pathMode = false;

    // The timeline chapter list
    var chapters = [];

    // Path of lookats
    var sequence = [];

    // A time value for each lookat on the path
    var timeline = [];

    // The current time on the path
    var time = 0;

    // Enables of disables camera animation
    var enabled = true;

    Human.properties.subscribe({
        propId: "timeline.chapterCamerasEnabled",
        value: enabled,
        callback: function (value) {
            enabled = !!value;
        }
    });

    Human.events.on("timeline.chapters.updated",
        function (chapterList) {
            clear();
            var chapter;
            var camera;
            for (var i = 0, len = chapterList.length; i < len; i++) {
                chapter = chapterList[i];
                camera = chapter.flyTo || chapter.jumpTo;
                if (camera) {
                    camera.time = chapter.time;
                    add(camera);
                }
            }
            chapters = chapterList;
        });

    Human.events.on("timeline.playing",
        function (params) {
            if (!enabled) {
                return;
            }
            if (ChapterCameras.pathMode) {
                setTime(params.time);
            }
        });

    Human.events.on("timeline.scrubbed",
        function (params) {
            if (!enabled) {
                return;
            }
            if (ChapterCameras.pathMode) {
                setTime(params.time);
            }
        });

    Human.events.on("timeline.chapters.activated",
        function (params) {
            if (!enabled) {
                return;
            }
            if (!ChapterCameras.pathMode) {
                var chapter = chapters[params.newChapterIndex];
                if (chapter) {
                    if (chapter.flyTo) {
                        Human.view.camera.fly.flyTo(chapter.flyTo);
                    } else if (chapter.jumpTo) {
                        Human.view.camera.fly.jumpTo(chapter.jumpTo);
                    }
                }
            }
        });

    function clear() {
        sequence = [];
        timeline = [];
        time = 0.0;
    }

    function add(lookat) {
        if (sequence.length === 0) {
            time = 0.0;
        }
        timeline.push(lookat.time);
        sequence.push(lookat);
    }

    function setTime(t) {
        time = t;
        update();
    }

    function getTotalTime() {
        if (timeline.length > 0) {
            return timeline[timeline.length - 1];
        }
        return 0;
    }

    function update() {
        if (sequence.length === 0) {
            return;
        }
        if (time <= timeline[0]) {
            Human.view.camera.setLookAt(sequence[0]);
            return;
        }
        if (time >= getTotalTime() || sequence.length === 1) {
            Human.view.camera.setLookAt(sequence[sequence.length - 1]);
            return;
        }
        var i = 0;
        while (timeline[i] < time) {
            ++i;
        }
        lerp(time, i - 1);
    }

    function lerp(t, i) {
        var t1 = timeline[i];
        var t2 = timeline[i + 1];
        var a = sequence[i];
        var b = sequence[i + 1];
        Human.view.camera.setLookAt( {
            eye: lerpVec(t, t1, t2, a.eye, b.eye),
            look: lerpVec(t, t1, t2, a.look, b.look),
            up: lerpVec(t, t1, t2, a.up, b.up)
        });
    }

    function lerpVec(t, t1, t2, p1, p2) {
        var f2 = (t - t1) / (t2 - t1);
        var f1 = 1.0 - f2;
        return  {
            x: p1.x * f1 + p2.x * f2,
            y: p1.y * f1 + p2.y * f2,
            z: p1.z * f1 + p2.z * f2
        };
    }
})();
;/**
 * @namespace Auto-plays the timeline after a period of user inactivity
 */
(function () {
    "use strict";

    var timeout = null;

    var enabled = false;
    var autoPlaying = false;

    Human.properties.subscribe({
        propId: "timeline.autoPlay.enabled",
        value: enabled,
        callback: function (value) {
            enabled = !!value;
            
            if(enabled) {
              startCountdown();
            } else {
              autoPlaying = false;
            }
        }
    });

    var timeoutSecs = 10;

    Human.properties.subscribe({
        propId: "timeline.autoPlay.timeoutSecs",
        value: timeoutSecs,
        callback: function (value) {
            timeoutSecs = value;
        }
    });
    
    var type = "play";
    
    var types = {
      
        play: function () {
            Human.timeline.play({
                startTime: Human.timeline.time
            });
        },
      
        'chapter-rotate': function () {
            var _wait = 5000;
        
            var _rotate = function () {
                if(!autoPlaying) {
                    return;
                }

                var startX = Human.view.camera.eye.x;
                var i = 0;
                var _interval = 20;
          
                var rotateInt = setInterval(function () {
                    if(!autoPlaying) {
                        clearInterval(rotateInt);
                    }

                    Human.view.camera.rotateY(0.5);

            
                    var diff = Math.abs(startX - Human.view.camera.eye.x);
            
                    if((diff <= 0.005 && i > _interval * 5) || i > _interval * 40) {
                        clearInterval(rotateInt);
                        setTimeout(_play, _wait);
                    }
            
                    i++;
                }, _interval);
            };
        
            var _play = function () {
                if(!autoPlaying) {
                    return;
                }
                
                //go to beginning if at end
                if(Human.timeline.time === Human.timeline.getTimeFrame().lastTime) {
                    Human.timeline.scrub({ time: 0 });
                    setTimeout(_rotate, _wait);
                } else {
                    Human.timeline.next();
                }
          
                Human.events.once('timeline.stopped', function () {
                    setTimeout(_rotate, _wait);
                });
            };
        
            _play();
        
        }
      
    };
    
    Human.properties.subscribe({
        propId: "timeline.autoPlay.type",
        value: type,
        callback: function (value) {
            type = value;
        }
    });

    // Start countdown when engine starts

    Human.events.on("started",
        function () {
            startCountdown();
        });

    // Start countdown when timeline stops

    Human.events.on("timeline.stopped",
        function () {
            startCountdown();
        });

    // (Re)start countdown when user interacts with the UI

    var listeners = {};

    listen("mousedown");
    listen("keydown");
    listen('mousewheel');

    function listen(type) {
        $(document).bind(type,
            listeners[type] = function () {
                autoPlaying = false;
                startCountdown();
            });
    }

    function startCountdown() {
        if (timeout) {
            clearTimeout(timeout);
            timeout = null;
        }
        
        if (!enabled) {
            return;
        }

        timeout = setTimeout(function () {
            if (enabled && !Human.timeline.playing && !autoPlaying) {
                autoPlaying = true;
                
                var method = types[type] || types.play;
                method();
            }
        }, timeoutSecs * 1000);
    }

})();
;(function() {
    "use strict";


    /**
     * Queries the current state of the timeline - chapters, time and play/pause state.
     */
    Human.rpc.define("timeline.query",
        function () {
            this.setResult(Human.timeline.query());
        });

    /**
     * Scrub timeline to time or chapter
     *
     * Scrub to given time in seconds:
     *
     * {
     *    time: 15
     * }
     *
     * Scrub to start of given chapter:
     *
     * {
     *    chapterId: "makeIncision"
     * }
     *
     */
    Human.rpc.define("timeline.scrub",
        function (params) {
            Human.timeline.scrub(params);
        });

    /**
     * Play the timeline (unpausing if currently paused) - several options:
     *
     *
     * Start at beginning, optionally stopping at next chapter or looping:
     *
     * {
     *    loop:                 true,           // Continue playing (default false) OR
     *    stopAtNextChapter:    true            // Stop playing at next chapter (default false)
     * }
     *
     * Start at given time, optionally stopping at next chapter or looping:
     *
     * {
     *    time:                 15,
     *    loop:                 true,           // Continue playing (default false) OR
     *    stopAtNextChapter:    true            // Stop playing at next chapter (default false)
     * }
     *
     * Start at given chapter, optionally stopping at next chapter or looping:
     *
     * {
     *    chapterId:            "makeIncision",
     *    loop:                 true,           // Continue playing (default false) OR
     *    stopAtNextChapter:    true            // Stop playing at next chapter (default false)
     * }
     *
     */
    Human.rpc.define("timeline.play",
        function (params) {
            Human.timeline.play(params);
        });

    // Stops timeline if currently playing
    Human.rpc.define("timeline.stop",
        function () {
            Human.timeline.stop();
        });

    // Winds timeline to start of previous chapter
    Human.rpc.define("timeline.prev",
        function () {
            Human.timeline.prev();
        });

    // Winds timeline to start of next chapter
    Human.rpc.define("timeline.next",
        function () {
            Human.timeline.next();
        });

    // Pauses timeline if currently playing
    Human.rpc.define("timeline.pause",
        function () {
            Human.timeline.pause();
        });

    // Unpauses timeline if currently paused
    Human.rpc.define("timeline.unpause",
        function () {
            Human.timeline.unpause();
        });

    // Captures bookmark of timeline playing state
    Human.rpc.define("timeline.getBookmark",
        function () {
            this.setResult(Human.timeline.getBookmark());
        });

    // Restores playing state of timeline to given bookmark
    Human.rpc.define("timeline.setBookmark",
        function (params) {
            Human.timeline.setBookmark(params);
        });
})();
;/**
 * @namespace Engine asset libraries.
 * @private
 */
Human.assets = Human.assets || {};;/**
 * @namespace Geometry libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsGeometries = Human.assets.geometries = {}; 

    /** All geometries
     */
    HumanAssetsGeometries.geometries = {};

    /** Geometries grouped into libraries
     */
    HumanAssetsGeometries.libraries = {};

    // Holds all SceneJS nodes for geometries
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Geometry library"
            });
        });

    /** Creates a geometries library
     * @param libraryId Unique library ID
     */
    HumanAssetsGeometries.createLibrary = function (libraryId) {
        if (HumanAssetsGeometries.libraries[libraryId]) {
            Human.log.error("Human.assets.geometries.createLibrary", "Geometry library already loaded: " + libraryId);
            return;
        }
        HumanAssetsGeometries.libraries[libraryId] = {
            // Root scene node for each library means we can blow away scene nodes
            // for a library in one shot by destroying the root
            node: libRoot.addNode({
                type: "library",
                data: "libraryId = " + libraryId
            }),
            libraryId: libraryId,
            geometries: {}
        };
    };

    /** Creates a geometry within an existing geometries library
     * @param libraryId ID of library
     * @param geometryId ID for new geometry, globally unique among geometries in all libraries
     * @param params Geometry params - geometry, texture, flags
     */
    HumanAssetsGeometries.createGeometry = function (libraryId, geometryId, params) {
        var library = HumanAssetsGeometries.libraries[libraryId];
        if (!library) {
            Human.log.error("Human.assets.geometries.createGeometry", "Geometry library not found: " + libraryId);
            return;
        }
        if (HumanAssetsGeometries.geometries[geometryId]) {
            Human.log.error("Human.assets.geometries.createGeometry", "Geometry already loaded: " + geometryId);
            return;
        }
        if (!params.geometry) {
            Human.log.error("Human.assets.geometries.createGeometry", "Mandatory attribute 'geometryId' expected on geometry: " + geometryId);
            return;
        }
        params.geometry.type = "geometry";
        var geometry = {
            //   materialId: params.materialId, // HACK while materialId can be on geometries
            geometry: library.node.addNode(params.geometry),
            type: "geometry"
        };
        // Boundary and center
        if (params.boundary) {
            var boundary = params.boundary;
            geometry.boundary = boundary;
            geometry.center = [
                (boundary.xmax + boundary.xmin) * 0.5,
                (boundary.ymax + boundary.ymin) * 0.5,
                (boundary.zmax + boundary.zmin) * 0.5
            ];
            geometry.axisBoundary = new Human.math.AxisBox3(
                [boundary.xmin, boundary.ymin, boundary.zmin],
                [boundary.xmax, boundary.ymax, boundary.zmax]);
        }
        HumanAssetsGeometries.geometries[geometryId] = geometry;
        library.geometries[geometryId] = geometry;
    };

    /**
     * Destroys a geometries library
     * @param libraryId
     */
    HumanAssetsGeometries.destroyLibrary = function (libraryId) {
        if (libraryId) {
            var lib = HumanAssetsGeometries.libraries[libraryId];
            if (!lib) {
                Human.log.warn("Human.assets.geometries.destroyLibrary", "Geometry library not found: " + libraryId);
                return;
            }
            lib.node.destroy(); // Blow away scene subgraph
            for (var geometryId in lib.geometries) {
                if (lib.geometries.hasOwnProperty(geometryId)) {
                    delete HumanAssetsGeometries.geometries[geometryId];
                }
            }
            delete HumanAssetsGeometries.libraries[libraryId];
        } else {
            HumanAssetsGeometries.reset();
        }
    };

    /** Destroys all geometry libraries
     */
    HumanAssetsGeometries.reset = function () {
        for (var libraryId in HumanAssetsGeometries.libraries) {
            if (HumanAssetsGeometries.libraries.hasOwnProperty(libraryId)) {
                HumanAssetsGeometries.destroyLibrary(libraryId);
            }
        }
    };
})();;(function () {
    "use strict";

    var BinaryLoader = window.HumanGeometryLoaderBinary = {}; 

    BinaryLoader.load = function (localLibraryId, globalLibraryId, manifest, ok, error) {

        // Get info that we'll use to ensure
        // that we only load what array data is provided
        var stats = getStats(manifest.geo);

        loadArrays(localLibraryId, stats,
            function (arrays) {

                var mesh;
                var geo;
                var geometryId;
                var positions;
                var indices;

                Human.assets.geometries.createLibrary(globalLibraryId);

                // Create meshes within the geometry
                for (var meshKey in manifest.geo) {
                    if (manifest.geo.hasOwnProperty(meshKey)) {

                        mesh = manifest.geo[meshKey];
                        geo = mesh.geometry;

                        geometryId = globalLibraryId + "." + meshKey;

                        positions = stats.positions ? slice(arrays.positions, geo.positions) : null;
                        indices = stats.indices ? slice(arrays.indices, geo.indices) : null;

                        Human.assets.geometries.createGeometry(globalLibraryId, geometryId, {
                            materialId: mesh.materialId,
                            geometry: {
                                primitive: "triangles",
                                positions: stats.positions ? positions : null,
                                normals: stats.normals ? slice(arrays.normals, geo.normals) : null,
                                uv: stats.uv ? slice(arrays.uv, geo.uv) : null,
                                indices: indices,
                                tangents: stats.tangents // Boolean, enables normal mapping on this geometry
                            },
                            boundary: stats.positions ? getBoundary(positions) : null
                        });
                    }
                }
                ok();
            },
            error);
    };

    /**
     * Returns info on what we'll be loading
     * @param map
     * @return {{}} The info
     */
    function getStats(map) {
        var data = {
            numGeos: 0,
            numArrays: 0,
            positions: false,
            indices: false,
            uv: false,
            normals: false
        };
        var item;
        var geometry;
        for (var key in map) {
            if (map.hasOwnProperty(key) && map[key]) {
                data.numGeos++;
                item = map[key];
                if (item.geometry) {
                    geometry = item.geometry;
                    if (geometry.positions && !data.positions) {
                        data.positions = true;
                        data.numArrays++;
                    }
                    if (geometry.indices && !data.indices) {
                        data.indices = true;
                        data.numArrays++;
                    }
                    if (geometry.normals && !data.normals) {
                        data.normals = true;
                        data.numArrays++;
                    }
                    if (geometry.uv && !data.uv) {
                        data.uv = true;
                        data.numArrays++;
                    }
                    if (geometry.tangents) {
                        // Boolean, causes SceneJS to automatically generate tangents to support normal mapping
                        data.tangents = geometry.tangents;
                    }
                }
            }
        }
        return data;
    }

    /**
     * Loads a set of binary arrays
     * @param localLibraryId IDs the array set
     * @params stats Indicates what we'll load
     * @param _ok Returns the arrays
     * @param _error Signals error
     * @private
     */
    function loadArrays(localLibraryId, stats, _ok, _error) {

        var wasError = false;
        var arrays = {};

        // Fired once all binary arrays have loaded
        function ok() {
            if (!wasError) {
                _ok(arrays);
            }
        }

        // Fired once on error
        function error(err) {
            if (!wasError) {
                wasError = true;
                _error(err);
            }
        }

        // Load data arrays
        var numArraysToLoad = stats.numArrays; // Must equal number of Human.net.getXX calls below or loading will hang
        var numArraysLoaded = 0;

        if (stats.positions) {
            Human.net.getGeometryPositions(
                localLibraryId,
                function (array) {
                    arrays.positions = array;
                    if (++numArraysLoaded === numArraysToLoad) {
                        ok();
                    }
                },
                error);
        }

        if (stats.normals) {
            Human.net.getGeometryNormals(
                localLibraryId,
                function (array) {
                    arrays.normals = array;
                    if (++numArraysLoaded === numArraysToLoad) {
                        ok();
                    }
                },
                error);
        }

        if (stats.uv) {
            Human.net.getGeometryUVs(
                localLibraryId,
                function (array) {
                    arrays.uv = array;
                    if (++numArraysLoaded === numArraysToLoad) {
                        ok();
                    }
                },
                error);
        }

        if (stats.indices) {
            Human.net.getGeometryIndices(
                localLibraryId,
                function (array) {
                    arrays.indices = array;
                    if (++numArraysLoaded === numArraysToLoad) {
                        ok();
                    }
                },
                error);
        }
    }

    // Extracts a portion of the given array
    function slice(array, portion, bumpOffset) {
        bumpOffset = bumpOffset || 0;
        var begin = portion[0] - bumpOffset;// substract offsets
        var end = begin + portion[1] - bumpOffset;
        if (array.subarray) {
            return array.subarray(begin, end); // https://bugs.webkit.org/show_bug.cgi?id=53618
        } else {
            return array.slice(begin, end);
        }
    }

    // Get minimal boundary enclosing the given array
    function getBoundary(positions) {
        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var x, y, z;
        for (var i = 0, len = positions.length - 2; i < len; i += 3) {
            x = positions[i];
            y = positions[i + 1];
            z = positions[i + 2];
            if (x === undefined || x === null ||
                y === undefined || y === null ||
                z === undefined || z === null) {
                continue;
            }
            if (x < xmin) {
                xmin = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (z < zmin) {
                zmin = z;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y > ymax) {
                ymax = y;
            }
            if (z > zmax) {
                zmax = z;
            }
        }
        return { xmin: xmin, ymin: ymin, zmin: zmin, xmax: xmax, ymax: ymax, zmax: zmax };
    }
})();
;(function () {
    "use strict";

    var JSONLoader = window.HumanGeometryLoaderJSON = {}; 

    JSONLoader.load = function (localGeometryId, globalGeometryId, manifest, onComplete, onError) {
        createGeometryLib(localGeometryId, globalGeometryId, manifest, onComplete,
            function () {
                var wasError = false;     // Soaks up multiple errors
                return function (error) {
                    if (!wasError) {
                        wasError = true;
                        onError(error);
                    }
                };
            });
    };

    function createGeometryLib(localGeometryId, globalGeometryId, manifest, onComplete, onError) {

       Human.assets.geometries.createLibrary(globalGeometryId);

        var meshes = manifest.meshes;
        if (!meshes) {
            onError("Geometry manifest 'meshes' property expected");
            return;
        }
        var countMeshesLoaded = 0;
        var numMeshes;

        if (typeof meshes.length === "number") {        // For deprecated format
            numMeshes = meshes.length;
        } else {                                        // For new format
            numMeshes = countKeysInMap(meshes);
        }

        // Stop onError being called for multiple failures,
        // and supress onComplete being called after any failures
        var wasError = false;
        var err = onError;
        onError = function (error) {
            if (!wasError) {
                wasError = true;
                if (err) {
                    err(error);
                }
            }
        };

        function onMeshLoadComplete() {

            if (wasError) {
                return;
            }

            countMeshesLoaded++;
            if (countMeshesLoaded >= numMeshes) {
                onComplete();

            }
        }

        if (Human._isArray(meshes)) { // Remove when all geometries use the new format below
            for (var i = 0; i < numMeshes; i++) {
                addMeshDeprecated(globalGeometryId, localGeometryId, meshes[i], onMeshLoadComplete, onError);
            }
        }
    }

    function countKeysInMap(map) {
        var count = 0;
        for (var key in map) {
            if (map.hasOwnProperty(key) && map[key]) {
                count++;
            }
        }
        return count;
    }

    function addMeshDeprecated(globalGeometryId, localGeometryId, mesh, onComplete, onError) {
        var meshId;
        var instancing = (typeof mesh !== "string");

        if (instancing) {
            if (!mesh.geo) {
                onError("failed to load 'geo' file for geometry module '" + localGeometryId + "' a mesh is missing a 'geo' element");
                return;
            }
            meshId = mesh.geo;
        } else {
            meshId = mesh;
        }

        Human.net.getGeometryMesh(
            localGeometryId,
            meshId,

            function (meshData) {

                // LEGACY DATA HACK
                // Globalise material link
//                if (meshData.materialId) {
//                    meshData.materialId = Human.assets.materials.createGlobalMaterialNodeId(meshData.materialId);
//                }

                // Add the mesh to the library
                var globalTargetMeshId = globalGeometryId + "." + meshId;

                meshData.boundary = getBoundary(meshData.positions);

                Human.assets.geometries.createGeometry(globalGeometryId, globalTargetMeshId, {
                    materialId: meshData.materialId,
                    geometry: meshData
                });

                onComplete();
            },
            function (error) {
                onError("failed to load 'geo' file for geometry module '" + localGeometryId + "' mesh '" +
                    meshId + "': " + error.errorText + " - status: " + error.request.status);
            });
    }

    function getBoundary(positions) {
        var xmin = 100000;
        var ymin = 100000;
        var zmin = 100000;
        var xmax = -100000;
        var ymax = -100000;
        var zmax = -100000;
        var x, y, z;
        for (var i = 0, len = positions.length - 2; i < len; i += 3) {
            x = positions[i];
            y = positions[i + 1];
            z = positions[i + 2];
            if (x === undefined || x === null ||
                y === undefined || y === null ||
                z === undefined || z === null) {
                continue;
            }
            if (x < xmin) {
                xmin = x;
            }
            if (y < ymin) {
                ymin = y;
            }
            if (z < zmin) {
                zmin = z;
            }
            if (x > xmax) {
                xmax = x;
            }
            if (y > ymax) {
                ymax = y;
            }
            if (z > zmax) {
                zmax = z;
            }
        }
        return { xmin:xmin, ymin:ymin, zmin:zmin, xmax:xmax, ymax:ymax, zmax:zmax };
    }

})();
;(function() {
    "use strict";

    /**
     * @namespace Loads geometry libraries into {@link Human.assets.geometries}
     * @private
     */
    Human.assets.geometries.loader = new Human.utils.Loader();

    Human.assets.geometries.loader.configure = function (params) {
        this._embedded = params.embedded;
        return this;
    };

    Human.assets.geometries.loader._load = function (moduleId, stateId, libraryId, params, ok, error) {

        var localLibraryId = libraryId;
        var globalLibraryId = stateId + "." + libraryId;

        Human.net.getGeometryManifest(
            localLibraryId,
            function (manifest) {
                if (!manifest.format) {
                    error("'format' expected in manifest for geometry module '" + localLibraryId + "'");
                    return;
                }
                switch (manifest.format) {
                    case "json":
                        HumanGeometryLoaderJSON.load(localLibraryId, globalLibraryId, manifest, ok, error);
                        break;
                    case "binary":
                        HumanGeometryLoaderBinary.load(localLibraryId, globalLibraryId, manifest, ok, error);
                        break;
                    default:
                        var message = "Human.assets.geometries.loader - Unsupported value '" + manifest.format +
                            "' for 'format' in manifest for geometry module '" + localLibraryId +
                            "' - supported values are 'json', 'binary' and 'tween'";
                        Human.log.error(message);
                        error(message);
                }
            },
            function (errMsg) {
                error("failed to load 'manifest' file for geometry module '" + localLibraryId + "': " + errMsg);
            });
    };

    Human.assets.geometries.loader._unload = function (globalLibraryId) {
        Human.assets.geometries.destroyLibrary(globalLibraryId);
    };
})();

;
/**
 * @namespace Material libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsMaterials = Human.assets.materials = {}; 

    /** All materials
     */
    HumanAssetsMaterials.materials = {};

    /** Materials grouped into libraries
     */
    HumanAssetsMaterials.libraries = {};

    // Holds all SceneJS nodes for materials
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type:"library",
                data: "Materials library"
            });
        });

    /** Given a state ID and a relative material ID, attempts to find the material within the libraries
     * @param materialId Relative material ID, ie. not prefixed by libraryId
     */
    HumanAssetsMaterials.findMaterial = function (materialId) {
        var material;
        for (var libraryId in HumanAssetsMaterials.libraries) {
            if (HumanAssetsMaterials.libraries.hasOwnProperty(libraryId)) {
                material = HumanAssetsMaterials.materials[libraryId + "." + materialId];
                if (material) {
                    return material;
                }
            }
        }
        return null;
    };

    /** Creates a materials library
     * @param libraryId Unique library ID
     */
    HumanAssetsMaterials.createLibrary = function (libraryId) {
        if (HumanAssetsMaterials.libraries[libraryId]) {
            Human.log.warn("Human.assets.materials.createLibrary", "Material library already loaded: " + libraryId);
            return;
        }
        HumanAssetsMaterials.libraries[libraryId] = {
            // Root scene node for each library means we can blow away scene nodes
            // for a library in one shot by destroying the root
            node:libRoot.addNode({
                type:"library",
                data: "libraryId = " + libraryId
            }),
            libraryId:libraryId,
            materials:{}
        };
    };

    /** Creates a material within an existing materials library
     * @param libraryId ID of library
     * @param materialId ID for new material, globally unique among materials in all libraries
     * @param params Material params - material, reflection, texture, flags
     */
    HumanAssetsMaterials.createMaterial = function (libraryId, materialId, params) {
        var library = HumanAssetsMaterials.libraries[libraryId];
        if (!library) {
            Human.log.error("Human.assets.materials.createMaterial", "Material library not found: " + libraryId);
            return;
        }
        if (HumanAssetsMaterials.materials[materialId]) {
            Human.log.warn("Human.assets.materials.createMaterial", "Material already loaded: " + materialId);
            return;
        }
        var material = {};
        if (params.material) {
            material.material = library.node.addNode(params.material);
            material.glassFactor = params.material.glassFactor !== undefined && params.material.glassFactor !== null ? params.material.glassFactor : 1.0;
            material.murkiness = params.material.murkiness !== undefined && params.material.murkiness !== null ? params.material.murkiness : 1.0;
        } else {
            material.glassFactor = 1.0;
            material.murkiness = 1.0;
        }
        if (params.reflection) { // Reflection asset
            material.reflection = library.node.addNode({
                type: "reflect",
                coreId: params.reflection.getCoreId() // Share core with reflection scene node
            });
        }
        if (params.texture) {
            // Use deprecated SceneJS texture - http://xeolabs.com/articles/scenejs4-release/#texture-node-changes
            params.texture.type = "_texture"; // Deprecated SceneJS texture
            material.texture = library.node.addNode(params.texture);
        }
        if (params.flags) {
            material.flags = library.node.addNode(params.flags);
        }
        HumanAssetsMaterials.materials[materialId] = material;
        library.materials[materialId] = material;
    };

    /**
     * Destroys a materials library
     * @param libraryId
     */
    HumanAssetsMaterials.destroyLibrary = function (libraryId) {
        if (libraryId) {
            var lib = HumanAssetsMaterials.libraries[libraryId];
            if (!lib) {
                Human.log.warn("Human.assets.materials.destroyLibrary", "Material library not found: " + libraryId);
                return;
            }
            lib.node.destroy(); // Blow away scene subgraph
            for (var materialId in lib.materials) {
                if (lib.materials.hasOwnProperty(materialId)) {
                    delete HumanAssetsMaterials.materials[materialId];
                }
            }
            delete HumanAssetsMaterials.libraries[libraryId];
        } else {
            HumanAssetsMaterials.reset();
        }
    };

    /** Destroys all material libraries
     */
    HumanAssetsMaterials.reset = function () {
        for (var libraryId in HumanAssetsMaterials.libraries) {
            if (HumanAssetsMaterials.libraries.hasOwnProperty(libraryId)) {
                HumanAssetsMaterials.destroyLibrary(libraryId);
            }
        }
    };
})();;(function() {
    "use strict";


    /**
     * @namespace Loads material libraries into {@link Human.assets.materials}
     * @private
     */
    Human.assets.materials.loader = new Human.utils.Loader();

    /**
     * Configures this loader
     * Must configure before loading things
     */
    Human.assets.materials.loader.configure = function (params) {
        this._embedded = params.embedded;
        return this;
    };

    /**
     * Loads a materials library
     * @param libraryId Library ID, unique within namespace of the configured stateId
     * @param params Params for loading
     * @param ok Success
     * @param error Failure
     */
    Human.assets.materials.loader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localLibraryId = libraryId;
        var globalLibraryId = modelId + "." + libraryId;

        var self = this;

        if (params && params.manifest) {
            // Manifest was passed in directly, typically for embedded mode
            var map = self._parseManifest(modelId, params.manifest, Human.net.getMaterialDir(localLibraryId), null, null);
            Human.assets.materials.createLibrary(globalLibraryId);
            for (var materialId in map) {
                if (map.hasOwnProperty(materialId)) {
                    Human.assets.materials.createMaterial(globalLibraryId, globalLibraryId + "." + materialId, map[materialId]);
                }
            }
            ok();
        } else {
            // Load library manifest
            Human.net.getMaterialLibrary(
                localLibraryId,
                function (manifest) {
                    var map = self._parseManifest(modelId, manifest, Human.net.getMaterialDir(localLibraryId), null, null);
                    Human.assets.materials.createLibrary(globalLibraryId);
                    for (var materialId in map) {
                        if (map.hasOwnProperty(materialId)) {
                            Human.assets.materials.createMaterial(globalLibraryId, globalLibraryId + "." + materialId, map[materialId]);
                        }
                    }
                    ok();
                },
                function (errMsg) {
                    error("failed to load manifest file for material module '" + localLibraryId + "': " + errMsg);
                });
        }
    };

    /**
     * Parses materials manifest out into a out of form
     * {
             *      "foo": {
             *          material: { .. SceneJS material attributes .. },
             *          reflection: { .. SceneJS reflection attributes .. },
             *          texture:  { .. SceneJS texture attributes .. },
             *          flags:  { .. SceneJS flags attributes .. }
             *      },
             *      //...
             * }
     *
     * Prefixes image URLs with image directory path.
     * Postfixes URLs with cache-defeating key.
     *
     * @param modelId Model ID, for building IDs to reflection assets
     * @param node Current manifest node, starts off at root
     * @param path Path to prefix image URLs with
     * @param out Result, starts off undefined
     * @param item Current item we're building during recurssion, starts off undefined
     */
    Human.assets.materials.loader._parseManifest = function (modelId, node, path, out, item) {
        out = out || {};
        var i, len;

        if (node.id) {
            item = {};
            out[node.id] = item;
            node.id = null; // Don't let SceneJS create a node with this ID - would cause ID clash
        }
        switch (node.type) {
            case  "texture":
                var layer;
                for (i = 0, len = node.layers.length; i < len; i++) {
                    layer = node.layers[i];
                    layer.uri = layer.uri || layer.src;
                    if (!layer.uri) {
                        layer.uri = ".";
                        Human.log.error("Human.assets.materials.loader._parseManifest", "Texture layer with no 'uri' or 'src' property");
                    } else {
                        if (this._embedded) {
                            // (bas) these were changed to absolute uris
                            layer.uri += "?v=" + Human.VERSION;
                        } else {
                            layer.uri = path + layer.uri.substring(layer.uri.lastIndexOf("/") + 1) + "?v=" + Human.VERSION;
                        }
                    }

                    // In SceneJS V3.0, texture blendMode has changed from "add" to "multiply".
                    // Some of our materials for texture have black base color, which worked fine with "add",
                    // but not with "multiply", so we'll default to "add" here.
                    layer.blendMode = layer.blendMode || "add";
                }
                if (item) {
                    item.texture = node;
                }
                break;

            case "material":
                if (item) {
                    item.material = node;
                    if (node.reflectionId) {
                        var reflectionId = node.reflectionId;
                        var reflection = Human.assets.reflections.findReflection(reflectionId);
                        if (reflection) {
                            item.reflection = reflection.reflection;
                        } else {
                            Human.log.error("Human.assets.materials.loader._parseManifest", "Reflection not found: " + reflectionId);
                        }
                    }
                }
                break;

            case "flags":
                if (item) {
                    item.flags = node;
                }
                break;
        }
        if (node.nodes) {
            for (i = 0, len = node.nodes.length; i < len; i++) {
                this._parseManifest(modelId, node.nodes[i], path, out, item);
            }
        }
        return out;
    };

    /**
     * Unloads a materials library
     * @param globalLibraryId
     * @private
     */
    Human.assets.materials.loader._unload = function (globalLibraryId) {
        Human.assets.materials.destroyLibrary(globalLibraryId);
    };
})();
;/**
 * @namespace Transform libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsTransforms = Human.assets.transforms = {}; 

    /** All transforms
     */
    HumanAssetsTransforms.transforms = {};

    /** Transforms grouped into libraries
     */
    HumanAssetsTransforms.libraries = {};

    /** Given a relative transform ID, attempts to find the transform within the libraries
     * @param transformId Relative transform ID, ie. not prefixed by libraryId
     */
    HumanAssetsTransforms.findTransform = function (transformId) {
        var transform;
        for (var libraryId in HumanAssetsTransforms.libraries) {
            if (HumanAssetsTransforms.libraries.hasOwnProperty(libraryId)) {
                transform = HumanAssetsTransforms.transforms[libraryId + "." + transformId];
                if (transform) {
                    return transform;
                }
            }
        }
        return null;
    };

    /** Creates a transform library
     * @param libraryId Unique library ID
     */
    HumanAssetsTransforms.createLibrary = function (libraryId) {
        if (HumanAssetsTransforms.libraries[libraryId]) {
            Human.log.warn("Human.assets.transforms.createLibrary", "Transform library already loaded: " + libraryId);
            return;
        }
        HumanAssetsTransforms.libraries[libraryId] = {
            libraryId: libraryId,
            transforms: {}
        };
    };

    /** Creates a transform within an existing transforms library
     * @param libraryId ID of library
     * @param transformId ID for new transform, globally unique among transforms in all libraries
     * @param params Transform params
     */
    HumanAssetsTransforms.createTransform = function (libraryId, transformId, params) {
        var library = HumanAssetsTransforms.libraries[libraryId];
        if (!library) {
            Human.log.error("Human.assets.transforms.createTransform", "Transform library not found: " + libraryId + ", wont create transform");
            return;
        }
        if (HumanAssetsTransforms.transforms[transformId]) {
            Human.log.warn("Human.assets.transforms.createTransform", "Transform already loaded, not reloading: " + transformId);
            return;
        }
        var transform = new Human.assets.transforms.Transform(params);
        HumanAssetsTransforms.transforms[transformId] = transform;
        library.transforms[transformId] = transform;
    };

    /**
     * Destroys a transforms library
     * @param libraryId
     */
    HumanAssetsTransforms.destroyLibrary = function (libraryId) {
        if (libraryId) {
            var lib = HumanAssetsTransforms.libraries[libraryId];
            if (!lib) {
                Human.log.warn("Human.assets.transforms.destroyLibrary", "Transform library not found: " + libraryId);
                return;
            }
            for (var transformId in lib.transforms) {
                if (lib.transforms.hasOwnProperty(transformId)) {
                    delete HumanAssetsTransforms.transforms[transformId];
                }
            }
            delete HumanAssetsTransforms.libraries[libraryId];
        } else {
            HumanAssetsTransforms.reset();
        }
    };

    /** Destroys all transform libraries
     */
    HumanAssetsTransforms.reset = function () {
        for (var libraryId in HumanAssetsTransforms.libraries) {
            if (HumanAssetsTransforms.libraries.hasOwnProperty(libraryId)) {
                HumanAssetsTransforms.destroyLibrary(libraryId);
            }
        }
    };
})();;(function() {
    "use strict";

    /**
     * A transformation asset with a {@link Human.assets.transforms}.
     * @param cfg
     * @constructor
     */
    Human.assets.transforms.Transform = function (cfg) {

        // Call parent class Human.Component init
        this._init();

        // Defaults
        this.pivot = { x: 0, y: 0, z: 0 };
        this.translate = { x: 0, y: 0, z: 0 };
        this.scale = { x: 1, y: 1, z: 1 };
        this.rotate = { x: 0, y: 0, z: 0 };

        // Initialize
        this.set(cfg);
    };

    Human.utils.extend(Human.assets.transforms.Transform, Human.Component);

    /**
     * Sets the transforms.
     */
    Human.assets.transforms.Transform.prototype.set = function (params) {

        if (params.pivot) {
            if (params.pivot.x !== undefined && params.pivot.x !== null) {
                this.pivot.x = params.pivot.x;
            }
            if (params.pivot.y !== undefined && params.pivot.y !== null) {
                this.pivot.y = params.pivot.y;
            }
            if (params.pivot.z !== undefined && params.pivot.z !== null) {
                this.pivot.z = params.pivot.z;
            }
        }

        if (params.translate) {
            if (params.translate.x !== undefined && params.translate.x !== null) {
                this.translate.x = params.translate.x;
            }
            if (params.translate.y !== undefined && params.translate.y !== null) {
                this.translate.y = params.translate.y;
            }
            if (params.translate.z !== undefined && params.translate.z !== null) {
                this.translate.z = params.translate.z;
            }
        }

        if (params.scale) {
            if (params.scale.x !== undefined && params.scale.x !== null) {
                this.scale.x = params.scale.x;
            }
            if (params.scale.y !== undefined && params.scale.y !== null) {
                this.scale.y = params.scale.y;
            }
            if (params.scale.z !== undefined && params.scale.z !== null) {
                this.scale.z = params.scale.z;
            }
        }

        if (params.rotate) {
            if (params.rotate.x !== undefined && params.rotate.x !== null) {
                this.rotate.x = params.rotate.x;
            }
            if (params.rotate.y !== undefined && params.rotate.y !== null) {
                this.rotate.y = params.rotate.y;
            }
            if (params.rotate.z !== undefined && params.rotate.z !== null) {
                this.rotate.z = params.rotate.z;
            }
        }

        this.publish("updated");

     //   this._buildMatrix();
    };

})();

;(function () {
    "use strict";

    /**
     * @namespace Loads transform libraries into {@link Human.assets.transforms}
     * @private
     */
    Human.assets.transforms.loader = new Human.utils.Loader();

    /**
     * Loads a transforms library
     * @param moduleId Module ID
     * @param modelId State ID
     * @param libraryId Library ID, unique within namespace of the configured moduleId
     * @param params Params for loading
     * @param ok Success
     * @param error Failure
     */
    Human.assets.transforms.loader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localLibraryId = libraryId;
        var globalLibraryId = modelId + "." + libraryId;

        // Load library manifest
        Human.net.getTransformsLibrary(
            localLibraryId,
            function (manifest) {

                // Create transform library

                var map = manifest.transforms;
                if (!map) {
                    error("failed to load manifest file for transform module '" + localLibraryId + "': 'transforms' element missing in manifest");
                    return;
                }

                Human.assets.transforms.createLibrary(globalLibraryId);

                for (var transformId in map) {
                    if (map.hasOwnProperty(transformId)) {
                        Human.assets.transforms.createTransform(globalLibraryId, globalLibraryId + "." + transformId, map[transformId]);
                    }
                }
                ok();
            },
            function (errMsg) {
                error("failed to load manifest file for transform module '" + localLibraryId + "': " + errMsg);
            });
    };

    /**
     * Unloads a transforms library
     * @param globalLibraryId
     * @private
     */
    Human.assets.transforms.loader._unload = function (globalLibraryId) {
        Human.assets.transforms.destroyLibrary(globalLibraryId);
    };
})();
;/**
 * @namespace Engine media (videos, audio etc).
 */
Human.media = Human.media || {};;/**
 * @namespace Generic container for streaming media clips
 */
Human.media.Clips = function (streamType) {
    "use strict";

    var self = this;

    this._streamType = streamType;

    /** Clips mapped to IDs
     */
    this.clips = {};

    /** Clips ordered by their timeline times
     *
     * @type {Array}
     */
    this.clipsList = [];

    /** Clips grouped into libraries
     */
    this.libraries = {};

    /**
     * IDs of clips that are currently "suggested", where those clips have time1 and time2 properties
     * that interesect the current timeline scrubber.
     * @type {Array}
     */
    this.suggestedClips = [];

    Human.events.fire(this._streamType + ".clips", self.clipsList, true);
    Human.events.fire(this._streamType + ".suggestedClips", self.suggestedClips, true);
    
    var publishSuggested = function (params) {
        var time = params.time;
        var updateSuggestion = false;
        var suggest, clip;
      
        self.suggestedClips.length = 0;
        for (var i = 0, len = self.clipsList.length; i < len; i++) {
            clip = self.clipsList[i];
            suggest = (
                clip.time1 !== undefined && 
                clip.time1 !== null && 
                clip.time2 !== undefined && 
                clip.time2 !== null && 
                clip.time1 <= time && 
                time <= clip.time2
            );
            updateSuggestion = updateSuggestion || (suggest !== clip.suggested);
            clip.suggested = suggest;
            if (suggest) {
                self.suggestedClips.push(clip.clipId);
            }
        }
        if (updateSuggestion) {
            Human.events.fire(self._streamType + ".suggestedClips", self.suggestedClips, true);
        }
    };
    
    // When timeline scrubbed, publish the set of clips with 'time1' and 'time2' properties
    // that intersect the current time
    Human.events.on("timeline.scrubbed", publishSuggested);
    Human.events.on("timeline.played", publishSuggested);
    //this is needed in some instances, ie when calling timeline.next in play mode
    Human.events.on("timeline.stopped", publishSuggested);
    
    var counter = 0;
    //fire publishSuggested for every 30 timeline.playing events.
    //roughly similar to 'timeline.scrubbed' frequency.
    Human.events.on("timeline.playing", function (params) {
      if(counter % 30 === 0) {
        publishSuggested(params);
        counter = 0;
      }
      counter += 1;
    });
    
    /**
     * Creates a clips library
     *
     * @param {String} libraryId Unique library ID
     * @param {[{}]} clips Clips within the library
     */
    this.createLibrary = function (libraryId, clips) {

        if (this.libraries[libraryId]) {

            // Tolerate reload of same library
            Human.log.warn("Human.media." + this._streamType + ".createLibrary", "Library already loaded: " + libraryId);
            return;
        }

        var library = this.libraries[libraryId] = {
            libraryId: libraryId,
            clips: {}
        };

        var p;
        var clip;

        // Create clips
        for (var i = 0, len = clips.length; i < len; i++) {
            p = clips[i];

            // Validate each clip
            if (!p.clipId) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: clipId");
                continue;
            }
            if (!p.displayName) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: displayName");
                continue;
            }
            if (!p.type) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: type");
                continue;
            }
            if (!p.src) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: src");
                continue;
            }
            if (p.time1 === undefined || p.time1 === null) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: time1 - defaulting to 0 seconds");
                p.time1 = 0;
            }
            if (p.time2 === undefined || p.time2 === null) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip property missing: time2 - defaulting to 0 seconds");
                p.time2 = 0;
            }
            if (this.clips[p.clipId]) {
                Human.log.error("Human.media." + this._streamType + ".createLibrary", "Clip 'clipId' clashes with another clip: '" + p.clipId + "' - replacing existing clip");
            }

            clip = {
                clipId: p.clipId,
                displayName: p.displayName,
                description: p.description || "",
                time1: p.time1,
                time2: p.time2,
                type: p.type || "",
                src: p.src,
                alternatives: p.alternatives || [],
                length: p.length || 0,
                suggested: false,
                status: "closed"
            };

            // Register clip against library
            library.clips[p.clipId] = clip;

            // Add clip to ID map
            this.clips[p.clipId] = clip;
        }

        // Rebuild time-ordered clip list from ID map
        this._rebuildClipList();
    };

    /** Rebuilds time-ordered clip list and exports it via event
     * @private
     */
    this._rebuildClipList = function () {
        this.clipsList = [];
        for (var clipId in this.clips) {
            if (this.clips.hasOwnProperty(clipId)) {
                this._insertClipIntoList(this.clipsList, this.clips[clipId]);
            }
        }
        // Publish new clip list
        Human.events.fire(this._streamType + ".clips", this.clipsList, true);
    };

    /**
     * Inserts a clip into list of clips ordered by time
     * @private
     */
    this._insertClipIntoList = function (list, clip) {
        if (list.length === 0) {
            // First clip in list
            list.push(clip);
        } else {
            // Find place and insert
            var v;
            for (var j = list.length - 1; j >= 0; j--) {
                v = list[j];
                if (v.time1 < clip.time1) {
                    list.splice(j + 1, 0, clip);
                    return;
                }
            }
            // Clip is earliest - insert at front of list
            list.splice(0, 0, clip);
        }
    };

    /**
     * Destroys a clips library
     * @param libraryId
     */
    this.destroyLibrary = function (libraryId) {
        var lib = this.libraries[libraryId];
        if (!lib) {
            // Tolerate missing library
            Human.log.warn("Human.media." + this._streamType + ".destroyLibrary", "Library not found: " + libraryId);
            return;
        }
        for (var clipId in lib.clips) {
            if (lib.clips.hasOwnProperty(clipId)) {
                delete this.clips[clipId];
                Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "destroyed" });
            }
        }
        delete this.libraries[libraryId];

        // Rebuild time-ordered clip list from remaining clips in ID map
        this._rebuildClipList();
    };

    /**
     * Opens a clip
     * @param clipId
     */
    this.open = function (clipId, ok) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "open" }, true);
        ok();
    };

    /**
     * Plays a clip
     * @param clipId
     */
    this.play = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "playing" }, true);
    };

    /**
     * Scrubs a clip to the given time
     * @param clipId
     * @param time
     */
    this.scrub = function (clipId, time) {
        Human.events.fire(this._streamType + ".scrubbed", { clipId: clipId, time: time });
    };

    /**
     * Pauses a clip
     * @param clipId
     */
    this.pause = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "paused" }, true);
    };

    /**
     * Stops a clip
     * @param clipId
     */
    this.stop = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "stopped" }, true);
    };

    /**
     * Closes a clip
     * @param clipId
     */
    this.close = function (clipId) {
        Human.events.fire(this._streamType + ".status", { clipId: clipId, status: "closed" }, true);
    };

    /**
     * Destroys all clip libraries
     */
    this.reset = function () {
        for (var libraryId in this.libraries) {
            if (this.libraries.hasOwnProperty(libraryId)) {
                this.destroyLibrary(libraryId);
            }
        }
    };
};;/**
 * @namespace Audio clips
 */
Human.media.audio= new Human.media.Clips("audio");;(function() {
    "use strict";

    /**
     * @namespace Loads sound libraries into {@link Human.media.audio}
     * @private
     */
    Human.media.audio.loader = new Human.utils.Loader();

    /**
     * Loads a sounds library
     * @param libraryId Library ID, unique within namespace of the configured modelId
     * @param params Params for loading
     * @param ok Success
     * @param error Failure
     */
    Human.media.audio.loader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localLibraryId = libraryId;
        var globalLibraryId = modelId + "." + libraryId;

        var self = this;

        // Load library manifest
        Human.net.getAudioLibrary(
            localLibraryId,
            function (manifest) {

                if (!self._preprocessManifest(localLibraryId, manifest, Human.net.getAudioDir(localLibraryId))) {
                    // Error in sound manifest, was logged
                    ok();
                    return;
                }

                Human.media.audio.createLibrary(globalLibraryId, manifest);

                ok();
            },
            function (errMsg) {
                error("failed to load manifest file for audio library '" + localLibraryId + "': " + errMsg);
            });
    };

    /**
     * Prefixes sound file URLs with sound directory path
     * Postfixes URLs with cache-defeating key
     */
    Human.media.audio.loader._preprocessManifest = function () {
    //    var sound;
    //    var src;
    //    var fileExt;
    //    for (var soundId in manifest) {
    //        if (manifest.hasOwnProperty(soundId)) {
    //            sound = manifest[soundId];
    //            src = sound.src;
    //            // Check sound file name exists
    //            if (!src) {
    //                Human.log.error("Audio 'src' attribute missing : (library '" + localSoundLibId + "', asset: '"
    //                    + soundId + "')");
    //                return false; // Manifest error
    //            }
    //
    //            // Check sound file name exists
    //            fileExt = src.split('.').pop();
    //            if (fileExt != "wav" && fileExt != "ogg") {
    //                Human.log.error("Sound file '" + src + "' not supported type (library: '" + localSoundLibId + "', asset: '"
    //                    + soundId + "') - supported types are: ['.wav', '.ogg']");
    //                return false; // Manifest error
    //            }
    //            sound.src = path + "/" + sound.src + "?v=" + Human.VERSION;
    //        }
    //    }
        return true; // Manifest OK
    };

    /**
     * Unloads a sounds library
     * @param globalLibraryId
     * @private
     */
    Human.media.audio.loader._unload = function (globalLibraryId) {
        Human.media.audio.destroyLibrary(globalLibraryId);
    };
})();
;(function() {
    "use strict";

    
    Human.rpc.define("audio.getClips",
        function () {
            this.setResult(Human.media.audio.clipsList);
        });

    Human.rpc.define("audio.open",
        function (params) {
            var self = this;
            Human.media.audio.open(params.clipId,
                function () {
                    self.setResult(true); // Opened
                });
        });

    Human.rpc.define("audio.play",
        function (params) {
            Human.media.audio.play(params.clipId);
        });

    Human.rpc.define("audio.scrub",
        function (params) {
            Human.media.audio.scrub(params.clipId, params.time);
        });

    Human.rpc.define("audio.pause",
        function (params) {
            Human.media.audio.pause(params.clipId);
        });

    Human.rpc.define("audio.stop",
        function (params) {
            Human.media.audio.stop(params.clipId);
        });

    Human.rpc.define("audio.close",
        function (params) {
            Human.media.videos.close(params.clipId);
        });
})();
;/**
 * @namespace Video clips
 */
Human.media.videos = new Human.media.Clips("videos");;(function() {
    "use strict";

    /**
     * @namespace Loads video libraries into {@link Human.media.videos}
     * @private
     */
    Human.media.videos.loader = new Human.utils.Loader();

    /**
     * Loads a videos library
     */
    Human.media.videos.loader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localLibraryId = libraryId;
        var globalLibraryId = modelId + "." + libraryId;

        Human.net.getVideosLibrary(
            localLibraryId,
            function (manifest) {
                Human.media.videos.createLibrary(globalLibraryId, manifest);
                ok();
            },
            function (errMsg) {
                error("failed to load manifest file for video library '" + localLibraryId + "': " + errMsg);
            });
    };

    /**
     * Unloads a videos library
     * @param globalLibraryId
     * @private
     */
    Human.media.videos.loader._unload = function (globalLibraryId) {
        Human.media.videos.destroyLibrary(globalLibraryId);
    };
})();

;(function() {
    "use strict";

    Human.rpc.define("videos.getClips",
        function () {
            this.setResult(Human.media.videos.clipsList);
        });

    Human.rpc.define("videos.open",
        function (params) {
            var self = this;
            Human.media.videos.open(params.clipId,
                function () {
                    self.setResult(true); // Opened
                });
        });

    Human.rpc.define("videos.play",
        function (params) {
            Human.media.videos.play(params.clipId);
        });

    Human.rpc.define("videos.scrub",
        function (params) {
            Human.media.videos.scrub(params.clipId, params.time);
        });

    Human.rpc.define("videos.pause",
        function (params) {
            Human.media.videos.pause(params.clipId);
        });

    Human.rpc.define("videos.stop",
        function (params) {
            Human.media.videos.stop(params.clipId);
        });

    Human.rpc.define("videos.close",
        function (params) {
            Human.media.videos.close(params.clipId);
        });
})();
;/**
 * @namespace Morph libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsMorphs = Human.assets.morphs = {}; 

    /** All morphs
     */
    HumanAssetsMorphs.morphs = {};

    /** Morphs grouped into libraries
     */
    HumanAssetsMorphs.libraries = {};

    // Holds all SceneJS nodes for morphs
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Morphs library"
            });
        });

    /** Given a relative morph ID, attempts to find the morph within the libraries
     * @param morphId Relative morph ID, ie. not prefixed by libraryId
     */
    HumanAssetsMorphs.findMorph = function (morphId) {
        var material;
        for (var libraryId in HumanAssetsMorphs.libraries) {
            if (HumanAssetsMorphs.libraries.hasOwnProperty(libraryId)) {
                material = HumanAssetsMorphs.morphs[libraryId + "." + morphId];
                if (material) {
                    return material;
                }
            }
        }
        return null;
    };

    /** Creates a morphs library
     * @param libraryId Unique library ID
     */
    HumanAssetsMorphs.createLibrary = function (libraryId) {
        if (HumanAssetsMorphs.libraries[libraryId]) {
            Human.log.warn("Human.assets.morphs", "Morph library already loaded: " + libraryId);
            return;
        }
        HumanAssetsMorphs.libraries[libraryId] = {
            // Root scene node for each library means we can blow away scene nodes
            // for a library in one shot by destroying the root
            node: libRoot.addNode({
                type: "library",
                data: "libraryId = " + libraryId
            }),
            libraryId: libraryId,
            morphs: {}
        };

        return HumanAssetsMorphs.libraries[libraryId];
    };

    /** Creates a material within an existing morphs library
     * @param libraryId ID of library
     * @param morphId ID for new material, globally unique among morphs in all libraries
     * @param params Material params - material, texture, flags

     */
    HumanAssetsMorphs.createMorph = function (libraryId, morphId, params) {
        var library = HumanAssetsMorphs.libraries[libraryId];
        if (!library) {
            Human.log.error("morph library not found: " + libraryId);
            return;
        }
        var morph = HumanAssetsMorphs.morphs[morphId];
        if (morph) {
            Human.log.warn("Human.assets.morphs.createMorph", "Morph already loaded: " + morphId);
            return morph;
        }
        var boundary = params.boundary;
        morph = {
            // materialId:params.materialId, // Deprecated
            boundary: boundary,
            center: [
                (boundary.xmax + boundary.xmin) * 0.5,
                (boundary.ymax + boundary.ymin) * 0.5,
                (boundary.zmax + boundary.zmin) * 0.5
            ],
            axisBoundary: new Human.math.AxisBox3(
                [boundary.xmin, boundary.ymin, boundary.zmin],
                [boundary.xmax, boundary.ymax, boundary.zmax])
        };
        if (params.morphGeometry) {
            params.morphGeometry.type = "morphGeometry";
            morph.morphGeometry = library.node.addNode(params.morphGeometry);
        }
        HumanAssetsMorphs.morphs[morphId] = morph;
        library.morphs[morphId] = morph;
        return morph;
    };

    /**
     * Destroys a morph library
     * @param libraryId
     */
    HumanAssetsMorphs.destroyLibrary = function (libraryId) {
        if (libraryId) {
            var lib = HumanAssetsMorphs.libraries[libraryId];
            if (!lib) {
                Human.log.warn("Human.assets.morphs.destroyLibrary", "Morph library not found: " + libraryId);
                return;
            }
            lib.node.destroy(); // Blow away scene subgraph
            for (var morphId in lib.morphs) {
                if (lib.morphs.hasOwnProperty(morphId)) {
                    delete HumanAssetsMorphs.morphs[morphId];
                }
            }
            delete HumanAssetsMorphs.libraries[libraryId];
        } else {
            HumanAssetsMorphs.reset();
        }
    };

    /** Destroys all morph libraries
     */
    HumanAssetsMorphs.reset = function () {
        for (var libraryId in HumanAssetsMorphs.libraries) {
            if (HumanAssetsMorphs.libraries.hasOwnProperty(libraryId)) {
                HumanAssetsMorphs.destroyLibrary(libraryId);
            }
        }
    };
})();;(function() {
    "use strict";

    /**
     * An animation comprised of a set of morphs, which may be installed into the {@link Human.timeline}.
     * Like all such animations, it has an {@link #update} method through which the timeline updates the
     * progress of the morphs. The morphs each contain a {@link SceneJS.MorphGeometry} and possibly
     * a {@link SceneJS.Geometry}, which are kept externally in a {@link Human.assets.morphs}.
     *
     * @class
     * @constructor
     * @private
     */
    Human.assets.morphs.Animation = function (cfg) {
        this.type = "morph-animation";
        this._loop = (cfg.loop !== false);
        this._morphList = [];
        this.timeline = cfg.timeline;
    };

    /**
     * Adds a morph to this animation
     * @param firstTime First time key
     * @param lastTime Last time key
     * @param update Callback to update the morph progress
     */
    Human.assets.morphs.Animation.prototype.addMorph = function (firstTime, lastTime, update) {
        this._morphList.push({ firstTime:firstTime, lastTime:lastTime, update:update  });
        this._timeFrame = null; // Need recompute
    };

    /**
     * Returns time frame enclosing keys of all contained morphs
     * @return {*}
     */
    Human.assets.morphs.Animation.prototype.getTimeFrame = function () {
        if (this._timeFrame) {
            return this._timeFrame;
        }
        var min = 1000000;
        var max = -1000000;
        var morph;
        var morphList = this._morphList;
        for (var i = 0, len = this._morphList.length; i < len; i++) {
            morph = morphList[i];
            if (morph.firstTime < min) {
                min = morph.firstTime;
            }
            if (morph.lastTime > max) {
                max = morph.lastTime;
            }
        }

        this._timeFrame = { firstTime:min, lastTime:max };

        return this._timeFrame;
    };

    /**
     * Updates progress of morphs
     * @param ctx
     * @param time
     */
    Human.assets.morphs.Animation.prototype.update = function (ctx, time) {
        var morph;
        var time2;
        for (var i = 0, len = this._morphList.length; i < len; i++) {
            morph = this._morphList[i];
            if (this._loop) {
                // Dont wrap when time is right on the last key
                time2 = (time === morph.lastTime) ? time : (morph.firstTime + time % (morph.lastTime - morph.firstTime));
            } else {
                if (time2 < morph.firstTime) {
                    time2 = morph.firstTime;
                }
                if (time2 > morph.lastTime) {
                    time2 = morph.lastTime;
                }
            }
            morph.update(time2);
        }
    };

    /**
     * Destroys this module
     */
    Human.assets.morphs.Animation.prototype.destroy = function () {
        this.destroyed = true;
    };
})();

;/**
 * @namespace Loads morph libraries into {@link Human.assets.morphs}
 * @private
 */
(function () {
    "use strict";

    var MorphsLoader = Human.assets.morphs.loader = {}; 

    MorphsLoader.load = function (stateId, localLibraryId, globalLibraryId, manifest, params, ok, error) {

        // Get info that we'll use to ensure
        // that we only load what array data is provided
        var stats = getStats(manifest.morphs);

        // Load bulk binary arrays
        loadBinaryArrays(localLibraryId, stats,

            function (arrays) {

                // Create morph library
                Human.assets.morphs.createLibrary(globalLibraryId);

                // Create morph animation

                params.timeline = params.timeline !== undefined && params.timeline !== null ? params.timeline : manifest.timeline;

                var animation = new Human.assets.morphs.Animation(params);

                // Create morphs and add them to library

                var globalMorphId;
                var morph;
                var targets;
                var numKeys;
                var sizePositionsPerTarget;
                var sizeNormalsPerTarget;
                var positionsIndex;
                var normalsIndex;

                for (var morphId in manifest.morphs) {
                    if (manifest.morphs.hasOwnProperty(morphId)) {

                        morph = manifest.morphs[morphId];

                        globalMorphId = globalLibraryId + "." + morphId;

                        targets = morph.targets;
                        numKeys = morph.keys.length;
                        sizePositionsPerTarget = targets.positions[1] / numKeys;
                        sizeNormalsPerTarget = targets.normals[1] / numKeys;

                        var keys = morph.keys;
                        var targetsData = [];

                        positionsIndex = targets.positions[0];
                        normalsIndex = targets.normals[0];

                        // Slice the positions and normals up among the arrays's morph targets
                        // Get the boundary that encloses all the position targets

                        for (var i = 0, boundary = null; i < numKeys; i++) {

                            var positions = new Float32Array(slice(arrays.positions, [positionsIndex, sizePositionsPerTarget]));

                            targetsData.push({
                                positions: positions,
                                normals: new Float32Array(slice(arrays.normals, [normalsIndex, sizeNormalsPerTarget]))
                            });

                            boundary = getBoundary(positions, boundary);

                            positionsIndex += sizePositionsPerTarget;
                            normalsIndex += sizeNormalsPerTarget;
                        }

                        // Create morph asset
                        var morphNodes = Human.assets.morphs.createMorph(globalLibraryId, globalMorphId, {
                            morphGeometry: {
                                targets: targetsData,
                                keys: keys
                            },
                            boundary: boundary
                        });

                        // Add morph to animation
                        addMorphToAnimation(animation, morphNodes, keys);
                    }
                }

                // Add animation to timeline
                Human.timeline.addAnimation(globalLibraryId, animation);

                // Done
                ok();

            },
            error);
    };

    /**
     * Returns info on what we'll be loading
     * @param map
     * @return {{}} The info
     */
    function getStats(map) {
        var data = {
            numMorphs: 0,
            numArrays: 0,
            positions: false,
            uv: false,
            normals: false
        };
        var item;
        var targets;
        for (var key in map) {
            if (map.hasOwnProperty(key) && map[key]) {
                data.numMorphs++;
                item = map[key];
                if (item.targets) {
                    targets = item.targets;
                    if (targets.positions && !data.positions) {
                        data.positions = true;
                        data.numArrays++;
                    }
                    if (targets.normals && !data.normals) {
                        data.normals = true;
                        data.numArrays++;
                    }
                    if (targets.uv && data.uv) {
                        data.uv = true;
                        data.numArrays++;
                    }
                }
            }
        }
        return data;
    }

    function loadBinaryArrays(localLibraryId, stats, _ok, _error) {

        var wasError = false;
        var arrays = {};

        // Fired once all binary arrays have loaded
        function ok() {
            if (!wasError) {
                _ok(arrays);
            }
        }

        // Fired once on error
        function error(err) {
            if (!wasError) {
                wasError = true;
                _error(err);
            }
        }

        // Load data arrays
        var numArraysToLoad = stats.numArrays; // Must equal number of Human.net.getXX calls below or loading will hang
        var numArraysLoaded = 0;

        if (stats.positions) {
            Human.net.getMorphPositions(
                localLibraryId,
                function (array) {
                    arrays.positions = array;
                    if (++numArraysLoaded === numArraysToLoad) {
                        ok();
                    }
                },
                error);
        }

        if (stats.normals) {
            Human.net.getMorphNormals(
                localLibraryId,
                function (array) {
                    arrays.normals = array;
                    if (++numArraysLoaded === numArraysToLoad) {
                        ok();
                    }
                },
                error);
        }

        if (stats.uv) {
            Human.net.getMorphUVs(
                localLibraryId,
                function (array) {
                    arrays.uv = array;
                    if (++numArraysLoaded === numArraysToLoad) {
                        ok();
                    }
                },
                error);
        }
    }

    function slice(array, portion) {
        var start = portion[0];
        var end = start + portion[1];
        if (array.subarray) {
            return array.subarray(start, end); // https://bugs.webkit.org/show_bug.cgi?id=53618
        } else {
            return array.slice(start, end);
        }
    }

    function getBoundary(positions, boundary) {
        if (!boundary) {
            boundary = {
                xmin: 100000,
                ymin: 100000,
                zmin: 100000,
                xmax: -100000,
                ymax: -100000,
                zmax: -100000
            };
        }
        var x, y, z;
        for (var i = 0, len = positions.length - 2; i < len; i += 3) {
            x = positions[i];
            y = positions[i + 1];
            z = positions[i + 2];
            if (x === undefined || x === null ||
                y === undefined || y === null ||
                z === undefined || z === null) {
                continue;
            }
            if (x < boundary.xmin) {
                boundary.xmin = x;
            }
            if (y < boundary.ymin) {
                boundary.ymin = y;
            }
            if (z < boundary.zmin) {
                boundary.zmin = z;
            }
            if (x > boundary.xmax) {
                boundary.xmax = x;
            }
            if (y > boundary.ymax) {
                boundary.ymax = y;
            }
            if (z > boundary.zmax) {
                boundary.zmax = z;
            }
        }
        return boundary;
    }

    function addMorphToAnimation(animation, morphNodes, keys) {
        var morphGeometry = morphNodes.morphGeometry;
        animation.addMorph(keys[0], keys[keys.length - 1],
            function (factor) {
                morphGeometry.setFactor(factor);
            });
    }

    MorphsLoader.unload = function (globalLibraryId) {
        Human.assets.morphs.destroyLibrary(globalLibraryId);
        Human.timeline.removeAnimation(globalLibraryId);
    };
})();
;/**
 * @namespace Reflection libraries
 * @private
 */
(function () {
    "use strict";

    var HumanAssetsReflections = Human.assets.reflections = {};

    /** All reflections
     */
    HumanAssetsReflections.reflections = {};

    /** Reflections grouped into libraries
     */
    HumanAssetsReflections.libraries = {};

    /** Exported reflections
     *
     * @type {{}}
     */
    HumanAssetsReflections.active = {};

    // Holds all SceneJS nodes for reflections
    var libRoot;

    Human.events.on(
        "loaded",
        function () {
            // Scene graph now available
            libRoot = Human.renderer.getNode('assetLibraryRoot').addNode({
                type: "library",
                data: "Reflections library" // For debugging
            });
        });


    /** Only once reflections are activated and mapped to names can they be used
     * <p>Enable materials to use a particular reflection when they have a "reflectionId" set to "myReflection":</p>
     * <pre>
     *     #activateReflections({
     *          "myReflection" : "someState.someReflectionLib.someReflectionId"
     *          });
     * </pre>
     *
     * @param mapping
     */
    HumanAssetsReflections.activateReflections = function (mapping) {
        HumanAssetsReflections.active = mapping || {};
    };

    /** Given a state ID and a relative reflection ID, attempts to find the reflection within the libraries
     * @param activeReflectionId Active reflection ID, as mapped with #activateReflections
     */
    HumanAssetsReflections.findReflection = function (activeReflectionId) {
        var reflectionId = HumanAssetsReflections.active[activeReflectionId];
        if (!reflectionId) {
            return null;
        }
        return HumanAssetsReflections.reflections[reflectionId];
    };

    /** Creates a reflections library
     * @param libraryId Unique library ID
     */
    HumanAssetsReflections.createLibrary = function (libraryId) {
        if (HumanAssetsReflections.libraries[libraryId]) {
            Human.log.warn("Human.assets.reflections.createLibrary", "Reflection library already loaded: " + libraryId);
            return;
        }
        HumanAssetsReflections.libraries[libraryId] = {
            // Root scene node for each library means we can blow away scene nodes
            // for a library in one shot by destroying the root
            node: libRoot.addNode({
                type: "library",
                data: "libraryId = " + libraryId // For debugging
            }),
            libraryId: libraryId,
            reflections: {}
        };
    };

    /** Creates a reflection within an existing reflections library
     * @param libraryId ID of library
     * @param reflectionId ID for new reflection, globally unique among reflections in all libraries
     * @param params Reflection params - reflection, texture, flags
     */
    HumanAssetsReflections.createReflection = function (libraryId, reflectionId, params) {
        var library = HumanAssetsReflections.libraries[libraryId];
        if (!library) {
            Human.log.error("Human.assets.reflections.createReflection", "Reflection library not found: " + libraryId);
            return;
        }
        if (HumanAssetsReflections.reflections[reflectionId]) {
            Human.log.warn("Human.assets.reflections.createReflection", "Reflection already loaded: " + reflectionId);
            return;
        }
        params.type = "reflect";
        params.blendMode = params.blendMode || "add";
        var reflection = {
            reflection: library.node.addNode(params)
        };
        HumanAssetsReflections.reflections[reflectionId] = reflection;
        library.reflections[reflectionId] = reflection;
    };

    /**
     * Destroys a reflections library
     * @param libraryId
     */
    HumanAssetsReflections.destroyLibrary = function (libraryId) {
        if (libraryId) {
            var lib = HumanAssetsReflections.libraries[libraryId];
            if (!lib) {
                Human.log.warn("Human.assets.reflections.destroyLibrary", "Reflection library not found: " + libraryId);
                return;
            }
            lib.node.destroy(); // Blow away scene subgraph
            for (var reflectionId in lib.reflections) {
                if (lib.reflections.hasOwnProperty(reflectionId)) {
                    delete HumanAssetsReflections.reflections[reflectionId];
                }
            }
            delete HumanAssetsReflections.libraries[libraryId];
        } else {
            HumanAssetsReflections.reset();
        }
    };

    /** Destroys all reflection libraries
     */
    HumanAssetsReflections.reset = function () {
        for (var libraryId in HumanAssetsReflections.libraries) {
            if (HumanAssetsReflections.libraries.hasOwnProperty(libraryId)) {
                HumanAssetsReflections.destroyLibrary(libraryId);
            }
        }
    };
})();;(function() {
    "use strict";
    
    
    /**
     * @namespace Loads reflections into {@link Human.view.reflections}
     * @private
     * @type {Loader}
     */
    Human.assets.reflections.loader = new Human.utils.Loader();

    Human.assets.reflections.loader._load = function (moduleId, modelId, libraryId, params, ok, error) {

        var localLibraryId = libraryId;
        var globalLibraryId = modelId + "." + libraryId;

        Human.net.getReflectionsLibrary(
            localLibraryId,
            function (manifest) {                        
                Human.assets.reflections.createLibrary(globalLibraryId);            
                var imagesPath = Human.net.getReflectionsDir(localLibraryId);
                var reflection;
                var srcList;
                for (var reflectionId in manifest) {
                    if (manifest.hasOwnProperty(reflectionId)) {
                        reflection = manifest[reflectionId];
                        srcList = reflection.src;
                        if (!srcList) {
                            Human.log.error("Human.assets.reflections.loader", "Reflection property missing: src");
                            continue;
                        }
                        if (!Human._isArray(srcList)) {
                            Human.log.error("Human.assets.reflections.loader", "Reflection property should be array: src");
                            continue;
                        }
                        for (var i = 0, len = srcList.length; i < len; i++) {
                            var src = srcList[i];
                            srcList[i] = imagesPath + src.substring(src.lastIndexOf("/") + 1) + "?v=" + Human.VERSION;
                        }                                        
                        Human.assets.reflections.createReflection(globalLibraryId, globalLibraryId + "." + reflectionId, reflection);
                    }
                }
                // Subsequently-loaded materials will need our reflections to exist, so render a frame
                // to force the creation of the reflections' nodes in the scene graph
                Human.renderer.forceRenderFrame();
                ok();
            },
            function (errMsg) {
                error("failed to load manifest file for reflections library '" + localLibraryId + "': " + errMsg);
            });
    };


    Human.assets.reflections.loader._unload = function (globalLibraryId) {
        Human.assets.reflections.destroyLibrary(globalLibraryId);
    };
})();
;/**

 @namespace Loads, registers and unloads models

 <p>
 To load a model, this object is given a model ID and an index that points to the various asset libraries
 that are to be loaded for it. It delegates to the various library loader objects to load those libraries,
 then registers the newly loaded model in a list, arranged in the same order as when the models were loaded.
 </p>
 <p>
 Note that within the list you'll have some models that depend upon others, where the models are ordered
 after the ones they depend on. For example, you might have an anatomy model (A), followed by a condition model
 (B) which contains animations that are applied to objects within (A).
 </p>
 <p>
 The various library loaders remember what they loaded for each given model's ID.
 </p>
 <p>
 When unloading a model, this object simply splices the model out of the list then tells the various
 loaders to unload whatever they loaded for that model's ID.
 </p>
 */
(function () {
    "use strict";

    var HumanModels = Human.models = {};

    /**
     * List of currently loaded models that came with IDs, in order of when they were loaded.
     * If models depend on each other in any way, then the dependents will come after the dependees.
     * @type {Object}
     */
    HumanModels.models = [];

    /**
     * Loads a model
     *
     * @memberof Human.models
     * @param {{}} params
     * @param {String} params.moduleId ID of module that 'owns' the model we're loading
     * @param {String} params.modelId ID of model we're loading
     * @param {Function} ok Success callback
     * @param {Function} error Error callback
     */
    HumanModels.loadModel = function (params, ok, error) {

        var moduleId = params.moduleId;

        if (!moduleId) {
            error("[Human.models.loadModel] Param missing: 'moduleId'");
            return;
        }

        var modelId = params.modelId;

        if (!modelId) {
            error("[Human.models.loadModel] Param missing: 'modelId'");
            return;
        }

        // Temporarily pause the renderer for faster loading
        Human.renderer.pushPause();

        // Start preloading images for textures
        preloadModelImages(modelId,
            function () {

                // Open model source, which is either a stream or directory, depending on whether
                // we're loading streams or from file system
                Human.net.openModel(modelId,
                    params.streamObjects,
                    function () {

                        // Load model's content index
                        Human.net.getStateIndex(
                            function (index) {

                                // Load the content
                                loadModelContent(moduleId, modelId, index,
                                    function () { // Loaded content OK

                                        // Unpause the renderer
                                        Human.renderer.popPause();

                                        // Wait until scene graph catches up on fresh node insertions
                                        Human.renderer.onTasksComplete(
                                            function () {
                                                ok();
                                            });
                                    });
                            },
                            function (errMsg) { // Error loading index

                                // Unpause the renderer
                                Human.renderer.popPause();

                                error("[Human.models.loadModel] Failed to load index for model '" + modelId + "': " + errMsg);
                            });
                    },
                    function (errMsg) {

                        // Unpause the renderer
                        Human.renderer.popPause();

                        error("[Human.models.loadModel] Failed to open source stream/directory for model '" + modelId + "': " + errMsg);
                    });
            });
    };

    // Preloads images for the textures in a model
    //
    // - loads model index and material library outlines
    // - callback is fired as soon as those are loaded
    // - continues to background pre-load images for textures in the material libraries

    function preloadModelImages(modelId, ok) {
        //   Human.log.info("Human.models.loadModel", "Texture images preload started");
        var mode = Human.net.mode;
        Human.net.setMode("file");
        Human.net.openModel(modelId,
            null,
            function () {
                Human.net.getStateIndex(
                    function (index) {
                        var data = index.data || {};
                        var libs = data.material || data.materials;
                        var tasks = [];
                        var numTasks = 0;
                        for (var libId in libs) {
                            if (libs.hasOwnProperty(libId)) {
                                tasks.push(getTextureImageCallback(libId, checkComplete));
                                numTasks++;
                            }
                        }
                        if (numTasks === 0) {
                            Human.net.setMode(mode);
                            ok();
                            return;
                        }
                        while (tasks.length) {
                            tasks.pop()();
                        }

                        function checkComplete() {
                            if (--numTasks === 0) {
                                Human.net.setMode(mode);
                                //   Human.log.info("Human.models.loadModel", "Texture images preload complete");
                                ok();
                            }
                        }
                    },
                    function (errMsg) {
                        Human.net.setMode(mode);
                        Human.log.error("Human.models.loadModel", "Texture images preload failed: " + errMsg);
                        ok();
                    });
            },
            function (errMsg) {
                Human.net.setMode(mode);
                Human.log.error("Human.models.loadModel", "Texture images preload failed: " + errMsg);
                ok();
            });
    }

    // Preloads images for the textures in a materials library
    function preloadMaterialLibImages(libId, ok) {
        Human.net.getMaterialLibrary(libId,
            function (outline) {
                var path = Human.net.getMaterialDir(libId);
                preloadTextureImages(outline, path);
                ok();
            });
    }

    // Preloads images for the textures in the given scene subgraph definition
    function preloadTextureImages(node, path) {
        var i, len;

        switch (node.type) {
            case  "texture":
                var layer;
                var src;
                for (i = 0, len = node.layers.length; i < len; i++) {
                    layer = node.layers[i];
                    src = layer.uri || layer.src;
                    if (src) {
                        var src2;
                        if (HumanModels._embedded) {
                            // (bas) these were changed to absolute uris
                            src2 = src + "?v=" + Human.VERSION;
                        } else {
                            src2 = path + src.substring(src.lastIndexOf("/") + 1) + "?v=" + Human.VERSION;
                        }
                        var img = new Image();
                        img.src = src2;
                        //   Human.log.info("Human.models.loadModel", "Preloaded texture image: " + src);
                    }
                }
                break;
        }
        if (node.nodes) {
            for (i = 0, len = node.nodes.length; i < len; i++) {
                preloadTextureImages(node.nodes[i], path);
            }
        }
    }

    function loadModelContent(moduleId, modelId, index, ok) {

        var data = index.data || {};

        // Blow away dissection history
        Human.view.dissect.reset();

        var tasks = [];

        if (data.reflections) {
            addTasks(moduleId, modelId, tasks, data.reflections, Human.assets.reflections.loader);
        }

        if (data.material || data.materials) {
            addTasks(moduleId, modelId, tasks, data.material || data.materials, Human.assets.materials.loader);
        }

        if (data.transforms) {
            addTasks(moduleId, modelId, tasks, data.transforms, Human.assets.transforms.loader);
        }

        if (data.sounds) {
            addTasks(moduleId, modelId, tasks, data.sounds, Human.media.audio.loader);
        }

        if (data.videos) {
            addTasks(moduleId, modelId, tasks, data.sounds, Human.media.videos.loader);
        }

        if (data.geometries) {
            addTasks(moduleId, modelId, tasks, data.geometries, Human.assets.geometries.loader);
        }

        if (data.animations) {
            addTasks(moduleId, modelId, tasks, data.animations, Human.timeline.animationLoader);
        }

        if (data.chapters) {
            addTasks(moduleId, modelId, tasks, data.chapters, Human.timeline.chapterLoader);
        }

        if (data.anatomies) {
            addTasks(moduleId, modelId, tasks, data.anatomies, Human.scene.loader);
        }

        if (data.lights) {
            addTasks(moduleId, modelId, tasks, data.lights, Human.view.lights.loader);
        }

        if (data.videos) {
            addTasks(moduleId, modelId, tasks, data.videos, Human.media.videos.loader);
        }

        if (data.audio) {
            addTasks(moduleId, modelId, tasks, data.audio, Human.media.audio.loader);
        }

        runTasks(tasks, function () {

            // Create module JSON scene objects
            Human.scene.objectLoader.load(moduleId, modelId, data.createObjects);

            // If it came with an ID, register the newly-loaded model for unloading later
            if (modelId) {
                HumanModels.models.push({
                    modelId: modelId
                });
            }

            // Done
            ok();
        });
    }

    function addTasks(moduleId, modelId, tasks, libs, loader) {
        for (var libraryId in libs) {
            if (libs.hasOwnProperty(libraryId)) {
                tasks.unshift(getTaskFunction(libraryId, moduleId, modelId, tasks, libs, loader));
            }
        }
    }

    function runTasks(tasks, ok) {
        if (tasks.length === 0) {
            ok();
            return;
        }
        tasks.pop()(
            function () {
                runTasks(tasks, ok);
            });
    }

    function getTextureImageCallback(libId, ok) {
        var _libId = libId;
        return function () {
            preloadMaterialLibImages(_libId, ok);
        };
    }

    function getTaskFunction(libraryId, moduleId, modelId, tasks, libs, loader) {
        var _libraryId = libraryId;
        var params = libs[libraryId];

        return function (ok) {
            try {
                loader.load(moduleId, modelId, _libraryId, params,
                    function () {
                        ok();
                    },
                    function (errMsg) {
                        Human.log.error("Human.models.loadModel", "Failed to load model '" + modelId + "' library '" + _libraryId + "': " + errMsg);
                        ok();
                    });
            } catch (e) {
                Human.log.error("Human.models.loadModel", "Failed to load model '" + modelId + "' library '" + _libraryId + "': " + e);
                ok();
            }
        };
    }

    /**
     * Unloads all models currently loaded
     */
    HumanModels.unloadAllModels = function () {
        while (HumanModels.models.length) {
            HumanModels.unloadModel(HumanModels.models.pop().modelId);
        }
    };

    /**
     * Unloads a model
     * @memberof Human.models
     * @param {String} [modelId] ID of model
     */
    HumanModels.unloadModel = function (modelId) {
        var model;
        for (var i = 0, len = HumanModels.models.length; i < len; i++) {
            model = HumanModels.models[i];
            if (model.modelId === modelId) {
                Human.assets.materials.loader.unload(modelId);
                Human.assets.geometries.loader.unload(modelId);
                Human.assets.transforms.loader.unload(modelId);
                Human.assets.reflections.loader.unload(modelId);
                Human.timeline.animationLoader.unload(modelId);
                Human.timeline.chapterLoader.unload(modelId);
                Human.scene.loader.unload(modelId);
                Human.scene.objectLoader.unload(modelId);
                Human.view.lights.loader.unload(modelId);
                Human.media.videos.loader.unload(modelId);
                Human.media.audio.loader.unload(modelId);
                HumanModels.models.splice(i, 1);
                // Force SceneJS cleanup?
                Human.renderer.forceRenderFrame();
                return;
            }
        }
    };
})();

;/**
 @namespace Captures and restores engine state to and from JSON bookmark objects.

 */
(function () {
    "use strict";

    var HumanBookmarks = Human.bookmarks = {};

    /**
     * Captures the current engine state to a JSON bookmark object
     * <h4>Examples</h4>
     * <p>Capture everything:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture();
     * </pre>
     * <p>Capture just camera and view modes:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture({
     *         camera: true,
     *         view: true
     *     });
     * </pre>
     * <p>Capture everything but view modes:</p>
     * <pre>
     *     var bookmark = Human.bookmarks.capture({
     *         view: false
     *     });
     * </pre>
     * @memberof Human.bookmarks
     * @param {{String: Boolean}} mask Mask which specifies what to capture in the bookmark
     * @param {Boolean} mask.modules Capture what modules are loaded?
     * @param {Boolean} mask.camera Capture camera state?
     * @param {Boolean} mask.modes Capture view modes?
     * @param {Boolean} mask.objects Capture scene object states?
     * @param {Boolean} mask.annotations Capture annotations?
     * @returns {{}} The JSON bookmark object
     */
    HumanBookmarks.capture = function (mask) {
        var bm = {};
        if (masked(mask, "modules")) {
            bm.modules = {
                moduleLibs: captureModuleLibs(),
                activeModules: captureActiveModules()
            };
        }
        if (masked(mask, "camera")) {
            bm.camera = captureCamera();
        }
        if (masked(mask, "modes")) {
            bm.modes = captureViewModes();
        }
        if (masked(mask, "clips")) {
            bm.clips = captureCrossSections();
        }
        if (masked(mask, "objects")) {
            bm.objects = captureObjectStates();
        }
        if (masked(mask, "annotations")) {
            bm.annotations = captureAnnotations();
        }
        if (masked(mask, "timeline")) {
            bm.timeline = Human.timeline.getBookmark();
        }
        return bm;
    };

    function masked(mask, key) {
        if (!mask) {
            return true;
        }
        if (mask[key] === true) {
            return true;
        }
        if (mask[key] === false) {
            return false;
        }
        return false;
    }

    /**
     * Bookmarks which module libraries are currently loaded
     */
    function captureModuleLibs() {
        var obj = Human.modules.db.moduleLibs;
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    }

    /**
     * Bookmarks which modules are currently active
     */
    function captureActiveModules() {
        var modules = [];
        if (Human.modules.numActiveModules > 0) {
            var activeModules = Human.modules.activeModules;
            for (var moduleId in activeModules) {
                if (activeModules.hasOwnProperty(moduleId)) {
                    modules.push(moduleId);
                }
            }
        }
        return modules;
    }

    /**
     * Bookmarks current state of the camera
     * @return {Object}
     */
    function captureCamera() {
        return Human.view.camera.getLookAt();
    }

    /**
     * Bookmarks current view modes
     * @return {Object} Flag for each view mode, indicating whether or not its enabled
     */
    function captureViewModes() {
        return {
            dissect: Human.view.dissect.getEnabled(),
            highlight: Human.view.highlight.getEnabled(),
            isolate: Human.view.isolate.getEnabled(),
            labels: Human.view.labels.getEnabled(),
            xray: Human.view.xray.getEnabled(),
            singlePick: Human.view.pick.getSinglePickEnabled(),
            multiPick: Human.view.pick.getMultiPickEnabled()
        };
    }

    /**
     * Bookmarks current state of cross-section planes
     * @return {Object} Map containing state of each clip plane, mapped to the plane IDs
     */
    function captureCrossSections() {
        var clips = Human.view.clip.clips;
        var clip;
        var map = {};
        for (var clipId in clips) {
            if (clips.hasOwnProperty(clipId)) {
                clip = clips[clipId];
                map[clipId] = {
                    clipId: clip.clipId,
                    type: clip.type,
                    progress: clip.progress,
                    state: clip.state
                };
            }
        }
        return map;
    }

    /**
     * Bookmarks current visibility, selection and transparency states of scene objects
     * @return {Object} Map containing set of flags for each object
     */
    function captureObjectStates() {
        var map = {};
        var anatomy = Human.scene;
        var objects = anatomy.objects;
        var object;
        var enabledObjects = anatomy.enabledObjects;
        var selectedObjects = anatomy.selectedObjects;
        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                object = objects[objectId];
                if (object.objects.length === 0) { // Only restore leaf objects - let scene set states of their parents
                    map[objectId] = {
                        enabled: !!enabledObjects[objectId],
                        selected: !!selectedObjects[objectId]
                    };
                }
            }
        }
        return map;
    }

    /** Bookmarks current annotations
     * @return {Array} List containing a set of properties for each annotation
     */
    function captureAnnotations() {
        var list = [];
        var annotations = Human.view.annotations.annotations;
        var annotation;
        var item;
        for (var annotationId in annotations) {
            if (annotations.hasOwnProperty(annotationId)) {
                annotation = annotations[annotationId];
                if (annotation.saved) {
                    item = {
                        annotationId: annotationId,
                        title: annotation.label.title,
                        description: annotation.label.description,
                        pos: annotation.pin.pos,
                        pinVec: annotation.pin.dir,
                        shown: annotation.pin.shown,
                        labelShown: annotation.label.shown,
                        labelOffset: annotation.label.offset
                    };
                    if (annotation.object) {
                        item.objectId = annotation.object.objectId;
                    }
                    list.push(item);
                }
            }
        }
        return list;
    }


    /**
     * Restores engine state from a JSON bookmark object
     * <h4> Example:</h4>
     * <pre>
     *     Human.bookmarks.restore(bookmark,
     *          function() {
     *              // Success
     *          },
     *          function(errMsg) {
     *              // Error restoring bookmark
     *              alert(errMsg);
     *          });
     * </pre>
     * @memberof Human.bookmarks
     * @param {{}} index The JSON bookmark object
     * @param {Function} ok Success callback
     */
    HumanBookmarks.restore = function (index, ok, withoutHack) {

        ok = ok || function () {
        };

        Human.events.fire("bookmarks.restoring");

        var legacy;

        // HACK: Backwards bookmark compatibility
        if (!withoutHack) {
            // the widget can't afford 400+ web requests
            legacy = translateLegacy(index);
        }

        Human.view.annotations.clearAnnotations();

        // Don't needlessly update scene while loading
        //Human.renderer.pushPause();

        if (index.modules) {

            // Unload content
            var activeModules = index.modules.activeModules;
            if (activeModules) {
                deactivateModulesExcept(activeModules);
                activeModules = stripActiveModulesFrom(activeModules);
            }

            // Default view modes
            Human.rpc.call(null, "highlight.setEnabled", { enable: true });
            Human.rpc.call(null, "pick.single.setEnabled", { enable: true });

            // Default camera
            Human.view.camera.fly.jumpTo({
                up: { x: 0, y: 1, z: 0 },
                eye: { x: 0, y: 0, z: -100 },
                look: { x: 0, y: 0, z: 0 }
            });

            // Activate modules
            var moduleLibIds = index.modules.moduleLibs || [];
            restoreModuleLibs(moduleLibIds.slice(0),
                function () {
                    if (activeModules) {
                        restoreActiveModules(activeModules.slice(0),
                            function () {
                                restoreUserState(index, legacy);
                                //   Human.renderer.popPause();
                                Human.events.fire("bookmarks.restored", index);
                                ok();
                            });
                    } else {
                        restoreUserState(index, legacy);
                        //   Human.renderer.popPause();
                        Human.events.fire("bookmarks.restored", index);
                        ok();
                    }
                });

        } else {
            restoreUserState(index, legacy);
            //  Human.renderer.popPause();
            Human.events.fire("bookmarks.restored", index);
            ok();
        }
    };

    //
    // "params": {
    //      "stateId": "maleAdult/maleAdult"
    // },
    // "states": [
    //      { "stateId": "maleAdult/gingivitis" }
    // ]
    //
    function translateLegacy(index) {

        var legacy;

        if (index.params || index.states) {

            var activeModules = [];
            var male = false;
            var female = false;
            var stateId;

            if (index.params) {

                stateId = index.params.stateId;

                if (stateId === "maleAdult") {
                    stateId = "production/maleAdult/maleAdult.json";
                    male = true;

                } else if (stateId === "femaleAdult") {
                    stateId = "production/femaleAdult/femaleAdult.json";
                    female = true;
                }

                // what if this modules is already active?
                activeModules.push(stateId);

                legacy = true;
            }

            if (index.states) {

                for (var i = 0, len = index.states.length; i < len; i++) {

                    stateId = index.states[i].stateId;

                    if (stateId === "maleAdult") {
                        stateId = "production/maleAdult/maleAdult.json";
                        male = true;

                    } else if (stateId === "femaleAdult") {
                        stateId = "production/femaleAdult/femaleAdult.json";
                        female = true;

                    } else {
                        if (male) {
                            stateId = "production/maleAdult/" + stateId + ".json";

                        } else if (female) {
                            stateId = "production/femaleAdult/" + stateId + ".json";
                        }
                    }

                    // what if this module is already active?
                    activeModules.push(stateId);
                }

                legacy = true;
            }

            // FIXME: this block results in 400+ HTTP requests
            index.modules = {

                // Hopefully loading every module library we'll ever need
                moduleLibs: [
                    "anatomies.json",
                    "production.json"
                ],
                activeModules: activeModules
            };
        }

        return legacy;
    }


    // Deactivates currently-active modules not in the given map
    function deactivateModulesExcept(activeModules) {
        // Get modules to activate in map
        var toActivate = {};
        for (var i = 0, len = activeModules.length; i < len; i++) {
            toActivate[activeModules[i]] = true;
        }
        // Deactivate any modules we're not about to activate
        for (var moduleId in Human.modules.activeModules) {
            if (Human.modules.activeModules.hasOwnProperty(moduleId)) {
                if (!toActivate[moduleId]) {
                    Human.modules.deactivateModules({ moduleId: moduleId });
                }
            }
        }
    }

    function stripActiveModulesFrom(activeModules) {
// Get new list of modules to activate,
        // stripped of the modules that are already active
        var activeModules2 = [];
        var moduleId;
        for (var i = 0, len = activeModules.length; i < len; i++) {
            moduleId = activeModules[i];
            if (!Human.modules.activeModules[moduleId]) {
                activeModules2.push(moduleId);
            }
        }
        return activeModules2;
    }

    function restoreModuleLibs(libIds, ok) {
        Human.modules.db.loadModuleLibs(libIds, ok);
    }

    function restoreActiveModules(moduleIds, ok) {
        if (moduleIds.length > 0) {
            var moduleId = moduleIds.shift();
            if (!Human.modules.activeModules[moduleId]) {
                Human.modules.activateModules({ moduleId: moduleId },
                    function () {
                        restoreActiveModules(moduleIds, ok);
                    });
            } else {
                restoreActiveModules(moduleIds, ok);
            }
        } else {
            ok();
        }
    }

    function restoreUserState(index, legacy) {
        // jshint camelcase: false

        if (index.annotations) {
            restoreAnnotations(index.annotations, index.is_owner);
        }
        if (index.clips) {
            restoreCrossSections(index.clips);
        }
        if (index.objects) {
            restoreObjectStates(index.objects, legacy);
        }
        if (index.modes) {
            restoreModes(index.modes);
        }
        if (index.camera) {
            restoreCamera(index.camera);
        }
        if (index.timeline) {
            Human.timeline.setBookmark(index.timeline);
        } else {
            Human.timeline.stop();
        }
    }

    /**
     * Loads camera position as given in bookmark
     * @param camera
     */
    function restoreCamera(camera) {
        camera = camera || {};
        Human.view.camera.fly.jumpTo({
            up: Human._apply(camera.up, { x: 0, y: 1, z: 0 }),
            eye: Human._apply(camera.eye, { x: 0, y: 0, z: -100 }),
            look: Human._apply(camera.look, { x: 0, y: 0, z: 0 })
        });
    }

    /**
     * Loads viewing modes as given in bookmark
     * @param modes Flag for each view mode, indicating enable or disable
     */
    function restoreModes(modes) {
        // Activate view modes via commands because those
        // handle all the mutual exclusivity of the various modes
        if (modes.dissect !== undefined && modes.dissect !== null) {
            //   Human.rpc.call(null, "dissect.setEnabled", { enable: modes.dissect });
        }
        if (modes.highlight !== undefined && modes.highlight !== null) {
            Human.rpc.call(null, "highlight.setEnabled", { enable: modes.highlight });
        }
        // Only enable isolate if objects are selected
        if (Human.scene.anySelected() && modes.isolate) {
            if (modes.isolate !== undefined && modes.isolate !== null) {
                Human.rpc.call(null, "isolate.setEnabled", { enable: modes.isolate  });
            }
        } else {
            if (modes.isolate !== undefined && modes.isolate !== null) {
                Human.rpc.call(null, "isolate.setEnabled", { enable: false  });
            }
        }
        if (modes.labels !== undefined && modes.labels !== null) {
            Human.rpc.call(null, "labels.setEnabled", { enable: modes.labels });
        }
        if (modes.singlePick !== undefined && modes.singlePick !== null) {
            Human.rpc.call(null, "pick.single.setEnabled", { enable: modes.singlePick });
        }
        if (modes.multiPick !== undefined && modes.multiPick !== null) {
            Human.rpc.call(null, "pick.multi.setEnabled", { enable: modes.multiPick });
        }
        if (modes.xray !== undefined && modes.xray !== null) {
            Human.rpc.call(null, "xray.setEnabled", { enable: modes.xray });
        }
    }

    /**
     * Loads cross-section clip plane states as given in bookmark
     * @param clips Clip plane states, mapped to IDs of the planes
     */
    function restoreCrossSections(clips) {
        Human.view.clip.reset();
        for (var clipId in clips) {
            if (clips.hasOwnProperty(clipId)) {
                Human.view.clip.setClip(clips[clipId]);
            }
        }
    }

    /**
     * Loads states of scene objects as given in bookmark
     * @param objects
     * @param legacy
     */
    function restoreObjectStates(objects, legacy) {
        // We only need to restore those states that can be modified through
        // user interaction. The modules themselves will take care of the other
        // types of object states on module activation, and those state types
        // can't be subsequently modified by the user.
        restoreObjectVisibilities(objects, legacy);
        restoreObjectSelection(objects, legacy);
    }

    /**
     * Loads visibility states of scene objects as given in bookmark
     * @param objects
     * @param legacy Replaces set of visible objects when true
     */
    function restoreObjectVisibilities(objects, legacy) {
        Human.scene.setEnabledObjects({ objectIds: getObjectFlags(objects, "enabled"), replace: !legacy });
    }

    /**
     * Loads selection states of scene objects as given in bookmark
     * @param objects
     * @param legacy Replaces set of selected objects when true
     */
    function restoreObjectSelection(objects, legacy) {
        Human.scene.setSelectedObjects({ objectIds: getObjectFlags(objects, "selected"), replace: !legacy });
    }

    function getObjectFlags(objects, flagName) {
        var flags = {};
        var value;
        objects = objects || {};
        var object;
        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {
                object = Human.scene.objects[objectId];
                if (!object) {
                    // Objects in bookmark will not exist if they were
                    // skipped in the stream data, which is OK.
                    continue;
                }
                value = objects[objectId][flagName];
                if (value === true || value === false) {
                    flags[objectId] = value;
                }
            }
        }
        return flags;
    }

    /**
     * Loads annotations as given in bookmark
     * @param annotations List of property sets, one for each annotation
     */
    function restoreAnnotations(annotations, isOwner) {
        var a;
        
        isOwner = (typeof isOwner === 'undefined') ? false : isOwner;
        
        for (var i = 0, len = annotations.length; i < len; i++) {
            a = annotations[i];
            Human.view.annotations.createAnnotation({
                annotationId: a.annotationId,
                objectId: a.objectId,
                title: a.title || "",
                description: a.description || "",
                pos: a.offset || a.pos,
                dir: a.pinVec,
                shown: a.shown,
                type: a.type,
                labelShown: a.labelShown,
                labelOffset: a.labelOffset,
                saved: true,
                isOwner: isOwner
            });
        }
    }
})();;/**
 @namespace Accesses the bookmarks database, providing methods to save, load, delete and query bookmarks.
 */
(function () {
    //jshint camelcase: false

    "use strict";

    var HumanBookmarksDB = Human.bookmarks.db = {};

    var categories = {
        enterprise: {
            catalog: { path: "/ws/user/bookmark/enterprise" },
            bookmarks: { path: "/ws/user/bookmark/enterprise" }
        },
        featured: {
            catalog: { path: "/ws/user/bookmark/public", data: { featured: 1} },
            bookmarks: { path: "/ws/user/bookmark/public", data: { featured: 1} }
        },
        'private': {
            catalog: { path: "/ws/user/bookmark/private" },
            bookmarks: { path: "/ws/user/bookmark/private" }
        },
        'public': {
            catalog: { path: "/ws/user/bookmark/public" },
            bookmarks: { path: "/ws/user/bookmark/public" }
        },
        static_conditions: {
            catalog: { path: "/ws/user/bookmark/public", data: { static_conditions: 1} },
            bookmarks: { path: "/ws/user/bookmark/public", data: { static_conditions: 1} }
        },
        shared: {
            catalog: { path: "/ws/user/bookmark/shared" },
            bookmarks: { path: "/ws/user/bookmark/shared" }
        },

        // Bookmark data in the file system for testing purposes
        test: {
            catalog: { path: "content/testData/bookmarking/catalog.json" },
            bookmarks: { path: "content/testData/bookmarking/bookmarks" }
        }
    };

    /**
     * Gets array of supported bookmark category names
     *
     * @memberof Human.bookmarks.db
     * @return {Array(String)} Array of category names
     */
    HumanBookmarksDB.getCategories = function () {
        return Object.keys(categories);
    };

    /**
     * Restores a bookmark from the database
     *
     * <p>Fires a "bookmarks.db.loading" before beginning the load, followed by a "bookmarks.db.loaded" on success,
     * or a "bookmarks.db.loadFailed" on failure.</p>
     *
     * @memberof Human.bookmarks.db
     * @param {String} category The bookmark category
     * @param {String} id ID of the bookmark within the category
     * @param {Function} ok Success callback
     * @param {Function} error Error callback
     */
    HumanBookmarksDB.loadBookmark = function (category, id, ok, error) {
        var notification = {
            category: category,
            id: id
        };
        Human.events.fire("bookmarks.db.loading", notification);
        var _error = function (err) {
            if (error) {
                Human.events.fire("bookmarks.db.loadFailed", Human._apply({ error: err }, notification));
                error(err);
            }
        };
        HumanBookmarksDB.getBookmark(category, id,
            function (index) {
                Human.bookmarks.restore(index,
                    function (params) {
                        if (ok) {
                            Human.events.fire("bookmarks.db.loaded", notification);
                            ok(params);
                        }
                    },
                    _error);
            },
            _error);
    };

    /**
     * Fetches a bookmark from the database without restoring it.
     * <p>To restore, you would then pass it to {@link Human.bookmarks.restore}.</p>
     * <p>This method exists to support any massaging you might want to do to the bookmark JSON in between.</p>
     *
     * @memberof Human.bookmarks.db
     * @param {String} category The bookmark category
     * @param {String} id ID of the bookmark within the category
     * @param {Function} ok Success callback
     * @param {Function} error Error callback
     */
    HumanBookmarksDB.getBookmark = function (category, id, ok, error) {
        var cat = categories[category];
        if (!cat) {
            error("Unsupported bookmark category: " + category);
            return;
        }
        var data = {
            eid: id
        };
        // Small hack for using test data
        var url = category === "test" ? cat.bookmarks.path + "/" + id : cat.bookmarks.path;
        jQuery.ajax({
            dataType: "json",
            url: url,
            data: data,
            success: function (index) {
                ok(index);
            },
            error: error
        });
    };

    // Temp hack for easy testing in dev
    HumanBookmarksDB._testLoadBookmark = function (id) {
        jQuery.ajax({
            dataType: "json",
            url: "https://dev.biodigitalhuman.com/search/bookmarks/data",
            data: {
                b: id
            },
            success: function (index) {
                Human.bookmarks.restore(index.bookmark,
                    function () {
                        console.log("Done!");
                    });
            },
            error: function (e) {
                console.log(e);
            }
        });
    };


    /**
     * Captures a bookmark to the database
     *
     * @memberof Human.bookmarks.db
     * @param {String} category The bookmark category
     * @param {String} [id] ID of existing bookmark when replacing
     * @param {String} [name] Optional display name
     * @param {String} [description] Optional description text
     * @param {[String]} [tags] Optional meta tags
     * @param {Function} ok Success callback
     * @param {Function} error Error callback
     */
    HumanBookmarksDB.saveBookmark = function (category, id, name, description, tags, ok, error, complete) {
        var cat = categories[category];
        if (!cat) {
            error("Unsupported bookmark category: " + category);
            return;
        }
        var data = {
            name: name || "",
            description: description || "",
            tags: JSON.stringify(tags),
            index: JSON.stringify(Human.bookmarks.capture())
        };
        if (!!id) {
            data.eid = id;
        }
        jQuery.post(cat.bookmarks.path, data, ok).error(error).complete(complete);
    };

    /**
     * Deletes a bookmark from a given category in the database
     *
     * @memberof Human.bookmarks.db
     * @param {String} category The bookmark category
     * @param {String} id ID of the bookmark within the category
     * @param {Function} ok Success callback
     * @param {Function} error Error callback
     */
    HumanBookmarksDB.deleteBookmark = function (category, id, ok, error) {
        var cat = categories[category];
        if (!cat) {
            error("Unsupported bookmark category: " + category);
            return;
        }
        var data = {
            eid: id
        };
        jQuery.ajax({ url: cat.bookmarks.path, type: "DELETE", data: data, success: ok, error: error });
    };

    /**
     * Gets a directory of bookmarks of a given category with entries that match given tags
     * <pre>
     * Example parameters:
     *
     * {
    *    tags: ["disease", "heart"] // Optional, returns all states when omitted
    *    category: "public"
    * }
     *
     * Result:
     *
     * {
    *      public: {
    *          foo: {
    *              id: "foo",
    *              name: "Foo State",
    *              description: "The foo state"
    *          },
    *          bar: {
    *              id: "bar",
    *              name: "Bar State",
    *              description: "The bar state"
    *          },
    *          baz: {
    *              id: "baz",
    *              name: "Baz State",
    *              description: "The baz state"
    *          },
    *          ....
    *      }
    *  }
     * </pre>
     * @memberof Human.bookmarks.db
     * @param category The bookmark category
     * @param tags Optional metatags
     * @param ok Success
     * @param error Failed
     */
    HumanBookmarksDB.listBookmarks = function (category, tags, ok, error) {
        var cat = categories[category];
        if (!cat) {
            error("Unsupported bookmark category: '" +
                category + "' - supported values are " + JSON.stringify(HumanBookmarksDB.getCategories()));
            return;
        }
        var data = {
            tags: tags
        };
        jQuery.ajax({
            dataType: "json",
            url: cat.catalog.path,
            data: data,
            success: ok,
            error: error
        });
    };

    /**
     * Search DB for bookmark-states with names matching given term and with matching tags
     *
     * @memberof Human.bookmarks.db
     * @param term Optional term
     * @param tags Optional metatags
     * @param ok Success
     * @param error Failed
     *<pre>
     * Example:
     *
     * GET /ws/user/bookmark/search?tags=maleAnatomy,anatomy,male,adult&term=ske
     *
     * =>
     *
     * {
    *    "featured":{
    *    },
    *    "public":{
    *       "9y":{
    *          "description":null,
    *          "creation_datetime":"2012-01-03T11:41:47.242705",
    *          "id":"9y",
    *          "name":"this is a public skeleton from the back"
    *       },
    *       ...
    *       }
    *    },
     *    "private":{
    *    }
     * }
     *</pre>
     */
    HumanBookmarksDB.searchBookmarks = function (term, tags, ok, error) {
        var data = {
            term: term || "",
            tags: (tags || []).join(",")
        };
        jQuery.ajax({
            dataType: "json",
            url: "/ws/user/bookmark/search",
            data: data,
            success: ok,
            error: error
        });
    };

})();

;/**
 * @namespace Loads medline bookmarks
 */
(function () {
    "use strict";

    var HumanBookmarksMedline = Human.bookmarks.medline = {};

    /**
     * Loads a Medline bookmark.
     *
     * @param {string} bookmarkId Bookmark ID.
     * @param {function} ok Completion callback - errors are logged.
     */
    HumanBookmarksMedline.load = function (bookmarkId, ok) {

        // Need base anatomy module's ID for to prefix the bookmark's object IDs with
        var anatomyModule = findAnatomy();
        if (!anatomyModule || anatomyModule.modelIds.length === 0) {
            Human.log.error("Human.bookmarks.medline", "Failed to load medline bookmark - no base anatomy module is active");
            ok();
            return;
        }

        // Load bookmark index
        Human.bookmarks.db.getBookmark("public", bookmarkId,
            function (index) {

                // Prefix keys in object state map with module ID
                // Build list of objects to fly camera to, excluding skin

                var objects = {};
                var flyToObjects = [];
                var object;
                var globalObjectId;
                var skinObjectId = "Integumentary_System";
                var prefix = anatomyModule.modelIds[0]; // Assume only one model; the anatomy

                for (var objectId in index.objects) {
                    if (index.objects.hasOwnProperty(objectId)) {
                        if (objectId.indexOf("maleAdult") === -1 && objectId.indexOf("femaleAdult") === -1) {
                            object = index.objects[objectId];

                            // Prefix the object ID
                            globalObjectId = prefix + "-" + objectId;
                            objects[globalObjectId] = object;

                            // Build object list - visible and non-excluded objects
                            if (object.enabled && objectId.indexOf(skinObjectId, objectId.length - skinObjectId.length) === -1) {
                                flyToObjects.push(globalObjectId);
                            }
                        }
                    }
                }

                // Deactivate certain module types
                Human.modules.deactivateModules({ tags: ["condition", "expo", "bookmark", "tour"]  });

                // Restore the bookmark
                Human.bookmarks.restore({ // Don't modify index
                        objects: objects,
                        modes: index.modes
                    },
                    function () {

                        // Fly camera to object list
                        Human.view.camera.fly.flyTo({
                                objects: flyToObjects
                            },
                            function () {
                                if (ok) {
                                    ok();
                                }
                            });
                    });
            });
    };

    function findAnatomy() {
        var module;
        for (var moduleId in Human.modules.activeModules) {
            if (Human.modules.activeModules.hasOwnProperty(moduleId)) {
                module = Human.modules.activeModules[moduleId];
                if (module.tags.indexOf("base")) {
                    return module;
                }
            }
        }
        return null;
    }

})();;(function() {
    "use strict";

    
    /** Captures a bookmark of current Human state, returns it as JSON
     *
     */
    Human.rpc.define("bookmarks.capture",
        function () {
            this.setResult(Human.bookmarks.capture());
        });

    /** Restores Human state from given bookmark JSON
     */
    Human.rpc.define("bookmarks.restore",
        function (params) {
            var self = this;
            Human.bookmarks.restore(params, function () {
                self.setResult(true);
            });
        });

    /**
     * Restores a bookmark from the database, does not return the JSON.
     */
    Human.rpc.define("bookmarks.db.load",
        function (params) {
            var self = this;
            Human.bookmarks.db.loadBookmark(params.category, params.id,
                function () {
                    self.setResult(true);
                },
                function (error) {
                    self.error("Failed to load bookmark (category='" + params.category + "', id='" + params.id + "') : " + error);
                });
        });

    /**
     * Fetches a bookmark from the database, without restoring it on the engine.
     */
    Human.rpc.define("bookmarks.db.get",
        function (params) {
            var self = this;
            Human.bookmarks.db.getBookmark(params.category, params.id,
                function (bookmark) {
                    self.setResult(bookmark);
                },
                function (error) {
                    self.error("Failed to get bookmark (category='" + params.category + "', id='" + params.id + "') : " + error);
                });
        });

    /**
     * Captures Human's current state to a bookmark in the database.
     */
    Human.rpc.define("bookmarks.db.save",
        function (params) {
            var self = this;
            Human.bookmarks.db.saveBookmark(params.category, params.id, params.name, params.description, params.tags,
                function () {
                    self.setResult(true);
                },
                function (error) {
                    self.error("Failed to save bookmark (category='" + params.category + "', id='" + params.id + "') : " + error);
                });
        });

    /**
     * Deletes a bookmark from a given category in the database.
     */
    Human.rpc.define("bookmarks.db.delete",
        function (params) {
            var self = this;
            Human.bookmarks.db.deleteBookmark(params.category, params.id,
                function () {
                    self.setResult(true);
                },
                function (error) {
                    self.error("Failed to delete bookmark (category='" + params.category + "', id='" + params.id + "') : " + error);
                });
        });


    /**
     * Gets a directory of bookmarks of a given category with entries that match given tags
     */
    Human.rpc.define("bookmarks.db.list",
        function (params) {
            var self = this;
            Human.bookmarks.db.listBookmarks(params.category, params.tags,
                function (result) {
                    self.setResult(result);
                },
                function (error) {
                    self.error("Failed to list bookmarks (category='" + params.category + "') : " + error);
                });
        });

    /**
     * Search DB for bookmarks with names matching given term and with matching tags
     */
    Human.rpc.define("bookmarks.db.search",
        function (params) {
            var self = this;
            Human.bookmarks.db.searchBookmarks(params.term, params.tags,
                function (result) {
                    self.setResult(result);
                },
                function (error) {
                    self.error("Failed to search bookmarks (term='" + params.term + "') : " + error);
                });
        });
})();

;/**
 @namespace Handles module creation, activation, deactivation, destruction and query.

 <p>Modules are the engine's abstract unit of content. These are extensible and can be all sorts things, such as anatomies,
 disease conditions, guided tours, bookmarks, medline conditions etc.</p>
 */
(function () {
    "use strict";

    var HumanModules = Human.modules = {};

    // True once Human loaded
    var loaded;

    // Module IDs are internally generated from this pool
    var idPool = new Human.utils.IDPool();

    // Existing modules
    HumanModules.modules = {};

    // Supports query for modules by tag matches
    // This just stores records of module IDs and tags
    var queryTagMap = new Human.utils.TagMapList();

    // Currently active modules
    HumanModules.activeModules = {};
    HumanModules.numActiveModules = 0;

    // Queues module activations so they don't happen on top of each other
    var activationQueue = [];

    // moduleIds assoicated by Display Names
    HumanModules.namesToModuleIds = {};

    // Semaphore true when module is activating
    var moduleActivating = false;

    // Defines what happens when we activate modules: we want to ensure
    // that anatomy gender switching unloads everything, and that only
    // one condition is loaded at a time.
    var activationRules;
    Human.properties.subscribe({
        propId: "modules.activationRules",
        value: {

            // Modules tagged "base" replace any other module currently active
            base: {
                replacesAll: true
            },

            // Modules tagged "condition" replace modules with these tags:
            standalone: {
                replaces: ["standalone"]
            },

            // Modules tagged "condition" replace modules with these tags:
            condition: {
                replaces: ["condition", "expo", "bookmark", "medline", "tour"]
            },

            tour: {
                replaces: ["condition", "expo", "bookmark", "medline", "tour"]
            },

            bookmark: {
                replaces: ["condition", "expo", "bookmark", "medline"]
            },

            medline: {
                replaces: ["condition", "expo", "bookmark", "medline"]
            },

            expo: {
                replaces: ["expo"]
            }
        },
        callback: function (value) {
            activationRules = value;
        }
    });

    // Type plugins
    var types = {};

    /**
     Adds a module type.

     <p>These are simply type objects that we plug in to provide callbacks that will be used to
     activate and deactivate modules of some given type.</p>

     <p>When we then create a module with {@link Human.modules.createModule}, it will need to have a
     type matching one of the types we plugged in.</p>

     <p><b>Example:</b></p>
     <pre>
     Human.modules.addModuleType("foo",  {

       // Callback applied to "foo" modules to activate them
       activate:function (module, ok, error) {
            var moduleId = module.moduleId;
            var fooParam = module.fooParam;
            var barParam = module.barParam;
            //..
       },

       // Callback applied to "foo" modules to deactivate them
       deactivate:function (module) {
            var moduleId = module.moduleId;
            //..
       }
    });
     </pre>


     @memberof Human.modules
     @param {String} typeName Module type name
     @param {*} type Module type
     @param {Function} type.activate Activation method
     @param {Function} type.deactivate Deactivation method
     */
    HumanModules.addModuleType = function (typeName, type) {
        types[typeName] = type;
    };

    // Make sure we don't try to create, activate or deactivate
    // modules until Human has loaded
    Human.events.on("loaded",
        function () {
            loaded = true;
        });

    /**
     Creates a module.

     <p>With a module type installed with {@link Human.modules.addModuleType} we can create modules of that type
     like this:</p>

     <pre>
     Human.modules.createModule({
           type: "foo",
           moduleId: "myModule",
           displayName: "Example Module",
           description: "An example module",
           tags: ["alpha", "beta"],

           // Followed by type-specific properties
           fooParam: "foo",
           barParam: 6
      });
     </pre>

     <p>That just registers a module in memory. It doesn't actually load anything into the engine until
     you activate it with {@link Human.modules.activateModules}.</p>

     @memberof Human.modules
     @param params
     @param {String} params.type Module type, corresponding to a type added with {@link Human.modules.addModuleType}
     @param {String} [params.moduleId] Optional unique module ID, internally generated if omitted
     @param {[String]} [params.tags] Optional meta tags to classify the new module
     @param {String} [params.description] Optional module description text
     @param {String} [params.displayName] Optional module display name
     @return {String} Module ID
     */
    HumanModules.createModule = function (params) {
        // Type is mandatory
        if (!params.type) {
            Human.log.error("Human.modules.createModule", "Parameter expected: type");
            return;
        }
        var Type = types[params.type];
        if (!Type) {
            Human.log.error("Human.modules.createModel", "Unsupported module type: '" + params.type + "'");
            return;
        }
        //Human.log.info("Human.modules.createModule", "Creating module - type: " + params.type + ", displayName: " + params.displayName || "(unnamed)");
        var moduleId;
        // Create the module
        if (params.moduleId) {
            moduleId = params.moduleId;
            if (HumanModules.modules[moduleId]) {
                Human.log.warn("Human.modules.createModule", "Module already created, won't create again: + " + moduleId);
                return;
            }
        } else {
            moduleId = idPool.getId();
        }
        params.moduleId = moduleId;
        params.displayName = params.displayName || "";
        params.description = params.description || "";
        params.translations = params.translations;
        params.tags = params.tags || [];
        params.active = false;
        params.timeActivated = -1;

        var module = new Type(params);
        HumanModules.modules[moduleId] = module;

        queryTagMap.addItem(moduleId, params.tags || ["untagged"], module);
        // add name map
        HumanModules.namesToModuleIds[params.displayName] = HumanModules.namesToModuleIds[params.displayName] || [];
        HumanModules.namesToModuleIds[params.displayName].push(moduleId);

        Human.events.fire("modules.created", params);

        return moduleId;
    };

    /**
     Activates selected modules.

     <p>Once we've created some modules with {@link Human.modules.createModule}, we can then activate them. We can select
     which modules to activate either by IDs or meta tags.</p>
     <p><b>Activate a module by ID:</b></p>

     <pre>
     Human.modules.activateModules({ moduleId: "myModule" },
     function() {
        // Success
    },
     function (errMsg) {
        // Error
    });
     </pre>

     <p><b>Activate a list of modules by ID, synchronously in given order:</b></p>

     <pre>
     Human.modules.activateModules({ moduleIds: ["myModule", "myOtherModule"] },
     function() {
        // Success
    },
     function (errMsg) {
        // Error
    });
     </pre>

     <p><b>Activate first module found that has the given tags:</b></p>

     <pre>
     Human.modules.activateModules({ tags: ["alpha"] },
     function() {
        // Success
    },
     function (errMsg) {
        // Error
    });
     </pre>

     @memberof Human.modules
     @param {*} params
     @param {[String]} [params.tags] Module meta tags
     @param {String} [params.moduleId] Module ID
     @param {[String]} [params.moduleIds] Array of module IDs, to activate in sequence
     @param {Function} ok Completion callback - also called even on error, which will be logged
     */
    HumanModules.activateModules = function (params, ok) {

        if (!loaded) {
            Human.log.error("Human.modules.activateModules", "Human not loaded - modules can only be activated when Human loaded");
            if (ok) {
                ok();
            }
            return;
        }

        var temp = ok;
        ok = function () {
            if (temp) {
                temp();
            }
        };

        var options = params;

        if (params.moduleId) {

            // Activate a single module
            var moduleId = params.moduleId;
            if (!HumanModules.modules[moduleId]) {

                // Module not defined

                Human.log.info("Human.modules.activateModules", "Module not found: '" + moduleId + "' - attempting to load definition");

                // Load module definition
                Human.net.getModuleDefinition(
                    moduleId,
                    function (module) {

                        // Create module
                        module.type = module.type || "content";
                        module.moduleId = moduleId;
                        HumanModules.createModule(module);

                        // Activate module
                        activateModule(moduleId, options, ok);
                    },
                function(error) {
                    Human.log.info("Human.modules.activateModules", "Failed to activate module: '" + moduleId + "' - " + error);
                    ok();
                });
                return;
            }

            activateModule(moduleId, options, ok);

        } else if (params.moduleIds) {
            activateModules(params.moduleIds.slice(0), options, ok);

        } else if (params.tags) {

            // Activate modules whose tag sets contain all of the given tags
            activateFirstModuleWithTags(params.tags, options, ok);
        }
    };

    /**
     * Activates the module of the given ID
     *
     * Queues the request if another module is already in the process of activation
     *
     * @param moduleId
     * @param options
     * @param ok
     */
    function activateModule(moduleId, options, ok) {
        if (moduleActivating) {
            activationQueue.unshift({ moduleId: moduleId, options: options, ok: ok });
            return;
        }
        _activateModule(moduleId, options,
            function () {
                if (ok) {
                    ok();
                }
                nextActivation();
            });
    }

    function _activateModule(moduleId, options, ok) {
        var module = HumanModules.modules[moduleId];
        if (!module) {
            Human.log.error("Human.modules.activateModules", "Module not found: " + moduleId);
            ok();
            return;
        }
        //Human.processes.updateProcess({ processId: "activateModules", statusText: "Loading " + module.displayName || "" });

        // Deactivate other modules according to rules for this
        // module's classification tags
        deactivateOtherModules(module);

        // Activate the module
        moduleActivating = true;
        Human.events.fire("modules.activating", { moduleId: moduleId });

        // Create process
        // Lower-level procedures (ie. in Human.models etc) will find
        // this process by ID and update its progress.
        Human.processes.startProcess({ processId: "modules.activate", statusText: "Loading " + module.displayName });

        module.activate(options,
            function () {

                // Register active module
                module.active = true;
                module.timeActivated = (new Date()).getTime();
                HumanModules.activeModules[moduleId] = module;
                HumanModules.numActiveModules++;

                // Complete process
                Human.processes.finishProcess({ processId: "modules.activate" });

                Human.events.fire("modules.activated", { moduleId: moduleId, timeActivated: module.timeActivated });
                moduleActivating = false;
                ok();
            });
    }

    /**
     * Deactivate other modules according to the rules configured for this module's tags
     */
    function deactivateOtherModules(module) {
        // Get the rules for each of the module's tags
        var tags = module.tags;
        var tag;
        var rules;
        var replaces;
        var tagMap = {};
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            rules = activationRules[tag];
            if (rules) {
                if (rules.replaces) {
                    replaces = rules.replaces;
                    // Accumulate a map of the tags in the rules' "replace" lists
                    for (var j = 0, lenj = replaces.length; j < lenj; j++) {
                        tagMap[replaces[j]] = true;
                    }
                } else if (rules.replacesAll) {
                    // But as soon as a rule says "replaceAll", deactivate all the other modules and return.
                    deactivateModule();
                    return;
                }
            }
        }
        // Convert map to list
        var tagList = [];
        for (tag in tagMap) {
            if (tagMap.hasOwnProperty(tag)) {
                tagList.push(tag);
            }
        }
        // Deactivate all those replaceable modules.
        deactivateModulesWithTags({ tags: tagList, matching: "any" });
    }

    function nextActivation() {
        if (activationQueue.length > 0) {
            var activation = activationQueue.pop();
            _activateModule(activation.moduleId, activation.options,
                function () {
                    activation.ok();
                    nextActivation();
                });
        }
    }

    // Human.processes UI shows the progress bar length at the lowest progress percentage found among all processes,
    // in a (very) conservative guess of how much overall progress has been made across all processes.
    // When activating multiple modules, we'll run a process that updates as each activation completes.
    // On each activation, the process's progress will advance by an percentage equal to 100 divided by the
    // number of processes. This will cause the overall process progress percentage to march forwards
    // at each one process completion. If there are 4 modules, then the progress increment will be 25% at
    // each completion. As module 1 completes, progress is 25%. As module 2 completes, progress is 50%, and so on.

    function activateModules(moduleIds, options, ok) {
        //Human.processes.startProcess({ processId: "activateModules", scaleProgress: 1 / moduleIds.length, statusText: "Loading" });
        _activateModules(moduleIds.slice(0), moduleIds.length, options, function () {
            //Human.processes.finishProcess({ processId: "activateModules" });
            ok();
        });
    }

//    // Fires callback as soon as current task count is zero
//    function onTasksComplete(ok) {
//        var numTasks = Human.renderer.getScene().getStatus().numTasks;
//        if (!numTasks || numTasks == 0) {
//            ok();
//            return;
//        }
//        var p = setInterval(
//            function () {
//                var numTasks = Human.renderer.getScene().getStatus().numTasks;
//                if (!numTasks || numTasks == 0) {
//                    clearInterval(p);
//                    ok();
//                }
//            }, 200);
//    }


    function _activateModules(moduleIds, numModules, options, ok) {
        if (moduleIds.length === 0) {
            ok();
            return;
        }
        var moduleId = moduleIds.shift();
        activateModule(moduleId, options,
            function () {
                if (moduleIds.length > 0) {
                    //Human.processes.updateProcess({ processId: "activateModules", scaleProgress: (1 / numModules) * (numModules - moduleIds.length + 1) });
                }
                _activateModules(moduleIds, numModules, options, ok);
            });
    }

    /**
     * Activates the first module found with tags that contain the given set
     *
     * @param {[String]} tags Tags to match on
     * @params {Object} options
     * @param {Function} ok Success callback
     * @param {Function} error Error callback
     */
    function activateFirstModuleWithTags(tags, options, ok) {
        var modules = queryTagMap.findItems({ matching: "atLeast", tags: tags });
        for (var i = 0, len = modules.length; i < len; i++) {
            activateModule(modules[i].moduleId, options, ok);
            return;
        }
        Human.log.warn("Human.modules.activateModules", "Failed to activate module - no module found with these tags: " + JSON.stringify(tags));
        ok();
    }


    /**
     Deactivates selected modules.

     <p>If we've previously activated some modules with {@link Human.modules.activateModules}, we can deactivate them again. We can
     select which modules to deactivate either by IDs or meta tags. We can also just indiscriminately deactivate all modules.</p>

     <p><b>Deactivate a module by ID:</b></p>
     <pre>
     Human.modules.deactivateModules({ moduleId: "myModule" });
     </pre>

     <p><b>Deactivate a list of modules by ID:</b></p>
     <pre>
     Human.modules.deactivateModules({ moduleIds: ["myModule", "myOtherModule"] });
     </pre>

     <p><b>Deactivate first module found that has the given tags:</b></p>
     <pre>
     Human.modules.deactivateModules({ tags: ["alpha"] });
     </pre>

     <p><b>Deactivate all modules:</b></p>
     <pre>
     Human.modules.deactivateModules();
     </pre>


     @memberof Human.modules
     @param {*} params
     @param {[String]} [params.tags] Tags of modules to deactivate
     @param {String} [params.moduleId] Module to NOT deactivate
     */
    HumanModules.deactivateModules = function (params) {
        params = params || {};

        if (params.tags) {

            // Deactivate modules matching given tags
            deactivateModulesWithTags(params);
        } else if (params.moduleId) {

            // Deactivate a given module
            deactivateModule(params.moduleId);
        } else {

            // Deactivate all modules
            deactivateModule();
        }

        Human.renderer.forceRenderFrame(); // Force SceneJS garbage collection, for efficiency
    };

    /**
     * Deactivates modules whose tag set contains the given tags
     */
    function deactivateModulesWithTags(params) {
        var modules = queryTagMap.findItems({ matching: params.matching || "atLeast", tags: params.tags});
        for (var i = 0, len = modules.length; i < len; i++) {
            deactivateModule(modules[i].moduleId);
        }
    }

    /**
     * Deactivates the module with the given ID
     * @param moduleId
     */
    function deactivateModule(moduleId) {
        if (moduleActivating) {
            return;
        }
        if (!moduleId) {
            // Deactivate all modules if none specified
            for (moduleId in HumanModules.modules) {
                if (HumanModules.modules.hasOwnProperty(moduleId) && HumanModules.activeModules[moduleId]) {
                    deactivateModule(moduleId);
                }
            }
            return;
        }
        var module = HumanModules.activeModules[moduleId];
        if (!module) { // Module is not active
            return;
        }
        Human.events.fire("modules.deactivating", { moduleId: moduleId });
        module.deactivate(module);
        module.active = false;
        module.timeActivated = -1;
        delete HumanModules.activeModules[moduleId];
        HumanModules.numActiveModules--;
        Human.events.fire("modules.deactivated", moduleId);
    }

    /**
     Destroys selected modules.

     <p>If we've previously created some modules with {@link Human.modules.createModule}, we can destroy them again. We can
     select which modules to destroy either by IDs or meta tags. We can also just indiscriminately destroy all modules.</p>
     <p>Note that destroying a module will implicitly deactivate it first.</p>

     <p><b>Destroy a module by ID:</b></p>
     <pre>
     Human.modules.destroyModules({ moduleId: "myModule" });
     </pre>

     <p><b>Destroy a list of modules by ID:</b></p>
     <pre>
     Human.modules.destroyModules({ moduleIds: ["myModule", "myOtherModule"] });
     </pre>

     <p><b>Destroy first module found that has the given tags:</b></p>
     <pre>
     Human.modules.destroyModules({ tags: ["alpha"] });
     </pre>

     <p><b>Destroy all modules:</b></p>
     <pre>
     Human.modules.destroyModules();
     </pre>


     @memberof Human.modules
     @param {*} params
     @param {[String]} [params.tags] Module meta tags
     @param {String} [params.moduleId] Module ID
     */
    HumanModules.destroyModules = function (params) {
        if (params.tags) {
            destroyModulesWithTags(params.tags);
        } else {
            destroyModule(params.moduleId);
        }
    };

    /**
     * Destroys modules whose tag set contains the given tags
     * @param tags
     */
    function destroyModulesWithTags(tags) {
        var modules = queryTagMap.findItems({ matching: "atLeast", tags: tags });
        for (var i = 0, len = modules.length; i < len; i++) {
            destroyModule(modules[i].moduleId);
        }
    }

    /**
     * Destroys the module with the given ID
     * @param moduleId
     */
    function destroyModule(moduleId) {
        if (moduleId) {
            // Destroy the specified module
            var module = HumanModules.modules[moduleId];
            if (!module) {
                Human.log.warn("Human.modules.destroyModules", "Failed to destroy module - module not found: + " + moduleId);
                return;
            }
            deactivateModule(moduleId);
            delete HumanModules.modules[moduleId];
            queryTagMap.removeItem(moduleId);
            // remove named entry
            if (HumanModules.namesToModuleIds.hasOwnProperty(module.displayName)) {
                var moduleIdIndex = HumanModules.namesToModuleIds[module.displayName].indexOf(moduleId);
                if (moduleIdIndex) {
                    HumanModules.namesToModuleIds[module.displayName].splice(moduleIdIndex, 1);
                }
            }
            idPool.putId(moduleId);
            Human.events.fire("modules.destroyed", moduleId);
            return;
        }
        // Destroy all modules
        for (moduleId in HumanModules.modules) {
            if (HumanModules.modules.hasOwnProperty(moduleId)) {
                destroyModule(moduleId);
            }
        }
    }

    /**
     Queries metadata on selected modules.

     <p>If we have some modules created, we can query what they are. We can select which modules to query either by IDs or
     meta tags. We can also just indiscriminately query all modules.</p>
     <p><b>Query modules matching tags:</b></p>
     <pre>
     var list = query({
       matching: "atLeast" | "any" | "most",
       tags: ["foo", "bar", "baz"]
 });
     </pre>

     Result:
     <pre>
     [
     {
         "moduleId": "foo",
         "displayName": "name1",
         "description": "bar",
         "tags": ["baz", "qux"]
     },
     {
         "moduleId": "foo2",
         "displayName": "name2",
         "description": "bar2",
         "tags": ["baz2", "qux2"]
     }
     //..
     ]
     </pre>

     <p><b>Query all modules:</b></p>
     <pre>
     var list = query();
     </pre>

     @param {{}} params Query params
     @param {[String]} params.tags Meta tags to match on
     @memberof Human.modules
     */
    HumanModules.query = function (params) {
        var module, moduleId, list;

        if (params) {
            if (params.tags) {
                // Query modules matching tags
                return queryTagMap.findItems(params);
            }
            if (params.moduleId) {
                // Query a specific module
                module = HumanModules.modules[params.moduleId];
                return module ? [module.module] : [];
            }
            if (params.names) {
                var modules = [];
                // for each name get assoicated modules
                for (var i in params.names) {
                    if (params.names.hasOwnProperty(i)) {
                        var name = params.names[i];
                        if (HumanModules.namesToModuleIds.hasOwnProperty(name)) {
                            var moduleIds = HumanModules.namesToModuleIds[name];
                            for (var j in moduleIds) {
                                if (moduleIds.hasOwnProperty(j)) {
                                    moduleId = moduleIds[j];
                                    if (HumanModules.modules.hasOwnProperty(moduleId)) {
                                        module = HumanModules.modules[moduleId];
                                        modules.push({
                                            moduleId: moduleId,
                                            type: module.type,
                                            displayName: module.displayName,
                                            description: module.description,
                                            translations: module.translations,
                                            tags: module.tags,
                                            animation: module.animation,
                                            active: module.active,
                                            timeActivated: module.timeActivated
                                        });
                                    } 
                                }
                            }
                        }
                    }
                    
                }
                return modules;
            }
            if (params.active) {
                // Query active modules
                list = [];
                for (moduleId in HumanModules.activeModules) {
                    if (HumanModules.activeModules.hasOwnProperty(moduleId)) {
                        module = HumanModules.activeModules[moduleId];
                        list.push({
                            moduleId: moduleId,
                            type: module.type,
                            displayName: module.displayName,
                            description: module.description,
                            translations: module.translations,
                            tags: module.tags,
                            animation: module.animation,
                            active: module.active,
                            timeActivated: module.timeActivated
                        });
                    }
                }
                return list;
            }
        }
        // Query all modules
        list = [];
        for (moduleId in HumanModules.modules) {
            if (HumanModules.modules.hasOwnProperty(moduleId)) {
                module = HumanModules.modules[moduleId];
                list.push({
                    moduleId: moduleId,
                    type: module.type,
                    displayName: module.displayName,
                    description: module.description,
                    translations: module.translations,
                    tags: module.tags,
                    animation: module.animation,
                    active: module.active,
                    timeActivated: module.timeActivated
                });
            }
        }
        return list;
    };

})();;/**
 * @namespace Loads libraries of content modules (anatomy, conditions, tours etc).
 *
 * <h3>Loading content module libraries</h3>
 * <pre>
 * Human.modules.db.loadModuleLibs(["anatomies.json", "cancers.json"],
 *      function() {
 *          // Loaded!
 *          Human.modules.activateModule("maleAnatomy");
 *          Human.modules.activateModule("lungCancer");
 *      },
 *      function(errMsg) {
 *          alert(errMsg);
 *      });
 * </pre>
 * <br>
 * <h3>Unloading content module libraries</h3>
 * <pre>
 * Human.modules.db.destroyModuleLib("maleAnatomy.json");
 * Human.modules.db.destroyModuleLib("cancers.json");
 *
 * </pre>
 */
(function () {
    "use strict";

    var HumanModulesDB = Human.modules.db = {};

    HumanModulesDB.moduleLibs = {};

    HumanModulesDB.loadModuleDbs = function(dbIds, ok) {
        // ? any particular reason to not use a for loop? async/blocking issues?
        ok = ok || Human._noop;
        if (dbIds.length === 0) {
            ok();
            return;
        }
        loadModuleDbs(dbIds.slice(0), ok);
    };

    function loadModuleDbs(dbIds, ok) {
        if (dbIds.length > 0) {
            var moduleDbId = dbIds.shift();
            HumanModulesDB.loadModuleDb(moduleDbId,
                function () {
                    loadModuleDbs(dbIds, ok);
                });
        } else {
            ok();
        }
    }

    HumanModulesDB.loadModuleDb = function(dbId, ok) {
        ok = ok || Human._noop;
        Human.log.info("Human.modules.db.loadModuleDb", "Loading module db: " + dbId + "...");
        // dbs should have the same name as libs, but with a different path
        if (HumanModulesDB.moduleLibs[dbId]) {
            // Already loaded
            Human.log.warn("Human.modules.db.loadModuleDb", "Module db already loaded - won't reload: " + dbId + "...");
            ok();
            return;
        }
        Human.net.getModuleDb(dbId,
            // a manifestDb inlines all the module jsons
            function (manifestDb) {
                if (!manifestDb.modules || manifestDb.modules.length === 0) {
                    ok();
                    return;
                }
                var moduleNames = [];
                for (var i = 0; i < manifestDb.modules.length; i++) {
                    var moduleEntry = manifestDb.modules[i];
                    var moduleId = moduleEntry.id;
                    var module = moduleEntry.module;
                    module.type = module.type || "content";
                    module.moduleId = moduleId;
                    Human.modules.createModule(module);
                    moduleNames.push(moduleId);
                }
                HumanModulesDB.moduleLibs[dbId] = moduleNames;
                ok();
            },
            function (errMsg) {
                Human.log.error("Human.modules.db.loadModuleDb", "Failed to load module db '" + dbId + "': " + errMsg);
                ok();
            });
    };

    /**
     * Loads a list of content module libraries.
     * This method will just log failed loads and will always call the success callback.
     * @param {[String]} libIds Module library IDs
     * @param {Function} ok Completion callback
     * @memberof Human.modules.db
     */
    HumanModulesDB.loadModuleLibs = function (libIds, ok) {
        ok = ok || Human._noop;
        if (libIds.length === 0) {
            ok();
            return;
        }
        loadModuleLibs(libIds.slice(0), ok);
    };

    // Loads models in synchronous sequence. Each model may have things like
    // animations that reference objects loaded by the models preceeding it.
    function loadModuleLibs(libIds, ok) {
        if (libIds.length > 0) {
            var moduleLibId = libIds.shift();
            HumanModulesDB.loadModuleLib(moduleLibId,
                function () {
                    loadModuleLibs(libIds, ok);
                },
                function (errMsg) {
                    Human.log.error("Human.modules.db.loadModuleLibs", "Failed to load module lib '" + moduleLibId + "': " + errMsg);
                    loadModuleLibs(libIds, ok);
                });
        } else {
            ok();
        }
    }

    /**
     * Loads a library of content modules
     * @param {String} libId Module library ID
     * @param {Function} ok Success callback
     * @param {Function} error Error callback
     * @memberof Human.modules.db
     */
    HumanModulesDB.loadModuleLib = function (libId, ok) {
        ok = ok || Human._noop;
        Human.log.info("Human.modules.db.loadModuleLib", "Loading module library: " + libId + "...");
        if (HumanModulesDB.moduleLibs[libId]) {
            // Already loaded
            Human.log.warn("Human.modules.db.loadModuleLib", "Module library already loaded - won't reload: " + libId + "...");
            ok();
            return;
        }
        Human.net.getModuleManifest(libId,
            function (manifest) {
                if (!manifest.modules || manifest.modules.length === 0) {
                    ok();
                    return;
                }
                HumanModulesDB.loadModuleDefinitions(
                    libId,
                    manifest.modules.slice(0),
                    function () {
                        HumanModulesDB.moduleLibs[libId] = manifest.modules;
                        ok();
                    });
            },
            function (errMsg) {
                Human.log.error("Human.modules.db.loadModuleLib", "Failed to load module library manifest: " + libId + "': " + errMsg);
                ok();
            });
    };

    HumanModulesDB.loadModuleDefinitions = function (libId, moduleIds, ok) {
        ok = ok || Human._noop;
        if (moduleIds.length === 0) {
            ok();
        } else {
            var moduleId = moduleIds.shift();
            Human.log.info("Human.modules.db.loadModuleLib", "Loading module definition: " + moduleId + "...");
            Human.net.getModuleDefinition(
                moduleId,
                function (module) {
                    module.type = module.type || "content";
                    module.moduleId = moduleId;
                    Human.modules.createModule(module);
                    HumanModulesDB.loadModuleDefinitions(libId, moduleIds, ok);
                },
                function (errMsg) {
                    Human.log.error("Human.modules.db.loadModuleLib", "Failed to load module definition: " + moduleId + "':" + errMsg);
                    HumanModulesDB.loadModuleDefinitions(libId, moduleIds, ok);
                });
        }
    };

    /**
     * Unloads a library of content modules
     * @param {String} libId Module library ID
     * @memberof Human.modules.db
     */
    HumanModulesDB.destroyModuleLib = function (libId) {
        var lib = HumanModulesDB.moduleLibs[libId];
        if (!lib) {
            return;
        }
        var modules = lib.modules;
        for (var i = 0, len = modules.length; i < len; i++) {
            Human.modules.destroyModulesModule(modules[i]);
        }
        delete HumanModulesDB.moduleLibs[libId];
    };

})();;/**
 * @namespace Gender-related functionality for modules
 */
(function () {
    "use strict";

    var HumanModulesGender = Human.modules.gender = {};

    // Which tags identify modules as being male/female anatomy
    var maleTags = [];
    var femaleTags = [];

    Human.properties.subscribe({
        propId: "modules.genderTags",
        value: {
            male: ["anatomy", "male", "base"],
            female: ["anatomy", "female", "base"]
        },
        callback: function (value) {
            maleTags = value.male || [];
            femaleTags = value.female || [];
        }
    });

    Human.events.on("modules.activating",
        function (params) {
            var moduleId = params.moduleId;
            var module = Human.modules.modules[moduleId];
            if (hasTags(module.tags, maleTags)) {
                notifyGenderActivating(moduleId, "male");
            } else if (hasTags(module.tags, femaleTags)) {
                notifyGenderActivating(moduleId, "female");
            }
        });

    function hasTags(tags, tagsNeeded) {
        var numFound = 0;
        var numNeeded = tagsNeeded.length;
        var tag;
        for (var i = 0, len = tags.length; i < len; i++) {
            tag = tags[i];
            for (var j = 0, lenj = tagsNeeded.length; j < lenj; j++) {
                if (tag === tagsNeeded[j]) {
                    if (++numFound === numNeeded) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    function notifyGenderActivating(moduleId, gender) {
        //     Human.log.info("Human.modules.gender", "Activating module for gender: '" + gender + "'");
        Human.events.fire("modules.gender.activating", { moduleId: moduleId, gender: gender });
    }

    Human.events.on("modules.activated",
        function (params) {
            var moduleId = params.moduleId;
            var module = Human.modules.modules[moduleId];
            if (hasTags(module.tags, maleTags)) {
                notifyGenderActivated(moduleId, "male");
            } else if (hasTags(module.tags, femaleTags)) {
                notifyGenderActivated(moduleId, "female");
            }
        });

    function notifyGenderActivated(moduleId, gender) {
        //   Human.log.info("Human.modules.gender", "Activated module for gender: '" + gender + "'");
        Human.events.fire("modules.gender.activated", { moduleId: moduleId, gender: gender });
    }

    /**
     * Loads an anatomy module for the given gender.
     *
     * <p>Recognised genders are 'male' and 'female'.</p>
     * <p>This method will save the selected gender to a cookie once the module has loaded.</p>
     *
     * <p>To load male gender, for example:</p>
     * <pre>
     *     Human.modules.gender.selectGender("male", function () { alert("Cool, loaded."); });
     * </pre>
     *
     * <p>After the module is loaded, a "gender" cookie with value "male" will be saved to the
     * document. Then, perhaps a couple of days later, you can load the app and call this method with a
     * null value for the gender:</p>
     * <pre>
     *     Human.modules.gender.selectGender(null, function () { alert("Cool, loaded."); });
     * </pre>
     *
     * <p>Then the saved cookie will be read from the document, and the module for the "male" will be loaded.</p>
     *
     * <p>You can then select a different gender:</p>
     *
     * <pre>
     *     Human.modules.gender.selectGender(null, function () { alert("Cool, loaded."); });
     * </pre>
     *
     * <p>which loads that gender and saves "female" to the cookie, so that gender will be loaded next time
     * you pass in null for the gender.</p>
     *
     * @memberof Human.cookies
     * @param {String} gender Selected gender - "male", "female" or null
     * @param {Function} [ok] Callback fired on completion - see log for errors
     */
    HumanModulesGender.selectGender = function (gender, ok) {
        if (maleTags.length === 0 || femaleTags.length === 0) {
            Human.log.error("Human.modules.selectGender", "No tags configured to identify male/female gender modules");
            if (ok) {
                ok();
            }
            return;
        }
        if (gender !== undefined && gender !== null && gender !== "male" && gender !== "female") {
            Human.log.error("Human.modules.gender.selectGender",
                "Unsupported value for 'gender' - supported values are 'male' and 'female'");
            ok();
            return;
        }
        if (!gender) {
            gender = Human.cookies.getCookie("gender") || "male";
        }
        Human.modules.activateModules({ tags: gender === "male" ? maleTags : femaleTags },
            function () {
                Human.cookies.setCookie("gender", gender);
                ok();
            });
    };

})();;/**
 * @namespace A module manager that deactivates modules that have the "standalone" tag whenever an object is shown that belongs to a module that does not have that tag.
 *
 * <p>Typical use case:</p>
 *
 * <ol>
 *      <li>loaded anatomy module,</li<
 *      <li>loaded condition module of beating heart, tagged "standalone", which hides the anatomy heart</li>
 *      <li>show heart in anatomy module</li>
 *      <li>deactivate the condition module, whose heart would now otherwise be visually overlapping the now-visible anatomy heart.</li>
 * <ol>
 */
(function () {
    "use strict";

    // Whether or not the standalone behaviour is enabled
    // eg. we would disable it while a bookmark is loading
    var enabled = true;

    // Track modules that are currently active that do not have the "standalone" tag. These vars simply cache
    // some info in order to help reduce the work done by this manager when reacting to objects being shown.

    var standaloneModules = {};
    var nonStandaloneModules = {};
    var numStandaloneModules = 0;

    // Disable standalone behaviour while modules are activating
    // Prevents module's setting of initial object visibilities from unloading any modules

    Human.events.on("modules.activating",
        function () {
            enabled = false;
        });

    Human.events.on("modules.activated",
        function (params) {
            var moduleId = params.moduleId;
            var module = Human.modules.modules[moduleId];
            var tags = module.tags;
            for (var i = 0, len = tags.length; i < len; i++) {
                if (tags[i] === "standalone") {
                    standaloneModules[moduleId] = module;
                    numStandaloneModules++;
                    enabled = true;
                    return;
                }
            }
            nonStandaloneModules[moduleId] = module;
            enabled = true;
        });

    Human.events.on("modules.deactivated",
        function (moduleId) {
            if (standaloneModules[moduleId]) {
                delete standaloneModules[moduleId];
                numStandaloneModules--;
            } else {
                delete nonStandaloneModules[moduleId];
            }
        });

    // Disable standalone behaviour while bookmark loading

    Human.events.on("bookmarks.restoring",
        function () {
            enabled = false;
        });

    Human.events.on("bookmarks.restored",
        function () {
            enabled = true;
        });

    // Disable standalone behaviour while timeline chapter activating

    Human.events.on("timeline.chapters.activating",
        function () {
            enabled = false;
        });

    Human.events.on("timeline.chapters.activated",
        function () {
            enabled = true;
        });

    // When an object is shown that belongs to a module that is not tagged "standalone",
    // then deactivate any currently active modules that have that tag.

    Human.events.on("scene.objectsShown",
        function (params) {
            if (!enabled) {
                // Unless standalone behaviour is currently disabled
                return;
            }
            if (Human.modules.numActiveModules > 0) {
                var object;
                var module;
                var enabledObjectsUpdate = params.enabledObjectsUpdate;
                for (var objectId in enabledObjectsUpdate) {
                    if (enabledObjectsUpdate[objectId] === true) {
                        object = Human.scene.objects[objectId];
                        module = nonStandaloneModules[object.moduleId];
                        if (module && numStandaloneModules > 0) {
                            Human.log.info("Human.modules.standalone", "Module " + object.moduleId + " object focused: " + params.objectId + " - deactivating all standalone modules");
                            Human.modules.deactivateModules({ tags: ["standalone"] });
                            return;
                        }
                    }
                }
            }
        });
})();;(function () {
    "use strict";

    var Content = function (cfg) {

        // Metadata

        this.moduleId = cfg.moduleId;
        this.displayName = cfg.displayName || "";
        this.description = cfg.description || "";
        this.translations = cfg.translations || {};
        this.tags = cfg.tags || [];
        this.active = false;

        // Flags for hacking around content bugs

        this.hacks = cfg.hacks;

        // Specific to this module type

        this.animation = cfg.animation;
        this.camera = cfg.camera;
        this.jumpTo = cfg.jumpTo;
        this.flyTo = cfg.flyTo;
        var p = cfg.modelIds || cfg.stateId;
        this.modelIds = p ? (Human._isArray(p) ? p : [p]) : [];
        this.showObjects = cfg.showObjects;
        this.selectObjects = cfg.selectObjects;
        this.pickThroughObjects = cfg.pickThroughObjects;
        this.transparentObjects = cfg.transparentObjects;
        this.desaturatedObjects = cfg.desaturatedObjects;
        this.backfaceObjects = cfg.backfaceObjects;
        this.objectGlassFactors = cfg.objectGlassFactors;
        this.objectOpacities = cfg.objectOpacities;
        this.animation = cfg.animation;
        this.xray = cfg.xray;
        this.annotations = cfg.annotations;
        this.annotationsLayout = cfg.annotationsLayout;
        this.environment = cfg.environment;
        this.chapterCameraPath = !!cfg.chapterCameraPath;
        this.effects = cfg.effects;
        this.properties = cfg.properties;
        this.reflections = cfg.reflections;

        this.swapped = false;
        this.swappedObjectId = null;

        // Remembers what to restore when module deactivates

        this.restoreReflections = null;
        this.restoreProperties = null;
        this.restoreEffects = null;
        this.restorePickThroughObjects = null;
        this.restoreObjectGlassFactors = null;
        this.restoreObjectOpacities = null;
        this.restoreCamera = null;

    };

    /**
     Activates this module.

     @param {Object} options Activation options
     @param {Boolean} options.swap When true, will activate module in "swap" mode
     @param ok
     */
    Content.prototype.activate = function (options, ok) {

        // Load models, then load app states like camera, viewing modes, cross-sections
        // and scene object visibility/selection/transparency.
        // Models are loaded synchronously in strict sequence because each model may have
        // things like animations that reference objects loaded by the models preceeding it.

        var self = this;

        // In "swap" mode we're swapping a scene object for a module. In this mode, the module
        // is constrained so that as it activates, it's not able to change the state of objects
        // that are already in the scene, nor is able to update the camera.

        // The swap effect requires that we don't change the viewpoint or destroy structures
        // that are not being swapped out.

        // A module in "swap' mode can however set view modes, engine properties, activate post-effects,
        // create light sources, etc.

        // A swapped module optionally remembers the object it was swapped for, so that it can
        // restore the visibility of that object when deactivated.

        var swap = !!options.swap;

        this.swapped = swap;

        if (swap) {
            this.swappedObjectId = options.objectId;
        }

        // HACK: Face winding bug hacks
        // Remove when condition meshes with face winding bug are re-exported

        if (self.hacks) {
            Human.properties.set({ "hacks.neverBackfaces": !!self.hacks.neverBackfaces });
            Human.properties.set({ "hacks.alwaysBackfaces": !!self.hacks.alwaysBackfaces });
        }

        if (this.reflections) {
            this.restoreReflections = Human.assets.reflections.active;
            Human.assets.reflections.activateReflections(this.reflections);
        }

        Human.view.annotations.clearAnnotations();

        this._loadModels(
            this.modelIds.slice(0),
            function () {
                var vals, object, objectId;

                // HACK:
                Human.properties.set({ "hacks.neverBackfaces": false });
                Human.properties.set({ "hacks.alwaysBackfaces": false });

                if (self.properties) {
                    self.restoreProperties = saveProperties(self.properties);
                    Human.properties.set(self.properties);
                }

                if (self.effects) {
                    self.restoreEffects = saveEffects();
                    Human.view.effects.clearEnabled();
                    Human.view.effects.setEnabled({ effectIds: self.effects });
                }

                if (self.showObjects) {

                    // Set scene object visibilities

                    Human.scene.setEnabledObjects({
                        objectIds: self._parseObjectIds(self.showObjects, swap),
                        replace: options.swap !== true // Replace the set of visible scene objects only if not swapping
                    });
                }

                if (self.selectObjects) {

                    // Set the set of selected scene objects

                    Human.scene.setSelectedObjects({
                        objects: self._parseObjectIds(self.selectObjects, swap),
                        replace: options.swap !== true // Replace the set of selected scene objects only if not swapping
                    });
                }

                if (self.pickThroughObjects) {

                    // Save previous pickable state of each object we'll set (un)pickable

                    self.restorePickThroughObjects = {};
                    vals = self._parseObjectIds(self.pickThroughObjects, swap);
                    for (objectId in vals) {
                        if (vals.hasOwnProperty(objectId)) {
                            object = Human.scene.objects[objectId];
                            if (object) {
                                self.restorePickThroughObjects[objectId] = object.pickable;
                            }
                        }
                    }
                    Human.scene.setPickThroughObjects({
                        objectIds: vals,
                        replace: false // Normally just want to make some object unpickable
                    });
                }

                if (self.transparentObjects) {
                    Human.scene.setTransparentObjects({
                        objectIds: self._parseObjectIds(self.transparentObjects, swap)
                    });
                }

                if (self.desaturatedObjects) {
                    Human.scene.setDesaturatedObjects({
                        objectIds: self._parseObjectIds(self.desaturatedObjects, swap)
                    });
                }

                if (self.backfaceObjects) {
                    Human.scene.setBackfaceObjects({
                        objectIds: self._parseObjectIds(self.backfaceObjects, swap)
                    });
                }

                if (self.objectGlassFactors) {
                    self.restoreObjectGlassFactors = {};
                    vals = self._parseObjectIds(self.objectGlassFactors, swap);
                    for (objectId in vals) {
                        if (vals.hasOwnProperty(objectId)) {
                            object = Human.scene.objects[objectId];
                            if (object) {
                                self.restoreObjectGlassFactors[objectId] = object.glassFactor;
                            }
                        }
                    }
                    Human.scene.setObjectGlassFactors({
                        objectIds: vals
                    });
                }

                if (self.objectMurkiness) {
                    self.restoreObjectMurkiness = {};
                    vals = self._parseObjectIds(self.objectMurkiness, swap);
                    for (objectId in vals) {
                        if (vals.hasOwnProperty(objectId)) {
                            object = Human.scene.objects[objectId];
                            if (object) {
                                self.restoreObjectMurkiness[objectId] = object.murkiness;
                            }
                        }
                    }
                    Human.scene.setObjectMurkiness({
                        objectIds: vals
                    });
                }

                if (self.objectOpacities) {
                    self.restoreObjectOpacities = {};
                    vals = self._parseObjectIds(self.objectOpacities, swap);
                    for (objectId in vals) {
                        if (vals.hasOwnProperty(objectId)) {
                            object = Human.scene.objects[objectId];
                            if (object) {
                                self.restoreObjectOpacities[objectId] = object.glassFactor;
                            }
                        }
                    }
                    Human.scene.setObjectOpacities({
                        objectIds: vals
                    });
                }


                if (self.annotations) {
                    loadAnnotations(self.moduleId, self.annotations);
                }

                // Cross-section plane reset
                Human.view.clip.reset();

                // Viewing mode
                if (self.xray === true) {
                    Human.rpc.call(null, "xray.setEnabled", { enable: true });
                } else {
                    Human.rpc.call(null, "highlight.setEnabled", { enable: true });
                }

                // Select chapter camera behaviour
                Human.timeline.chapterCameras.pathMode = self.chapterCameraPath;

                // Timeline
                if (self.animation) {

                    Human.timeline.play(self.animation);

                } else if (!swap)  {

                    // Set animations and chapters to their initial states
                    // Don't do this when swapping

                    Human.timeline.scrub({
                        time: 0
                    });
                }

                // Annotation layout type
                if (self.annotationsLayout) {
                    Human.properties.set({
                        "annotations.layout.type": self.annotationsLayout
                    });
                }

                if (!swap) {

                    // Camera
                    // Save current camera for restore on module deactivation

                    if (self.camera || self.flyTo || self.jumpTo) {
                        var camera = Human.view.camera;
                        self.restoreCamera = {
                            lookat: camera.getLookAt(),
                            screenPan: camera.getScreenPan()
                        };
                    }

                    if (self.camera) { // DEPRECATED
                        Human.view.camera.fly.flyTo({
                                eye: self.camera.eye,
                                look: self.camera.look,
                                up: self.camera.up,
                                arc: 0.0 // Don't want arcing on initial flyto
                            },
                            ok);

                        if (self.camera.screenPan) {
                            Human.view.camera.setScreenPan(self.camera.screenPan);
                        }

                    } else if (self.flyTo) { // Fly camera to target
                        Human.view.camera.fly.flyTo({
                                eye: self.flyTo.eye,
                                look: self.flyTo.look,
                                up: self.flyTo.up,
                                arc: 0.0 // Don't want arcing on initial flyto
                            },
                            ok);

                    } else if (self.jumpTo) { // Fly camera to target
                        Human.view.camera.fly.jumpTo({
                            eye: self.jumpTo.eye,
                            look: self.jumpTo.look,
                            up: self.jumpTo.up
                        });
                        ok();

                    } else {

                        // No camera

                        Human.renderer.forceRenderFrame();
                        ok();
                    }
                } else {

                    // Suppress camera

                    ok();
                }
            });
    };

    // Returns map of properties that would be overridden by those given,
    // for restoring when module deactivated
    function saveProperties(props) {
        var saved = {};
        for (var propId in props) {
            if (props.hasOwnProperty(propId)) {
                saved[propId] = props[propId];
            }
        }
        return saved;
    }

    function saveEffects() {
        var effects = Human.view.effects.effects;
        var effect;
        var saved = {};
        for (var effectId in effects) {
            if (effects.hasOwnProperty(effectId)) {
                effect = effects[effectId];
                saved[effectId] = effect.enabled ? Human._apply(effect.params, {}) : false;
            }
        }
        return saved;
    }

    function loadAnnotations(moduleId, annotations) {
        var a;
        var newAnnotation;
        for (var i = 0, len = annotations.length; i < len; i++) {
            a = annotations[i];
            newAnnotation = Human.view.annotations.createAnnotation({
                moduleId:moduleId,
                annotationId: a.annotationId,
                type: a.type,
                objectId: a.objectId,
                title: a.title || "",
                description: a.description || "",
                pos: a.offset || a.pos,
                dir: a.pinVec || a.dir,
                shown: a.type === "secondary" ? false : a.shown,
                labelShown: a.type === "secondary" ? false : a.labelShown !== false,
                labelOffset: a.labelOffset,
                saved: true,
                on: a.on, // Behaviours
                embed: a.embed
            });

            // Save any auto-generated IDs
            a.annotationId = newAnnotation.annotationId;
        }
    }

    function unloadAnnotations(annotations) {
        var a;
        var b;
        for (var i = 0, len = annotations.length; i < len; i++) {
            a = annotations[i];
            b = Human.view.annotations.annotations[a.annotationId];
            if (b) {
                b.destroy();
            }
        }
    }

    Content.prototype.deactivate = function () {

        Human.timeline.stop();

        if (this.annotations) {
            unloadAnnotations(this.annotations);
        }

        if (this.modelIds) {
            var modelIds = this.modelIds;
            for (var i = 0, len = modelIds.length; i < len; i++) {
                Human.models.unloadModel(modelIds[i]);
            }
        }

        if (this.restoreReflections) {
            Human.assets.reflections.activateReflections(this.restoreReflections);
            this.restoreReflections = null;
        }

        if (this.restoreProperties) {
            Human.properties.set(this.restoreProperties);
            this.restoreProperties = null;
        }

        if (this.restoreEffects) {
            Human.view.effects.clearEnabled();
            Human.view.effects.setEnabled(this.restoreEffects);
            this.restoreEffects = null;
        }

        if (this.restorePickThroughObjects) {
            Human.scene.setPickThroughObjects({
                objectIds: this.restorePickThroughObjects,
                replace: false
            });
            this.restorePickThroughObjects = null;
        }

        if (this.restoreObjectGlassFactors) {
            Human.scene.setObjectGlassFactors({
                objectIds: this.restoreObjectGlassFactors
            });
            this.restoreObjectGlassFactors = null;
        }

        if (this.restoreObjectOpacities) {
            Human.scene.setObjectOpacities({
                objectIds: this.restoreObjectOpacities
            });
            this.restoreObjectOpacities = null;
        }

        if (this.restoreCamera) {

            var camera = Human.view.camera;

            camera.setLookAt(this.restoreCamera.lookat);
            camera.setScreenPan(this.restoreCamera.screenPan);

            this.restoreCamera = null;
        }
    };

    // Loads models in synchronous sequence. Each model may have things like
    // animations that reference objects loaded by the models preceding it.
    Content.prototype._loadModels = function (modelIds, ok) {
        if (modelIds.length > 0) {
            var modelId = modelIds.shift();
            var modelArgs = {
                moduleId: this.moduleId,
                modelId: modelId
            };
            if (this.streamObjects) {
                modelArgs.streamObjects = this.streamObjects;
            }
            var self = this;
            Human.models.loadModel(
                modelArgs,
                function () {
                    self._loadModels(modelIds, ok);
                },
                function (errMsg) {
                    Human.log.error("Human.modules.activate", "Failed to activate module: Failed to load model '" + modelId + "': " + errMsg);
                    self._loadModels(modelIds, ok);
                });
        } else {
            ok();
        }
    };

    /**
     * Given a map of booleans for object IDs, if the map has a "*" entry, then insert
     * a "true" for the ID of each object that was loaded by this module.
     *
     * When in swapping mode, strip out entries for objects that are not within those
     * that were loaded by this module.
     */
    Content.prototype._parseObjectIds = function (objectIds, swap) {
        var objectId;

        if (!objectIds) {
            return {};
        }

        if (swap) {

            // Swap mode; 
            // discard flags for objects not loaded by this module

            var temp = {};

            for (objectId in objectIds) {
                if (objectIds.hasOwnProperty(objectId)) {
                    if (this._hasObject(objectId)) {
                        temp[objectId] = objectIds[objectId];
                    }
                }
            }

            if (objectIds["*"] !== undefined && objectIds["*"] !== null) {
                temp["*"] = objectIds["*"];
            }

            objectIds = temp;
        }

        var wildcard = objectIds["*"];

        if (wildcard === undefined || wildcard === null) {
            return objectIds;
        }

        // Expand wildcard into flags for object IDs

        var modelIds = this.modelIds;

        if (modelIds) {
            for (var i = 0, len = modelIds.length; i < len; i++) {
                var objects = Human.scene.modelObjects[modelIds[i]];
                for (objectId in objects) {
                    if (objects.hasOwnProperty(objectId)) {
                        objectIds[objectId] = wildcard;
                    }
                }
            }
        }

        return objectIds;
    };

    /**
     * Returns true if the given scene object ID matches one
     * of the objects loaded by this module
     */
    Content.prototype._hasObject = function (objectId) {

        var modelIds = this.modelIds;

        if (!modelIds) {

            // Not loading any objects, so cannot own the given object
            return false;
        }

        for (var i = 0, len = this.modelIds.length; i < len; i++) {
            if (objectId.indexOf(this.modelIds[i]) === 0) {
                return true;
            }
        }

        return false;
    };

    Human.modules.addModuleType("content", Content);

})();;/**
 * @namespace Module that exhibits scene objects
 *
 * </pre>
 */

(function () {
    "use strict";

    function ObjectExpo(cfg) {

        // Metadata
        this.moduleId = cfg.moduleId;
        this.displayName = cfg.displayName || "";
        this.description = cfg.description || "";
        this.tags = cfg.tags || [];
        this.active = false;

        // Specific to this module type
        this.spinRate = cfg.spinRate || 0.02;
        this.delay = cfg.delay || 5.0;
        this.mode = cfg.mode || "visible";
        this.objects = cfg.objects;

        this.active = false;
    }

    ObjectExpo.prototype.activate = function (options, ok) {

        //this._reset = Human.bookmarks.capture();

        var delay = this.delay * 1000; // Secs to millis
        var list = [];
        var object, objects, objectId;

        switch (this.mode) {

            // Expo whatever objects are currently visible
            case "visible":
                objects = Human.scene.enabledObjects;
                for (objectId in objects) {
                    if (objects.hasOwnProperty(objectId)) {
                        object = objects[objectId];
                        if (object.objects.length === 0) {
                            list.push(object);
                        }
                    }
                }
                break;

            // Expo the given object objects
            case "objects":
                objects = Human.scene.rootObjects;
                for (objectId in objects) {
                    if (objects.hasOwnProperty(objectId)) {
                        this._listObjects(objects[objectId], list);
                    }
                }
                break;

            default:
                Human.log.error("ObjectExpo", "Mode not supported: " + this.mode);
        }

        Human.rpc.call(null, "xray.setEnabled", { enable: true });

        var lastTime;
        var lastFocusTime;
        var self = this;

        Human.events.on("tick",
            this._tick = function () {
                var time = (new Date()).getTime();
                var elapsed = (time - (lastTime === undefined || lastTime === null ? time : lastTime));
                var elapsedFocus = (time - (lastFocusTime === undefined || lastFocusTime === null ? time : lastFocusTime));

                Human.view.camera.rotateY(elapsed * self.spinRate);

                if (lastFocusTime === undefined || lastFocusTime === null || elapsedFocus > delay) {
                    var object = list[Math.round(Math.random() * list.length)];
                    if (object) {

//                        Human.view.annotations.placer.placeAnnotation({
//                            objectId: object.objectId,
//                            pos: object.getCenter(),
//                            title: object.objectId,
//                            description: "hggggghj  ghhjg jhgggjhhg",
//                            saved: true
//                        });

                        Human.view.focus.focusObject({
                            objectId: object.objectId,
                            showLabel: true,
                            replace: true
                        });
                        lastFocusTime = time;
                    }
                }

                lastTime = time;
            });

        ok();
    };

    ObjectExpo.prototype._listObjects = function (object, list) {
        var objects = object.objects;
        var childObject;
        for (var i = 0, len = objects.length; i < len; i++) {
            childObject = objects[i];
            if (this.objects) {
                if (this._selectedObject(this.objects, childObject)) {
                    list.push(childObject);
                }
            } else {
                list.push(childObject);
            }
            this._listObjects(childObject, list);
        }
    };

    ObjectExpo.prototype._selectedObject = function (objects, object) {
        var flag;
        for (var o = object; o !== undefined && o !== null; o = o.parent) {
            flag = objects[o.objectId];
            if (flag === true) {
                return true;
            } else if (flag === false) {
                return false;
            }
        }
        return false;
    };

    /**
     * Deactivates an ObjectExpo module
     *
     * This is called by {@link Human.modules} when we fire a "Modules.Dectivate"
     * command for this module type
     */
    ObjectExpo.prototype.deactivate = function () {
        Human.events.off("tick", this._tick);
        this.active = false;
    };

    Human.modules.addModuleType("objectExpo", ObjectExpo);
})();
;/**
 * @namespace Module that exhibits other modules
 *
 * </pre>
 */

(function () {
    "use strict";

    function ModuleExpo(cfg) {

        // Metadata
        this.moduleId = cfg.moduleId;
        this.displayName = cfg.displayName || "";
        this.description = cfg.description || "";
        this.tags = cfg.tags || [];
        this.active = false;

        // Specific to this module type
        this.delay = cfg.delay || 10000;
        this.expoModules = cfg.expoModules;
    }

    /**
     * Activates this module
     * @param {function} ok Called when activated
     */
    ModuleExpo.prototype.activate = function (options, ok) {

        var modules = Human.modules.query(this.expoModules);
        var i = 0;
        var self = this;

        if (modules.length > 0) {
            nextModule();
        } else {
            Human.log.warn("moduleExpo", "No modules found");
        }

        function nextModule() {
            var module = modules[i++ % modules.length];
            Human.modules.activateModules({ moduleId: module.moduleId },
                function () {
                    if (self.active) {
                        setTimeout(nextModule, self.delay);
                    }
                });
        }

        ok();
    };

    /**
     * Deactivates this module
     */
    ModuleExpo.prototype.deactivate = function () {
        // Not sure what to do here
    };

    Human.modules.addModuleType("moduleExpo", ModuleExpo);
})();
;(function () {
    "use strict";

    function Bookmark(cfg) {

        // Metadata
        this.moduleId = cfg.moduleId;
        this.displayName = cfg.displayName || "";
        this.description = cfg.description || "";
        this.tags = cfg.tags || [];
        this.active = false;

        // Specific to this module type
        this.category = cfg.category;
        this.bookmarkId = cfg.bookmarkId;
    }

    Bookmark.prototype.activate = function (ok, options, error) {
        Human.log.info("Human.modules", "Activating bookmark: " + this.bookmarkId);
        // Fetch the bookmark index from DB
        Human.bookmarks.db.loadBookmark(this.category, this.bookmarkId,
            ok,
            function (errMsg) {
                error("[Human.modules] Failed to load bookmark: " + errMsg);
            });

        ok();
    };

    Bookmark.prototype.deactivate = function () {
        Human.log.info("Human.modules", "Deactivating bookmark: " + this.bookmarkId);
    };

    Human.modules.addModuleType("bookmark", Bookmark);

})();
;/**
 * @namespace Module that explodes the set of currently visible scene objects
 *
 */

(function () {
    "use strict";

    function Explode(cfg) {

        // Metadata
        this.moduleId = cfg.moduleId;
        this.displayName = cfg.displayName || "Exploded view";
        this.description = cfg.description || "Exploded view";
        this.tags = cfg.tags || [];
        this.active = false;
        this.distance = cfg.distance || 20.0;
        this.objects = cfg.objects;
        this.factor = 0.0;
        this.dir = 1.0;
    }

    Explode.prototype.activate = function (options, ok) {

        // Get list of leaf objects to update
        // Also find their centers
        var list = [];
        var objects = Human.scene.enabledObjects;
        var object;
        var center = [0, 0, 0];
        var objectCenter;

        for (var objectId in objects) {
            if (objects.hasOwnProperty(objectId)) {

                object = objects[objectId];

                if (object.objects.length === 0) {
                    objectCenter = object.getCenter();
                    list.push({
                        pos: objectCenter,
                        pos2: null,
                        dir: Human.math.vec3(),
                        object: object
                    });
                    center[0] += objectCenter[0];
                    center[1] += objectCenter[1];
                    center[2] += objectCenter[2];
                }
            }
        }
        center[0] /= list.length;
        center[1] /= list.length;
        center[2] /= list.length;

        // Get movement vectors for objects
        for (var i = 0, len = list.length; i < len; i++) {
            var entry = list[i];
            var pos = entry.pos;
            Human.math.subVec3(pos, center, entry.dir);
            //entry.vec = Human.math.normalizeVec3(entry.dir);
        }

        var lastTime;
        var self = this;

        Human.events.on("tick",
            this._tick = function () {

                if (self.factor > 1.0) {
                    self.factor = 1.0;
                    self.dir = 0.0;
                    return;
                }

                if (self.factor < 0.0) {
                    self.factor = 0.0;
                    self.dir = 0.0;
                    return;
                }

                var time = (new Date()).getTime();

                // Animate objects on paths
                for (var i = 0, len = list.length; i < len; i++) {
                    var entry = list[i];
                    var pos = Human.math.addVec3(entry.pos, Human.math.mulVec3Scalar(entry.dir, self.factor));
                    entry.object.setTransform({
                        translate: {x: pos[0], y: pos[1], z: pos[2]}
                    });
                }

                self.factor += (0.01 * self.dir);

                lastTime = time;
            });

        this.factor = 0;
        this.dir = 1.0;

        ok();
    };

    /**
     * Deactivates an Explode module
     */
    Explode.prototype.deactivate = function () {
        Human.events.off("tick", this._tick);
        this.active = false;
    };

    Human.modules.addModuleType("explode", Explode);
})();
;(function() {
    "use strict";

    
    Human.rpc.define("modules.getModules",
        function (params) {
            this.setResult(Human.modules.query(params));
        });

    Human.rpc.define("modules.activate",
        function (params) {
            var self = this;
            Human.modules.activateModules(params,
                function () {
                    self.setResult(true); // Activated
                });
        });

    Human.rpc.define("modules.deactivate",
        function (params) {
            Human.modules.deactivateModules(params);
        });
})();;/**
 *  @namespace Manages network sockets to which remote clients can attach.
 */
(function () {
    "use strict";

    var HumanClients = Human.clients = {};

    /**
     * Number of remote clients connected to this engine
     * @type {number}
     */
    HumanClients.numConnections = 0;

    /**
     * Registers a client type
     * @param clazz
     */
    HumanClients.addClient = function (clientFn) {
        clientFn({
            connected: function () {
                HumanClients.numConnections++;
                Human.events.fire("clients.connected", {});
            },
            disconnected: function () {
                HumanClients.numConnections--;
                Human.events.fire("clients.disconnected", {});
            }
        });
    };

})();
;/**
 WebSocket messaging server
 */

(function () {
    "use strict";

    // Get socket server configs off URL.

    // Can't get these via Human.properties, because the socket connection must start up
    // as soon as Human fires a "loaded" event, which happens before any of the init scripts
    // execute, which is the earliest opportunity that we have for setting engine properties.

    // Socket needs to be started on "loaded" so that API can immediately send across calls
    // to do things like set canvas background color etc.

    // Only enable this code module if URL contains "socketEnabled=true".

    var socketEnabled = Human.request.getSearchParam("socketEnabled") === "true";

    if (!socketEnabled) {
        Human.log.info("Human.clients.webSocketClient", "WebSocket enabled: NO - socketEnabled=true was not found on URL.");
        return;
    }

    Human.log.info("Human.clients.webSocketClient", "WebSocket enabled: YES - socketEnabled=true was found on URL.");

    var socketServerURL = Human.request.getSearchParam("socketURL") || "https://api.biodigitalhuman.com";
    var socketServerPort = Human.request.getSearchParam("socketPort") || 443;
    var socketServerChannel = Human.request.getSearchParam("socketChannel") || "human";

    var socket = null;              // The WebSocket
    var countProcesses = 0;         // Human busy when > 0
    var requestQueue = [];          // Buffers incoming requests while countProcesses > 0
    var requestQueuePumpInterval;   // Interval pumps request queue

    var connected = false;
    var error = null;
    var ready = false;

    // Relay all engine errors back to the client

    Human.onError(
        function (e) {
            if (connected) {
                sendResponse({ error: e });
            }
            error = e;
        });

    Human.events.on("started",
        function () {
            if (connected) {
                sendResponse({ message: "ready" });
            }
            ready = true;
        });

    Human.events.on("loaded",
        function () {

            // Engine loaded

            Human.clients.numConnections++;
            Human.events.fire("clients.connected", {});

            Human.log.info("Human.clients.webSocketClient", "WebSocket server enabled.");

            // Load Socket.IO library

            Human.log.info("Human.clients.webSocketClient", "Loading Socket.IO Library...");

            loadSocketIO(function (io) {

                Human.log.info("Human.clients.webSocketClient", "Socket.IO library loaded.");

                // Start the socket server

                // Buffer incoming RPC calls whenever engine is busy doing some internal task.
                // We'll assume that whatever the engine's doing will take priority over client requests.

                Human.events.on("processes.started",
                    function () {
                        countProcesses++;
                    });

                Human.events.on("processes.finished",
                    function () {
                        if (countProcesses > 0) {
                            countProcesses--;
                        }
                    });

                Human.events.on("processes.failed",
                    function () {
                        countProcesses--;
                    });

                // Relay results of all engine RPC calls back to client

                Human.rpc.onResult(
                    function (key, value) {
                        var results = {};
                        results[key] = value;
                        sendResponse({ results: results });
                    });


                // Connect server to socket

                try {

                    socket = io.connect(socketServerURL + ":" + socketServerPort);

                    var socketConnected = false;

                    socket.on('connect',
                        function () {

                            // Server connected to socket

                            if (socketConnected) {
                                return;
                            }

                            socketConnected = true;

                            Human.log.info("Human.clients.webSocketClient", "Connected.");
                            Human.log.info("Human.clients.webSocketClient", "Subscribing");

                            // Subscribe server to channel

                            socket.emit('subscribe', socketServerChannel);
                        });

                    socket.on('status',
                        function (status) {
                              Human.log.info("[client " + socketServerURL + "] received status:" + status);
                        });

                    socket.on('message',
                        function (message) {

                            // Handle message from client

                            Human.log.info("Human.clients.webSocketClient", JSON.stringify(message));

                            if (message.action === "connect") {

                                // Client requests connection

                                Human.log.info("Human.clients.webSocketClient", "Client connected");

                                // Accept connection

                                socket.emit('sendreply', socketServerChannel, { message: "connected" });

                                // Then send any buffered notification of error or readiness

                                if (error) {
                                    socket.emit('sendreply', socketServerChannel, { message: "error", error: error });

                                } else if (ready) {
                                    socket.emit('sendreply', socketServerChannel, { message: "ready" });
                                }

                            } else if (message.call) {

                                // Client makes an RPC call

                                handleCall(message);
                            }
                        });

                } catch (e) {
                    Human.log.error("Human.clients.webSocketClient#start", "Error initializing socket: " + e);
                }
            });
        });


    function loadSocketIO(ok) {
        var socketIOLibraryURL = socketServerURL + ":" + socketServerPort + "/socket.io/socket.io.js";
        Human.log.info("[Socket] Loading Socket.IO library from " + socketIOLibraryURL);
        require([socketIOLibraryURL], function (io) {
            ok(io);
        });
        /*
        var el = document.createElement('script');
        el.type = 'text/javascript';
        el.src = socketIOLibraryURL;
        el.onload = function () {
            ok();
        };
        document.body.appendChild(el);
        */
    }

    function sendResponse(message) {
        try {
            socket.emit('sendreply', socketServerChannel, message);
        } catch (e) {
            Human.log.error("Human.clients.webSocketClient#sendResponse", "Error sending response: " + e);
        }
    }

    function handleCall(message) {

        var procName = message.call;

        // Execute camera commands immediately to avoid queue lag

        if (procName === "camera.pan" ||
            procName === "camera.orbit" ||
            procName === "camera.flyTo" ||
            procName === "camera.jumpTo" ||
            procName === "camera.zoom" ||
            procName === "camera.getZoom" ||

            // Allow procedures marked with connected param to execute immediately (they are not related to the Human)

            (message.params && message.params.connected)) {

            executeCall(message);

            return;
        }

        if (countProcesses === 0) {      // Execute immediately if Human not busy

            // Human not busy, execute call

            executeCall(message);

        } else {

            // Human busy, buffer the call

            requestQueue.push(message);

            if (!requestQueuePumpInterval) {

                // Start call queue pump if not already running

                requestQueuePumpInterval = setInterval(
                    function () {

                        if (requestQueue.length > 0 && countProcesses === 0) {
                            executeCall(requestQueue.shift());
                        }

                        if (requestQueue.length === 0) {

                            // Stop pump when queue empty

                            clearInterval(requestQueuePumpInterval);
                            requestQueuePumpInterval = null;
                        }
                    }, 20);
            }
        }
    }

    function executeCall(message) {
        try {
            Human.rpc.call(message.id, message.call, message.params);
        } catch (e) {
            Human.log.error("Human.clients.webSocketClient", "Error executing RPC call [callId: " + message.id + ", procedure: " + message.call + "]: " + e);
        }
    }
})();
;/**
 Window messaging

 */
Human.clients.addClient(
    function (cfg) {
        "use strict";

        var client;
        var clientOrigin;
        var responseQueue = [];
        var rpcQueue = [];
        var countProcesses = 0; // Stalls rpcQueue when > 0
        var pQueueInterval;

        Human.events.on("started",
            function () {
                sendResponse({ message: "status", status: "ready" });
            });

        Human.events.on("processes.started",
            function () {
                countProcesses++;
            });

        Human.events.on("processes.finished",
            function () {
                countProcesses--;
                if (countProcesses < 0) {
                    countProcesses = 0;
                    Human.log.warn("Human.clients.windowClient", "Extra Process.Finished event caught");
                }
            });

        Human.events.on("processes.failed",
            function () {
                countProcesses--;
            });

        if (window.addEventListener) {

            // Relay errors back to client
            Human.onError(
                function (error) {
                    sendResponse({ error: error });
                });

            // Relay any RPC procedure call results back to client
            Human.rpc.onResult(
                function (key, value) {
                    var results = {};
                    results[key] = value;
                    sendResponse({ results: results });
                });

            // Handle messages from client
            addEventListener("message",
                function (event) {
                    var msg;
                    try {
                        msg = JSON.parse(event.data);
                    } catch (e) {
                        Human.log.error("Human.clients.windowClient", "JSON parse failed on an incoming Web message: " + e.message || e);
                        return;
                    }
                    if (msg.action === "connect") {
                        // Connection request
                        if (!client) {
                            Human.log.info("Human.clients.windowClient", "Client connected");
                            cfg.connected();
                            client = event.source;
                            clientOrigin = event.origin;
                            sendResponse({ message: "connected" });
                            flushResponseQueue();
                        }
                    } else {
                        // RPC call
                        if (msg.call) {
                            handleCall(msg);
                        }
                    }
                }, false);
        } else {
            Human.log.error("Human.clients.windowClient", "Browser does not support cross-window messaging");
        }

        function sendResponse(json) {
            var message = JSON.stringify(json);
            if (!client) {
                responseQueue.push(message);
                return;
            }
            client.postMessage(message, clientOrigin);
        }

        function flushResponseQueue() {
            while (responseQueue.length > 0) {
                client.postMessage(responseQueue.pop(), clientOrigin);
            }
        }

        function handleCall(msg) {
            var procName = msg.call;
            // Execute camera commands immediately to avoid queue lag
            if (procName === "camera.pan" ||
                procName === "camera.orbit" ||
                procName === "camera.flyTo" ||
                procName === "camera.jumpTo" ||
                procName === "camera.zoom" ||
                //allow procedures marked with connected param to execute immediately (they are not related to the Human)
                (msg.params && msg.params.connected)) {
                executeCall(msg);
                return;
            }
            if (countProcesses === 0) {      // Execute immediately if Human not busy
                executeCall(msg);
            } else {
                rpcQueue.push(msg);        // Else enqueue
                if (!pQueueInterval) {
                    pQueueInterval = setInterval(
                        function () {
                            if (rpcQueue.length > 0 && countProcesses === 0) {
                                executeCall(rpcQueue.shift());
                            }
                            if (rpcQueue.length === 0) {
                                clearInterval(pQueueInterval);
                            }
                        }, 20);
                }
            }
        }

        function executeCall(msg) {
            try {
                Human.rpc.call(msg.id, msg.call, msg.params);
            } catch (e) {
                Human.log.error("Human.clients.windowClient", "Error executing RPC call [callId: " + msg.id + ", procedure: " + msg.call + "]: " + e);
            }

        }

    });


;
(function () {
    "use strict";

    var HumanActions = Human.actions = {};
    
    HumanActions._actions = {};

    Human.events.on("loaded",
        function () {

            // Alternative entry point for Human.actions._doAction via data-human-action attribute

            $(document).on('click', '[data-human-action]', function () {
                var $el = $(this);
                var action = $el.attr('data-human-action');
                var args = $el.attr('data-arguments');

                if (action) {
                    HumanActions._doAction([action, args]);
                }
            });
        });
    
    /** Registers an action handler.
     *
     * @param actionId
     * @param callback
     */
    HumanActions.addAction = function (actionId, callback) {
        HumanActions._actions[actionId] = callback;
    };

    /** Fires an action handler
     *
     * @param actionStr
     * @private
     */
    HumanActions._doAction = function (data) {
        var tokens;
        
        if(typeof data === 'string') {
            tokens = data.split("?");
            
            if (tokens.length === 0) {
                Human.log.error("Human.actions._parse", "Parsed invalid action link: " + data + "(ignoring)");
                return;
            }
        } else {
            tokens = data;
        }

        var actionId = tokens[0];

        var action = HumanActions._actions[actionId];

        if (!action) {
            Human.log.error("Human.actions._doAction", "Parsed invalid action link - action not found: " + actionId + " (ignoring)");
            return;
        }

        var actionParams = {};

        // Parse params
        var p = tokens[1];
        if (p) {
            var keyVals = p.split("&");
            var keyVal;
            for (var i = 0, len = keyVals.length; i < len; i++) {
                keyVal = keyVals[i].split("=");
                actionParams[keyVal[0]] = keyVal[1];
            }
        }

        // When action callbacks fail, they can just throw exceptions rather than go to the trouble
        // of logging and recovering. Then we can nicely log those in context of the action and recover.
        try {
            action(actionParams);
        } catch (e) {
            Human.log.error("Human.actions._doAction", "Action '" + actionId + "' threw an exception: " + e);
        }
    };

    /** Parses markdown into HREFs that fire action handlers that were registered with {@link #addAction}.
     *
     * @param markdown
     * @returns {*}
     */
    HumanActions.parse = function (markdown) {
        return markdown.replace(/\[\[([^|]*?)\|(.*?)\]\]/g, '<a href="javascript:Human.actions._doAction(\'$1\')">$2</a>');
    };

})();;(function() {
	"use strict";

	Human.rpc.define("actions.doAction",
	    function (params) {
	        Human.actions._doAction([params.action, params.arguments]);
	    });

})();


    